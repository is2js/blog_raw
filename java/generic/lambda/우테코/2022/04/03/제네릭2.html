<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>generic 개인공부 2 | 돌범텤놑</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="generic 개인공부 2" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="generic + lambda + intersectionType" />
<meta property="og:description" content="generic + lambda + intersectionType" />
<link rel="canonical" href="blog.chojaeseong.com/java/generic/lambda/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/03/%EC%A0%9C%EB%84%A4%EB%A6%AD2.html" />
<meta property="og:url" content="blog.chojaeseong.com/java/generic/lambda/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/03/%EC%A0%9C%EB%84%A4%EB%A6%AD2.html" />
<meta property="og:site_name" content="돌범텤놑" />
<meta property="og:image" content="blog.chojaeseong.com/images/posts/java.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-04-03T00:00:00-05:00" />
<script type="application/ld+json">
{"datePublished":"2022-04-03T00:00:00-05:00","url":"blog.chojaeseong.com/java/generic/lambda/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/03/%EC%A0%9C%EB%84%A4%EB%A6%AD2.html","@type":"BlogPosting","image":"blog.chojaeseong.com/images/posts/java.png","headline":"generic 개인공부 2","dateModified":"2022-04-03T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"blog.chojaeseong.com/java/generic/lambda/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/03/%EC%A0%9C%EB%84%A4%EB%A6%AD2.html"},"description":"generic + lambda + intersectionType","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<!-- 폰트추가를 위한 link태그 삽입 -->
  <!-- 폰트1:  기본 spoqa 웹폰트 -->
  <!-- css에서 * {} 다 뒤집어씀. -->
  <link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSansNeo.css' rel='stylesheet' type='text/css'>
  <!-- 폰트2:  블로그 제목들 sunflower 웹폰트 -->
  <!-- 쥬피터 등 포스트 내부 글자 h1, h2 제목은 sunflower체 도입 -->
  <link href="//fonts.googleapis.com/css?family=Sunflower:300,500,700" rel="stylesheet"> 

  <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="blog.chojaeseong.com/feed.xml" title="돌범텤놑" /><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">돌범텤놑</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About Me</a><a class="page-link" href="/search/">Search</a><a class="page-link" href="/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">generic 개인공부 2</h1><p class="page-description">generic + lambda + intersectionType</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-04-03T00:00:00-05:00" itemprop="datePublished">
        Apr 3, 2022
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      49 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/categories/#java">java</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#generic">generic</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#lambda">lambda</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#우테코">우테코</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <!-- toc가 먼저 나오므로 h3로 안내하기 -->
    <h3>📜 제목으로 보기</h3>
    <ul class="section-nav">
<li class="toc-entry toc-h3"><a href="#개념">개념</a>
<ul>
<li class="toc-entry toc-h4"><a href="#제네릭과-raw-type">제네릭과 raw type</a></li>
<li class="toc-entry toc-h4"><a href="#제네릭-메서드">제네릭 메서드</a></li>
<li class="toc-entry toc-h4"><a href="#제네릭과-상속">제네릭과 상속</a></li>
<li class="toc-entry toc-h4"><a href="#제네릭-타입-추론">제네릭 타입 추론</a></li>
<li class="toc-entry toc-h4"><a href="#제네릭과-와일드카드">제네릭과 와일드카드</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#심화">심화</a>
<ul>
<li class="toc-entry toc-h4"><a href="#type-paramter를-필요로-하는-제네릭-메서드의-파라미터list-에-대해-type-paramter-적용-vs-wildcards-적용">type paramter를 필요로 하는, 제네릭 메서드의 파라미터(List&lt; &gt;)에 대해 Type Paramter 적용 vs WildCards 적용</a>
<ul>
<li class="toc-entry toc-h5"><a href="#type-paramter-적용">Type Paramter 적용</a></li>
<li class="toc-entry toc-h5"><a href="#unbounded-wildcards-적용">unbounded WildCards 적용</a></li>
<li class="toc-entry toc-h5"><a href="#bounded-wildcards-적용">bounded WildCards 적용</a></li>
<li class="toc-entry toc-h5"><a href="#wild-card로-정의-가능하다면-지네릭-메소드-대신-와일드카드로-메서드-작성하는-이유">wild card로 정의 가능하다면 지네릭 메소드 대신 와일드카드로 메서드 작성하는 이유</a></li>
<li class="toc-entry toc-h5"><a href="#와일드카드를-사용한-상태에서-비교를-위한-compareto-사용을-위해-bound-wild-card인-----extends-comparable은-허용한다-하지만-메서드-내부에-t를-이용하느-코드가-나온다면-응답형-앞에-t를-t-extends-comparable로-바꿔주면-된다">와일드카드를 사용한 상태에서 비교를 위한 compareTo 사용을 위해 bound wild card인   &lt; ? extends Comparable&gt;은 허용한다. 하지만 메서드 내부에 T를 이용하느 코드가 나온다면, 응답형 앞에 T를 &lt;T extends Comparable&gt;로 바꿔주면 된다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#pecs는-사실-메서드내부-사용되는-t는-e--메서드외부에서-사용되는-t는-s-이다">PECS는 사실… 메서드내부 사용되는 T는 E / 메서드외부에서 사용되는 T는 S 이다.</a></li>
<li class="toc-entry toc-h4"><a href="#와일드카드-사용시-캡처-문제">와일드카드 사용시 캡처 문제</a>
<ul>
<li class="toc-entry toc-h5"><a href="#다시-지네릭메서드로-돌아가도-되지만-자바-설계상-헬퍼메서드를-만들어준다">다시 지네릭메서드로 돌아가도 되지만, 자바 설계상 헬퍼메서드를 만들어준다</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#lambda">Lambda</a>
<ul>
<li class="toc-entry toc-h5"><a href="#람다식-구현-이전-익명클래스로-구현">람다식 구현 이전, 익명클래스로 구현</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#intersectiontype-기본">IntersectionType 기본</a></li>
<li class="toc-entry toc-h4"><a href="#intersectiontype으로-marker-interface의-default-method을-합친-익명-객체-만들어보기제한점-존재">IntersectionType으로 marker interface의 default method을 합친 익명 객체 만들어보기(제한점 존재)</a></li>
<li class="toc-entry toc-h4"><a href="#consumer파라미터-추가를-통한-콜백형식으로-intersectiontype에-기능-하나씩-확장하기제한점-존재">Consumer파라미터 추가를 통한, 콜백형식으로 IntersectionType에 기능 하나씩 확장하기(제한점 존재)</a></li>
<li class="toc-entry toc-h4"><a href="#람다식구현-인자용-함수형인페t를-상속한-인터페이스로-default-method내부에서-변경가능한-람다식에-따른-기능-수행하는-메서드가-된다">람다식구현 인자용 함수형인페&lt;T&gt;를 상속한 인터페이스로, default method내부에서 변경가능한 람다식에 따른 기능 수행하는 메서드가 된다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#새로운-아이디어와-최종-예제">새로운 아이디어와 최종 예제</a>
<ul>
<li class="toc-entry toc-h4"><a href="#기존-구현class-후-구현체-인자-대신-람다식-구현--인자---함수형인페-파라미터-구현체추클호출-대신-정해진메서드호출하여-내부context로-실행---제네릭-메서드로-변환하되-함수형인페를-t상한으로---여러type-동시구현을-상한경계-대신-람다식-캐스팅--consumer로-밖으로-빼기">기존: (구현class 후 구현체 인자 대신) 람다식 구현  인자 -&gt; 함수형인페 파라미터 (구현체.추클()호출 대신 정해진메서드()호출하여 내부context로 실행) -&gt; 제네릭 메서드로 변환하되 함수형인페를 T상한으로 -&gt; 여러Type 동시구현을 상한경계 대신 람다식 캐스팅 + Consumer로 밖으로 빼기</a></li>
<li class="toc-entry toc-h4"><a href="#현재-일반-인터페이스메서드-2개이상-의-기능-다-가지면서--새로운-기능을-람다식-캐스팅-했던-것처럼-동적으로-추가하고-싶다">현재: 일반 인터페이스(메서드 2개이상) 의 기능 다 가지면서 + 새로운 기능을 람다식 캐스팅 했던 것처럼 동적으로 추가하고 싶다</a></li>
<li class="toc-entry toc-h4"><a href="#더이상-수정할-수-없는-라이브러리에-기능추가">더이상 수정할 수 없는 라이브러리에 기능추가</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#제네릭-기본-적용-예시-모음">제네릭 기본 적용 예시 모음</a></li>
</ul><ul>
  <li><a href="https://www.youtube.com/watch?v=ipT2XG1SHtQ&amp;list=PLv-xDnFD-nnmof-yoZQN8Fs2kVljIuFyC&amp;index=12">참고 유튜브</a></li>
</ul>

<h3 id="개념">
<a class="anchor" href="#%EA%B0%9C%EB%85%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>개념</h3>

<ul>
  <li>모던 자바(5이후) 가장 대표적인 기술 2가지
    <ul>
      <li><strong>제네릭</strong></li>
      <li>
<strong>람다</strong>
        <ul>
          <li>하나 더 추가한다면, 애노테이션</li>
          <li>
<strong>애노테이션</strong>은 프레임워크 개발자, 라이브러리 개발자들이나 만들 것. <strong>우리가 만들 일은 없다.</strong>
</li>
        </ul>
      </li>
      <li>코드 작성시 가장 많이 만지는 것
        <ul>
          <li>제네릭과 람다</li>
          <li>잘 활용해야한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="제네릭과-raw-type">
<a class="anchor" href="#%EC%A0%9C%EB%84%A4%EB%A6%AD%EA%B3%BC-raw-type" aria-hidden="true"><span class="octicon octicon-link"></span></a>제네릭과 raw type</h4>

<ul>
  <li>제네릭 -&gt; 사실 <code class="language-plaintext highlighter-rouge">타입 파라미터</code>를 사용하면 제네릭이다~!</li>
  <li>제네릭 사용이유
    <ol>
      <li>.add() : <strong>컴파일 시점에서</strong>, 컴파일에게 타입을 건네주어, <strong>데이터 일관성 있게 모을 때</strong>, 정확하게 <strong>타입체킹</strong>한다.
        <ul>
          <li>타입정보를 안주면, List는 T자리에는 Object로 대체하여, 컴파일러가 타입체크를 못해준다.
            <ul>
              <li>컴파일러가 몰랐기 때문에, compile에러 대신 <strong>runtime시 에러가 난다</strong>.</li>
              <li><strong>즉, runtime시에만 발생하는 버그(모은 데이터가 일광성이 없는 버그)를 미리 방지한다.</strong></li>
            </ul>
          </li>
          <li>해당 list에는 어떤 타입만 들어갈지 정해서, 일관성있게 코드를 작성해야하는데, 이런 부분을 도와준다.
            <ul>
              <li>intellij 빨간줄 -&gt; compile에러 by 제네릭</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>.get():  <code class="language-plaintext highlighter-rouge">1번에서 일관성 없게 모은 Object타입의 list</code>라면? <strong>꺼내서 사용할 때, 매번 다운캐스팅해야한다. 실수 할 수도 있음.</strong>
        <ul>
          <li><strong>제네릭은 적절한 타입캐스팅(다운캐스팅)을 알아서 해준다.</strong></li>
        </ul>
      </li>
      <li>
<strong>똑같은 코드 Type만 다른 class를 또 생성할 필요 없다</strong>
        <ul>
          <li>Type만 바꾼 <strong>class재사용</strong>이 가능해진다.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>raw Type
    <ul>
      <li>좁은 것을 타입 파라미터 없는 raw Type <code class="language-plaintext highlighter-rouge">List</code>에 할당해주는 것은 가능하지만
        <ul>
          <li>그 순간부터 가지고 있던 내용물의 Type을 잃어먹는다.</li>
        </ul>
      </li>
      <li>다시 좁은 쪽으로 할당시키면, 일단 해당 타입 파라미터에 맞게 할당은 되지만
        <ul>
          <li>꺼내는 순간부터 가지고 있던 내용물 Type &lt;-&gt; 타입파라미터 타입이 달라 에러가 난다.</li>
        </ul>
      </li>
      <li>
<strong>raw Type을 쓰지마라.</strong>
        <ul>
          <li>
<strong>더불어, 컴파일시 <code class="language-plaintext highlighter-rouge">Problems</code>에 뜨는 워닝을 그냥 넘어가지마라.</strong>
            <ul>
              <li><strong>워닝을 체크하고  Build &gt; <code class="language-plaintext highlighter-rouge">Rebuild Project</code>로 해결하면서 확인하자.</strong></li>
              <li><strong>상세하게 워닝을 보는 방법은 <code class="language-plaintext highlighter-rouge">설정 &gt; java compiler &gt; 추가 파라미터</code> -&gt; 에러창에 나온 <code class="language-plaintext highlighter-rouge">-Xlint</code>등을 붙혀서 다시 컴파일한다.</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>raw Type으로 중간에 넣어도 컴파일 에러가 안나는 이유</strong></p>

    <ul>
      <li>
        <p>java 5 제네릭 이전의 코드는 모두 <code class="language-plaintext highlighter-rouge">raw Type List</code>이었기 때문에</p>

        <ul>
          <li>
            <p>개발자가 체크하고, 변환해서 사용해야한다.</p>
          </li>
          <li>
            <p>개발자가 <code class="language-plaintext highlighter-rouge">raw Type List</code>를 좁은 곳으로 할당할 때 생기는 문제인 <code class="language-plaintext highlighter-rouge">Unchecked assignment</code>에서는  <strong>@SuppressWarning(“unchecked”)로 옛날 코드임을 명시해준다</strong></p>

            <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">ints</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
  <span class="nc">List</span> <span class="n">rawInts</span> <span class="o">=</span> <span class="n">ints</span><span class="o">;</span>
            
  <span class="c1">// 3) 반대의 상황은?</span>
  <span class="c1">//  -&gt; raw Type을 -&gt; 다시 변&lt;구&gt;제에 넣으면?</span>
  <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span> 
  <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">ints2</span> <span class="o">=</span> <span class="n">rawInts</span><span class="o">;</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Generics</span> <span class="o">{</span>
    <span class="c1">//2. staic main에 사용할 static 클래스를 만드는데, 클래스 옆에 &lt;T&gt; 뻐금괄호로 [타입파라미터]를 추가한다.</span>
    <span class="c1">// - 타입 파라미터는 type variable로 불린다. 내부에서  변수처럼 T t;로 쓸 수 있기 때문</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Hello</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="c1">//6. Hello&lt;T&gt; class에 옆에 선언한 타입 파라미터에 매핑이 되어서</span>
        <span class="c1">// -&gt; 클래스 내부에서는 1) 필드Type 2) 메서드 파라미터의 Type 3) 메서드 응답Type으로 사용되기도 한다.</span>
        <span class="c1">//new Hello&lt;String&gt;(); -&gt;</span>
        <span class="c1">//1) T t;</span>
        <span class="c1">//2) Object method(T t) {return null;}</span>
        <span class="c1">//3) &lt;T&gt; Obejct method(T t){return null};</span>


    <span class="o">}</span>

    <span class="c1">//3. 일반적인 (메서드)파라미터는 파라미터 자리에 신언 -&gt; 밖에서 해당Type의 input(값, 객체)를 넣어준다.</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//1. main메서드 ps vm으로 만들기</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//4.</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"Generics"</span><span class="o">);</span>

        <span class="c1">//5. 타입 파라미터에도 메서드 파라미터와 마찬가지로 실제 뭔가(타입)를 넣어주는데 [타입 인자]라고 한다.</span>
        <span class="c1">// -&gt; 실제 &lt;Type&gt;정보(타입 인자)를 타입 파라미터 T자리에 넣어주면 -&gt; 6.</span>
        <span class="c1">//new Hello&lt;String&gt;(); //type argument</span>

        <span class="c1">//7. 제네릭 사용이유</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// 1) 넣을 때, 컴파일 에러가 나서, 일관성있게 타입체킹을 해준다</span>
        <span class="c1">//list.add(4) </span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"str"</span><span class="o">);</span>

        <span class="c1">// 2) 꺼내서 사용할 때, 매번 다운캐스팅해야한다. 실수 할 수도 있음.</span>
        <span class="c1">//final String s = (String) list.get(0);</span>
        <span class="kd">final</span> <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

        <span class="c1">//3) 타입만 바꿔서 class재사용이 가능해진다.</span>

        <span class="c1">//8. raw Type?! (구체형 지정했는데 타입파라미터 없이 변수로 받는 경우)</span>
        <span class="c1">// 1) 우항은 호.&lt;구&gt;.제를 해놨는데, -&gt; 변&lt;구&gt;제로 변환없이 -&gt; 좌측 변수는 제네릭 타입 없는 변수(raw Type)에 받는 경우</span>
        <span class="c1">// -&gt; 괜찮다?!</span>
        <span class="c1">//new ArrayList&lt;Integer&gt;();</span>
        <span class="nc">List</span> <span class="n">rawList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;();</span>

        <span class="c1">// 2) 호&lt;&gt;.구.지 -&gt; 변.&lt;구&gt;.제 를 -&gt; 다시 그대로 제네릭 타입 없는 변수(raw Type)에 할당하는 경우</span>
        <span class="c1">// -&gt; 괜찮다?!</span>
        <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">ints</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
        <span class="nc">List</span> <span class="n">rawInts</span> <span class="o">=</span> <span class="n">ints</span><span class="o">;</span>

        <span class="c1">// 3) 반대의 상황은?</span>
        <span class="c1">//  -&gt; raw Type을 -&gt; 다시 변&lt;구&gt;제에 넣으면?</span>
        <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">ints2</span> <span class="o">=</span> <span class="n">rawInts</span><span class="o">;</span>
        <span class="c1">// Unchecked assignment: 'java.util.List' to 'java.util.List&lt;java.lang.Integer&gt;'</span>
        <span class="c1">// --&gt; raw Type으로 받는 순간, 다시 어떤 Type인지 모르는 상태가 된다.</span>
        <span class="c1">// --&gt; T상태를 다시 type argument가 있는 곳에 넣어줬으니,</span>
        <span class="c1">// --&gt; Object(우) -&gt; Integer(좌)로 캐스팅해서 넣는 것이다.</span>
        <span class="c1">// ---&gt; 위험하다. 만약 Object에 integer 들어있는 것을 List&lt;String&gt;에 캐스팅해서 넣으면...</span>
        <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">strs</span> <span class="o">=</span> <span class="n">rawInts</span><span class="o">;</span> <span class="c1">// raw type에 들어간 순간, 안에 내용물의 타입은 잊어먹고, 좁은 곳으로 캐스팅되서 들어갈 수 있게 된다.</span>
        <span class="c1">// -&gt; 문제는, type argument에 맞춰서 다운캐스팅되서 들어가 컴파일은 되지만, 꺼내올 때부터 문제가 된다.</span>
        <span class="c1">// --&gt; 내용물은 int, type은</span>
        <span class="kd">final</span> <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">strs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="c1">//        class java.lang.Integer cannot be cast to class java.lang.String (java.lang.Integer and java.lang.String are in module java.base of loader 'bootstrap')</span>
<span class="c1">//        at Generics.main(Generics.java:67)</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="제네릭-메서드">
<a class="anchor" href="#%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%A9%94%EC%84%9C%EB%93%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>제네릭 메서드</h4>

<ol>
  <li>
    <p>인스턴스 메서드</p>
  </li>
  <li>
    <p>스태틱 메서드 : class level type parameter꺼는 못씀</p>

    <ul>
      <li>class level의 type paramter는 인스턴스 생성시 <code class="language-plaintext highlighter-rouge">class&lt;T&gt;</code>의 T가 정해져 사용되기 때문</li>
    </ul>
  </li>
  <li>
    <p>생성자</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericsMethod</span> <span class="o">{</span>
     <span class="c1">//0. class 혹은 interface 옆에 타입파라미터가 붙어서 시작하는 경우도 있지만,</span>
     <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Hello</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
     <span class="o">}</span>
    
     <span class="c1">//1. method에서도 타입 파라미터를 붙일 수 있다.</span>
     <span class="c1">// -&gt; String을 파라미터 받아서 출력했었지만</span>
     <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
         <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
     <span class="o">}</span>
    
     <span class="c1">// --&gt; 이젠 어떤 타입이든 받아서 .toString()으로 출력하면 어떤 타입이든 다 출력된다.</span>
     <span class="c1">// --&gt; 이 때, class, interface옆에 &lt;T&gt;를 붙인 것처럼, [응답형 앞에 &lt;T&gt;를 붙여줘야한다.]</span>
     <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
         <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
     <span class="o">}</span>
    
     <span class="c1">//3. static 메서드(인스턴스 안만들고 쓰는 메서드)에도 적용가능하다.</span>
     <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">staticPrint</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
         <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
     <span class="o">}</span>
    
     <span class="c1">//5. 주의!!</span>
     <span class="c1">// class&lt;T&gt; type variable은 -&gt; 해당 class의 인스턴스가 만들어질 때 인자를 받아오게 되는데</span>
     <span class="c1">// -&gt; static은 인스턴스 만들지를 않고 사용하니, T를 모르는 상태 그대로</span>
     <span class="c1">// -&gt; static 메서드는, 인스턴스생성때 T를 채우는 class level이 아닌, method level에서 Type parameter를 사용해야한다.</span>
     <span class="c1">// --&gt; class level type paramter로는 사용 불가능했던 static method는</span>
     <span class="c1">//     method level에서는 type paramter를 static method에서 사용 가능하다.</span>
    
     <span class="c1">//6. class level과 다르게 메서드 level type parameter를 지정하자.</span>
     <span class="kd">static</span> <span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">staticPrint2</span><span class="o">(</span><span class="no">S</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
         <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
     <span class="o">}</span>
    
     <span class="c1">//7. &lt;,&gt;로 2개 level(class, method)의 Type paramter를 섞어 쓸 수 있다.</span>
     <span class="c1">// -&gt; 1개는 class level, 1개는 method level일 것이다.</span>
     <span class="c1">// 1) method level에 정의한 타입파라미터 -&gt; 메서드 파라미터에서 사용</span>
     <span class="c1">// 2) class level에 정의한 타입파라미터 -&gt; 메서드 응답형에서 사용 가능</span>
     <span class="o">&lt;</span><span class="no">S</span><span class="o">,</span> <span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">staticPrint3</span><span class="o">(</span><span class="no">S</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
         <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
         <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
     <span class="o">}</span>
    
     <span class="c1">//8. method level 1) 인스턴스메서드 2) 스태틱메서드(new)에 추가로</span>
     <span class="c1">// -&gt; 3) 생성자에서도 method level type paramter를 쓸 수 있다.(class level과 별개로)</span>
     <span class="kd">public</span> <span class="nf">GenericsMethod</span><span class="o">()</span> <span class="o">{}</span>
     <span class="c1">// 생성자에서도 class level과 별개로 아무Type이나 받을 수 있다.</span>
     <span class="c1">// 생성자는 응답이 없으므로 생성자 메서드앞에 &lt;&gt;를 작성해주면 된다.</span>
     <span class="kd">public</span> <span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="nf">GenericsMethod</span><span class="o">(</span><span class="no">S</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
     <span class="o">}</span>
    
     <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
         <span class="c1">//2. 어떤 타입이든 받아서 출력되는지 확인해보자.</span>
         <span class="k">new</span> <span class="nf">GenericsMethod</span><span class="o">().</span><span class="na">print</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
         <span class="k">new</span> <span class="nf">GenericsMethod</span><span class="o">().</span><span class="na">print</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    
         <span class="c1">//4. method level의 타입파라미터는 static method에도 적용가능하다</span>
         <span class="nc">GenericsMethod</span><span class="o">.</span><span class="na">staticPrint</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
         <span class="nc">GenericsMethod</span><span class="o">.</span><span class="na">staticPrint</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>
     <span class="o">}</span>
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Bounded Type paratmer : 내부 로직에 의해 제한이 필요한 Type paramter</p>

    <ul>
      <li>다양한 Type을 다 받을 수 있다 -&gt; generic한 method</li>
      <li>내부 알고리즘상 꼭 필요한 제약조건(Comparable을 구현한 Type만 들어와서 비교가능해야함)이 걸고 싶다 -&gt; bound type parameter</li>
    </ul>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericBounded</span> <span class="o">{</span>
     <span class="c1">// 0. default로는 타입제한이 없은 &lt;T&gt;가 오지만  &lt;T extends List&gt; 등</span>
     <span class="c1">// -&gt; Bounded Type parameter ?</span>
    
     <span class="c1">// 1. 인스턴스 or static(for main) 메서드에서도 쓸 수 있다.</span>
     <span class="c1">// -&gt; 변.&lt;구&gt;.제와 비슷하게, 메서드용 &lt;구체형&gt;제한은,  응답형 앞에 표기하는 &lt;T&gt;에서 해준다.</span>
     <span class="c1">//static &lt;T extends List&gt; void print(T t) {}</span>
    
     <span class="c1">// 2. bound제한을 줄 때, 1개만 할 수 있따 생각하지만, &amp; 1개로 여러개 형을 줄 수 있다.</span>
     <span class="c1">// -&gt; multiple bound ( 공통으로서 다 만족해야한다. OR옵션은 없다.)</span>
     <span class="c1">//static &lt;T extends List &amp; B &amp; C&gt; void print(T t) {}</span>
     <span class="c1">// -&gt; class가 올 경우는 1개만, interface는 여러개 구현하는 것처럼 여러개 가능</span>
     <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">List</span> <span class="o">&amp;</span> <span class="nc">Serializable</span> <span class="o">&amp;</span> <span class="nc">Comparable</span> <span class="o">&amp;</span> <span class="nc">Closeable</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
     <span class="o">}</span>
    
     <span class="c1">//3. 예시) array + 기준값을 받아서, 기준값보다 큰 것의 갯수 구하기</span>
     <span class="c1">// -&gt; 제네릭 사용하지 않고, Integer로 fix</span>
     <span class="kd">static</span> <span class="kt">long</span> <span class="nf">countGreaterThan</span><span class="o">(</span><span class="nc">Integer</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">elem</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">)</span>
             <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="n">elem</span><span class="o">)</span>
             <span class="o">.</span><span class="na">count</span><span class="o">();</span>
     <span class="o">}</span>
    
     <span class="c1">// 6. type만 다르니 generic method을 도입하자.(구체형 -&gt; T로 변경)</span>
 <span class="c1">//    static &lt;T&gt; long genericCountGreaterThan(T[] arr, T elem) {</span>
     <span class="c1">// 10. 내부 비교로직이 들어가는 method level type paramter는 Comparable&lt;T&gt;로 구현한 Type으로 제한을 걸어줘야한다</span>
     <span class="c1">// -&gt; 이제 genericCountGreaterThan() 인자는 comparable구현하여 비교가능한 애들만 넘어온다.</span>
     <span class="c1">// --&gt; cf) Comparable은 impl시 해당 class형을 제네릭파라미터를 받았었다. -&gt; 여기선 T</span>
     <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="kt">long</span> <span class="nf">genericCountGreaterThan</span><span class="o">(</span><span class="no">T</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="no">T</span> <span class="n">elem</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">)</span>
             <span class="c1">// 7. 문자는 크기비교를 숫자Type만 가능한 부등호로 비교하고 있었다.</span>
             <span class="c1">//.filter(s -&gt; s &gt; elem)</span>
             <span class="c1">// 8. 숫자 이외에 더 일반적으로 &amp; Type(객체)의 순서를 비교(크기 비교)하려면</span>
             <span class="c1">// - Comparable &lt;- 이 인터페이스를 작성해서 찾아 들어가서 확인도 같이해보자.</span>
             <span class="c1">//Comparable</span>
             <span class="c1">// - Comparable 구현후 -&gt; 내부 compareTo 라는 메서드를 구현해서 비교할 수 있지만.</span>
             <span class="c1">// - s는 T타입 이라서 .compareTo가 있는지 도 모른다는게 문제다</span>
             <span class="c1">//.filter(s -&gt; s.compareTo(elem))</span>
             <span class="c1">//9. 그렇다면 T타입은... 미리 좀 내부에서 Comparable을 구현해서 비교가 되는 놈으로 제한하자</span>
             <span class="c1">// -&gt; type parameter를 (비교가능한 객체로) 제한하려면? -&gt; bounded type parameter를 쓰면 된다.</span>
             <span class="c1">//11. 이제 s가 bounded type parameter로서 comparable구현Type으로  보장되었다</span>
             <span class="c1">// -&gt; compareTo가 사용가능하다. 이 return값은 int 1, 0, 1이니.. t/f가 아님을 조심하자.</span>
             <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
             <span class="o">.</span><span class="na">count</span><span class="o">();</span>
     <span class="o">}</span>
    
     <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
         <span class="kd">final</span> <span class="nc">Integer</span><span class="o">[]</span> <span class="n">integers</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
         <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"countGreaterThan(integers, 4) = "</span> <span class="o">+</span> <span class="n">countGreaterThan</span><span class="o">(</span><span class="n">integers</span><span class="o">,</span> <span class="mi">4</span><span class="o">));</span>
         <span class="c1">//4. 숫자말고, 다른Type인 문자도 크기 비교가 가능하다~</span>
         <span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">strings</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">,</span> <span class="s">"4"</span><span class="o">,</span> <span class="s">"5"</span><span class="o">,</span> <span class="s">"6"</span><span class="o">,</span> <span class="s">"7"</span><span class="o">};</span>
         <span class="c1">//countGreaterThan(strings) -&gt; 구체형이  fix되어있으니 컴파일 에러</span>
         <span class="c1">//5. generic 도입을 고민한다.</span>
         <span class="c1">//12. generic + 비교를 위한 bound type paramter가 적용이 끝났으면 사용해보자</span>
         <span class="c1">// -&gt; string도 String을 찍어서 들어가보면, impl Comparabel&lt;String&gt;을 구현하고 있기 때문이다.</span>
         <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"genericCountGreaterThan(strings, \"3\") = "</span> <span class="o">+</span> <span class="n">genericCountGreaterThan</span><span class="o">(</span><span class="n">strings</span><span class="o">,</span> <span class="s">"2"</span><span class="o">));</span>
     <span class="o">}</span>
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h4 id="제네릭과-상속">
<a class="anchor" href="#%EC%A0%9C%EB%84%A4%EB%A6%AD%EA%B3%BC-%EC%83%81%EC%86%8D" aria-hidden="true"><span class="octicon octicon-link"></span></a>제네릭과 상속</h4>

<ul>
  <li>
    <p>타입 파라미터의 상속관계는, 제네릭 적용 class 상속관계에 아무 영향을 주지 않는다.</p>
  </li>
  <li>
    <p>같은 추상체의 SubType(추상체가 가진 type paramter도 같으면)이면</p>

    <ul>
      <li>
        <p>구상체만의 type paramter는 달라고 할당된다.</p>

        <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyList</span><span class="o">&lt;</span><span class="no">E</span><span class="o">,</span> <span class="no">P</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{}</span>
        
  <span class="c1">//</span>
            
  <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;();</span>
  <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;();</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="제네릭-타입-추론">
<a class="anchor" href="#%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%83%80%EC%9E%85-%EC%B6%94%EB%A1%A0" aria-hidden="true"><span class="octicon octicon-link"></span></a>제네릭 타입 추론</h4>

<ul>
  <li>
    <p>java 7이하는 type paramter를 추론 못하는 경우도 있을 수 있다. 이 때는 <code class="language-plaintext highlighter-rouge">메서드 호출()</code> 앞에 <code class="language-plaintext highlighter-rouge">&lt;Type&gt;</code>를 붙여준다.</p>
  </li>
  <li>
    <p>Collections.emptyList(); 같은 경우, 들어가는 parameter가 없기 때문에 추론이 안될 수 있다. -&gt; 메서드앞에 <code class="language-plaintext highlighter-rouge">&lt;Type&gt;</code>을 명시해준다.</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c1">//java 7이하 타입추론안될 때 명시해주기</span>
  <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.&lt;</span><span class="nc">String</span><span class="o">&gt;</span><span class="n">emptyList</span><span class="o">();</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="제네릭과-와일드카드">
<a class="anchor" href="#%EC%A0%9C%EB%84%A4%EB%A6%AD%EA%B3%BC-%EC%99%80%EC%9D%BC%EB%93%9C%EC%B9%B4%EB%93%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>제네릭과 와일드카드</h4>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">?</code>: wildcards -&gt; 모르고, 알필요도 없다.</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">T</code>: 선언시점에서 T는 뭔지 모르지만, 타입 정해지면 그것으로 사용하겠따</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">&lt;?&gt;</code></p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">&lt;? extends Object&gt;</code>와 동치이다. <strong>Object의 기능만 사용</strong>한다</p>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">List&lt;?&gt;</code> : 구상체들 기능은 필요없고, 추상체 <strong>List의 기능만 사용</strong>한다.</p>
      </li>
      <li>
        <p>**명확하게 <object>형을 정해놓는 것에 비해, 아무형이나 올 수 있고, 그 기능은 가장 추상형 기능만 사용한다.( bound 제한있을 시)**</object></p>

        <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericsWildcards</span> <span class="o">{</span>
      <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printList</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">list</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
      <span class="o">}</span>
        
      <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printList2</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">list</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
      <span class="o">}</span>
        
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
          <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integers</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
          <span class="c1">// 1. Object-Integer와 달리,  List&lt;Object&gt; 와 List&lt;Integer&gt;는 SubType의 관계가 아니므로 인자로 못 넣는다.</span>
          <span class="c1">// - my) 추상형 변수 = 구상형 객체 [할당]  ==  호출시( 구상형 인자 ) -&gt; 메서드 선언부(추상체 파라미터) 호출이나 마찬가지</span>
          <span class="c1">// -&gt; 인자 대입은 구상형 -&gt; 내부 파라미터는 추상형으로서, SubType만 올 수 있는데</span>
          <span class="c1">// --&gt; List&lt;Integer&gt; 인자 -&gt; List&lt;Object&gt; 파라미터는 SubType관계가 아니므로 들어갈 수 없다.</span>
          <span class="c1">// --&gt; 즉, integer는 Object의 서브타입이지만, 리스트integer는 리스트object의 서브타입이 아니므로 호출시 대입 불가능</span>
          <span class="c1">// -&gt; 명확하게 &lt;형&gt;을 정해놓으면, SubType만 할당/대입 가능하다!!!</span>
          <span class="c1">//printList(integers); //compile Error</span>
        
          <span class="c1">//2. ? 와일드카드는 명확하게 어떤형X, 어떤 형이든 상관없이 받아서, 추상형의 기능만 이용한다.</span>
          <span class="n">printList2</span><span class="o">(</span><span class="n">integers</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>
        
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>와일드카드 제한점?!</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericsWildcards</span> <span class="o">{</span>
      <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printList</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">list</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
      <span class="o">}</span>
    
      <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printList2</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">list</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
      <span class="o">}</span>
    
      <span class="c1">//3. class 2개를 만들어보자</span>
      <span class="kd">static</span> <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
      <span class="o">}</span>
    
      <span class="kd">static</span> <span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="no">A</span> <span class="o">{</span>
      <span class="o">}</span>
    
    
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
          <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integers</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
          <span class="c1">// 1. Object-Integer와 달리,  List&lt;Object&gt; 와 List&lt;Integer&gt;는 SubType의 관계가 아니므로 인자로 못 넣는다.</span>
          <span class="c1">// - my) 추상형 변수 = 구상형 객체 [할당]  ==  호출시( 구상형 인자 ) -&gt; 메서드 선언부(추상체 파라미터) 호출이나 마찬가지</span>
          <span class="c1">// -&gt; 인자 대입은 구상형 -&gt; 내부 파라미터는 추상형으로서, SubType만 올 수 있는데</span>
          <span class="c1">// --&gt; List&lt;Integer&gt; 인자 -&gt; List&lt;Object&gt; 파라미터는 SubType관계가 아니므로 들어갈 수 없다.</span>
          <span class="c1">// --&gt; 즉, integer는 Object의 서브타입이지만, 리스트integer는 리스트object의 서브타입이 아니므로 호출시 대입 불가능</span>
          <span class="c1">// -&gt; 명확하게 &lt;형&gt;을 정해놓으면, SubType만 할당/대입 가능하다!!!</span>
          <span class="c1">//printList(integers); //compile Error</span>
    
          <span class="c1">//2. ? 와일드카드는 명확하게 어떤형X, 어떤 형이든 상관없이 받아서, 추상형의 기능만 이용한다.</span>
          <span class="n">printList2</span><span class="o">(</span><span class="n">integers</span><span class="o">);</span>
    
          <span class="c1">//4.</span>
          <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">B</span><span class="o">&gt;</span> <span class="n">bList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
          <span class="c1">// 4-1. A 이하의 SubType형 list를 받을 수 있게하고, List&lt;B&gt;를 넣었더니..</span>
          <span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">A</span><span class="o">&gt;</span> <span class="n">la</span> <span class="o">=</span> <span class="n">bList</span><span class="o">;</span>
          <span class="c1">// 4-2. 호.&lt;구&gt;.지로 완전 내부가 바꼈나??? A를 add하면 compile error</span>
          <span class="c1">//la.add(new A()); //compile Error</span>
          <span class="c1">// 4-3. 그렇다고 치기엔, B도 add가 안된다.</span>
          <span class="c1">//la.add(new B());</span>
          <span class="c1">// 4-4. 와일드카드의 제한점으로서... add는 null밖에 안된다. -&gt; why?</span>
          <span class="n">la</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="심화">
<a class="anchor" href="#%EC%8B%AC%ED%99%94" aria-hidden="true"><span class="octicon octicon-link"></span></a>심화</h3>

<h4 id="type-paramter를-필요로-하는-제네릭-메서드의-파라미터list-에-대해-type-paramter-적용-vs-wildcards-적용">
<a class="anchor" href="#type-paramter%EB%A5%BC-%ED%95%84%EC%9A%94%EB%A1%9C-%ED%95%98%EB%8A%94-%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0list-%EC%97%90-%EB%8C%80%ED%95%B4-type-paramter-%EC%A0%81%EC%9A%A9-vs-wildcards-%EC%A0%81%EC%9A%A9" aria-hidden="true"><span class="octicon octicon-link"></span></a>type paramter를 필요로 하는, 제네릭 메서드의 파라미터(<code class="language-plaintext highlighter-rouge">List&lt; &gt;</code>)에 대해 Type Paramter 적용 vs WildCards 적용</h4>

<h5 id="type-paramter-적용">
<a class="anchor" href="#type-paramter-%EC%A0%81%EC%9A%A9" aria-hidden="true"><span class="octicon octicon-link"></span></a>Type Paramter 적용</h5>

<ul>
  <li>
    <p>와일드카드를 적용한 것과 다르게</p>

    <ul>
      <li>
        <p><strong>한번 정의된 <code class="language-plaintext highlighter-rouge">type parameter</code>는 추가 파라미터,  body내부 인스턴스 변수, 응답 값 등 <code class="language-plaintext highlighter-rouge">메서드 내부 다양한 곳에서 T를 활용</code>할 수 있다.</strong></p>

        <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c1">//1. type paramter를  메서드 파라미터(List&lt; &gt;)에 사용한 경우</span>
  <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">method1</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        
  <span class="o">}</span>
</code></pre></div>        </div>

        <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c1">//1. type paramter를  메서드 파라미터(List&lt; &gt;)에 사용한 경우</span>
  <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">method1</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>    <span class="c1">// 1) 메서드파라미터</span>
  	<span class="c1">// 2) 내부 인스턴스 변수의 Type</span>
      <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
        
      <span class="c1">// 3) 응답Type으로도   type paramter를 활용할 수 있다.</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h5 id="unbounded-wildcards-적용">
<a class="anchor" href="#unbounded-wildcards-%EC%A0%81%EC%9A%A9" aria-hidden="true"><span class="octicon octicon-link"></span></a>unbounded WildCards 적용</h5>

<ul>
  <li>
    <p>내부에서 활용할 수 도 없는 와일드 카드를 type paramter로 왜 사용하는 것일까?</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method2</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<ol>
  <li>
    <p>컬렉션를 받고 싶다면, 컬렉션&lt;?&gt; 와일드카드를 이용해야한다.아무원소&gt;</p>

    <ul>
      <li>
<strong><code class="language-plaintext highlighter-rouge">List&lt;Object&gt;</code>로 형이 명시된 경우, <code class="language-plaintext highlighter-rouge">List&lt;SubType&gt;</code>의 자손이 아니므로 파라미터가 인자를 받을 수 없게 됨.</strong>
        <ul>
          <li><strong><code class="language-plaintext highlighter-rouge">List&lt;?&gt;</code>는 <code class="language-plaintext highlighter-rouge">List&lt;Obejct의 SubType&gt;</code> 아무거나 다 받을 수 있다.</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>그러나 <code class="language-plaintext highlighter-rouge">unbound wild card</code>인 <code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>사용시에는 제약이 있다.</strong></p>

    <ol>
      <li>
        <p>특정 Type의 값을 add등 넣지 못한다.</p>
      </li>
      <li>
        <p>특정 Type의 원소들과 관련된 기능은 사용못하고 -&gt; 가장 추상체List, Object만의 기능만 사용한다.</p>

        <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method2</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
     <span class="c1">//3.그러나 `unbound wild card`(extends 등 사용안한 것)인 `&lt;?&gt;`사용시에는 제약이 있다.</span>
     <span class="c1">//3-1. 해당 자료구조에 구체적인 Type의 값(객체)을 넣을 수 없다.</span>
     <span class="c1">//     -&gt; 해당 자료구조에는  null만 넣을 수 있다.</span>
     <span class="c1">//list.add("1"); //compile error</span>
     <span class="c1">//list.add(1); //compile error</span>
     <span class="c1">//list.add(null); // runtime UOE error</span>
     <span class="c1">//3-2. 가장 추상체 = List만의 기능 + Object만의 기능만 사용가능하며, 각 Type의 원소들과 관련된 기능은 사용 못한다.</span>
     <span class="c1">//3-2-1. List만의 기능</span>
     <span class="c1">//list.clear();// runtime UOE error</span>
     <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
     <span class="kd">final</span> <span class="nc">Iterator</span><span class="o">&lt;?&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
     <span class="c1">//3-2-2. Object만의 기능</span>
     <span class="n">list</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
     <span class="n">list</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        
 <span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>unbound wild card 사용 예시1</strong></p>

    <ol>
      <li>
        <p>list를 받아 비어있으면 true반환하는 <code class="language-plaintext highlighter-rouge">isEmpty()</code>
 <img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220507220736564.png" alt="image-20220507220736564"></p>
      </li>
      <li>
        <p>list의 원소가 어느type이든, <strong>어떤 종류의 list라도 받을 수 있게 <code class="language-plaintext highlighter-rouge">&lt;T&gt;</code> 와일드카드로 파라미터 지역변수를 지정</strong>해주자
 <img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220507220849243.png" alt="image-20220507220849243"></p>

        <p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220507220948421.png" alt="image-20220507220948421"></p>

        <pre><code class="language-JAVA"> private static &lt;T&gt; boolean isEmpty(final List&lt;T&gt; list) {
     return list.size() == 0;
 }
</code></pre>
      </li>
      <li>
        <p><strong>메서드 파라미터속 type parameter T를 내부에서 사용하지 않았다면,  T -&gt; 언바운드 wild card로 바꿀 수 있다.</strong></p>

        <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="c1">//메서드 파라미터속 type parameter T를 내부에서 사용하지 않았다면</span>
 <span class="c1">//     -&gt; 타입 파라미터 대신 와일드카드를 적용시킬 수 있다.</span>
 <span class="c1">//     -&gt; (타입파라미터 안쓰면 -&gt; 응답형 앞에 명시한 것도 삭제해주기)</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
 <span class="o">}</span>
        
        
        
 <span class="c1">//4. unbound wild card 사용 예시를 들기 위해</span>
 <span class="c1">// -&gt; 어느 list를 받아 비어있으면 true를 반환하는 isEmpty()를 만든다 가정한다.</span>
 <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerList</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">isEmpty</span><span class="o">(</span><span class="n">integerList</span><span class="o">));</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>지네릭 메소드를 쓰는 이유:</strong> 지네릭 type parameter로 정의된 T type의 <code class="language-plaintext highlighter-rouge">원소</code>에 관심 있어, <code class="language-plaintext highlighter-rouge">메서드 내부 T를 사용해야만</code> 하는,  <code class="language-plaintext highlighter-rouge">add/remove/set 원소단위로 기능</code>이 들어가는 경우</p>
  </li>
  <li>
    <p><strong>지네릭 메소드 대신 와일드카드를  쓰는 이유:</strong>  자료구조 속 원소에는 관심X -&gt; List단위로서의 기능만 + Object의 기능만 쓸 경우</p>
  </li>
  <li>
    <p><strong>unbound wild card 사용 예시2</strong></p>

    <ol>
      <li>
        <p>frequnecy( list, 3) -&gt; <strong>특정 원소가 몇번 중복</strong>되어있는지</p>

        <p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220507223309292.png" alt="image-20220507223309292"></p>

        <p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220507223342739.png" alt="image-20220507223342739"></p>
      </li>
      <li>
        <p><strong>List의 원소 Type,  개별원소Type  모두 <code class="language-plaintext highlighter-rouge">T</code>로 대체해준다.</strong></p>

        <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">long</span> <span class="nf">frequency</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kd">final</span> <span class="no">T</span> <span class="n">elem</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
         <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">elem</span><span class="o">))</span>
         <span class="o">.</span><span class="na">count</span><span class="o">();</span>
 <span class="o">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p><strong>빈도 검사에서도 <code class="language-plaintext highlighter-rouge">내부에서 T가 안쓰였으니.. 와일드카드로 변환</code>이 가능할 것 같은데</strong></p>

        <ul>
          <li>type parameter를 정의하는 곳에만 들어갈 수 있다.</li>
          <li>
<strong><code class="language-plaintext highlighter-rouge">컬렉션&lt;T&gt;</code>의 파라미터 변수는 <code class="language-plaintext highlighter-rouge">컬렉션&lt;Object&gt;</code>로 <code class="language-plaintext highlighter-rouge">컬렉션&lt;Subtype&gt;</code>을 받을 수 없지만, <code class="language-plaintext highlighter-rouge">단일 TypeParameter</code>는 추상-구상 SubType관계가 유지되므로 <code class="language-plaintext highlighter-rouge">Object</code>로 <code class="language-plaintext highlighter-rouge">어느 타입이든 받는 T</code>를 대신할 수 있다.</strong>
            <ul>
              <li>즉 메서드 파라미터 속  <code class="language-plaintext highlighter-rouge">T t</code> -&gt; <code class="language-plaintext highlighter-rouge">? t</code>(X) -&gt; <strong><code class="language-plaintext highlighter-rouge">Object t</code> (O)로 바꿔도 된다!</strong>
</li>
            </ul>
          </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220507223838433.png" alt="image-20220507223838433"></p>

        <p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220507225051896.png" alt="image-20220507225051896"></p>
      </li>
      <li>
        <p>내부 로직에서 사용되는 메서드를 봐도</p>

        <ul>
          <li>equals -&gt; Object에 정의된 기능 -&gt; <code class="language-plaintext highlighter-rouge">?</code>로 변환 가능!</li>
          <li><strong>와일드카드의 사용법 중에 1가지는 Object에 정의된 기능은 사용 허용!이다</strong></li>
        </ul>

        <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">frequency</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">elem</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
         <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">elem</span><span class="o">))</span>
         <span class="o">.</span><span class="na">count</span><span class="o">();</span>
 <span class="o">}</span>
        
        
 <span class="c1">//5. 빈도를 세는 것(list + 개별원소)도 내부에서는 개별원소 기능이 없다 -&gt; filter + equals기능만 사용 -&gt; 지네릭 메서드 대신 와일드카드로</span>
 <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">duplicateIntegerList</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"frequency(duplicateIntegerList, 3) = "</span> <span class="o">+</span> <span class="n">frequency</span><span class="o">(</span><span class="n">duplicateIntegerList</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
</ol>

<h5 id="bounded-wildcards-적용">
<a class="anchor" href="#bounded-wildcards-%EC%A0%81%EC%9A%A9" aria-hidden="true"><span class="octicon octicon-link"></span></a>bounded WildCards 적용</h5>

<ol>
  <li>
    <p>max 메서드 생성</p>

    <p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220507235709440.png" alt="image-20220507235709440"></p>
  </li>
  <li>
    <p>원래는 integer로 시작해서 T로 변환해야하지만, 바로 제네릭 메서드로 작성해보자.</p>

    <ul>
      <li>
        <p>stream을 이용해서 max를 구한다면</p>

        <ul>
          <li>loop -&gt; 제일 작은 초기값 세팅후 -&gt; 업데이트 방식과 다르게</li>
          <li>reduce의 초기값 없이 바로 BinaryOperator 사용방식으로, 누적해서 2개의 값씩 비교해나간다</li>
        </ul>
      </li>
      <li>
        <p>optional반환인데 값만 강제로 꺼내고 싶다면 <strong>.get()</strong>을 때리면 된다.</p>

        <ul>
          <li><strong>만약 <code class="language-plaintext highlighter-rouge">Optional에서 .get()으로 값을 못꺼낸 상황</code>일 땐, <code class="language-plaintext highlighter-rouge">NoSuchElementException</code>을 낸다.</strong></li>
        </ul>

        <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c1">//2. 원래는 Integer부터 만들어야 정상이지만, 제네릭을 계속 썼다보니 제네릭 메소드로 만들어보자.</span>
  <span class="c1">//private static &lt;T&gt; void max(final List&lt;T&gt; list) {</span>
  <span class="c1">//2-2. 제네릭 메서드의 type parameter에서  upper bound는 파라미터 자리가 아닌 [응답형 앞]에서 준다.</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="no">T</span> <span class="nf">max</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
          <span class="c1">//2-1. max를 loop를 구할 땐, 가장 작은값을 후보 변수에 세팅 -&gt; 계속 업데이트하면서 구하는데, stream으로는?</span>
          <span class="c1">// -&gt; reduce의 2번째 방식(초기값 identity 따로 안주고 첫+둘 -&gt; 합+셋 -&gt; 순으로 연산 하기위해)으로 작성해보자.</span>
          <span class="c1">// -&gt; 연산후 연산결과의 Type이 현재 원소들과 같은 Type으로 되돌려줘야한다.</span>
          <span class="c1">// -&gt; 누적해가면서 &lt;2변수를 비교후 큰값을 남기기&gt;가 max값이다.</span>
          <span class="c1">// --&gt; Integer였다면  a &gt; b ? a : b 의 3항연산자를 써서 (비교후 t/f별 return) 했을 것이다.</span>
          <span class="c1">//.reduce((a,b) -&gt; a &gt; b ? a : b)</span>
          <span class="c1">// -&gt; 하지만, 제네릭을 통해 아무Type T -&gt; [부등호를 통한 숫자비교]이외의 비교를 위해서</span>
          <span class="c1">// --&gt; Comparable 구현으로 제한한 Type에 대해 compareTo로 비교한다.</span>
          <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="o">)</span>
          <span class="c1">//2-3.stream에 원소가 없을 경우 optional로 반환하는데, get()을 통해 값만 강제로 꺼낼 수 도 있다.</span>
          <span class="c1">// -&gt; 값이 없는데 get을 시도했을 때 예외가 발생하는데, 이것은 자연스런 예외라고 생각할 수 있다.</span>
          <span class="c1">// NoSuchElementException: No value present</span>
          <span class="c1">// default값이나 or 특정예외를 발생시키는 코드를 작성안해도, 없는 값 get시도시 예외는 자연스러운 것으로 봐도 된다.</span>
          <span class="o">.</span><span class="na">get</span><span class="o">();</span>
  <span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>내부T 안쓴 것처럼 보이지만, stream -&gt; 개별 원소 접근 -&gt; T쓴 것 과 마찬가지로 wildcard로 변환 불가능.의 상태이다. 하지만, <code class="language-plaintext highlighter-rouge">wild cards가 개입될 여지</code>가 있다.</strong></p>

    <ul>
      <li>
        <p>wild card 도입 전</p>

        <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="no">T</span> <span class="nf">max</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
          <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="o">)</span>
          <span class="o">.</span><span class="na">get</span><span class="o">();</span>
  <span class="o">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>stream 아니였으면, 내부 T를 사용 -&gt; wildcard로 변환은 불가능한 상태</p>

        <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="no">T</span> <span class="n">currentMax</span>  <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
  <span class="k">for</span> <span class="o">(</span><span class="kd">final</span> <span class="no">T</span> <span class="n">t</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">currentMax</span><span class="o">)&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">currentMax</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
      <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">currentMax</span><span class="o">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>내부에 개별원소 T의 사용으로 <code class="language-plaintext highlighter-rouge">&lt;?&gt;</code> 대신 <code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>의 제네릭 메서드로 정해졌어도</strong></p>

    <ul>
      <li><strong>내부에서 사용되는 <code class="language-plaintext highlighter-rouge">파라미터 속 컬렉션의 type parameter</code>는 <code class="language-plaintext highlighter-rouge">upper bound with ?</code>으로 수정가능하고</strong></li>
      <li><strong><code class="language-plaintext highlighter-rouge">외부</code>에서 사용되는 <code class="language-plaintext highlighter-rouge">응답형 앞의 Comparable&lt;T&gt; type paramter</code>는 <code class="language-plaintext highlighter-rouge">lower bound with ?</code>로 수정 가능하다</strong></li>
    </ul>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="c1">//3. 내부T 안쓴 것처럼 보이지만, stream -&gt; 개별 원소 접근 -&gt; T쓴 것 과 마찬가지로 wildcard로 변환 불가능.의 상태이다.</span>
 <span class="c1">//3-1. 비교메서드compareTo() 의 사용은 T type 원소뿐만 아니라, T의 SubType들도 인자로 들어와 비교될 수 있다.</span>
 <span class="c1">//     비교메서드의 인자뿐만 아니라 컬렉선&lt;T&gt;에서 각 원소가 [메서드 내부에서 사용=소모]되는 경우라면 [와일드카드를 사용한 upper bound type paramter]로 넘긴다는 가이드라인 있다.</span>
 <span class="c1">//     -&gt; 메서드 파라미터의 [개별 원소가 메서드 내부에 사용되는 컬렉션의 type parameter] List&lt;T&gt; -&gt; List&lt;? extends T&gt;</span>
 <span class="c1">//    private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;T&gt; list) {</span>
 <span class="c1">//3-2. 반대로, Comparable&lt;T&gt;에 걸린 T는 메서드내부에서 정해져 사용되지 않고, 메서드 밖에서 사용되는 Type paramter라서</span>
 <span class="c1">//  -&gt; lower bound로 정의해준다.</span>
 <span class="c1">//    private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;? extends T&gt; list) {</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;&gt;</span> <span class="no">T</span> <span class="nf">max</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
         <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="o">)</span>
         <span class="o">.</span><span class="na">get</span><span class="o">();</span>
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h5 id="wild-card로-정의-가능하다면-지네릭-메소드-대신-와일드카드로-메서드-작성하는-이유">
<a class="anchor" href="#wild-card%EB%A1%9C-%EC%A0%95%EC%9D%98-%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4%EB%A9%B4-%EC%A7%80%EB%84%A4%EB%A6%AD-%EB%A9%94%EC%86%8C%EB%93%9C-%EB%8C%80%EC%8B%A0-%EC%99%80%EC%9D%BC%EB%93%9C%EC%B9%B4%EB%93%9C%EB%A1%9C-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0" aria-hidden="true"><span class="octicon octicon-link"></span></a>wild card로 정의 가능하다면 지네릭 메소드 대신 와일드카드로 메서드 작성하는 이유</h5>

<ul>
  <li>oracle문서: T type parameter의 지네릭 메소드는 <strong>내부 로직에 T type을 사용해서 처리하겠다</strong>라는 의미가 담겨있다고 한다.
    <ul>
      <li><strong>Type parameter는 내부 구현이 노출이 된다.</strong></li>
    </ul>
  </li>
  <li>와일드 카드로 작성을 권장한다.</li>
</ul>

<h5 id="와일드카드를-사용한-상태에서-비교를-위한-compareto-사용을-위해-bound-wild-card인-----extends-comparable은-허용한다-하지만-메서드-내부에-t를-이용하느-코드가-나온다면-응답형-앞에-t를-t-extends-comparable로-바꿔주면-된다">
<a class="anchor" href="#%EC%99%80%EC%9D%BC%EB%93%9C%EC%B9%B4%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%83%81%ED%83%9C%EC%97%90%EC%84%9C-%EB%B9%84%EA%B5%90%EB%A5%BC-%EC%9C%84%ED%95%9C-compareto-%EC%82%AC%EC%9A%A9%EC%9D%84-%EC%9C%84%ED%95%B4-bound-wild-card%EC%9D%B8-----extends-comparable%EC%9D%80-%ED%97%88%EC%9A%A9%ED%95%9C%EB%8B%A4-%ED%95%98%EC%A7%80%EB%A7%8C-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%82%B4%EB%B6%80%EC%97%90-t%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EB%8A%90-%EC%BD%94%EB%93%9C%EA%B0%80-%EB%82%98%EC%98%A8%EB%8B%A4%EB%A9%B4-%EC%9D%91%EB%8B%B5%ED%98%95-%EC%95%9E%EC%97%90-t%EB%A5%BC-t-extends-comparable%EB%A1%9C-%EB%B0%94%EA%BF%94%EC%A3%BC%EB%A9%B4-%EB%90%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>와일드카드를 사용한 상태에서 비교를 위한 compareTo 사용을 위해 bound wild card인   <code class="language-plaintext highlighter-rouge">&lt; ? extends Comparable&gt;</code>은 허용한다. 하지만 메서드 내부에 <code class="language-plaintext highlighter-rouge">T</code>를 이용하느 코드가 나온다면, 응답형 앞에 T를 <code class="language-plaintext highlighter-rouge">&lt;T extends Comparable&gt;</code>로 바꿔주면 된다.</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isEmpty2</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&gt;</span> <span class="kt">boolean</span> <span class="nf">isEmpty3</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="pecs는-사실-메서드내부-사용되는-t는-e--메서드외부에서-사용되는-t는-s-이다">
<a class="anchor" href="#pecs%EB%8A%94-%EC%82%AC%EC%8B%A4-%EB%A9%94%EC%84%9C%EB%93%9C%EB%82%B4%EB%B6%80-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-t%EB%8A%94-e--%EB%A9%94%EC%84%9C%EB%93%9C%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-t%EB%8A%94-s-%EC%9D%B4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>PECS는 사실… 메서드내부 사용되는 T는 E / 메서드외부에서 사용되는 T는 S 이다.</h4>

<ol>
  <li>
    <p>어느타입의 List든 <code class="language-plaintext highlighter-rouge">List&lt;T&gt;</code>를 받아 max(list)를 구현</p>

    <ul>
      <li>
        <p>reduce로 누적하여 연산하되, 둘중에 큰 값만 남기도록 한다.</p>

        <ul>
          <li>초기값 없이 바로 BinaryOperator작성하여, 1과2 -&gt;  연산값과 3번째, …  ,</li>
          <li>매번 연산값은 첫번째 요소와 동일한 Type이 되어야한다.</li>
          <li>둘 중에 큰 값만 남겨 return해야하므로 삼항연산자를 활용했다.</li>
        </ul>
      </li>
      <li>
        <p>Integer로 시작했었지만, Number Type 이외의 값도 비교해야하므로</p>

        <ul>
          <li>들어오는 T에 대해 응답형앞에서 <code class="language-plaintext highlighter-rouge">&lt;T extends Comparable&lt;T&gt;&gt;</code>로 <strong>Comparable 인페를 구현한 Type으로 bound한다.</strong>
</li>
        </ul>

        <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="no">T</span> <span class="nf">max</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
          <span class="c1">//2-1. max를 loop를 구할 땐, 가장 작은값을 후보 변수에 세팅 -&gt; 계속 업데이트하면서 구하는데, stream으로는?</span>
          <span class="c1">// -&gt; reduce의 2번째 방식(초기값 identity 따로 안주고 첫+둘 -&gt; 합+셋 -&gt; 순으로 연산 하기위해)으로 작성해보자.</span>
          <span class="c1">// -&gt; 연산후 연산결과의 Type이 현재 원소들과 같은 Type으로 되돌려줘야한다.</span>
          <span class="c1">// -&gt; 누적해가면서 &lt;2변수를 비교후 큰값을 남기기&gt;가 max값이다.</span>
          <span class="c1">// --&gt; Integer였다면  a &gt; b ? a : b 의 3항연산자를 써서 (비교후 t/f별 return) 했을 것이다.</span>
          <span class="c1">//.reduce((a,b) -&gt; a &gt; b ? a : b)</span>
          <span class="c1">// -&gt; 하지만, 제네릭을 통해 아무Type T -&gt; [부등호를 통한 숫자비교]이외의 비교를 위해서</span>
          <span class="c1">// --&gt; Comparable 구현으로 제한한 Type에 대해 compareTo로 비교한다.</span>
          <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="o">)</span>
          <span class="c1">//2-3.stream에 원소가 없을 경우 optional로 반환하는데, get()을 통해 값만 강제로 꺼낼 수 도 있다.</span>
          <span class="c1">// -&gt; 값이 없는데 get을 시도했을 때 예외가 발생하는데, 이것은 자연스런 예외라고 생각할 수 있다.</span>
          <span class="c1">// NoSuchElementException: No value present</span>
          <span class="c1">// default값이나 or 특정예외를 발생시키는 코드를 작성안해도, 없는 값 get시도시 예외는 자연스러운 것으로 봐도 된다.</span>
          <span class="o">.</span><span class="na">get</span><span class="o">();</span>
  <span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>(stream안썼으면) 내부에서 T가 사용되는 상황(stream으로는 개별원소에 접근하는 상황)이므로 <code class="language-plaintext highlighter-rouge">&lt;T&gt; 대신 &lt;?&gt; = 추상체 자체기능 + Object의기능만 사용</code>은 불가능한 지네릭 메소드여야만 한다</strong></p>

    <ul>
      <li><strong>하지만 <code class="language-plaintext highlighter-rouge">와일드카드가 끼어들만 여지</code>가 남겨져있다</strong></li>
    </ul>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="no">T</span> <span class="nf">max</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
         <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="o">)</span>
         <span class="o">.</span><span class="na">get</span><span class="o">();</span>
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>위에서 보는 것처럼</p>

    <ol>
      <li>
        <p><strong>내부에서 개별적으로 사용되는 <code class="language-plaintext highlighter-rouge">메서드 파라미터 속 List&lt;T&gt;</code>에서의 <code class="language-plaintext highlighter-rouge">T</code>는 <code class="language-plaintext highlighter-rouge">a.비교메서드( b )</code>에서 a와 b  자리에는 T type대신 <code class="language-plaintext highlighter-rouge">SubType</code>도 들어가서 비교될 수 있기 때문에 T의 subtype을 의미하는 <code class="language-plaintext highlighter-rouge">List&lt;? extends T&gt;</code>를 대신사용할 수 있다.</strong></p>
      </li>
      <li>
        <p><strong>외부 Comparable 클래스에서 compareTo정의시 사용될 <code class="language-plaintext highlighter-rouge">Comparable&lt;T&gt;</code>의 T는 <code class="language-plaintext highlighter-rouge">비교메서드를 구성</code>하는 Type이라고 볼 수 있다.</strong></p>

        <ul>
          <li>Integer끼리의 비교는 a - b 처럼 compareTo가 간단하게 구성될지 몰라도</li>
          <li><strong>어느타입이든 비교되려면, <code class="language-plaintext highlighter-rouge">Object객체 2개를 비교</code>할 수 있는 compareTo가 만들어져야한다.</strong></li>
          <li><strong>그래서 Comparable처럼 <code class="language-plaintext highlighter-rouge">외부에서 사용될 T는 T에 대해 SuperType으로 구성</code>되어도 된다.</strong></li>
        </ul>

        <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;&gt;</span> <span class="no">T</span> <span class="nf">max</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
         <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="o">)</span>
         <span class="o">.</span><span class="na">get</span><span class="o">();</span>
 <span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
  <li>
    <p>바깥에서 쓰는 T의 대한 예시 -&gt; <strong>Collections.max( list  , comparator)</strong></p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
     <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
    
     <span class="c1">//4. 바깥에서 쓰일 Comparable&lt;T&gt;의 T는 &lt;T extends Comparable&lt;? super T&gt;&gt;처럼 SuperType이 들어가도 된다?? 를 증명해보기</span>
     <span class="c1">// 4-1. List 예시는, 자체 comparator가 내부에 내장 되어있어, Comparable를 구현안해도 알아서 집계함수내에서 집계된다.</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Collections.max(list) = "</span> <span class="o">+</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">list</span><span class="o">));</span>
     <span class="c1">// 4-2. 이번엔 비교대상obj의 class가 직접 Comparable을 구현하는 것이 아니라,</span>
     <span class="c1">//      한 단계 위층에서, 직접 2개의 원소를 받아 비교가능하도록 만드는 비교자 Comparator인터페이스를 만드는 경우</span>
     <span class="c1">//      집계메서드의 다음인자로 만들어서 던진다.</span>
     <span class="c1">//Collections.max(list, Comparator) //Comparator의 내부 구현을 보기 위해 잠시 적어두고 타고 들어갔다옴.</span>
     <span class="c1">// -&gt; Comparator은 인터페이스로 증 @FunctionalInterface로서, 외부에서 인자를 던질 때, 람다식으로 구현가능하다.</span>
     <span class="c1">// --&gt; int compare(T o1, T o2); 파라미터 2개 -&gt; (a,b)로 시작 &amp;&amp;  응답 int -&gt; 1개 int로 나오도록 람다식 마무리</span>
     <span class="c1">//Collections.max(list, (a, b) -&gt; a - b );</span>
     <span class="c1">// ---&gt; 그러나, T 타입을 받아 비교하도록 되어있으므로 [람다식의 Type paramter 다운? 캐스팅]을 사용할 수 있다.</span>
     <span class="c1">//     cf) 람다식은 타입을 캐스팅할 수 있는 것이 장점이라고 한다.</span>
     <span class="c1">// ----&gt; Integer List의 원소들끼리 비교라면, Compator&lt;Integer&gt;로 람다식의 T타입을 캐스팅해서 쓰면 되지만</span>
     <span class="c1">//       여기에서는 지네릭 -&gt; 모든 타입 -&gt; Object로 [람다식 타입 캐스팅]을 시도하여 obj vs obj 비교가 가능하게 한다.</span>
     <span class="c1">// -----&gt; 이렇게 되면, object - object 의 부등호 비교가 말을 안듣게 된다.</span>
     <span class="c1">//Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a - b); // a-b error!</span>
     <span class="c1">// ------&gt; a와 b가 integer가 아니라 object가 되었다고 가정하고</span>
     <span class="c1">//         **object의 공통 .toString()**을 통해 compareTo로 비교한다고 가정하고 작성한다.</span>
     <span class="nc">Collections</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="o">(</span><span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;)</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">toString</span><span class="o">()));</span> <span class="c1">// a-b error!</span>
     <span class="c1">//4-3. 이렇게 2개의 obj로 비교하는 Comparator 인터페이스 구현체를 람다식타입캐스팅해서 인자로 던졌는데 잘 동적을 한다</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
         <span class="s">"Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString())) = "</span>
         <span class="o">+</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="o">(</span><span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;)</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">toString</span><span class="o">())));</span>
     <span class="c1">// 4-4. 여기서 하고 싶은말은, Comparable or Comparator에 붙은 &lt;T&gt;는 비교할 객체 2개의 type이며</span>
     <span class="c1">// -&gt; 그 T에는 SuperType이 와도 된다는 이야기를 하고싶은 것</span>
     <span class="c1">// --&gt; 하위 경계만 list의 T인 Integer로 잡혀있을 뿐 -&gt; ? super T 로서, Integer의 SuperType이 와도 된다.</span>
    
     <span class="c1">//5. 이제 Comparable&lt; ? super T&gt;를 통해 -&gt; compareTo를 사용할 객체는 T보다 더 SuperType 특히, Object를 줘도 가능하다는게 밝혀졌다.</span>
     <span class="c1">// -&gt; Comparable내부 구조를  object. 비교메서드 ( object )로 바꿔놓은 상태다.</span>
     <span class="c1">// 그렇다면, max(final List&lt;? extends T&gt; list) 에서 list의 원소는 [비교될 객체 a, b자리에 구현체 SubType이 들어갈 수 있다]는 어떻게 확인할까?</span>
     <span class="c1">// -&gt; 비교 구조는 SuperType 특히, Object1. 비교메서드 ( Object 2)로 잡힌 상태로서, </span>
     <span class="c1">// --&gt; 각각의 Object1, 2 자리에 SubType(구현체)가 들어가는 것은 자연스러운 일로 이해할 수 있다.</span>
     <span class="c1">// -&gt; SubType의 원소가 비교메서드 자리에 들어갈 수 있는지 판단하려면</span>
     <span class="c1">// ---&gt; max()함수의 T를 Integer의 추상체인 Number로 고정시켜 호출하면,</span>
     <span class="c1">// 파라미터속 T -&gt;  NumberType인데, 인자로 던진 Integer 타입이 들어가도 잘 동작하는 것을 확인할 수 있다.</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
         <span class="s">"Collections.&lt;Number&gt;max(list, (Comparator&lt;Object&gt;)(a,b) -&gt; a.toString().compareTo(b.toString())) = "</span>
         <span class="o">+</span> <span class="nc">Collections</span><span class="o">.&lt;</span><span class="nc">Number</span><span class="o">&gt;</span><span class="n">max</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="o">(</span><span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;)</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">toString</span><span class="o">())));</span>
    
     <span class="c1">//6. 어떨때는 upper bound? 어떨때는 under bound? -&gt; java에서 설명하는 기준이 있다.</span>
     <span class="c1">// 1) 넘기는 파라미터 type이 메서드 내부에서 사용되는 경우 -&gt; 상위경계(upper bound)를 쓰면 되고</span>
     <span class="c1">// 2) 외부에서 정의되는 메서드에 사용될 경우 ex&gt; Comparable내부에서 사용될 T -&gt; 하위 경계(under bound)를 쓰면 된다.</span>
     <span class="c1">// -&gt; 가장 잘보여주는 예가 Collections 내부의 copy()메서드다</span>
     <span class="c1">//  cf) alt+7(Structure)에서 ctrl+f에서 찾아보기</span>
     <span class="c1">// public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {</span>
     <span class="c1">// 소스 src는 안에서 copy메서드 내부에서 소모되는 것이므로 &lt;? extends T&gt; 구현체 와도 된다.</span>
     <span class="c1">// 데스티네이션 dest는 copy메서드 내부에서 [만들어진 뒤 밖으로 내보내 사용 될 것] -&gt; 구조를 추상체로 잡아주도록 &lt;? super T&gt;로 와일드카드를 준다.</span>
     <span class="c1">//  - 안에서 만들어지긴 하지만 ouput으로서 밖에서 사용되는 것임.</span>
     <span class="c1">/// 3) 귀찮으면, 잘모르겠으면 그냥 &lt;T&gt;로만 지정해서 쓰면 된다..</span>
    
 <span class="o">}</span>
    
</code></pre></div>    </div>
  </li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericsWildCard</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
        <span class="c1">//1. list가 들어오면 그 원소들 중 가장 큰 값을 반환하도록 한다. 만든다.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"max(list) = "</span> <span class="o">+</span> <span class="n">max</span><span class="o">(</span><span class="n">list</span><span class="o">));</span>

        <span class="c1">//4. 바깥에서 쓰일 Comparable&lt;T&gt;의 T는 &lt;T extends Comparable&lt;? super T&gt;&gt;처럼 SuperType이 들어가도 된다?? 를 증명해보기</span>
        <span class="c1">// 4-1. List 예시는, 자체 comparator가 내부에 내장 되어있어, Comparable를 구현안해도 알아서 집계함수내에서 집계된다.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Collections.max(list) = "</span> <span class="o">+</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">list</span><span class="o">));</span>
        <span class="c1">// 4-2. 이번엔 비교대상obj의 class가 직접 Comparable을 구현하는 것이 아니라,</span>
        <span class="c1">//      한 단계 위층에서, 직접 2개의 원소를 받아 비교가능하도록 만드는 비교자 Comparator인터페이스를 만드는 경우</span>
        <span class="c1">//      집계메서드의 다음인자로 만들어서 던진다.</span>
        <span class="c1">//Collections.max(list, Comparator) //Comparator의 내부 구현을 보기 위해 잠시 적어두고 타고 들어갔다옴.</span>
        <span class="c1">// -&gt; Comparator은 인터페이스로 증 @FunctionalInterface로서, 외부에서 인자를 던질 때, 람다식으로 구현가능하다.</span>
        <span class="c1">// --&gt; int compare(T o1, T o2); 파라미터 2개 -&gt; (a,b)로 시작 &amp;&amp;  응답 int -&gt; 1개 int로 나오도록 람다식 마무리</span>
        <span class="c1">//Collections.max(list, (a, b) -&gt; a - b );</span>
        <span class="c1">// ---&gt; 그러나, T 타입을 받아 비교하도록 되어있으므로 [람다식의 Type paramter 다운? 캐스팅]을 사용할 수 있다.</span>
        <span class="c1">//     cf) 람다식은 타입을 캐스팅할 수 있는 것이 장점이라고 한다.</span>
        <span class="c1">// ----&gt; Integer List의 원소들끼리 비교라면, Compator&lt;Integer&gt;로 람다식의 T타입을 캐스팅해서 쓰면 되지만</span>
        <span class="c1">//       여기에서는 지네릭 -&gt; 모든 타입 -&gt; Object로 [람다식 타입 캐스팅]을 시도하여 obj vs obj 비교가 가능하게 한다.</span>
        <span class="c1">// -----&gt; 이렇게 되면, object - object 의 부등호 비교가 말을 안듣게 된다.</span>
        <span class="c1">//Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a - b); // a-b error!</span>
        <span class="c1">// ------&gt; a와 b가 integer가 아니라 object가 되었다고 가정하고</span>
        <span class="c1">//         **object의 공통 .toString()**을 통해 compareTo로 비교한다고 가정하고 작성한다.</span>
        <span class="nc">Collections</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="o">(</span><span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;)</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">toString</span><span class="o">()));</span> <span class="c1">// a-b error!</span>
        <span class="c1">//4-3. 이렇게 2개의 obj로 비교하는 Comparator 인터페이스 구현체를 람다식타입캐스팅해서 인자로 던졌는데 잘 동적을 한다</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
            <span class="s">"Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString())) = "</span>
                <span class="o">+</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="o">(</span><span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;)</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">toString</span><span class="o">())));</span>
        <span class="c1">// 4-4. 여기서 하고 싶은말은, Comparable or Comparator에 붙은 &lt;T&gt;는 비교할 객체 2개의 type이며</span>
        <span class="c1">// -&gt; 그 T에는 SuperType이 와도 된다는 이야기를 하고싶은 것</span>
        <span class="c1">// --&gt; 하위 경계만 list의 T인 Integer로 잡혀있을 뿐 -&gt; ? super T 로서, Integer의 SuperType이 와도 된다.</span>

        <span class="c1">//5. 이제 Comparable&lt; ? super T&gt;를 통해 -&gt; compareTo를 사용할 객체는 T보다 더 SuperType 특히, Object를 줘도 가능하다는게 밝혀졌다.</span>
        <span class="c1">// -&gt; Comparable내부 구조를  object. 비교메서드 ( object )로 바꿔놓은 상태다.</span>
        <span class="c1">// 그렇다면, max(final List&lt;? extends T&gt; list) 에서 list의 원소는 [비교될 객체 a, b자리에 구현체 SubType이 들어갈 수 있다]는 어떻게 확인할까?</span>
        <span class="c1">// -&gt; 비교 구조는 SuperType 특히, Object1. 비교메서드 ( Object 2)로 잡힌 상태로서, </span>
        <span class="c1">// --&gt; 각각의 Object1, 2 자리에 SubType(구현체)가 들어가는 것은 자연스러운 일로 이해할 수 있다.</span>
        <span class="c1">// -&gt; SubType의 원소가 비교메서드 자리에 들어갈 수 있는지 판단하려면</span>
        <span class="c1">// ---&gt; max()함수의 T를 Integer의 추상체인 Number로 고정시켜 호출하면,</span>
        <span class="c1">// 파라미터속 T -&gt;  NumberType인데, 인자로 던진 Integer 타입이 들어가도 잘 동작하는 것을 확인할 수 있다.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
            <span class="s">"Collections.&lt;Number&gt;max(list, (Comparator&lt;Object&gt;)(a,b) -&gt; a.toString().compareTo(b.toString())) = "</span>
                <span class="o">+</span> <span class="nc">Collections</span><span class="o">.&lt;</span><span class="nc">Number</span><span class="o">&gt;</span><span class="n">max</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="o">(</span><span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;)</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">toString</span><span class="o">())));</span>

        <span class="c1">//6. 어떨때는 upper bound? 어떨때는 under bound? -&gt; java에서 설명하는 기준이 있다.</span>
        <span class="c1">// 1) 넘기는 파라미터 type이 메서드 내부에서 사용되는 경우 -&gt; 상위경계(upper bound)를 쓰면 되고</span>
        <span class="c1">// 2) 외부에서 정의되는 메서드에 사용될 경우 ex&gt; Comparable내부에서 사용될 T -&gt; 하위 경계(under bound)를 쓰면 된다.</span>
        <span class="c1">// -&gt; 가장 잘보여주는 예가 Collections 내부의 copy()메서드다</span>
        <span class="c1">//  cf) alt+7(Structure)에서 ctrl+f에서 찾아보기</span>
        <span class="c1">// public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {</span>
        <span class="c1">// 소스 src는 안에서 copy메서드 내부에서 소모되는 것이므로 &lt;? extends T&gt; 구현체 와도 된다.</span>
        <span class="c1">// 데스티네이션 dest는 copy메서드 내부에서 [만들어진 뒤 밖으로 내보내 사용 될 것] -&gt; 구조를 추상체로 잡아주도록 &lt;? super T&gt;로 와일드카드를 준다.</span>
        <span class="c1">//  - 안에서 만들어지긴 하지만 ouput으로서 밖에서 사용되는 것임.</span>
        <span class="c1">/// 3) 귀찮으면, 잘모르겠으면 그냥 &lt;T&gt;로만 지정해서 쓰면 된다..</span>

    <span class="o">}</span>

    <span class="c1">//3. 내부T 안쓴 것처럼 보이지만, stream -&gt; 개별 원소 접근 -&gt; T쓴 것 과 마찬가지로 wildcard로 변환 불가능.의 상태이다.</span>
    <span class="c1">//3-1. 비교메서드compareTo() 의 사용은 T type 원소뿐만 아니라, T의 SubType들도 인자로 들어와 비교될 수 있다.</span>
    <span class="c1">//     비교메서드의 인자뿐만 아니라 컬렉선&lt;T&gt;에서 각 원소가 [메서드 내부에서 사용=소모]되는 경우라면 [와일드카드를 사용한 upper bound type paramter]로 넘긴다는 가이드라인 있다.</span>
    <span class="c1">//     -&gt; 메서드 파라미터의 [개별 원소가 메서드 내부에 사용되는 컬렉션의 type parameter] List&lt;T&gt; -&gt; List&lt;? extends T&gt;</span>
<span class="c1">//    private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;T&gt; list) {</span>
    <span class="c1">//3-2. 반대로, Comparable&lt;T&gt;에 걸린 T는 메서드내부에서 정해져 사용되지 않고, 메서드 밖에서 사용되는 Type paramter라서</span>
    <span class="c1">//  -&gt; lower bound로 정의해준다.</span>
<span class="c1">//    private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;? extends T&gt; list) {</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;&gt;</span> <span class="no">T</span> <span class="nf">max</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="o">)</span>
            <span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">//2. 원래는 Integer부터 만들어야 정상이지만, 제네릭을 계속 썼다보니 제네릭 메소드로 만들어보자.</span>
    <span class="c1">//private static &lt;T&gt; void max(final List&lt;T&gt; list) {</span>
    <span class="c1">//2-2. 제네릭 메서드의 type parameter에서  upper bound는 파라미터 자리가 아닌 [응답형 앞]에서 준다.</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="no">T</span> <span class="nf">max2</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
            <span class="c1">//2-1. max를 loop를 구할 땐, 가장 작은값을 후보 변수에 세팅 -&gt; 계속 업데이트하면서 구하는데, stream으로는?</span>
            <span class="c1">// -&gt; reduce의 2번째 방식(초기값 identity 따로 안주고 첫+둘 -&gt; 합+셋 -&gt; 순으로 연산 하기위해)으로 작성해보자.</span>
            <span class="c1">// -&gt; 연산후 연산결과의 Type이 현재 원소들과 같은 Type으로 되돌려줘야한다.</span>
            <span class="c1">// -&gt; 누적해가면서 &lt;2변수를 비교후 큰값을 남기기&gt;가 max값이다.</span>
            <span class="c1">// --&gt; Integer였다면  a &gt; b ? a : b 의 3항연산자를 써서 (비교후 t/f별 return) 했을 것이다.</span>
            <span class="c1">//.reduce((a,b) -&gt; a &gt; b ? a : b)</span>
            <span class="c1">// -&gt; 하지만, 제네릭을 통해 아무Type T -&gt; [부등호를 통한 숫자비교]이외의 비교를 위해서</span>
            <span class="c1">// --&gt; Comparable 구현으로 제한한 Type에 대해 compareTo로 비교한다.</span>
            <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="o">)</span>
            <span class="c1">//2-3.stream에 원소가 없을 경우 optional로 반환하는데, get()을 통해 값만 강제로 꺼낼 수 도 있다.</span>
            <span class="c1">// -&gt; 값이 없는데 get을 시도했을 때 예외가 발생하는데, 이것은 자연스런 예외라고 생각할 수 있다.</span>
            <span class="c1">// NoSuchElementException: No value present</span>
            <span class="c1">// default값이나 or 특정예외를 발생시키는 코드를 작성안해도, 없는 값 get시도시 예외는 자연스러운 것으로 봐도 된다.</span>
            <span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="와일드카드-사용시-캡처-문제">
<a class="anchor" href="#%EC%99%80%EC%9D%BC%EB%93%9C%EC%B9%B4%EB%93%9C-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%BA%A1%EC%B2%98-%EB%AC%B8%EC%A0%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>와일드카드 사용시 캡처 문제</h4>

<ol>
  <li>
    <p>reverse
 <img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220508144038502.png" alt="image-20220508144038502"></p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericsCapture</span> <span class="o">{</span>
     <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    
         <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
         <span class="c1">//1. 이번엔 어느타입의 list든 revese시키는 함수를 만들어보자.</span>
         <span class="c1">// -&gt; 제일 쉽게 구현하는 것은 list를 1개 temp에 방어적 복사(새로운 list로 복제)해놓고,</span>
         <span class="c1">// -&gt; i번째에, temp에서는 n-i-1번재로 뒤에서부터 꺼내서, 원본 list값을 바꿔버리는(set) 전략이다.</span>
         <span class="n">reverse</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
    
         <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"list = "</span> <span class="o">+</span> <span class="n">list</span><span class="o">);</span>
     <span class="o">}</span>
    
     <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
         <span class="c1">//2. reverse전략: temp list 1개를 방어적 복사 -&gt; index를 돌면서 뒤에서부터 temp에서 꺼낸 값을 -&gt; 원본 list의 값에 set</span>
         <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">list</span><span class="o">);</span>
    
         <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
             <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">temp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
         <span class="o">}</span>
     <span class="o">}</span>
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>List<t>는 사용됬지만, 개별원소 T t의 type관련 기능이 사용되지 않았다.</t></p>

    <ul>
      <li>T type정보가 내부에서 의미있게 사용되는가?
        <ul>
          <li>생성자에 list집어넣기 / size / get in List/ set in List -&gt; 전부 List자체 기능</li>
        </ul>
      </li>
      <li>
        <p><strong>type paramter대신 와일드카드 사용가능하다</strong></p>

        <ul>
          <li>응답형 앞에 T 삭제</li>
          <li>type parameter <code class="language-plaintext highlighter-rouge">List&lt;T&gt;</code>를  <code class="language-plaintext highlighter-rouge">List&lt;?&gt;</code>대체하기</li>
        </ul>
      </li>
      <li>
        <p><strong>와일드 카드로 바꿔줬더니, <code class="language-plaintext highlighter-rouge">capture</code>에러가 뜬다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220508150715899.png" alt="image-20220508150715899"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>와일드카드로 Type을 모르고 관심없다고 했는데 <code class="language-plaintext highlighter-rouge">그 ?의 Type을 추론해야하는 상황</code> = 캡처의 상황이 찾아오기도 한다</strong></p>
    <ul>
      <li>캡처=와일드카드의 타입추론</li>
      <li><strong>listd에 .set을 할려고보니, temp에서 꺼내온 Type을 어떤 형으로 정해서 넣어줘야하지? 모르는 상황</strong></li>
    </ul>
  </li>
</ol>

<h5 id="다시-지네릭메서드로-돌아가도-되지만-자바-설계상-헬퍼메서드를-만들어준다">
<a class="anchor" href="#%EB%8B%A4%EC%8B%9C-%EC%A7%80%EB%84%A4%EB%A6%AD%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EB%8F%8C%EC%95%84%EA%B0%80%EB%8F%84-%EB%90%98%EC%A7%80%EB%A7%8C-%EC%9E%90%EB%B0%94-%EC%84%A4%EA%B3%84%EC%83%81-%ED%97%AC%ED%8D%BC%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A4%80%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>다시 지네릭메서드로 돌아가도 되지만, 자바 설계상 헬퍼메서드를 만들어준다</h5>

<ol>
  <li>
    <p>reverse()메소드 내부에 <code class="language-plaintext highlighter-rouge">private revserseHelper( list )</code>메소드를 만들고, <strong>지네릭메소드로 돌린 코드를 helper메서드에 넣어준다.</strong></p>

    <ul>
      <li><strong>구조상 원본메서드는 <code class="language-plaintext highlighter-rouge">List&lt;?&gt; list</code>의 와일드카드를 사용중이고</strong></li>
      <li><strong>내부 helper메서드는 와일드카드 list를 던졌는데 -&gt; 파라미터는 <code class="language-plaintext highlighter-rouge">List&lt;T&gt; list</code>의 지네릭 메서드를 사용하게 된다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220508151256874.png" alt="image-20220508151256874">
 <img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220508151409703.png" alt="image-20220508151409703"></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">List&lt;?&gt; list</code> -&gt; <code class="language-plaintext highlighter-rouge">List&lt;T&gt; list</code> <strong>메서드에 대입이 가능한가?</strong></p>

    <ul>
      <li>SubType 인자만 -&gt; SuperType파라미터가 받을 수 있을 텐데?
        <ul>
          <li>일치하거나 List<t> 가 ?의 SuperType(추상체)여야 인자로 던지기 가능함</t>
</li>
        </ul>
      </li>
      <li>
<strong>사실 그런관계는 없다. 그러나 컴파일러가 자동으로 ? -&gt; T 대입시 T로 캡쳐를 해준다고 한다.</strong>
        <ul>
          <li>why 이런구조를 쓸까? 그냥 지네릭 메서드를 쓰면 편할텐데
            <ul>
              <li><strong>T라는 type도 내부구현으로서 감출 수 있으면 감추기 위해</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericsCapture</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
        <span class="n">reverse</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"list = "</span> <span class="o">+</span> <span class="n">list</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">reverseHelper</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">reverseHelper</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">list</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">temp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>와일드카드로 변환했는데, 구체적인 Type정보가 필요한 코드를 만나서 캡처문제가 발생했구나</strong> 정도로 이해하고 있으면 된다.</p>
  </li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericsCapture</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
        <span class="c1">//1. 이번엔 어느타입의 list든 revese시키는 함수를 만들어보자.</span>
        <span class="c1">// -&gt; 제일 쉽게 구현하는 것은 list를 1개 temp에 방어적 복사(새로운 list로 복제)해놓고,</span>
        <span class="c1">// -&gt; i번째에, temp에서는 n-i-1번재로 뒤에서부터 꺼내서, 원본 list값을 바꿔버리는(set) 전략이다.</span>
        <span class="n">reverse</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"list = "</span> <span class="o">+</span> <span class="n">list</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//3. List&lt;T&gt;는 사용됬지만, 개별원소 T t의 type관련 기능이 사용되지 않았다.</span>
    <span class="c1">// -&gt; T type정보가 내부에서 의미있게 사용되는가?</span>
    <span class="c1">// 생성자에 list집어넣기 / size / get in List/ set in List -&gt; 전부 List자체 기능</span>
    <span class="c1">// -&gt; type paramter대신 와일드카드 사용가능하다</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//2. reverse전략: temp list 1개를 방어적 복사 -&gt; index를 돌면서 뒤에서부터 temp에서 꺼낸 값을 -&gt; 원본 list의 값에 set</span>
        <span class="c1">//        final List&lt;?&gt; temp = new ArrayList&lt;&gt;(list);</span>
        <span class="c1">//</span>
        <span class="c1">//        for (int i = 0; i &lt; list.size(); i++) {</span>
        <span class="c1">//            list.set(i, temp.get(list.size() - i - 1));</span>
        <span class="c1">//        }</span>
        <span class="c1">//4. 지네릭 -&gt;와일드카드로 변환시 캡처 문제가 발생할 경우, private helper메서드를 만들고</span>
        <span class="c1">// 그 내부를 다시 지네릭메서드로 돌린다.</span>
        <span class="n">reverseHelper</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//5.  List&lt;?&gt; list -&gt; final List&lt;T&gt; list 메서드에 대입이 가능한가?</span>
    <span class="c1">// -&gt; SubType 인자만 -&gt; SuperType파라미터가 받을 수 있을 텐데?</span>
    <span class="c1">// (일치하거나 List&lt;T&gt; 가 ?의 SuperType(추상체)여야 인자로 던지기 가능함)</span>
    <span class="c1">// --&gt; 사실 그런관계는 없다. 그러나 컴파일러가 자동으로 ? -&gt; T 대입시 T로 캡쳐를 해준다고 한다.</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">reverseHelper</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">list</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">temp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="lambda">
<a class="anchor" href="#lambda" aria-hidden="true"><span class="octicon octicon-link"></span></a>Lambda</h4>

<ol>
  <li>
    <p>람다식을 인자로 받는 메서드를 만들고</p>

    <p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220508153348072.png" alt="image-20220508153348072"></p>

    <p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220508153405247.png" alt="image-20220508153405247"></p>
  </li>
  <li>
    <p><strong>인자의 빨간줄은 <code class="language-plaintext highlighter-rouge">파라미터를 뭘로 바꾸면 람다식 인자가 사라질까?</code></strong></p>

    <ul>
      <li>
        <p><strong>IDE가 아직 람다식을 <code class="language-plaintext highlighter-rouge">java.util.Function</code>으로는 <code class="language-plaintext highlighter-rouge">파라미터 자동생성</code>을 안해준다.</strong>
  <img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220508153508511.png" alt="image-20220508153508511"></p>

        <p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220508153521391.png" alt="image-20220508153521391"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>해석해보기</strong></p>

    <ol>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">Function</code>은 <code class="language-plaintext highlighter-rouge">람다식 구현을 하나의 구현체 인자</code>로 받는 <code class="language-plaintext highlighter-rouge">변수/파라미터 속 추상체이자 인터페이스</code>이다.</strong></p>
      </li>
      <li>
        <p>내부를 보면, 메서드가 1개만 있는 함수형인터페이스다</p>

        <ul>
          <li>
<strong><code class="language-plaintext highlighter-rouge">람다식으로 구현 가능</code> == 인터페이스에 구현해야할 함수가 1개만 있어서 그자리에서 구현 == 함수형 인터페이스</strong>
  <img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220508153732391.png" alt="image-20220508153732391">
</li>
        </ul>
      </li>
      <li>
        <p>**그렇다면 <code class="language-plaintext highlighter-rouge">람다식</code> <code class="language-plaintext highlighter-rouge">구현</code> 자체가 <code class="language-plaintext highlighter-rouge">메서드 1개인 인터페이스</code>의 <code class="language-plaintext highlighter-rouge">구현체</code>가 되어, 인터페이스(추상체)를 파라미터로 받는 메서드의 인자로서  구현체로서 던져진다. **</p>

        <p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220508153914582.png" alt="image-20220508153914582"></p>
      </li>
      <li>
        <p><strong>함수형인터페이스는 <code class="language-plaintext highlighter-rouge">지네릭 인터페이스</code>로서, <code class="language-plaintext highlighter-rouge">인자/응답의 type paramter를 지정한 메서드 파라미터</code>로 지정할 수 있다.</strong>
 <img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220508164449665.png" alt="image-20220508164449665"></p>

        <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(</span><span class="kd">final</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        
 <span class="o">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">람다식 구현 인자를 받는 함수형인페</code>에 제네릭 type parameter여부는 <code class="language-plaintext highlighter-rouge">parameter hint</code>로 확인하면서 람다식을 구현하면 된다.</strong></p>
      </li>
    </ol>

    <p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220508164319419.png" alt="image-20220508164319419"></p>
  </li>
</ol>

<h5 id="람다식-구현-이전-익명클래스로-구현">
<a class="anchor" href="#%EB%9E%8C%EB%8B%A4%EC%8B%9D-%EA%B5%AC%ED%98%84-%EC%9D%B4%EC%A0%84-%EC%9D%B5%EB%AA%85%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C-%EA%B5%AC%ED%98%84" aria-hidden="true"><span class="octicon octicon-link"></span></a>람다식 구현 이전, 익명클래스로 구현</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//4. 사실 람다식을 -&gt; 익명클래스라는 [인터페이스를 객체처럼 생성후 -&gt; 중괄호로 그자리에서 인터페이스속 1개 메서드를 Override구현]한 뒤, 변수 추출하여, 익클로 구현 변수를 함수형 인터페이스 인자 자리에 넣어줄 수 있다.</span>
<span class="c1">//new Function&lt;String, String&gt;(){}</span>
<span class="c1">// -&gt; generate -&gt; impl method</span>
<span class="c1">//        new Function&lt;String, String&gt;(){</span>
<span class="c1">//            @Override</span>
<span class="c1">//            //4-1. 그자리에서 구현했지만, 들어오는 인자는 s</span>
<span class="c1">//            public String apply(final String s) {</span>
<span class="c1">//                //4-2. 그자리에서 구현했지만, 응답값은 s</span>
<span class="c1">//                return s;</span>
<span class="c1">//            }</span>
<span class="c1">//        };</span>
<span class="c1">// 4-3. 인터페이스를 객체처럼 -&gt; {}중괄호 그자리 구현 했다면 -&gt; 그것을 사용하기 위해선 -&gt; 익클은 변수 추출로 빼야한다.</span>
<span class="kd">final</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">function</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Function</span><span class="o">&lt;&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">apply</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">};</span>
<span class="c1">// 4-4. 이제 익클로 구현한 function를 람다식이 있던 자리 == 함수형인터페이스를 파라미터로 받는 메서드(인자) 자리에 넣어줄 수 있다.</span>
<span class="c1">// -&gt; 그러면 내부에서 apply가 자동으로 호출된다.?!</span>
<span class="c1">//hello(function);</span>
<span class="c1">// 4-5. 하지만, 메소드1개인 함수형 인터페이스의 구상체 구현은 익클구현보다는, 람다식으로 해당 메서드를 구현하면 된다.</span>
<span class="n">hello</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">);</span>
</code></pre></div></div>

<ul>
  <li>
    <p>익명 클래스 구현 -&gt; 람다식 구현으로 옮겨오는 과정</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="c1">//5. 메소드1개 인터페이스의 익명클래 구현에서</span>
  <span class="c1">// 1) 익명클래스 관련 코드 삭제(new ~ @Override)</span>
  <span class="c1">// 2) 응답형은 알아서 추론&lt;, R&gt;</span>
  <span class="c1">// 3) 메서드명 필요없어 삭제</span>
  <span class="c1">// 하면 아래와 같다</span>
  <span class="n">hello</span><span class="o">(</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">)</span> <span class="o">-&gt;{</span>
      <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
  <span class="o">}</span> <span class="o">);</span>
  <span class="c1">// 4) 지네릭을 쓰는 함수형인페에서 이미 인자의 type을 정해놨을 것이므로</span>
  <span class="c1">// -&gt; 인자 type도 추론 가능해서 삭제</span>
  <span class="c1">// 5) 응답쪽 statement가 1줄인 경우, 중괄호 + return + 세미콜론 생략</span>
  <span class="n">hello</span><span class="o">(</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">);</span>
</code></pre></div>    </div>

    <ul>
      <li>cf) type추론은 compile time에 이루어진다.</li>
    </ul>
  </li>
</ul>

<h4 id="intersectiontype-기본">
<a class="anchor" href="#intersectiontype-%EA%B8%B0%EB%B3%B8" aria-hidden="true"><span class="octicon octicon-link"></span></a>IntersectionType 기본</h4>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">람다식 구현</code>인자를 받는 <code class="language-plaintext highlighter-rouge">함수형인페 파라미터</code>의 메서드를 쓰는 데, <code class="language-plaintext highlighter-rouge">마커 인터페이스를 붙여야할 경우</code>가 생긴다면</strong></p>

    <ol>
      <li>
        <p><strong>해당 메서드의 파라미터를 <code class="language-plaintext highlighter-rouge">Function t</code> -&gt;  <code class="language-plaintext highlighter-rouge">T t</code>를 받는 제네릭메서드로 바꾸고</strong></p>
      </li>
      <li><strong>upper bound를 <code class="language-plaintext highlighter-rouge">&lt;T extends Function&gt;</code>으로 준다.</strong></li>
      <li>
<strong>이제type parameter에 <code class="language-plaintext highlighter-rouge">&lt;T extends 함수형인페 &amp; 마커인터페이스&gt;</code>형식</strong>으로 intersectionType type parameter를 사용해서 <strong><code class="language-plaintext highlighter-rouge">상한시 요구되는 타입을 여러 interface를 섞어 제한</code>하면 된다.</strong>
</li>
    </ol>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericsIntersectionType</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//1. [람다식 구현]을 인자로 받는 [메서드]를 만들자.</span>
        <span class="c1">// -&gt; why? 람다식 구현을 받는 추상체 파라미터는 [메소드 1개의 함수형인페 구현을 받아주는 중 &amp;&amp; 인자-&gt;응답T를 지네릭으로 정의]해놓았기 때문이다.</span>
        <span class="c1">// cf) 람다식으로 구현해도, 익명클래스는 아니지만, 비슷한 클래스가 내부에 정의되서 익클처럼 작동한다...</span>
        <span class="n">hello</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">);</span>

        <span class="c1">//3. 람다식은 앞에 (소괄호를 통한 타입 캐스팅)이 가능하다고 했다.</span>
        <span class="c1">// -&gt; type없이 캐스팅을 해줘도 된다. 불필요 하지만..</span>
        <span class="n">hello</span><span class="o">((</span><span class="nc">Function</span><span class="o">)</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">);</span>

        <span class="c1">//4. 람다식의 캐스팅은 사실 intersectionType을 위해 사용된다.</span>
        <span class="c1">// -&gt; 메서드 1개는 이미 함수형인페것을 구현하고 있는 람다식이지만</span>
        <span class="c1">// --&gt; 메서드가 내부에 없는 marker interface를 &amp;를 통해 추가 구현한다는 개념이다.</span>
        <span class="c1">// 대표적인 marker interface를 [Serializable]로 생각하자.</span>
        <span class="c1">// impl Comparable처럼, impl Serializable을 하면 -&gt; [파일/네트워크에서 직렬화 가능한 class임을 마킹]하는 인터페이스다.</span>
        <span class="c1">// impl로 구현즉시, instanceof로 확인해보면, Serializable Type이 되어버린다.</span>
        <span class="c1">// -&gt; Type만 가지고도 전송가능한지 확인할 수 있어서 좋다.</span>

        <span class="c1">// 5. 람다식 구현 유지조건은, intersectionType을 사용하더라도, 총 구현 메서드가 1개기만 하면 된다.</span>
        <span class="c1">// 1 &amp; 0 &amp; 1 -&gt; 람다식구현에서 에러가 난다. 람다식은 메서드 1개만 구현</span>
        <span class="c1">//hello((Function &amp; Serializable &amp; Closeable) s -&gt; s);</span>
        <span class="c1">// 1 &amp; 0</span>
        <span class="c1">// -&gt; 내부적으로 class를 정의하는데, 3가지 인터페이스를 모두 impl한 class를 정의함.</span>
        <span class="n">hello</span><span class="o">((</span><span class="nc">Function</span> <span class="o">&amp;</span> <span class="nc">Serializable</span><span class="o">)</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">);</span>

    <span class="o">}</span>

    <span class="c1">//2. 이번엔 함수형인페속 type paramter를 지금 정의하지 않았고 -&gt; raw type으로 지네릭 인터페이스를 사용한다.</span>
    <span class="c1">// -&gt; 이 경우, &lt;T, R&gt; 자리에는 &lt;Object, Object&gt;가 들어가 있다.</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(</span><span class="kd">final</span> <span class="nc">Function</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">(</span><span class="s">"GenericsIntersectionType#hello not write."</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="c1">//6. [람다식구현을 받는 함수형인페 Type]의 메서드 파라미터(final Function o)에다가</span>
    <span class="c1">// -&gt; bounded type parameter으로 명시되는 제네릭 메서드(T o)로 변환할 수 있다.</span>
    <span class="c1">// -&gt; 원래는 지네릭메서드를 고려할 땐, 어느타입이든 받을 수 있게 T로 놓았지만</span>
    <span class="c1">// -&gt; 여기서는 [직렬화가능한 &amp; 람다식 구현]을 인자로 넘기는 경우가 있으며, 그 때 제한을 걸어줄 때</span>
    <span class="c1">// --&gt; 여기선 최소 해당조건을 구현하거나 그 자식 구현체로 제한하는 Type을 type parameter로 넣어준다.</span>
    <span class="c1">// ---&gt; 이렇게 할 경우 class Myclass implements Function, Serializeable의 여러 인터페이 구현한 클래스의 객체를 생성할 필요가 없어진다.</span>
    <span class="c1">//-&gt; 요약) 마커인터페이스를 붙일 필요가 있는데, 람다식으로 간결하고 표현하고 싶다 -&gt; 지네릭 메서드를 intersectionalType을 써서 정의해라</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Function</span> <span class="o">&amp;</span> <span class="nc">Serializable</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">hello2</span><span class="o">(</span><span class="kd">final</span> <span class="no">T</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">(</span><span class="s">"GenericsIntersectionType#hello not write."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<ul>
  <li>그러나 요즘 직렬화가능한 것을 넘겨주는 것은 잘안한다고 한다.</li>
  <li><strong>새로운 class를 만들지 않고도, <code class="language-plaintext highlighter-rouge">IntersectionType을 통한 인터페이스 조합</code>을 통해  <code class="language-plaintext highlighter-rouge">새로운 class = 새로운 익명의 Type</code>을 만들어내는 효과를 만들어낼 수 있다.</strong></li>
</ul>

<h4 id="intersectiontype으로-marker-interface의-default-method을-합친-익명-객체-만들어보기제한점-존재">
<a class="anchor" href="#intersectiontype%EC%9C%BC%EB%A1%9C-marker-interface%EC%9D%98-default-method%EC%9D%84-%ED%95%A9%EC%B9%9C-%EC%9D%B5%EB%AA%85-%EA%B0%9D%EC%B2%B4-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EA%B8%B0%EC%A0%9C%ED%95%9C%EC%A0%90-%EC%A1%B4%EC%9E%AC" aria-hidden="true"><span class="octicon octicon-link"></span></a>IntersectionType으로 marker interface의 default method을 합친 익명 객체 만들어보기(제한점 존재)</h4>

<ul>
  <li>기존 함수형인페의 기능(apply) + 마커인페의 default method들의 기능을 모두 합쳐서 가지고 있는 새로운 객체가 생성된다.
    <ul>
      <li>문제점: <strong>람다식구현 인자 던질 때 <code class="language-plaintext highlighter-rouge">캐스팅</code> 해준 만큼 -&gt;  제네릭 메서드의 <code class="language-plaintext highlighter-rouge">상한에도 또 명시</code></strong>
</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericsIntersectionType2</span> <span class="o">{</span>
    <span class="c1">//1. 새로운 default메서드만 가지는 인터페이스를 하나 생성한다.</span>
    <span class="kd">interface</span> <span class="nc">Hello</span> <span class="o">{</span>
        <span class="c1">//2. 인터페이스안에는 default 메서드를 1개 만들어 -&gt; 부연코드를 넣을 수 있다(아니면 다 공통 추상메서드만 있어야함)</span>
        <span class="c1">// -&gt; 제한이 있긴하다 (상속x/ public만/ 필드정의 후 사용x)</span>
        <span class="c1">// -&gt; 가능한 것 : 인터페이스 내 추상메서드 / static메서드 호출 가능</span>
        <span class="k">default</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//2. 또 default메서드만 가지는 인터페이스를 하나 생성</span>
    <span class="kd">interface</span> <span class="nc">Hi</span> <span class="o">{</span>
        <span class="k">default</span> <span class="kt">void</span> <span class="nf">hi</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hi"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//3. 람다식 구현을 인자로받는 [함수형인터페이스]를 파라미터로 받는 메서드를 정의한다.</span>
        <span class="c1">//hello( s -&gt; s);</span>
        <span class="c1">//4. 람다식 구현은, 해당 추상체인 [함수형인페]로 캐스팅할 수 있다</span>
<span class="c1">//        hello((Function) s -&gt; s);</span>
        <span class="c1">//5. 람다식 구현시 사용하는 캐스팅에 Intersection Type으로서 &amp;로 여러 market 인터페이스를 구현할 수 있다.</span>
        <span class="c1">// -&gt; 람다식 캐스팅은 총 method개수가 1개여야하지만, default method는 0개로 친다!</span>
        <span class="n">hello</span><span class="o">((</span><span class="nc">Function</span> <span class="o">&amp;</span> <span class="nc">Hello</span> <span class="o">&amp;</span> <span class="nc">Hi</span><span class="o">)</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//6. Function 및 그 구상체(람다식구현)만 받았었지만</span>
    <span class="c1">// -&gt; 3개 인터페이스 다 구현한 이후만 받도록 만들기 위해서</span>
    <span class="c1">//private static void hello(final Function function) {</span>
    <span class="c1">// 6-1. 제네릭 메서드로 변환한다. Function function -&gt; T function</span>
    <span class="c1">// 6-2. T에 상한을 Function으로 둔다</span>
    <span class="c1">//private static &lt;T extends Function&gt; void hello(final T function) {</span>
    <span class="c1">// 6-3. T에 상한 인터페이스에다가 &amp; Intersection로 마커인터페이스들을 추가한다.</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Function</span> <span class="o">&amp;</span> <span class="nc">Hello</span> <span class="o">&amp;</span> <span class="nc">Hi</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(</span><span class="kd">final</span> <span class="no">T</span> <span class="n">function</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//6-4. T function는 &lt;Function &amp; Hello &amp; Hi&gt; Type으로 제한된 상태이므로</span>
        <span class="c1">// -&gt; Function이 가지고 있는 apply를 적용할 수 있다.</span>
        <span class="n">function</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="s">"s"</span><span class="o">);</span>
        <span class="c1">// 7. 신기한 점은 market interface내에 있는 default method도 호출이 가능하다는 점이다.</span>
        <span class="c1">// -&gt; 함수형 인터페이스의 기능(apply) + 마커인터페이스의 default method들의 기능을 모두 합침</span>
        <span class="n">function</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
        <span class="n">function</span><span class="o">.</span><span class="na">hi</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">//8. 제네릭메서드의 상한과 insectionType + 인터페이스의 defaul method를 활용하면</span>
    <span class="c1">// -&gt; 기능 자체를 계속 추가해줄 수 있는데,</span>
    <span class="c1">// [문제]는 [1) 람다식구현시 캐스팅 일일히 해놓고] -&gt; 또 호출을 받는 [2) 제네릭 메서드의 upper bound에도 일일히 명시]해줘야하기 때문에</span>
    <span class="c1">// -&gt; 의미가 없다.</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="consumer파라미터-추가를-통한-콜백형식으로-intersectiontype에-기능-하나씩-확장하기제한점-존재">
<a class="anchor" href="#consumer%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-%EC%B6%94%EA%B0%80%EB%A5%BC-%ED%86%B5%ED%95%9C-%EC%BD%9C%EB%B0%B1%ED%98%95%EC%8B%9D%EC%9C%BC%EB%A1%9C-intersectiontype%EC%97%90-%EA%B8%B0%EB%8A%A5-%ED%95%98%EB%82%98%EC%94%A9-%ED%99%95%EC%9E%A5%ED%95%98%EA%B8%B0%EC%A0%9C%ED%95%9C%EC%A0%90-%EC%A1%B4%EC%9E%AC" aria-hidden="true"><span class="octicon octicon-link"></span></a>Consumer파라미터 추가를 통한, 콜백형식으로 IntersectionType에 기능 하나씩 확장하기(제한점 존재)</h4>

<ul>
  <li>각각 따로 기능을 구현한 interface의 method기능들을 모았어도 -&gt; <strong>공통정보를 활용하는 방법이 없으니, 모아도 별로 의미가 없어 보이는 제한점…</strong>
</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericsIntersectionType3</span> <span class="o">{</span>

    <span class="kd">interface</span> <span class="nc">Hello</span> <span class="o">{</span>
        <span class="k">default</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">interface</span> <span class="nc">Hi</span> <span class="o">{</span>
        <span class="k">default</span> <span class="kt">void</span> <span class="nf">hi</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hi"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//1. run이라는 메서드를 만들어 (intersectionType)으로 캐스팅된 람다식구현을 인자로 받는다.</span>
        <span class="c1">//run((Function &amp; Hello &amp; Hi) s -&gt; s);</span>
        <span class="c1">//5. 컨슈머T로 넘어갈 컨슈머용 람다식(인자O -&gt; return값 없는 사용만 우항에 몰빵)</span>
        <span class="n">run</span><span class="o">((</span><span class="nc">Function</span> <span class="o">&amp;</span> <span class="nc">Hello</span> <span class="o">&amp;</span> <span class="nc">Hi</span><span class="o">)</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">,</span> <span class="n">o</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">o</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
            <span class="n">o</span><span class="o">.</span><span class="na">hi</span><span class="o">();</span>
        <span class="o">});</span>
        <span class="c1">//6. 누락된 개념:</span>
        <span class="c1">// 6-1. 제네릭메서드의 상한으로 3개 인페 정의부분을 -&gt; 첫번째 파라미터의 람다식 캐스팅에 의존한다 (컨슈머T는 첫번째 상한제한T를 그대로 이용하기 때문에 다 미리 타입이 추론되어있다)</span>
        <span class="c1">// 6-2. 제네릭메서드 내부에서 호출된 로직을, 바깥의 ConsumerT 구현 람다식으로 뺐다.-&gt; 2번째 인자의 람다식구현 우항(lambda object)</span>
        <span class="c1">//      - 요곤 6-1.을 이용하기 위함함</span>

        <span class="c1">//7. s-&gt;s는 의미가 없다. Function의 람다식구현을 가장 짧게 나타냈을 뿐이다.</span>
        <span class="c1">// -&gt; 주요기능은 intersectionType으로 추가되는 marker 인터페이스의 &lt;default method&gt;기능이다.</span>

        <span class="c1">//9. 새로운 마커인터페이스+그 default method기능을 추가시켜서 사용해보자.</span>
        <span class="c1">// 9-1. 람다식 캐스팅에 추가한다.</span>
        <span class="n">run</span><span class="o">((</span><span class="nc">Function</span> <span class="o">&amp;</span> <span class="nc">Hello</span> <span class="o">&amp;</span> <span class="nc">Hi</span> <span class="o">&amp;</span> <span class="nc">Printer</span><span class="o">)</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">,</span> <span class="n">o</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">o</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
            <span class="n">o</span><span class="o">.</span><span class="na">hi</span><span class="o">();</span>
            <span class="c1">// 9-2. 새로운 default method 기능 추가 사용 in Consumer</span>
            <span class="n">o</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"sadsf"</span><span class="o">);</span>
        <span class="o">});</span>

        <span class="c1">//10. 각자 따로 노는 기능들을 그냥 단순 조합만 하면 무슨 의미가 있을까?</span>
        <span class="c1">// 그냥 static메서드 모아놓은 것과 같은 효과일뿐이다?</span>
        <span class="c1">// -&gt; 1개의 Type안에 method가 여러개다? -&gt;  공유하고 있는 필드정보가 있어야 의미가 있는 것이다.</span>
        <span class="c1">// --&gt; delegate를 활용하여 각각 따로 기능을 구현한 interface가 공통정보를 활용하는 방법이 있다.?!</span>
    <span class="o">}</span>

    <span class="c1">//8. 이제 marker인터페이스 및 default method를 추가하여 새로운 기능을 추가한 Type으로 확장해보자.</span>
    <span class="kd">interface</span> <span class="nc">Printer</span> <span class="o">{</span>
        <span class="k">default</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// cf) 일반 람다식은 파라미터를 함수형인페로 안잡아주는데, 캐스팅하니까 바로 잡아준다.</span>
    <span class="c1">// 2. 일단은 함수형인페 이하로 upper bound를 준 제네릭 메서드로 변경한다.</span>
    <span class="c1">//private static void run(final Function function) {</span>

    <span class="c1">//3. 이번엔 upperbound에 intersection을 거는 것이 아니라</span>
    <span class="c1">// -&gt; [함수형인페 Consumer&lt;T&gt;]를 메소드 파라미터로 추가한다.</span>
    <span class="c1">// --&gt; 컨슈머T(void accept(T t);)는 accept기능을 가지는데, return은 없고 파라미터만 있다</span>
    <span class="c1">// ---&gt; 반대로 Supplier&lt;T&gt;는 get기능을 가지는데, 파라미터는 없고, return만 T type이다.</span>
    <span class="c1">// [컨슈머T를 썼다 -&gt; 뭔가 Lambda object(람다식 구현의 우항)를 갖다주면, &lt;&lt; 그걸 파라미터로 받는 메소드 내부에서 응답없이 .accept( 인자 )로 넘어온 lambda object(우항)을 사용하기만 할 수 있다&gt;&gt; 는 뜻이다]</span>
    <span class="c1">//private static &lt;T extends Function&gt; void run(final T t) {</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Function</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="kd">final</span> <span class="no">T</span> <span class="n">t</span><span class="o">,</span>
                                                 <span class="kd">final</span> <span class="nc">Consumer</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">consumer</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 4. 그렇다면, run내부에서 호출되었던 t.hello();, t.hi();들을</span>
        <span class="c1">// -&gt; consumer 인자부분에서 lambda object(우항)에 담아서 던져주고</span>
        <span class="c1">// consumer.accept(t)로 lambda object(컨슈머 람다식 우항)를 return없이 실행만 시킨다.</span>
        <span class="n">consumer</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="람다식구현-인자용-함수형인페t를-상속한-인터페이스로-default-method내부에서-변경가능한-람다식에-따른-기능-수행하는-메서드가-된다">
<a class="anchor" href="#%EB%9E%8C%EB%8B%A4%EC%8B%9D%EA%B5%AC%ED%98%84-%EC%9D%B8%EC%9E%90%EC%9A%A9-%ED%95%A8%EC%88%98%ED%98%95%EC%9D%B8%ED%8E%98t%EB%A5%BC-%EC%83%81%EC%86%8D%ED%95%9C-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A1%9C-default-method%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EB%B3%80%EA%B2%BD%EA%B0%80%EB%8A%A5%ED%95%9C-%EB%9E%8C%EB%8B%A4%EC%8B%9D%EC%97%90-%EB%94%B0%EB%A5%B8-%EA%B8%B0%EB%8A%A5-%EC%88%98%ED%96%89%ED%95%98%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C%EA%B0%80-%EB%90%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>람다식구현 인자용 <code class="language-plaintext highlighter-rouge">함수형인페&lt;T&gt;</code>를 상속한 인터페이스로, default method내부에서 <code class="language-plaintext highlighter-rouge">변경가능한 람다식</code>에 따른 기능 수행하는 메서드가 된다.</h4>

<p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220509093135784.png" alt="image-20220509093135784"></p>

<p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220509093810775.png" alt="image-20220509093810775"></p>

<p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220509094644938.png" alt="image-20220509094644938"></p>

<p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220509094710244.png" alt="image-20220509094710244"></p>

<p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220509095435303.png" alt="image-20220509095435303"></p>

<p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220509095855893.png" alt="image-20220509095855893"></p>

<p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220509101609070.png" alt="image-20220509101609070"></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericsIntersectionTypeWithDelegate</span> <span class="o">{</span>
    <span class="c1">//1. 지네릭으로서 type 정보 1개를 가진 interface 선언</span>
    <span class="kd">interface</span> <span class="nc">DelegateTo</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="c1">//2. supplier처럼 인자안받고, 응답만 T type의 객체로 하는, 추상메서드 1개를 선언한다.</span>
        <span class="no">T</span> <span class="nf">delegate</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">//3. 이제 delegateTo 지네릭 인터페이스를 extends로 상속하는 인터페이스를 만든다.</span>
    <span class="c1">// -&gt; 이 때, 지네릭 인터페이스의 type parameter에 구체형을 줘야한다!</span>
    <span class="c1">// -&gt; 또한 확장기능을 추가하기 위해 default method를 추가한다. (총합 1개메서드의 람다식에 카운팅 안되는 메서드)</span>
    <span class="kd">interface</span> <span class="nc">Hello</span> <span class="kd">extends</span> <span class="nc">DelegateTo</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="k">default</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">()</span> <span class="o">{</span>
            <span class="c1">//4. 이제 확장기능 뿐만 아니라 + default메서드 속에서 상속한 (함수형)인터페이스의 기능(delegate())를 호출할 수 잇다.</span>
            <span class="c1">// -&gt; 함수형인페 추상메서드는 인자없이 T응답인데 -&gt; DelegateTo&lt;String&gt;으로 박아서 상속했으니 String을 응답할 것이다.</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello "</span> <span class="o">+</span> <span class="n">delegate</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//5. 아까랑 조금 다르다.</span>
        <span class="c1">// -&gt; 바깥에 호출하는 메서드 + 일단 람다식 캐스팅부터 작성한다.</span>
        <span class="c1">// -&gt; 상속한 마지막 인터페이스가 뿐만 아니라, 부모인 함수형인페도 같이 처음부터 적어줘야</span>
        <span class="c1">// -&gt; 함수형 인페로 인한 람다식 작성이 가능하다.</span>
        <span class="c1">//run((DelegateTo&lt;String&gt; &amp; Hello))</span>

        <span class="c1">//6. 이번엔 [함수형인페 속 메서드가 인자X의 supplier -&gt; 람다식 구현시 좌항이 빈 ()-&gt;로 출발해야한다]</span>
        <span class="c1">//run((DelegateTo&lt;String&gt; &amp; Hello) () -&gt; )</span>
        <span class="c1">//7. 인자없는 ()-&gt; 지만, 응답은 T 타입 -&gt; String 이므로 [우항=lambda object]는 String으로 반환해주자.</span>
        <span class="c1">//run((DelegateTo&lt;String&gt; &amp; Hello) () -&gt; "ChoJaeSeong")</span>
        <span class="c1">//8. 이제 기본적으로 제네릭메서드로서 상한 2개 &amp;&amp; 내부에서 기능호출하는 메서드에서</span>
        <span class="c1">//   내부호출을 2번재 인자에 [return없이 메서드 호출만 하는 로직 옮기기용 Consumer&lt;T&gt;의 람다식] 작성</span>
        <span class="c1">//   -&gt; 이것을 통해, 상한을 일일히 제네릭 상한으로 안적어주고, Consumer&lt;T&gt;가 1번째 람다식에서 추론해서 갖다쓰게 된다.</span>
        <span class="n">run</span><span class="o">((</span><span class="nc">DelegateTo</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="nc">Hello</span><span class="o">)</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">"ChoJaeSeong"</span><span class="o">,</span> <span class="n">o</span> <span class="o">-&gt;</span> <span class="o">{</span>

        <span class="o">});</span>
        <span class="c1">//12. 해석</span>
        <span class="c1">// 1) 람다식 구현() -&gt; "ChoJaeSeong"는, 함수형인터페이스DelegateTo&lt;String&gt; 의 추메 T delegate()의  실제 구현 코드가 되어버린다.</span>
        <span class="c1">// 2) Consumer가 받아온 로직 중 default 메소드 hello 호출 -&gt; 그 내부에 함수형인페 속 추메 delegate() 호출이 있다면?</span>
        <span class="c1">//   -&gt; 여기 정해둔 람다식구현이 빨려 들어가 실행된다.</span>
        <span class="c1">// 3) 그 이유는, 타입캐스팅 속 InterSectionType &amp; 로 인해, 뒤쪽 인페의 default method안에 들어있는 부모인터페이스의 메서드 호출시, 앞에 함수형인페의 추상메서드를 그대로 가져와 호출한다.(자바가 인식해준다)</span>
        <span class="n">run</span><span class="o">((</span><span class="nc">DelegateTo</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="nc">Hello</span><span class="o">)</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">"ChoJaeSeong"</span><span class="o">,</span> <span class="n">o</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="c1">// 13. 앞에서 intersectionType으로 추가해준 인터페이스는</span>
            <span class="c1">//     그 앞의 deletage를 상속한 뒤, 그 속의 추메를 내부에서 사용할 수 있게 된다.</span>
            <span class="c1">//  -&gt; default 고정 기능이 아닌, 함수형인페를 부모로 상속한 뒤, default method에서 사용 -&gt;</span>
            <span class="c1">//    호출시 람다식에 의해 언제든지 변경가능한 기능을 수행하게 됨됨</span>
            <span class="n">o</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
        <span class="o">});</span>

        <span class="c1">//14. 람다식 캐스팅 부분에 인터섹션Type을 추가한 뒤,</span>
        <span class="c1">//    consumer block에서 새로운 기능을 호출하면, 람다식구현이 그대로 추상메서드 호출 자리에 사용되면서 기능이 추가된다</span>
        <span class="n">run</span><span class="o">((</span><span class="nc">DelegateTo</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="nc">Hello</span> <span class="o">&amp;</span> <span class="nc">UpperCase</span><span class="o">)</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">"ChoJaeSeong"</span><span class="o">,</span> <span class="n">o</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">o</span><span class="o">.</span><span class="na">upperCase</span><span class="o">();</span>
        <span class="o">});</span>

        <span class="c1">//15. 이제 람다식을 동적으로 바꿔도 바뀐 체로 기능이 합쳐진다.</span>
        <span class="n">run</span><span class="o">((</span><span class="nc">DelegateTo</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="nc">Hello</span> <span class="o">&amp;</span> <span class="nc">UpperCase</span><span class="o">)</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">"abcde"</span><span class="o">,</span> <span class="n">o</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">o</span><span class="o">.</span><span class="na">upperCase</span><span class="o">();</span>
        <span class="o">});</span>
    <span class="o">}</span>

    <span class="c1">//13. 이제 Consumer block안에 새로운 기능을 추가하고 싶다! 하지만, 새로운 클래스를 만들거나 하고 싶진 않다면?</span>
    <span class="c1">//   -&gt; 람다식 캐스팅에 인터섹션Type을 추가할 default method의 interface추가 -&gt; [람다식으로 구현하는 delegate()기능 + @]로 기능 추가할 수 있다.</span>
    <span class="c1">//13-1. 똑같이 함수형인페는 상속해서 -&gt; 내부에서 함수형인페를 호출할 수 있어야한다.</span>
    <span class="kd">interface</span> <span class="nc">UpperCase</span> <span class="kd">extends</span> <span class="nc">DelegateTo</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="k">default</span> <span class="kt">void</span> <span class="nf">upperCase</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">delegate</span><span class="o">().</span><span class="na">toUpperCase</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//9. 기본 제네릭 메서드로 정의하며, 람다식의 추상체 파라미터인 인터페이스(DelegateTo&lt;String&gt;) 대신 -&gt; T t로 쓴다.</span>
    <span class="c1">// -&gt; 여기서 말하는 T는 람다식캐스팅 맨 앞의 인터페이스를 T로 본다.</span>
    <span class="c1">// -&gt; 이제 인터페이스를 구현한 것 이후로의 SubType만 받기 위해, T의 상한을 응답형 앞에서 받아준다.</span>
    <span class="c1">// --&gt; 여기서, T는 DelegateTo&lt;&gt;인데, DelegateTo 자체의  type paramter는 다른 것으로 표기해줘야한다.</span>
    <span class="c1">//     run은 2개의 type paramter &lt;T, S&gt; 2개를 가지게 된다.</span>
    <span class="c1">// -&gt; Consumer는 delegate에 해당하는 T를 받아와서 람다식에서 호출되도록 한다.</span>
    <span class="c1">// 10. 아까는 Function이라는 함수형인페를 바로 사용했지만,</span>
    <span class="c1">// -&gt; 지금은,  DelegateTo라는 자체제작 (메소드1개의 인터페이스-&gt;) 함수형인페 + type이 중요해서 Function에서 안쓰던 제네릭을 붙여서 type을 살린 상태로</span>
    <span class="c1">//   좀더 복잡해졌다.</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">DelegateTo</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;,</span> <span class="no">S</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="kd">final</span> <span class="no">T</span> <span class="n">t</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">Consumer</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">consumer</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//11. Consumer의 람다식으로 뺀 로직을, 실행context는 여기 메서드 내부에서 시켜주게 한다.</span>
        <span class="c1">// -&gt; my) 람다식구현 인자로 받은 로직 -&gt; 함수형인페로 파라미터로 받아서 -&gt; 로직.실행()의  context는 메서드 내부에서 실행되게 한다. 함수실행로직 작성만 밖에서</span>
        <span class="c1">// -&gt; my2) 구현체 객체 -&gt; 인터페이스  파라미터 -&gt; 구현체 객체.의 기능 실행()은  메서드 내부에서...</span>
        <span class="n">consumer</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h3 id="새로운-아이디어와-최종-예제">
<a class="anchor" href="#%EC%83%88%EB%A1%9C%EC%9A%B4-%EC%95%84%EC%9D%B4%EB%94%94%EC%96%B4%EC%99%80-%EC%B5%9C%EC%A2%85-%EC%98%88%EC%A0%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>새로운 아이디어와 최종 예제</h3>

<h4 id="기존-구현class-후-구현체-인자-대신-람다식-구현--인자---함수형인페-파라미터-구현체추클호출-대신-정해진메서드호출하여-내부context로-실행---제네릭-메서드로-변환하되-함수형인페를-t상한으로---여러type-동시구현을-상한경계-대신-람다식-캐스팅--consumer로-밖으로-빼기">
<a class="anchor" href="#%EA%B8%B0%EC%A1%B4-%EA%B5%AC%ED%98%84class-%ED%9B%84-%EA%B5%AC%ED%98%84%EC%B2%B4-%EC%9D%B8%EC%9E%90-%EB%8C%80%EC%8B%A0-%EB%9E%8C%EB%8B%A4%EC%8B%9D-%EA%B5%AC%ED%98%84--%EC%9D%B8%EC%9E%90---%ED%95%A8%EC%88%98%ED%98%95%EC%9D%B8%ED%8E%98-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-%EA%B5%AC%ED%98%84%EC%B2%B4%EC%B6%94%ED%81%B4%ED%98%B8%EC%B6%9C-%EB%8C%80%EC%8B%A0-%EC%A0%95%ED%95%B4%EC%A7%84%EB%A9%94%EC%84%9C%EB%93%9C%ED%98%B8%EC%B6%9C%ED%95%98%EC%97%AC-%EB%82%B4%EB%B6%80context%EB%A1%9C-%EC%8B%A4%ED%96%89---%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EB%90%98-%ED%95%A8%EC%88%98%ED%98%95%EC%9D%B8%ED%8E%98%EB%A5%BC-t%EC%83%81%ED%95%9C%EC%9C%BC%EB%A1%9C---%EC%97%AC%EB%9F%ACtype-%EB%8F%99%EC%8B%9C%EA%B5%AC%ED%98%84%EC%9D%84-%EC%83%81%ED%95%9C%EA%B2%BD%EA%B3%84-%EB%8C%80%EC%8B%A0-%EB%9E%8C%EB%8B%A4%EC%8B%9D-%EC%BA%90%EC%8A%A4%ED%8C%85--consumer%EB%A1%9C-%EB%B0%96%EC%9C%BC%EB%A1%9C-%EB%B9%BC%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>기존: (구현class 후 구현체 인자 대신) 람다식 구현  인자 -&gt; 함수형인페 파라미터 (구현체.추클()호출 대신 정해진메서드()호출하여 내부context로 실행) -&gt; 제네릭 메서드로 변환하되 함수형인페를 T상한으로 -&gt; 여러Type 동시구현을 상한경계 대신 람다식 캐스팅 + Consumer로 밖으로 빼기</h4>

<h4 id="현재-일반-인터페이스메서드-2개이상-의-기능-다-가지면서--새로운-기능을-람다식-캐스팅-했던-것처럼-동적으로-추가하고-싶다">
<a class="anchor" href="#%ED%98%84%EC%9E%AC-%EC%9D%BC%EB%B0%98-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A9%94%EC%84%9C%EB%93%9C-2%EA%B0%9C%EC%9D%B4%EC%83%81-%EC%9D%98-%EA%B8%B0%EB%8A%A5-%EB%8B%A4-%EA%B0%80%EC%A7%80%EB%A9%B4%EC%84%9C--%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EB%9E%8C%EB%8B%A4%EC%8B%9D-%EC%BA%90%EC%8A%A4%ED%8C%85-%ED%96%88%EB%8D%98-%EA%B2%83%EC%B2%98%EB%9F%BC-%EB%8F%99%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%B6%94%EA%B0%80%ED%95%98%EA%B3%A0-%EC%8B%B6%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>현재: 일반 인터페이스(메서드 2개이상) 의 기능 다 가지면서 + 새로운 기능을 람다식 캐스팅 했던 것처럼 <code class="language-plaintext highlighter-rouge">동적으로 추가</code>하고 싶다</h4>

<h4 id="더이상-수정할-수-없는-라이브러리에-기능추가">
<a class="anchor" href="#%EB%8D%94%EC%9D%B4%EC%83%81-%EC%88%98%EC%A0%95%ED%95%A0-%EC%88%98-%EC%97%86%EB%8A%94-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%97%90-%EA%B8%B0%EB%8A%A5%EC%B6%94%EA%B0%80" aria-hidden="true"><span class="octicon octicon-link"></span></a>더이상 수정할 수 없는 라이브러리에 기능추가</h4>

<ul>
  <li>
    <p>Repository의 findAll()이 List가 아닌 iterator를 리턴하는데, list로 받으려고 별도의 메서드 만드는 것이 관련있을까? 아님…</p>
  </li>
  <li>
    <p>예제 인터페이스는 이미 4개의 메서드를 가진 인터페이스가 base라서… 람다식 구현(함수형인페-메소드1개를 인자에서 구현)을 받을 수 가 없다.</p>

    <ul>
      <li>람다식의 우항에서 해당 구현체객체를 넘겨주는 람다식을 작성하더라도.. 캐스팅은 안된다?!</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220509123024132.png" alt="image-20220509123024132"></p>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericsIntersectionTypeWithDelegateExample</span> <span class="o">{</span>

    <span class="c1">//1. List는 구현해야할 추메가 너무 많아서, Pair&lt;T&gt;라는 인터페이스를 하나 정의해준다.</span>
    <span class="kd">interface</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="c1">// 2. 값을 2개 가질 수 있어서 각각을 꺼낼 수 있는 메서드 2개를 가진다( 함수형인페X -&gt; 람다식으로 인자에서 구현X)</span>
        <span class="c1">//    + setter도 2개 가진다.</span>
        <span class="no">T</span> <span class="nf">getFirst</span><span class="o">();</span>

        <span class="no">T</span> <span class="nf">getSecond</span><span class="o">();</span>

        <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">);</span>

        <span class="kt">void</span> <span class="nf">setSecond</span><span class="o">(</span><span class="no">T</span> <span class="n">second</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//2. 이제 일반 인터페이스를 구현하는 class를 만든다.</span>
    <span class="c1">// -&gt; 인터페이스 impl할 때, 제네릭 인터페이스면 -&gt; 직접 명시해서 구현하자.</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Name</span> <span class="kd">implements</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="c1">//3. class라서 이제 필드를 만들어, 정보를 보관할 수 있다.</span>
        <span class="kd">private</span> <span class="nc">String</span> <span class="n">firstName</span><span class="o">;</span>
        <span class="kd">private</span> <span class="nc">String</span> <span class="n">lastName</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Name</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span> <span class="n">firstName</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">lastName</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">firstName</span> <span class="o">=</span> <span class="n">firstName</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">lastName</span> <span class="o">=</span> <span class="n">lastName</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">firstName</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getSecond</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">lastName</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">firstName</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSecond</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span> <span class="n">second</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">lastName</span> <span class="o">=</span> <span class="n">second</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">interface</span> <span class="nc">DelegateTo</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="no">T</span> <span class="nf">delegate</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">DelegateTo</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;,</span> <span class="no">S</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="kd">final</span> <span class="no">T</span> <span class="n">t</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">Consumer</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">consumer</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">consumer</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//7. Forwarding인터페이스를 만들어준다. (~를 넘긴다는 의미)</span>
    <span class="c1">//7-1. 람다식으로 쓰기 위해 함수형인페 Delegate 인터페이스를 상속한다.</span>
    <span class="c1">// - 동적으로 쓰고 싶은 인터페이스 Pair&lt;T&gt;를 함수형인페&lt;T&gt;의 type paramter에  넣어준다.</span>
    <span class="c1">// - Delegate뿐만 아니라, Pair 인터페이스도 상속한다.</span>
    <span class="kd">interface</span> <span class="nc">ForwardingPair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">DelegateTo</span><span class="o">&lt;</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;,</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="c1">//7-2. 인터페이스에 있는 여러개의 추상메서드를 -&gt; 상속후 default method로서 오버라이딩 하는 방법이 있다.</span>
        <span class="c1">// (1) 오버라이딩 해서 다 가져온 다음 -&gt; (2) @Override 지우고, default메서드로 바꾸주고</span>
        <span class="c1">// (3) getter의 경우, DelegateTo 상속으로 호출가능한 delegate()를 호출한다.</span>
        <span class="c1">//     -&gt; delegate는 들어오는 T를 응답해주는 supplier 역할인데, 그 T자리에 Pair&lt;T&gt;가 들어가 있으니</span>
        <span class="c1">//     -&gt; pair내부의 여러 추상메서드를 호출하도록 작성한다.</span>

        <span class="c1">//        @Override</span>
        <span class="c1">//        T getFirst();</span>
        <span class="k">default</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
            <span class="c1">//8. delegate()하면, elegateTo에 적힌 Type인 pair&lt;T&gt; 타입이 오고 -&gt; 거기서 정의된 메서드를 호출한다.</span>
            <span class="c1">// -&gt; supplier형태의 T응답 DelegateTo&lt;T&gt; 인페를 상속한 인페는</span>
            <span class="c1">// -&gt; DelegateTo&lt;T&gt;의 T 자리에 넣은, extends DelegateTo&lt;Pair&lt;T&gt;&gt; 상의 [Pair&lt;T&gt;]를 반환해주게 된다.</span>
            <span class="c1">// --&gt; delegate()로 반환된 인터페이스 Pair&lt;T&gt;는.. 그 내부 추상메서드를 호출할 수 있다.</span>
            <span class="k">return</span> <span class="nf">delegate</span><span class="o">().</span><span class="na">getFirst</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="k">default</span> <span class="no">T</span> <span class="nf">getSecond</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">delegate</span><span class="o">().</span><span class="na">getSecond</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="k">default</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">delegate</span><span class="o">().</span><span class="na">setFirst</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">default</span> <span class="kt">void</span> <span class="nf">setSecond</span><span class="o">(</span><span class="no">T</span> <span class="n">second</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">delegate</span><span class="o">().</span><span class="na">setSecond</span><span class="o">(</span><span class="n">second</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//9. ForwardingPair를 만들면, 인터페이스는 Delegate만 남는다.</span>
    <span class="c1">// -&gt; 그 뒤의 Pair는 이미 안에서 구현된 상태기 때문이다.</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//4. 생각하면서 람다식구현을 인자로 받는 메서드 -&gt; 그것을 제네릭으로 받는 메서드를 run을 호출해보자.</span>
        <span class="c1">//run(()-&gt;"", o-&gt;{});</span>

        <span class="c1">//5. 우리가 원하는 것: 일반인페 기능구현 + 동적으로 기능추가 하고 싶다.</span>
        <span class="c1">// 5-1. 메서드 2개이상의 일반 인터페이스 의 기능을 다 가진다 -&gt; 람다식구현 대입 불가 -&gt; 구현체객체를 만들어, [넣어줘야할 구현체 객체를 람다식 우항에서 제공]해주기</span>
        <span class="c1">//    - 참고) 추상체 인터페이스 파라미터에 넣을, 구현체 객체를 생성할 때도, 변수(좌항)은 추상체로 받아주자.!</span>
        <span class="c1">//final Name name = new Name("Toby", "Lee");</span>
        <span class="kd">final</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Name</span><span class="o">(</span><span class="s">"Toby"</span><span class="o">,</span> <span class="s">"Lee"</span><span class="o">);</span>
        <span class="c1">// 5-2. 람다식으로 함수형인페 1개 전체 구현이 아니라,  일반 인페가 받는 구현체 객체를 람다식으러 넣어주면 된다.</span>
        <span class="c1">//run(() () -&gt; name, );</span>

        <span class="c1">//6. 하지만, 람다식의 우항으로 넘기는 name은 Pair라는 인터페이스를 넘길 수 없는 상황?이다.</span>
        <span class="c1">// -&gt; 람다에서 사용하게 만들고 싶다~! 새로운 아이디어가 필요하다.</span>

        <span class="c1">//10. 이제 람다식 캐스팅을 ForwardingPair라고 놓는다.</span>
        <span class="c1">// -&gt; FP는 DelegateTo를 상속한 상태이므로</span>
        <span class="c1">// -&gt; DelegateTo를 상한경계로 받는 run의 첫번재 인자 T에 넣어줄 수 있고 ( 람다식의 우항에 supplier -&gt; T t )</span>
        <span class="c1">// -&gt; 메서드 내부호출될 로직을, 함수형인페로 받아 -&gt; 외부에서 [첫번째 인자에 의해 자동 추론된 Type] 람다식으로 제공 받을 수 있어</span>
        <span class="c1">// -&gt; 2번째 인자 람다식을 동적으로 넣어줄 수 있다.</span>
        <span class="n">run</span><span class="o">((</span><span class="nc">ForwardingPair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;)</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">name</span><span class="o">,</span> <span class="n">o</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"o.getFirst() = "</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="na">getFirst</span><span class="o">());</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"o.getSecond() = "</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="na">getSecond</span><span class="o">());</span>
        <span class="o">});</span>

        <span class="c1">//11. 컨슈머 쪽의 o의 Type은 사실 ForwardingPair이다.</span>
        <span class="c1">// -&gt; ForwardingPair이다는 delegateTo에 해당하는 것이고</span>
        <span class="c1">// -&gt; delegateTo를 구현하는 메서드는 () -&gt; name 밖이다.</span>
        <span class="c1">// -&gt; 그 우항에서 반환되어 입력되는 name속 메서드는</span>
        <span class="c1">// -&gt; ForwardingPair가 delete상속후 다 정의를 해놓았으니</span>
        <span class="c1">// -&gt; o에서 호출해서 쓰기만 하면 된다?!</span>

        <span class="c1">//람다식 타입캐스팅 쓸 수 있는 인터페이스 -&gt; default method는 0개로 침. 함수형 인터페이스..?!</span>
        <span class="c1">//https://www.youtube.com/watch?v=PQ58n0hk7DI&amp;list=PLv-xDnFD-nnmof-yoZQN8Fs2kVljIuFyC&amp;index=11</span>
        <span class="c1">//1:43:00 c참고하기</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="제네릭-기본-적용-예시-모음">
<a class="anchor" href="#%EC%A0%9C%EB%84%A4%EB%A6%AD-%EA%B8%B0%EB%B3%B8-%EC%A0%81%EC%9A%A9-%EC%98%88%EC%8B%9C-%EB%AA%A8%EC%9D%8C" aria-hidden="true"><span class="octicon octicon-link"></span></a>제네릭 기본 적용 예시 모음</h3>

<ol>
  <li>
    <p>print</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="c1">//before</span>
 <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
 <span class="o">}</span>
    
 <span class="c1">//after</span>
 <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>countGreaterThan(arr, elem)</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="c1">//before</span>
 <span class="kd">static</span> <span class="kt">long</span> <span class="nf">countGreaterThan</span><span class="o">(</span><span class="nc">Integer</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">elem</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">)</span>
         <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="n">elem</span><span class="o">)</span>
         <span class="o">.</span><span class="na">count</span><span class="o">();</span>
 <span class="o">}</span>
    
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
     <span class="kd">final</span> <span class="nc">Integer</span><span class="o">[]</span> <span class="n">integers</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"countGreaterThan(integers, 4) = "</span> <span class="o">+</span> <span class="n">countGreaterThan</span><span class="o">(</span><span class="n">integers</span><span class="o">,</span> <span class="mi">4</span><span class="o">));</span>
 <span class="o">}</span>
</code></pre></div>    </div>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="c1">//after</span>
 <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="kt">long</span> <span class="nf">genericCountGreaterThan</span><span class="o">(</span><span class="no">T</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="no">T</span> <span class="n">elem</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">arr</span><span class="o">)</span>
         <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
         <span class="o">.</span><span class="na">count</span><span class="o">();</span>
 <span class="o">}</span>
    
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
     <span class="kd">final</span> <span class="nc">Integer</span><span class="o">[]</span> <span class="n">integers</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"genericCountGreaterThan(integers, 4) = "</span> <span class="o">+</span> <span class="n">genericCountGreaterThan</span><span class="o">(</span><span class="n">integers</span><span class="o">,</span> <span class="mi">4</span><span class="o">));</span>
     <span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">strings</span> <span class="o">=</span> <span class="o">{</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">,</span> <span class="s">"4"</span><span class="o">,</span> <span class="s">"5"</span><span class="o">,</span> <span class="s">"6"</span><span class="o">,</span> <span class="s">"7"</span><span class="o">};</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"genericCountGreaterThan(strings, \"3\") = "</span> <span class="o">+</span> <span class="n">genericCountGreaterThan</span><span class="o">(</span><span class="n">strings</span><span class="o">,</span> <span class="s">"2"</span><span class="o">));</span>
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>isEmpty(list)  - 지네릭 메소드 버전</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
 <span class="o">}</span>
</code></pre></div>    </div>

    <ul>
      <li>
<strong>isEmpty</strong> - 내부 로직에 type paramter 미사용으로 <strong>unbound wild card로 변경한 버전</strong>
</li>
    </ul>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>frequency(list, elem) - 지네릭 메소드 버전</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">long</span> <span class="nf">frequency</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kd">final</span> <span class="no">T</span> <span class="n">elem</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
         <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">elem</span><span class="o">))</span>
         <span class="o">.</span><span class="na">count</span><span class="o">();</span>
 <span class="o">}</span>
</code></pre></div>    </div>

    <ul>
      <li>frequency - 와일드 카드 버전
        <ul>
          <li>**equals비교가 제대로 되려면 List<t>의 원소 vs 원소1개 T를 비교하는 지네릭 메소드가 낫지 않을까?**</t>
</li>
          <li>equlas의 비교는 사실, 똑같은 Type일 이유가 없다.
            <ul>
              <li>equals비교 대상으로 허용하지 않는다면, 에러가 날 것이다.</li>
              <li>list의 원소Type와 비교할 원소는 다른 Type을 가져가는 경우도 있다. ex&gt; SubType</li>
              <li>
<strong>동일한Type으로만 비교시, 지네릭 메서드를 쓰면 되겠지만…</strong> SubType(구상체)와의 비교도 하기도하고, 자바 api에도 이렇게 설계되어있다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">frequency</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">elem</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
         <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">elem</span><span class="o">))</span>
         <span class="o">.</span><span class="na">count</span><span class="o">();</span>
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>max - 제네릭 메소드 버전</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="no">T</span> <span class="nf">max2</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
         <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="o">)</span>
         <span class="o">.</span><span class="na">get</span><span class="o">();</span>
 <span class="o">}</span>
</code></pre></div>    </div>

    <ul>
      <li>wild card 개입 by <strong>메서드 내부 사용시 upper / 메서드 외부용 super</strong>
</li>
    </ul>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;&gt;</span> <span class="no">T</span> <span class="nf">max</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
         <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="o">)</span>
         <span class="o">.</span><span class="na">get</span><span class="o">();</span>
 <span class="o">}</span>
</code></pre></div>    </div>

    <ul>
      <li><strong>max - collections(인자인 List내장 Comparator 사용 버전)</strong></li>
    </ul>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="nc">Collections</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">list</span><span class="o">)</span>
</code></pre></div>    </div>

    <ul>
      <li>max - <strong>collections</strong> + <code class="language-plaintext highlighter-rouge">Comparable&lt;? super T&gt;</code>예시를 위해, 비교메서드 구성을 Object로 해버리는 <strong>직접  Comparator(객체 비교방법) 제시 with 람다 캐스팅</strong>
</li>
    </ul>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="nc">Collections</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="o">(</span><span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;)</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">toString</span><span class="o">()));</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>reverse: 지네릭 메서드로는 1개로 표현가능</p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
     <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">list</span><span class="o">);</span>
    
     <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
         <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">temp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
     <span class="o">}</span>
 <span class="o">}</span>
</code></pre></div>    </div>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
     <span class="n">reverseHelper</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
 <span class="o">}</span>
    
 <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">reverseHelper</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
     <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">list</span><span class="o">);</span>
     <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
         <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">temp</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
     <span class="o">}</span>
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ol>


  </div><a class="u-url" href="/java/generic/lambda/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/03/%EC%A0%9C%EB%84%A4%EB%A6%AD2.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>평범한 한의사 돌범의 엔지니어 도전기</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/is2js" target="_blank" title="is2js"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/is2js" target="_blank" title="is2js"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
