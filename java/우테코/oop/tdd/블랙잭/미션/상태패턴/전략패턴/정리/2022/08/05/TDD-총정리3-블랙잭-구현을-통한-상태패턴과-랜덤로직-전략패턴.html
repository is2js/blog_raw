<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>TDD 총정리3-블랙잭 구현을 통한 상태패턴과 랜덤로직 전략패턴 | 돌범텤놑</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="TDD 총정리3-블랙잭 구현을 통한 상태패턴과 랜덤로직 전략패턴" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="TDD학습 내용 압축 정리" />
<meta property="og:description" content="TDD학습 내용 압축 정리" />
<link rel="canonical" href="blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/tdd/%EB%B8%94%EB%9E%99%EC%9E%AD/%EB%AF%B8%EC%85%98/%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%A0%95%EB%A6%AC/2022/08/05/TDD-%EC%B4%9D%EC%A0%95%EB%A6%AC3-%EB%B8%94%EB%9E%99%EC%9E%AD-%EA%B5%AC%ED%98%84%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4%EA%B3%BC-%EB%9E%9C%EB%8D%A4%EB%A1%9C%EC%A7%81-%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4.html" />
<meta property="og:url" content="blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/tdd/%EB%B8%94%EB%9E%99%EC%9E%AD/%EB%AF%B8%EC%85%98/%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%A0%95%EB%A6%AC/2022/08/05/TDD-%EC%B4%9D%EC%A0%95%EB%A6%AC3-%EB%B8%94%EB%9E%99%EC%9E%AD-%EA%B5%AC%ED%98%84%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4%EA%B3%BC-%EB%9E%9C%EB%8D%A4%EB%A1%9C%EC%A7%81-%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4.html" />
<meta property="og:site_name" content="돌범텤놑" />
<meta property="og:image" content="blog.chojaeseong.com/images/posts/java.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-08-05T00:00:00-05:00" />
<script type="application/ld+json">
{"datePublished":"2022-08-05T00:00:00-05:00","url":"blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/tdd/%EB%B8%94%EB%9E%99%EC%9E%AD/%EB%AF%B8%EC%85%98/%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%A0%95%EB%A6%AC/2022/08/05/TDD-%EC%B4%9D%EC%A0%95%EB%A6%AC3-%EB%B8%94%EB%9E%99%EC%9E%AD-%EA%B5%AC%ED%98%84%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4%EA%B3%BC-%EB%9E%9C%EB%8D%A4%EB%A1%9C%EC%A7%81-%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4.html","@type":"BlogPosting","image":"blog.chojaeseong.com/images/posts/java.png","headline":"TDD 총정리3-블랙잭 구현을 통한 상태패턴과 랜덤로직 전략패턴","dateModified":"2022-08-05T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/tdd/%EB%B8%94%EB%9E%99%EC%9E%AD/%EB%AF%B8%EC%85%98/%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%A0%95%EB%A6%AC/2022/08/05/TDD-%EC%B4%9D%EC%A0%95%EB%A6%AC3-%EB%B8%94%EB%9E%99%EC%9E%AD-%EA%B5%AC%ED%98%84%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4%EA%B3%BC-%EB%9E%9C%EB%8D%A4%EB%A1%9C%EC%A7%81-%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4.html"},"description":"TDD학습 내용 압축 정리","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<!-- 폰트추가를 위한 link태그 삽입 -->
  <!-- 폰트1:  기본 spoqa 웹폰트 -->
  <!-- css에서 * {} 다 뒤집어씀. -->
  <link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSansNeo.css' rel='stylesheet' type='text/css'>
  <!-- 폰트2:  블로그 제목들 sunflower 웹폰트 -->
  <!-- 쥬피터 등 포스트 내부 글자 h1, h2 제목은 sunflower체 도입 -->
  <link href="//fonts.googleapis.com/css?family=Sunflower:300,500,700" rel="stylesheet"> 

  <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="blog.chojaeseong.com/feed.xml" title="돌범텤놑" /><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">돌범텤놑</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About Me</a><a class="page-link" href="/search/">Search</a><a class="page-link" href="/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">TDD 총정리3-블랙잭 구현을 통한 상태패턴과 랜덤로직 전략패턴</h1><p class="page-description">TDD학습 내용 압축 정리</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-08-05T00:00:00-05:00" itemprop="datePublished">
        Aug 5, 2022
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      22 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/categories/#java">java</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#우테코">우테코</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#oop">oop</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#TDD">TDD</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#블랙잭">블랙잭</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#미션">미션</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#상태패턴">상태패턴</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#전략패턴">전략패턴</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#정리">정리</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <!-- toc가 먼저 나오므로 h3로 안내하기 -->
    <h3>📜 제목으로 보기</h3>
    <ul class="section-nav">
<li class="toc-entry toc-h3"><a href="#블랙잭-상태-패턴-구현">블랙잭 상태 패턴 구현</a></li>
</ul><ul>
  <li>랜덤을 셔플로 구현하여 데이터를 제공해주는 Deck에서, 랜덤부분을 전략패턴으로 만들고, 외부에서 [직접 반환되는 객체를 만들어놓고 -&gt; 최종 객체만 람다식에 넣어] 제공함.</li>
</ul>

<h3 id="블랙잭-상태-패턴-구현">
<a class="anchor" href="#%EB%B8%94%EB%9E%99%EC%9E%AD-%EC%83%81%ED%83%9C-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84" aria-hidden="true"><span class="octicon octicon-link"></span></a>블랙잭 상태 패턴 구현</h3>

<ol>
  <li>
    <p>컴퓨터내부에서 로직의 시작인 card 2개가 주어진다면, <strong>정제된input이라 생각하고 카드부터 만든다.</strong></p>

    <ul>
      <li><strong>제한된 종류의 값 = 상수묶음은 enum으로 만들어서 카드를 만든다.</strong></li>
      <li>테스트메서드명은 인자 -&gt; 1case 가 결정한다.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803141223263.png" alt="image-20220803141223263"></p>
  </li>
  <li>
    <p><strong>4 x 13 종류의 객체는 캐싱이 가능하다.</strong></p>

    <ul>
      <li>캐싱을 적용하려면 일단 <strong>생성자 인자 그대로 <code class="language-plaintext highlighter-rouge">정팩메</code>로 만들고, 기본생성자는 private해준다</strong>
</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/eb9d9669-3c47-4bc2-a036-e045e7bae549.gif" alt="eb9d9669-3c47-4bc2-a036-e045e7bae549"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803141533284.png" alt="image-20220803141533284"></p>
  </li>
  <li>
    <p><strong>원래는 <code class="language-plaintext highlighter-rouge">기본생성자의 1개 인자</code>에 대해 hashMap<code class="language-plaintext highlighter-rouge">&lt;생성자인자, 객체&gt;</code>형으로 static CACHE map을 만들어야하지만, <code class="language-plaintext highlighter-rouge">파라미터가 2개일경우, 1개로 합친 Key</code>를 만들어야한다.</strong></p>

    <ul>
      <li>2개이상의 정보를 묶은 class를 만들어도 되지만, <strong>string을 이용해서 합쳐 1개의 key로 만들어 <code class="language-plaintext highlighter-rouge">&lt;String, 객체&gt;</code>형을 많이 사용한다.</strong>
</li>
      <li><strong>캐쉬의 기본공식은 꺼내서 없으면 put해주고, return get을 반환이다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/303bdea4-3f7f-401f-8ced-e537eb227a77.gif" alt="303bdea4-3f7f-401f-8ced-e537eb227a77"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803142249589.png" alt="image-20220803142249589"></p>
  </li>
  <li>
    <p><strong>테스트메서드명도 함수를 from or of의 정펙메로 바꿔주고, isSameAs로 테스트한다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803142749590.png" alt="image-20220803142749590"></p>
  </li>
  <li>
    <p><strong>java의 기능으로서 없으면 key에 대한 value를 생성해주고 있으면 반환하는 <code class="language-plaintext highlighter-rouge">computeIfAbsent</code>를 사용해서 리팩토링한다.</strong></p>

    <ul>
      <li>또한 캐싱될 객체의 수를 알고 있으면 미리 넣어줘도 된다.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/e488a62d-24bf-4ab9-8f50-1dc5ed300d1a.gif" alt="e488a62d-24bf-4ab9-8f50-1dc5ed300d1a"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803143606805.png" alt="image-20220803143606805"></p>
  </li>
  <li>
    <p>CACHE대상객체는, 거의 값객체기 때문에,  <strong>값으로 비교하기 위해 eq/hC오버라이딩도 해준다.</strong></p>
  </li>
  <li>
    <p><strong>이제 <code class="language-plaintext highlighter-rouge">가진 2장의 카드</code>로 <code class="language-plaintext highlighter-rouge">정해진 종류의 행위마다 변화하는 상태 판단</code>하면서, <code class="language-plaintext highlighter-rouge">Game</code>을 풀어 가야한다.</strong></p>

    <ul>
      <li>카드2장 -&gt; if 상태판단 -&gt; <strong><code class="language-plaintext highlighter-rouge">상태에 따른 행위 -&gt; 다른 상태</code></strong>
</li>
      <li><strong><code class="language-plaintext highlighter-rouge">if 상태에 따른 행위의 결과가 다른 상태가 나온다면, 상태패턴</code>을 고려한다</strong></li>
      <li>2장의 받은 상태에서
        <ul>
          <li>if 21 -&gt; 블랙잭 상태 -&gt; stop</li>
          <li>if 21미만 -&gt; hit상태 -&gt; stay or hit지속</li>
        </ul>
      </li>
      <li>
<strong><code class="language-plaintext highlighter-rouge">가장 만만하게 응답될 상태의 input</code>부터 case를 만들고 -&gt; 테스트메서드명으로 시작하면 된다.</strong>
        <ul>
          <li><strong><code class="language-plaintext highlighter-rouge">hit가 output상태로 나오는 input을 넣어주자.</code></strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Service가 아닌 만들어낸 input부터 시작하는 Game클래스를 만들고, <strong>서비스메서드처럼 static으로 start()를 만들고 재료를 넣어주자.</strong>
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803172330589.png" alt="image-20220803172330589"></p>

    <ul>
      <li><strong>input으로 <code class="language-plaintext highlighter-rouge">hit대상이되는 카드2장을 인자</code>를 넣어주고, <code class="language-plaintext highlighter-rouge">응닶값이 hit상태</code>이어야한다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/c67370cb-5be1-4ac1-8c1a-ad972ed07cfc.gif" alt="c67370cb-5be1-4ac1-8c1a-ad972ed07cfc"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803172709657.png" alt="image-20220803172709657"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803173533986.png" alt="image-20220803173533986"></p>
  </li>
  <li>
    <p><strong>다음은 Game.start()가 blackjack상태를 응답하도록 작성해보자.</strong></p>

    <ul>
      <li>
        <p>테스트에 인자를 blackjack으로 넣어주고</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803174548392.png" alt="image-20220803174548392"></p>
      </li>
      <li>
        <p><strong>blackjack시 ACE가 11로 사용될줄알아야한다. enum에 매핑된 값이 필요함을 인지한다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803174605022.png" alt="image-20220803174605022"></p>
      </li>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">enum에 값이 매핑되는 순간부터 바로 getter를 작성</code>해주면 된다.</strong></p>

        <ul>
          <li>
            <p><strong>ACE는 1or11을 가질 수 있으나 <code class="language-plaintext highlighter-rouge">규칙상 상한이 21점으로 제한되어있다면, 11을default시 2장을 아예 가질 수 없기 때문에, default를 작은 수로 주고 보정</code>한다</strong></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803175357571.png" alt="image-20220803175357571"></p>
          </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803174635793.png" alt="image-20220803174635793"></p>
      </li>
      <li>
        <p>card입장에서는 enum getter -&gt; enum point getter 2번을 거쳐야하므로, getter를 래핑해서 만들어준다.</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803180048429.png" alt="image-20220803180048429"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803180056251.png" alt="image-20220803180056251"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>2장의 카드 중에, <code class="language-plaintext highlighter-rouge">ACE가 포함되어 있을 경우</code> &amp;&amp; <code class="language-plaintext highlighter-rouge">[11로 쓸 때, 합 21] -&gt; [1로 쓰면 합 11]</code>일 경우만, blackjack이 되도록 처리해줘야한다.</strong></p>

    <ul>
      <li>
        <p><strong>2개의 카드 중에 ace가 있는지 확인</strong>한다.</p>

        <ul>
          <li>
            <p><strong>일급컬렉션이 아닌 상태에서 <code class="language-plaintext highlighter-rouge">동일형 객체 일괄처리</code>는 List.of()나 Stream.of()를 사용해서 묶어서 처리한다.</strong></p>
          </li>
          <li>
            <p><strong><code class="language-plaintext highlighter-rouge">있는지 없는지 판단</code>은<code class="language-plaintext highlighter-rouge"> filter + count</code>가 아니라<code class="language-plaintext highlighter-rouge">anyMatch( -&gt; 개별요소판단 )</code>로 판단한다.</strong></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/98305185-6d82-4ef3-9790-2d8f12751669.gif" alt="98305185-6d82-4ef3-9790-2d8f12751669"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803223426698.png" alt="image-20220803223426698"></p>
          </li>
        </ul>
      </li>
      <li>
        <p><strong>ace를 가졌다면 &amp;&amp;</strong> 2장의 <strong>합</strong>이 11이하인지 확인한다</p>

        <ul>
          <li>11이하이면, ace는 10으로 쓰일 수 있다.</li>
          <li><strong>11이면,  ace를 가진 경우 blackjack이다.</strong></li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803223757989.png" alt="image-20220803223757989"></p>
      </li>
      <li>
        <p><strong>즉, ace를 작은값로 유지하고, 기준값을 큰값일때로 잡아서 처리하면 된다.</strong></p>

        <ul>
          <li><strong>ace(1) + 10 -&gt; 11이면 21로 블랙잭</strong></li>
          <li>ace(1) + x -&gt; 11미만이면, ace(11) + x</li>
          <li>ace(1) + 11 -&gt; 12이상이면, 교환불가</li>
          <li><strong>ace가 2장있다면? 변환될 수 있는 ace는 한장이다. 2장 변환시 이미 22가 되어버림</strong></li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803224512177.png" alt="image-20220803224512177"></p>
      </li>
    </ul>
  </li>
  <li>
    <p>테스트를 통과했다면, <strong>리팩토링한다</strong>.</p>

    <ol>
      <li>
        <p><strong>일급컬렉션이 아닌 <code class="language-plaintext highlighter-rouge">같은형 객체 일괄처리</code>를 위해 List.of()로 묶었지만, <code class="language-plaintext highlighter-rouge">같은형끼리의 단순집계</code>또한 List.of()로 묶어서 누적연산으로 처리가능하다.</strong></p>

        <ul>
          <li>같은 context에서 <code class="language-plaintext highlighter-rouge">일괄처리</code>와 <code class="language-plaintext highlighter-rouge">같은형 끼리의 연산</code>이 뭉쳐있다면, <strong>List.of()나 Stream.of()로 묶어주는 것은 공통코드가 된다. <code class="language-plaintext highlighter-rouge">파라미터 추출로 각각을 빼낸뒤, 1개의 변수로 대체</code>할 수 있다.</strong>
</li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/c99a733b-5da6-459c-afda-cf65c89c814e.gif" alt="c99a733b-5da6-459c-afda-cf65c89c814e"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803225702034.png" alt="image-20220803225702034"></p>
      </li>
      <li>
        <p><strong>같은형끼리의 <code class="language-plaintext highlighter-rouge">단순연산</code> or <code class="language-plaintext highlighter-rouge">일괄처리</code>로 인해 <code class="language-plaintext highlighter-rouge">2개이상의 같은형을 List.of</code>로 묶었다면, <code class="language-plaintext highlighter-rouge">List.of()로 묶는 곳에서 일급컬렉션</code>을 고려한다.</strong></p>

        <ul>
          <li>
            <p>Stream.of()는 List.of()로 바꿔서 일급컬렉션의 생성자 인자로 올리자.</p>
          </li>
          <li>
            <p>이후 <strong><code class="language-plaintext highlighter-rouge">인자없는 생성장에서 빈컬렉션으로 초기화</code>하여, add가능한 일급컬렉션으로 수정하자.</strong></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803230332195.png" alt="image-20220803230332195"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/bd76e09c-c932-4314-8299-2d915b9bc787.gif" alt="bd76e09c-c932-4314-8299-2d915b9bc787"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803230845620.png" alt="image-20220803230845620"></p>
          </li>
          <li>
            <p><strong>인자없는 생성자는 <code class="language-plaintext highlighter-rouge">부생성자</code>이므로 <code class="language-plaintext highlighter-rouge">빈컬렉션 초기화를 this()</code>에 넣어서 초기화해주자</strong></p>

            <ul>
              <li>add시 새객체 반환시, 얕은복사 안해줘도 add전 객체는 버려져서 오염될 일이 없을 것 같아서 빼줬다.</li>
            </ul>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/1733ea67-d615-4ce6-9ac7-aafe4801d9a3.gif" alt="1733ea67-d615-4ce6-9ac7-aafe4801d9a3"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803231130552.png" alt="image-20220803231130552"></p>
          </li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>책임위임을 위임하려면, 일단 <code class="language-plaintext highlighter-rouge">현재context상의 메서드의 파라미터</code>에 걸려있어야 하며, <code class="language-plaintext highlighter-rouge">static메서드라면, static키워드를 삭제하고 위임</code>해야한다.</strong></p>

    <ul>
      <li>
<strong>getter를 쓰더라도 파라미터로 들어가서 완성</strong>해놓자.</li>
      <li><strong>static메서드라면, <code class="language-plaintext highlighter-rouge">static키워드를 지운 뒤 f6으로 위임</code>해야한다</strong></li>
      <li>getter를 썼다면, <strong>위임된 객체에서는 내수용getter가 사용되고 있으니 지우고, 필드로 바꾸자.</strong>
</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/ac7f2bd5-ca83-4487-bcd0-c1065dc82c97.gif" alt="ac7f2bd5-ca83-4487-bcd0-c1065dc82c97"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803234008203.png" alt="image-20220803234008203"></p>
  </li>
  <li>
    <p><strong>또다른 리팩토링으로서 <code class="language-plaintext highlighter-rouge">조건식에 하나의 도메인에 대한 메서드호출이 나열되어있다면, 메서드 추출시 파라미터에 1개만 도메인만 걸리며, 이 또한 묶어서 책임을 위임</code>할 수 있다.</strong></p>

    <ul>
      <li>
        <p>역시 static안이라면, static을 지우고 위임한다.</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803234519904.png" alt="image-20220803234519904"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220803234556959.png" alt="image-20220803234556959"></p>
      </li>
    </ul>
  </li>
  <li>
    <p>상태패턴 적용을 위해 <strong>state라는 추상체 인터페이스를</strong> 만들고, <strong>응답형을 Object가 아닌 추상체로 주면 -&gt; <code class="language-plaintext highlighter-rouge">알아서 응답되는 객체들을 구현</code>하라고 intellij가 알려준다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/280a5884-db1a-4fb6-8d73-50c00726bcde.gif" alt="280a5884-db1a-4fb6-8d73-50c00726bcde"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804114048025.png" alt="image-20220804114048025"></p>
  </li>
  <li>
    <p>테스트코드의 응답형에 따른 변수형도 변경해준다.
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804114302886.png" alt="image-20220804114302886"></p>
  </li>
  <li>
    <p><strong>추상체를 만드는 순간부터 <code class="language-plaintext highlighter-rouge">패키지를 분리하여, 패키지폴더 대상 다이어그램으로 의존성을 확인</code>하자.</strong></p>

    <ul>
      <li><strong>이후, <code class="language-plaintext highlighter-rouge">구상체만의 메서드 개발후 올리기전 다이어그램 + CompareFile하자</code></strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804114547248.png" alt="image-20220804114547248"></p>
  </li>
  <li>
    <p><strong>상태패턴을 도입했으면, <code class="language-plaintext highlighter-rouge">응답값으로 나온 현재 상태</code>를 바탕으로 <code class="language-plaintext highlighter-rouge">추상체에 있는 [다음상태로 갈 수 있는 인자]를 받아 [다음상태로가는 메서드]</code>를 정의해줘야한다. <code class="language-plaintext highlighter-rouge">에러호출로 종료되는 제일 쉬운 현재상태(blackjack)부터 [다음 상태로 넘어가는 메서드]를 만들자</code></strong></p>

    <ul>
      <li>테스트메서드에 작성한 <code class="language-plaintext highlighter-rouge">응답된 상태</code>
        <ul>
          <li>Hit</li>
          <li>Blackjack -&gt; <strong>draw즉시 <code class="language-plaintext highlighter-rouge">에러 호출로 종료</code>라서 더 쉽다.</strong>
</li>
        </ul>
      </li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804115950502.png" alt="image-20220804115950502"></p>
  </li>
  <li>
    <p><strong>이 때, <code class="language-plaintext highlighter-rouge">특정 쉬운 구현체부터 메서드 작성</code>이라면, <code class="language-plaintext highlighter-rouge">공통메서드일지 모르니, 오퍼레이터로 만들지말고 다운캐스팅해서, 구현체만의 메서드</code>로 만든 뒤, <code class="language-plaintext highlighter-rouge">공통이면, @Override</code>해서 올린다.</strong></p>

    <ul>
      <li>
<strong>응답값을 받을 때 (특정구현체) 다운캐스팅</strong>을 하고, 메서드를 작성한다</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/7b4e31c2-60ee-4cd3-976e-aedf73a30026.gif" alt="7b4e31c2-60ee-4cd3-976e-aedf73a30026"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804120914397.png" alt="image-20220804120914397"></p>
  </li>
  <li>
    <p><strong>특정구현체의 메서드이며, <code class="language-plaintext highlighter-rouge">thr 던질 메서드</code>라도 <code class="language-plaintext highlighter-rouge">미래에 공통으로 사용될 예비오퍼레이터라면, 응답형을 지정</code>한뒤 던진다.</strong></p>

    <ul>
      <li>게임종료는 thr로 한다.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804121345849.png" alt="image-20220804121345849"></p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">다운캐스팅된 구상체만의 메서드 개발이 완료</code>되면, <code class="language-plaintext highlighter-rouge">다이어그램을 확인해서, 올려도 되는지 판단</code>한다.</strong></p>

    <ul>
      <li>
<strong>다이어그램 + CompareFile을 펼쳐 모든 구상체가 호출해도 되는 메서드인지 확인</strong>한다.
        <ul>
          <li>다이어그램 단축키 : ctrl + alt + shift + U</li>
          <li>compareFile : 구상체들만 선택후 ctrl + D</li>
        </ul>
      </li>
      <li>올릴 거면, 다운캐스팅했떤 로직을 삭제하고, 다른 구상체들도 구현한다.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/5f9ff154-0934-4173-a368-295ad75eadba.gif" alt="5f9ff154-0934-4173-a368-295ad75eadba"></p>
  </li>
  <li>
    <p><strong>Override + pull members up으로 오퍼레이터로 올린 뒤, <code class="language-plaintext highlighter-rouge">테스트상 다운캐스팅한 로직은 삭제</code>해준다</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/ae3803d6-7046-4488-a724-eb9ba30ff1bc.gif" alt="ae3803d6-7046-4488-a724-eb9ba30ff1bc"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804125036585.png" alt="image-20220804125036585"></p>
  </li>
  <li>
    <p><strong>blackjack -&gt; 게임종료(thr)는 끝났다. 이제 <code class="language-plaintext highlighter-rouge">hit상태에서 -&gt; draw or stay</code>를 할 수 있다.</strong></p>

    <ul>
      <li><strong>일단 draw부터 만든다.</strong></li>
      <li>
<strong>hit상태에서는</strong>
        <ol>
          <li><strong>합 20이하라면, hit상태</strong></li>
          <li><strong>합21이라면, blackjack상태</strong></li>
          <li><strong>합 21초과라면, bust상태이다</strong></li>
        </ol>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">테스트에서는 case마다 인자로 넣어줘서 차근차근 개발하며, 제일 쉬운 것(hit)</code>부터 응답하게 만들어나가면 된다.</strong></li>
    </ul>
  </li>
  <li>
    <p><strong>hit응답상태에서 <code class="language-plaintext highlighter-rouge">합 20이하가 되는 인자</code>를 넣어줘 <code class="language-plaintext highlighter-rouge">다시 히트상태를 응답</code>하도록 case를 만든다.</strong></p>

    <ul>
      <li><strong>첫 case만 만들 땐, 빠르게 return이라 연산식이 없다. 하지만,,,</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/32a9fc9b-72a3-4f55-b1f6-bf7d929e9ae8.gif" alt="32a9fc9b-72a3-4f55-b1f6-bf7d929e9ae8"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804125940467.png" alt="image-20220804125940467"></p>

    <ul>
      <li>
        <p>아직까지는 hit만 빠르게 반환하도록 만든다.</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804130150609.png" alt="image-20220804130150609"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804125843507.png" alt="image-20220804125843507"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>이제 hit에서 2번째 쉬운 상태응답case인, hit -&gt; bust로 간다.</strong></p>

    <ul>
      <li>테스트를 작성하고</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804131116751.png" alt="image-20220804131116751"></p>

    <ul>
      <li>
        <p><strong>Bust 클래스를 만들고, State구현한 뒤, <code class="language-plaintext highlighter-rouge">hit의 draw()의 내부 로직을 작성해야하는데..</code></strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804131254370.png" alt="image-20220804131254370"></p>
      </li>
      <li>
        <p><strong>Hit의 트리거메서드인 draw의 2번째 case Bust를 판단하려면, <code class="language-plaintext highlighter-rouge">기존 카드정보를 모두 상태값으로 쥐고 있고 vs 메서드 인자로 넘어온 정보를 통해 상태업데이트 후 새객체반환</code>해야한다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804131617383.png" alt="image-20220804131617383"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>최초의 상태객체를 만들어내는 <code class="language-plaintext highlighter-rouge">Game.start()</code>에서 <code class="language-plaintext highlighter-rouge">현재정보를 생성자의 인자로 넘겨줘 상태값으로 가지고 있어야</code>한다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804131920221.png" alt="image-20220804131920221"></p>

    <ul>
      <li>
        <p><strong>trigger + 정보를 판단하려면, <code class="language-plaintext highlighter-rouge">상태객체는 생성시부터 이미 정보를 상태값으로 가지고 있도록</code>해야한다.</strong></p>
      </li>
      <li>
        <p><strong>최초로 상태객체가 만들어지는 곳</strong>에서 <strong><code class="language-plaintext highlighter-rouge">현재 상태를 결정하는 정보를 생성자  주입해서 물고 있자.</code></strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/d3c82900-8efc-4652-885c-f1b6844206a3.gif" alt="d3c82900-8efc-4652-885c-f1b6844206a3"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804132506391.png" alt="image-20220804132506391"></p>
      </li>
      <li>
        <p><strong>기존에 생성자 없이 사용하던 객체에, <code class="language-plaintext highlighter-rouge">상태값이 추가되어 생성자가 추가될 경우</code>, <code class="language-plaintext highlighter-rouge">부생성자로 빈값할당</code>으로 초기화해주는 <code class="language-plaintext highlighter-rouge">기본생성자</code>를 추가해서 <code class="language-plaintext highlighter-rouge">기존코드가 망가지게 않게 한다</code></strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/45c77192-814c-4c49-9d5e-a763f5ca0adb.gif" alt="45c77192-814c-4c49-9d5e-a763f5ca0adb"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804132909980.png" alt="image-20220804132909980"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804132919754.png" alt="image-20220804132919754"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804133122081.png" alt="image-20220804133122081"></p>
      </li>
      <li>
        <p><strong>또한, <code class="language-plaintext highlighter-rouge">trigger메서드내에서는 업데이트된 상태값으로 새 상태객체를 생성해서 반환</code>해줘야한다.</strong></p>

        <ul>
          <li>상태값도 포장된 일급컬렉션이라, cards + card를 처리해야한다.</li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804132354817.png" alt="image-20220804132354817"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>같은형의 일급vs단일라면 메세지를 보내서 처리해야한다. <code class="language-plaintext highlighter-rouge">주로 add가 쓰일 것이다.</code></strong></p>

    <ul>
      <li>add를 만든다면, list + add로 인해 <strong>상태변화된 불변일급컬렉션을 반환</strong>해줘야한다.</li>
      <li><strong>이 때, <code class="language-plaintext highlighter-rouge">기존 상태값(컬렉션 필드)를 얕은복사</code>후 add해야한다.</strong></li>
      <li>
<strong>컬렉션 파라미터의 사전검증</strong>으로서 <strong>일급컬렉션에서 add하여 <code class="language-plaintext highlighter-rouge">새로운 컬렉션 상태</code>를 만들어, <code class="language-plaintext highlighter-rouge">새로운 일급컬렉션 객체</code>를 불변하게 반환할 때는, <code class="language-plaintext highlighter-rouge">기존상태값을 얕은복사해서 연관성을 떼어내야한다</code></strong>
</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/679b4781-0333-4a55-8484-3cef333d5a02.gif" alt="679b4781-0333-4a55-8484-3cef333d5a02"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804154848612.png" alt="image-20220804154848612"></p>
  </li>
  <li>
    <p><strong>상태필드가 <code class="language-plaintext highlighter-rouge">객체이상, 일급컬렉션인 경우</code>, <code class="language-plaintext highlighter-rouge">현재 구체적인 값의 상태를 물어볼땐  getter대신 메세지</code>를 보낸다</strong></p>

    <ul>
      <li>
<strong>상태필드가 <code class="language-plaintext highlighter-rouge">객체이상, 일급컬렉션인 경우</code>, <code class="language-plaintext highlighter-rouge">현재 구체적인 값의 상태를 물어볼땐  getter대신 메세지</code>를 보내서 <code class="language-plaintext highlighter-rouge">값으로만 응답</code>받는다.</strong>
        <ul>
          <li><strong>이미 가진 카드들의 합을 <code class="language-plaintext highlighter-rouge">묶어서 연산</code>하도록 프로그래밍 되어있으니, <code class="language-plaintext highlighter-rouge">갯수가 늘어나도 합 연산은 그대로 유지되고, 그 메서드를 내수용으로 사용</code>하면 된다.</strong></li>
        </ul>
      </li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804155811937.png" alt="image-20220804155811937"></p>

    <ul>
      <li>
        <p>상태값이 객체이상이라면, 메서드를 보내서 현재상태를 물어본다</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/2659722a-0b81-42b2-baf2-d05d89a2f64e.gif" alt="2659722a-0b81-42b2-baf2-d05d89a2f64e"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804160524197.png" alt="image-20220804160524197"></p>
      </li>
    </ul>
  </li>
  <li>
    <p>현재 진척도</p>

    <ul>
      <li>hit or blackjack
        <ul>
          <li>
<strong>blackjack</strong> -&gt; 뽑을 시 예외발생해서 종료</li>
          <li>hit
            <ul>
              <li>hit</li>
              <li>
<strong>bust -&gt; 뽑을 시 예외발생해서 종료</strong> « 먼저 처리해주자</li>
              <li>blackjack?</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">종료상태</code>객체는 <code class="language-plaintext highlighter-rouge">trigger메서드 호출시 예외발생으로 종료</code>까지 마무리해줘야한다.</strong></p>

    <ul>
      <li>Blackjack상태객체, Bust상태객체 (앞으로 Stay도 종료상태일 것임)</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804161343735.png" alt="image-20220804161343735"></p>

    <ul>
      <li>
        <p><strong>참조변수 재할당시 람다캡처리 문제가 발생한다. 체이닝가능한 메서드는 체이닝해주자.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804161817136.png" alt="image-20220804161817136"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804161614014.png" alt="image-20220804161614014"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>setNext, add와 같이 <code class="language-plaintext highlighter-rouge">같은형 객체</code>를 반환하는 메서드들뿐만 아니라 <code class="language-plaintext highlighter-rouge">같은카테고리인 추상체</code>를 반환하는 메서드들도 <code class="language-plaintext highlighter-rouge">체이닝 메서드</code>이다.</strong></p>

    <ul>
      <li>객체반환메서드는 체이닝을 생각하자.</li>
      <li><strong>이 때, static메서드로서 게임출발을 담당했던 메서드도 <code class="language-plaintext highlighter-rouge">State</code>를 반환하는 메서드이므로 <code class="language-plaintext highlighter-rouge">체이닝 가능</code>하다</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804162044271.png" alt="image-20220804162044271"></p>
  </li>
  <li>
    <p><strong>2장인데, ace를 안 가진상태에서도 블랙잭이 될 수 있다. hit -&gt; blackjack을 개발해보자.</strong></p>

    <ul>
      <li>hit or blackjack
        <ul>
          <li>blackjack -&gt; 뽑을 시 예외발생해서 종료</li>
          <li>hit
            <ul>
              <li>hit</li>
              <li>bust -&gt; 뽑을 시 예외발생해서 종료</li>
              <li><strong>blackjack -&gt; ace를 가졋다면 합 11 , <code class="language-plaintext highlighter-rouge">ace가 없다면 합21</code>시 만족</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804163356345.png" alt="image-20220804163356345"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804163338000.png" alt="image-20220804163338000"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804221126471.png" alt="image-20220804221126471"></p>
  </li>
  <li>
    <p><strong>핵심로직을 시작하는 <code class="language-plaintext highlighter-rouge">카드2장input -&gt; 상태객체 output</code>하던 스태틱 클래스도 <code class="language-plaintext highlighter-rouge">Ready 상태</code>의 상태객체다.</strong></p>

    <ol>
      <li>
        <p>Game -&gt; Ready 수정</p>

        <ul>
          <li>
            <p>테스트의 Ready.start() -&gt; <strong>찾아바꾸기로 new Ready()</strong>.start()로 수정하자.</p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/e17fed9b-1609-49f1-a76d-868c057590ee.gif" alt="e17fed9b-1609-49f1-a76d-868c057590ee"></p>
          </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804221313986.png" alt="image-20220804221313986"></p>
      </li>
      <li>
        <p><strong>State인터페이스 구현</strong> 후 <strong>start보다 <code class="language-plaintext highlighter-rouge">구현메서드draw()를 가장 위로</code></strong></p>

        <ul>
          <li>상태를 구현한 구현객체라는 의도를 명확히 하기 위해서는 <strong><code class="language-plaintext highlighter-rouge">구상메서드를 가장 위로</code> 올린다.</strong>
</li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804221725083.png" alt="image-20220804221725083"></p>

        <ul>
          <li>
            <p><strong>상태객체 패키지로 이동시킨다.</strong></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804222040550.png" alt="image-20220804222040550"></p>
          </li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">서비스 메서드 == 스태틱 메서드 like 유틸메서드</code>에서 -&gt; <code class="language-plaintext highlighter-rouge">객체</code>가 되었다면</strong></p>

    <ul>
      <li>
        <p>상태값으로 카드 2장을 받는다.</p>
      </li>
      <li>
        <p><strong>상태값을 만드는 input들은 다 생성자로 들어와야한다.</strong></p>

        <ul>
          <li><strong>메서드로 상태값 정보가 들어온다면, setter다. 지양해야한다.</strong></li>
        </ul>
      </li>
      <li>
        <p><strong>서비스의 <code class="language-plaintext highlighter-rouge">유틸메서드 input</code> -&gt; <code class="language-plaintext highlighter-rouge">생성자로 주입</code> 된다</strong></p>
      </li>
      <li>
        <p><strong>서비스의  <code class="language-plaintext highlighter-rouge">유틸메서드내 로직을 거친 뒤 1개의 output응답값(상태객체)</code> -&gt; <code class="language-plaintext highlighter-rouge">필드</code>로 가진다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804223725402.png" alt="image-20220804223725402"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>start의 카드2장의 input은 <code class="language-plaintext highlighter-rouge">생성자로 주입</code>되고, 1개의 output인 상태객체는 필드가 되어 <code class="language-plaintext highlighter-rouge">상태객체를 초기화</code>해서 최초로 가지는 <code class="language-plaintext highlighter-rouge">상태 포장객체</code>가 Ready가 된다.</strong></p>

    <ul>
      <li><strong>즉, 서비스메서드는 나중에 <code class="language-plaintext highlighter-rouge">첫 상태객체를 초기화해서 사용하는 포장객체</code>가 되는 것이다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/5272c2d7-0faf-41ed-bfc5-3f201631f616.gif" alt="5272c2d7-0faf-41ed-bfc5-3f201631f616"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshot%0As/main/image-20220804224629295.png" alt="image-20220804224629295"></p>
  </li>
  <li>
    <p><strong>이렇게 <code class="language-plaintext highlighter-rouge">Cards</code>가 아닌 <code class="language-plaintext highlighter-rouge">다른 상태객체</code>를 가지게 되면, <code class="language-plaintext highlighter-rouge">상태객체가 아니라 상태객체를 사용하는 객체</code>가 된다.</strong></p>

    <ul>
      <li><strong>하지만, <code class="language-plaintext highlighter-rouge">Ready</code>라는 상태객체도 <code class="language-plaintext highlighter-rouge">상태를 사용할 객체가 State state의 초기값으로 가져야할</code> 객체로서  엄연히 존재해야하며 <code class="language-plaintext highlighter-rouge">다른 상태객체들처럼 draw()를 구현</code>하여 <code class="language-plaintext highlighter-rouge">다른 상태로 넘어가야 한다</code></strong></li>
    </ul>
  </li>
  <li>
    <p>정리하면</p>

    <ol>
      <li>
        <p>Ready도 <strong>다른 상태객체들과 <code class="language-plaintext highlighter-rouge">동일 상태값 필드</code>(Cards)</strong>를 가지며 <strong><code class="language-plaintext highlighter-rouge">생성자로는 아무것도 주입 안된 빈카드로 초기화</code>하는 <code class="language-plaintext highlighter-rouge">기본 생성자</code>로 만들어져야한다.</strong></p>
      </li>
      <li>
        <p>Ready도 .start()로 다른 객체로 넘어가는 것이 아닌 <strong>다른 상태객체들의 메서드처럼 <code class="language-plaintext highlighter-rouge">Trigger메서드(draw())</code>로부터 setter정보를 받아 <code class="language-plaintext highlighter-rouge">상태값업데이트 이후 상태값을 가지고 판단하여 다른 상태로 넘어가</code>도록 수정한다.</strong></p>
        <ul>
          <li><strong>Ready는 카드를 2장을 받는다. -&gt; 다른상태객체처럼 draw로 1장씩 받도록 정의하고 <code class="language-plaintext highlighter-rouge">외부에서 2번을 호출</code>하던지 <code class="language-plaintext highlighter-rouge">다른 파라미터로서 받도록 오버로딩메서드</code>로 정의해준다.</strong></li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>빈생성자 -&gt; 빈 상태값으로 생서될 수 있도록 <strong>생성자를 수정</strong>하고, <strong>다음 상태객체로 넘어가는 로직을 draw로 옮긴</strong>다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/8821434b-59bf-44fa-857c-0bf99997e8f8.gif" alt="8821434b-59bf-44fa-857c-0bf99997e8f8"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804230734646.png" alt="image-20220804230734646"></p>
  </li>
  <li>
    <p><strong>문제는 <code class="language-plaintext highlighter-rouge">Ready는 1장이 아니라 2장을 다 받은 상태에서 판단이 이루어져야하는데, 1장만 받고 hit로 바로 가고 있다.</code></strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804230943424.png" alt="image-20220804230943424"></p>
  </li>
  <li>
    <p><strong>Ready가 2장을 받은 상탠지 확인하는 것은 <code class="language-plaintext highlighter-rouge">Ready의 상태값인 cards</code>로 판단해야한다.</strong></p>

    <ul>
      <li>객체이상이므로 메세지를 던져 물어본다. <strong>너 2장 받았냐고, 아직 2장미만의 Ready상태냐고</strong>
</li>
      <li>
<strong>1장 받고 상태값이 바뀌면, 새객체를 반환해야줘야하므로 다시 new Ready(바뀐cards)로 응답한다.</strong>
        <ul>
          <li>cards로도 만들어져야하므로 생성자가 추가되고, 기존 생성자는 부생성자가 된다.</li>
        </ul>
      </li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/81ab59df-4c25-4618-99ca-509c250ba0e.gif" alt="81ab59df-4c25-4618-99ca-509c250ba0e"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804233720485.png" alt="image-20220804233720485"></p>

    <ul>
      <li>
        <p><strong>밑에 로직도 업데이트된 상태값으로 생성하도록 수정한다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804234229117.png" alt="image-20220804234229117"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>test에선 다 start(카드, 2장)으로 작성된 상태다.</strong></p>

    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">코드 수정은 기존코드start를 복사해서 수정draw</code>하고 나서 지운다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/648a43fa-9915-4db6-8955-27b213f1bc8e.gif" alt="648a43fa-9915-4db6-8955-27b213f1bc8e"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220804235357245.png" alt="image-20220804235357245"></p>

    <ul>
      <li>
        <p><strong>서비스 or 핵심로직  통합테스트가 Ready라는 1개 상태객체 테스트로 바꼈다.</strong></p>

        <ul>
          <li>
            <p><strong><code class="language-plaintext highlighter-rouge">개별 상태객체에 해당하는 코드들은 각자의 테스트로</code> 나누어서 옮긴다.</strong></p>
          </li>
          <li>
            <p><strong>비록 Ready에서 시작하지만 일단 옮겨간다.</strong></p>
          </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/647523ba-25d4-4853-9ece-f32ec5ff414e.gif" alt="647523ba-25d4-4853-9ece-f32ec5ff414e"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Ready부터 시작하는 테스트를, 해당객체부터 시작하도록 수정한다.</strong></p>

    <ul>
      <li><strong>Ready는 인자없는 생성자에서 draw()2번했지만</strong></li>
      <li><strong><code class="language-plaintext highlighter-rouge">특정상태 객체는 cards를 상태값으로 주고 시작</code>하도록 변경하면 된다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805002505575.png" alt="image-20220805002505575"></p>
  </li>
  <li>
    <p><strong>파라미터 변경한 생성자 추가해주기 -&gt; <code class="language-plaintext highlighter-rouge">파라미터 추가는 해당 파라미터로 생성자 추가한 뒤 오버로딩으로 처리</code>한다고 했다.</strong></p>

    <ul>
      <li>
        <p>client가 편해야한다.</p>
      </li>
      <li>
        <p>Cards를 만드려면 List.of() 로 묵어줘야하니, <strong>내부에서 묶어주고 가변인자로 주도록 변경해보자.</strong></p>

        <ul>
          <li>
            <p>기존
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805002739625.png" alt="image-20220805002739625"></p>
          </li>
          <li>
            <p><strong><code class="language-plaintext highlighter-rouge">인자입력시 List.of() -&gt; 가변배열</code>로 입력하도록 변경한다.</strong></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/172a6aed-0912-45a7-a0d6-ff892d0afe2f.gif" alt="172a6aed-0912-45a7-a0d6-ff892d0afe2f"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805003122391.png" alt="image-20220805003122391"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805003145189.png" alt="image-20220805003145189"></p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">상태변화가 없는 캐싱 객체</code>는 싱글톤이라, <code class="language-plaintext highlighter-rouge">testutil패키지 &gt; Fixtures클래스</code>안에 <code class="language-plaintext highlighter-rouge">상수객체</code>로 만들어 써도 된다.</strong></p>

    <ul>
      <li>
        <p>test루트에서 <code class="language-plaintext highlighter-rouge">testutil</code> 패키지를 만들고 내부 <code class="language-plaintext highlighter-rouge">Fixtures</code>를 만들자</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/bffe3520-7e82-4591-8991-e8338e197072.gif" alt="bffe3520-7e82-4591-8991-e8338e197072"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805123413269.png" alt="image-20220805123413269"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Fixtures에 쓸려면 <code class="language-plaintext highlighter-rouge">어디서든 불러도 같은 객체가 생성되도록 캐싱==싱글톤이 보장</code>되어야한다.</strong></p>

    <ul>
      <li>isSameAs로 확인해야한다.</li>
      <li><strong>만약, 캐싱객체가 아니더라도, <code class="language-plaintext highlighter-rouge">eq/hC를 재정의하여 값이 같으면 같은 객체가 되는 값객체</code>가 되어야한다. 이 땐, isEqualTo로 정의한다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805124337165.png" alt="image-20220805124337165"></p>
  </li>
  <li>
    <p>**싱글톤 캐싱객체 or VO라서, <code class="language-plaintext highlighter-rouge">생성해서 쓰면 무조건 같은 객체</code>가 보장되었다면, <code class="language-plaintext highlighter-rouge">테스트에서 쓰인 객체들의 상수추출 -&gt; Fixture로 옮겨서 재활용</code>할 수 있다. **</p>

    <ul>
      <li><strong>상수가 되면 편하게 생성안하고 편하게 쓰면 된다.</strong></li>
      <li><strong><code class="language-plaintext highlighter-rouge">한글로 Fixture를 생성해서 쓰자</code></strong></li>
      <li>상수 추출후, <strong>Fixture로 옮기기전에 미리 다 상수로 바꿔놓으면 더 쉽다(<code class="language-plaintext highlighter-rouge">ctrl+H</code>)</strong>
</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/7ed764cd-8939-486c-899a-0c81689cf785.gif" alt="7ed764cd-8939-486c-899a-0c81689cf785"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805125353849.png" alt="image-20220805125353849"></p>
  </li>
  <li>
    <p><strong>이제 <code class="language-plaintext highlighter-rouge">빈 생성자로 빈 상태값으로 시작하는 Ready의 [시작상태객체]</code>가 완성되었다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805130924167.png" alt="image-20220805130924167"></p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">시작객체</code>가 있다면, <code class="language-plaintext highlighter-rouge">같은 패키지로 몰아서 시작객체public을 제외한 나머지들은 default가시성</code>을 가지도록 해서, 외부에서 생성안되도록 한다면, <code class="language-plaintext highlighter-rouge">사전검증을 안해도 된다.</code></strong></p>

    <ul>
      <li>
<strong>만약, 생성자가 기본생성자라서 정의를 안해줬다면, <code class="language-plaintext highlighter-rouge">재정의 후 가시성변경</code>해줘야한다.</strong>
        <ul>
          <li><strong>대표적인 예가 <code class="language-plaintext highlighter-rouge">유틸클래스(상태값없이 input-&gt;output static메서드만 가지는)는 생성자를 private가시성으로 변경</code>해주는 것이다.</strong></li>
          <li><strong>생성자가 없는 클래스 -&gt; <code class="language-plaintext highlighter-rouge">public으로 열여있으며, 재료를 바탕으로 상태값을 만들지 않는 클래스</code></strong></li>
        </ul>
      </li>
      <li>client가 잘못입력할 수도 있기 때문에 <strong><code class="language-plaintext highlighter-rouge">중간에 생성되는 상태객체들</code>은 <code class="language-plaintext highlighter-rouge">외부에서 생성못하도록 가시성으로 막아주기</code></strong>
</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/9c833c96-8fe1-4e44-965e-681bbf771ffa.gif" alt="9c833c96-8fe1-4e44-965e-681bbf771ffa"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805133739069.png" alt="image-20220805133739069"></p>
  </li>
  <li>
    <p><strong>상태객체는 <code class="language-plaintext highlighter-rouge">trigger메서드(draw)</code>외에 <code class="language-plaintext highlighter-rouge">중도 stop</code>메서드와 <code class="language-plaintext highlighter-rouge">stop상태</code>를 가질 수 있다.</strong></p>

    <ul>
      <li>
        <p>ready <strong>+ trigger</strong></p>

        <ul>
          <li>blackjack</li>
          <li>hit <strong>+ trigger</strong>
            <ul>
              <li>bust</li>
              <li>
<del>blackjack</del> : 블랙잭은 2장일때만 가능이다.</li>
              <li>hit</li>
            </ul>
          </li>
          <li>hit <strong>+ stop</strong> : <strong>중도stop 메서드</strong>
            <ul>
              <li><strong><code class="language-plaintext highlighter-rouge">stay</code> : 중도 stop상태객체 반환</strong></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p><strong>stop메서드와 stop상태객체 2개를 다 만들어준다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805175144554.png" alt="image-20220805175144554"></p>
      </li>
    </ul>
  </li>
  <li>
    <p>hit상태에서 stay를 호출하도록 테스트를 짠다.
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805175856032.png" alt="image-20220805175856032"></p>
  </li>
  <li>
    <p>메서드가 반환해야할 상태객체부터 만들고, <strong>State 추상체상태의 hit에서 stay()를 만들면, 오퍼레이터로 등록된다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805180022327.png" alt="image-20220805180022327"></p>
  </li>
  <li>
    <p><strong>각 구현체는 외부에서는 추상체변수에서 다형성으로 사용되니, <code class="language-plaintext highlighter-rouge">특정 구상체(hit)에서 빨간줄 메서드로 만들면, 추상체인 인터페이스의 오퍼레이터</code>로 올라간다.</strong></p>

    <ul>
      <li>
        <p>일단 인터페이스에 생성하고 -&gt; <strong>해당 구현체만 일단 구현해보자.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/363f9945-4c87-4673-a7e5-4f418b00b0bb.gif" alt="363f9945-4c87-4673-a7e5-4f418b00b0bb"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805180538834.png" alt="image-20220805180538834"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805180525972.png" alt="image-20220805180525972"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">특정 구상체에만 사용되는 메서드</code>가 등장했다.</strong></p>

    <ul>
      <li>
        <p>상속관계면, 조합관계로 바꾼다.</p>
      </li>
      <li>
        <p><strong>이미 인터페이스를 구현하는 조합관계의 구상체였다면</strong></p>

        <ol>
          <li><strong>일단 인터페이스에 올리고, 특정구상체만 자기메서드를 로직을 구현한다.</strong></li>
          <li><strong>마저 테스트를 진행해야하니 <code class="language-plaintext highlighter-rouge">나머지 구상체들은 로직 없이 구현만 해준다</code></strong></li>
          <li><strong>이후 <code class="language-plaintext highlighter-rouge">해당메서드 테스트가 끝</code>나면, <code class="language-plaintext highlighter-rouge">특정구상체 외 사용하지 않는 구상체들에게 내리기 전</code>에 <code class="language-plaintext highlighter-rouge">중간에서 막아주는 추상클래스로 만들어지는 중간추상층</code>을 만들어준다.</strong></li>
        </ol>
      </li>
      <li>
        <p><strong>일단 모든 구상체들도 구현은 하고 특정 메서드의 테스트를 진행한다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/cc2f7b9b-ca37-4345-9a92-387415551210.gif" alt="cc2f7b9b-ca37-4345-9a92-387415551210"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805181221407.png" alt="image-20220805181221407"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>사용하지 않는 메서드를 <code class="language-plaintext highlighter-rouge">억지구현한 코드가 중복</code>이라서 <code class="language-plaintext highlighter-rouge">해당하지 않는 구상체들만 묶은 중간추상층(추상클래스)</code>를 도입하고, 거기서 구현해준다.</strong></p>

    <ul>
      <li>
        <p>중간추상층은 <strong>구상체로 내려가는 메서드를, 중간에 구현하여 중복되는 코드를 가운데서 막아준다.</strong></p>

        <ul>
          <li><strong>이 때, 중간추상층은 카테고리로서, <code class="language-plaintext highlighter-rouge">Ready는 같이 묶기엔 의미가 다르다</code></strong></li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805181543133.png" alt="image-20220805181543133"></p>
      </li>
    </ul>

    <ol>
      <li>
<strong>일단 인터페이스를 구현하는 <code class="language-plaintext highlighter-rouge">중간추상층</code> 추상클래스를 <code class="language-plaintext highlighter-rouge">형용사 상태</code>네이밍해서 만들고</strong>
        <ul>
          <li><strong>stay할 수 없는 것들은 <code class="language-plaintext highlighter-rouge">이미 끝난 Finished</code>라고 하고</strong></li>
          <li><strong>Ready는 논외로 성격이 달라, 놓아두고</strong></li>
          <li><strong>Hit도 구현하므로 놓아둔다</strong></li>
        </ul>
      </li>
      <li><strong>해당하는 구상체들은 추상클래스를 상속한다</strong></li>
      <li><strong>사용하지 않는 메서드는 <code class="language-plaintext highlighter-rouge">thr IllegalState</code>로 처리한다.</strong></li>
    </ol>
  </li>
  <li>
    <p><strong>State를 구현한 추상클래스Finished를</strong> 만들고</p>

    <ol>
      <li>abstract를 달고, 2개의 오퍼레이터 모두 구현해주되</li>
      <li><strong>먹어줄 것(stay -&gt; 사용안됨)만 남기고, 개별구현할 것들은<code class="language-plaintext highlighter-rouge">@Overide 구현 메서드들을 자식들에게 다 내려보낸다</code></strong></li>
    </ol>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/ada195af-063e-4373-a796-eaceee8ea527.gif" alt="ada195af-063e-4373-a796-eaceee8ea527"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805183950787.png" alt="image-20220805183950787"></p>

    <ol>
      <li>
        <p><strong>하위 구상체들은 인터페이스 impl이 아닌 중간추상층인 <code class="language-plaintext highlighter-rouge">Finished</code>를 extends한다</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805184042552.png" alt="image-20220805184042552"></p>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>추상클래스 도입시 <code class="language-plaintext highlighter-rouge">중간에 먹어줘서 공짜로 물려주는 것들은 final을 달아서 자시이 수정 못하게 막아야한다</code></strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805184221982.png" alt="image-20220805184221982"></p>

    <ul>
      <li>
        <p><strong>구상체가 도입되고, 추상체도 추가되었으니 다이어그램을 본다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805184548517.png" alt="image-20220805184548517"></p>
      </li>
      <li>
        <p><strong>추상클래스 도입후 <code class="language-plaintext highlighter-rouge">눈꽃모양의 final</code>을 확인하자.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220805185002337.png" alt="image-20220805185002337"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>모든 구상체에 대해 <code class="language-plaintext highlighter-rouge">stay()</code>메서드가 추가되었으니 메서드 테스트를 추가한다.</strong></p>

    <ul>
      <li>blackjack, bust, stay -&gt; finished -&gt; stay호출시 예외</li>
      <li>ready -&gt; stay호출 시 예외</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806125452720.png" alt="image-20220806125452720"></p>

    <ul>
      <li><strong>Stay 도메인객체가 추가되었으니, 생성 및 메서드 테스트를 해야한다.</strong></li>
    </ul>
  </li>
  <li>
    <p><strong>상태패턴의 상태객체반환 with trigger되는 <code class="language-plaintext highlighter-rouge">결국엔 다른 객체의 상태값으로 포장</code>될 <code class="language-plaintext highlighter-rouge">객체</code>들은 <code class="language-plaintext highlighter-rouge">view에 넘기기 위해 getter를 무조건 가진다</code></strong></p>

    <ul>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">trigger 등 set계열 메서드들 개발이 완료되면 getter도 개발</code>해야한다.</strong></p>
      </li>
      <li>
        <p><strong>원래 <code class="language-plaintext highlighter-rouge">추상클래스의 중복필드처리</code>는 <code class="language-plaintext highlighter-rouge">부모필드는 생성자 정의없이 -&gt; setter만든 뒤, setter주입</code>되어서 <code class="language-plaintext highlighter-rouge">자식이 super를 못쓰게 해야하는데..</code></strong></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>복잡한 구조에서 <code class="language-plaintext highlighter-rouge">getter</code>개발하기</strong></p>

    <ul>
      <li><strong>현재는 복잡한 구조로 되어있기 때문에, <code class="language-plaintext highlighter-rouge">메서드 개발을 1개의 구현체에서부터 올리기</code>를 하진 못한다. <code class="language-plaintext highlighter-rouge">최상위 인터페이스State에서 정의후 하나씩 내려오기</code>해야한다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806133501868.png" alt="image-20220806133501868"></p>

    <ol>
      <li>
        <p><strong>최상위 인터페이스에 getter를 정의하되 <code class="language-plaintext highlighter-rouge">값의 반환</code>이 아닐 때는 <code class="language-plaintext highlighter-rouge">.get필드()</code>대신 <code class="language-plaintext highlighter-rouge">.객체()</code>형식으로 정의해본다.</strong></p>

        <ul>
          <li>인터페이스에서는 접근제한자가 public이 default이므로 두고 <strong>반환형을 상태값 Cards로 주면서, 메서드명도 cards()의 필드명으로 만들자</strong>
</li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/09e19aec-4613-43ef-813f-ecf2fee9b6c8.gif" alt="09e19aec-4613-43ef-813f-ecf2fee9b6c8"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806135501987.png" alt="image-20220806135501987"></p>
      </li>
      <li>
        <p><strong>개별 구상체(Ready, Hit)는 바로 구현하되, <code class="language-plaintext highlighter-rouge">중간추상층 Finished</code>에서는 해당오퍼레이터가 중복인지 확인한다.</strong></p>

        <ul>
          <li>
            <p><strong>getter오퍼레이터의 구현은 <code class="language-plaintext highlighter-rouge">getter구현 전에 필드값이 존재</code>해야하는데</strong></p>

            <ul>
              <li>
                <p><strong>중간추상층의 부모가 없다면, 바로 <code class="language-plaintext highlighter-rouge">자신의 필드를 반환</code>해주면 된다.</strong></p>
              </li>
              <li>
                <p>Ready / Hit 구상체</p>
              </li>
            </ul>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/48e74868-8edf-456e-99b8-e8ba38a8c9b4.gif" alt="48e74868-8edf-456e-99b8-e8ba38a8c9b4"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806135930790.png" alt="image-20220806135930790"></p>
          </li>
          <li>
            <p>**<code class="language-plaintext highlighter-rouge">중간추상층에서 먹어준다면, [좋은 부모로서 생성자없이 setter로 -&gt; private필드올릴 준비]를 해야한다</code> **</p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806140117699.png" alt="image-20220806140117699"></p>
          </li>
        </ul>
      </li>
      <li>
        <p><strong>3개 구상체에 대해 <code class="language-plaintext highlighter-rouge">공통getter</code>라고 판단이 들었으면, <code class="language-plaintext highlighter-rouge">final 템플릿</code>메서드로서 <code class="language-plaintext highlighter-rouge">중간에서 먹어준다</code></strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/c9ed91ed-d0dd-418f-8466-47dac1b52d4d.gif" alt="c9ed91ed-d0dd-418f-8466-47dac1b52d4d"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806140435264.png" alt="image-20220806140435264"></p>

        <ul>
          <li>
            <p><strong>추상클래스는 무조건 public final</strong> or protected abstract다</p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806140531052.png" alt="image-20220806140531052"></p>
          </li>
        </ul>
      </li>
      <li>
        <p><strong>문제는, <code class="language-plaintext highlighter-rouge">getter로 반환될 필드를 부모인 중간추상층에 올리는 순간</code>, 부모의 생성자가 정의되어 <code class="language-plaintext highlighter-rouge">자식이 super를 쓰는 불상사</code>가 생길 수 있다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806140408780.png" alt="image-20220806140408780"></p>
      </li>
      <li>
        <p><strong>부모는 해당필드에 대해 <code class="language-plaintext highlighter-rouge">생성자가 아닌 public final setter</code>로 객체를 초기화시키며</strong></p>

        <ol>
          <li>
            <p><strong>해당 부모의 <code class="language-plaintext highlighter-rouge">구상체 자식들은 안보이지만 setter를 이용해서 해당 필드를 채워야한다</code></strong></p>

            <ol>
              <li>
                <p><strong>맞는지 모르겠지만, setter로 인해 상태값 변화했으면, 변화된 객체를 반환해줘서 <code class="language-plaintext highlighter-rouge">체이닝</code>가능하게 한다</strong></p>

                <ul>
                  <li>
                    <p>예시</p>

                    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806141343001.png" alt="image-20220806141343001"></p>

                    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806141236714.png" alt="image-20220806141236714"></p>
                  </li>
                </ul>
              </li>
            </ol>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/ad86e7b6-b7a6-4c9e-b66b-9a45db6744ba.gif" alt="ad86e7b6-b7a6-4c9e-b66b-9a45db6744ba"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806141431436.png" alt="image-20220806141431436"></p>
          </li>
          <li>
            <p><strong>기존에 cards를 생성자 주입했던 구상체들은 setter로 변경해야한다.?!</strong></p>
          </li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<p>​</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>6. **부모가 `getter를 먹으려면 + 공통의 필드 cards`까지 먹어야했다.**
   ![image-20220806141621141](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806141621141.png)

7. **자식들은 getter구현 안한 상태 유지 + `공통필드 + 그 생성자까지 제거`해줘야한다.**

   ![dbbd4ebb-90b5-4ed0-a344-3de8cfc09e02](https://raw.githubusercontent.com/is3js/screenshots/main/dbbd4ebb-90b5-4ed0-a344-3de8cfc09e02.gif)

   ![image-20220806141930165](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806141930165.png)

8. **자식들이 그동안 테스트에서 `new Blackjack( cards )`를 사용한 부분은**

   1. **부모에 위치하는 `부모 속 공통필드에 템플릿setter로 공급`하고 -&gt; `템플릿getter`를 사용해서 해당 필드를 조회할 수 있다.**

      ![b01ac58e-55d8-4730-aa34-d4007ea55429](https://raw.githubusercontent.com/is3js/screenshots/main/b01ac58e-55d8-4730-aa34-d4007ea55429.gif)

   2. **생성자주입으로 사용하던 객체를 -&gt; [부모공통필드로 옮기는 바람에 setter로]사용해야된다면, 코드변화가 많지는 않다**

      1. new 객체(  주입  )   -&gt; new 객체**( ). setter**(  주입  )

         ![image-20220806142627252](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806142627252.png)

         ![image-20220806142650775](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806142650775.png)
</code></pre></div></div>

<p>​</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>9. **getter구현이 완료되었으면 getter에 대해서 생각해보기**

   - **만약 view로 반환하는 객체가 `불변객체(불변일급 -&gt; 상태변화시 새객체 반환)`라면, `DTO가 필요없고, public getter가 가능`하다.**
     - 객체의 **상태를 변화시키는 set계열을 호출해봤자 `내부에서는 새객체를 반환`되는 메서드만 제공**된다.
       ![image-20220806145015195](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806145015195.png)
     - **객체의 상태를 꺼내보는 get계열을 호출해봤자 **
       - **`컬렉션 필드라면, 이미 내부에서 생성자복사(얕은복사)`를 통해 `기존상태값과의 연결을 끊어놓은 상태`로 내준다.** 
       - **그 내부의 개별요소 객체들을 set계열로 호출해봤자 새객체가 반환된다.**
       - 개별객체들은 get계열로 호출해도 연결안되고 반환된다.
   - **view로 보내는 `컬렉션 필드 반환 getter들은 깊은 복사`를 이미 하고 있어야한다.**
     - **조작불가 + 깊은복사까지 이루어져야한다.**
     - **개별요소들을 view에선 건들이면 안되기 때문**
   - **암기getter**
     1. **`getter정의시 return 불변객체`라면, `public열어두기 가능 + dto없어도 됨`** 
        - **불변의 일급컬렉션 객체 반환 -&gt; dto없는 public getter로 제공**
        - **불변객체 아니라면, `Dto로 만들어서 반환`**
     2. **`getter정의시 return 컬렉션필드라면, view로 보낼 땐, 깊은 복사로 못건들게 해서 반환`**
        - **불변의 일급컬렉션 `자신 내부의 컬렉션 필드 반환`**
          - server사이드 반환이라면, 얕은복사 반환후, 내부에서 객체들 조작
          - **view반환이라면,  `깊은 복사 반환 or DTO로 반환` 후, 내부 객체들 조작안되게**

10. **Ready도 getter가 있어야하나?**

    - 0개 카드 확인? 1개 카드 확인? -&gt; **갯수만 메세지보내서 확인하면 되는데, 내부까지??**

    - 선택이다
      1. **Ready는 `카드 2장채워질때까지==다른상태객체 될때까지` 값을 반환안하려면 `thr`로 막아주기**
      2. **보여줘도 되면 getter구현**
</code></pre></div></div>

<ol>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">getter 추가 -&gt; 중복필드로서 같이 움직이는 해당 상태값</code>이 추가된 상황에서</strong></p>

    <ol>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">최상위 인터페이스에서부터 추가</code>되었으며</strong></p>
      </li>
      <li>
        <p><strong>구현시, <code class="language-plaintext highlighter-rouge">어느 구상체들도 thr로 예외없이 다 100% 다 구현</code>된 상태라면</strong></p>
      </li>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">구상체 100%구현 메서드 + 필드</code>로서 <code class="language-plaintext highlighter-rouge">중복제거를 위한 중간추상층</code>이 추가된다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806171853571.png" alt="image-20220806171853571"></p>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>추상클래스 이름은 Finished를 포함하여 모든 구상체를 아루는 형용사인 <code class="language-plaintext highlighter-rouge">Started(시작된 상태)</code>로 한다.</strong></p>

    <ol>
      <li>
        <p>State인터페이스를 구현한 추상클래스를 만든다.</p>
      </li>
      <li>
        <p><strong>getter만 구현하여 막아주고, <code class="language-plaintext highlighter-rouge">구상체 100% 동일구현이 아닌</code> 나머지는 다 흘려보낸다</strong></p>
      </li>
      <li>
        <p><strong>중복된 필드의 구현이라면 <code class="language-plaintext highlighter-rouge">생성자 대신 public final 템플릿 setter로 정의</code>한다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/463ad1ff-3be7-4fee-a21a-29df67773e8e.gif" alt="463ad1ff-3be7-4fee-a21a-29df67773e8e"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806172328738.png" alt="image-20220806172328738"></p>
      </li>
      <li>
        <p><strong>하위에 있는 추상클래스Finsished,  Ready, Hit는 State가 아닌 <code class="language-plaintext highlighter-rouge">Started중간추상층을 extends</code>하고 <code class="language-plaintext highlighter-rouge">중복되는 getter + 필드 + 생성자</code>를 모두 제거한 뒤, <code class="language-plaintext highlighter-rouge">필드를 사용하던 곳은 getter로 / 생성자로 받던 재료는 setter로</code> 변경해야한다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/2b588ebe-2d36-4432-91cb-cfe5e9921ec8.gif" alt="2b588ebe-2d36-4432-91cb-cfe5e9921ec8"></p>

        <ul>
          <li>
            <p>Finished</p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806172934736.png" alt="image-20220806172934736"></p>
          </li>
          <li>
            <p>Ready</p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806173016138.png" alt="image-20220806173016138"></p>
          </li>
          <li>
            <p>Hit</p>

            <ul>
              <li><strong>자신의 필드 cards를 사용하던 곳은 <code class="language-plaintext highlighter-rouge">부모가 물려준 중복메서드인 템플릿 getter -&gt;  cards()</code>를 내수용으로 사용한다.</strong></li>
              <li><strong>자신의 생성자 주입으로 상태를 받았던 것을 <code class="language-plaintext highlighter-rouge">부모가 물려준 중복메서드의 템플릿 setter를 이용해 물려받는 -&gt; 부모의 field를 채우고</code> -&gt; 나는 getter cards()만 사용할 수 있게 한다</strong></li>
            </ul>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806173057219.png" alt="image-20220806173057219"></p>
          </li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>추상클래스로 중복필드 + <code class="language-plaintext highlighter-rouge">생성자까지 제거 하다보니 -&gt; 생성자가 없으면 public생성자</code>상태가 되어버렸다.</strong></p>

    <ol>
      <li>
        <p><strong>하지만, <code class="language-plaintext highlighter-rouge">패키지내 중간객체 클래스</code> or <code class="language-plaintext highlighter-rouge">유틸메서드 클래스</code>의 생성자들은 <code class="language-plaintext highlighter-rouge">default와 private</code>으로 잠겨있어야한다.</strong>
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806174625925.png" alt="image-20220806174625925"></p>
      </li>
      <li>
        <p><strong>패키지내 시작객체 <code class="language-plaintext highlighter-rouge">Ready를 제외한 모든 구상 상태겍체들의 보이지 않는 기본생성자를 재정의해서 default로 변경</code>해주자</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/01daf272-6ec1-4677-aaa8-56914dc508bf.gif" alt="01daf272-6ec1-4677-aaa8-56914dc508bf"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806174957587.png" alt="image-20220806174957587"></p>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>상태객체의 인터페이스 <code class="language-plaintext highlighter-rouge">오퍼레이터는 최소 4개+ @가 필요</code>하다</strong></p>

    <ol>
      <li>
        <p>trigger 메서드: draw()</p>
      </li>
      <li>
        <p>중단 메서드:  stay()</p>
      </li>
      <li>
        <p>현재상태값 반환메서드: getter cards()</p>
      </li>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">is특정[중간추상층]인지</code> 확인 메서드: boolean isXXXX()</strong></p>

        <ul>
          <li>
            <p><strong>여기서는 stay개발시 불가하여 묶여진 <code class="language-plaintext highlighter-rouge">Finished 형용사 중간추상층</code>이 이미 있으니 <code class="language-plaintext highlighter-rouge">끝난 상태냐</code>라고 물어볼 수 있다.</strong></p>

            <ul>
              <li><strong><code class="language-plaintext highlighter-rouge">특정 구상체인지는 물어보지 않는다. 그놈빼고 다 false를 대답하기 때문에</code> -&gt; <code class="language-plaintext highlighter-rouge">특정 구상체인지는 물어보지말고 메세지를 던진다.</code></strong></li>
            </ul>
          </li>
          <li>
            <p><strong><code class="language-plaintext highlighter-rouge">다형성 인터페이스에 존재하는 boolean 메서드는 -&gt; 구상체들이 구현만 해주면 알아서 개별 답변되는 메서드</code>다</strong></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806180149358.png" alt="image-20220806180149358"></p>
          </li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>State인터페이스에 <strong>특정상태(그룹, 중간추상층) 확인 메서드를 구현하고</strong></p>

    <ul>
      <li>
        <p>Started는 건너띄고, <strong>Finished에서는 True / 나머지 구상체 Ready, Hit에서는 False를 return하자</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806182142251.png" alt="image-20220806182142251"></p>

        <ul>
          <li><strong>Finished에서 구현했다면, 추클로서 중간에 중복을 먹어 구현하였으니 final을 달아야한다</strong></li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/cb59d4e9-72ca-45c4-ac00-88d08c67c334.gif" alt="cb59d4e9-72ca-45c4-ac00-88d08c67c334"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806182052780.png" alt="image-20220806182052780"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806182039996.png" alt="image-20220806182039996"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806182119187.png" alt="image-20220806182119187"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>상태객체의 인터페이스 <code class="language-plaintext highlighter-rouge">오퍼레이터는 최소 4개+ @가 필요</code>하다</strong></p>

    <ol>
      <li>trigger 메서드: draw()</li>
      <li>중단 메서드:  stay()</li>
      <li>현재상태값 반환메서드: getter cards()</li>
      <li>is끝난상태[중간추상층]인지` 확인 메서드: boolean isXXXX()</li>
      <li>
<strong>현재 상태객체를 만드는 상태값Cards를 이용해서, <code class="language-plaintext highlighter-rouge">정보를 가진놈이 기능을 가진다</code></strong>
        <ul>
          <li><strong>정보전문가패턴에 따라, 상태값으로 가능한 연산은, 가진 놈이 한다.</strong></li>
          <li>cards를 가진 <strong>state객체가, cards로 계산하는 것을 한다.</strong>
</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">상태별 수익계산 profit()</code>메서드를 State인터페이스에 구현해보자.</strong></p>

    <ul>
      <li>
        <p>만약, <strong><code class="language-plaintext highlighter-rouge">추상체변수만의 구상체별 자동 구현</code></strong>을 모른다면? <strong>state객체를 보유한 player 내부에서</strong></p>

        <ul>
          <li>
            <p><strong><code class="language-plaintext highlighter-rouge">state.isBlackjack()</code>?  -&gt; 블랙잭 계산</strong></p>
          </li>
          <li>
            <p><strong><code class="language-plaintext highlighter-rouge">state.isBust()</code>?  -&gt; 0 반환</strong></p>
          </li>
          <li>
            <p><strong><code class="language-plaintext highlighter-rouge">state.isStay()</code>?  -&gt; Stay 계산</strong></p>
          </li>
          <li>
            <p>하나하나 다 확인해서 그에 따른 계산을 해줘야한다.</p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806183305823.png" alt="image-20220806183305823"></p>
          </li>
        </ul>
      </li>
      <li>
        <p><strong>추상체변수의 <code class="language-plaintext highlighter-rouge">구상체별 기능 구현</code>은 <code class="language-plaintext highlighter-rouge">전략패턴처럼 구현만 하면 알아서 적용</code>된다.</strong></p>

        <ul>
          <li>
<strong>이미 외부생성(전략패턴) or trigger메서드(상태패턴)에 의해</strong>  State state안에는 Blackjack이나 Bust나 Stay가 담겨있는 상태다
            <ul>
              <li><strong>개별로 구현만 해주면, 알아서 작동한다.</strong></li>
            </ul>
          </li>
          <li><strong>대신, 알아서 계산안되어야할 놈들은 thr나 예외처리 해놔야한다.</strong></li>
        </ul>
      </li>
      <li>
        <p><strong>추상체 변수의 <code class="language-plaintext highlighter-rouge">상태이용 개별구현 메서드</code>는 구상체를 물어보지말고 구현만 해놓으면 알아서 적용된다.</strong></p>

        <ul>
          <li><strong>상태값이 일반 객체였으면… 물어보고 판단했을 것인데… 추상체변수인 순간 알아서 구현됨을 생각하자.</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>State 인터페이스에 <code class="language-plaintext highlighter-rouge">전략패턴과 달리, 구상체들이 가진 상태값cards</code>를 바탕으로 계산하는 기능인 <code class="language-plaintext highlighter-rouge">profit</code>을 구현하되, <code class="language-plaintext highlighter-rouge">파라미터로 [계산마다 바뀔 수 있는 필요정보 betMoney]</code>를 인자로 받자</strong></p>

    <ul>
      <li>
        <p><strong>구상체들이 상태값을 가지는 경우, 인터페이스 오퍼레이트는 상태값을 이용한 계산 기능도 추가할 수 있다.</strong></p>

        <ul>
          <li>getter도 그랬고..</li>
        </ul>
      </li>
      <li>
        <p><strong>인터페이스에 메서드를 올리는 순간 <code class="language-plaintext highlighter-rouge">알아서 구상체별로 개별구현되는 메서드구나</code> 생각하자</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806185128475.png" alt="image-20220806185128475"></p>
      </li>
      <li>
        <p><strong>계산의 대상은 <code class="language-plaintext highlighter-rouge">이미 끝난 상태의 Finished</code>만 해당이 된다.</strong></p>

        <ul>
          <li>
            <p>Ready와 Hit는 <strong>예외상황으로 먼저 막아놓자.</strong></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/7512c061-e33e-47a6-be67-89107122610d.gif" alt="7512c061-e33e-47a6-be67-89107122610d"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806185930878.png" alt="image-20220806185930878"></p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">구상체들에서 개별구현되니 일단은 중간추상층(Finished)는 건너띄고 구현</code>한다</strong></p>

    <ul>
      <li>Blackjack -&gt; betMoney의 2배 반환
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806190556279.png" alt="image-20220806190556279">
</li>
      <li>Bust -&gt; <strong>-1을 곱해 반환 (그만큼 손해)</strong>
</li>
      <li>Stay -&gt; 추가정보가 더 필요하니 계산말고 그냥 반환</li>
    </ul>
  </li>
  <li>
    <p><strong>중간추상층이 좋은 부모가 되려면, <code class="language-plaintext highlighter-rouge">공통점이 아예 없는 개별구현로직 조차, 개별구현훅메서드를 래핑하고 있는 public final 템플릿메소드</code>로 가지고 있고, <code class="language-plaintext highlighter-rouge">서로 다른 로직은 protected abstract 훅메서드만 내보내줘야한다.</code></strong></p>

    <ol>
      <li>
        <p>CompareFile(ctrl+D)로 <strong>구상체 메서드들의 공통점과 차이점</strong>을 살펴보고, <strong><code class="language-plaintext highlighter-rouge">어느부분까지를 훅메서드로 뺄 것인지 생각</code>한다.</strong></p>

        <ul>
          <li><strong>상수만 서로 달라도, 해당부분을 훅 메서드로 뺄 수 있다.</strong></li>
        </ul>
      </li>
      <li>
        <p><strong>구상체들 중 <code class="language-plaintext highlighter-rouge">서로 다른 훅 부분에  가장 파라미터가 많이 사용되는 로직</code>을 가진 구상체 1개를 선택하고 <code class="language-plaintext highlighter-rouge">해당 메서드를 중간추상층으로 잘라내서 올린다</code></strong></p>
      </li>
      <li>
        <p><strong>올린 public 템플릿메서드 내부에서 <code class="language-plaintext highlighter-rouge">다른 부분만 내수용 메서드 추출(구상체private -&gt; 추상체protected abstract)의 훅메서드로 만든다</code></strong></p>

        <ul>
          <li><strong>올리고 나서 훅을 만든다면, <code class="language-plaintext highlighter-rouge">메서드 추출후 가시성을 private -&gt; protected abstract로 직접 변경</code>해줘야한다.</strong></li>
          <li><strong>올린 템플릿메서드는 final로…</strong></li>
        </ul>
      </li>
      <li>
        <p><strong>나머지 구상체들은, <code class="language-plaintext highlighter-rouge">훅메서드를 구현</code>하면서, 기존 구현메서드의 다른 부분만 훅에 입력한 뒤, 기존 메서드는 삭제해준다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/e46c06eb-6722-429a-8311-3ff3f0fb6af9.gif" alt="e46c06eb-6722-429a-8311-3ff3f0fb6af9"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806225502853.png" alt="image-20220806225502853"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806225516439.png" alt="image-20220806225516439"></p>
      </li>
      <li>
        <p><strong>public 템플릿메소드는 final을 달아준다. 깜빡했으면…</strong>
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806225611306.png" alt="image-20220806225611306"></p>
      </li>
    </ol>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">중복제거 등 추상화/상속 관련작업</code>이 끝날 때마다, diagram을 보자</strong></p>

    <ul>
      <li><strong>복잡하다면, 생성자+method만 키고 보자.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806230604477.png" alt="image-20220806230604477"></p>

    <ul>
      <li>
        <p><strong>추상화 레벨을 보고 싶다면, <code class="language-plaintext highlighter-rouge">바로 위의 추상클래스에 데고 usage(shift+F12)</code>를 통해 <code class="language-plaintext highlighter-rouge">어떤 놈들이 나를 직접 extends했는지</code>확인하면 된다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806231001237.png" alt="image-20220806231001237"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Finished <code class="language-plaintext highlighter-rouge">기존 중간추상층과 추상화레벨을 맞추기</code> 위해 <code class="language-plaintext highlighter-rouge">Ready</code>와 <code class="language-plaintext highlighter-rouge">Hit</code>구상체의 공통점과 차이점을 확인한다.</strong></p>

    <ul>
      <li>
        <p>draw, stay는 구현내용이 개별구현으로 100% 달라서 일단 유지하고</p>
      </li>
      <li>
        <p><strong>profit()과 isFinished()는 비슷한게 아니라 완전히 동일</strong>하므로, <strong>추상층에 올릴 것이다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806232414858.png" alt="image-20220806232414858"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>finished에 대항하는 isFinished false를 가진 <code class="language-plaintext highlighter-rouge">형용사 중간추상층 Running</code>을 만든다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is2js/screenshots/main/image-20220323000036426.png" alt=""></p>

    <ol>
      <li>
        <p>Started를 구현하고, Ready에서 공통메서드만 중간에서 먹어준다.</p>
      </li>
      <li>
        <p>abstract클래스며, 중복코드를 제거하는 템플릿메소드들은 final을 달아준다.</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/449c9322-56b1-419d-88c8-13a04d0463b5.gif" alt="449c9322-56b1-419d-88c8-13a04d0463b5"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806232957330.png" alt="image-20220806232957330"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806233009526.png" alt="image-20220806233009526"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806233220821.png" alt="image-20220806233220821"></p>
      </li>
    </ol>
  </li>
  <li>
    <p>이제 추상화레벨이 맞춰졌다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807000217047.png" alt="image-20220807000217047"></p>
  </li>
  <li>
    <p><strong>부가적인 처리로서, <code class="language-plaintext highlighter-rouge">자식들은 훅메서드만 가지도록 좋은 부모 만들기</code>의 일환으로</strong></p>

    <ul>
      <li><strong>100% 로직이 달라도 메서드명만 같다면, 100% 훅메서드인 포장 public final template으로 올리자.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807001054996.png" alt="image-20220807001054996"></p>

    <ul>
      <li>
        <p><strong>문제는 오퍼레이터 메서드명은 유지되어야하는데, 100% 훅메서드명을 동일하게 못잡으니 어렵다.</strong></p>

        <ul>
          <li>
            <p>draw -&gt; drawFrom</p>
          </li>
          <li>
            <p>stay -&gt; stayEach</p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/ef036983-3849-4d1c-a20a-f62a28f58644.gif" alt="ef036983-3849-4d1c-a20a-f62a28f58644"></p>
          </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807001808286.png" alt="image-20220807001808286"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807001832475.png" alt="image-20220807001832475"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807001851504.png" alt="image-20220807001851504"></p>
      </li>
      <li>
        <p>자식 구상체들은 훅만 소유</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807002018941.png" alt="image-20220807002018941"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Finished에서도 좋은 부모를 만들기 위해 템플릿메서드로 올리고, 자식들은 훅만 소유하도록 변경해보자.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807002057853.png" alt="image-20220807002057853"></p>

    <ul>
      <li>
        <p>draw를 중간추상층의 템플릿메서드로 올리자</p>

        <ul>
          <li>
            <p><strong>100%로직이 같아서 훅메서드를 뽑을 필요가 없었다.</strong></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/1388bb0d-489b-470a-98f9-ab96ad095260.gif" alt="1388bb0d-489b-470a-98f9-ab96ad095260"></p>
          </li>
          <li>
            <p><strong>final을 달아주는 것을 깜빡해서 달아주자.</strong></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807002635494.png" alt="image-20220807002635494"></p>
          </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807002715139.png" alt="image-20220807002715139"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>그러고보니, <code class="language-plaintext highlighter-rouge">중간추상층 2개도 상위 추상클래스로 올릴 수 있을 것</code>같은데, <code class="language-plaintext highlighter-rouge">훅을 메서드 vs 안가진 메서드</code> 등의 차이도 있고, 카테고리 문제도 있어서 일단 여기까지만 처리한다.</strong></p>

    <ul>
      <li><strong>구상체(자식들)은 모두 훅메서드만 가졌다.</strong></li>
      <li>전략패턴으로 변경된다면, 전부 전략메서드만 구현하게 되는 것이다.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807003348526.png" alt="image-20220807003348526"></p>
  </li>
  <li>
    <p><strong>이제 <code class="language-plaintext highlighter-rouge">상태객체를 추상체변수로 소유해서 사용하는 Player</code>를 다른 패키지에서 생성한다.</strong></p>

    <ul>
      <li>
        <p><strong>상태객체는 trigger에 의해 계속 변화므로 <code class="language-plaintext highlighter-rouge">not final 필드초기화</code>+ <code class="language-plaintext highlighter-rouge">set계열메서드</code>로 가지고 있는다.</strong></p>
      </li>
      <li>
        <p><strong>상태를 바꾸는 set계열이지만, <code class="language-plaintext highlighter-rouge">이미 정해진 종류의 상태를 가진다면 set대신 public void toggle</code>에 가깝다.</strong></p>

        <ul>
          <li>필드초기화시 유일하게 열린 Ready 로 만든다.</li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/d8da10a5-85d0-4523-8dd7-7b5c05fc2bd9.gif" alt="d8da10a5-85d0-4523-8dd7-7b5c05fc2bd9"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807010832575.png" alt="image-20220807010832575"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">메서드가 호출객체(자신)의 상태가 변하는 메서드(setter/toggle계열)</code>때, <code class="language-plaintext highlighter-rouge">호출객체(state) 상테에 따른, 제한[호출시 예외발생코드가 존재]이 있는 action</code>이라면, <code class="language-plaintext highlighter-rouge">if문으로 [예외발생 코드 상태로 진입못하게 하는] 상태condition을 확인</code>후 시행해야한다.</strong></p>

    <ul>
      <li><strong>state가 blackjack, bust, stay로 업데이트되었다면,  draw를 호출 시 예외가 발생한다.</strong></li>
      <li>
<strong>애초에 해당 상태(Finished)가 아닐때만 호출하도록 condition을 걸고 시행한다</strong>
        <ul>
          <li><strong><code class="language-plaintext highlighter-rouge">예외발생 코드를 짜놨찌만, 그쪽에 도달하지 못하게 막아주는 것이다.</code></strong></li>
        </ul>
      </li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807011225148.png" alt="image-20220807011225148"></p>
  </li>
  <li>
    <p><strong>만약, <code class="language-plaintext highlighter-rouge">매번 확인하며 자신을 업데이트</code>하는 작업을 <code class="language-plaintext highlighter-rouge">여러번 &amp;&amp; 조건불만족시까지 반복</code>하고 싶다면 -&gt; <code class="language-plaintext highlighter-rouge">if condition + set계열 action의 반복문이 while</code>이다.</strong></p>

    <ul>
      <li>
        <p><strong>이 때, 파라미터는 <code class="language-plaintext highlighter-rouge">Cards의 컬렉션 뭉태기</code>가 아니라 <code class="language-plaintext highlighter-rouge">반복이 끝날때까지, iterator로서 1개씩 재료 제공메서드()getter를 제공해주는 객체</code>가 파라미터로 와야한다.</strong></p>

        <ul>
          <li>
            <p><strong>1번일 때 파라미터가 Card라고 해서 -&gt; Cards 나 Cards컬렉션을 생각하지말고 <code class="language-plaintext highlighter-rouge">iterator같은 객체</code>를 생각하자. <code class="language-plaintext highlighter-rouge">public 메서드의 파라미터 == 외부에서 생성되어 들어옴 -&gt; 도메인 객체를 외부에 함부러</code> -&gt; 허용하지말자</strong></p>

            <ul>
              <li><strong><code class="language-plaintext highlighter-rouge">my) 데이터(도메인)객체를 함부로 외부에서 생성하도록 public 메서드의 파라미터로 받지말자.</code> -&gt; <code class="language-plaintext highlighter-rouge">내부에서 생성하거나, 내부에서 iter로 받자</code> -&gt; <code class="language-plaintext highlighter-rouge">도메인객체의 메서드가 public으로서 외부에 공개된 것이면 상관없지만, 일단  내부생성/캡슐화 조달(iter)로 받자</code></strong></li>
            </ul>
          </li>
          <li>
            <p><strong>반복이 끝날때까지, 매번 재료를 1개씩 제공해줘야한다.</strong></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/92e5fda9-5ab5-4e79-84dd-43f21d423298.gif" alt="92e5fda9-5ab5-4e79-84dd-43f21d423298"></p>
          </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807012819734.png" alt="image-20220807012819734"></p>
      </li>
    </ul>
  </li>
  <li>
    <p>카드를 1장씩 제공해줄 수 있는 Deck을 만들어보자.</p>

    <ol>
      <li>
        <p><strong>Deque의 재료 컬렉션을 생성할 땐, <code class="language-plaintext highlighter-rouge">ArrayList</code>로 일단 생성하고</strong></p>
      </li>
      <li>
        <p><strong>제공할 때, 얕은복사(생성자복사)시 <code class="language-plaintext highlighter-rouge">new ArrayDeque&lt;&gt;( list )</code>의 <code class="language-plaintext highlighter-rouge">생성자 복사시 형 변환하여 deque를 제공</code>해주면 된다.</strong></p>
      </li>
      <li>
        <p><strong>이 때, <code class="language-plaintext highlighter-rouge">랜덤으로 섞인 것을 제공해주려면, ArrayList를 먼저 shuffle한 뒤, deque로 생성자복사해서 제공</code>한다</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807123437674.png" alt="image-20220807123437674"></p>
      </li>
      <li>
        <p><strong>가변 콜렉션 -&gt; append을 써서 생성하는 것은 <code class="language-plaintext highlighter-rouge">stream으로 묶어서 일괄처리</code>가 가능하다.</strong></p>

        <ol>
          <li>
            <p>2중 for문은 <strong>stream -&gt; map -&gt; stream -&gt; 기존map을 flatmap후 바깥에서 collect</strong>하면 된다.</p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/51f7b591-8476-421e-ae82-602aff5abaaa.gif" alt="51f7b591-8476-421e-ae82-602aff5abaaa"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807124141031.png" alt="image-20220807124141031"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807124150334.png" alt="image-20220807124150334"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807124206100.png" alt="image-20220807124206100"></p>
          </li>
        </ol>
      </li>
      <li>
        <p><strong>생성자에서 쓰이는 <code class="language-plaintext highlighter-rouge">내부context(보라색)은 필드</code>인데, <code class="language-plaintext highlighter-rouge">내부 필드 초기화</code>는 <code class="language-plaintext highlighter-rouge">메서드 추출시 안뽑히고 내수용메서드가 되어버리니, 필드 초기화하는 = 우항값을 지역변수로 뽑아서, [필드 = 초기화]가 아닌 [지역변수 할당 = ]해서 필드초기화는 제외시키고, 위쪽만 메서드 추출하자.</code></strong></p>

        <ul>
          <li>
            <p><strong><code class="language-plaintext highlighter-rouge">메서드 추출시</code>, <code class="language-plaintext highlighter-rouge">필드 초기화 부분은 제외</code>시키자!</strong></p>
          </li>
          <li>
            <p><strong><code class="language-plaintext highlighter-rouge">메서드 추출시, 다른 곳에 위임되지 않을, 내부context필드 초기화 &amp;&amp; 재할당은 할당값(우항)만 따로 지역변수로 빼놓고, 해당 context를 제외시키고 추출한다</code></strong></p>

            <ul>
              <li><strong>만약, 내부context를 다른쪽에 위임하는 로직이면, 내부context를 지역변수로 빼서 위쪽으로 놓고, 해당 지역변수가 파라미터로  잡히게 한다.</strong></li>
            </ul>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/e90db055-47b1-4b09-87e0-6cfefaeea16f.gif" alt="e90db055-47b1-4b09-87e0-6cfefaeea16f"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807125203951.png" alt="image-20220807125203951"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807125500504.png" alt="image-20220807125500504"></p>
          </li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>랜덤이 포함된 로직은,  보이자마자, <code class="language-plaintext highlighter-rouge">전략패턴적용</code>을 위해, <code class="language-plaintext highlighter-rouge">메서드추출 -&gt; 전략객체.메서드()호출 -&gt; 전략객체에 위임 -&gt; 전략 인터페이스 생성</code>으로 빼놓자.</strong></p>

    <ol>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">랜덤이 껴있는 전체로직( 객체 반환까지 )</code>을 1개의 메서드로 추출한다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/b92ff93b-fe78-4ced-98ce-19005afb7f4b.gif" alt="b92ff93b-fe78-4ced-98ce-19005afb7f4b">
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807133924318.png" alt="image-20220807133924318"></p>
      </li>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">위임을 위해 예비전략메서드의 인자에 new 랜덤전략객체()</code>를 넣어서 <code class="language-plaintext highlighter-rouge">파라미터로 추가</code>한다. 내부에선 사용하진 않는다.(위임하기 위해 만든 객체라서 원래 사용된 상태)</strong></p>

        <ul>
          <li>
            <p>파라미터에 전략객체가 있어야 -&gt; 파라미터 속 1개의 객체로 위임할 수 있다.</p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/ba7258b3-b722-4898-844e-885391718b77.gif" alt="ba7258b3-b722-4898-844e-885391718b77">
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807134122277.png" alt="image-20220807134122277"></p>
          </li>
        </ul>
      </li>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">내부 메서드가 있다면, 모두 new 전략랜덤객체를 파라미터로 추가</code>해준다.</strong></p>

        <ul>
          <li>
            <p><strong>내부 메서드들 내부의 <code class="language-plaintext highlighter-rouge">this context</code>도, 모두 전략객체로 교체</strong></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/dc294698-a194-497d-b171-1f2202bfb67b.gif" alt="dc294698-a194-497d-b171-1f2202bfb67b"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807134713089.png" alt="image-20220807134713089"></p>

            <ul>
              <li>
                <p><strong>this가 메서드레퍼런스에 껴있으면, 다시 람다식으로 풀어서 <code class="language-plaintext highlighter-rouge">파라미터 추가</code></strong></p>

                <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/793c853e-9619-4b27-8bb4-72be98de434d.gif" alt="793c853e-9619-4b27-8bb4-72be98de434d"></p>

                <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807134845380.png" alt="image-20220807134845380"></p>
              </li>
            </ul>
          </li>
          <li>
            <p><strong>보라색 context가 껴있으면, 파라미터로 추출</strong></p>
          </li>
        </ul>
      </li>
      <li>
        <p><strong>내부메서드들부터 F6으로 위임한다</strong></p>

        <ol>
          <li>
            <p><strong>만약, 바깥부터 하면, 내부 내수용메서드 == Deck메서드 == Deck가 파라미터로 달린체로 위임된다</strong></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807135027659.png" alt="image-20220807135027659"></p>
          </li>
          <li>
            <p><strong><code class="language-plaintext highlighter-rouge">아주 안쪽 &amp;&amp; 먼저 실행되는 내수용 메서드들부터 위임하자</code></strong></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/e0ddd88d-dfe2-4f6d-ae02-75f3774f3187.gif" alt="e0ddd88d-dfe2-4f6d-ae02-75f3774f3187"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807135410544.png" alt="image-20220807135410544"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807135604705.png" alt="image-20220807135604705"></p>

            <ul>
              <li>
                <p><strong>위임된 내수용메서드들은 수동으로private으로 바꿔주자</strong>.(옮길때는 위임해준 쪽으로 넘겨줘야해서 public이 자동으로 걸린다.)</p>

                <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220815143724053.png" alt="image-20220815143724053"></p>
              </li>
            </ul>
          </li>
        </ol>
      </li>
      <li>
        <p><strong>이제, 특정 전략객체가 아닌, <code class="language-plaintext highlighter-rouge">전략인터페이스를 파라미터를 통해 외부에서 주입</code>받아서 소유하도록 하기 위해, <code class="language-plaintext highlighter-rouge">구상체로부터 전략인터페이스를 만들어 올린다</code>.</strong></p>

        <ol>
          <li>
            <p>구상클래스에서 @Override -&gt; extract interface -&gt; 전략인터페이스 생성 -&gt; <strong>전략메서드만 추출</strong></p>
          </li>
          <li>
            <p>구상체 사용처(Deck)에서 <strong>파라미터 추출 -&gt; 생성자로는 전략인터페이스가 들어오도록 수정</strong></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/04fcb343-b1f7-4482-923a-b29a430261d8.gif" alt="04fcb343-b1f7-4482-923a-b29a430261d8"></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807140331139.png" alt="image-20220807140331139"></p>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>이제 Deck에서는 랜덤Deque카드들을 소유한 상태이므로 Player에게 pop으로 1개씩 제공해준다.</strong></p>

    <ul>
      <li>
        <p>Player는 while문으로 상태확인하면서, <strong>Deck으로부터 1개씩 재료를 iterator처럼 제공받는다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/2a024204-2c01-4410-8846-43e87e0130b9.gif" alt="2a024204-2c01-4410-8846-43e87e0130b9"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807140606654.png" alt="image-20220807140606654"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>하나의 기능만 뺀 전략패턴은 람다식을 편하게 사용하도록 애너테이션을 붙여준다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807140849701.png" alt="image-20220807140849701"></p>
  </li>
  <li>
    <p><strong>RandomCardGenerator는 List로 종류별로 만든 카드 List -&gt; Shuffle후 -&gt; Deque로 반환</strong>해주는데, <strong><code class="language-plaintext highlighter-rouge">Deque의 재료 List는 1번만 생성해놓고, 필요시 shuffle후 생성자복사만 매번 해주면 된다.</code></strong></p>

    <ul>
      <li><strong>즉, 카드종류별 List는 <code class="language-plaintext highlighter-rouge">static 필드에 미리 1번만 생성해놓으면 된다.</code></strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/95fd73d8-8e5c-488f-8f2a-990018331ded.gif" alt="95fd73d8-8e5c-488f-8f2a-990018331ded"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807223426856.png" alt="image-20220807223426856"></p>
  </li>
  <li>
    <p><strong>이제 Random로직이 보여서 묶어서 만든 전략패턴의 <code class="language-plaintext highlighter-rouge">수동전략 생성 or 람다식 대입</code>을 만들어보자.</strong></p>

    <ul>
      <li><strong>수동전략은 사실상 Test에서 밖에 안쓰이므로 <code class="language-plaintext highlighter-rouge">도메인에 전략객체 생성을 안한다</code></strong></li>
      <li><strong>람다식으로 바로 대입이 불가능하면, <code class="language-plaintext highlighter-rouge">수동전략 클래스를 testutil에 추가</code>해준다.</strong></li>
    </ul>
  </li>
  <li>
    <p><strong>전략객체가 주입되는 객체를 생성하고, <code class="language-plaintext highlighter-rouge">전략객체 주입부</code>에 <code class="language-plaintext highlighter-rouge">가상인자 람다식으로 [전략메서드 대신구현]</code>이 가능한지 보자.</strong></p>

    <ul>
      <li>확인해보니 , Deck의 생성자에서 쓰고 있다 -&gt; <strong>테스트에서 new Deck() 을 만들자.</strong>
</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807232206299.png" alt="image-20220807232206299"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807232220504.png" alt="image-20220807232220504"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807232136058.png" alt="image-20220807232136058"></p>

    <ul>
      <li>
        <p><strong>람다식으로 <code class="language-plaintext highlighter-rouge">전략메서드 로직을 구현하여 시그니쳐에 맞는 응답</code>을 해줄 수 있는지 확인하자.</strong></p>

        <ul>
          <li><strong>전략메서드는 <code class="language-plaintext highlighter-rouge">Deque&lt;Card&gt;</code>인 <code class="language-plaintext highlighter-rouge">new ArrayDeque&lt;Card&gt;();</code>를 채워서 응답해주면 된다.</strong></li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807232417754.png" alt="image-20220807232417754"></p>
      </li>
      <li>
        <p><strong>람다식 내에서 수동으로 채워주기엔 무리가 있으니 <code class="language-plaintext highlighter-rouge">위쪽에서 지역변수로 채워놓고, 해당 지역변수를 넣어줘도 된다.</code></strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807232534896.png" alt="image-20220807232534896"></p>
      </li>
      <li>
        <p><strong>카드2, 5를 수동으로 채워서 deck을 pop해보면, 뒤쪽 5가 나온다</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/f832a82d-af31-4fe9-b9b4-6f6eec5de5e7.gif" alt="f832a82d-af31-4fe9-b9b4-6f6eec5de5e7"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807234741623.png" alt="image-20220807234741623"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">수동으로 전략메서드 시그니쳐 응답값 구현</code>을 반복해서 사용할 예정이라면 <code class="language-plaintext highlighter-rouge">메서드 추출후, Fixed수동전략객체Class에 위임</code>하여 재활용한다.</strong></p>

    <ul>
      <li>
        <p><strong>이 때, <code class="language-plaintext highlighter-rouge">수동으로 넣어주는 값들을 변수로 빼서 사용할 수 있다.</code></strong></p>

        <ul>
          <li>랜덤카드생성은 정해진 수의 카드만 가능</li>
        </ul>
      </li>
      <li>
        <p><strong>수동카드생성은, <code class="language-plaintext highlighter-rouge">파라미터로 원하는 요소들로 짧게 구성 가능</code></strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/0e9ce492-833c-4223-9967-e9ba993ed2d2.gif" alt="0e9ce492-833c-4223-9967-e9ba993ed2d2"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807235828447.png" alt="image-20220807235828447"></p>
      </li>
      <li>
        <p><strong>원하는 수만큼 받을 수 있게 <code class="language-plaintext highlighter-rouge">2번째 파라미터부터를 가변배열로 받아서 처리</code>한다</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/ff728444-5533-42f4-b85a-46dc1df35067.gif" alt="ff728444-5533-42f4-b85a-46dc1df35067"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220808000033000.png" alt="image-20220808000033000"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>이 때, <code class="language-plaintext highlighter-rouge">테스트용 수동 전략이 적용된 객체</code>생성까지를 <code class="language-plaintext highlighter-rouge">하나의 fixture생성</code>으로 보고 묶을 수 있다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/5c74f3aa-ecd0-44be-8def-b2e385d5a2cd.gif" alt="5c74f3aa-ecd0-44be-8def-b2e385d5a2cd"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220808001610654.png" alt="image-20220808001610654"></p>
  </li>
  <li>
    <p><strong>캐싱객체 or 불변Vo객체의 Fixture 모음이 아니라 <code class="language-plaintext highlighter-rouge">1개의 FixtureGenerator</code>로서 <code class="language-plaintext highlighter-rouge">testutil패키지지 &gt; FixtureGenerator클래스를 만들고, 생성 유틸메서드로 추출</code>하여 재활용할 수 있다.</strong></p>

    <ol>
      <li>
        <p><strong>testutil패키지 아래 <code class="language-plaintext highlighter-rouge">FixtureGenerator</code></strong> 클래스를 만든다</p>
      </li>
      <li>
        <p><strong>private메서드를 유틸메서드(Fixture정팩매)로서 <code class="language-plaintext highlighter-rouge">public static</code>을 붙인 뒤 <code class="language-plaintext highlighter-rouge">위임</code>한다</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/4a1139ce-e8ef-4c9e-8517-65e790c15489.gif" alt="4a1139ce-e8ef-4c9e-8517-65e790c15489"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220808002002988.png" alt="image-20220808002002988"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220808002015770.png" alt="image-20220808002015770"></p>
      </li>
    </ol>
  </li>
  <li>
    <p>player는 카드1장 받으면 Ready이 되어야한다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/f4b91d9f-4f26-40f7-a902-7abf144f62df.gif" alt="f4b91d9f-4f26-40f7-a902-7abf144f62df"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807224704847.png" alt="image-20220807224704847"></p>

    <ul>
      <li>
        <p><strong>하지만, 최초의 Ready상태에서 Started에 선언된 공통필드가 <code class="language-plaintext highlighter-rouge">null</code>상태라서 getter호출시 에러가 난다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807224602497.png" alt="image-20220807224602497"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807224613893.png" alt="image-20220807224613893"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807224629139.png" alt="image-20220807224629139"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807224536611.png" alt="image-20220807224536611"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807224642213.png" alt="image-20220807224642213"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>교훈) <code class="language-plaintext highlighter-rouge">not final + setter계열 조합 for좋은부모</code>는 null참조가 될 수 있으니 <code class="language-plaintext highlighter-rouge">반드시 초기값 필드초기화를 해주자</code></strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807224811919.png" alt="image-20220807224811919"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807224832856.png" alt="image-20220807224832856"></p>
  </li>
  <li>
    <p>2장이상 draw하면, Ready가 아닌 상태가 된다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807225214117.png" alt="image-20220807225214117"></p>
  </li>
  <li>
    <p><strong>Player가 Deck을 전달받으면 finished가 될때가지 draw로 뽑아간다.</strong></p>

    <ul>
      <li><strong>이럴 경우, <code class="language-plaintext highlighter-rouge">hit상태도 !finished라서 계속 반복하여 stay를 못한다</code></strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807225449880.png" alt="image-20220807225449880"></p>

    <ul>
      <li><strong>deck을 받아도 finished까지 반복이 아닌 1장만 받도록 수정해보자.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807230956468.png" alt="image-20220807230956468"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220807231031376.png" alt="image-20220807231031376"></p>

    <ul>
      <li>
<strong>만약, ! state.isReady()가 존재했다면… 연속해서 Ready아닐때까지 받으면 좋으련만..</strong>
        <ul>
          <li>
<strong>이 draw는 Ready를 벗어나기 위한 것으로 1번밖에 안쓰인다.</strong>
            <ul>
              <li><strong>draw는 범용으로 finished전까지 호출되어야하는 것이 맞다</strong></li>
              <li>
<strong>그러나, stay호출을 무시 ready -&gt; hit -&gt; finished로 가기엔 finished까지 가기엔..</strong>
                <ul>
                  <li>stay상태는 hit -&gt; stay()메서드호출만 가능한 finished상태임.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
<strong>isReady는 isFinished(끝난후 호출가능한 메서드 ex&gt; profit 등이 있는 중요한상태)와 달리, 오퍼레이터로 작성하기엔.. 무리가 있다.</strong>
            <ul>
              <li>Ready빼고 finisehd그룹 -&gt; 공통 false / Hit -&gt; false로 2개만 주면 되긴 하는데..</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>


  </div><a class="u-url" href="/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/tdd/%EB%B8%94%EB%9E%99%EC%9E%AD/%EB%AF%B8%EC%85%98/%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%A0%95%EB%A6%AC/2022/08/05/TDD-%EC%B4%9D%EC%A0%95%EB%A6%AC3-%EB%B8%94%EB%9E%99%EC%9E%AD-%EA%B5%AC%ED%98%84%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4%EA%B3%BC-%EB%9E%9C%EB%8D%A4%EB%A1%9C%EC%A7%81-%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="blog.chojaeseong.com/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>평범한 한의사 돌범의 엔지니어 도전기</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
  <a href="/feed.xml" target="_blank" title="rss">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://github.com/is2js/" target="_blank" title="github">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#github"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://twitter.com/yarotheslav" target="_blank" title="twitter">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#twitter"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://www.linkedin.com/in/yshmarov/" target="_blank" title="linkedin">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#linkedin"></use>
    </svg>
  </a>
</li>
</ul>
</div>

  </div>

</footer>
</body>

</html>
