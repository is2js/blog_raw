<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>menu를 만들며 익히는 command, memento 패턴 | 돌범텤놑</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="menu를 만들며 익히는 command, memento 패턴" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="compositeMenu객체를 commandMenu객체로 memento를 통한 저장,로드" />
<meta property="og:description" content="compositeMenu객체를 commandMenu객체로 memento를 통한 저장,로드" />
<link rel="canonical" href="blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/menu/command/memento/side/2022/07/31/menu%EB%A5%BC-%EB%A7%8C%EB%93%A4%EB%A9%B0-%EC%9D%B5%ED%9E%88%EB%8A%94-command,-memento%ED%8C%A8%ED%84%B4.html" />
<meta property="og:url" content="blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/menu/command/memento/side/2022/07/31/menu%EB%A5%BC-%EB%A7%8C%EB%93%A4%EB%A9%B0-%EC%9D%B5%ED%9E%88%EB%8A%94-command,-memento%ED%8C%A8%ED%84%B4.html" />
<meta property="og:site_name" content="돌범텤놑" />
<meta property="og:image" content="blog.chojaeseong.com/images/posts/java.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-07-31T00:00:00-05:00" />
<script type="application/ld+json">
{"datePublished":"2022-07-31T00:00:00-05:00","url":"blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/menu/command/memento/side/2022/07/31/menu%EB%A5%BC-%EB%A7%8C%EB%93%A4%EB%A9%B0-%EC%9D%B5%ED%9E%88%EB%8A%94-command,-memento%ED%8C%A8%ED%84%B4.html","@type":"BlogPosting","image":"blog.chojaeseong.com/images/posts/java.png","headline":"menu를 만들며 익히는 command, memento 패턴","dateModified":"2022-07-31T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/menu/command/memento/side/2022/07/31/menu%EB%A5%BC-%EB%A7%8C%EB%93%A4%EB%A9%B0-%EC%9D%B5%ED%9E%88%EB%8A%94-command,-memento%ED%8C%A8%ED%84%B4.html"},"description":"compositeMenu객체를 commandMenu객체로 memento를 통한 저장,로드","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<!-- 폰트추가를 위한 link태그 삽입 -->
  <!-- 폰트1:  기본 spoqa 웹폰트 -->
  <!-- css에서 * {} 다 뒤집어씀. -->
  <link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSansNeo.css' rel='stylesheet' type='text/css'>
  <!-- 폰트2:  블로그 제목들 sunflower 웹폰트 -->
  <!-- 쥬피터 등 포스트 내부 글자 h1, h2 제목은 sunflower체 도입 -->
  <link href="//fonts.googleapis.com/css?family=Sunflower:300,500,700" rel="stylesheet"> 

  <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="blog.chojaeseong.com/feed.xml" title="돌범텤놑" /><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">돌범텤놑</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About Me</a><a class="page-link" href="/search/">Search</a><a class="page-link" href="/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">menu를 만들며 익히는 command, memento 패턴</h1><p class="page-description">compositeMenu객체를 commandMenu객체로 memento를 통한 저장,로드</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-07-31T00:00:00-05:00" itemprop="datePublished">
        Jul 31, 2022
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      27 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/categories/#java">java</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#우테코">우테코</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#oop">oop</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#object">object</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#menu">menu</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#command">command</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#memento">memento</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#side">side</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <!-- toc가 먼저 나오므로 h3로 안내하기 -->
    <h3>📜 제목으로 보기</h3>
    <ul class="section-nav">
<li class="toc-entry toc-h1"><a href="#menu를-만들며-익히는-command-memento-패턴">menu를 만들며 익히는 command, memento 패턴</a>
<ul>
<li class="toc-entry toc-h2"><a href="#command패턴-적용하기">Command패턴 적용하기</a>
<ul>
<li class="toc-entry toc-h3"><a href="#커맨드-인터페이스에서-역할execute-undo부터-정의하고-기능위임한-객체는-파라미터로-받는다">커맨드 인터페이스에서 역할(execute, undo)부터 정의하고, 기능위임한 객체는 파라미터로 받는다.</a></li>
<li class="toc-entry toc-h3"><a href="#커맨드홀더객체---기능-위임받을-객체를-소유해서-래핑하는-구상클래스를-만들며-모든-기능을-래핑하기-위해-위임객체composite의-내장을-다-복사해온다">커맨드홀더객체 -&gt; [기능 위임받을 객체를 소유]해서 래핑하는 구상클래스를 만들며, [모든 기능을 래핑]하기 위해, 위임객체Composite의 내장을 다 복사해온다.</a>
<ul>
<li class="toc-entry toc-h4"><a href="#상속없이-특정객체의-기능을-위임하려면-필드로-소유---내장복사---래핑하는-방법-밖이다">상속없이 특정객체의 기능을 위임하려면, 필드로 소유 -&gt; 내장복사 -&gt; 래핑하는 방법 밖이다</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#소유객체-기능복사후-내장을-정리한다">소유객체 기능복사후 내장을 정리한다</a>
<ul>
<li class="toc-entry toc-h4"><a href="#01-소유객체-기능-래핑을-위한-내장복사후-필드는-소유객체-빼고-다-삭제--생성자-이름-수정부터-한다">01 소유객체 기능 래핑을 위한 내장복사후 [필드는 소유객체 빼고 다 삭제] + [생성자 이름 수정]부터 한다.</a></li>
<li class="toc-entry toc-h4"><a href="#02--기능의-command화-대상들인-상태변화-set계열-메서드들은-일단-두고-getter계열만-소유객체를-통해-래핑한다">02  기능의 command화 대상들인 [상태변화 set계열] 메서드들은 일단 두고, [getter계열만 소유객체를 통해 래핑]한다.</a>
<ul>
<li class="toc-entry toc-h5"><a href="#getter는-제공기능이므로-행위가-아니다---행위를-캡슐화하여-지연실행하는-커맨드객체-대상이-아니다">getter는 제공기능이므로, 행위가 아니다. -&gt; 행위를 캡슐화하여 지연실행하는 커맨드객체 대상이 아니다</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#커맨드화-대상인-setter계열-메서드의-실행시점-위임하기">커맨드화 대상인 setter계열 메서드의 [실행시점] 위임하기</a>
<ul>
<li class="toc-entry toc-h4"><a href="#새로운-객체인-command객체를-만들고-커맨드홀더-객체가-소유객체-래핑해서-실행하는-책임을-다시-한번-커맨드객체에서-실행하도록-실행시점을-위임한다">새로운 객체인 command객체를 만들고, 커맨드홀더 객체가 [소유객체 래핑해서 실행]하는 책임을, 다시 한번 [커맨드객체에서 실행]하도록 [실행시점]을 위임한다</a></li>
<li class="toc-entry toc-h4"><a href="#01-execute와-undo가-같아-제일-쉬운-set계열-toggle커맨드객체부터-만들어보자">01 execute와 undo가 같아 제일 쉬운 set계열 toggle커맨드객체부터 만들어보자.</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#커맨드홀더객체는-소유객체의-실행을-커맨드객체에게-위임하되--커맨드-객체-내부-생성후-커맨드객체-위임-실행함으로써-지연실행-주체인-커맨드객체-자체를-실행전-컬렉션-필드에-저장할-수-있다">커맨드홀더객체는, 소유객체의 실행을 커맨드객체에게 위임하되  [커맨드 객체 내부 생성]후 [커맨드객체 위임 실행]함으로써, [지연실행 주체인 커맨드객체 자체]를 [실행전 컬렉션 필드에 저장]할 수 있다.</a>
<ul>
<li class="toc-entry toc-h4"><a href="#undoredo는-지연실행-주체인-커맨드객체를-컬렉션-필드에-저장해놓기-때문에-execute한-주체를-다시-불러와서-undo할-수-있게-된다-커맨드홀더객체가-커맨드객체들-외부저장소list필드-역할을-한다">undo/redo는 지연실행 주체인 [커맨드객체]를 컬렉션 필드에 저장해놓기 때문에, execute한 주체를 다시 불러와서 undo할 수 있게 된다. 커맨드홀더객체가 [커맨드객체들 외부저장소(List필드)] 역할을 한다</a></li>
<li class="toc-entry toc-h4"><a href="#모든-set계열메서드들은-커맨드객체에-실행시점위임으로서-해당-커맨드객체생성---외부저장소에-저장---실행한다-이-때-추상체변수cmd의-add---cmdexecute는-반복된다-내수용-addcommand메서드를-만들고-반복사용하도록-하자">모든 set계열메서드들은 커맨드객체에 실행시점위임으로서 해당 커맨드객체생성 -&gt; 외부저장소에 저장 -&gt; 실행한다. 이 때, [추상체변수cmd의 add -&gt; cmd.execute]는 반복된다. 내수용 addCommand()메서드를 만들고, 반복사용하도록 하자.</a></li>
<li class="toc-entry toc-h4"><a href="#이제부터-매-set메서드들의-커맨드화할-때마다-addcommand를-통해-저장--실행까지-한다">이제부터 매 set메서드들의 커맨드화할 때마다 addCommand()를 통해 저장 + 실행까지 한다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#커맨드-홀더-소유객체는-메서드인자를-통한-를-기억해서-사용-안해도될까">커맨드 홀더 소유객체는 [메서드인자를 통한 를 기억해서 사용] 안해도될까?호출&gt;</a>
<ul>
<li class="toc-entry toc-h4"><a href="#현재-모든-set계열메서드마다-필드소유객체-compositemenu를-호출메서드의-파라미터가-아니라-내부context필드로서-반복-사용하고-있다">현재 모든 set계열메서드마다 [필드소유객체 CompositeMenu]를 [호출메서드의 파라미터]가 아니라 [내부context필드로서 반복 사용]하고 있다</a>
<ul>
<li class="toc-entry toc-h5"><a href="#행위-위임을-위한-메서드위임당할-객체는-파라미터로가-아닐-때-파라미터로-받을-필요없이-내부context를-재활용해도-되는-객체는-절대-상태변화가-없는-final-불변객체만-가능하다">행위 위임을 위한 메서드(위임당할 객체는 파라미터로)가 아닐 때, 파라미터로 받을 필요없이 내부context를 재활용해도 되는 객체는? [절대 상태변화가 없는 final 불변객체]만 가능하다</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#command홀더-클래스는-래핑할-소유객체를-final불변으로-유지하여-어떤-커맨드객체에서든-똑같이-작동하도록-한다">command홀더 클래스는, 래핑할 소유객체를 final불변으로 유지하여, 어떤 커맨드객체에서든 똑같이 작동하도록 한다</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#command홀더는-소유객체를-대신해서-외부에서-생성---활용될-것이므로-소유객체-생성자-파라미터값을-받아-필드-채우는를-그대로-유지하며-소유객체를-내부-생성한다">Command홀더는 소유객체를 대신해서 외부에서 생성 -&gt; 활용될 것이므로 소유객체 생성자 파라미터(값을 받아 필드 채우는)를 그대로 유지하며, 소유객체를 내부 생성한다</a>
<ul>
<li class="toc-entry toc-h4"><a href="#command홀더객체를-도입하는-순간부터-기존-composite객체는-외부에서-사용안된다-command홀더내에서-소유객체composite객체를-생성한다-생성자-내장을-그대로-활용한다">command홀더객체를 도입하는 순간부터, 기존 Composite객체는 외부에서 사용안된다. command홀더내에서 소유객체composite객체를 생성한다. 생성자 내장을 그대로 활용한다</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#모든-상태변화메서드-settersettitle-등를-커맨드화-한다">모든 상태변화메서드 setter(setTitle 등)를 커맨드화 한다</a>
<ul>
<li class="toc-entry toc-h4"><a href="#정해진-인터페이스의-구상클래스가-기능을-위임받을-땐-필요한-외부정보를-메서드로부터-받지못하니-생성자를-통한-필드로-context를-기억해놔야한다">정해진 인터페이스의 구상클래스가 기능을 위임받을 땐, 필요한 외부정보를 메서드로부터 받지못하니, 생성자를 통한 필드로 context를 기억해놔야한다.</a></li>
<li class="toc-entry toc-h4"><a href="#02-settitle-커맨드화">02 setTitle 커맨드화</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#undo의-비밀은-구상-커맨드객체에-메서드인자로-들어가는-실행위임했다면-execute직전의-context를-getter로-가져와-객체-내부필드에-저장set해놓아서-undo시-불러와-사용하여-counter칠-수-있다">undo의 비밀은? 구상 커맨드[객체]에 [메서드인자로 들어가는 실행위임]했다면, [execute직전의 context를 getter로 가져와 객체 내부필드에 저장(set)]해놓아서, [undo시 불러와 사용]하여 counter칠 수 있다.</a>
<ul>
<li class="toc-entry toc-h4"><a href="#커맨드객체라는-새로운-구상class에-위임하게-되면-당시context를-필드로-기억할-수-있다">커맨드객체라는 새로운 구상class에 위임하게 되면, 당시context를 필드로 기억할 수 있다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#단순-setter의-undo-execute직전에-getter를-통해-당시context를-가져와-내부필드oldxxxx를-이용해서-old값으로-다시-setter한다">단순 setter의 undo: execute직전에 getter를 통해 당시context를 가져와 내부필드(oldXXXX)를 이용해서 [old값으로 다시 setter]한다.</a>
<ul>
<li class="toc-entry toc-h4"><a href="#03-setdate-등-나머지-단순setter-커맨드화">03 setDate 등 나머지 단순Setter 커맨드화</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#add의-undo-원본메서드에서-컬렉션에-add된-객체를-반환하도록-해야--저장-후-undo를-칠-수-있다">add의 undo: 원본메서드에서 컬렉션에 add된 객체를 반환하도록 해야,  저장 후 undo를 칠 수 있다.</a>
<ul>
<li class="toc-entry toc-h4"><a href="#일단-04-add-execute만들기">일단 04 add execute만들기</a></li>
<li class="toc-entry toc-h4"><a href="#add의-undo는-실행-전-old값이-아닌-add될-내부생성객체가-필요하다">add의 undo는 실행 전 old값이 아닌, add될 내부생성객체가 필요하다</a></li>
<li class="toc-entry toc-h4"><a href="#add메서드는-undo를-위해서라도-내부생성되어-내부컬렉션에-add될-객체를-반환를-해줘야한다">add메서드는 undo를 위해서라도 내부생성되어 내부컬렉션에 [add될 객체를 반환]를 해줘야한다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#remove의-undo-remove된-객체가-아니라-remove되기-전-객체의-필드정보들을-getter로-받아와야--저장-후-add할-수-있다">remove의 undo: remove된 객체가 아니라, [remove되기 전 객체의 필드정보들]을 [getter]로 받아와야,  저장 후 add할 수 있다.</a>
<ul>
<li class="toc-entry toc-h4"><a href="#05-remove-커맨드화">05 remove 커맨드화</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#생각해보기">생각해보기</a>
<ul>
<li class="toc-entry toc-h4"><a href="#커맨드객체에는-2가지-종류의-기억필드를-가진다">커맨드객체에는 2가지 종류의 기억필드를 가진다.</a></li>
<li class="toc-entry toc-h4"><a href="#커맨드객체로-굳이-기능행위를-한번-더-포장해서-써야하나-undoredo와-지연실행">커맨드객체로 굳이 기능(행위)를 한번 더 포장해서 써야하나? undo/redo와 지연실행</a></li>
<li class="toc-entry toc-h4"><a href="#커맨드객체-외부저장소를-setcommand가-아닌-listcommand를-쓰는-이유">커맨드객체 외부저장소를 Set&lt;Command&gt;가 아닌 List&lt;Command&gt;를 쓰는 이유</a></li>
<li class="toc-entry toc-h4"><a href="#지연실행포장객체에-위임의-장점">지연실행(포장객체에 위임)의 장점</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#커맨드홀더의-undo메서드미완성">커맨드홀더의 undo메서드(미완성)</a>
<ul>
<li class="toc-entry toc-h4"><a href="#지금까지는-커맨드홀더의-addcommand---cmd객체의-execute호출만-했고-cmd객체의-undo를-호출하지-않았다">지금까지는 커맨드홀더의 addCommand() -&gt; cmd객체의 execute호출만 했고, cmd객체의 undo()를 호출하지 않았다.</a></li>
<li class="toc-entry toc-h4"><a href="#addcommand와-달리-undo는-외부저장소list의-조회전-처럼-remove-전pop과-동일-존재검증을-해야한다">addCommand와 달리 undo()는 외부저장소List의 (조회전 처럼) remove 전(pop과 동일) 존재검증을 해야한다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#커맨드홀더의-redo-undo시-외부저장소list에서-removepop로-날리지말고-cursor-도입">커맨드홀더의 redo: undo시 외부저장소(List)에서 remove(pop)로 날리지말고 Cursor 도입</a>
<ul>
<li class="toc-entry toc-h4"><a href="#외부저장소list의-index를-cursor로-도입하여-컬렉션-요소-날리지-않고-add-execute하기">외부저장소List의 index를 cursor로 도입하여, 컬렉션 요소 날리지 않고 add-execute하기</a></li>
<li class="toc-entry toc-h4"><a href="#cursor는-대상컬렉션에-요소를-add할때마다-1씩-증가되어-맨마지막-index에-위치시킨다-컬렉션이-사용되는-곳ctrlf7-altf7-add기능이-있는-곳-등에서-cursor도-업데이트-로직을-추가한다">cursor는 대상컬렉션에 요소를 add할때마다 1씩 증가되어, 맨마지막 index에 위치시킨다. 컬렉션이 사용되는 곳(ctrl+F7, alt+F7, add기능이 있는 곳 등)에서 cursor도 업데이트 로직을 추가한다.</a></li>
<li class="toc-entry toc-h4"><a href="#상태변화하는-컬렉션의-cursorvariant변수를-직접-상태변화하지말고-이미-변화한-연결-variant-필드컬렉션의-api를-이용한-불변식으로-관리해라">상태변화하는 컬렉션의 cursor(variant변수)를 직접 상태변화하지말고, 이미 변화한 연결 variant 필드(컬렉션)의 api를 이용한 불변식으로 관리해라</a></li>
<li class="toc-entry toc-h4"><a href="#add시-cursor를-마지막index로-업데이트는-add전에-하지말고-add후-바뀐-컬렉션으로-불변식을-만들어서-한다">add시 cursor를 마지막index로 업데이트는, add전에 하지말고, add후 바뀐 컬렉션으로 불변식을 만들어서 한다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#cmd외부저장소-list는-stack역할으로서-방금-add-execute한-커맨드객체가-현재cursor--1-위치에-있어야한다-그래야-undocursor-1시-원래자리를-찾아올-수-있게-된다">cmd외부저장소 List는 stack(역할)으로서 방금 add-execute한 커맨드객체가 [현재cursor + 1] 위치에 있어야한다. 그래야 undo(cursor-1)시 원래자리를 찾아올 수 있게 된다.</a>
<ul>
<li class="toc-entry toc-h4"><a href="#add후-cursor를-컬렉션api로-마지막위치로-업데이트하는-상황에서-add-execute하여-list에-add될-객체가-현재cursor1위치에-이어야한다----add전-cursor1마지막요소들을-remove해서-날려놔야-add후-size-1이-마지막위치가-된다">add후 cursor를 컬렉션api로 마지막위치로 업데이트하는 상황에서, add-execute하여 List에 add될 객체가 [현재cursor+1]위치에 이어야한다.  -&gt; add전, [cursor+1~마지막]요소들을 remove해서 날려놔야, add후 size()-1이 마지막위치가 된다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#커맨드-홀더의-undo의-remove를-제거하기-위해-업데이트">커맨드 홀더의 undo의 remove를 제거하기 위해 업데이트</a>
<ul>
<li class="toc-entry toc-h4"><a href="#undo에서-삭제-전-컬렉션--존재검증---더이상-컬렉션-요소를-삭제하지-않으니-cursor로-검증cursor-0은-undo시킬-cmd객체가-있는-상황">undo에서 삭제 전 컬렉션  존재검증 -&gt; 더이상 컬렉션 요소를 삭제하지 않으니, cursor로 검증(cursor 0은 undo시킬 cmd객체가 있는 상황)</a></li>
<li class="toc-entry toc-h4"><a href="#undo는-popremovesize-1-대신-현재cursor의-외부저장소cmd객체를-가져온-뒤-cursor는-한칸-뒤로-이동시켜야한다">undo는 (pop==remove(size-1) 대신) 현재cursor의 외부저장소cmd객체를 가져온 뒤, cursor는 한칸 뒤로 이동시켜야한다</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#redo-구현">redo 구현</a>
<ul>
<li class="toc-entry toc-h4"><a href="#이론-redo는-커서만-빽한-undo상태가-대상이며-cursor--1-위치로-가서-꺼내서-execute하는-것이다">(이론) redo는 [커서만 빽한 undo상태가 대상]이며 cursor + 1 위치로 가서 꺼내서 execute하는 것이다.</a></li>
<li class="toc-entry toc-h4"><a href="#이론-undo의-대상과-redo의-대상">(이론) undo의 대상과 redo의 대상</a></li>
<li class="toc-entry toc-h4"><a href="#구현1---redo전-cursor-invariant검사로-redo할게-없는-상황이면-종료-cursor한칸-앞으로-못감--undo안한상황--add-execute만-한-상황--cursor가-제일-마지막에-위치">구현1 - redo전 cursor invariant검사로, [redo할게 없는 상황이면 종료] (cursor한칸 앞으로 못감 == undo안한상황 == add-execute만 한 상황 == cursor가 제일 마지막에 위치)</a></li>
<li class="toc-entry toc-h4"><a href="#진해서-두고-그-놈을-한번-더-execute하는-것이다">진해서 두고, 그 놈을 한번 더 execute하는 것이다.</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#addcommand-undo-redo-with-cursor---객체소유-커맨드홀더객체-완성---커맨드패턴-완성---undoreo하며-출력">addCommand/ undo/ redo with cursor -&gt; 객체소유 커맨드홀더객체 완성 -&gt; 커맨드패턴 완성 -&gt; undo/reo하며 출력</a>
<ul>
<li class="toc-entry toc-h3"><a href="#main에서-composite객체소유객체-대신-command홀더객체를-사용해보자">Main에서 Composite객체(소유객체) 대신 Command홀더객체를 사용해보자.</a>
<ul>
<li class="toc-entry toc-h4"><a href="#더이상-소유된-composite객체는-외부에서-사용하지-않는다-command홀더객체가-생성자에서-재료만-받아-내부생성했다">더이상 소유된 composite객체는 외부에서 사용하지 않는다. Command홀더객체가 생성자에서 재료만 받아 내부생성했다</a></li>
<li class="toc-entry toc-h4"><a href="#root에-menu에만-add할게-아니라-자식menu을-먼저-미리-생성자식에-자식-미리-추가한-것도-add하려면-자식-menu를-지역변수로-받아서-생성해놓고-root에-미리-생성된-menu도-add가능하도록-수정해야한다">root에 menu에만 add할게 아니라, 자식menu을 먼저 미리 생성(자식에 자식 미리 추가)한 것도 add하려면, 자식 menu를 지역변수로 받아서 생성해놓고, [root에 미리 생성된 menu도 add가능하도록 수정]해야한다</a></li>
<li class="toc-entry toc-h4"><a href="#기존의-정보를-통한-소유객체-내부생성-add커맨드객체는-이미-생성된-menu객체와-전혀-다른-context---생성자-필드가-다름---새로운-커맨드객체가-필요하다">기존의, 정보를 통한 소유객체 내부생성 Add커맨드객체는, 이미 생성된 Menu객체와 전혀 다른 context -&gt; 생성자-필드가 다름 -&gt; 새로운 커맨드객체가 필요하다</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#파라미터만-다르더라도-새-커맨드객체-생성">파라미터만 다르더라도 새 커맨드객체 생성</a>
<ul>
<li class="toc-entry toc-h4"><a href="#행위위임-커맨드객체는-커맨드호출-서비스메서드의-파라미터가-달라지면-커맨드객체의-기억필드가-달라져서-메서드-오버로딩처럼재활용-못하니-새-커맨드객체를-생성해서-위임해야한다">행위위임 커맨드객체는, 커맨드호출 서비스메서드의 파라미터가 달라지면, 커맨드객체의 기억필드가 달라져서 [메서드 오버로딩처럼]재활용 못하니, 새 커맨드객체를 생성해서 위임해야한다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#출력은-command홀더객체root---report생성---renderer-with-visitor---consolevisitor로-출력이다">출력은 Command홀더객체(root) -&gt; report생성 -&gt; Renderer with Visitor -&gt; ConsoleVisitor로 출력이다.</a>
<ul>
<li class="toc-entry toc-h4"><a href="#제어는-renderer가-제어를-타는-것은-특정-visitor들을-미리-생성자-주입">제어는 Renderer가, 제어를 타는 것은 특정 Visitor들을 미리 생성자 주입</a></li>
<li class="toc-entry toc-h4"><a href="#제어타면서-행위를-할-객체를-renderer에게-건네주면-내부에서-visitor에게-파라미터로-객체를-넘겨-visitor에게-위임한다">제어타면서 행위를 할 객체를 Renderer에게 건네주면, 내부에서 Visitor에게 파라미터로 객체를 넘겨, Visitor에게 위임한다</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#생각해보기-1">생각해보기</a>
<ul>
<li class="toc-entry toc-h4"><a href="#소유객체는-undo에서-remove하기-위해--add시-add되는-객체를-return해서-필드로-저장----커맨드홀더객체의-add는-return없는-void">소유객체는 undo에서 remove하기 위해,  add시 add되는 객체를 return해서 필드로 저장  /  커맨드홀더객체의 add는 return없는 void</a></li>
<li class="toc-entry toc-h4"><a href="#커맨드객체에-지연실행을-위임함으로써-실행-시-aggregation필드외부저장소list에-저장해놓을-수-있으며-다시-반복실행-undo실행-redo-등을-저장소에서-꺼내서-한다">커맨드객체에 지연실행을 위임함으로써, 실행 시 aggregation필드(외부저장소List)에 저장해놓을 수 있으며, 다시 반복실행, undo실행, redo 등을 저장소에서 꺼내서 한다</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#오타-수정">오타 수정</a>
<ul>
<li class="toc-entry toc-h4"><a href="#compositemenu의-remove에서-존재검증시-느낌표-하나-빠짐">CompositeMenu의 remove에서 존재검증시 !느낌표 하나 빠짐</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#composite객체---command객체-사용전환-완료됨---커맨드홀더객체커맨드패턴만의-undoredo를-사용해보자">Composite객체 -&gt; Command객체 사용전환 완료됨 -&gt; 커맨드홀더객체(커맨드패턴)만의 undo/redo를 사용해보자.</a>
<ul>
<li class="toc-entry toc-h4"><a href="#커맨드홀더객체undo는-커맨드홀더객체-어느행위-든addmenu-settitle-등-직전-행동에-대해-카운터를-친다">커맨드홀더객체.undo()는 커맨드홀더객체 어느행위 든(addMenu, setTitle 등) 직전 행동에 대해 카운터를 친다.</a></li>
<li class="toc-entry toc-h4"><a href="#redo는-직전의-undo에-대해서-카운터를-친다">redo는 직전의 undo에 대해서 카운터를 친다</a></li>
<li class="toc-entry toc-h4"><a href="#잘-작동한다">잘 작동한다</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#생각해보기-2">생각해보기</a>
<ul>
<li class="toc-entry toc-h4"><a href="#public-서비스메서드-with-private-도메인객체-파라미터-메서드---도메인객체-generator-서비스메서드">public 서비스메서드 with private 도메인객체 파라미터 메서드 -&gt; 도메인객체 generator 서비스메서드</a>
<ul>
<li class="toc-entry toc-h5"><a href="#커맨드홀더객체의--소유객체-래핑-set계열메서드들은-다-addcommand해당-커맨드객체-를-호출하는-래핑된-서비스-메서드들이다">커맨드홀더객체의  소유객체 래핑 set계열메서드들은 다 [addCommand(해당 커맨드객체) 를 호출하는 래핑된 서비스 메서드]들이다</a></li>
<li class="toc-entry toc-h5"><a href="#래핑을-풀고-private-addcommand메서드-만-public으로-공개하면-처리-가능하지만-외부에서-직접-커맨드객체를-new때려서-생성해서-넣어줘야한다---차라리-서비스메서드를-제공하고-커맨드-홀더객체-내부에-private-generator로-생성하는게-낫다">래핑을 풀고 private addCommand메서드 만 public으로 공개하면 처리 가능하지만, 외부에서 직접 커맨드객체를 new때려서 생성해서 넣어줘야한다. -&gt; 차라리 서비스메서드를 제공하고 커맨드 홀더객체 내부에 private generator로 생성하는게 낫다</a></li>
<li class="toc-entry toc-h5"><a href="#객체-파라미터를-public으로-공개한다는-것은-외부에서-생성한-뒤-받겠다는-말인데-도메인을-보호하자---public메서드의-객체-파라미터는-최대한-피하자---서비스-메서드를-제공하자">객체 파라미터를 public으로 공개한다는 것은, 외부에서 생성한 뒤 받겠다는 말인데, 도메인을 보호하자. -&gt; public메서드의 객체 파라미터는 최대한 피하자 -&gt; 서비스 메서드를 제공하자</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#커맨드패턴커맨드홀더객체을-쓰면-좋은-점지연실행으로-인한-외부저장소---undoredo-장점-외">커맨드패턴(커맨드홀더객체)을 쓰면 좋은 점(지연실행으로 인한 외부저장소 -&gt; undo/redo 장점 외)</a>
<ul>
<li class="toc-entry toc-h5"><a href="#composite객체가-제공하던-모든-메서드들---command홀더객체는-사실상-외부에-public-addcommandexecuteadd만-제공--구상-커맨드객체만-외부에서-입력해주면-그외-메서드는-없어도-된다편의상-커맨드객체별-서비스메서드로-제공-중">composite객체가 제공하던 모든 메서드들 -&gt; command홀더객체는 사실상 외부에 public addCommand(execute+add)만 제공 + 구상 커맨드객체만 외부에서 입력해주면, 그외 메서드는 없어도 된다.(편의상 커맨드객체별 서비스메서드로 제공 중)</a></li>
<li class="toc-entry toc-h5"><a href="#실시간-실행런타임-중-상태변경은-커맨드객체가-최고다-커맨드홀더--addcommand-원하는-상태변경-커맨드객체--ex-홈페이지-빌더">실시간, 실행(런타임) 중 상태변경은 커맨드객체가 최고다. 커맨드홀더 + addCommand( 원하는 상태변경 커맨드객체 ) ex&gt; 홈페이지 빌더</a></li>
<li class="toc-entry toc-h5"><a href="#즉-범용-커맨드홀더객체--차이점을-만드는-구상커맨드객체들을-소유하고-있으면-객체간-차이를-런타임에서-실시간으로-만들어낼-수-있다">즉 범용 커맨드홀더객체 + 차이점을 만드는 구상커맨드객체들을 소유하고 있으면, 객체간 차이를 런타임에서 실시간으로 만들어낼 수 있다.</a></li>
<li class="toc-entry toc-h5"><a href="#커맨드홀더객체-내-서비스메서드들addcommand래핑이외에-메서드들get계열-의존성을-가진-것으로-소유객체가-변하면-같이-죽는다-하지만-서비스메서드들은-이미-죽은상태의-메서드들이라-의존성없이-좋은-메서드들임">커맨드홀더객체 내 서비스메서드들(addCommand래핑)이외에 메서드들(get계열) 의존성을 가진 것으로, 소유객체가 변하면 같이 죽는다. 하지만, 서비스메서드들은 이미 죽은상태의 메서드들이라 의존성없이 좋은 메서드들임</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#커맨드패턴이-무적같지만-save와-load가-안된다-save와-load를-하려면-시리얼라이제이션을-통한-영속화를-따로-해야한다">커맨드패턴이 무적같지만.. save와 load가 안된다. save와 load를 하려면, [시리얼라이제이션을 통한 영속화]를 따로 해야한다.</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#메멘토-패턴-save-with-visitor패턴">메멘토 패턴 save with Visitor패턴</a>
<ul>
<li class="toc-entry toc-h3"><a href="#커맨드홀더객체는-소유객체composite객체의-메멘토상태정보를-관리하는-caretaker역할을-하여-저장컬렉션-필드를-가진다">커맨드홀더객체는 소유객체(Composite객체)의 메멘토(상태정보)를 관리하는 CareTaker역할을 하여 저장컬렉션 필드를 가진다.</a>
<ul>
<li class="toc-entry toc-h4"><a href="#고전에는-stack으로-관리하지만-여기서는-map으로-한다-map의-key는-주로-string으로-받는다-save는-json으로-저장될-메멘토라서-string으로-저장한다">고전에는 Stack으로 관리하지만, 여기서는 Map으로 한다. map의 key는 주로 string으로 받는다. save는 json으로 저장될 메멘토라서 string으로 저장한다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#메멘토-관리자-커맨드홀더는-save와-load함수를-가지며-void-save-string-load-시그니쳐부터-작성한다">메멘토 관리자 커맨드홀더는, save와 load함수를 가지며, void save, String load 시그니쳐부터 작성한다.</a>
<ul>
<li class="toc-entry toc-h4"><a href="#save시-저장할-string-key를-외부에서-받고-load로-꺼낼-때도-key를-받는다">save시 저장할 string key를 외부에서 받고, load로 꺼낼 때도 key를 받는다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#save는-renderer와-jsonvisitor를-활용해서-만든다">Save는 Renderer와 JsonVisitor를 활용해서 만든다.</a>
<ul>
<li class="toc-entry toc-h4"><a href="#제어역전한-renderer-생성자주입되어-제어를-타는-전략객체-visitor-메서드인자로-들어가는-데이터객체composite-report의-역할을-변경해야한다">제어역전한 Renderer, 생성자주입되어 제어를 타는 전략객체 Visitor, 메서드인자로 들어가는 데이터객체(Composite-&gt;report)의 역할을 변경해야한다</a></li>
<li class="toc-entry toc-h4"><a href="#renderer는-제어만-역전해서-visitor에게-제어로직을-위임해주는-void메서드만-제공한다-뭔가를-반환안해준다">Renderer는 [제어만 역전해서 visitor에게 제어로직을 위임해주는 void메서드]만 제공한다. 뭔가를 반환안해준다.</a></li>
<li class="toc-entry toc-h4"><a href="#전략visitor들은-renderer제어역전클래스에-주입되서--데이터객체를-메서드인자로-위임받아-자기-전략메서드들에서-사용하지만--제어처리-전략메서드들도-다-void이다-뭔가를-반환안해준다">전략Visitor들은, Renderer(제어역전)클래스에 주입되서,  데이터객체를 메서드인자로 위임받아, 자기 전략메서드들에서 사용하지만,  [제어처리 전략메서드들도 다 void]이다. 뭔가를 반환안해준다</a></li>
<li class="toc-entry toc-h4"><a href="#출력관련-제어역전renderer와-visitor-전략오퍼레이터들은-모두-void로-정의해놓고-구상-전략객체들이-데이터출력-제어로직을-담당한다">출력관련 제어역전Renderer와, Visitor 전략오퍼레이터들은 모두 void로 정의해놓고, [구상 전략객체들이 데이터+출력 제어로직을 담당]한다</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#구상-visitor들은-위임받은-데이터-객체를-처리할-때-싸이클을-타면서-처리한-정보를-구상-객체context로서-필드에-저장해놨다가-차후-getter로-제공해줄-수-있다">구상 Visitor들은 [위임받은 데이터 객체를 처리]할 때, [싸이클을 타면서 처리한 정보를, 구상 객체context로서 필드에 저장]해놨다가, [차후 getter로 제공]해줄 수 있다.</a>
<ul>
<li class="toc-entry toc-h4"><a href="#출력-rendering관련-제어로직들은-다-void로-시작한다-visitor가-싸이클을-타면서-처리된-정보를-구상-vsititor전략객체마다-저장하고-싶은-데이터개체-처리정보는-상태값으로-저장으로-일단-저장해서-품고-있자">출력, rendering관련 제어로직들은 다 void로 시작한다. Visitor가 싸이클을 타면서, 처리된 정보를 [구상 Vsititor전략객체마다 저장하고 싶은 데이터개체 처리정보는 상태값으로 저장]으로 일단 저장해서 품고 있자!!</a></li>
<li class="toc-entry toc-h4"><a href="#factory에-----new객체-지연생성--vs------외부생성객체-로컬변수-이미-생성된-객체-주입">factory에 ( () -&gt; new객체) 지연생성  vs  ( () -&gt; 외부생성객체 로컬변수) 이미 생성된 객체 주입</a>
<ul>
<li class="toc-entry toc-h5"><a href="#my-함수형-인터페이스-factory지연생성으로-주입하는-이유는-가상인자-람다식을-통한-구현시-new-때리는-것을--넣어-지연생성할-수도-있지만-이미-외부에서-생성된-객체를-주입도-선택가능하기-때문이다">my) 함수형 인터페이스 factory(지연생성)으로 주입하는 이유는 [가상인자 람다식을 통한 구현]시 [new 때리는 것을  넣어 지연생성]할 수도 있지만, [이미 외부에서 생성된 객체를 주입]도 선택가능하기 때문이다.</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#상태값을-가지는-visitor는-더이상-reneder-속-factory로-주입---내부에서-new때려서-생성-후-처리하고-소멸해서는-안된다">상태값을 가지는 Visitor는 더이상 [Reneder 속 factory로 주입 -&gt; 내부에서 new때려서 생성 후 처리하고 소멸]해서는 안된다.</a>
<ul>
<li class="toc-entry toc-h4"><a href="#save에-필요한-정보를-이미-생성한-jsonvisitor가-renderer의-싸이클을-타고와서-getter로-제공해줄-것이다">save에 필요한 정보를 이미 생성한 JsonVisitor가 renderer의 싸이클을 타고와서 getter로 제공해줄 것이다.</a></li>
<li class="toc-entry toc-h4"><a href="#renderer--jsonvisitor를-커맨드홀더객체-속-메멘토-save메서드로-가져와-정보-싸이클태워-출력대신-상태값-저장된-정보를-getter로-제공해준다">renderer + jsonvisitor를 커맨드홀더객체 속 메멘토 save메서드로 가져와 정보, 싸이클태워, 출력대신 상태값 저장된 정보를 getter로 제공해준다.</a></li>
<li class="toc-entry toc-h4"><a href="#참고-지연실행을-위한-람다식-속-지역변수는-inline하면-안된다">참고) 지연실행을 위한 람다식 속 지역변수는 inline하면 안된다!</a></li>
<li class="toc-entry toc-h4"><a href="#참고2-커맨드홀더객체는-main에서-생성한-컴포짓-root객체를-소유한다-그래서-save속-renderer에-필요한-report를-만들-때-root인-소유객체필드composite필드로-만든다">참고2) 커맨드홀더객체는 Main에서 생성한 [컴포짓 root객체]를 소유한다. 그래서 save속 renderer에 필요한 report를 만들 때, root인 소유객체필드(Composite필드)로 만든다.</a>
<ul>
<li class="toc-entry toc-h5"><a href="#my-지연생성은-내부에서-new때려서-생성하는-것과-동일하다-상태값-없는-불변객체-생성시-이렇게-한다-그러나-어떤-구상체는-상태값을-가지고-내부에서-처리된-후-변경된-상태--새로운-정보를-외부에-제공할-수-도-있다-지연생성-람다식에---이미-생성된-객체를-넣어줘서-내부로직이-끝난-후에도-정보가-외부지역변수-속-객체는-정보를-가지고-있게-된다">my) 지연생성은 내부에서 new때려서 생성하는 것과 동일하다. 상태값 없는 불변객체 생성시 이렇게 한다. 그러나 어떤 구상체는 상태값을 가지고, 내부에서 처리된 후 [변경된 상태] == [새로운 정보]를 외부에 제공할 수 도 있다. [지연생성 람다식에 -&gt; 이미 생성된 객체]를 넣어줘서, 내부로직이 끝난 후에도 정보가 외부지역변수 속 객체는 정보를 가지고 있게 된다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#외부미리-생성된-뒤-싸이클을-타는-visitor객체는-싸이클을타며-저장한-상태필드-속-정보를-getter로-제공해줘야한다">외부미리 생성된 뒤, 싸이클을 타는 Visitor객체는 싸이클을타며 저장한 상태필드 속 정보를 getter로 제공해줘야한다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#save내부-json만드는-일을-메서드추출하여-리팩토링하고-json만드는-일을-테스트하자">save내부 json만드는 일을 메서드추출하여 리팩토링하고, json만드는 일을 테스트하자</a>
<ul>
<li class="toc-entry toc-h4"><a href="#내수용-메서드추출시-내부context가-불변객체면-파라미터로-안빼도-된다">내수용 메서드추출시, 내부context가 불변객체면 파라미터로 안빼도 된다.</a></li>
<li class="toc-entry toc-h4"><a href="#create-json하는-일은-private내수용메서드다-테스트는-그대로-복사해가서-하고-지운다">create json하는 일은 private내수용메서드다. 테스트는 그대로 복사해가서 하고 지운다</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#생각해보기-3">생각해보기</a>
<ul>
<li class="toc-entry toc-h4"><a href="#memento패턴은-visitor패턴이-이미-구현되어있으면-쉽게-구현가능하다">memento패턴은, visitor패턴이 이미 구현되어있으면 쉽게 구현가능하다</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#메멘토-패턴-load-구현jsonstring---root부터-자신setter--자식동적트리순회---composite객체-만들기">메멘토 패턴 load 구현(jsonString -&gt; root부터 자신setter + 자식동적트리순회 -&gt; composite객체 만들기)</a>
<ul>
<li class="toc-entry toc-h3"><a href="#load는-조회이므로-존재검증---조회---가져온-데이터의-postcondition검사까지-동시에-한다">load는 조회이므로, [존재검증 -&gt; 조회 -&gt; 가져온 데이터의 postcondition검사]까지 동시에 한다.</a></li>
<li class="toc-entry toc-h3"><a href="#load시-컴포짓객체의-생성은-커맨드홀드가-소유한-필드객체root-composite을-재활용해서-한다">load시 컴포짓객체의 생성은 커맨드홀드가 소유한 필드객체(root Composite)을 재활용해서 한다.</a>
<ul>
<li class="toc-entry toc-h4"><a href="#재활용하는-composite-root-객체는-자식들을-먼저-비워야한다-이-때-자식들도-자신내부의-자식들을-비워야하니-재귀---동적트리순회를-통한-삭제를-해야한다">재활용하는 composite root 객체는 자식들을 먼저 비워야한다. 이 때, 자식들도 자신내부의 자식들을 비워야하니, [재귀 -&gt; 동적트리순회를 통한 삭제]를 해야한다.</a></li>
<li class="toc-entry toc-h4"><a href="#composite객체의-자식들-삭제는-자식의-자식들도-삭제되거야하는-동적트리-순회---재귀메서드가-된다">composite객체의 자식들 삭제는 [자식의 자식들도 삭제되거야하는 동적트리 순회] -&gt; 재귀메서드가 된다.</a></li>
<li class="toc-entry toc-h4"><a href="#동적트리삭제-재귀메서드의-종착역으로서-삭제할-자식들이-없으면-ealry-return으로-종료한다-삭제-전-존재검증은-thr-없을-수-도-있는-것의-삭제는-early-return이다-">[동적트리삭제] 재귀메서드의 종착역으로서, [삭제할 자식들이 없으면 ealry return]으로 종료한다. (삭제 전 존재검증은 thr, [없을 수 도 있는 것의 삭제]는 early return이다. )</a></li>
<li class="toc-entry toc-h4"><a href="#자식들의-동적트리삭제는-자신의-차례에서-자식들삭제-로직을-넣어줘야한다-자식들을-동적트리순회하면서-호출하고-난-다음---끝처리로서-자식들-컬렉션필드를-clear-해준다">[자식들의 동적트리삭제]는 자신의 차례에서 [자식들삭제 로직]을 넣어줘야한다. [자식들을 동적트리순회하면서, 호출하고 난 다음] -&gt; 끝처리로서 [자식들 컬렉션필드를 .clear()] 해준다</a>
<ul>
<li class="toc-entry toc-h5"><a href="#자식들에게-피드백받는-재귀처리는-자식들을-살려놓고-돌린상태의--동적트리-or-자식재귀호출-1여러개-호출이-끝난-상태에서-끝처리로-자식들을-처리한다">자식들에게 피드백받는 재귀처리는, 자식들을 살려놓고 돌린상태의  [동적트리 or 자식재귀호출 1~여러개 호출]이 끝난 상태에서, [끝처리로 자식들을 처리]한다</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#리팩토링---load--자식들처리에서-load로직을-1개-메서드로-추출">리팩토링 -&gt; load + 자식들처리에서 load로직을 1개 메서드로 추출</a>
<ul>
<li class="toc-entry toc-h5"><a href="#할당문이-포함된-로직에서-아직-할당된-지역변수가-뒤에-쓰이지-않았다면-return없이-추출된다---뒤에-억지로라도-써놓고-추출하면-편하다">할당문이 포함된 로직에서, 아직 할당된 지역변수가 뒤에 쓰이지 않았다면, return없이 추출된다. -&gt; 뒤에 억지로라도 써놓고 추출하면 편하다</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#json-string을-cursor도입하여-다음depth로-이동하면서-composite객체-재생성하기">json String을 cursor도입하여 다음depth로 이동하면서 Composite객체 재생성하기</a>
<ul>
<li class="toc-entry toc-h3"><a href="#load메서드내-jsonstring-파싱하는-복잡한-작업이-시작된다-디버깅하면서-내부로직을-만들기-위해-load한-json을-반환하도록-수정한-뒤-테스트에서-환경을-조성해-만들어나가자">load메서드내 json(string) 파싱하는 복잡한 작업이 시작된다. 디버깅하면서 내부로직을 만들기 위해 load한 json을 반환하도록 수정한 뒤, 테스트에서 환경을 조성해 만들어나가자</a>
<ul>
<li class="toc-entry toc-h4"><a href="#최소한-자식을-가지는-예제-json-string을-만들어둔다">최소한 자식을 가지는 예제 json String을 만들어둔다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#커맨드홀더객체-내-root자신부터-만들기-위해-데이터-추출-by-target-string--indexof--cursor--substring">커맨드홀더객체 내, root자신부터 만들기 위해 데이터 추출 by target String + .indexOf() + cursor + .substring</a>
<ul>
<li class="toc-entry toc-h4"><a href="#01-찾고싶은-string속-data의-직전-string을--target변수로-추출한다-예제-jsonstring-복붙활용">01 찾고싶은 string속 data의 직전 string을  target변수로 추출한다 (예제 jsonstring 복붙활용)</a></li>
<li class="toc-entry toc-h4"><a href="#02-cursor을-0으로-초기화하고-indexof-string타겟-시작index에-쓰일-데이터추출시마다-업데이트되는-검색-시작인덱스로-사용한다">02 cursor을 0으로 초기화하고, index.Of( string타겟, 시작index)에 쓰일 [데이터추출시마다 업데이트되는 검색 시작인덱스]로 사용한다</a></li>
<li class="toc-entry toc-h4"><a href="#03-indexof-target데이터직전까지의-문자열-cursor검색시작인덱스-을-통해---target-start-index를-찾는다---못찾는-경우--1을-반환하며-그-때-cursor도--1으로-업데이트한다">03 .indexOf( target[데이터직전까지의 문자열], cursor[검색시작인덱스] )을 통해 -&gt; target start index를 찾는다. -&gt; 못찾는 경우 -1을 반환하며, 그 때 cursor도 -1으로 업데이트한다</a></li>
<li class="toc-entry toc-h4"><a href="#04-target-start-index--targetlength-로-cursor-업데이트하여---cursor가-데이터시작점에-오도록-위치시킨다">04 target start index + target.length() 로 cursor 업데이트하여 -&gt; cursor가 데이터시작점에 오도록 위치시킨다.</a></li>
<li class="toc-entry toc-h4"><a href="#05-data의-끝을-알려주는-target인-를-cursor데이터시작--1부터-indexof--로-찾아-data끝--1위치를-찾는다">05 data의 끝을 알려주는 target인 &quot;를 cursor(데이터시작) + 1부터 .indexOf( , )로 찾아, data끝 + 1위치를 찾는다.</a></li>
<li class="toc-entry toc-h4"><a href="#06-data시작cursor--data끝1-까지를-substring을-통해-data만-추출한다">06 data시작(cursor) ~ data끝+1 까지를 substring을 통해, data만 추출한다</a></li>
<li class="toc-entry toc-h4"><a href="#07-data를-추출할-때까지-cursor의-움직임을-관찰하고--다음-target도-찾아본다">07 data를 추출할 때까지, cursor의 움직임을 관찰하고,  다음 target도 찾아본다.</a></li>
<li class="toc-entry toc-h4"><a href="#08-가변변수-cursor-초기화와-변수-초기화-부분은-제외하고-가변변수-업데이트-부분만-메서드-추출한다">08 [가변변수 cursor 초기화]와 [변수 초기화] 부분은 제외하고 [가변변수 업데이트 부분만 메서드 추출]한다</a>
<ul>
<li class="toc-entry toc-h5"><a href="#가변변수는-외부에-두고-추출한-메서드가-반환한-값으로-외부-가변변수-업데이트하게-한다">가변변수는 외부에 두고 [추출한 메서드가 반환한 값]으로 [외부 가변변수 업데이트]하게 한다</a></li>
<li class="toc-entry toc-h5"><a href="#가변변수는-외부에-두어-파라미터로-뽑히더라도-내부에서-다시-가변변수를-업데이트하고-그-가변변수를-return---외부에서-다시-업데이트도록-뽑힌다-어차피-외부에서-업데이트하도록-메서드-추출되므로-내부-메서드에서는-가변변수가-업데이트될-값만-return하도록-수정한다">가변변수는 외부에 두어 파라미터로 뽑히더라도, 내부에서 다시 가변변수를 업데이트하고, 그 가변변수를 return -&gt; 외부에서 다시 업데이트도록 뽑힌다. [어차피 외부에서 업데이트하도록 메서드 추출]되므로 [내부 메서드에서는 가변변수가 업데이트될 값만 return]하도록 수정한다.</a></li>
<li class="toc-entry toc-h5"><a href="#지역변수-초기화-부분은-외부에-두고-추출한메서드의-파라미터로-입력되도록-외부에서-다른-값으로-초기화해도-사용할-수-있는-메서드로-만든다">지역변수 초기화 부분은 외부에 두고 [추출한메서드의 파라미터로 입력]되도록 [외부에서 다른 값으로 초기화해도 사용할 수 있는 메서드]로 만든다.</a></li>
<li class="toc-entry toc-h5"><a href="#변수초기화관련-메서드추출에서-지역변수---추출메서드-인자의-과정을-inline으로-바꾸는-순간-특정-지역변수with초기화없이-다른-값을-대입할-수-있게-된다">변수초기화관련 메서드추출에서, [지역변수 -&gt; 추출메서드 인자]의 과정을 [INLINE으로 바꾸는 순간, 특정 지역변수with초기화없이, 다른 값을 대입]할 수 있게 된다</a></li>
<li class="toc-entry toc-h5"><a href="#값이-바뀌는-변수는-지역변수를-inline화-했지만-가변변수는-inline하면-안된다-계속-업데이트-되서-외부-다른-메서드들도-쓸-것이기-때문에-초기값--외부-업데이트가-유지되어야한다----inline해도-지역변수가-사라지지-않고-남아있음">[값이 바뀌는 변수]는 지역변수를 inline화 했지만, [가변변수는 inline하면 안된다. 계속 업데이트 되서 외부 다른 메서드들도 쓸 것이기 때문에, 초기값 + 외부 업데이트가 유지되어야한다]  -&gt; inline해도 지역변수가 사라지지 않고 남아있음</a></li>
<li class="toc-entry toc-h5"><a href="#즉-내부context불변필드제외를-지역변수로-위에두고-추출하여-파라미터로-만들-듯-가변변수와-다른-값으로-바뀔-수-있는-변수-초기화부분은-위쪽--외부에-두고-메서드추출한다">즉, 내부context(불변필드제외)를 지역변수로 위에두고 추출하여 파라미터로 만들 듯, [가변변수]와 [다른 값으로 바뀔 수 있는 변수 초기화]부분은 위쪽 == 외부에 두고 메서드추출한다</a></li>
<li class="toc-entry toc-h5"><a href="#바뀌는-지역변수의-값---인자로-inline화-되었다면-특정-지역변수로-만들어진-파라미터의-이름을-바꿔주자-title-target---dataprefix-등">바뀌는 지역변수의 값 -&gt; 인자로 inline화 되었다면, [특정 지역변수로 만들어진 파라미터]의 이름을 바꿔주자 (title target -&gt; dataPrefix 등)</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#09-업데이트된-가변변수cursor를-이용하는-다음로직인-substring-부분을-메서드추출해보자">09 업데이트된 가변변수cursor를 이용하는, 다음로직인 substring 부분을 메서드추출해보자</a>
<ul>
<li class="toc-entry toc-h5"><a href="#가-데이터의-끝임을-알려주므로-변하지-않는-상수로-취급한다면-바뀌는-변수는-포함된-가변변수-사용밖에-없다">&quot;가 데이터의 끝임을 알려주므로, 변하지 않는 상수로 취급한다면, 바뀌는 변수는 [포함된 가변변수 사용]밖에 없다</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#10-조심-가변변수--업데이트-이후--가변변수-사용-부분은-inline화-하면-안된다">10 조심! [가변변수 = 업데이트 –이후–&gt;  가변변수 ]사용 부분은 inline화 하면 안된다!</a>
<ul>
<li class="toc-entry toc-h5"><a href="#가변변수란-위쪽에-컨트롤타워로서-지역변수에-계속-업데이트-되는-것이-목적이다-업데이트-로직을-inline화-시키면-컨트롤타워가-업데이트-안되고-일회성-사용하는-것-밖에-안된다">가변변수란, [위쪽에 컨트롤타워로서 지역변수에 계속 업데이트 되는 것이 목적]이다. 업데이트 로직을 inline화 시키면, 컨트롤타워가 업데이트 안되고, 일회성 사용하는 것 밖에 안된다.</a></li>
<li class="toc-entry toc-h5"><a href="#가변변수는-컨트롤-타워에-업데이트하면서-사용할-사람들은-사용해야한다-가변변수를-업데이트와-동시에-인자로-inline화하고-싶다면---메서드-인자에서---가변변수--업데이트로직자체를-수동inline해야한다">가변변수는 [컨트롤 타워에 업데이트하면서, 사용할 사람들은 사용]해야한다. [가변변수를 업데이트와 동시에 인자로 INLINE화]하고 싶다면 -&gt; 메서드 인자에서  [ (가변변수 = 업데이트로직)]자체를 수동INLINE해야한다</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#11-targetprefix만-바꿔서-다음-타겟이-잘-추출되는지-확인한다-title---date">11 targetPrefix만 바꿔서, 다음 타겟이 잘 추출되는지 확인한다 (title -&gt; date)</a></li>
<li class="toc-entry toc-h4"><a href="#12-available까지-추출해보고-가변변수업데이트-inline으로-바꾼-뒤-자신의-처리가-끝났으니-커맨드홀더객체load로-옮겨서-root-composite객체를-setter로-만들어주자">12 available까지 추출해보고, 가변변수업데이트 inline으로 바꾼 뒤, 자신의 처리가 끝났으니 커맨드홀더객체#load로 옮겨서, root Composite객체를 setter로 만들어주자</a>
<ul>
<li class="toc-entry toc-h5"><a href="#test에서-만든-로직--private메서드들을--load메서드로-옮긴다">Test에서 만든 로직 + private메서드들을  load메서드로 옮긴다</a></li>
<li class="toc-entry toc-h5"><a href="#커맨드홀더객체-내-root-composite객체를-재활용하기-위해-추출한-필드정보를-setter로-채운다-string-date---localdatetimeparse--string-boolean---booleanparseboolean-으로-를-한번더-씌워서-set해줘야한다">커맨드홀더객체 내 root Composite객체를, 재활용하기 위해, 추출한 필드정보를 setter로 채운다. String date -&gt; LocalDateTime.parse() / String boolean -&gt; Boolean.parseBoolean() 으로 를 한번더 씌워서 set해줘야한다</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#커맨드홀더-객체-내-자식들-정보가-있는지-확인-후-add해서-붙여주기">커맨드홀더 객체 내, 자식들 정보가 있는지 확인 후, add해서 붙여주기</a>
<ul>
<li class="toc-entry toc-h4"><a href="#composite객체의-자식생성은-데이터가-있을-경우---데이터를-추출해서-add로-root에-붙여주면-된다">composite객체의 자식생성은 [데이터가 있을 경우] -&gt; 데이터를 추출해서 .add()로 root에 붙여주면 된다.</a></li>
<li class="toc-entry toc-h4"><a href="#13-자식-존재유무-판단할-수-있는-곳인-sub--를-prefix로-그-1칸-뒤까지-이동시켜-자식-있다면-로-시작하도록-cursor업데이트-시키기">13 자식 존재유무 판단할 수 있는 곳인 [sub: [ 를 prefix로 그 1칸 뒤까]지 이동시켜, 자식 있다면, {로 시작하도록 cursor업데이트 시키기</a></li>
<li class="toc-entry toc-h4"><a href="#14-다시-한번-복잡한-로직자식-존재유무--데이터-추출이-예견되므로-test로-현재까지-결과를-옮겨서-디버깅하며-처리하기">14 다시 한번 복잡한 로직(자식 존재유무 &amp;&amp; 데이터 추출)이 예견되므로 Test로 현재까지 결과를 옮겨서 디버깅하며 처리하기</a>
<ul>
<li class="toc-entry toc-h5"><a href="#자신의-정보-추출까지는-cursor가-업데이트-되어있으니-cursor-업데이트-로직까지-들고와서-test에서-진행한다">자신의 정보 추출까지는 cursor가 업데이트 되어있으니, cursor 업데이트 로직까지 들고와서 Test에서 진행한다.</a></li>
<li class="toc-entry toc-h5"><a href="#test참고-커맨드홀더객체내-load메서드에서-재활용하는-객체는-command홀더객체가-아니라-소유--composite원본객체를-만든다-하지만-test에서는-command홀더객체-내부-composite객체를-생성해서-테스트한다면-save나-load가-호출불가하므로-테스트의-목적인-load메서드를-호출하고-load의-뒷부분만-처리하기-위해-중간결과인-json을-받고-처리-중에-있다">Test참고) 커맨드홀더객체내 load메서드에서 재활용하는 객체는 command홀더객체가 아니라 소유  composite원본객체를 만든다. 하지만, Test에서는 Command홀더객체 내부 composite객체를 생성해서 테스트한다면, save나 load가 호출불가하므로 테스트의 목적인 load메서드를 호출하고, load의 뒷부분만 처리하기 위해 중간결과인 json을 받고 처리 중에 있다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#14-자식정보가-남아있을-때까지-add---while문을-사용해서-반복하며-cursor와-같이-움직이는-배열은-cursor로-현재-위치를-확인하도록-while문을-작성한다-이때-cursor업데이트-조건은-1칸씩-이동이다데이터-추출이-아니라-데이터-존재유무-확인부터">14 자식정보가 남아있을 때까지 add -&gt; while문을 사용해서 반복하며, [cursor와 같이 움직이는 배열]은 [cursor로 현재 위치를 확인]하도록 while문을 작성한다. 이때, cursor업데이트 조건은 1칸씩 이동이다(데이터 추출이 아니라 데이터 존재유무 확인부터)</a>
<ul>
<li class="toc-entry toc-h5"><a href="#참고-command홀더객체-내-cmd객체들-외부저장소list배열과-cursor로-상태확인">참고) command홀더객체 내, cmd객체들 외부저장소(List배열)과 cursor로 상태확인</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#15-sub--1칸-뒤에서부터-cursor를-1개씩-증가시키면서-문자열1개씩-확인하며-자식존재여부를-판단한다">15 sub: [ 1칸 뒤에서부터 cursor를 1개씩 증가시키면서 문자열1개씩 확인하며, 자식존재여부를 판단한다.</a>
<ul>
<li class="toc-entry toc-h5"><a href="#데이터-추출이전에-cursor에-있는-문자열-1개씩-jsoncharatcursor으로-뽑아-검사하여-if-자식데이터-존재유무를-확인한다-cursor업뎃-중에-if에-안걸린다면-건너띈다는-의미이다">데이터 추출이전에, cursor에 있는 문자열 1개씩 json.charAt(cursor)으로 뽑아 검사하여, if 자식데이터 존재유무를 확인한다. cursor++업뎃 중에 if에 안걸린다면 건너띈다는 의미이다.</a></li>
<li class="toc-entry toc-h5"><a href="#담에-나온-문자열이-라면-자식이-최소-1개-존재한다는-의미이다---자식데이터들을-추출한-뒤-add자식-해준다">[담에 나온 문자열이 {라면, 자식이 최소 1개 존재한다는 의미이다. -&gt; 자식데이터들을 추출한 뒤, add자식 해준다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#현재-availableboolean에-대한-setter메서드는-toggle만-커맨드로-만들어줬다-여기서-available의-setter를-추가해줘야한다">현재 Available(boolean)에 대한 setter메서드는 toggle만 커맨드로 만들어줬다. 여기서 available의 setter를 추가해줘야한다.</a>
<ul>
<li class="toc-entry toc-h5"><a href="#객체를-생성하면-기본-default로-정해져서-toggle만-정의하고-setter는-무시했지만-save된-jsonstring으로-load할때는-기본값이-아닌-저장된-값으로-채워줘야한다">객체를 생성하면 기본 default로 정해져서 toggle만 정의하고, setter는 무시했지만, save된 jsonstring으로 load할때는, 기본값이 아닌 저장된 값으로 채워줘야한다</a></li>
<li class="toc-entry toc-h5"><a href="#compositemenu생성자에-available을-받아서-생성되는-것까지-test에서부터-추가해-나가야한다">CompositeMenu생성자에 available을 받아서 생성되는 것까지, Test에서부터 추가해 나가야한다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#커맨드홀더-소유객체composite의-필드가-추가되었으면-add만-수정하지-말고----remove도-다-처리해줘야한다-필드에-대해-oldxxxx처리">커맨드홀더 소유객체(Composite)의 필드가 추가되었으면, Add만 수정하지 말고 -&gt;  Remove도 다 처리해줘야한다. (필드에 대해 oldXXXX처리)</a></li>
<li class="toc-entry toc-h4"><a href="#command홀더객체는-addremoveundoredo-이외에-소유객체의-필드setter들도-커맨드객체-처리해줘야했다">command홀더객체는, add/remove/undo/redo 이외에 소유객체의 필드setter들도 커맨드객체 처리해줘야했다.</a>
<ul>
<li class="toc-entry toc-h5"><a href="#available은-tf라서-toggle만-만들어줬었는데-객체-재활용을-통한-생성을-하기-위해-setter로-만들어줘야한다">available은 t/f라서 toggle만 만들어줬었는데, 객체 재활용을 통한 생성을 하기 위해 setter로 만들어줘야한다.</a></li>
<li class="toc-entry toc-h5"><a href="#다시-test로-넘어와서-자식데이터-중에-available까지-뽑아서-자식menu를-추가해준다">다시 Test로 넘어와서, 자식데이터 중에 available까지 뽑아서 자식menu를 추가해준다</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#16-sub-담에-를-발견해서-자식데이터-추출후-add했다면--닫히기-전에-로-자식의-자식이-있는지-확인해야한다">16 sub[ 담에 {를 발견해서 자식데이터 추출후 add했다면, } 닫히기 전에 [로 자식의 자식이 있는지 확인해야한다</a>
<ul>
<li class="toc-entry toc-h5"><a href="#하지만--자식-발견하도-바로-continue로-넘어가는게-아니라-이어서-추출cursor업뎃자식add후-자식의-자식이-있는지-vs--가-바로-나와서-sub가-닫히는지-검사하는-중이다">하지만, { 자식 발견하도 바로 continue로 넘어가는게 아니라 이어서 추출+cursor업뎃+자식add후 자식의 자식[이 있는지 vs ` ]가 바로 나와서 sub[가 닫히는지 `검사하는 중이다.</a></li>
<li class="toc-entry toc-h5"><a href="#if로-1개의-작업이-끝났다면-빠른-continue를-해주는게-좋은데-뒤에-공통로직인-반복문변수-업데이트로직-cursor가-남아있다면-continue로-끝내면-안된다">if로 1개의 작업이 끝났다면, 빠른 continue를 해주는게 좋은데… 뒤에 공통로직인 [반복문변수 업데이트로직] cursor++가 남아있다면, continue로 끝내면 안된다.</a></li>
<li class="toc-entry toc-h5"><a href="#매번-if---continue할때마다-cursor업데이트할지-vs-if만-처리하고-continue없이-공통으로-cursor업데이트할지-정해야한다">매번 if - continue할때마다 cursor업데이트할지 vs if만 처리하고 continue없이 공통으로 cursor업데이트할지 정해야한다</a></li>
<li class="toc-entry toc-h5"><a href="#반복문내-모든-if에-대해-밑에-반복문-업데이트-같은-공통로직이-남아있다면-if에서-early-continue하면-안된다">반복문내 모든 if에 대해 밑에 반복문 업데이트 같은 공통로직이 남아있다면, if에서 early continue하면 안된다</a></li>
<li class="toc-entry toc-h5"><a href="#이대로-반복문이-흘러가면-자식-발견후-같은level의-다음자식들은-다-발견될시-데이터-추출후-add가-끝날-것이다">이대로 반복문이 흘러가면, 자식 발견후, 같은level의 다음자식들은 다 {발견될시 데이터 추출후 add가 끝날 것이다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#17--확인으로-자식의-데이터를-추출해-add했다면-다음-해야할-일은-자식의-가-열리고-가-발견되어-또다른-depth자식의-자식이-열리는지-확인해야한다-그리고-이것은--가-발견되어서-최소-1개의-자식이-있고-거기서-sub-가-열리는지-확인하는-것이다">17  {확인으로 자식의 데이터를 추출해 add했다면, 다음 해야할 일은, 자식의 [가 열리고 {가 발견되어 또다른 depth(자식의 자식)이 열리는지 확인해야한다. 그리고 이것은  {가 발견되어서 최소 1개의 자식이 있고, 거기서 sub: [가 열리는지 확인하는 것이다.</a>
<ul>
<li class="toc-entry toc-h5"><a href="#반복문-속에서-특정if에-걸린-것을-확인하는-방법은-가변변수를-통해-결과물or불린flag을-챙겨놓는-방법-밖이다">반복문 속에서 특정if에 걸린 것을 확인하는 방법은 가변변수를 통해 결과물or불린Flag을 챙겨놓는 방법 밖이다.</a></li>
<li class="toc-entry toc-h5"><a href="#원래-load는-composite객체의-add로-자식을-넣지만-테스트에서는-포장된-command홀더객체를-사용하고-커맨드홀더객체들의-메서드들은-결과물이-없는-void라서-지연실행한다고-했다---지금은-boolean으로-플래그를-챙기고-내부에서는-add결과물로-if걸린-것을-확인하도록-바꾸자">원래 load는 composite객체의 add로 자식을 넣지만, 테스트에서는 포장된 command홀더객체를 사용하고, 커맨드홀더객체들의 메서드들은 결과물이 없는 void라서 지연실행한다고 했다. -&gt; 지금은 boolean으로 플래그를 챙기고. 내부에서는 add결과물로 if걸린 것을 확인하도록 바꾸자.</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#18-자신의-처리후---반복문으로-데이터뽑아-자식들을-채우다가-자식의-자식을-발견한-순간부터는-재귀를-돌려야한다">18 자신의 처리후 -&gt; 반복문으로 데이터뽑아 자식들을 채우다가, [자식의 자식]을 발견한 순간부터는 재귀를 돌려야한다</a>
<ul>
<li class="toc-entry toc-h5"><a href="#자신에서-자식들의-처리는--반복문--자식-1개처리로-여러자식들을-처리하도록-정의된다-이-때-반복문을-포함한-자식들처리-전체-부분을-재귀함수로-추출해야-내부에서-자식의-자식이-등장할-때-똑같이-반복문--자식1개로-처리--자식의-자식들-재귀로-처리-처리를-할-수-있다">자신에서 [자식들의 처리]는  [반복문 + 자식 1개처리]로 여러자식들을 처리하도록 정의된다. 이 때, [반복문을 포함한 자식들처리 전체] 부분을 재귀함수로 추출해야, 내부에서 자식의 자식이 등장할 때, 똑같이 [반복문 + 자식1개로 처리 + 자식의 자식들 재귀로 처리] 처리를 할 수 있다.</a></li>
<li class="toc-entry toc-h5"><a href="#재귀함수에서는-반복문내-자식1개-객체--재귀에서-자식의-자식으로-업데이트되어서-호출되어야하므로-재귀함수-파라미터에는-반복문내-자식1개-객체가-포함된-후---자식의-자식으로-업뎃하여-호출되어야-한다">재귀함수에서는 [반복문내 자식1개 객체]-&gt; [재귀에서 자식의 자식으로 업데이트]되어서 호출되어야하므로 [재귀함수 파라미터에는 반복문내 자식1개 객체가 포함된 후 -&gt; 자식의 자식으로 업뎃하여 호출]되어야 한다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#19-직접-composite객체의-자식객체들-생성을-위한-재귀로-만들어보기">19 직접 composite객체의 자식객체들 생성을 위한 재귀로 만들어보기</a>
<ul>
<li class="toc-entry toc-h5"><a href="#root의-자신처리는-재귀에서-제외한다--자식들부터만-자신의-처리가-반복문--자신처리1개의-여러번-반복되기-때문이다">root의 자신처리는 재귀에서 제외한다.  [자식들부터만, 자신의 처리가 반복문 + 자신처리1개의 여러번 반복되기 때문]이다.</a></li>
<li class="toc-entry toc-h5"><a href="#01-root의-자식들처리를-위한-반복문부터-재귀메서드로서-메서드-추출한다">01 root의 자식들처리를 위한 반복문부터 재귀메서드로서 메서드 추출한다.</a></li>
<li class="toc-entry toc-h5"><a href="#02-객체의-반복문처리-재귀는-반복문내-자식객체1개---자식의-자식-등장---자식의-자식객체-1개로-업데이트된-재귀-호출을-하면-된다--그러기-위해서는-파라미터로-자식객체-1개의-형이-올라와야하며-인자는-child---파라미터는-parent로-명명해준다">02 객체의 반복문처리 재귀는 [반복문내 자식객체1개 -&gt; 자식의 자식 등장 -&gt; 자식의 자식객체 1개로 업데이트된 재귀 호출]을 하면 된다.  그러기 위해서는, [파라미터로 자식객체 1개의 형]이 올라와야하며 [인자는 child -&gt; 파라미터는 parent로 명명]해준다.</a></li>
<li class="toc-entry toc-h5"><a href="#03-문제상황1-객체반복문-재귀메서드의-stack결정-파라미터-초기값이-반복문내-자식1개-객체가-아니라-root-자신이-들어간다---아-재귀에서-인자는-필요한-현재상태-값root일-뿐이고-실제--내부-작동하는-것은그-상태값으로-만들어진-다음-자식객체child-내부에서-만들어지거나-getter로-불려져서-그놈이-다음재귀에-상태값으로-들어가는-구나">03 문제상황1) 객체반복문 재귀메서드의 stack결정 파라미터 초기값이 반복문내 자식1개 객체가 아니라, [root 자신]이 들어간다. -&gt; “아~! 재귀에서 인자는 필요한 현재상태 값(root)일 뿐이고, 실제  내부 작동하는 것은,그 상태값으로 만들어진 다음 자식객체(child) 내부에서 만들어지거나 getter로 불려져서, 그놈이 다음재귀에 상태값으로 들어가는 구나~!”</a></li>
<li class="toc-entry toc-h5"><a href="#04-문제상황2-root가-들어갔으면-반복문내-자식객체1개가-만들어져서-변수로-활용되어야-다음-재귀의-root대신-들어가서-자신이-root역할을-한다">04 문제상황2) root가 들어갔으면, [반복문내 자식객체1개]가 만들어져서 변수로 활용되어야, 다음 재귀의 root대신 들어가서 자신이 root역할을 한다?!</a></li>
<li class="toc-entry toc-h5"><a href="#05-이제-자식의-자식이-발견된-시점에서-자식의-자식을---자식처럼-처리하기-위해-재귀메서드를-parent---child로-바꿔호출해준다">05 이제 자식의 자식이 발견된 시점에서, 자식의 자식을 -&gt; 자식처럼 처리하기 위해, 재귀메서드를 [parent -&gt; child로 바꿔]호출해준다.</a></li>
<li class="toc-entry toc-h5"><a href="#06-일반적인-반복문-객체재귀의-for-자식객체들---다음재귀와-다르게-종착역-자식들-소유안해서-for가-안돌고-끝나는-곳이-종착역이-아니다-----반복문이-json과-cursor로-돌아가고-있으므로-해당depthstack의-처리가-끝나는-곳을-직접-알려줘야한다---를-만나는-순간-해당-stack을-종료해야한다">06 일반적인 반복문 객체재귀의 [for 자식객체들 -&gt; 다음재귀]와 다르게 [종착역: 자식들 소유안해서 for가 안돌고 끝나는 곳이 종착역]이 아니다.   -&gt; 반복문이 json과 cursor로 돌아가고 있으므로, 해당depth(stack)의 처리가 끝나는 곳을 직접 알려줘야한다 -&gt; &#39;]&#39;를 만나는 순간 해당 stack을 종료해야한다.</a></li>
<li class="toc-entry toc-h5"><a href="#07-정해진-소스json을-돌며-모든-재귀stack에서-cursor를-업데이트하고-공유해야한다면-해당-stack이-끝나더라도-외부에서-초기화된-가변변수-cursor를-반환해줘야-다음-또다른-stack이-쓸-수-있다---자식객체-for문이-아니라-외부-컨트롤타워를-두고-초기화된-가변변수-cursor를-쓰는-재귀문이라면-stack끝나고-빽할-때마다-업데이트된-cursor를-종착역에서-반환해줘야한다-종착역반환---자식재귀-반환---재귀정의부-반환---외부에-반환">07 정해진 소스(json)을 돌며, 모든 재귀stack에서 cursor를 업데이트하고 공유해야한다면, 해당 stack이 끝나더라도, 외부에서 초기화된 가변변수 cursor를 반환해줘야, 다음 또다른 stack이 쓸 수 있다. -&gt; 자식객체 for문이 아니라, [외부 컨트롤타워를 두고 초기화된 가변변수 cursor를 쓰는 재귀문]이라면, [stack끝나고 빽할 때마다 업데이트된 cursor를 종착역에서 반환]해줘야한다. (종착역반환 -&gt; 자식재귀 반환 -&gt; 재귀정의부 반환 -&gt; 외부에 반환)</a></li>
<li class="toc-entry toc-h5"><a href="#08-재귀로-더해진-자식들을-확인하기-위해-cmdgetmenu객체를-지역변수로-빼고---composite객체를-출력하라면-rendere에-consolevisitor를-주입하고-메서드인자-compoiste--report로-만들어서-넣어줘야한다">08 재귀로 더해진 자식들을 확인하기 위해 cmd.getMenu()객체를 지역변수로 빼고 -&gt; composite객체를 출력하라면 rendere에 consolevisitor를 주입하고, 메서드인자 compoiste-&gt; report로 만들어서 넣어줘야한다</a></li>
<li class="toc-entry toc-h5"><a href="#09-이제-command홀더객체-load-내부로-옮긴-뒤-재활용이-완성된-소유composite객체를-반환하도록-load메서드의-시그니쳐를-바꾼다">09 이제 command홀더객체# load 내부로 옮긴 뒤, 재활용이 완성된 소유Composite객체를 반환하도록 load메서드의 시그니쳐를 바꾼다.</a></li>
<li class="toc-entry toc-h5"><a href="#10-test에서는-load의-반환이-string-json---재활용완성된-composite객체를-받도록-수정하고-다시-한번-출력해보자">10 test에서는 load의 반환이 string json -&gt; 재활용완성된 composite객체를 받도록 수정하고 다시 한번 출력해보자.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul><h1 id="menu를-만들며-익히는-command-memento-패턴">
<a class="anchor" href="#menu%EB%A5%BC-%EB%A7%8C%EB%93%A4%EB%A9%B0-%EC%9D%B5%ED%9E%88%EB%8A%94-command-memento-%ED%8C%A8%ED%84%B4" aria-hidden="true"><span class="octicon octicon-link"></span></a>menu를 만들며 익히는 command, memento 패턴</h1>

<ul>
  <li><a href="https://blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/menu/composite/visitor/2022/07/30/menu%EB%A5%BC-%EB%A7%8C%EB%93%A4%EB%A9%B0-%EC%9D%B5%ED%9E%88%EB%8A%94-visitor%ED%8C%A8%ED%84%B4.html">composite패턴, visitor패턴 적용</a></li>
  <li><a href="https://github.com/is2js/object2/tree/d503e51cfa4dadd3063a0c2cd06ba45388fe91a9/src/main/java/menu">시작 깃헙</a></li>
</ul>

<h2 id="command패턴-적용하기">
<a class="anchor" href="#command%ED%8C%A8%ED%84%B4-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>Command패턴 적용하기</h2>

<h3 id="커맨드-인터페이스에서-역할execute-undo부터-정의하고-기능위임한-객체는-파라미터로-받는다">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%97%90%EC%84%9C-%EC%97%AD%ED%95%A0execute-undo%EB%B6%80%ED%84%B0-%EC%A0%95%EC%9D%98%ED%95%98%EA%B3%A0-%EA%B8%B0%EB%8A%A5%EC%9C%84%EC%9E%84%ED%95%9C-%EA%B0%9D%EC%B2%B4%EB%8A%94-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A1%9C-%EB%B0%9B%EB%8A%94%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드 인터페이스에서 역할(execute, undo)부터 정의하고, 기능위임한 객체는 파라미터로 받는다.</h3>

<ol>
  <li>
    <p>인터페이스를 만들고 2가지 기본역할을 만든다.</p>

    <ol>
      <li>
        <p>void execute</p>
      </li>
      <li>
        <p>void undo</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810175233743.png" alt="image-20220810175233743"></p>
      </li>
    </ol>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">행위를 위임하여 캡슐화할 객체를 메서드인자로 받아서 내부에서 실행</code>시킨다.</strong></p>

    <ul>
      <li>task객체를 직접적으로 조작하는 것이 아니라 <strong>객체 인자 -&gt; 객체 기능 자체를 포장해서 지연실행시킨다.</strong>
</li>
      <li><strong><code class="language-plaintext highlighter-rouge">객체 기능 위임 -&gt; 위임한 객체의 메서드 파라미터</code>로 들어온다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810175507565.png" alt="image-20220810175507565"></p>
  </li>
</ol>

<h3 id="커맨드홀더객체---기능-위임받을-객체를-소유해서-래핑하는-구상클래스를-만들며-모든-기능을-래핑하기-위해-위임객체composite의-내장을-다-복사해온다">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4---%EA%B8%B0%EB%8A%A5-%EC%9C%84%EC%9E%84%EB%B0%9B%EC%9D%84-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%86%8C%EC%9C%A0%ED%95%B4%EC%84%9C-%EB%9E%98%ED%95%91%ED%95%98%EB%8A%94-%EA%B5%AC%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A5%BC-%EB%A7%8C%EB%93%A4%EB%A9%B0-%EB%AA%A8%EB%93%A0-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EB%9E%98%ED%95%91%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%B4-%EC%9C%84%EC%9E%84%EA%B0%9D%EC%B2%B4composite%EC%9D%98-%EB%82%B4%EC%9E%A5%EC%9D%84-%EB%8B%A4-%EB%B3%B5%EC%82%AC%ED%95%B4%EC%98%A8%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드홀더객체 -&gt; [기능 위임받을 객체를 소유]해서 래핑하는 구상클래스를 만들며, [모든 기능을 래핑]하기 위해, 위임객체Composite의 내장을 다 복사해온다.</h3>

<h4 id="상속없이-특정객체의-기능을-위임하려면-필드로-소유---내장복사---래핑하는-방법-밖이다">
<a class="anchor" href="#%EC%83%81%EC%86%8D%EC%97%86%EC%9D%B4-%ED%8A%B9%EC%A0%95%EA%B0%9D%EC%B2%B4%EC%9D%98-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EC%9C%84%EC%9E%84%ED%95%98%EB%A0%A4%EB%A9%B4-%ED%95%84%EB%93%9C%EB%A1%9C-%EC%86%8C%EC%9C%A0---%EB%82%B4%EC%9E%A5%EB%B3%B5%EC%82%AC---%EB%9E%98%ED%95%91%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EB%B0%96%EC%9D%B4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>상속없이 특정객체의 기능을 위임하려면, 필드로 소유 -&gt; 내장복사 -&gt; 래핑하는 방법 밖이다</h4>

<ol>
  <li>
    <p>커맨드홀더 객체는 <strong>기능위임객체를 소유</strong>해서 래핑하고 있다.
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810175831733.png" alt="image-20220810175831733"></p>
  </li>
  <li>
    <p><strong>모든 기능을 위임받기 위해, <code class="language-plaintext highlighter-rouge">소유객체의 내장을 모두 복사</code>해서 가져온다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/dbabd3f0-fd62-4e4b-9ce9-51931040e0f4.gif" alt="dbabd3f0-fd62-4e4b-9ce9-51931040e0f4"></p>
  </li>
</ol>

<h3 id="소유객체-기능복사후-내장을-정리한다">
<a class="anchor" href="#%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4-%EA%B8%B0%EB%8A%A5%EB%B3%B5%EC%82%AC%ED%9B%84-%EB%82%B4%EC%9E%A5%EC%9D%84-%EC%A0%95%EB%A6%AC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>소유객체 기능복사후 내장을 정리한다</h3>

<h4 id="01-소유객체-기능-래핑을-위한-내장복사후-필드는-소유객체-빼고-다-삭제--생성자-이름-수정부터-한다">
<a class="anchor" href="#01-%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4-%EA%B8%B0%EB%8A%A5-%EB%9E%98%ED%95%91%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%82%B4%EC%9E%A5%EB%B3%B5%EC%82%AC%ED%9B%84-%ED%95%84%EB%93%9C%EB%8A%94-%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4-%EB%B9%BC%EA%B3%A0-%EB%8B%A4-%EC%82%AD%EC%A0%9C--%EC%83%9D%EC%84%B1%EC%9E%90-%EC%9D%B4%EB%A6%84-%EC%88%98%EC%A0%95%EB%B6%80%ED%84%B0-%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>01 소유객체 기능 래핑을 위한 내장복사후 [필드는 소유객체 빼고 다 삭제] + [생성자 이름 수정]부터 한다.</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/25d509ee-d289-47a6-b893-39745a5e68d5.gif" alt="25d509ee-d289-47a6-b893-39745a5e68d5"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810180242725.png" alt="image-20220810180242725"></p>

<h4 id="02--기능의-command화-대상들인-상태변화-set계열-메서드들은-일단-두고-getter계열만-소유객체를-통해-래핑한다">
<a class="anchor" href="#02--%EA%B8%B0%EB%8A%A5%EC%9D%98-command%ED%99%94-%EB%8C%80%EC%83%81%EB%93%A4%EC%9D%B8-%EC%83%81%ED%83%9C%EB%B3%80%ED%99%94-set%EA%B3%84%EC%97%B4-%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4%EC%9D%80-%EC%9D%BC%EB%8B%A8-%EB%91%90%EA%B3%A0-getter%EA%B3%84%EC%97%B4%EB%A7%8C-%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%9E%98%ED%95%91%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>02  기능의 command화 대상들인 [상태변화 set계열] 메서드들은 일단 두고, [getter계열만 소유객체를 통해 래핑]한다.</h4>

<h5 id="getter는-제공기능이므로-행위가-아니다---행위를-캡슐화하여-지연실행하는-커맨드객체-대상이-아니다">
<a class="anchor" href="#getter%EB%8A%94-%EC%A0%9C%EA%B3%B5%EA%B8%B0%EB%8A%A5%EC%9D%B4%EB%AF%80%EB%A1%9C-%ED%96%89%EC%9C%84%EA%B0%80-%EC%95%84%EB%8B%88%EB%8B%A4---%ED%96%89%EC%9C%84%EB%A5%BC-%EC%BA%A1%EC%8A%90%ED%99%94%ED%95%98%EC%97%AC-%EC%A7%80%EC%97%B0%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4-%EB%8C%80%EC%83%81%EC%9D%B4-%EC%95%84%EB%8B%88%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>getter는 제공기능이므로, 행위가 아니다. -&gt; 행위를 캡슐화하여 지연실행하는 커맨드객체 대상이 아니다</h5>

<ul>
  <li><strong>어떤 객체에 대해 <code class="language-plaintext highlighter-rouge">상속없이 기능 위임</code>하는 방법은 <code class="language-plaintext highlighter-rouge">소유한 뒤, 래핑하면서 위임</code>하는 방법밖이다.</strong></li>
  <li>
<code class="language-plaintext highlighter-rouge">return 필드</code> -&gt; <code class="language-plaintext highlighter-rouge">return 소유객체.get필드()</code>
</li>
  <li>
    <p>getter가 파라미터가 있다면 -&gt; 소유객체.getter(파라미터)를 넣어주면 된다.</p>
  </li>
  <li>
    <p><strong>getter내부가 복잡해도, 해당 메서드이이름만 보고 -&gt; <code class="language-plaintext highlighter-rouge">소유객체.해당메서드()</code>로 만들자.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810181141278.png" alt="image-20220810181141278"></p>

    <p>​	<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810181119901.png" alt="image-20220810181119901"></p>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/3e660f7b-654e-4ffe-a8f1-f937ace560ab.gif" alt="3e660f7b-654e-4ffe-a8f1-f937ace560ab"></p>

<ul>
  <li>
    <p>getter래핑이 끝나면, 맨 밑으로 내려놓자</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810181224648.png" alt="image-20220810181224648"></p>
  </li>
</ul>

<h3 id="커맨드화-대상인-setter계열-메서드의-실행시점-위임하기">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%94-%EB%8C%80%EC%83%81%EC%9D%B8-setter%EA%B3%84%EC%97%B4-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%EC%8B%A4%ED%96%89%EC%8B%9C%EC%A0%90-%EC%9C%84%EC%9E%84%ED%95%98%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드화 대상인 setter계열 메서드의 [실행시점] 위임하기</h3>

<h4 id="새로운-객체인-command객체를-만들고-커맨드홀더-객체가-소유객체-래핑해서-실행하는-책임을-다시-한번-커맨드객체에서-실행하도록-실행시점을-위임한다">
<a class="anchor" href="#%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B0%9D%EC%B2%B4%EC%9D%B8-command%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%A7%8C%EB%93%A4%EA%B3%A0-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94-%EA%B0%9D%EC%B2%B4%EA%B0%80-%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4-%EB%9E%98%ED%95%91%ED%95%B4%EC%84%9C-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EC%B1%85%EC%9E%84%EC%9D%84-%EB%8B%A4%EC%8B%9C-%ED%95%9C%EB%B2%88-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%ED%95%98%EB%8F%84%EB%A1%9D-%EC%8B%A4%ED%96%89%EC%8B%9C%EC%A0%90%EC%9D%84-%EC%9C%84%EC%9E%84%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>새로운 객체인 command객체를 만들고, 커맨드홀더 객체가 [소유객체 래핑해서 실행]하는 책임을, 다시 한번 [커맨드객체에서 실행]하도록 [실행시점]을 위임한다</h4>

<h4 id="01-execute와-undo가-같아-제일-쉬운-set계열-toggle커맨드객체부터-만들어보자">
<a class="anchor" href="#01-execute%EC%99%80-undo%EA%B0%80-%EA%B0%99%EC%95%84-%EC%A0%9C%EC%9D%BC-%EC%89%AC%EC%9A%B4-set%EA%B3%84%EC%97%B4-toggle%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EB%B6%80%ED%84%B0-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>01 execute와 undo가 같아 제일 쉬운 set계열 toggle커맨드객체부터 만들어보자.</h4>

<ol>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">소유객체의 set계열 메서드 실행</code>의 위임받을 커맨드객체는, 커맨드 인터페이스를 구현해서 생성한다.</strong></p>

    <ul>
      <li>정해진 메서드로만 위임할 것이다.</li>
      <li>
        <p><strong>특정메서드의 실행위임은</strong>  <strong>파라미터로 원래 기능객체가 가서 실행되는 것으로</strong>위임된다.</p>
      </li>
      <li>
<strong>위임될 행위는, 파라미터로 같이 가는 이상, <code class="language-plaintext highlighter-rouge">해당객체.이미정해진 기능()</code>으로 실행된다.</strong>
        <ul>
          <li>따라서 따로 구현하거나 하지 않는다.</li>
        </ul>
      </li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/95c5d03a-00f1-44d2-b642-f8e701be0907.gif" alt="95c5d03a-00f1-44d2-b642-f8e701be0907"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810182500894.png" alt="image-20220810182500894"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810182720508.png" alt="image-20220810182720508"></p>
  </li>
</ol>

<h3 id="커맨드홀더객체는-소유객체의-실행을-커맨드객체에게-위임하되--커맨드-객체-내부-생성후-커맨드객체-위임-실행함으로써-지연실행-주체인-커맨드객체-자체를-실행전-컬렉션-필드에-저장할-수-있다">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4%EB%8A%94-%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%8B%A4%ED%96%89%EC%9D%84-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EC%97%90%EA%B2%8C-%EC%9C%84%EC%9E%84%ED%95%98%EB%90%98--%EC%BB%A4%EB%A7%A8%EB%93%9C-%EA%B0%9D%EC%B2%B4-%EB%82%B4%EB%B6%80-%EC%83%9D%EC%84%B1%ED%9B%84-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4-%EC%9C%84%EC%9E%84-%EC%8B%A4%ED%96%89%ED%95%A8%EC%9C%BC%EB%A1%9C%EC%8D%A8-%EC%A7%80%EC%97%B0%EC%8B%A4%ED%96%89-%EC%A3%BC%EC%B2%B4%EC%9D%B8-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4-%EC%9E%90%EC%B2%B4%EB%A5%BC-%EC%8B%A4%ED%96%89%EC%A0%84-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%95%84%EB%93%9C%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드홀더객체는, 소유객체의 실행을 커맨드객체에게 위임하되  [커맨드 객체 내부 생성]후 [커맨드객체 위임 실행]함으로써, [지연실행 주체인 커맨드객체 자체]를 [실행전 컬렉션 필드에 저장]할 수 있다.</h3>

<h4 id="undoredo는-지연실행-주체인-커맨드객체를-컬렉션-필드에-저장해놓기-때문에-execute한-주체를-다시-불러와서-undo할-수-있게-된다-커맨드홀더객체가-커맨드객체들-외부저장소list필드-역할을-한다">
<a class="anchor" href="#undoredo%EB%8A%94-%EC%A7%80%EC%97%B0%EC%8B%A4%ED%96%89-%EC%A3%BC%EC%B2%B4%EC%9D%B8-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%95%84%EB%93%9C%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%B4%EB%86%93%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%97%90-execute%ED%95%9C-%EC%A3%BC%EC%B2%B4%EB%A5%BC-%EB%8B%A4%EC%8B%9C-%EB%B6%88%EB%9F%AC%EC%99%80%EC%84%9C-undo%ED%95%A0-%EC%88%98-%EC%9E%88%EA%B2%8C-%EB%90%9C%EB%8B%A4-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4%EA%B0%80-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EB%93%A4-%EC%99%B8%EB%B6%80%EC%A0%80%EC%9E%A5%EC%86%8Clist%ED%95%84%EB%93%9C-%EC%97%AD%ED%95%A0%EC%9D%84-%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>undo/redo는 지연실행 주체인 [커맨드객체]를 컬렉션 필드에 저장해놓기 때문에, execute한 주체를 다시 불러와서 undo할 수 있게 된다. 커맨드홀더객체가 [커맨드객체들 외부저장소(List필드)] 역할을 한다</h4>

<ol>
  <li>
    <p>커맨드객체를 내부생성후, 실행 전 저장하는데, 컬렉션필드 생성후 한참 뒤에 add되므로 <strong>빈컬렉션 + set/add메서드가 필수다</strong></p>

    <ul>
      <li>
        <p><strong>이 때, Set이 아닌 <code class="language-plaintext highlighter-rouge">List를 외부저장소로 채택</code>하여, <code class="language-plaintext highlighter-rouge">차후 마지막 꺼만 or 커서도입 or 짝수만 등</code>의 형태로 command를 뽑아 쓸 수 있게 한다</strong></p>
      </li>
      <li>
        <p><strong>외부에서 add하는게 아니라, 내부에서 요소 생성후 add하니까, setter메서드는 현재 필요없다</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/3f5595a6-76a4-4c34-a6ef-f9cbfed6030f.gif" alt="3f5595a6-76a4-4c34-a6ef-f9cbfed6030f"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810183432914.png" alt="image-20220810183432914"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810183442992.png" alt="image-20220810183442992"></p>
      </li>
    </ul>
  </li>
</ol>

<h4 id="모든-set계열메서드들은-커맨드객체에-실행시점위임으로서-해당-커맨드객체생성---외부저장소에-저장---실행한다-이-때-추상체변수cmd의-add---cmdexecute는-반복된다-내수용-addcommand메서드를-만들고-반복사용하도록-하자">
<a class="anchor" href="#%EB%AA%A8%EB%93%A0-set%EA%B3%84%EC%97%B4%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4%EC%9D%80-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EC%97%90-%EC%8B%A4%ED%96%89%EC%8B%9C%EC%A0%90%EC%9C%84%EC%9E%84%EC%9C%BC%EB%A1%9C%EC%84%9C-%ED%95%B4%EB%8B%B9-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EC%83%9D%EC%84%B1---%EC%99%B8%EB%B6%80%EC%A0%80%EC%9E%A5%EC%86%8C%EC%97%90-%EC%A0%80%EC%9E%A5---%EC%8B%A4%ED%96%89%ED%95%9C%EB%8B%A4-%EC%9D%B4-%EB%95%8C-%EC%B6%94%EC%83%81%EC%B2%B4%EB%B3%80%EC%88%98cmd%EC%9D%98-add---cmdexecute%EB%8A%94-%EB%B0%98%EB%B3%B5%EB%90%9C%EB%8B%A4-%EB%82%B4%EC%88%98%EC%9A%A9-addcommand%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EA%B3%A0-%EB%B0%98%EB%B3%B5%EC%82%AC%EC%9A%A9%ED%95%98%EB%8F%84%EB%A1%9D-%ED%95%98%EC%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>모든 set계열메서드들은 커맨드객체에 실행시점위임으로서 해당 커맨드객체생성 -&gt; 외부저장소에 저장 -&gt; 실행한다. 이 때, [추상체변수cmd의 add -&gt; cmd.execute]는 반복된다. 내수용 addCommand()메서드를 만들고, 반복사용하도록 하자.</h4>

<ul>
  <li>
<strong>공통필드</strong>외에  <strong>추상체변수 호출의 반복</strong> 또한 반복되는 코드라서 내수용메서드로 추출해야한다.</li>
</ul>

<p><img src="../../../AppData/Local/Temp/127d319e-adc3-406c-8bf3-a64544878491.gif" alt="127d319e-adc3-406c-8bf3-a64544878491"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810183915693.png" alt="image-20220810183915693"></p>

<h4 id="이제부터-매-set메서드들의-커맨드화할-때마다-addcommand를-통해-저장--실행까지-한다">
<a class="anchor" href="#%EC%9D%B4%EC%A0%9C%EB%B6%80%ED%84%B0-%EB%A7%A4-set%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4%EC%9D%98-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%94%ED%95%A0-%EB%95%8C%EB%A7%88%EB%8B%A4-addcommand%EB%A5%BC-%ED%86%B5%ED%95%B4-%EC%A0%80%EC%9E%A5--%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80-%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>이제부터 <code class="language-plaintext highlighter-rouge">매 set메서드들의 커맨드화</code>할 때마다 addCommand()를 통해 <code class="language-plaintext highlighter-rouge">저장 + 실행</code>까지 한다.</strong>
</h4>

<h3 id="커맨드-홀더-소유객체는-메서드인자를-통한-를-기억해서-사용-안해도될까">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C-%ED%99%80%EB%8D%94-%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%B8%EC%9E%90%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%A5%BC-%EA%B8%B0%EC%96%B5%ED%95%B4%EC%84%9C-%EC%82%AC%EC%9A%A9-%EC%95%88%ED%95%B4%EB%8F%84%EB%90%A0%EA%B9%8C" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드 홀더 소유객체는 [메서드인자를 통한 를 기억해서 사용] 안해도될까?호출&gt;</h3>

<ul>
  <li>
    <p><strong>아래와 같이 소유객체는 <code class="language-plaintext highlighter-rouge">호출당시 context</code>를 안받아도 될까?</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/3691e182-295a-4989-9a42-ea58a1c3848c.gif" alt="3691e182-295a-4989-9a42-ea58a1c3848c"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810190305204.png" alt="image-20220810190305204"></p>
  </li>
</ul>

<h4 id="현재-모든-set계열메서드마다-필드소유객체-compositemenu를-호출메서드의-파라미터가-아니라-내부context필드로서-반복-사용하고-있다">
<a class="anchor" href="#%ED%98%84%EC%9E%AC-%EB%AA%A8%EB%93%A0-set%EA%B3%84%EC%97%B4%EB%A9%94%EC%84%9C%EB%93%9C%EB%A7%88%EB%8B%A4-%ED%95%84%EB%93%9C%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4-compositemenu%EB%A5%BC-%ED%98%B8%EC%B6%9C%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC-%EB%82%B4%EB%B6%80context%ED%95%84%EB%93%9C%EB%A1%9C%EC%84%9C-%EB%B0%98%EB%B3%B5-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B3%A0-%EC%9E%88%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>현재 모든 set계열메서드마다 [필드소유객체 CompositeMenu]를 [호출메서드의 파라미터]가 아니라 [내부context필드로서 반복 사용]하고 있다</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810190651777.png" alt="image-20220810190651777"></p>

<h5 id="행위-위임을-위한-메서드위임당할-객체는-파라미터로가-아닐-때-파라미터로-받을-필요없이-내부context를-재활용해도-되는-객체는-절대-상태변화가-없는-final-불변객체만-가능하다">
<a class="anchor" href="#%ED%96%89%EC%9C%84-%EC%9C%84%EC%9E%84%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9C%84%EC%9E%84%EB%8B%B9%ED%95%A0-%EA%B0%9D%EC%B2%B4%EB%8A%94-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A1%9C%EA%B0%80-%EC%95%84%EB%8B%90-%EB%95%8C-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A1%9C-%EB%B0%9B%EC%9D%84-%ED%95%84%EC%9A%94%EC%97%86%EC%9D%B4-%EB%82%B4%EB%B6%80context%EB%A5%BC-%EC%9E%AC%ED%99%9C%EC%9A%A9%ED%95%B4%EB%8F%84-%EB%90%98%EB%8A%94-%EA%B0%9D%EC%B2%B4%EB%8A%94-%EC%A0%88%EB%8C%80-%EC%83%81%ED%83%9C%EB%B3%80%ED%99%94%EA%B0%80-%EC%97%86%EB%8A%94-final-%EB%B6%88%EB%B3%80%EA%B0%9D%EC%B2%B4%EB%A7%8C-%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>행위 위임을 위한 메서드(위임당할 객체는 파라미터로)가 아닐 때, 파라미터로 받을 필요없이 내부context를 재활용해도 되는 객체는? [절대 상태변화가 없는 final 불변객체]만 가능하다</h5>

<ol>
  <li>내부context라도 <strong>setter등으로 상태변화하는 객체</strong>는 <strong>상태 확인후 사용</strong>해야하지만, <strong>상태확인 없이 내부context를 재활용해도 되는 객체는 <code class="language-plaintext highlighter-rouge">final이 붙어서, context생성 당시, 생성자로만 받고 난 뒤, 아예 변할일이 없는 필드</code>만 가능하다.</strong>
</li>
</ol>

<h4 id="command홀더-클래스는-래핑할-소유객체를-final불변으로-유지하여-어떤-커맨드객체에서든-똑같이-작동하도록-한다">
<a class="anchor" href="#command%ED%99%80%EB%8D%94-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EB%9E%98%ED%95%91%ED%95%A0-%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4%EB%A5%BC-final%EB%B6%88%EB%B3%80%EC%9C%BC%EB%A1%9C-%EC%9C%A0%EC%A7%80%ED%95%98%EC%97%AC-%EC%96%B4%EB%96%A4-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EC%97%90%EC%84%9C%EB%93%A0-%EB%98%91%EA%B0%99%EC%9D%B4-%EC%9E%91%EB%8F%99%ED%95%98%EB%8F%84%EB%A1%9D-%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>command홀더 클래스는, 래핑할 소유객체를 final불변으로 유지하여, 어떤 커맨드객체에서든 똑같이 작동하도록 한다</h4>

<ol>
  <li>
    <p>final 필드 -&gt; 생성자 주입 받도록 수정한다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/050bd901-b2c2-4755-801d-9b4653a82a26.gif" alt="050bd901-b2c2-4755-801d-9b4653a82a26"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810191230273.png" alt="image-20220810191230273"></p>
  </li>
</ol>

<h3 id="command홀더는-소유객체를-대신해서-외부에서-생성---활용될-것이므로-소유객체-생성자-파라미터값을-받아-필드-채우는를-그대로-유지하며-소유객체를-내부-생성한다">
<a class="anchor" href="#command%ED%99%80%EB%8D%94%EB%8A%94-%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%8C%80%EC%8B%A0%ED%95%B4%EC%84%9C-%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-%EC%83%9D%EC%84%B1---%ED%99%9C%EC%9A%A9%EB%90%A0-%EA%B2%83%EC%9D%B4%EB%AF%80%EB%A1%9C-%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EA%B0%92%EC%9D%84-%EB%B0%9B%EC%95%84-%ED%95%84%EB%93%9C-%EC%B1%84%EC%9A%B0%EB%8A%94%EB%A5%BC-%EA%B7%B8%EB%8C%80%EB%A1%9C-%EC%9C%A0%EC%A7%80%ED%95%98%EB%A9%B0-%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%82%B4%EB%B6%80-%EC%83%9D%EC%84%B1%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>Command홀더는 소유객체를 대신해서 외부에서 생성 -&gt; 활용될 것이므로 소유객체 생성자 파라미터(값을 받아 필드 채우는)를 그대로 유지하며, 소유객체를 내부 생성한다</h3>

<h4 id="command홀더객체를-도입하는-순간부터-기존-composite객체는-외부에서-사용안된다-command홀더내에서-소유객체composite객체를-생성한다-생성자-내장을-그대로-활용한다">
<a class="anchor" href="#command%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%8F%84%EC%9E%85%ED%95%98%EB%8A%94-%EC%88%9C%EA%B0%84%EB%B6%80%ED%84%B0-%EA%B8%B0%EC%A1%B4-composite%EA%B0%9D%EC%B2%B4%EB%8A%94-%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%EC%95%88%EB%90%9C%EB%8B%A4-command%ED%99%80%EB%8D%94%EB%82%B4%EC%97%90%EC%84%9C-%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4composite%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%83%9D%EC%84%B1%ED%95%9C%EB%8B%A4-%EC%83%9D%EC%84%B1%EC%9E%90-%EB%82%B4%EC%9E%A5%EC%9D%84-%EA%B7%B8%EB%8C%80%EB%A1%9C-%ED%99%9C%EC%9A%A9%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>command홀더객체를 도입하는 순간부터, 기존 Composite객체는 외부에서 사용안된다. command홀더내에서 소유객체composite객체를 생성한다. 생성자 내장을 그대로 활용한다</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/bc49ab22-2ae2-4910-a7d8-cd8ed8ce4108.gif" alt="bc49ab22-2ae2-4910-a7d8-cd8ed8ce4108"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810191550687.png" alt="image-20220810191550687"></p>

<h3 id="모든-상태변화메서드-settersettitle-등를-커맨드화-한다">
<a class="anchor" href="#%EB%AA%A8%EB%93%A0-%EC%83%81%ED%83%9C%EB%B3%80%ED%99%94%EB%A9%94%EC%84%9C%EB%93%9C-settersettitle-%EB%93%B1%EB%A5%BC-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%94-%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>모든 상태변화메서드 setter(setTitle 등)를 커맨드화 한다</h3>

<h4 id="정해진-인터페이스의-구상클래스가-기능을-위임받을-땐-필요한-외부정보를-메서드로부터-받지못하니-생성자를-통한-필드로-context를-기억해놔야한다">
<a class="anchor" href="#%EC%A0%95%ED%95%B4%EC%A7%84-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EA%B5%AC%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EA%B0%80-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EC%9C%84%EC%9E%84%EB%B0%9B%EC%9D%84-%EB%95%90-%ED%95%84%EC%9A%94%ED%95%9C-%EC%99%B8%EB%B6%80%EC%A0%95%EB%B3%B4%EB%A5%BC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C%EB%B6%80%ED%84%B0-%EB%B0%9B%EC%A7%80%EB%AA%BB%ED%95%98%EB%8B%88-%EC%83%9D%EC%84%B1%EC%9E%90%EB%A5%BC-%ED%86%B5%ED%95%9C-%ED%95%84%EB%93%9C%EB%A1%9C-context%EB%A5%BC-%EA%B8%B0%EC%96%B5%ED%95%B4%EB%86%94%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>정해진 인터페이스의 구상클래스가 기능을 위임받을 땐, 필요한 외부정보를 메서드로부터 받지못하니, 생성자를 통한 필드로 context를 기억해놔야한다.</h4>

<h4 id="02-settitle-커맨드화">
<a class="anchor" href="#02-settitle-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%94" aria-hidden="true"><span class="octicon octicon-link"></span></a>02 setTitle 커맨드화</h4>

<ol>
  <li>
    <p>커맨드객체를 인터페이스 구현후 생성한다.</p>
  </li>
  <li>
    <p>외부저장소add 후 exexcute해주는 addCommand( ) 메서드에 cmd객체를 넣어준다.</p>
  </li>
  <li>
    <p><strong>이 때,  오퍼레이터 execute에 필요한 외부 정보는, 구상클래스로서 생성자-&gt;필드로 기억해서 내부에서 사용한다</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/1ec01558-9ee0-4828-ba0c-64116ec83330.gif" alt="1ec01558-9ee0-4828-ba0c-64116ec83330"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810192428138.png" alt="image-20220810192428138"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810192509540.png" alt="image-20220810192509540"></p>
  </li>
</ol>

<h3 id="undo의-비밀은-구상-커맨드객체에-메서드인자로-들어가는-실행위임했다면-execute직전의-context를-getter로-가져와-객체-내부필드에-저장set해놓아서-undo시-불러와-사용하여-counter칠-수-있다">
<a class="anchor" href="#undo%EC%9D%98-%EB%B9%84%EB%B0%80%EC%9D%80-%EA%B5%AC%EC%83%81-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EC%97%90-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%B8%EC%9E%90%EB%A1%9C-%EB%93%A4%EC%96%B4%EA%B0%80%EB%8A%94-%EC%8B%A4%ED%96%89%EC%9C%84%EC%9E%84%ED%96%88%EB%8B%A4%EB%A9%B4-execute%EC%A7%81%EC%A0%84%EC%9D%98-context%EB%A5%BC-getter%EB%A1%9C-%EA%B0%80%EC%A0%B8%EC%99%80-%EA%B0%9D%EC%B2%B4-%EB%82%B4%EB%B6%80%ED%95%84%EB%93%9C%EC%97%90-%EC%A0%80%EC%9E%A5set%ED%95%B4%EB%86%93%EC%95%84%EC%84%9C-undo%EC%8B%9C-%EB%B6%88%EB%9F%AC%EC%99%80-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-counter%EC%B9%A0-%EC%88%98-%EC%9E%88%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>undo의 비밀은? 구상 커맨드[객체]에 [메서드인자로 들어가는 실행위임]했다면, [execute직전의 context를 getter로 가져와 객체 내부필드에 저장(set)]해놓아서, [undo시 불러와 사용]하여 counter칠 수 있다.</h3>

<h4 id="커맨드객체라는-새로운-구상class에-위임하게-되면-당시context를-필드로-기억할-수-있다">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EB%9D%BC%EB%8A%94-%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B5%AC%EC%83%81class%EC%97%90-%EC%9C%84%EC%9E%84%ED%95%98%EA%B2%8C-%EB%90%98%EB%A9%B4-%EB%8B%B9%EC%8B%9Ccontext%EB%A5%BC-%ED%95%84%EB%93%9C%EB%A1%9C-%EA%B8%B0%EC%96%B5%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드객체라는 새로운 구상class에 위임하게 되면, 당시context를 필드로 기억할 수 있다.</h4>

<h3 id="단순-setter의-undo-execute직전에-getter를-통해-당시context를-가져와-내부필드oldxxxx를-이용해서-old값으로-다시-setter한다">
<a class="anchor" href="#%EB%8B%A8%EC%88%9C-setter%EC%9D%98-undo-execute%EC%A7%81%EC%A0%84%EC%97%90-getter%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%8B%B9%EC%8B%9Ccontext%EB%A5%BC-%EA%B0%80%EC%A0%B8%EC%99%80-%EB%82%B4%EB%B6%80%ED%95%84%EB%93%9Coldxxxx%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4%EC%84%9C-old%EA%B0%92%EC%9C%BC%EB%A1%9C-%EB%8B%A4%EC%8B%9C-setter%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>단순 setter의 undo: execute직전에 getter를 통해 당시context를 가져와 내부필드(oldXXXX)를 이용해서 [old값으로 다시 setter]한다.</h3>

<ol>
  <li>
    <p><strong>execute당시의 context를 필드에 박아 기억</strong>해둔다</p>

    <ul>
      <li>필드명은 <code class="language-plaintext highlighter-rouge">oldXXX</code>로 지으면 된다.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/1311f28a-8c62-46d3-8ab4-f02b7fd7d646.gif" alt="1311f28a-8c62-46d3-8ab4-f02b7fd7d646"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810221534099.png" alt="image-20220810221534099"></p>
  </li>
</ol>

<h4 id="03-setdate-등-나머지-단순setter-커맨드화">
<a class="anchor" href="#03-setdate-%EB%93%B1-%EB%82%98%EB%A8%B8%EC%A7%80-%EB%8B%A8%EC%88%9Csetter-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%94" aria-hidden="true"><span class="octicon octicon-link"></span></a>03 setDate 등 나머지 단순Setter 커맨드화</h4>

<ol>
  <li>
    <p>setTitle클래스를 복사해서 만들면 쉽다.</p>
  </li>
  <li>
    <p>execute당시 필요한 context들은 위임객체(커맨드객체)의 생성자로 주입해서 박아둔다</p>
  </li>
  <li>
    <p><strong>execute직전</strong> 바뀌기 전 old context는 getter로 불러와서 필드로 주입해서 기억해놓는다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/e192c4f6-a2dc-4ea3-9f69-4d49b5290547.gif" alt="e192c4f6-a2dc-4ea3-9f69-4d49b5290547"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810222231170.png" alt="image-20220810222231170"></p>
  </li>
</ol>

<h3 id="add의-undo-원본메서드에서-컬렉션에-add된-객체를-반환하도록-해야--저장-후-undo를-칠-수-있다">
<a class="anchor" href="#add%EC%9D%98-undo-%EC%9B%90%EB%B3%B8%EB%A9%94%EC%84%9C%EB%93%9C%EC%97%90%EC%84%9C-%EC%BB%AC%EB%A0%89%EC%85%98%EC%97%90-add%EB%90%9C-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%98%EB%8F%84%EB%A1%9D-%ED%95%B4%EC%95%BC--%EC%A0%80%EC%9E%A5-%ED%9B%84-undo%EB%A5%BC-%EC%B9%A0-%EC%88%98-%EC%9E%88%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>add의 undo: 원본메서드에서 컬렉션에 add된 객체를 반환하도록 해야,  저장 후 undo를 칠 수 있다.</h3>

<h4 id="일단-04-add-execute만들기">
<a class="anchor" href="#%EC%9D%BC%EB%8B%A8-04-add-execute%EB%A7%8C%EB%93%A4%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>일단 04 add execute만들기</h4>

<ol>
  <li>
    <p>인터페이스 구현 Add 커맨드객체 생성</p>
  </li>
  <li>
    <p>addCommand()를 태워서 외부저장소 add후 execute까지</p>

    <ul>
      <li>
        <p>기존 add메서드는 void add가 아니라 boolean add였지만, <strong>cmd.execute() 오퍼레이터는 반환값없이 다 void로 정의되어있어서 add래핑메서드는 boolean반환이 불가능해서 void로 바뀐다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/1bb28cb3-36eb-4ded-891e-a7990a7f7794.gif" alt="1bb28cb3-36eb-4ded-891e-a7990a7f7794"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810233349666.png" alt="image-20220810233349666"></p>

        <p>​	<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810233424073.png" alt="image-20220810233424073"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810233405626.png" alt="image-20220810233405626"></p>
      </li>
    </ul>
  </li>
</ol>

<h4 id="add의-undo는-실행-전-old값이-아닌-add될-내부생성객체가-필요하다">
<a class="anchor" href="#add%EC%9D%98-undo%EB%8A%94-%EC%8B%A4%ED%96%89-%EC%A0%84-old%EA%B0%92%EC%9D%B4-%EC%95%84%EB%8B%8C-add%EB%90%A0-%EB%82%B4%EB%B6%80%EC%83%9D%EC%84%B1%EA%B0%9D%EC%B2%B4%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%98%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>add의 undo는 실행 전 old값이 아닌, add될 내부생성객체가 필요하다</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810233819059.png" alt="image-20220810233819059"></p>

<h4 id="add메서드는-undo를-위해서라도-내부생성되어-내부컬렉션에-add될-객체를-반환를-해줘야한다">
<a class="anchor" href="#add%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-undo%EB%A5%BC-%EC%9C%84%ED%95%B4%EC%84%9C%EB%9D%BC%EB%8F%84-%EB%82%B4%EB%B6%80%EC%83%9D%EC%84%B1%EB%90%98%EC%96%B4-%EB%82%B4%EB%B6%80%EC%BB%AC%EB%A0%89%EC%85%98%EC%97%90-add%EB%90%A0-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%B0%98%ED%99%98%EB%A5%BC-%ED%95%B4%EC%A4%98%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>add메서드는 undo를 위해서라도 내부생성되어 내부컬렉션에 [add될 객체를 반환]를 해줘야한다.</h4>

<ul>
  <li>
    <p>내부에서 생성된 후 , add되는 만큼, <strong>해당 메서드에서 return해줘야 외부에서 가질 수 있다.</strong></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">public void add</code>로 만드는 컬렉션setter는 undo가 불가능하다고 생각하자.</p>
  </li>
</ul>

<ol>
  <li>
    <p>원래 기능을 가지는 compositemenu의 add메서드를 <strong>add되는 객체를 반환하도록 수정</strong>한다</p>
  </li>
  <li>
    <p><strong>커맨드객체는, execute시 반환되는 <code class="language-plaintext highlighter-rouge">undo용 add된객체</code>를 필드로 저장한다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/cb06a746-b4c5-48cc-bf58-7d1bf92fdbd8.gif" alt="cb06a746-b4c5-48cc-bf58-7d1bf92fdbd8"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810234237367.png" alt="image-20220810234237367"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810234307874.png" alt="image-20220810234307874"></p>
  </li>
  <li>
    <p><strong>저장된 add된 객체를 바탕으로 undo치면 된다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810234517422.png" alt="image-20220810234517422"></p>
  </li>
</ol>

<h3 id="remove의-undo-remove된-객체가-아니라-remove되기-전-객체의-필드정보들을-getter로-받아와야--저장-후-add할-수-있다">
<a class="anchor" href="#remove%EC%9D%98-undo-remove%EB%90%9C-%EA%B0%9D%EC%B2%B4%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC-remove%EB%90%98%EA%B8%B0-%EC%A0%84-%EA%B0%9D%EC%B2%B4%EC%9D%98-%ED%95%84%EB%93%9C%EC%A0%95%EB%B3%B4%EB%93%A4%EC%9D%84-getter%EB%A1%9C-%EB%B0%9B%EC%95%84%EC%99%80%EC%95%BC--%EC%A0%80%EC%9E%A5-%ED%9B%84-add%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>remove의 undo: remove된 객체가 아니라, [remove되기 전 객체의 필드정보들]을 [getter]로 받아와야,  저장 후 add할 수 있다.</h3>

<h4 id="05-remove-커맨드화">
<a class="anchor" href="#05-remove-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%94" aria-hidden="true"><span class="octicon octicon-link"></span></a>05 remove 커맨드화</h4>

<ul>
  <li>add의 undo는 내부생성된 객체를 필요로했지만</li>
  <li>
<strong>remove의 undo인 add는 <code class="language-plaintext highlighter-rouge">삭제 객체의 필드정보들</code>을 알아야 <code class="language-plaintext highlighter-rouge">내부생성</code>되도록 add할 수 있다.</strong>
    <ul>
      <li><strong>remove되면 해당 객체필드정보들을 얻을 수 없으니, <code class="language-plaintext highlighter-rouge">execute에서 객체 삭제전, 객체필드정보들을 미리 getter로 빼놓는다.</code></strong></li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/262e883f-e5f3-4101-9bbf-52796e2ad8df.gif" alt="262e883f-e5f3-4101-9bbf-52796e2ad8df"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220810235434224.png" alt="image-20220810235434224"></p>

<h3 id="생각해보기">
<a class="anchor" href="#%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>생각해보기</h3>

<h4 id="커맨드객체에는-2가지-종류의-기억필드를-가진다">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EC%97%90%EB%8A%94-2%EA%B0%80%EC%A7%80-%EC%A2%85%EB%A5%98%EC%9D%98-%EA%B8%B0%EC%96%B5%ED%95%84%EB%93%9C%EB%A5%BC-%EA%B0%80%EC%A7%84%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드객체에는 2가지 종류의 기억필드를 가진다.</h4>

<ol>
  <li>
<code class="language-plaintext highlighter-rouge">소유객체의 기능호출에 필요한 context</code>를 생성자 -&gt; 필드로 기억한다.</li>
  <li>
<code class="language-plaintext highlighter-rouge">execute당시의 context를 old계열</code>필드로 기억한다.</li>
  <li>만약, 커맨드객체에 위임안하고 undo를 한다면?
    <ul>
      <li>당시의 context들을 모두 set or 배열 컬렉션으로 기억해놓고, 순서대로 가져와서 쓴다.</li>
    </ul>
  </li>
  <li>하지만, <strong>하나의 객체를 만들어놓고, 거기다가 기능 위임(파라미터로 원본객체)하게 되면, <code class="language-plaintext highlighter-rouge">객체context로서 필드에 이름으로 저장</code>해놓고 뽑아 쓸 수 있다.</strong>
</li>
</ol>

<h4 id="커맨드객체로-굳이-기능행위를-한번-더-포장해서-써야하나-undoredo와-지연실행">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EB%A1%9C-%EA%B5%B3%EC%9D%B4-%EA%B8%B0%EB%8A%A5%ED%96%89%EC%9C%84%EB%A5%BC-%ED%95%9C%EB%B2%88-%EB%8D%94-%ED%8F%AC%EC%9E%A5%ED%95%B4%EC%84%9C-%EC%8D%A8%EC%95%BC%ED%95%98%EB%82%98-undoredo%EC%99%80-%EC%A7%80%EC%97%B0%EC%8B%A4%ED%96%89" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드객체로 굳이 기능(행위)를 한번 더 포장해서 써야하나? undo/redo와 지연실행</h4>

<ul>
  <li>위에 말한 것처럼, Closure와 같이, <strong>포장 객체 필드에 당시context를 기억</strong>할 수 있어서 <strong>undo, redo</strong>가 가능하다.</li>
  <li>
<strong>또한, 행위 포장객체를 이용하면, 지연실행이 가능해진다</strong>
    <ul>
      <li>addCommand()에는 외부저장소 add + execute를 묶어놨지만</li>
      <li><strong>따로 분리하여 add따로 / execute따로 가능하다</strong></li>
    </ul>
  </li>
</ul>

<h4 id="커맨드객체-외부저장소를-setcommand가-아닌-listcommand를-쓰는-이유">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4-%EC%99%B8%EB%B6%80%EC%A0%80%EC%9E%A5%EC%86%8C%EB%A5%BC-setcommand%EA%B0%80-%EC%95%84%EB%8B%8C-listcommand%EB%A5%BC-%EC%93%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드객체 외부저장소를 <code class="language-plaintext highlighter-rouge">Set&lt;Command&gt;</code>가 아닌 <code class="language-plaintext highlighter-rouge">List&lt;Command&gt;</code>를 쓰는 이유</h4>

<ul>
  <li>
    <p>보통 같으면 index가 없이 객체식별자로 구분하는 Set을 썼겠지만</p>
  </li>
  <li>
    <p><strong>List를 저장소로 채택하면 index(값context)를 이용해서 <code class="language-plaintext highlighter-rouge">짝수만/홀수만/원하는 갯수/ 마지막꺼만</code> 뽑아 쓸 수 있기 때문이다.</strong></p>

    <ul>
      <li><strong>Set은 마지막꺼만 뽑아 쓸 수 없어 undo를 할수 없다</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811005136048.png" alt="image-20220811005136048"></p>
  </li>
</ul>

<h4 id="지연실행포장객체에-위임의-장점">
<a class="anchor" href="#%EC%A7%80%EC%97%B0%EC%8B%A4%ED%96%89%ED%8F%AC%EC%9E%A5%EA%B0%9D%EC%B2%B4%EC%97%90-%EC%9C%84%EC%9E%84%EC%9D%98-%EC%9E%A5%EC%A0%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>지연실행(포장객체에 위임)의 장점</h4>

<ul>
  <li>지연실행이 안된다면, <strong>여러 행위 실행시, 반복문에서 무조건 행위를 호출해야만 한다</strong>
</li>
  <li><strong>지연실행 된다면, <code class="language-plaintext highlighter-rouge">반복문을 10번 돌더라도, 객체만 뽑아놓고, 나중에 행위호출</code>할 수 잇께 되어, <code class="language-plaintext highlighter-rouge">비동기 실행</code>이 가능해진다.</strong></li>
</ul>

<h3 id="커맨드홀더의-undo메서드미완성">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EC%9D%98-undo%EB%A9%94%EC%84%9C%EB%93%9C%EB%AF%B8%EC%99%84%EC%84%B1" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드홀더의 undo메서드(미완성)</h3>

<h4 id="지금까지는-커맨드홀더의-addcommand---cmd객체의-execute호출만-했고-cmd객체의-undo를-호출하지-않았다">
<a class="anchor" href="#%EC%A7%80%EA%B8%88%EA%B9%8C%EC%A7%80%EB%8A%94-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EC%9D%98-addcommand---cmd%EA%B0%9D%EC%B2%B4%EC%9D%98-execute%ED%98%B8%EC%B6%9C%EB%A7%8C-%ED%96%88%EA%B3%A0-cmd%EA%B0%9D%EC%B2%B4%EC%9D%98-undo%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%98%EC%A7%80-%EC%95%8A%EC%95%98%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>지금까지는 커맨드홀더의 addCommand() -&gt; cmd객체의 execute호출만 했고, cmd객체의 undo()를 호출하지 않았다.</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811005842037.png" alt="image-20220811005842037"></p>

<h4 id="addcommand와-달리-undo는-외부저장소list의-조회전-처럼-remove-전pop과-동일-존재검증을-해야한다">
<a class="anchor" href="#addcommand%EC%99%80-%EB%8B%AC%EB%A6%AC-undo%EB%8A%94-%EC%99%B8%EB%B6%80%EC%A0%80%EC%9E%A5%EC%86%8Clist%EC%9D%98-%EC%A1%B0%ED%9A%8C%EC%A0%84-%EC%B2%98%EB%9F%BC-remove-%EC%A0%84pop%EA%B3%BC-%EB%8F%99%EC%9D%BC-%EC%A1%B4%EC%9E%AC%EA%B2%80%EC%A6%9D%EC%9D%84-%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>addCommand와 달리 undo()는 외부저장소List의 (조회전 처럼) remove 전(pop과 동일) 존재검증을 해야한다.</h4>

<ul>
  <li>undo할 게 없으면 그냥 early return하고 끝내자 (원래는 thr)</li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811010028962.png" alt="image-20220811010028962"></p>

<ul>
  <li>
    <p>원래는 list에서 stack으로 pop을 해야하지만, <strong>java에서는 pop == remove(맨 마지막index)이다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811010406685.png" alt="image-20220811010406685"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811010434818.png" alt="image-20220811010434818"></p>

    <p><img src="../../../AppData/Roaming/Typora/typora-user-images/image-20220811010459328.png" alt="image-20220811010459328"></p>
  </li>
</ul>

<h3 id="커맨드홀더의-redo-undo시-외부저장소list에서-removepop로-날리지말고-cursor-도입">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EC%9D%98-redo-undo%EC%8B%9C-%EC%99%B8%EB%B6%80%EC%A0%80%EC%9E%A5%EC%86%8Clist%EC%97%90%EC%84%9C-removepop%EB%A1%9C-%EB%82%A0%EB%A6%AC%EC%A7%80%EB%A7%90%EA%B3%A0-cursor-%EB%8F%84%EC%9E%85" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드홀더의 redo: undo시 외부저장소(List)에서 remove(pop)로 날리지말고 Cursor 도입</h3>

<ul>
  <li>undo만 짠다면 외부저장소(List)에서 remove(size-1)로 pop하여 쉽게 짜여지지만,</li>
  <li>redo기능이 존재할 예정이라면, remove로 커맨드객체를 외부저장소List에서 바로 날리면 안된다.</li>
</ul>

<h4 id="외부저장소list의-index를-cursor로-도입하여-컬렉션-요소-날리지-않고-add-execute하기">
<a class="anchor" href="#%EC%99%B8%EB%B6%80%EC%A0%80%EC%9E%A5%EC%86%8Clist%EC%9D%98-index%EB%A5%BC-cursor%EB%A1%9C-%EB%8F%84%EC%9E%85%ED%95%98%EC%97%AC-%EC%BB%AC%EB%A0%89%EC%85%98-%EC%9A%94%EC%86%8C-%EB%82%A0%EB%A6%AC%EC%A7%80-%EC%95%8A%EA%B3%A0-add-execute%ED%95%98%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>외부저장소List의 index를 cursor로 도입하여, 컬렉션 요소 날리지 않고 add-execute하기</h4>

<ol>
  <li>
    <p>저장소List 필드에 대해 <strong>cursor의 위치도 항상 기억되어야하므로 <code class="language-plaintext highlighter-rouge">cursor대상 컬렉션 밑에 int cursor필드를 추가</code>한다.</strong></p>

    <ul>
      <li>
<strong>빈 컬렉션 시작이므로 <code class="language-plaintext highlighter-rouge">cursor를 0으로 초기화</code></strong>
        <ul>
          <li>원래 cursor 0은, 1개 아이템이 index 0에 들어가있는 상태이다.</li>
          <li><strong><code class="language-plaintext highlighter-rouge">원래라면 cursor를 -1 상태로 초기화</code>해야할 것 같다</strong></li>
          <li>어차피 cursor는 add시 add-execute시 size()-1로 마지막 위치로 업데이트될 것이다.</li>
        </ul>
      </li>
      <li>cursor는 바뀌는 것이니 not final</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811012311739.png" alt="image-20220811012311739"></p>
  </li>
</ol>

<h4 id="cursor는-대상컬렉션에-요소를-add할때마다-1씩-증가되어-맨마지막-index에-위치시킨다-컬렉션이-사용되는-곳ctrlf7-altf7-add기능이-있는-곳-등에서-cursor도-업데이트-로직을-추가한다">
<a class="anchor" href="#cursor%EB%8A%94-%EB%8C%80%EC%83%81%EC%BB%AC%EB%A0%89%EC%85%98%EC%97%90-%EC%9A%94%EC%86%8C%EB%A5%BC-add%ED%95%A0%EB%95%8C%EB%A7%88%EB%8B%A4-1%EC%94%A9-%EC%A6%9D%EA%B0%80%EB%90%98%EC%96%B4-%EB%A7%A8%EB%A7%88%EC%A7%80%EB%A7%89-index%EC%97%90-%EC%9C%84%EC%B9%98%EC%8B%9C%ED%82%A8%EB%8B%A4-%EC%BB%AC%EB%A0%89%EC%85%98%EC%9D%B4-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-%EA%B3%B3ctrlf7-altf7-add%EA%B8%B0%EB%8A%A5%EC%9D%B4-%EC%9E%88%EB%8A%94-%EA%B3%B3-%EB%93%B1%EC%97%90%EC%84%9C-cursor%EB%8F%84-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EB%A1%9C%EC%A7%81%EC%9D%84-%EC%B6%94%EA%B0%80%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>cursor는 대상컬렉션에 요소를 add할때마다 1씩 증가되어, 맨마지막 index에 위치시킨다. 컬렉션이 사용되는 곳(ctrl+F7, alt+F7, add기능이 있는 곳 등)에서 cursor도 업데이트 로직을 추가한다.</h4>

<ol>
  <li>
    <p>ctrl + F7로 컬렉션변수가 사용된 곳을 다 찾는다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811013204369.png" alt="image-20220811013204369"></p>
  </li>
  <li>
    <p><strong>add면 <code class="language-plaintext highlighter-rouge">add전 cursor++</code>, remove면  <code class="language-plaintext highlighter-rouge">remove전 cusror--;</code>업데이트를 해준다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/b61ce801-b9cb-41ac-8754-009770e28bf4.gif" alt="b61ce801-b9cb-41ac-8754-009770e28bf4"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811013254482.png" alt="image-20220811013254482"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811013305398.png" alt="image-20220811013305398"></p>
  </li>
</ol>

<h4 id="상태변화하는-컬렉션의-cursorvariant변수를-직접-상태변화하지말고-이미-변화한-연결-variant-필드컬렉션의-api를-이용한-불변식으로-관리해라">
<a class="anchor" href="#%EC%83%81%ED%83%9C%EB%B3%80%ED%99%94%ED%95%98%EB%8A%94-%EC%BB%AC%EB%A0%89%EC%85%98%EC%9D%98-cursorvariant%EB%B3%80%EC%88%98%EB%A5%BC-%EC%A7%81%EC%A0%91-%EC%83%81%ED%83%9C%EB%B3%80%ED%99%94%ED%95%98%EC%A7%80%EB%A7%90%EA%B3%A0-%EC%9D%B4%EB%AF%B8-%EB%B3%80%ED%99%94%ED%95%9C-%EC%97%B0%EA%B2%B0-variant-%ED%95%84%EB%93%9C%EC%BB%AC%EB%A0%89%EC%85%98%EC%9D%98-api%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B6%88%EB%B3%80%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EA%B4%80%EB%A6%AC%ED%95%B4%EB%9D%BC" aria-hidden="true"><span class="octicon octicon-link"></span></a>상태변화하는 컬렉션의 cursor(variant변수)를 직접 상태변화하지말고, 이미 변화한 연결 variant 필드(컬렉션)의 api를 이용한 불변식으로 관리해라</h4>

<ul>
  <li>직접 <code class="language-plaintext highlighter-rouge">++</code>으로 업데이트하면, 틀림없이 오류가 생긴다.</li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">상태변화 필연시 되는 variant 필드는, 원치않는 상태를 방지하는 불변식을 찾아서 불변식으로 재할당하여 업데이트</code>해야한다</strong>
    <ul>
      <li>List의 index는 제한범위가 있다. 직접 업데이트해서 if로 검사하지말고, 불변식을 찾아서 그것으로관리해야한다.</li>
    </ul>
  </li>
</ul>

<h4 id="add시-cursor를-마지막index로-업데이트는-add전에-하지말고-add후-바뀐-컬렉션으로-불변식을-만들어서-한다">
<a class="anchor" href="#add%EC%8B%9C-cursor%EB%A5%BC-%EB%A7%88%EC%A7%80%EB%A7%89index%EB%A1%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%8A%94-add%EC%A0%84%EC%97%90-%ED%95%98%EC%A7%80%EB%A7%90%EA%B3%A0-add%ED%9B%84-%EB%B0%94%EB%80%90-%EC%BB%AC%EB%A0%89%EC%85%98%EC%9C%BC%EB%A1%9C-%EB%B6%88%EB%B3%80%EC%8B%9D%EC%9D%84-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%84%9C-%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>add시 cursor를 마지막index로 업데이트는, add전에 하지말고, add후 바뀐 컬렉션으로 불변식을 만들어서 한다.</h4>

<ul>
  <li>앞으로 cursor의 업데이트는 add후 한다.
    <ul>
      <li><strong>add후에 컬렉션.size() - 1을 이용해 제일 마지막 index를 가리키게 한다.</strong></li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/a4103e47-b7d1-4ce7-ae50-3339826135ff.gif" alt="a4103e47-b7d1-4ce7-ae50-3339826135ff"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811015636305.png" alt="image-20220811015636305"></p>

<h3 id="cmd외부저장소-list는-stack역할으로서-방금-add-execute한-커맨드객체가-현재cursor--1-위치에-있어야한다-그래야-undocursor-1시-원래자리를-찾아올-수-있게-된다">
<a class="anchor" href="#cmd%EC%99%B8%EB%B6%80%EC%A0%80%EC%9E%A5%EC%86%8C-list%EB%8A%94-stack%EC%97%AD%ED%95%A0%EC%9C%BC%EB%A1%9C%EC%84%9C-%EB%B0%A9%EA%B8%88-add-execute%ED%95%9C-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EA%B0%80-%ED%98%84%EC%9E%ACcursor--1-%EC%9C%84%EC%B9%98%EC%97%90-%EC%9E%88%EC%96%B4%EC%95%BC%ED%95%9C%EB%8B%A4-%EA%B7%B8%EB%9E%98%EC%95%BC-undocursor-1%EC%8B%9C-%EC%9B%90%EB%9E%98%EC%9E%90%EB%A6%AC%EB%A5%BC-%EC%B0%BE%EC%95%84%EC%98%AC-%EC%88%98-%EC%9E%88%EA%B2%8C-%EB%90%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>cmd외부저장소 List는 stack(역할)으로서 방금 add-execute한 커맨드객체가 [현재cursor + 1] 위치에 있어야한다. 그래야 undo(cursor-1)시 원래자리를 찾아올 수 있게 된다.</h3>

<h4 id="add후-cursor를-컬렉션api로-마지막위치로-업데이트하는-상황에서-add-execute하여-list에-add될-객체가-현재cursor1위치에-이어야한다----add전-cursor1마지막요소들을-remove해서-날려놔야-add후-size-1이-마지막위치가-된다">
<a class="anchor" href="#add%ED%9B%84-cursor%EB%A5%BC-%EC%BB%AC%EB%A0%89%EC%85%98api%EB%A1%9C-%EB%A7%88%EC%A7%80%EB%A7%89%EC%9C%84%EC%B9%98%EB%A1%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%ED%95%98%EB%8A%94-%EC%83%81%ED%99%A9%EC%97%90%EC%84%9C-add-execute%ED%95%98%EC%97%AC-list%EC%97%90-add%EB%90%A0-%EA%B0%9D%EC%B2%B4%EA%B0%80-%ED%98%84%EC%9E%ACcursor1%EC%9C%84%EC%B9%98%EC%97%90-%EC%9D%B4%EC%96%B4%EC%95%BC%ED%95%9C%EB%8B%A4----add%EC%A0%84-cursor1%EB%A7%88%EC%A7%80%EB%A7%89%EC%9A%94%EC%86%8C%EB%93%A4%EC%9D%84-remove%ED%95%B4%EC%84%9C-%EB%82%A0%EB%A0%A4%EB%86%94%EC%95%BC-add%ED%9B%84-size-1%EC%9D%B4-%EB%A7%88%EC%A7%80%EB%A7%89%EC%9C%84%EC%B9%98%EA%B0%80-%EB%90%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>add후 cursor를 컬렉션api로 마지막위치로 업데이트하는 상황에서, add-execute하여 List에 add될 객체가 [현재cursor+1]위치에 이어야한다.  -&gt; add전, [cursor+1~마지막]요소들을 remove해서 날려놔야, add후 size()-1이 마지막위치가 된다.</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811021902771.png" alt="image-20220811021902771"></p>

<ol>
  <li>
    <p>뒤로 이동했을 cursor의 위치에서, <strong>마지막부터 ~ cursor+1까지 돌면서, remove로 날린다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/b9527979-acc9-4a94-9feb-4903051f019f.gif" alt="b9527979-acc9-4a94-9feb-4903051f019f"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811022230632.png" alt="image-20220811022230632"></p>
  </li>
</ol>

<h3 id="커맨드-홀더의-undo의-remove를-제거하기-위해-업데이트">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C-%ED%99%80%EB%8D%94%EC%9D%98-undo%EC%9D%98-remove%EB%A5%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%B4-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드 홀더의 undo의 remove를 제거하기 위해 업데이트</h3>

<h4 id="undo에서-삭제-전-컬렉션--존재검증---더이상-컬렉션-요소를-삭제하지-않으니-cursor로-검증cursor-0은-undo시킬-cmd객체가-있는-상황">
<a class="anchor" href="#undo%EC%97%90%EC%84%9C-%EC%82%AD%EC%A0%9C-%EC%A0%84-%EC%BB%AC%EB%A0%89%EC%85%98--%EC%A1%B4%EC%9E%AC%EA%B2%80%EC%A6%9D---%EB%8D%94%EC%9D%B4%EC%83%81-%EC%BB%AC%EB%A0%89%EC%85%98-%EC%9A%94%EC%86%8C%EB%A5%BC-%EC%82%AD%EC%A0%9C%ED%95%98%EC%A7%80-%EC%95%8A%EC%9C%BC%EB%8B%88-cursor%EB%A1%9C-%EA%B2%80%EC%A6%9Dcursor-0%EC%9D%80-undo%EC%8B%9C%ED%82%AC-cmd%EA%B0%9D%EC%B2%B4%EA%B0%80-%EC%9E%88%EB%8A%94-%EC%83%81%ED%99%A9" aria-hidden="true"><span class="octicon octicon-link"></span></a>undo에서 삭제 전 컬렉션  존재검증 -&gt; 더이상 컬렉션 요소를 삭제하지 않으니, cursor로 검증(cursor 0은 undo시킬 cmd객체가 있는 상황)</h4>

<ol>
  <li>
    <p><strong>undo할 요소가 컬렉션에 있는지</strong></p>

    <ul>
      <li>
        <p><strong>(기존) add/remove로 관리었다면 -&gt; <code class="language-plaintext highlighter-rouge">.size() == 0</code>  or  <code class="language-plaintext highlighter-rouge">.isEmpty()</code></strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811023445411.png" alt="image-20220811023445411"></p>
      </li>
      <li>
        <p><strong>(현재) 요소remove없이 cursor로 뒤로 이동만 함 -&gt; <code class="language-plaintext highlighter-rouge">cursor 0이 첫 요소에 cmd객체가  undo할 것이 남아있는 상황</code> -&gt; <code class="language-plaintext highlighter-rouge">cursor가 0보다 작으면 요소가 없는 상황</code></strong></p>

        <ul>
          <li>cursor0에서 뒤로 가면, 데이터가 없는 상황이다.</li>
          <li>cursor0은 첫 원소가 있는 위치다</li>
        </ul>
      </li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811024501939.png" alt="image-20220811024501939"></p>
  </li>
</ol>

<h4 id="undo는-popremovesize-1-대신-현재cursor의-외부저장소cmd객체를-가져온-뒤-cursor는-한칸-뒤로-이동시켜야한다">
<a class="anchor" href="#undo%EB%8A%94-popremovesize-1-%EB%8C%80%EC%8B%A0-%ED%98%84%EC%9E%ACcursor%EC%9D%98-%EC%99%B8%EB%B6%80%EC%A0%80%EC%9E%A5%EC%86%8Ccmd%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EA%B0%80%EC%A0%B8%EC%98%A8-%EB%92%A4-cursor%EB%8A%94-%ED%95%9C%EC%B9%B8-%EB%92%A4%EB%A1%9C-%EC%9D%B4%EB%8F%99%EC%8B%9C%EC%BC%9C%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>undo는 (pop==remove(size-1) 대신) 현재cursor의 외부저장소cmd객체를 가져온 뒤, cursor는 한칸 뒤로 이동시켜야한다</h4>

<ol>
  <li>
    <p>기존에는 remove로 pop해와서 썼는데, 지금은 현재커서 위치 갖다쓰고, 컬렉션은 유지하고 커서만 이동시킨다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/db1f1a31-c608-4296-9658-009b3cc1c221.gif" alt="db1f1a31-c608-4296-9658-009b3cc1c221"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811024619373.png" alt="image-20220811024619373"></p>
  </li>
  <li>
    <p><strong>사용후 1씩 업데이트라면, java에서는 <code class="language-plaintext highlighter-rouge">메서드(변수사용--)</code> 이나 <code class="language-plaintext highlighter-rouge">메서드(변수++)</code>형태로 단일연산자로 처리할 수 있다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811024644454.png" alt="image-20220811024644454"></p>
  </li>
  <li>
    <p>트랜잭션일어날 일이 아니면 <strong>지역변수 쿠션을 안준다.</strong></p>

    <ul>
      <li><strong>단항연산자는 앞에 붙을때만 업데이트되서 사용되고, 뒤에 붙으면 사용후 업데이트 된다.</strong></li>
      <li><strong><code class="language-plaintext highlighter-rouge">단항연산자 사용변수 이후 체이닝메서드는 이미 업데이트된 변수 상태니, 사용시 주의하자</code></strong></li>
      <li><strong><code class="language-plaintext highlighter-rouge">트랜잭션을 만드는 메서드 체이닝시 단항연산자를 사용해서, 중간에 다른 사용 못하게 하자</code></strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811024828326.png" alt="image-20220811024828326"></p>
  </li>
</ol>

<h3 id="redo-구현">
<a class="anchor" href="#redo-%EA%B5%AC%ED%98%84" aria-hidden="true"><span class="octicon octicon-link"></span></a>redo 구현</h3>

<h4 id="이론-redo는-커서만-빽한-undo상태가-대상이며-cursor--1-위치로-가서-꺼내서-execute하는-것이다">
<a class="anchor" href="#%EC%9D%B4%EB%A1%A0-redo%EB%8A%94-%EC%BB%A4%EC%84%9C%EB%A7%8C-%EB%B9%BD%ED%95%9C-undo%EC%83%81%ED%83%9C%EA%B0%80-%EB%8C%80%EC%83%81%EC%9D%B4%EB%A9%B0-cursor--1-%EC%9C%84%EC%B9%98%EB%A1%9C-%EA%B0%80%EC%84%9C-%EA%BA%BC%EB%82%B4%EC%84%9C-execute%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>(이론) redo는 [커서만 빽한 undo상태가 대상]이며 cursor + 1 위치로 가서 꺼내서 execute하는 것이다.</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811121544292.png" alt="image-20220811121544292"></p>

<h4 id="이론-undo의-대상과-redo의-대상">
<a class="anchor" href="#%EC%9D%B4%EB%A1%A0-undo%EC%9D%98-%EB%8C%80%EC%83%81%EA%B3%BC-redo%EC%9D%98-%EB%8C%80%EC%83%81" aria-hidden="true"><span class="octicon octicon-link"></span></a>(이론) undo의 대상과 redo의 대상</h4>

<ul>
  <li>undo의 대상: 현재 execute하여 stack에 add된 cmd객체
    <ul>
      <li>add-execute시, <strong>cursor도 맨 마지막으로 업데이트 된 상태</strong>가 되도록 로직이 짜여져있다.</li>
      <li><strong>현재 cursor의 cmd객체를 가져와서 .undo만 치면 된다.</strong></li>
    </ul>
  </li>
  <li>redo의 대상: 현재 undo하여 stack상 cursor가 -1 빽한 상태이며, <strong>cursor한칸 앞의 cmd객체</strong>
    <ul>
      <li><strong>cursor를 +1 해준 뒤, 그곳의 객체를 execute해주는 것이 redo</strong></li>
      <li>cursor가 add-execute의 대상cmd객체에 위치하고 있으니, 다시 undo가 가능하다</li>
    </ul>
  </li>
  <li><strong>execute는 처음 <code class="language-plaintext highlighter-rouge">add-execute든, redo든, 방금 시행한 객체를 가리키고 있어야 undo가 가능</code>해진다.</strong></li>
</ul>

<h4 id="구현1---redo전-cursor-invariant검사로-redo할게-없는-상황이면-종료-cursor한칸-앞으로-못감--undo안한상황--add-execute만-한-상황--cursor가-제일-마지막에-위치">
<a class="anchor" href="#%EA%B5%AC%ED%98%841---redo%EC%A0%84-cursor-invariant%EA%B2%80%EC%82%AC%EB%A1%9C-redo%ED%95%A0%EA%B2%8C-%EC%97%86%EB%8A%94-%EC%83%81%ED%99%A9%EC%9D%B4%EB%A9%B4-%EC%A2%85%EB%A3%8C-cursor%ED%95%9C%EC%B9%B8-%EC%95%9E%EC%9C%BC%EB%A1%9C-%EB%AA%BB%EA%B0%90--undo%EC%95%88%ED%95%9C%EC%83%81%ED%99%A9--add-execute%EB%A7%8C-%ED%95%9C-%EC%83%81%ED%99%A9--cursor%EA%B0%80-%EC%A0%9C%EC%9D%BC-%EB%A7%88%EC%A7%80%EB%A7%89%EC%97%90-%EC%9C%84%EC%B9%98" aria-hidden="true"><span class="octicon octicon-link"></span></a>구현1 - redo전 cursor invariant검사로, [redo할게 없는 상황이면 종료] (cursor한칸 앞으로 못감 == undo안한상황 == add-execute만 한 상황 == cursor가 제일 마지막에 위치)</h4>

<ol>
  <li>
    <p><strong>cursor가 undo를 하지 않은 상태면, redo가 안된다.</strong></p>

    <ul>
      <li>redo는 undo한 상태에서 cursor를 다시 +1 한 뒤, execute하는 것인데</li>
      <li>
<strong>cursor가 List 맨 마지막에 위치한 상태(undo안하고 add-execute만 한 상황)이면 redo는 불가능</strong>하다.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/90ca8de4-f4ef-494e-bdcc-502195479129.gif" alt="90ca8de4-f4ef-494e-bdcc-502195479129"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811122515721.png" alt="image-20220811122515721"></p>
  </li>
</ol>

<h4 id="진해서-두고-그-놈을-한번-더-execute하는-것이다">
<a class="anchor" href="#%EC%A7%84%ED%95%B4%EC%84%9C-%EB%91%90%EA%B3%A0-%EA%B7%B8-%EB%86%88%EC%9D%84-%ED%95%9C%EB%B2%88-%EB%8D%94-execute%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>진해서 두고, 그 놈을 한번 더 execute하는 것이다.</h4>

<ul>
  <li>
    <p>만약, 먼저 업데이트되서 쓴다고 하면,  <strong><code class="language-plaintext highlighter-rouge">++변수</code> 단항연산자를 메서드 인자로</strong> 쓰면 된다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/5fc43cc6-6bd2-4ca7-9853-7faa87c8305e.gif" alt="5fc43cc6-6bd2-4ca7-9853-7faa87c8305e"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811122734403.png" alt="image-20220811122734403"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811122750640.png" alt="image-20220811122750640"></p>
  </li>
</ul>

<h2 id="addcommand-undo-redo-with-cursor---객체소유-커맨드홀더객체-완성---커맨드패턴-완성---undoreo하며-출력">
<a class="anchor" href="#addcommand-undo-redo-with-cursor---%EA%B0%9D%EC%B2%B4%EC%86%8C%EC%9C%A0-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4-%EC%99%84%EC%84%B1---%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%8C%A8%ED%84%B4-%EC%99%84%EC%84%B1---undoreo%ED%95%98%EB%A9%B0-%EC%B6%9C%EB%A0%A5" aria-hidden="true"><span class="octicon octicon-link"></span></a>addCommand/ undo/ redo with cursor -&gt; 객체소유 커맨드홀더객체 완성 -&gt; 커맨드패턴 완성 -&gt; undo/reo하며 출력</h2>

<h3 id="main에서-composite객체소유객체-대신-command홀더객체를-사용해보자">
<a class="anchor" href="#main%EC%97%90%EC%84%9C-composite%EA%B0%9D%EC%B2%B4%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4-%EB%8C%80%EC%8B%A0-command%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>Main에서 Composite객체(소유객체) 대신 Command홀더객체를 사용해보자.</h3>

<h4 id="더이상-소유된-composite객체는-외부에서-사용하지-않는다-command홀더객체가-생성자에서-재료만-받아-내부생성했다">
<a class="anchor" href="#%EB%8D%94%EC%9D%B4%EC%83%81-%EC%86%8C%EC%9C%A0%EB%90%9C-composite%EA%B0%9D%EC%B2%B4%EB%8A%94-%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4-command%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4%EA%B0%80-%EC%83%9D%EC%84%B1%EC%9E%90%EC%97%90%EC%84%9C-%EC%9E%AC%EB%A3%8C%EB%A7%8C-%EB%B0%9B%EC%95%84-%EB%82%B4%EB%B6%80%EC%83%9D%EC%84%B1%ED%96%88%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>더이상 소유된 composite객체는 외부에서 사용하지 않는다. Command홀더객체가 생성자에서 재료만 받아 내부생성했다</h4>

<ul>
  <li>
    <p>Main에 있는 CompositeMenu -&gt; CommandMenu로 변경하자</p>

    <ul>
      <li>ctrl + F7로 사용 context들을 표시하고 시작하면 편할 것이다.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/94b5cc1d-15c3-4e57-957e-bbf5617a1296.gif" alt="94b5cc1d-15c3-4e57-957e-bbf5617a1296"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811124541044.png" alt="image-20220811124541044"></p>
  </li>
</ul>

<h4 id="root에-menu에만-add할게-아니라-자식menu을-먼저-미리-생성자식에-자식-미리-추가한-것도-add하려면-자식-menu를-지역변수로-받아서-생성해놓고-root에-미리-생성된-menu도-add가능하도록-수정해야한다">
<a class="anchor" href="#root%EC%97%90-menu%EC%97%90%EB%A7%8C-add%ED%95%A0%EA%B2%8C-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%9E%90%EC%8B%9Dmenu%EC%9D%84-%EB%A8%BC%EC%A0%80-%EB%AF%B8%EB%A6%AC-%EC%83%9D%EC%84%B1%EC%9E%90%EC%8B%9D%EC%97%90-%EC%9E%90%EC%8B%9D-%EB%AF%B8%EB%A6%AC-%EC%B6%94%EA%B0%80%ED%95%9C-%EA%B2%83%EB%8F%84-add%ED%95%98%EB%A0%A4%EB%A9%B4-%EC%9E%90%EC%8B%9D-menu%EB%A5%BC-%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98%EB%A1%9C-%EB%B0%9B%EC%95%84%EC%84%9C-%EC%83%9D%EC%84%B1%ED%95%B4%EB%86%93%EA%B3%A0-root%EC%97%90-%EB%AF%B8%EB%A6%AC-%EC%83%9D%EC%84%B1%EB%90%9C-menu%EB%8F%84-add%EA%B0%80%EB%8A%A5%ED%95%98%EB%8F%84%EB%A1%9D-%EC%88%98%EC%A0%95%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>root에 menu에만 add할게 아니라, 자식menu을 먼저 미리 생성(자식에 자식 미리 추가)한 것도 add하려면, 자식 menu를 지역변수로 받아서 생성해놓고, [root에 미리 생성된 menu도 add가능하도록 수정]해야한다</h4>

<ul>
  <li>현재는
    <ul>
      <li>root menu의 정보 -&gt; root생성</li>
      <li>root의 1차 자식의 menu정보 -&gt; <strong>root 1차 자식들 add만 할 수 있는 상황</strong>
</li>
    </ul>
  </li>
  <li>
<strong>정보를 통한 add 이외에</strong> <strong>외부에서 미리 생성된 CommandMenu를 add할 수 있도록 메서드를 추가해보자.</strong>
    <ul>
      <li>문제점이 발견된다.</li>
    </ul>
  </li>
</ul>

<h4 id="기존의-정보를-통한-소유객체-내부생성-add커맨드객체는-이미-생성된-menu객체와-전혀-다른-context---생성자-필드가-다름---새로운-커맨드객체가-필요하다">
<a class="anchor" href="#%EA%B8%B0%EC%A1%B4%EC%9D%98-%EC%A0%95%EB%B3%B4%EB%A5%BC-%ED%86%B5%ED%95%9C-%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4-%EB%82%B4%EB%B6%80%EC%83%9D%EC%84%B1-add%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EB%8A%94-%EC%9D%B4%EB%AF%B8-%EC%83%9D%EC%84%B1%EB%90%9C-menu%EA%B0%9D%EC%B2%B4%EC%99%80-%EC%A0%84%ED%98%80-%EB%8B%A4%EB%A5%B8-context---%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%84%EB%93%9C%EA%B0%80-%EB%8B%A4%EB%A6%84---%EC%83%88%EB%A1%9C%EC%9A%B4-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%98%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>기존의, 정보를 통한 소유객체 내부생성 Add커맨드객체는, 이미 생성된 Menu객체와 전혀 다른 context -&gt; 생성자-필드가 다름 -&gt; 새로운 커맨드객체가 필요하다</h4>

<ol>
  <li>
    <p>일단, 외부에서 Composite객체 대신, Command홀더객체로 만든 것을 add해보면, <strong>기존 커맨드객체가 instance context로서 기억하는, 당시context == 필드가 달라진다.</strong>
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811133820213.png" alt="image-20220811133820213"></p>
  </li>
  <li>
    <p>기존 필드들을 초기화할 수 없어서 생성자 및 필드에 불이 들어오게 된다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811133848633.png" alt="image-20220811133848633"></p>
  </li>
  <li>
    <p>억지로 필드에 기억했다고 치더라도 <strong>execute시에도 다른 메서드를 호출해야해서 곤란하다</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811133934991.png" alt="image-20220811133934991"></p>
  </li>
  <li>
    <p><strong>게다가 <code class="language-plaintext highlighter-rouge">커맨드홀더는 포장객체일 뿐, 내부 자식들은 Composite객체(소유객체)형으로 자식들이 추가</code>된다.</strong></p>

    <ul>
      <li><strong>메서드 파라미터가 달라지면, <code class="language-plaintext highlighter-rouge">행위위임받은 커맨드객체는, 메서드처럼 오버로딩해서 재활용</code>못한다</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811134014851.png" alt="image-20220811134014851"></p>
  </li>
</ol>

<h3 id="파라미터만-다르더라도-새-커맨드객체-생성">
<a class="anchor" href="#%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A7%8C-%EB%8B%A4%EB%A5%B4%EB%8D%94%EB%9D%BC%EB%8F%84-%EC%83%88-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1" aria-hidden="true"><span class="octicon octicon-link"></span></a>파라미터만 다르더라도 새 커맨드객체 생성</h3>

<h4 id="행위위임-커맨드객체는-커맨드호출-서비스메서드의-파라미터가-달라지면-커맨드객체의-기억필드가-달라져서-메서드-오버로딩처럼재활용-못하니-새-커맨드객체를-생성해서-위임해야한다">
<a class="anchor" href="#%ED%96%89%EC%9C%84%EC%9C%84%EC%9E%84-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EB%8A%94-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%98%B8%EC%B6%9C-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EA%B0%80-%EB%8B%AC%EB%9D%BC%EC%A7%80%EB%A9%B4-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EC%9D%98-%EA%B8%B0%EC%96%B5%ED%95%84%EB%93%9C%EA%B0%80-%EB%8B%AC%EB%9D%BC%EC%A0%B8%EC%84%9C-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9%EC%B2%98%EB%9F%BC%EC%9E%AC%ED%99%9C%EC%9A%A9-%EB%AA%BB%ED%95%98%EB%8B%88-%EC%83%88-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%83%9D%EC%84%B1%ED%95%B4%EC%84%9C-%EC%9C%84%EC%9E%84%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>행위위임 커맨드객체는, 커맨드호출 서비스메서드의 파라미터가 달라지면, 커맨드객체의 기억필드가 달라져서 [메서드 오버로딩처럼]재활용 못하니, 새 커맨드객체를 생성해서 위임해야한다.</h4>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">add시 정보</code> -&gt; 내부compoiste객체 생성 형태가 아니라 <code class="language-plaintext highlighter-rouge">add시 이미 완성된 command객체</code>로서 파라미터가 달라졌다면, <strong>새롭게 커맨드객체를 만들어야한다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/52f0ac03-237c-49a1-892e-20b7baf259b6.gif" alt="52f0ac03-237c-49a1-892e-20b7baf259b6"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811135319617.png" alt="image-20220811135319617"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811135507553.png" alt="image-20220811135507553"></p>
  </li>
  <li>
    <p><strong>위임해줬던 Composite객체는, 커맨드객체 내부에서 지연실행 될 때, <code class="language-plaintext highlighter-rouge">완성된 커맨드객체가 아닌, 자신형을 자식으로 add</code>한다</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811135745691.png" alt="image-20220811135745691"></p>
  </li>
  <li>
    <p>커맨드홀더객체로부터 소유객체 getter를 만들어준다.</p>

    <ul>
      <li>Add과정과  동일하게 처리해준다.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/2e7ae8b3-a902-4135-a9b9-2c3fb8ee1fad.gif" alt="2e7ae8b3-a902-4135-a9b9-2c3fb8ee1fad"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811135943175.png" alt="image-20220811135943175"></p>
  </li>
</ol>

<h3 id="출력은-command홀더객체root---report생성---renderer-with-visitor---consolevisitor로-출력이다">
<a class="anchor" href="#%EC%B6%9C%EB%A0%A5%EC%9D%80-command%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4root---report%EC%83%9D%EC%84%B1---renderer-with-visitor---consolevisitor%EB%A1%9C-%EC%B6%9C%EB%A0%A5%EC%9D%B4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>출력은 Command홀더객체(root) -&gt; report생성 -&gt; Renderer with Visitor -&gt; ConsoleVisitor로 출력이다.</h3>

<h4 id="제어는-renderer가-제어를-타는-것은-특정-visitor들을-미리-생성자-주입">
<a class="anchor" href="#%EC%A0%9C%EC%96%B4%EB%8A%94-renderer%EA%B0%80-%EC%A0%9C%EC%96%B4%EB%A5%BC-%ED%83%80%EB%8A%94-%EA%B2%83%EC%9D%80-%ED%8A%B9%EC%A0%95-visitor%EB%93%A4%EC%9D%84-%EB%AF%B8%EB%A6%AC-%EC%83%9D%EC%84%B1%EC%9E%90-%EC%A3%BC%EC%9E%85" aria-hidden="true"><span class="octicon octicon-link"></span></a>제어는 Renderer가, 제어를 타는 것은 특정 Visitor들을 미리 생성자 주입</h4>

<h4 id="제어타면서-행위를-할-객체를-renderer에게-건네주면-내부에서-visitor에게-파라미터로-객체를-넘겨-visitor에게-위임한다">
<a class="anchor" href="#%EC%A0%9C%EC%96%B4%ED%83%80%EB%A9%B4%EC%84%9C-%ED%96%89%EC%9C%84%EB%A5%BC-%ED%95%A0-%EA%B0%9D%EC%B2%B4%EB%A5%BC-renderer%EC%97%90%EA%B2%8C-%EA%B1%B4%EB%84%A4%EC%A3%BC%EB%A9%B4-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-visitor%EC%97%90%EA%B2%8C-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A1%9C-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%84%98%EA%B2%A8-visitor%EC%97%90%EA%B2%8C-%EC%9C%84%EC%9E%84%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>제어타면서 행위를 할 객체를 Renderer에게 건네주면, 내부에서 Visitor에게 파라미터로 객체를 넘겨, Visitor에게 위임한다</h4>

<ol>
  <li>
    <p>출력은 ConsoleVisitor를 주입해서 만든 Renderer로 한다.</p>

    <ul>
      <li>어차피 <strong>Visitor는 Renderer내부 (지연)생성이니, <code class="language-plaintext highlighter-rouge">Render의 메서드에게 재료객체Report</code>를 던져줘서 호출한다.</strong>
</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811140728010.png" alt="image-20220811140728010"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811140904808.png" alt="image-20220811140904808"></p>
  </li>
</ol>

<h3 id="생각해보기-1">
<a class="anchor" href="#%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EA%B8%B0-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>생각해보기</h3>

<h4 id="소유객체는-undo에서-remove하기-위해--add시-add되는-객체를-return해서-필드로-저장----커맨드홀더객체의-add는-return없는-void">
<a class="anchor" href="#%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4%EB%8A%94-undo%EC%97%90%EC%84%9C-remove%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%B4--add%EC%8B%9C-add%EB%90%98%EB%8A%94-%EA%B0%9D%EC%B2%B4%EB%A5%BC-return%ED%95%B4%EC%84%9C-%ED%95%84%EB%93%9C%EB%A1%9C-%EC%A0%80%EC%9E%A5----%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4%EC%9D%98-add%EB%8A%94-return%EC%97%86%EB%8A%94-void" aria-hidden="true"><span class="octicon octicon-link"></span></a>소유객체는 undo에서 remove하기 위해,  add시 add되는 객체를 return해서 필드로 저장  /  커맨드홀더객체의 add는 return없는 void</h4>

<ul>
  <li>
    <p>CommandMenu</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811155816972.png" alt="image-20220811155816972"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811160044421.png" alt="image-20220811160044421"></p>
  </li>
  <li>
    <p>CompositeMenu</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811155912879.png" alt="image-20220811155912879"></p>
  </li>
  <li>
    <p>**<code class="language-plaintext highlighter-rouge">커맨드홀더객체의 add는 원래 return이 없다</code> **</p>
    <ul>
      <li>소유객체를 <strong>지연실행</strong>시키기 위해 <strong>add동작이 구상 커맨드객체 내부에서 소유객체의 add가 실행</strong>된다.</li>
      <li>
<strong>커맨드객체에 위임한 뒤, 커맨드객체를 필요할 때 지연실행 시킬 수 있어야, <code class="language-plaintext highlighter-rouge">실행 전 외부저장소에 저장해놓고 실행</code>할 수 있기 때문에, <code class="language-plaintext highlighter-rouge">최종 소유객체의 add가 미리 실행되서 return되면 안된다.</code></strong>
        <ul>
          <li>바로 실행한다면 무조건 동기적인 실행이며, undo/redo를 못한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="커맨드객체에-지연실행을-위임함으로써-실행-시-aggregation필드외부저장소list에-저장해놓을-수-있으며-다시-반복실행-undo실행-redo-등을-저장소에서-꺼내서-한다">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EC%97%90-%EC%A7%80%EC%97%B0%EC%8B%A4%ED%96%89%EC%9D%84-%EC%9C%84%EC%9E%84%ED%95%A8%EC%9C%BC%EB%A1%9C%EC%8D%A8-%EC%8B%A4%ED%96%89-%EC%8B%9C-aggregation%ED%95%84%EB%93%9C%EC%99%B8%EB%B6%80%EC%A0%80%EC%9E%A5%EC%86%8Clist%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%B4%EB%86%93%EC%9D%84-%EC%88%98-%EC%9E%88%EC%9C%BC%EB%A9%B0-%EB%8B%A4%EC%8B%9C-%EB%B0%98%EB%B3%B5%EC%8B%A4%ED%96%89-undo%EC%8B%A4%ED%96%89-redo-%EB%93%B1%EC%9D%84-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%97%90%EC%84%9C-%EA%BA%BC%EB%82%B4%EC%84%9C-%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드객체에 지연실행을 위임함으로써, 실행 시 aggregation필드(외부저장소List)에 저장해놓을 수 있으며, <code class="language-plaintext highlighter-rouge">다시 반복실행, undo실행, redo 등을 저장소에서 꺼내서 한다</code>
</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811160618447.png" alt="image-20220811160618447"></p>

<h3 id="오타-수정">
<a class="anchor" href="#%EC%98%A4%ED%83%80-%EC%88%98%EC%A0%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>오타 수정</h3>

<h4 id="compositemenu의-remove에서-존재검증시-느낌표-하나-빠짐">
<a class="anchor" href="#compositemenu%EC%9D%98-remove%EC%97%90%EC%84%9C-%EC%A1%B4%EC%9E%AC%EA%B2%80%EC%A6%9D%EC%8B%9C-%EB%8A%90%EB%82%8C%ED%91%9C-%ED%95%98%EB%82%98-%EB%B9%A0%EC%A7%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>CompositeMenu의 remove에서 존재검증시 !느낌표 하나 빠짐</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811161948509.png" alt="image-20220811161948509"></p>

<h3 id="composite객체---command객체-사용전환-완료됨---커맨드홀더객체커맨드패턴만의-undoredo를-사용해보자">
<a class="anchor" href="#composite%EA%B0%9D%EC%B2%B4---command%EA%B0%9D%EC%B2%B4-%EC%82%AC%EC%9A%A9%EC%A0%84%ED%99%98-%EC%99%84%EB%A3%8C%EB%90%A8---%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%8C%A8%ED%84%B4%EB%A7%8C%EC%9D%98-undoredo%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>Composite객체 -&gt; Command객체 사용전환 완료됨 -&gt; 커맨드홀더객체(커맨드패턴)만의 undo/redo를 사용해보자.</h3>

<ul>
  <li>
<strong>포장한 커맨드홀더객체를 만든 이유</strong>는, 내부에 <strong>커맨드객체 외부저장소(aggregation)</strong>를 가져서 undo/redo를 하기 위함.</li>
</ul>

<h4 id="커맨드홀더객체undo는-커맨드홀더객체-어느행위-든addmenu-settitle-등-직전-행동에-대해-카운터를-친다">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4undo%EB%8A%94-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4-%EC%96%B4%EB%8A%90%ED%96%89%EC%9C%84-%EB%93%A0addmenu-settitle-%EB%93%B1-%EC%A7%81%EC%A0%84-%ED%96%89%EB%8F%99%EC%97%90-%EB%8C%80%ED%95%B4-%EC%B9%B4%EC%9A%B4%ED%84%B0%EB%A5%BC-%EC%B9%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드홀더객체.undo()는 커맨드홀더객체 어느행위 든(addMenu, setTitle 등) 직전 행동에 대해 카운터를 친다.</h4>

<ul>
  <li>
    <p><strong>undo는 해당 Command홀더객체의 최근행동에 1개씩 적용된다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811162230541.png" alt="image-20220811162230541"></p>
  </li>
</ul>

<h4 id="redo는-직전의-undo에-대해서-카운터를-친다">
<a class="anchor" href="#redo%EB%8A%94-%EC%A7%81%EC%A0%84%EC%9D%98-undo%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%B9%B4%EC%9A%B4%ED%84%B0%EB%A5%BC-%EC%B9%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>redo는 직전의 undo에 대해서 카운터를 친다</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811162318006.png" alt="image-20220811162318006"></p>

<h4 id="잘-작동한다">
<a class="anchor" href="#%EC%9E%98-%EC%9E%91%EB%8F%99%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>잘 작동한다</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/3c7071af-ce20-41cf-ab57-04d9de15394e.gif" alt="3c7071af-ce20-41cf-ab57-04d9de15394e"></p>

<h3 id="생각해보기-2">
<a class="anchor" href="#%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EA%B8%B0-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>생각해보기</h3>

<h4 id="public-서비스메서드-with-private-도메인객체-파라미터-메서드---도메인객체-generator-서비스메서드">
<a class="anchor" href="#public-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A9%94%EC%84%9C%EB%93%9C-with-private-%EB%8F%84%EB%A9%94%EC%9D%B8%EA%B0%9D%EC%B2%B4-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-%EB%A9%94%EC%84%9C%EB%93%9C---%EB%8F%84%EB%A9%94%EC%9D%B8%EA%B0%9D%EC%B2%B4-generator-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A9%94%EC%84%9C%EB%93%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>public 서비스메서드 with private 도메인객체 파라미터 메서드 -&gt; 도메인객체 generator 서비스메서드</h4>

<h5 id="커맨드홀더객체의--소유객체-래핑-set계열메서드들은-다-addcommand해당-커맨드객체-를-호출하는-래핑된-서비스-메서드들이다">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4%EC%9D%98--%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4-%EB%9E%98%ED%95%91-set%EA%B3%84%EC%97%B4%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4%EC%9D%80-%EB%8B%A4-addcommand%ED%95%B4%EB%8B%B9-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4-%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%98%EB%8A%94-%EB%9E%98%ED%95%91%EB%90%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4%EC%9D%B4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드홀더객체의  소유객체 래핑 set계열메서드들은 다 [addCommand(해당 커맨드객체) 를 호출하는 래핑된 서비스 메서드]들이다</h5>

<ul>
  <li>
    <p><strong>전부다 내부에서 execute-add하는 addCommand(new 커맨드객체())만 호출한다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811162721858.png" alt="image-20220811162721858"></p>
  </li>
</ul>

<h5 id="래핑을-풀고-private-addcommand메서드-만-public으로-공개하면-처리-가능하지만-외부에서-직접-커맨드객체를-new때려서-생성해서-넣어줘야한다---차라리-서비스메서드를-제공하고-커맨드-홀더객체-내부에-private-generator로-생성하는게-낫다">
<a class="anchor" href="#%EB%9E%98%ED%95%91%EC%9D%84-%ED%92%80%EA%B3%A0-private-addcommand%EB%A9%94%EC%84%9C%EB%93%9C-%EB%A7%8C-public%EC%9C%BC%EB%A1%9C-%EA%B3%B5%EA%B0%9C%ED%95%98%EB%A9%B4-%EC%B2%98%EB%A6%AC-%EA%B0%80%EB%8A%A5%ED%95%98%EC%A7%80%EB%A7%8C-%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-%EC%A7%81%EC%A0%91-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EB%A5%BC-new%EB%95%8C%EB%A0%A4%EC%84%9C-%EC%83%9D%EC%84%B1%ED%95%B4%EC%84%9C-%EB%84%A3%EC%96%B4%EC%A4%98%EC%95%BC%ED%95%9C%EB%8B%A4---%EC%B0%A8%EB%9D%BC%EB%A6%AC-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EC%A0%9C%EA%B3%B5%ED%95%98%EA%B3%A0-%EC%BB%A4%EB%A7%A8%EB%93%9C-%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4-%EB%82%B4%EB%B6%80%EC%97%90-private-generator%EB%A1%9C-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94%EA%B2%8C-%EB%82%AB%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>래핑을 풀고 private addCommand메서드 만 public으로 공개하면 처리 가능하지만, 외부에서 직접 커맨드객체를 new때려서 생성해서 넣어줘야한다. -&gt; 차라리 서비스메서드를 제공하고 커맨드 홀더객체 내부에 private generator로 생성하는게 낫다</h5>

<ul>
  <li>
    <p>가정</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811162849837.png" alt="image-20220811162849837"></p>
  </li>
</ul>

<h5 id="객체-파라미터를-public으로-공개한다는-것은-외부에서-생성한-뒤-받겠다는-말인데-도메인을-보호하자---public메서드의-객체-파라미터는-최대한-피하자---서비스-메서드를-제공하자">
<a class="anchor" href="#%EA%B0%9D%EC%B2%B4-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A5%BC-public%EC%9C%BC%EB%A1%9C-%EA%B3%B5%EA%B0%9C%ED%95%9C%EB%8B%A4%EB%8A%94-%EA%B2%83%EC%9D%80-%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-%EC%83%9D%EC%84%B1%ED%95%9C-%EB%92%A4-%EB%B0%9B%EA%B2%A0%EB%8B%A4%EB%8A%94-%EB%A7%90%EC%9D%B8%EB%8D%B0-%EB%8F%84%EB%A9%94%EC%9D%B8%EC%9D%84-%EB%B3%B4%ED%98%B8%ED%95%98%EC%9E%90---public%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%EA%B0%9D%EC%B2%B4-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%8A%94-%EC%B5%9C%EB%8C%80%ED%95%9C-%ED%94%BC%ED%95%98%EC%9E%90---%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EC%A0%9C%EA%B3%B5%ED%95%98%EC%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>객체 파라미터를 public으로 공개한다는 것은, 외부에서 생성한 뒤 받겠다는 말인데, 도메인을 보호하자. -&gt; public메서드의 객체 파라미터는 최대한 피하자 -&gt; 서비스 메서드를 제공하자</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811163021173.png" alt="image-20220811163021173"></p>

<h4 id="커맨드패턴커맨드홀더객체을-쓰면-좋은-점지연실행으로-인한-외부저장소---undoredo-장점-외">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%8C%A8%ED%84%B4%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4%EC%9D%84-%EC%93%B0%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%A0%90%EC%A7%80%EC%97%B0%EC%8B%A4%ED%96%89%EC%9C%BC%EB%A1%9C-%EC%9D%B8%ED%95%9C-%EC%99%B8%EB%B6%80%EC%A0%80%EC%9E%A5%EC%86%8C---undoredo-%EC%9E%A5%EC%A0%90-%EC%99%B8" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드패턴(커맨드홀더객체)을 쓰면 좋은 점(지연실행으로 인한 외부저장소 -&gt; undo/redo 장점 외)</h4>

<h5 id="composite객체가-제공하던-모든-메서드들---command홀더객체는-사실상-외부에-public-addcommandexecuteadd만-제공--구상-커맨드객체만-외부에서-입력해주면-그외-메서드는-없어도-된다편의상-커맨드객체별-서비스메서드로-제공-중">
<a class="anchor" href="#composite%EA%B0%9D%EC%B2%B4%EA%B0%80-%EC%A0%9C%EA%B3%B5%ED%95%98%EB%8D%98-%EB%AA%A8%EB%93%A0-%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4---command%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4%EB%8A%94-%EC%82%AC%EC%8B%A4%EC%83%81-%EC%99%B8%EB%B6%80%EC%97%90-public-addcommandexecuteadd%EB%A7%8C-%EC%A0%9C%EA%B3%B5--%EA%B5%AC%EC%83%81-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EB%A7%8C-%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-%EC%9E%85%EB%A0%A5%ED%95%B4%EC%A3%BC%EB%A9%B4-%EA%B7%B8%EC%99%B8-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-%EC%97%86%EC%96%B4%EB%8F%84-%EB%90%9C%EB%8B%A4%ED%8E%B8%EC%9D%98%EC%83%81-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EB%B3%84-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EC%A0%9C%EA%B3%B5-%EC%A4%91" aria-hidden="true"><span class="octicon octicon-link"></span></a>composite객체가 제공하던 모든 메서드들 -&gt; command홀더객체는 사실상 외부에 public addCommand(execute+add)만 제공 + 구상 커맨드객체만 외부에서 입력해주면, 그외 메서드는 없어도 된다.(편의상 커맨드객체별 서비스메서드로 제공 중)</h5>

<ul>
  <li>행위(compositeMenu)를 구상클래스(command객체들)에 위임한다 -&gt; 행위객체를 소유하는 홀더객체(포장객체, commandMenu)는 위임된 구상클래스를 인자로 받는 메서드 1개(addCommand())만 가지면 된다.</li>
</ul>

<h5 id="실시간-실행런타임-중-상태변경은-커맨드객체가-최고다-커맨드홀더--addcommand-원하는-상태변경-커맨드객체--ex-홈페이지-빌더">
<a class="anchor" href="#%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%8B%A4%ED%96%89%EB%9F%B0%ED%83%80%EC%9E%84-%EC%A4%91-%EC%83%81%ED%83%9C%EB%B3%80%EA%B2%BD%EC%9D%80-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EA%B0%80-%EC%B5%9C%EA%B3%A0%EB%8B%A4-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94--addcommand-%EC%9B%90%ED%95%98%EB%8A%94-%EC%83%81%ED%83%9C%EB%B3%80%EA%B2%BD-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4--ex-%ED%99%88%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B9%8C%EB%8D%94" aria-hidden="true"><span class="octicon octicon-link"></span></a>실시간, 실행(런타임) 중 상태변경은 커맨드객체가 최고다. 커맨드홀더 + addCommand( 원하는 상태변경 커맨드객체 ) ex&gt; 홈페이지 빌더</h5>

<ul>
  <li>
    <p>이렇게 되면, <strong>컴파일 타임에는 메서드가 없고, 런타임에 위임받은 구상클래스만 <code class="language-plaintext highlighter-rouge">원할때마다 동적으로 바꿔서 넣어</code>주면 기능이 작동한다</strong></p>
  </li>
  <li>
    <p>즉, <strong>커맨드홀더객체만 가진 상태</strong>로 + <strong>관련 구상 커맨드객체</strong>만 받으면, 원하는 기능을 수행하게 된다.</p>

    <ul>
      <li>잠시 서비스 메서드들 없다고 가정하고 addCommand를 public으로 풀어놓은 상태</li>
      <li><strong>버튼 클릭시, 해당 구상체만 addCommand해주면 원하는 상태가 된다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220811164310426.png" alt="image-20220811164310426"></p>

    <ul>
      <li>homepage 빌더들은 <strong>해당 요소클릭시, 해당하는 커맨드객체만 add-execute해준다</strong>
</li>
    </ul>
  </li>
</ul>

<h5 id="즉-범용-커맨드홀더객체--차이점을-만드는-구상커맨드객체들을-소유하고-있으면-객체간-차이를-런타임에서-실시간으로-만들어낼-수-있다">
<a class="anchor" href="#%EC%A6%89-%EB%B2%94%EC%9A%A9-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4--%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94-%EA%B5%AC%EC%83%81%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4%EB%93%A4%EC%9D%84-%EC%86%8C%EC%9C%A0%ED%95%98%EA%B3%A0-%EC%9E%88%EC%9C%BC%EB%A9%B4-%EA%B0%9D%EC%B2%B4%EA%B0%84-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EB%9F%B0%ED%83%80%EC%9E%84%EC%97%90%EC%84%9C-%EC%8B%A4%EC%8B%9C%EA%B0%84%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%82%BC-%EC%88%98-%EC%9E%88%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>즉 범용 커맨드홀더객체 + 차이점을 만드는 구상커맨드객체들을 소유하고 있으면, 객체간 차이를 런타임에서 실시간으로 만들어낼 수 있다.</h5>

<h5 id="커맨드홀더객체-내-서비스메서드들addcommand래핑이외에-메서드들get계열-의존성을-가진-것으로-소유객체가-변하면-같이-죽는다-하지만-서비스메서드들은-이미-죽은상태의-메서드들이라-의존성없이-좋은-메서드들임">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4-%EB%82%B4-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4addcommand%EB%9E%98%ED%95%91%EC%9D%B4%EC%99%B8%EC%97%90-%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4get%EA%B3%84%EC%97%B4-%EC%9D%98%EC%A1%B4%EC%84%B1%EC%9D%84-%EA%B0%80%EC%A7%84-%EA%B2%83%EC%9C%BC%EB%A1%9C-%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4%EA%B0%80-%EB%B3%80%ED%95%98%EB%A9%B4-%EA%B0%99%EC%9D%B4-%EC%A3%BD%EB%8A%94%EB%8B%A4-%ED%95%98%EC%A7%80%EB%A7%8C-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4%EC%9D%80-%EC%9D%B4%EB%AF%B8-%EC%A3%BD%EC%9D%80%EC%83%81%ED%83%9C%EC%9D%98-%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4%EC%9D%B4%EB%9D%BC-%EC%9D%98%EC%A1%B4%EC%84%B1%EC%97%86%EC%9D%B4-%EC%A2%8B%EC%9D%80-%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4%EC%9E%84" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드홀더객체 내 서비스메서드들(addCommand래핑)이외에 메서드들(get계열) 의존성을 가진 것으로, 소유객체가 변하면 같이 죽는다. 하지만, 서비스메서드들은 이미 죽은상태의 메서드들이라 의존성없이 좋은 메서드들임</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220801235406574.png" alt="image-20220801235406574"></p>

<h4 id="커맨드패턴이-무적같지만-save와-load가-안된다-save와-load를-하려면-시리얼라이제이션을-통한-영속화를-따로-해야한다">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%8C%A8%ED%84%B4%EC%9D%B4-%EB%AC%B4%EC%A0%81%EA%B0%99%EC%A7%80%EB%A7%8C-save%EC%99%80-load%EA%B0%80-%EC%95%88%EB%90%9C%EB%8B%A4-save%EC%99%80-load%EB%A5%BC-%ED%95%98%EB%A0%A4%EB%A9%B4-%EC%8B%9C%EB%A6%AC%EC%96%BC%EB%9D%BC%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%98%81%EC%86%8D%ED%99%94%EB%A5%BC-%EB%94%B0%EB%A1%9C-%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드패턴이 무적같지만.. save와 load가 안된다. save와 load를 하려면, [시리얼라이제이션을 통한 영속화]를 따로 해야한다.</h4>

<h2 id="메멘토-패턴-save-with-visitor패턴">
<a class="anchor" href="#%EB%A9%94%EB%A9%98%ED%86%A0-%ED%8C%A8%ED%84%B4-save-with-visitor%ED%8C%A8%ED%84%B4" aria-hidden="true"><span class="octicon octicon-link"></span></a>메멘토 패턴 save with Visitor패턴</h2>

<h3 id="커맨드홀더객체는-소유객체composite객체의-메멘토상태정보를-관리하는-caretaker역할을-하여-저장컬렉션-필드를-가진다">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4%EB%8A%94-%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4composite%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%A9%94%EB%A9%98%ED%86%A0%EC%83%81%ED%83%9C%EC%A0%95%EB%B3%B4%EB%A5%BC-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-caretaker%EC%97%AD%ED%95%A0%EC%9D%84-%ED%95%98%EC%97%AC-%EC%A0%80%EC%9E%A5%EC%BB%AC%EB%A0%89%EC%85%98-%ED%95%84%EB%93%9C%EB%A5%BC-%EA%B0%80%EC%A7%84%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드홀더객체는 소유객체(Composite객체)의 메멘토(상태정보)를 관리하는 CareTaker역할을 하여 저장컬렉션 필드를 가진다.</h3>

<h4 id="고전에는-stack으로-관리하지만-여기서는-map으로-한다-map의-key는-주로-string으로-받는다-save는-json으로-저장될-메멘토라서-string으로-저장한다">
<a class="anchor" href="#%EA%B3%A0%EC%A0%84%EC%97%90%EB%8A%94-stack%EC%9C%BC%EB%A1%9C-%EA%B4%80%EB%A6%AC%ED%95%98%EC%A7%80%EB%A7%8C-%EC%97%AC%EA%B8%B0%EC%84%9C%EB%8A%94-map%EC%9C%BC%EB%A1%9C-%ED%95%9C%EB%8B%A4-map%EC%9D%98-key%EB%8A%94-%EC%A3%BC%EB%A1%9C-string%EC%9C%BC%EB%A1%9C-%EB%B0%9B%EB%8A%94%EB%8B%A4-save%EB%8A%94-json%EC%9C%BC%EB%A1%9C-%EC%A0%80%EC%9E%A5%EB%90%A0-%EB%A9%94%EB%A9%98%ED%86%A0%EB%9D%BC%EC%84%9C-string%EC%9C%BC%EB%A1%9C-%EC%A0%80%EC%9E%A5%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>고전에는 Stack으로 관리하지만, 여기서는 Map으로 한다. map의 key는 주로 string으로 받는다. save는 json으로 저장될 메멘토라서 string으로 저장한다.</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812123737095.png" alt="image-20220812123737095"></p>

<h3 id="메멘토-관리자-커맨드홀더는-save와-load함수를-가지며-void-save-string-load-시그니쳐부터-작성한다">
<a class="anchor" href="#%EB%A9%94%EB%A9%98%ED%86%A0-%EA%B4%80%EB%A6%AC%EC%9E%90-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EB%8A%94-save%EC%99%80-load%ED%95%A8%EC%88%98%EB%A5%BC-%EA%B0%80%EC%A7%80%EB%A9%B0-void-save-string-load-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B3%90%EB%B6%80%ED%84%B0-%EC%9E%91%EC%84%B1%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>메멘토 관리자 커맨드홀더는, save와 load함수를 가지며, void save, String load 시그니쳐부터 작성한다.</h3>

<h4 id="save시-저장할-string-key를-외부에서-받고-load로-꺼낼-때도-key를-받는다">
<a class="anchor" href="#save%EC%8B%9C-%EC%A0%80%EC%9E%A5%ED%95%A0-string-key%EB%A5%BC-%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-%EB%B0%9B%EA%B3%A0-load%EB%A1%9C-%EA%BA%BC%EB%82%BC-%EB%95%8C%EB%8F%84-key%EB%A5%BC-%EB%B0%9B%EB%8A%94%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>save시 저장할 string key를 외부에서 받고, load로 꺼낼 때도 key를 받는다.</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812124146329.png" alt="image-20220812124146329"></p>

<h3 id="save는-renderer와-jsonvisitor를-활용해서-만든다">
<a class="anchor" href="#save%EB%8A%94-renderer%EC%99%80-jsonvisitor%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%B4%EC%84%9C-%EB%A7%8C%EB%93%A0%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>Save는 Renderer와 JsonVisitor를 활용해서 만든다.</h3>

<h4 id="제어역전한-renderer-생성자주입되어-제어를-타는-전략객체-visitor-메서드인자로-들어가는-데이터객체composite-report의-역할을-변경해야한다">
<a class="anchor" href="#%EC%A0%9C%EC%96%B4%EC%97%AD%EC%A0%84%ED%95%9C-renderer-%EC%83%9D%EC%84%B1%EC%9E%90%EC%A3%BC%EC%9E%85%EB%90%98%EC%96%B4-%EC%A0%9C%EC%96%B4%EB%A5%BC-%ED%83%80%EB%8A%94-%EC%A0%84%EB%9E%B5%EA%B0%9D%EC%B2%B4-visitor-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%B8%EC%9E%90%EB%A1%9C-%EB%93%A4%EC%96%B4%EA%B0%80%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%9D%EC%B2%B4composite-report%EC%9D%98-%EC%97%AD%ED%95%A0%EC%9D%84-%EB%B3%80%EA%B2%BD%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>제어역전한 Renderer, 생성자주입되어 제어를 타는 전략객체 Visitor, 메서드인자로 들어가는 데이터객체(Composite-&gt;report)의 역할을 변경해야한다</h4>

<ol>
  <li>
    <p>실질적으로 전략 중 하나로서 <strong>Composite객체를 메서드 인자로받아, Renderer부터 Composite객체 제어로직을 위임받은 JsonVisitor의 역할</strong>이</p>

    <ul>
      <li>
        <p>현재는 <strong>Composite객체의 데이터</strong>를  json형태로 만들어서, <strong>콘솔에 출력하는 상황</strong>이다.</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812124544994.png" alt="image-20220812124544994"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812124601092.png" alt="image-20220812124601092"></p>
      </li>
      <li>
        <p><strong>출력이 아니라 <code class="language-plaintext highlighter-rouge">string으로 모아서 반환해주도록 변경</code>해야한다</strong></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>최종적으로 <code class="language-plaintext highlighter-rouge">Renderer가 render함수를 통해 데이터 객체의 제어 처리</code>하므로 <code class="language-plaintext highlighter-rouge">JsonVisitor를 태운 renderer</code>는 출력이 아닌 <code class="language-plaintext highlighter-rouge">데이터객체 + 제어 시 string을 모아서 반환</code>하게 하고, 이것을 이용해 <code class="language-plaintext highlighter-rouge">save</code>해야한다</strong></p>

    <ul>
      <li>
        <p>ConsoleVisitor만, 데이터객체를 제어를 태우면서 출력</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812124942863.png" alt="image-20220812124942863"></p>
      </li>
      <li>
        <p><strong>JsonVisitor는, 데이터객체를 제어를 태우면서 String반환</strong></p>
      </li>
    </ul>
  </li>
</ol>

<h4 id="renderer는-제어만-역전해서-visitor에게-제어로직을-위임해주는-void메서드만-제공한다-뭔가를-반환안해준다">
<a class="anchor" href="#renderer%EB%8A%94-%EC%A0%9C%EC%96%B4%EB%A7%8C-%EC%97%AD%EC%A0%84%ED%95%B4%EC%84%9C-visitor%EC%97%90%EA%B2%8C-%EC%A0%9C%EC%96%B4%EB%A1%9C%EC%A7%81%EC%9D%84-%EC%9C%84%EC%9E%84%ED%95%B4%EC%A3%BC%EB%8A%94-void%EB%A9%94%EC%84%9C%EB%93%9C%EB%A7%8C-%EC%A0%9C%EA%B3%B5%ED%95%9C%EB%8B%A4-%EB%AD%94%EA%B0%80%EB%A5%BC-%EB%B0%98%ED%99%98%EC%95%88%ED%95%B4%EC%A4%80%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>Renderer는 [제어만 역전해서 visitor에게 제어로직을 위임해주는 void메서드]만 제공한다. 뭔가를 반환안해준다.</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812125320309.png" alt="image-20220812125320309"></p>

<h4 id="전략visitor들은-renderer제어역전클래스에-주입되서--데이터객체를-메서드인자로-위임받아-자기-전략메서드들에서-사용하지만--제어처리-전략메서드들도-다-void이다-뭔가를-반환안해준다">
<a class="anchor" href="#%EC%A0%84%EB%9E%B5visitor%EB%93%A4%EC%9D%80-renderer%EC%A0%9C%EC%96%B4%EC%97%AD%EC%A0%84%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90-%EC%A3%BC%EC%9E%85%EB%90%98%EC%84%9C--%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%B8%EC%9E%90%EB%A1%9C-%EC%9C%84%EC%9E%84%EB%B0%9B%EC%95%84-%EC%9E%90%EA%B8%B0-%EC%A0%84%EB%9E%B5%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80%EB%A7%8C--%EC%A0%9C%EC%96%B4%EC%B2%98%EB%A6%AC-%EC%A0%84%EB%9E%B5%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4%EB%8F%84-%EB%8B%A4-void%EC%9D%B4%EB%8B%A4-%EB%AD%94%EA%B0%80%EB%A5%BC-%EB%B0%98%ED%99%98%EC%95%88%ED%95%B4%EC%A4%80%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>전략Visitor들은, Renderer(제어역전)클래스에 주입되서,  데이터객체를 메서드인자로 위임받아, 자기 전략메서드들에서 사용하지만,  [제어처리 전략메서드들도 다 void]이다. 뭔가를 반환안해준다</h4>

<ul>
  <li>
    <p>Renderer속 Visitor</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812125456303.png" alt="image-20220812125456303"></p>
  </li>
  <li>
    <p>Visitor인터페이스</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812125516950.png" alt="image-20220812125516950"></p>
  </li>
</ul>

<h4 id="출력관련-제어역전renderer와-visitor-전략오퍼레이터들은-모두-void로-정의해놓고-구상-전략객체들이-데이터출력-제어로직을-담당한다">
<a class="anchor" href="#%EC%B6%9C%EB%A0%A5%EA%B4%80%EB%A0%A8-%EC%A0%9C%EC%96%B4%EC%97%AD%EC%A0%84renderer%EC%99%80-visitor-%EC%A0%84%EB%9E%B5%EC%98%A4%ED%8D%BC%EB%A0%88%EC%9D%B4%ED%84%B0%EB%93%A4%EC%9D%80-%EB%AA%A8%EB%91%90-void%EB%A1%9C-%EC%A0%95%EC%9D%98%ED%95%B4%EB%86%93%EA%B3%A0-%EA%B5%AC%EC%83%81-%EC%A0%84%EB%9E%B5%EA%B0%9D%EC%B2%B4%EB%93%A4%EC%9D%B4-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%B6%9C%EB%A0%A5-%EC%A0%9C%EC%96%B4%EB%A1%9C%EC%A7%81%EC%9D%84-%EB%8B%B4%EB%8B%B9%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>출력관련 제어역전Renderer와, Visitor 전략오퍼레이터들은 모두 void로 정의해놓고, [구상 전략객체들이 데이터+출력 제어로직을 담당]한다</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812125753628.png" alt="image-20220812125753628"></p>

<h3 id="구상-visitor들은-위임받은-데이터-객체를-처리할-때-싸이클을-타면서-처리한-정보를-구상-객체context로서-필드에-저장해놨다가-차후-getter로-제공해줄-수-있다">
<a class="anchor" href="#%EA%B5%AC%EC%83%81-visitor%EB%93%A4%EC%9D%80-%EC%9C%84%EC%9E%84%EB%B0%9B%EC%9D%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%B2%98%EB%A6%AC%ED%95%A0-%EB%95%8C-%EC%8B%B8%EC%9D%B4%ED%81%B4%EC%9D%84-%ED%83%80%EB%A9%B4%EC%84%9C-%EC%B2%98%EB%A6%AC%ED%95%9C-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EA%B5%AC%EC%83%81-%EA%B0%9D%EC%B2%B4context%EB%A1%9C%EC%84%9C-%ED%95%84%EB%93%9C%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%B4%EB%86%A8%EB%8B%A4%EA%B0%80-%EC%B0%A8%ED%9B%84-getter%EB%A1%9C-%EC%A0%9C%EA%B3%B5%ED%95%B4%EC%A4%84-%EC%88%98-%EC%9E%88%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>구상 Visitor들은 [위임받은 데이터 객체를 처리]할 때, [싸이클을 타면서 처리한 정보를, 구상 객체context로서 필드에 저장]해놨다가, [차후 getter로 제공]해줄 수 있다.</h3>

<h4 id="출력-rendering관련-제어로직들은-다-void로-시작한다-visitor가-싸이클을-타면서-처리된-정보를-구상-vsititor전략객체마다-저장하고-싶은-데이터개체-처리정보는-상태값으로-저장으로-일단-저장해서-품고-있자">
<a class="anchor" href="#%EC%B6%9C%EB%A0%A5-rendering%EA%B4%80%EB%A0%A8-%EC%A0%9C%EC%96%B4%EB%A1%9C%EC%A7%81%EB%93%A4%EC%9D%80-%EB%8B%A4-void%EB%A1%9C-%EC%8B%9C%EC%9E%91%ED%95%9C%EB%8B%A4-visitor%EA%B0%80-%EC%8B%B8%EC%9D%B4%ED%81%B4%EC%9D%84-%ED%83%80%EB%A9%B4%EC%84%9C-%EC%B2%98%EB%A6%AC%EB%90%9C-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EA%B5%AC%EC%83%81-vsititor%EC%A0%84%EB%9E%B5%EA%B0%9D%EC%B2%B4%EB%A7%88%EB%8B%A4-%EC%A0%80%EC%9E%A5%ED%95%98%EA%B3%A0-%EC%8B%B6%EC%9D%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%9C%EC%B2%B4-%EC%B2%98%EB%A6%AC%EC%A0%95%EB%B3%B4%EB%8A%94-%EC%83%81%ED%83%9C%EA%B0%92%EC%9C%BC%EB%A1%9C-%EC%A0%80%EC%9E%A5%EC%9C%BC%EB%A1%9C-%EC%9D%BC%EB%8B%A8-%EC%A0%80%EC%9E%A5%ED%95%B4%EC%84%9C-%ED%92%88%EA%B3%A0-%EC%9E%88%EC%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>출력, rendering관련 제어로직들은 다 void로 시작한다. Visitor가 싸이클을 타면서, 처리된 정보를 [구상 Vsititor전략객체마다 저장하고 싶은 데이터개체 처리정보는 상태값으로 저장]으로 일단 저장해서 품고 있자!!</h4>

<ol>
  <li>
    <p>JsonVisitor에 <strong>제어 라이프싸이클을 타는 메서드들의 <code class="language-plaintext highlighter-rouge">처리결과를 모을 수 있는 상태 필드</code>를 추가하자</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812131846831.png" alt="image-20220812131846831"></p>
  </li>
  <li>
    <p>더이상 출력하지 않으므로, sout 와 padding부분을 삭제한다.</p>

    <ul>
      <li>
        <p>json을 출력안한다면, 공백문자열인 padding을 삭제해줘야한다.</p>
      </li>
      <li>
        <p>padding 관련 삭제</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/f6dcf6df-87c6-4d92-9100-8065db3ad2ef.gif" alt="f6dcf6df-87c6-4d92-9100-8065db3ad2ef"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812132146294.png" alt="image-20220812132146294"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>sout삭제</strong>하고 <strong><code class="language-plaintext highlighter-rouge">Visitor의 상태값</code>에 다가 stirng add로 모으기</strong></p>

    <ul>
      <li>
        <p>Visitor의 저장상태값은 final이면 안되겠구나! <strong>사이클타면서 계속 저장</strong>
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/f48f2af5-ac47-4626-b72f-a30ad8093e97.gif" alt="f48f2af5-ac47-4626-b72f-a30ad8093e97"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812132953555.png" alt="image-20220812132953555"></p>
      </li>
    </ul>
  </li>
</ol>

<h4 id="factory에-----new객체-지연생성--vs------외부생성객체-로컬변수-이미-생성된-객체-주입">
<a class="anchor" href="#factory%EC%97%90-----new%EA%B0%9D%EC%B2%B4-%EC%A7%80%EC%97%B0%EC%83%9D%EC%84%B1--vs------%EC%99%B8%EB%B6%80%EC%83%9D%EC%84%B1%EA%B0%9D%EC%B2%B4-%EB%A1%9C%EC%BB%AC%EB%B3%80%EC%88%98-%EC%9D%B4%EB%AF%B8-%EC%83%9D%EC%84%B1%EB%90%9C-%EA%B0%9D%EC%B2%B4-%EC%A3%BC%EC%9E%85" aria-hidden="true"><span class="octicon octicon-link"></span></a>factory에 ( () -&gt; new객체) 지연생성  vs  ( () -&gt; 외부생성객체 로컬변수) 이미 생성된 객체 주입</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220802130921137.png" alt="image-20220802130921137"></p>

<h5 id="my-함수형-인터페이스-factory지연생성으로-주입하는-이유는-가상인자-람다식을-통한-구현시-new-때리는-것을--넣어-지연생성할-수도-있지만-이미-외부에서-생성된-객체를-주입도-선택가능하기-때문이다">
<a class="anchor" href="#my-%ED%95%A8%EC%88%98%ED%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-factory%EC%A7%80%EC%97%B0%EC%83%9D%EC%84%B1%EC%9C%BC%EB%A1%9C-%EC%A3%BC%EC%9E%85%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EB%8A%94-%EA%B0%80%EC%83%81%EC%9D%B8%EC%9E%90-%EB%9E%8C%EB%8B%A4%EC%8B%9D%EC%9D%84-%ED%86%B5%ED%95%9C-%EA%B5%AC%ED%98%84%EC%8B%9C-new-%EB%95%8C%EB%A6%AC%EB%8A%94-%EA%B2%83%EC%9D%84--%EB%84%A3%EC%96%B4-%EC%A7%80%EC%97%B0%EC%83%9D%EC%84%B1%ED%95%A0-%EC%88%98%EB%8F%84-%EC%9E%88%EC%A7%80%EB%A7%8C-%EC%9D%B4%EB%AF%B8-%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-%EC%83%9D%EC%84%B1%EB%90%9C-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%A3%BC%EC%9E%85%EB%8F%84-%EC%84%A0%ED%83%9D%EA%B0%80%EB%8A%A5%ED%95%98%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%9D%B4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>my) 함수형 인터페이스 factory(지연생성)으로 주입하는 이유는 [가상인자 람다식을 통한 구현]시 [new 때리는 것을  넣어 지연생성]할 수도 있지만, [이미 외부에서 생성된 객체를 주입]도 선택가능하기 때문이다.</h5>

<h3 id="상태값을-가지는-visitor는-더이상-reneder-속-factory로-주입---내부에서-new때려서-생성-후-처리하고-소멸해서는-안된다">
<a class="anchor" href="#%EC%83%81%ED%83%9C%EA%B0%92%EC%9D%84-%EA%B0%80%EC%A7%80%EB%8A%94-visitor%EB%8A%94-%EB%8D%94%EC%9D%B4%EC%83%81-reneder-%EC%86%8D-factory%EB%A1%9C-%EC%A3%BC%EC%9E%85---%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-new%EB%95%8C%EB%A0%A4%EC%84%9C-%EC%83%9D%EC%84%B1-%ED%9B%84-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B3%A0-%EC%86%8C%EB%A9%B8%ED%95%B4%EC%84%9C%EB%8A%94-%EC%95%88%EB%90%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>상태값을 가지는 Visitor는 더이상 [Reneder 속 factory로 주입 -&gt; 내부에서 new때려서 생성 후 처리하고 소멸]해서는 안된다.</h3>

<h4 id="save에-필요한-정보를-이미-생성한-jsonvisitor가-renderer의-싸이클을-타고와서-getter로-제공해줄-것이다">
<a class="anchor" href="#save%EC%97%90-%ED%95%84%EC%9A%94%ED%95%9C-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EC%9D%B4%EB%AF%B8-%EC%83%9D%EC%84%B1%ED%95%9C-jsonvisitor%EA%B0%80-renderer%EC%9D%98-%EC%8B%B8%EC%9D%B4%ED%81%B4%EC%9D%84-%ED%83%80%EA%B3%A0%EC%99%80%EC%84%9C-getter%EB%A1%9C-%EC%A0%9C%EA%B3%B5%ED%95%B4%EC%A4%84-%EA%B2%83%EC%9D%B4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>save에 필요한 정보를 이미 생성한 JsonVisitor가 renderer의 싸이클을 타고와서 getter로 제공해줄 것이다.</h4>

<ul>
  <li>
<strong>JsonVisitor는 상태값을 가지는 순간부터, [외부 미리 생성 -&gt; 싸이클 태워 상태값에 정보채우기 -&gt; 외부에서 getter로 채운 데이터 사용]이 가능</strong>하다</li>
</ul>

<h4 id="renderer--jsonvisitor를-커맨드홀더객체-속-메멘토-save메서드로-가져와-정보-싸이클태워-출력대신-상태값-저장된-정보를-getter로-제공해준다">
<a class="anchor" href="#renderer--jsonvisitor%EB%A5%BC-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4-%EC%86%8D-%EB%A9%94%EB%A9%98%ED%86%A0-save%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EA%B0%80%EC%A0%B8%EC%99%80-%EC%A0%95%EB%B3%B4-%EC%8B%B8%EC%9D%B4%ED%81%B4%ED%83%9C%EC%9B%8C-%EC%B6%9C%EB%A0%A5%EB%8C%80%EC%8B%A0-%EC%83%81%ED%83%9C%EA%B0%92-%EC%A0%80%EC%9E%A5%EB%90%9C-%EC%A0%95%EB%B3%B4%EB%A5%BC-getter%EB%A1%9C-%EC%A0%9C%EA%B3%B5%ED%95%B4%EC%A4%80%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>renderer + jsonvisitor를 커맨드홀더객체 속 메멘토 save메서드로 가져와 정보, 싸이클태워, 출력대신 상태값 저장된 정보를 getter로 제공해준다.</h4>

<ol>
  <li>
    <p>Main에서 출력에 사용됬던 Renderer + Visitor 사용코드를 CommandMenu#save메서드로 가져온다</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/5c30774b-dc9e-420f-b16b-3fa7d8eb9341.gif" alt="5c30774b-dc9e-420f-b16b-3fa7d8eb9341"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812134503073.png" alt="image-20220812134503073"></p>

    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">Renderer와 Visitor는 이제 커맨드홀더객체의 내부생성 의존도</code>를 가지게 된다.</strong></li>
    </ul>
  </li>
  <li>
    <p><strong>JsonVistor를 Renderer에 주입해서 싸이클을 태우도록 변경</strong>한 뒤, <strong><code class="language-plaintext highlighter-rouge">Renderer 내부 지연생성이 아니라, 외부에서 미리 생성된 jsonVisitor</code>를 지역변수로 빼서, 넣어준다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/64c4c348-ac60-4692-a970-ecdc73e46db8.gif" alt="64c4c348-ac60-4692-a970-ecdc73e46db8"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812134917250.png" alt="image-20220812134917250"></p>
  </li>
</ol>

<h4 id="참고-지연실행을-위한-람다식-속-지역변수는-inline하면-안된다">
<a class="anchor" href="#%EC%B0%B8%EA%B3%A0-%EC%A7%80%EC%97%B0%EC%8B%A4%ED%96%89%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%9E%8C%EB%8B%A4%EC%8B%9D-%EC%86%8D-%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98%EB%8A%94-inline%ED%95%98%EB%A9%B4-%EC%95%88%EB%90%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>참고) 지연실행을 위한 람다식 속 지역변수는 inline하면 안된다!</h4>

<ul>
  <li>람다식에서 생성식이 있다? -&gt; <strong>지연실행이 -&gt; 지연생성</strong>이다. -&gt; <strong>지연생성은 내부생성이며 -&gt; 내부에서 소멸되는 <code class="language-plaintext highlighter-rouge">상태값 정보가 외부에서 필요없는 유틸성 메서드만 가진다</code></strong>
</li>
  <li>**람다식에 이미 생성된 객체를 넣어준다? -&gt; **
    <ul>
      <li>**<code class="language-plaintext highlighter-rouge">구상체 중 지연생성 == 내부생성</code>하는 <code class="language-plaintext highlighter-rouge">유틸성, 상태값없는 객체</code>도 있지만, **</li>
      <li>
<strong><code class="language-plaintext highlighter-rouge">다른 구상체는 외부에서 미리 생성해서 내부에서 처리되며, 상태값에 정보를 저장</code>하는 과정을 거치게 된다.</strong>
        <ul>
          <li>이것을 인라인해버리면… 내부생성으로 바뀐다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="참고2-커맨드홀더객체는-main에서-생성한-컴포짓-root객체를-소유한다-그래서-save속-renderer에-필요한-report를-만들-때-root인-소유객체필드composite필드로-만든다">
<a class="anchor" href="#%EC%B0%B8%EA%B3%A02-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4%EB%8A%94-main%EC%97%90%EC%84%9C-%EC%83%9D%EC%84%B1%ED%95%9C-%EC%BB%B4%ED%8F%AC%EC%A7%93-root%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%86%8C%EC%9C%A0%ED%95%9C%EB%8B%A4-%EA%B7%B8%EB%9E%98%EC%84%9C-save%EC%86%8D-renderer%EC%97%90-%ED%95%84%EC%9A%94%ED%95%9C-report%EB%A5%BC-%EB%A7%8C%EB%93%A4-%EB%95%8C-root%EC%9D%B8-%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4%ED%95%84%EB%93%9Ccomposite%ED%95%84%EB%93%9C%EB%A1%9C-%EB%A7%8C%EB%93%A0%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>참고2) 커맨드홀더객체는 Main에서 생성한 [컴포짓 root객체]를 소유한다. 그래서 save속 renderer에 필요한 report를 만들 때, root인 소유객체필드(Composite필드)로 만든다.</h4>

<ul>
  <li>
    <p>Main 속 root 객체 -&gt; report생성 -&gt; renderer가 태움</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812135651667.png" alt="image-20220812135651667"></p>
  </li>
  <li>
    <p><strong>save 속 compoiste소유객체 -&gt; report 생성에 사용 -&gt; renderer에 사용</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812135724238.png" alt="image-20220812135724238"></p>
  </li>
</ul>

<h5 id="my-지연생성은-내부에서-new때려서-생성하는-것과-동일하다-상태값-없는-불변객체-생성시-이렇게-한다-그러나-어떤-구상체는-상태값을-가지고-내부에서-처리된-후-변경된-상태--새로운-정보를-외부에-제공할-수-도-있다-지연생성-람다식에---이미-생성된-객체를-넣어줘서-내부로직이-끝난-후에도-정보가-외부지역변수-속-객체는-정보를-가지고-있게-된다">
<a class="anchor" href="#my-%EC%A7%80%EC%97%B0%EC%83%9D%EC%84%B1%EC%9D%80-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-new%EB%95%8C%EB%A0%A4%EC%84%9C-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EA%B2%83%EA%B3%BC-%EB%8F%99%EC%9D%BC%ED%95%98%EB%8B%A4-%EC%83%81%ED%83%9C%EA%B0%92-%EC%97%86%EB%8A%94-%EB%B6%88%EB%B3%80%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EC%8B%9C-%EC%9D%B4%EB%A0%87%EA%B2%8C-%ED%95%9C%EB%8B%A4-%EA%B7%B8%EB%9F%AC%EB%82%98-%EC%96%B4%EB%96%A4-%EA%B5%AC%EC%83%81%EC%B2%B4%EB%8A%94-%EC%83%81%ED%83%9C%EA%B0%92%EC%9D%84-%EA%B0%80%EC%A7%80%EA%B3%A0-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EC%B2%98%EB%A6%AC%EB%90%9C-%ED%9B%84-%EB%B3%80%EA%B2%BD%EB%90%9C-%EC%83%81%ED%83%9C--%EC%83%88%EB%A1%9C%EC%9A%B4-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EC%99%B8%EB%B6%80%EC%97%90-%EC%A0%9C%EA%B3%B5%ED%95%A0-%EC%88%98-%EB%8F%84-%EC%9E%88%EB%8B%A4-%EC%A7%80%EC%97%B0%EC%83%9D%EC%84%B1-%EB%9E%8C%EB%8B%A4%EC%8B%9D%EC%97%90---%EC%9D%B4%EB%AF%B8-%EC%83%9D%EC%84%B1%EB%90%9C-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%84%A3%EC%96%B4%EC%A4%98%EC%84%9C-%EB%82%B4%EB%B6%80%EB%A1%9C%EC%A7%81%EC%9D%B4-%EB%81%9D%EB%82%9C-%ED%9B%84%EC%97%90%EB%8F%84-%EC%A0%95%EB%B3%B4%EA%B0%80-%EC%99%B8%EB%B6%80%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98-%EC%86%8D-%EA%B0%9D%EC%B2%B4%EB%8A%94-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%9E%88%EA%B2%8C-%EB%90%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>my) 지연생성은 내부에서 new때려서 생성하는 것과 동일하다. 상태값 없는 불변객체 생성시 이렇게 한다. 그러나 어떤 구상체는 상태값을 가지고, 내부에서 처리된 후 [변경된 상태] == [새로운 정보]를 외부에 제공할 수 도 있다. [지연생성 람다식에 -&gt; 이미 생성된 객체]를 넣어줘서, 내부로직이 끝난 후에도 정보가 외부지역변수 속 객체는 정보를 가지고 있게 된다.</h5>

<h4 id="외부미리-생성된-뒤-싸이클을-타는-visitor객체는-싸이클을타며-저장한-상태필드-속-정보를-getter로-제공해줘야한다">
<a class="anchor" href="#%EC%99%B8%EB%B6%80%EB%AF%B8%EB%A6%AC-%EC%83%9D%EC%84%B1%EB%90%9C-%EB%92%A4-%EC%8B%B8%EC%9D%B4%ED%81%B4%EC%9D%84-%ED%83%80%EB%8A%94-visitor%EA%B0%9D%EC%B2%B4%EB%8A%94-%EC%8B%B8%EC%9D%B4%ED%81%B4%EC%9D%84%ED%83%80%EB%A9%B0-%EC%A0%80%EC%9E%A5%ED%95%9C-%EC%83%81%ED%83%9C%ED%95%84%EB%93%9C-%EC%86%8D-%EC%A0%95%EB%B3%B4%EB%A5%BC-getter%EB%A1%9C-%EC%A0%9C%EA%B3%B5%ED%95%B4%EC%A4%98%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>외부미리 생성된 뒤, 싸이클을 타는 Visitor객체는 싸이클을타며 저장한 상태필드 속 정보를 getter로 제공해줘야한다.</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/0c99b1e8-65d9-438c-9361-c37c7e05bdaa.gif" alt="0c99b1e8-65d9-438c-9361-c37c7e05bdaa"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812140058863.png" alt="image-20220812140058863"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812140042921.png" alt="image-20220812140042921"></p>

<h3 id="save내부-json만드는-일을-메서드추출하여-리팩토링하고-json만드는-일을-테스트하자">
<a class="anchor" href="#save%EB%82%B4%EB%B6%80-json%EB%A7%8C%EB%93%9C%EB%8A%94-%EC%9D%BC%EC%9D%84-%EB%A9%94%EC%84%9C%EB%93%9C%EC%B6%94%EC%B6%9C%ED%95%98%EC%97%AC-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81%ED%95%98%EA%B3%A0-json%EB%A7%8C%EB%93%9C%EB%8A%94-%EC%9D%BC%EC%9D%84-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EC%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>save내부 json만드는 일을 메서드추출하여 리팩토링하고, json만드는 일을 테스트하자</h3>

<h4 id="내수용-메서드추출시-내부context가-불변객체면-파라미터로-안빼도-된다">
<a class="anchor" href="#%EB%82%B4%EC%88%98%EC%9A%A9-%EB%A9%94%EC%84%9C%EB%93%9C%EC%B6%94%EC%B6%9C%EC%8B%9C-%EB%82%B4%EB%B6%80context%EA%B0%80-%EB%B6%88%EB%B3%80%EA%B0%9D%EC%B2%B4%EB%A9%B4-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A1%9C-%EC%95%88%EB%B9%BC%EB%8F%84-%EB%90%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>내수용 메서드추출시, 내부context가 불변객체면 파라미터로 안빼도 된다.</h4>

<ul>
  <li>
    <p>메서드 추출시 <strong><code class="language-plaintext highlighter-rouge">내부context(보라색)</code>이 불변 필드면, 굳이 파라미터로 추출안해도</strong> 된다!</p>

    <ul>
      <li><strong>만약, 다른객체에 위임할 예정이라면, 파라미터로 올려줘야한다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/fd4ed7f5-b458-40bb-a44d-551aadf7d564.gif" alt="fd4ed7f5-b458-40bb-a44d-551aadf7d564"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812140847628.png" alt="image-20220812140847628"></p>
  </li>
</ul>

<h4 id="create-json하는-일은-private내수용메서드다-테스트는-그대로-복사해가서-하고-지운다">
<a class="anchor" href="#create-json%ED%95%98%EB%8A%94-%EC%9D%BC%EC%9D%80-private%EB%82%B4%EC%88%98%EC%9A%A9%EB%A9%94%EC%84%9C%EB%93%9C%EB%8B%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8A%94-%EA%B7%B8%EB%8C%80%EB%A1%9C-%EB%B3%B5%EC%82%AC%ED%95%B4%EA%B0%80%EC%84%9C-%ED%95%98%EA%B3%A0-%EC%A7%80%EC%9A%B4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>create json하는 일은 private내수용메서드다. 테스트는 그대로 복사해가서 하고 지운다</h4>

<ul>
  <li>
    <p>테스트는 작성안하는 중이니 Main으로 복사해놓고</p>

    <ul>
      <li>static을 붙이고</li>
      <li><strong>필요한 context는 파라미터로 빼서, main내에서 공급받아 테스트한다</strong></li>
      <li>json출력을 확인하려면, <code class="language-plaintext highlighter-rouge">.json</code>파일을 만들어서, 자동정렬시켜보면 된다.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/24afe264-683c-46a2-a6f0-fa4ebaef114e.gif" alt="24afe264-683c-46a2-a6f0-fa4ebaef114e"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812162857539.png" alt="image-20220812162857539"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812162831307.png" alt="image-20220812162831307"></p>
  </li>
</ul>

<h3 id="생각해보기-3">
<a class="anchor" href="#%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EA%B8%B0-3" aria-hidden="true"><span class="octicon octicon-link"></span></a>생각해보기</h3>

<h4 id="memento패턴은-visitor패턴이-이미-구현되어있으면-쉽게-구현가능하다">
<a class="anchor" href="#memento%ED%8C%A8%ED%84%B4%EC%9D%80-visitor%ED%8C%A8%ED%84%B4%EC%9D%B4-%EC%9D%B4%EB%AF%B8-%EA%B5%AC%ED%98%84%EB%90%98%EC%96%B4%EC%9E%88%EC%9C%BC%EB%A9%B4-%EC%89%BD%EA%B2%8C-%EA%B5%AC%ED%98%84%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>memento패턴은, visitor패턴이 이미 구현되어있으면 쉽게 구현가능하다</h4>

<ol>
  <li>
    <p>Visitor패턴으로 <strong>데이터객체의 정보처리를 <code class="language-plaintext highlighter-rouge">Visitor의 상태값에 저장</code></strong>한다.</p>

    <ul>
      <li>Visitor는 출력관련 제어로직을 역전시킨 Renderer클래스에 주입되어</li>
      <li>출력관련 라이프싸이클을 타면서</li>
      <li>데이터객체를 인자로 받아 라이프싸이클 메서드 내부에서 제어로직을 처리한다</li>
      <li><strong>제어로직 처리가 출력 or 데이터를 모으는 과정이라면, <code class="language-plaintext highlighter-rouge">메서드마다 처리내용을 상태값에 저장</code>해놓으면 된다.</strong></li>
      <li><strong>한번 타고온 외부생성Visitor는 상태값에 가진 정보를 getter로 토해낸다</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812163436350.png" alt="image-20220812163436350"></p>
  </li>
  <li>
    <p><strong>Visitor가 Memento정보를 내부 상태값으로 가지고 있는 것</strong>이므로, <strong>데이터객체 홀더 객체(커맨드홀더객체) 내부에 save, load를 구현하는데, <code class="language-plaintext highlighter-rouge">save메서드에서 데이터객체 인자 + Visitor 생성자주입</code>으로 라이프싸이클 태우고 나온 <code class="language-plaintext highlighter-rouge">Visitor의 상태값</code>을 그대로 받아서, save할  컬렉션에 저장한다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812163450728.png" alt="image-20220812163450728"></p>
  </li>
</ol>

<h2 id="메멘토-패턴-load-구현jsonstring---root부터-자신setter--자식동적트리순회---composite객체-만들기">
<a class="anchor" href="#%EB%A9%94%EB%A9%98%ED%86%A0-%ED%8C%A8%ED%84%B4-load-%EA%B5%AC%ED%98%84jsonstring---root%EB%B6%80%ED%84%B0-%EC%9E%90%EC%8B%A0setter--%EC%9E%90%EC%8B%9D%EB%8F%99%EC%A0%81%ED%8A%B8%EB%A6%AC%EC%88%9C%ED%9A%8C---composite%EA%B0%9D%EC%B2%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>메멘토 패턴 load 구현(jsonString -&gt; root부터 자신setter + 자식동적트리순회 -&gt; composite객체 만들기)</h2>

<h3 id="load는-조회이므로-존재검증---조회---가져온-데이터의-postcondition검사까지-동시에-한다">
<a class="anchor" href="#load%EB%8A%94-%EC%A1%B0%ED%9A%8C%EC%9D%B4%EB%AF%80%EB%A1%9C-%EC%A1%B4%EC%9E%AC%EA%B2%80%EC%A6%9D---%EC%A1%B0%ED%9A%8C---%EA%B0%80%EC%A0%B8%EC%98%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-postcondition%EA%B2%80%EC%82%AC%EA%B9%8C%EC%A7%80-%EB%8F%99%EC%8B%9C%EC%97%90-%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>load는 조회이므로, [존재검증 -&gt; 조회 -&gt; 가져온 데이터의 postcondition검사]까지 동시에 한다.</h3>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812171906759.png" alt="image-20220812171906759"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812174319707.png" alt="image-20220812174319707"></p>

<ul>
  <li>
    <p>오타수정</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812192105685.png" alt="image-20220812192105685"></p>
  </li>
</ul>

<h3 id="load시-컴포짓객체의-생성은-커맨드홀드가-소유한-필드객체root-composite을-재활용해서-한다">
<a class="anchor" href="#load%EC%8B%9C-%EC%BB%B4%ED%8F%AC%EC%A7%93%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%83%9D%EC%84%B1%EC%9D%80-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%93%9C%EA%B0%80-%EC%86%8C%EC%9C%A0%ED%95%9C-%ED%95%84%EB%93%9C%EA%B0%9D%EC%B2%B4root-composite%EC%9D%84-%EC%9E%AC%ED%99%9C%EC%9A%A9%ED%95%B4%EC%84%9C-%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>load시 컴포짓객체의 생성은 커맨드홀드가 소유한 필드객체(root Composite)을 재활용해서 한다.</h3>

<h4 id="재활용하는-composite-root-객체는-자식들을-먼저-비워야한다-이-때-자식들도-자신내부의-자식들을-비워야하니-재귀---동적트리순회를-통한-삭제를-해야한다">
<a class="anchor" href="#%EC%9E%AC%ED%99%9C%EC%9A%A9%ED%95%98%EB%8A%94-composite-root-%EA%B0%9D%EC%B2%B4%EB%8A%94-%EC%9E%90%EC%8B%9D%EB%93%A4%EC%9D%84-%EB%A8%BC%EC%A0%80-%EB%B9%84%EC%9B%8C%EC%95%BC%ED%95%9C%EB%8B%A4-%EC%9D%B4-%EB%95%8C-%EC%9E%90%EC%8B%9D%EB%93%A4%EB%8F%84-%EC%9E%90%EC%8B%A0%EB%82%B4%EB%B6%80%EC%9D%98-%EC%9E%90%EC%8B%9D%EB%93%A4%EC%9D%84-%EB%B9%84%EC%9B%8C%EC%95%BC%ED%95%98%EB%8B%88-%EC%9E%AC%EA%B7%80---%EB%8F%99%EC%A0%81%ED%8A%B8%EB%A6%AC%EC%88%9C%ED%9A%8C%EB%A5%BC-%ED%86%B5%ED%95%9C-%EC%82%AD%EC%A0%9C%EB%A5%BC-%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>재활용하는 composite root 객체는 자식들을 먼저 비워야한다. 이 때, 자식들도 자신내부의 자식들을 비워야하니, [재귀 -&gt; 동적트리순회를 통한 삭제]를 해야한다.</h4>

<ol>
  <li>
    <p>재활용할 커맨드홀더객체 내부필드인 root composite객체에게 <strong>자식들을 삭제하라는 메세지를 보낸다.</strong></p>

    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">Composite객체 내부</code>에서 자식컬렉션을 지우는 작업이 이루어진다.</strong></li>
      <li>자신을 비우는 것은, <strong>생성시 setter를 사용할 예정이므로</strong> 안해도 된다.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812175140991.png" alt="image-20220812175140991"></p>
  </li>
</ol>

<h4 id="composite객체의-자식들-삭제는-자식의-자식들도-삭제되거야하는-동적트리-순회---재귀메서드가-된다">
<a class="anchor" href="#composite%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%9E%90%EC%8B%9D%EB%93%A4-%EC%82%AD%EC%A0%9C%EB%8A%94-%EC%9E%90%EC%8B%9D%EC%9D%98-%EC%9E%90%EC%8B%9D%EB%93%A4%EB%8F%84-%EC%82%AD%EC%A0%9C%EB%90%98%EA%B1%B0%EC%95%BC%ED%95%98%EB%8A%94-%EB%8F%99%EC%A0%81%ED%8A%B8%EB%A6%AC-%EC%88%9C%ED%9A%8C---%EC%9E%AC%EA%B7%80%EB%A9%94%EC%84%9C%EB%93%9C%EA%B0%80-%EB%90%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>composite객체의 자식들 삭제는 [자식의 자식들도 삭제되거야하는 동적트리 순회] -&gt; 재귀메서드가 된다.</h4>

<ol>
  <li>
    <p>외부에서 자식들 지우라고 메세지를 보냈지만, <strong>자식들의 자식들도 지워져야하므로 <code class="language-plaintext highlighter-rouge">composite객체의 삭제</code>역시, 동적트리순회를 통한 삭제 -&gt; 재귀메서드이다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812175353691.png" alt="image-20220812175353691"></p>
  </li>
</ol>

<h4 id="동적트리삭제-재귀메서드의-종착역으로서-삭제할-자식들이-없으면-ealry-return으로-종료한다-삭제-전-존재검증은-thr-없을-수-도-있는-것의-삭제는-early-return이다-">
<a class="anchor" href="#%EB%8F%99%EC%A0%81%ED%8A%B8%EB%A6%AC%EC%82%AD%EC%A0%9C-%EC%9E%AC%EA%B7%80%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%EC%A2%85%EC%B0%A9%EC%97%AD%EC%9C%BC%EB%A1%9C%EC%84%9C-%EC%82%AD%EC%A0%9C%ED%95%A0-%EC%9E%90%EC%8B%9D%EB%93%A4%EC%9D%B4-%EC%97%86%EC%9C%BC%EB%A9%B4-ealry-return%EC%9C%BC%EB%A1%9C-%EC%A2%85%EB%A3%8C%ED%95%9C%EB%8B%A4-%EC%82%AD%EC%A0%9C-%EC%A0%84-%EC%A1%B4%EC%9E%AC%EA%B2%80%EC%A6%9D%EC%9D%80-thr-%EC%97%86%EC%9D%84-%EC%88%98-%EB%8F%84-%EC%9E%88%EB%8A%94-%EA%B2%83%EC%9D%98-%EC%82%AD%EC%A0%9C%EB%8A%94-early-return%EC%9D%B4%EB%8B%A4-" aria-hidden="true"><span class="octicon octicon-link"></span></a>[동적트리삭제] 재귀메서드의 종착역으로서, [삭제할 자식들이 없으면 ealry return]으로 종료한다. (삭제 전 존재검증은 thr, [없을 수 도 있는 것의 삭제]는 early return이다. )</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/40fe9655-5141-4035-b515-73573fcac395.gif" alt="40fe9655-5141-4035-b515-73573fcac395"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812175655588.png" alt="image-20220812175655588"></p>

<ul>
  <li>
    <p>자식들 삭제를 위한 재귀에서, [자신의 처리] -&gt; [자식들 처리]의 호출만되고 삭제로직은 아직 없다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812175937239.png" alt="image-20220812175937239"></p>
  </li>
</ul>

<h4 id="자식들의-동적트리삭제는-자신의-차례에서-자식들삭제-로직을-넣어줘야한다-자식들을-동적트리순회하면서-호출하고-난-다음---끝처리로서-자식들-컬렉션필드를-clear-해준다">
<a class="anchor" href="#%EC%9E%90%EC%8B%9D%EB%93%A4%EC%9D%98-%EB%8F%99%EC%A0%81%ED%8A%B8%EB%A6%AC%EC%82%AD%EC%A0%9C%EB%8A%94-%EC%9E%90%EC%8B%A0%EC%9D%98-%EC%B0%A8%EB%A1%80%EC%97%90%EC%84%9C-%EC%9E%90%EC%8B%9D%EB%93%A4%EC%82%AD%EC%A0%9C-%EB%A1%9C%EC%A7%81%EC%9D%84-%EB%84%A3%EC%96%B4%EC%A4%98%EC%95%BC%ED%95%9C%EB%8B%A4-%EC%9E%90%EC%8B%9D%EB%93%A4%EC%9D%84-%EB%8F%99%EC%A0%81%ED%8A%B8%EB%A6%AC%EC%88%9C%ED%9A%8C%ED%95%98%EB%A9%B4%EC%84%9C-%ED%98%B8%EC%B6%9C%ED%95%98%EA%B3%A0-%EB%82%9C-%EB%8B%A4%EC%9D%8C---%EB%81%9D%EC%B2%98%EB%A6%AC%EB%A1%9C%EC%84%9C-%EC%9E%90%EC%8B%9D%EB%93%A4-%EC%BB%AC%EB%A0%89%EC%85%98%ED%95%84%EB%93%9C%EB%A5%BC-clear-%ED%95%B4%EC%A4%80%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>[자식들의 동적트리삭제]는 자신의 차례에서 [자식들삭제 로직]을 넣어줘야한다. [자식들을 동적트리순회하면서, 호출하고 난 다음] -&gt; 끝처리로서 [자식들 컬렉션필드를 .clear()] 해준다</h4>

<h5 id="자식들에게-피드백받는-재귀처리는-자식들을-살려놓고-돌린상태의--동적트리-or-자식재귀호출-1여러개-호출이-끝난-상태에서-끝처리로-자식들을-처리한다">
<a class="anchor" href="#%EC%9E%90%EC%8B%9D%EB%93%A4%EC%97%90%EA%B2%8C-%ED%94%BC%EB%93%9C%EB%B0%B1%EB%B0%9B%EB%8A%94-%EC%9E%AC%EA%B7%80%EC%B2%98%EB%A6%AC%EB%8A%94-%EC%9E%90%EC%8B%9D%EB%93%A4%EC%9D%84-%EC%82%B4%EB%A0%A4%EB%86%93%EA%B3%A0-%EB%8F%8C%EB%A6%B0%EC%83%81%ED%83%9C%EC%9D%98--%EB%8F%99%EC%A0%81%ED%8A%B8%EB%A6%AC-or-%EC%9E%90%EC%8B%9D%EC%9E%AC%EA%B7%80%ED%98%B8%EC%B6%9C-1%EC%97%AC%EB%9F%AC%EA%B0%9C-%ED%98%B8%EC%B6%9C%EC%9D%B4-%EB%81%9D%EB%82%9C-%EC%83%81%ED%83%9C%EC%97%90%EC%84%9C-%EB%81%9D%EC%B2%98%EB%A6%AC%EB%A1%9C-%EC%9E%90%EC%8B%9D%EB%93%A4%EC%9D%84-%EC%B2%98%EB%A6%AC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>자식들에게 피드백받는 재귀처리는, 자식들을 살려놓고 돌린상태의  [동적트리 or 자식재귀호출 1~여러개 호출]이 끝난 상태에서, [끝처리로 자식들을 처리]한다</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812180055145.png" alt="image-20220812180055145"></p>

<h4 id="리팩토링---load--자식들처리에서-load로직을-1개-메서드로-추출">
<a class="anchor" href="#%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81---load--%EC%9E%90%EC%8B%9D%EB%93%A4%EC%B2%98%EB%A6%AC%EC%97%90%EC%84%9C-load%EB%A1%9C%EC%A7%81%EC%9D%84-1%EA%B0%9C-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EC%B6%94%EC%B6%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>리팩토링 -&gt; load + 자식들처리에서 load로직을 1개 메서드로 추출</h4>

<h5 id="할당문이-포함된-로직에서-아직-할당된-지역변수가-뒤에-쓰이지-않았다면-return없이-추출된다---뒤에-억지로라도-써놓고-추출하면-편하다">
<a class="anchor" href="#%ED%95%A0%EB%8B%B9%EB%AC%B8%EC%9D%B4-%ED%8F%AC%ED%95%A8%EB%90%9C-%EB%A1%9C%EC%A7%81%EC%97%90%EC%84%9C-%EC%95%84%EC%A7%81-%ED%95%A0%EB%8B%B9%EB%90%9C-%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98%EA%B0%80-%EB%92%A4%EC%97%90-%EC%93%B0%EC%9D%B4%EC%A7%80-%EC%95%8A%EC%95%98%EB%8B%A4%EB%A9%B4-return%EC%97%86%EC%9D%B4-%EC%B6%94%EC%B6%9C%EB%90%9C%EB%8B%A4---%EB%92%A4%EC%97%90-%EC%96%B5%EC%A7%80%EB%A1%9C%EB%9D%BC%EB%8F%84-%EC%8D%A8%EB%86%93%EA%B3%A0-%EC%B6%94%EC%B6%9C%ED%95%98%EB%A9%B4-%ED%8E%B8%ED%95%98%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>할당문이 포함된 로직에서, 아직 할당된 지역변수가 뒤에 쓰이지 않았다면, return없이 추출된다. -&gt; 뒤에 억지로라도 써놓고 추출하면 편하다</h5>

<ul>
  <li>참고) 할당문 추출시, 뒤에 쓰이지도 않았는데, return한다? <strong>반복문 내 업데이트변수를 포함한 추출이다 -&gt; 어차피 외부에서 업데이트될테니, 가변변수 빼고 추출할 수 있도록 해보자.</strong>
</li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/ff784f4b-c42f-4d8f-a765-e1447cd5647e.gif" alt="ff784f4b-c42f-4d8f-a765-e1447cd5647e"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812180723286.png" alt="image-20220812180723286"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812180738951.png" alt="image-20220812180738951"></p>

<h2 id="json-string을-cursor도입하여-다음depth로-이동하면서-composite객체-재생성하기">
<a class="anchor" href="#json-string%EC%9D%84-cursor%EB%8F%84%EC%9E%85%ED%95%98%EC%97%AC-%EB%8B%A4%EC%9D%8Cdepth%EB%A1%9C-%EC%9D%B4%EB%8F%99%ED%95%98%EB%A9%B4%EC%84%9C-composite%EA%B0%9D%EC%B2%B4-%EC%9E%AC%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>json String을 cursor도입하여 다음depth로 이동하면서 Composite객체 재생성하기</h2>

<h3 id="load메서드내-jsonstring-파싱하는-복잡한-작업이-시작된다-디버깅하면서-내부로직을-만들기-위해-load한-json을-반환하도록-수정한-뒤-테스트에서-환경을-조성해-만들어나가자">
<a class="anchor" href="#load%EB%A9%94%EC%84%9C%EB%93%9C%EB%82%B4-jsonstring-%ED%8C%8C%EC%8B%B1%ED%95%98%EB%8A%94-%EB%B3%B5%EC%9E%A1%ED%95%9C-%EC%9E%91%EC%97%85%EC%9D%B4-%EC%8B%9C%EC%9E%91%EB%90%9C%EB%8B%A4-%EB%94%94%EB%B2%84%EA%B9%85%ED%95%98%EB%A9%B4%EC%84%9C-%EB%82%B4%EB%B6%80%EB%A1%9C%EC%A7%81%EC%9D%84-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%9C%84%ED%95%B4-load%ED%95%9C-json%EC%9D%84-%EB%B0%98%ED%99%98%ED%95%98%EB%8F%84%EB%A1%9D-%EC%88%98%EC%A0%95%ED%95%9C-%EB%92%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C-%ED%99%98%EA%B2%BD%EC%9D%84-%EC%A1%B0%EC%84%B1%ED%95%B4-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%82%98%EA%B0%80%EC%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>load메서드내 json(string) 파싱하는 복잡한 작업이 시작된다. 디버깅하면서 내부로직을 만들기 위해 load한 json을 반환하도록 수정한 뒤, 테스트에서 환경을 조성해 만들어나가자</h3>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/db6bedac-6e54-4def-86b5-7ec09032f498.gif" alt="db6bedac-6e54-4def-86b5-7ec09032f498"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812192208045.png" alt="image-20220812192208045"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812192141957.png" alt="image-20220812192141957"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812192317195.png" alt="image-20220812192317195"></p>

<h4 id="최소한-자식을-가지는-예제-json-string을-만들어둔다">
<a class="anchor" href="#%EC%B5%9C%EC%86%8C%ED%95%9C-%EC%9E%90%EC%8B%9D%EC%9D%84-%EA%B0%80%EC%A7%80%EB%8A%94-%EC%98%88%EC%A0%9C-json-string%EC%9D%84-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%91%94%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>최소한 자식을 가지는 예제 json String을 만들어둔다.</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/14155c0a-3e64-4b82-b269-da3d9b4e51fc.gif" alt="14155c0a-3e64-4b82-b269-da3d9b4e51fc"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812192820284.png" alt="image-20220812192820284"></p>

<h3 id="커맨드홀더객체-내-root자신부터-만들기-위해-데이터-추출-by-target-string--indexof--cursor--substring">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4-%EB%82%B4-root%EC%9E%90%EC%8B%A0%EB%B6%80%ED%84%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%9C%84%ED%95%B4-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B6%94%EC%B6%9C-by-target-string--indexof--cursor--substring" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드홀더객체 내, root자신부터 만들기 위해 데이터 추출 by target String + .indexOf() + cursor + .substring</h3>

<h4 id="01-찾고싶은-string속-data의-직전-string을--target변수로-추출한다-예제-jsonstring-복붙활용">
<a class="anchor" href="#01-%EC%B0%BE%EA%B3%A0%EC%8B%B6%EC%9D%80-string%EC%86%8D-data%EC%9D%98-%EC%A7%81%EC%A0%84-string%EC%9D%84--target%EB%B3%80%EC%88%98%EB%A1%9C-%EC%B6%94%EC%B6%9C%ED%95%9C%EB%8B%A4-%EC%98%88%EC%A0%9C-jsonstring-%EB%B3%B5%EB%B6%99%ED%99%9C%EC%9A%A9" aria-hidden="true"><span class="octicon octicon-link"></span></a>01 찾고싶은 string속 data의 직전 string을  target변수로 추출한다 (예제 jsonstring 복붙활용)</h4>

<ul>
  <li>title의 데이터를 찾기 위해 데이터 직전까지 중에 타겟string <code class="language-plaintext highlighter-rouge">title:  "</code>을 잡는다</li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/a94eda59-80eb-4b25-a3eb-a8b75e256101.gif" alt="a94eda59-80eb-4b25-a3eb-a8b75e256101"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812193341896.png" alt="image-20220812193341896"></p>

<h4 id="02-cursor을-0으로-초기화하고-indexof-string타겟-시작index에-쓰일-데이터추출시마다-업데이트되는-검색-시작인덱스로-사용한다">
<a class="anchor" href="#02-cursor%EC%9D%84-0%EC%9C%BC%EB%A1%9C-%EC%B4%88%EA%B8%B0%ED%99%94%ED%95%98%EA%B3%A0-indexof-string%ED%83%80%EA%B2%9F-%EC%8B%9C%EC%9E%91index%EC%97%90-%EC%93%B0%EC%9D%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%B6%94%EC%B6%9C%EC%8B%9C%EB%A7%88%EB%8B%A4-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%90%98%EB%8A%94-%EA%B2%80%EC%83%89-%EC%8B%9C%EC%9E%91%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>02 cursor을 0으로 초기화하고, index.Of( string타겟, 시작index)에 쓰일 [데이터추출시마다 업데이트되는 검색 시작인덱스]로 사용한다</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812193843458.png" alt="image-20220812193843458"></p>

<h4 id="03-indexof-target데이터직전까지의-문자열-cursor검색시작인덱스-을-통해---target-start-index를-찾는다---못찾는-경우--1을-반환하며-그-때-cursor도--1으로-업데이트한다">
<a class="anchor" href="#03-indexof-target%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A7%81%EC%A0%84%EA%B9%8C%EC%A7%80%EC%9D%98-%EB%AC%B8%EC%9E%90%EC%97%B4-cursor%EA%B2%80%EC%83%89%EC%8B%9C%EC%9E%91%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%9D%84-%ED%86%B5%ED%95%B4---target-start-index%EB%A5%BC-%EC%B0%BE%EB%8A%94%EB%8B%A4---%EB%AA%BB%EC%B0%BE%EB%8A%94-%EA%B2%BD%EC%9A%B0--1%EC%9D%84-%EB%B0%98%ED%99%98%ED%95%98%EB%A9%B0-%EA%B7%B8-%EB%95%8C-cursor%EB%8F%84--1%EC%9C%BC%EB%A1%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>03 .indexOf( target[데이터직전까지의 문자열], cursor[검색시작인덱스] )을 통해 -&gt; target start index를 찾는다. -&gt; 못찾는 경우 -1을 반환하며, 그 때 cursor도 -1으로 업데이트한다</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812225749243.png" alt="image-20220812225749243"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812225853761.png" alt="image-20220812225853761"></p>

<h4 id="04-target-start-index--targetlength-로-cursor-업데이트하여---cursor가-데이터시작점에-오도록-위치시킨다">
<a class="anchor" href="#04-target-start-index--targetlength-%EB%A1%9C-cursor-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%ED%95%98%EC%97%AC---cursor%EA%B0%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EC%9E%91%EC%A0%90%EC%97%90-%EC%98%A4%EB%8F%84%EB%A1%9D-%EC%9C%84%EC%B9%98%EC%8B%9C%ED%82%A8%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>04 target start index + target.length() 로 cursor 업데이트하여 -&gt; cursor가 데이터시작점에 오도록 위치시킨다.</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812230052240.png" alt="image-20220812230052240"></p>

<h4 id="05-data의-끝을-알려주는-target인-를-cursor데이터시작--1부터-indexof--로-찾아-data끝--1위치를-찾는다">
<a class="anchor" href="#05-data%EC%9D%98-%EB%81%9D%EC%9D%84-%EC%95%8C%EB%A0%A4%EC%A3%BC%EB%8A%94-target%EC%9D%B8-%EB%A5%BC-cursor%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%8B%9C%EC%9E%91--1%EB%B6%80%ED%84%B0-indexof--%EB%A1%9C-%EC%B0%BE%EC%95%84-data%EB%81%9D--1%EC%9C%84%EC%B9%98%EB%A5%BC-%EC%B0%BE%EB%8A%94%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>05 data의 끝을 알려주는 target인 <code class="language-plaintext highlighter-rouge">"</code>를 cursor(데이터시작) + 1부터 .indexOf( , )로 찾아, data끝 + 1위치를 찾는다.</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812230527294.png" alt="image-20220812230527294"></p>

<h4 id="06-data시작cursor--data끝1-까지를-substring을-통해-data만-추출한다">
<a class="anchor" href="#06-data%EC%8B%9C%EC%9E%91cursor--data%EB%81%9D1-%EA%B9%8C%EC%A7%80%EB%A5%BC-substring%EC%9D%84-%ED%86%B5%ED%95%B4-data%EB%A7%8C-%EC%B6%94%EC%B6%9C%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>06 data시작(cursor) ~ data끝+1 까지를 substring을 통해, data만 추출한다</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812230656351.png" alt="image-20220812230656351"></p>

<ul>
  <li>
    <p>title에 해당하는 데이터만 잘 추출되는지 확인한다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812230857316.png" alt="image-20220812230857316"></p>
  </li>
</ul>

<h4 id="07-data를-추출할-때까지-cursor의-움직임을-관찰하고--다음-target도-찾아본다">
<a class="anchor" href="#07-data%EB%A5%BC-%EC%B6%94%EC%B6%9C%ED%95%A0-%EB%95%8C%EA%B9%8C%EC%A7%80-cursor%EC%9D%98-%EC%9B%80%EC%A7%81%EC%9E%84%EC%9D%84-%EA%B4%80%EC%B0%B0%ED%95%98%EA%B3%A0--%EB%8B%A4%EC%9D%8C-target%EB%8F%84-%EC%B0%BE%EC%95%84%EB%B3%B8%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>07 data를 추출할 때까지, cursor의 움직임을 관찰하고,  다음 target도 찾아본다.</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812231645953.png" alt="image-20220812231645953"></p>

<ul>
  <li>cursor  <code class="language-plaintext highlighter-rouge">0</code> -&gt; <code class="language-plaintext highlighter-rouge">data시작위치</code>로 업데이트된다</li>
  <li>
<strong>다음은 직전data시작위치 -&gt; 다음data시작위치</strong>로 업데이트 될 것이다.</li>
</ul>

<h4 id="08-가변변수-cursor-초기화와-변수-초기화-부분은-제외하고-가변변수-업데이트-부분만-메서드-추출한다">
<a class="anchor" href="#08-%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98-cursor-%EC%B4%88%EA%B8%B0%ED%99%94%EC%99%80-%EB%B3%80%EC%88%98-%EC%B4%88%EA%B8%B0%ED%99%94-%EB%B6%80%EB%B6%84%EC%9D%80-%EC%A0%9C%EC%99%B8%ED%95%98%EA%B3%A0-%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EB%B6%80%EB%B6%84%EB%A7%8C-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%B6%94%EC%B6%9C%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>08 [가변변수 cursor 초기화]와 [변수 초기화] 부분은 제외하고 [가변변수 업데이트 부분만 메서드 추출]한다</h4>

<ul>
  <li>
<strong>가변변수 업데이트로서 벌써 1개의 메서드추출이 1개의 역할</strong>을 하고 있는 것이다.
    <ul>
      <li>가변변수가 로직에 포함되면, <strong>메서드 추출시, 가변변수 재할당업데이트 = 추출메서드()로 뽑히기 때문에, 그것부터 해결해야한다</strong>
</li>
    </ul>
  </li>
</ul>

<h5 id="가변변수는-외부에-두고-추출한-메서드가-반환한-값으로-외부-가변변수-업데이트하게-한다">
<a class="anchor" href="#%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98%EB%8A%94-%EC%99%B8%EB%B6%80%EC%97%90-%EB%91%90%EA%B3%A0-%EC%B6%94%EC%B6%9C%ED%95%9C-%EB%A9%94%EC%84%9C%EB%93%9C%EA%B0%80-%EB%B0%98%ED%99%98%ED%95%9C-%EA%B0%92%EC%9C%BC%EB%A1%9C-%EC%99%B8%EB%B6%80-%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%ED%95%98%EA%B2%8C-%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>가변변수는 외부에 두고 [추출한 메서드가 반환한 값]으로 [외부 가변변수 업데이트]하게 한다</h5>

<h5 id="가변변수는-외부에-두어-파라미터로-뽑히더라도-내부에서-다시-가변변수를-업데이트하고-그-가변변수를-return---외부에서-다시-업데이트도록-뽑힌다-어차피-외부에서-업데이트하도록-메서드-추출되므로-내부-메서드에서는-가변변수가-업데이트될-값만-return하도록-수정한다">
<a class="anchor" href="#%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98%EB%8A%94-%EC%99%B8%EB%B6%80%EC%97%90-%EB%91%90%EC%96%B4-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A1%9C-%EB%BD%91%ED%9E%88%EB%8D%94%EB%9D%BC%EB%8F%84-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EB%8B%A4%EC%8B%9C-%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98%EB%A5%BC-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%ED%95%98%EA%B3%A0-%EA%B7%B8-%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98%EB%A5%BC-return---%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-%EB%8B%A4%EC%8B%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%8F%84%EB%A1%9D-%EB%BD%91%ED%9E%8C%EB%8B%A4-%EC%96%B4%EC%B0%A8%ED%94%BC-%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%ED%95%98%EB%8F%84%EB%A1%9D-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%B6%94%EC%B6%9C%EB%90%98%EB%AF%80%EB%A1%9C-%EB%82%B4%EB%B6%80-%EB%A9%94%EC%84%9C%EB%93%9C%EC%97%90%EC%84%9C%EB%8A%94-%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98%EA%B0%80-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%90%A0-%EA%B0%92%EB%A7%8C-return%ED%95%98%EB%8F%84%EB%A1%9D-%EC%88%98%EC%A0%95%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>가변변수는 외부에 두어 파라미터로 뽑히더라도, 내부에서 다시 가변변수를 업데이트하고, 그 가변변수를 return -&gt; 외부에서 다시 업데이트도록 뽑힌다. [어차피 외부에서 업데이트하도록 메서드 추출]되므로 [내부 메서드에서는 가변변수가 업데이트될 값만 return]하도록 수정한다.</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812232610228.png" alt="image-20220812232610228"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812232755957.png" alt="image-20220812232755957"></p>

<ul>
  <li>어차피 외부에서 가변변수 재할당해서 업데이트되도록 메서드가 추출된다.
    <ul>
      <li><strong>내부에서는 가변변수 업데이트하여 반환안해도 된다. 그냥 업데이트할 값을 return하도록 수정하자</strong></li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812232537689.png" alt="image-20220812232537689"></p>

<h5 id="지역변수-초기화-부분은-외부에-두고-추출한메서드의-파라미터로-입력되도록-외부에서-다른-값으로-초기화해도-사용할-수-있는-메서드로-만든다">
<a class="anchor" href="#%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98-%EC%B4%88%EA%B8%B0%ED%99%94-%EB%B6%80%EB%B6%84%EC%9D%80-%EC%99%B8%EB%B6%80%EC%97%90-%EB%91%90%EA%B3%A0-%EC%B6%94%EC%B6%9C%ED%95%9C%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A1%9C-%EC%9E%85%EB%A0%A5%EB%90%98%EB%8F%84%EB%A1%9D-%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-%EB%8B%A4%EB%A5%B8-%EA%B0%92%EC%9C%BC%EB%A1%9C-%EC%B4%88%EA%B8%B0%ED%99%94%ED%95%B4%EB%8F%84-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EB%A7%8C%EB%93%A0%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>지역변수 초기화 부분은 외부에 두고 [추출한메서드의 파라미터로 입력]되도록 [외부에서 다른 값으로 초기화해도 사용할 수 있는 메서드]로 만든다.</h5>

<ul>
  <li>추출하면, 해당 지역변수값만 쓸 수 있는 것처럼 나온다
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812232953503.png" alt="image-20220812232953503">
</li>
</ul>

<h5 id="변수초기화관련-메서드추출에서-지역변수---추출메서드-인자의-과정을-inline으로-바꾸는-순간-특정-지역변수with초기화없이-다른-값을-대입할-수-있게-된다">
<a class="anchor" href="#%EB%B3%80%EC%88%98%EC%B4%88%EA%B8%B0%ED%99%94%EA%B4%80%EB%A0%A8-%EB%A9%94%EC%84%9C%EB%93%9C%EC%B6%94%EC%B6%9C%EC%97%90%EC%84%9C-%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98---%EC%B6%94%EC%B6%9C%EB%A9%94%EC%84%9C%EB%93%9C-%EC%9D%B8%EC%9E%90%EC%9D%98-%EA%B3%BC%EC%A0%95%EC%9D%84-inline%EC%9C%BC%EB%A1%9C-%EB%B0%94%EA%BE%B8%EB%8A%94-%EC%88%9C%EA%B0%84-%ED%8A%B9%EC%A0%95-%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98with%EC%B4%88%EA%B8%B0%ED%99%94%EC%97%86%EC%9D%B4-%EB%8B%A4%EB%A5%B8-%EA%B0%92%EC%9D%84-%EB%8C%80%EC%9E%85%ED%95%A0-%EC%88%98-%EC%9E%88%EA%B2%8C-%EB%90%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>변수초기화관련 메서드추출에서, [지역변수 -&gt; 추출메서드 인자]의 과정을 [INLINE으로 바꾸는 순간, 특정 지역변수with초기화없이, 다른 값을 대입]할 수 있게 된다</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812233125844.png" alt="image-20220812233125844"></p>

<p>​	<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812233143574.png" alt="image-20220812233143574"></p>

<h5 id="값이-바뀌는-변수는-지역변수를-inline화-했지만-가변변수는-inline하면-안된다-계속-업데이트-되서-외부-다른-메서드들도-쓸-것이기-때문에-초기값--외부-업데이트가-유지되어야한다----inline해도-지역변수가-사라지지-않고-남아있음">
<a class="anchor" href="#%EA%B0%92%EC%9D%B4-%EB%B0%94%EB%80%8C%EB%8A%94-%EB%B3%80%EC%88%98%EB%8A%94-%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98%EB%A5%BC-inline%ED%99%94-%ED%96%88%EC%A7%80%EB%A7%8C-%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98%EB%8A%94-inline%ED%95%98%EB%A9%B4-%EC%95%88%EB%90%9C%EB%8B%A4-%EA%B3%84%EC%86%8D-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EB%90%98%EC%84%9C-%EC%99%B8%EB%B6%80-%EB%8B%A4%EB%A5%B8-%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4%EB%8F%84-%EC%93%B8-%EA%B2%83%EC%9D%B4%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%97%90-%EC%B4%88%EA%B8%B0%EA%B0%92--%EC%99%B8%EB%B6%80-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EA%B0%80-%EC%9C%A0%EC%A7%80%EB%90%98%EC%96%B4%EC%95%BC%ED%95%9C%EB%8B%A4----inline%ED%95%B4%EB%8F%84-%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98%EA%B0%80-%EC%82%AC%EB%9D%BC%EC%A7%80%EC%A7%80-%EC%95%8A%EA%B3%A0-%EB%82%A8%EC%95%84%EC%9E%88%EC%9D%8C" aria-hidden="true"><span class="octicon octicon-link"></span></a>[값이 바뀌는 변수]는 지역변수를 inline화 했지만, [가변변수는 inline하면 안된다. 계속 업데이트 되서 외부 다른 메서드들도 쓸 것이기 때문에, 초기값 + 외부 업데이트가 유지되어야한다]  -&gt; inline해도 지역변수가 사라지지 않고 남아있음</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812233639837.png" alt="image-20220812233639837"></p>

<h5 id="즉-내부context불변필드제외를-지역변수로-위에두고-추출하여-파라미터로-만들-듯-가변변수와-다른-값으로-바뀔-수-있는-변수-초기화부분은-위쪽--외부에-두고-메서드추출한다">
<a class="anchor" href="#%EC%A6%89-%EB%82%B4%EB%B6%80context%EB%B6%88%EB%B3%80%ED%95%84%EB%93%9C%EC%A0%9C%EC%99%B8%EB%A5%BC-%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98%EB%A1%9C-%EC%9C%84%EC%97%90%EB%91%90%EA%B3%A0-%EC%B6%94%EC%B6%9C%ED%95%98%EC%97%AC-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A1%9C-%EB%A7%8C%EB%93%A4-%EB%93%AF-%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98%EC%99%80-%EB%8B%A4%EB%A5%B8-%EA%B0%92%EC%9C%BC%EB%A1%9C-%EB%B0%94%EB%80%94-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%B3%80%EC%88%98-%EC%B4%88%EA%B8%B0%ED%99%94%EB%B6%80%EB%B6%84%EC%9D%80-%EC%9C%84%EC%AA%BD--%EC%99%B8%EB%B6%80%EC%97%90-%EB%91%90%EA%B3%A0-%EB%A9%94%EC%84%9C%EB%93%9C%EC%B6%94%EC%B6%9C%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>즉, 내부context(불변필드제외)를 지역변수로 위에두고 추출하여 파라미터로 만들 듯, [가변변수]와 [다른 값으로 바뀔 수 있는 변수 초기화]부분은 위쪽 == 외부에 두고 메서드추출한다</h5>

<h5 id="바뀌는-지역변수의-값---인자로-inline화-되었다면-특정-지역변수로-만들어진-파라미터의-이름을-바꿔주자-title-target---dataprefix-등">
<a class="anchor" href="#%EB%B0%94%EB%80%8C%EB%8A%94-%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98%EC%9D%98-%EA%B0%92---%EC%9D%B8%EC%9E%90%EB%A1%9C-inline%ED%99%94-%EB%90%98%EC%97%88%EB%8B%A4%EB%A9%B4-%ED%8A%B9%EC%A0%95-%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A7%84-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EC%9D%98-%EC%9D%B4%EB%A6%84%EC%9D%84-%EB%B0%94%EA%BF%94%EC%A3%BC%EC%9E%90-title-target---dataprefix-%EB%93%B1" aria-hidden="true"><span class="octicon octicon-link"></span></a>바뀌는 지역변수의 값 -&gt; 인자로 inline화 되었다면, [특정 지역변수로 만들어진 파라미터]의 이름을 바꿔주자 (title target -&gt; dataPrefix 등)</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/59ec283f-6ac4-4573-9390-4d4866c7dedf.gif" alt="59ec283f-6ac4-4573-9390-4d4866c7dedf"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812234426691.png" alt="image-20220812234426691"></p>

<h4 id="09-업데이트된-가변변수cursor를-이용하는-다음로직인-substring-부분을-메서드추출해보자">
<a class="anchor" href="#09-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%90%9C-%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98cursor%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EB%8A%94-%EB%8B%A4%EC%9D%8C%EB%A1%9C%EC%A7%81%EC%9D%B8-substring-%EB%B6%80%EB%B6%84%EC%9D%84-%EB%A9%94%EC%84%9C%EB%93%9C%EC%B6%94%EC%B6%9C%ED%95%B4%EB%B3%B4%EC%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>09 업데이트된 가변변수cursor를 이용하는, 다음로직인 substring 부분을 메서드추출해보자</h4>

<h5 id="가-데이터의-끝임을-알려주므로-변하지-않는-상수로-취급한다면-바뀌는-변수는-포함된-가변변수-사용밖에-없다">
<a class="anchor" href="#%EA%B0%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-%EB%81%9D%EC%9E%84%EC%9D%84-%EC%95%8C%EB%A0%A4%EC%A3%BC%EB%AF%80%EB%A1%9C-%EB%B3%80%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EC%83%81%EC%88%98%EB%A1%9C-%EC%B7%A8%EA%B8%89%ED%95%9C%EB%8B%A4%EB%A9%B4-%EB%B0%94%EB%80%8C%EB%8A%94-%EB%B3%80%EC%88%98%EB%8A%94-%ED%8F%AC%ED%95%A8%EB%90%9C-%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98-%EC%82%AC%EC%9A%A9%EB%B0%96%EC%97%90-%EC%97%86%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a><code class="language-plaintext highlighter-rouge">"</code>가 데이터의 끝임을 알려주므로, 변하지 않는 상수로 취급한다면, 바뀌는 변수는 [포함된 가변변수 사용]밖에 없다</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812233818138.png" alt="image-20220812233818138"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812233935833.png" alt="image-20220812233935833"></p>

<h4 id="10-조심-가변변수--업데이트-이후--가변변수-사용-부분은-inline화-하면-안된다">
<a class="anchor" href="#10-%EC%A1%B0%EC%8B%AC-%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98--%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EC%9D%B4%ED%9B%84--%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98-%EC%82%AC%EC%9A%A9-%EB%B6%80%EB%B6%84%EC%9D%80-inline%ED%99%94-%ED%95%98%EB%A9%B4-%EC%95%88%EB%90%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>10 조심! [가변변수 = 업데이트 –이후–&gt;  가변변수 ]사용 부분은 inline화 하면 안된다!</h4>

<ul>
  <li>
    <p>기존</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812234738164.png" alt="image-20220812234738164"></p>
  </li>
  <li>
    <p><strong>잘못된 예: <code class="language-plaintext highlighter-rouge">가변변수 업데이트 -&gt; 가변변수 사용을 inline</code></strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812234516183.png" alt="image-20220812234516183"></p>
  </li>
</ul>

<h5 id="가변변수란-위쪽에-컨트롤타워로서-지역변수에-계속-업데이트-되는-것이-목적이다-업데이트-로직을-inline화-시키면-컨트롤타워가-업데이트-안되고-일회성-사용하는-것-밖에-안된다">
<a class="anchor" href="#%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98%EB%9E%80-%EC%9C%84%EC%AA%BD%EC%97%90-%EC%BB%A8%ED%8A%B8%EB%A1%A4%ED%83%80%EC%9B%8C%EB%A1%9C%EC%84%9C-%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98%EC%97%90-%EA%B3%84%EC%86%8D-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EB%90%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EB%AA%A9%EC%A0%81%EC%9D%B4%EB%8B%A4-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EB%A1%9C%EC%A7%81%EC%9D%84-inline%ED%99%94-%EC%8B%9C%ED%82%A4%EB%A9%B4-%EC%BB%A8%ED%8A%B8%EB%A1%A4%ED%83%80%EC%9B%8C%EA%B0%80-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EC%95%88%EB%90%98%EA%B3%A0-%EC%9D%BC%ED%9A%8C%EC%84%B1-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83-%EB%B0%96%EC%97%90-%EC%95%88%EB%90%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>가변변수란, [위쪽에 컨트롤타워로서 지역변수에 계속 업데이트 되는 것이 목적]이다. 업데이트 로직을 inline화 시키면, 컨트롤타워가 업데이트 안되고, 일회성 사용하는 것 밖에 안된다.</h5>

<ul>
  <li>
    <p>가변변수 업데이트 이후 사용</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812234937284.png" alt="image-20220812234937284"></p>
  </li>
  <li>
    <p><strong>가변변수 업데이트 로직을 inline화 하여, 업데이트된 값만 사용하고 치웠을 때</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812235027611.png" alt="image-20220812235027611"></p>
  </li>
</ul>

<h5 id="가변변수는-컨트롤-타워에-업데이트하면서-사용할-사람들은-사용해야한다-가변변수를-업데이트와-동시에-인자로-inline화하고-싶다면---메서드-인자에서---가변변수--업데이트로직자체를-수동inline해야한다">
<a class="anchor" href="#%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98%EB%8A%94-%EC%BB%A8%ED%8A%B8%EB%A1%A4-%ED%83%80%EC%9B%8C%EC%97%90-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%ED%95%98%EB%A9%B4%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%82%AC%EB%9E%8C%EB%93%A4%EC%9D%80-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4-%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98%EB%A5%BC-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EC%99%80-%EB%8F%99%EC%8B%9C%EC%97%90-%EC%9D%B8%EC%9E%90%EB%A1%9C-inline%ED%99%94%ED%95%98%EA%B3%A0-%EC%8B%B6%EB%8B%A4%EB%A9%B4---%EB%A9%94%EC%84%9C%EB%93%9C-%EC%9D%B8%EC%9E%90%EC%97%90%EC%84%9C---%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98--%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%A1%9C%EC%A7%81%EC%9E%90%EC%B2%B4%EB%A5%BC-%EC%88%98%EB%8F%99inline%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>가변변수는 [컨트롤 타워에 업데이트하면서, 사용할 사람들은 사용]해야한다. [가변변수를 업데이트와 동시에 인자로 INLINE화]하고 싶다면 -&gt; 메서드 인자에서  [ (가변변수 = 업데이트로직)]자체를 수동INLINE해야한다</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812235324488.png" alt="image-20220812235324488"></p>

<ul>
  <li>java는 python3.8의 업데이트후 사용 -&gt; 코끼리연산자로  업데이트와 동시에 사용이 가능하다</li>
</ul>

<h4 id="11-targetprefix만-바꿔서-다음-타겟이-잘-추출되는지-확인한다-title---date">
<a class="anchor" href="#11-targetprefix%EB%A7%8C-%EB%B0%94%EA%BF%94%EC%84%9C-%EB%8B%A4%EC%9D%8C-%ED%83%80%EA%B2%9F%EC%9D%B4-%EC%9E%98-%EC%B6%94%EC%B6%9C%EB%90%98%EB%8A%94%EC%A7%80-%ED%99%95%EC%9D%B8%ED%95%9C%EB%8B%A4-title---date" aria-hidden="true"><span class="octicon octicon-link"></span></a>11 targetPrefix만 바꿔서, 다음 타겟이 잘 추출되는지 확인한다 (title -&gt; date)</h4>

<ul>
  <li>json예시 출력을 활용해서 prefix를 만들고</li>
  <li>컨트롤타워를 통해 업데이트되는 가변변수 cursor를 지속 업데이트하면서</li>
  <li>title대신 date도 뽑아본다.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/199d4a6a-3544-43be-8189-f3925e8e3b5a.gif" alt="199d4a6a-3544-43be-8189-f3925e8e3b5a"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220812235651670.png" alt="image-20220812235651670"></p>

<h4 id="12-available까지-추출해보고-가변변수업데이트-inline으로-바꾼-뒤-자신의-처리가-끝났으니-커맨드홀더객체load로-옮겨서-root-composite객체를-setter로-만들어주자">
<a class="anchor" href="#12-available%EA%B9%8C%EC%A7%80-%EC%B6%94%EC%B6%9C%ED%95%B4%EB%B3%B4%EA%B3%A0-%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-inline%EC%9C%BC%EB%A1%9C-%EB%B0%94%EA%BE%BC-%EB%92%A4-%EC%9E%90%EC%8B%A0%EC%9D%98-%EC%B2%98%EB%A6%AC%EA%B0%80-%EB%81%9D%EB%82%AC%EC%9C%BC%EB%8B%88-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4load%EB%A1%9C-%EC%98%AE%EA%B2%A8%EC%84%9C-root-composite%EA%B0%9D%EC%B2%B4%EB%A5%BC-setter%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A3%BC%EC%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>12 available까지 추출해보고, 가변변수업데이트 inline으로 바꾼 뒤, 자신의 처리가 끝났으니 커맨드홀더객체#load로 옮겨서, root Composite객체를 setter로 만들어주자</h4>

<h5 id="test에서-만든-로직--private메서드들을--load메서드로-옮긴다">
<a class="anchor" href="#test%EC%97%90%EC%84%9C-%EB%A7%8C%EB%93%A0-%EB%A1%9C%EC%A7%81--private%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4%EC%9D%84--load%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EC%98%AE%EA%B8%B4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>Test에서 만든 로직 + private메서드들을  load메서드로 옮긴다</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/1362bf23-28ac-48b8-a949-91cb9a053990.gif" alt="1362bf23-28ac-48b8-a949-91cb9a053990"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813002916083.png" alt="image-20220813002916083"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813002927802.png" alt="image-20220813002927802"></p>

<h5 id="커맨드홀더객체-내-root-composite객체를-재활용하기-위해-추출한-필드정보를-setter로-채운다-string-date---localdatetimeparse--string-boolean---booleanparseboolean-으로-를-한번더-씌워서-set해줘야한다">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4-%EB%82%B4-root-composite%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%9E%AC%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%B4-%EC%B6%94%EC%B6%9C%ED%95%9C-%ED%95%84%EB%93%9C%EC%A0%95%EB%B3%B4%EB%A5%BC-setter%EB%A1%9C-%EC%B1%84%EC%9A%B4%EB%8B%A4-string-date---localdatetimeparse--string-boolean---booleanparseboolean-%EC%9C%BC%EB%A1%9C-%EB%A5%BC-%ED%95%9C%EB%B2%88%EB%8D%94-%EC%94%8C%EC%9B%8C%EC%84%9C-set%ED%95%B4%EC%A4%98%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드홀더객체 내 root Composite객체를, 재활용하기 위해, 추출한 필드정보를 setter로 채운다. String date -&gt; LocalDateTime.parse() / String boolean -&gt; Boolean.parseBoolean() 으로 를 한번더 씌워서 set해줘야한다</h5>

<ul>
  <li>available필드는 setter대신 toggle만 있었는데, setter를 추가해줬다.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/cc51258b-632c-44f6-ae1c-0cf214bed3a8.gif" alt="cc51258b-632c-44f6-ae1c-0cf214bed3a8"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813003532107.png" alt="image-20220813003532107"></p>

<h3 id="커맨드홀더-객체-내-자식들-정보가-있는지-확인-후-add해서-붙여주기">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94-%EA%B0%9D%EC%B2%B4-%EB%82%B4-%EC%9E%90%EC%8B%9D%EB%93%A4-%EC%A0%95%EB%B3%B4%EA%B0%80-%EC%9E%88%EB%8A%94%EC%A7%80-%ED%99%95%EC%9D%B8-%ED%9B%84-add%ED%95%B4%EC%84%9C-%EB%B6%99%EC%97%AC%EC%A3%BC%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드홀더 객체 내, 자식들 정보가 있는지 확인 후, add해서 붙여주기</h3>

<h4 id="composite객체의-자식생성은-데이터가-있을-경우---데이터를-추출해서-add로-root에-붙여주면-된다">
<a class="anchor" href="#composite%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%9E%90%EC%8B%9D%EC%83%9D%EC%84%B1%EC%9D%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80-%EC%9E%88%EC%9D%84-%EA%B2%BD%EC%9A%B0---%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%B6%94%EC%B6%9C%ED%95%B4%EC%84%9C-add%EB%A1%9C-root%EC%97%90-%EB%B6%99%EC%97%AC%EC%A3%BC%EB%A9%B4-%EB%90%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>composite객체의 자식생성은 [데이터가 있을 경우] -&gt; 데이터를 추출해서 .add()로 root에 붙여주면 된다.</h4>

<ul>
  <li>
    <p>기존 main에서 자식을 생성하는 방법</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813131524124.png" alt="image-20220813131524124"></p>
  </li>
</ul>

<h4 id="13-자식-존재유무-판단할-수-있는-곳인-sub--를-prefix로-그-1칸-뒤까지-이동시켜-자식-있다면-로-시작하도록-cursor업데이트-시키기">
<a class="anchor" href="#13-%EC%9E%90%EC%8B%9D-%EC%A1%B4%EC%9E%AC%EC%9C%A0%EB%AC%B4-%ED%8C%90%EB%8B%A8%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EA%B3%B3%EC%9D%B8-sub--%EB%A5%BC-prefix%EB%A1%9C-%EA%B7%B8-1%EC%B9%B8-%EB%92%A4%EA%B9%8C%EC%A7%80-%EC%9D%B4%EB%8F%99%EC%8B%9C%EC%BC%9C-%EC%9E%90%EC%8B%9D-%EC%9E%88%EB%8B%A4%EB%A9%B4-%EB%A1%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8F%84%EB%A1%9D-cursor%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EC%8B%9C%ED%82%A4%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>13 자식 존재유무 판단할 수 있는 곳인 [<code class="language-plaintext highlighter-rouge">sub: [</code> 를 prefix로 그 1칸 뒤까]지 이동시켜, 자식 있다면, {로 시작하도록 cursor업데이트 시키기</h4>

<ul>
  <li>
    <p>데이터는 추출안하고, 자식데이터를 뽑을 수 있는 위치까지만 cursor를 업데이트시켜놔야한다</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813131010418.png" alt="image-20220813131010418"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813131103143.png" alt="image-20220813131103143"></p>
  </li>
</ul>

<h4 id="14-다시-한번-복잡한-로직자식-존재유무--데이터-추출이-예견되므로-test로-현재까지-결과를-옮겨서-디버깅하며-처리하기">
<a class="anchor" href="#14-%EB%8B%A4%EC%8B%9C-%ED%95%9C%EB%B2%88-%EB%B3%B5%EC%9E%A1%ED%95%9C-%EB%A1%9C%EC%A7%81%EC%9E%90%EC%8B%9D-%EC%A1%B4%EC%9E%AC%EC%9C%A0%EB%AC%B4--%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B6%94%EC%B6%9C%EC%9D%B4-%EC%98%88%EA%B2%AC%EB%90%98%EB%AF%80%EB%A1%9C-test%EB%A1%9C-%ED%98%84%EC%9E%AC%EA%B9%8C%EC%A7%80-%EA%B2%B0%EA%B3%BC%EB%A5%BC-%EC%98%AE%EA%B2%A8%EC%84%9C-%EB%94%94%EB%B2%84%EA%B9%85%ED%95%98%EB%A9%B0-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>14 다시 한번 복잡한 로직(자식 존재유무 &amp;&amp; 데이터 추출)이 예견되므로 Test로 현재까지 결과를 옮겨서 디버깅하며 처리하기</h4>

<h5 id="자신의-정보-추출까지는-cursor가-업데이트-되어있으니-cursor-업데이트-로직까지-들고와서-test에서-진행한다">
<a class="anchor" href="#%EC%9E%90%EC%8B%A0%EC%9D%98-%EC%A0%95%EB%B3%B4-%EC%B6%94%EC%B6%9C%EA%B9%8C%EC%A7%80%EB%8A%94-cursor%EA%B0%80-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EB%90%98%EC%96%B4%EC%9E%88%EC%9C%BC%EB%8B%88-cursor-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EB%A1%9C%EC%A7%81%EA%B9%8C%EC%A7%80-%EB%93%A4%EA%B3%A0%EC%99%80%EC%84%9C-test%EC%97%90%EC%84%9C-%EC%A7%84%ED%96%89%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>자신의 정보 추출까지는 cursor가 업데이트 되어있으니, cursor 업데이트 로직까지 들고와서 Test에서 진행한다.</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/7a89cc74-1780-4f7e-92d9-a46b1fe506ce.gif" alt="7a89cc74-1780-4f7e-92d9-a46b1fe506ce"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813135031229.png" alt="image-20220813135031229"></p>

<h5 id="test참고-커맨드홀더객체내-load메서드에서-재활용하는-객체는-command홀더객체가-아니라-소유--composite원본객체를-만든다-하지만-test에서는-command홀더객체-내부-composite객체를-생성해서-테스트한다면-save나-load가-호출불가하므로-테스트의-목적인-load메서드를-호출하고-load의-뒷부분만-처리하기-위해-중간결과인-json을-받고-처리-중에-있다">
<a class="anchor" href="#test%EC%B0%B8%EA%B3%A0-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4%EB%82%B4-load%EB%A9%94%EC%84%9C%EB%93%9C%EC%97%90%EC%84%9C-%EC%9E%AC%ED%99%9C%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B0%9D%EC%B2%B4%EB%8A%94-command%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%86%8C%EC%9C%A0--composite%EC%9B%90%EB%B3%B8%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%A7%8C%EB%93%A0%EB%8B%A4-%ED%95%98%EC%A7%80%EB%A7%8C-test%EC%97%90%EC%84%9C%EB%8A%94-command%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4-%EB%82%B4%EB%B6%80-composite%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%83%9D%EC%84%B1%ED%95%B4%EC%84%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%9C%EB%8B%A4%EB%A9%B4-save%EB%82%98-load%EA%B0%80-%ED%98%B8%EC%B6%9C%EB%B6%88%EA%B0%80%ED%95%98%EB%AF%80%EB%A1%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9D%98-%EB%AA%A9%EC%A0%81%EC%9D%B8-load%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%98%EA%B3%A0-load%EC%9D%98-%EB%92%B7%EB%B6%80%EB%B6%84%EB%A7%8C-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%B4-%EC%A4%91%EA%B0%84%EA%B2%B0%EA%B3%BC%EC%9D%B8-json%EC%9D%84-%EB%B0%9B%EA%B3%A0-%EC%B2%98%EB%A6%AC-%EC%A4%91%EC%97%90-%EC%9E%88%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>Test참고) 커맨드홀더객체내 load메서드에서 재활용하는 객체는 command홀더객체가 아니라 소유  composite원본객체를 만든다. 하지만, Test에서는 Command홀더객체 내부 composite객체를 생성해서 테스트한다면, save나 load가 호출불가하므로 테스트의 목적인 load메서드를 호출하고, load의 뒷부분만 처리하기 위해 중간결과인 json을 받고 처리 중에 있다.</h5>

<h4 id="14-자식정보가-남아있을-때까지-add---while문을-사용해서-반복하며-cursor와-같이-움직이는-배열은-cursor로-현재-위치를-확인하도록-while문을-작성한다-이때-cursor업데이트-조건은-1칸씩-이동이다데이터-추출이-아니라-데이터-존재유무-확인부터">
<a class="anchor" href="#14-%EC%9E%90%EC%8B%9D%EC%A0%95%EB%B3%B4%EA%B0%80-%EB%82%A8%EC%95%84%EC%9E%88%EC%9D%84-%EB%95%8C%EA%B9%8C%EC%A7%80-add---while%EB%AC%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C-%EB%B0%98%EB%B3%B5%ED%95%98%EB%A9%B0-cursor%EC%99%80-%EA%B0%99%EC%9D%B4-%EC%9B%80%EC%A7%81%EC%9D%B4%EB%8A%94-%EB%B0%B0%EC%97%B4%EC%9D%80-cursor%EB%A1%9C-%ED%98%84%EC%9E%AC-%EC%9C%84%EC%B9%98%EB%A5%BC-%ED%99%95%EC%9D%B8%ED%95%98%EB%8F%84%EB%A1%9D-while%EB%AC%B8%EC%9D%84-%EC%9E%91%EC%84%B1%ED%95%9C%EB%8B%A4-%EC%9D%B4%EB%95%8C-cursor%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EC%A1%B0%EA%B1%B4%EC%9D%80-1%EC%B9%B8%EC%94%A9-%EC%9D%B4%EB%8F%99%EC%9D%B4%EB%8B%A4%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B6%94%EC%B6%9C%EC%9D%B4-%EC%95%84%EB%8B%88%EB%9D%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A1%B4%EC%9E%AC%EC%9C%A0%EB%AC%B4-%ED%99%95%EC%9D%B8%EB%B6%80%ED%84%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>14 자식정보가 남아있을 때까지 add -&gt; while문을 사용해서 반복하며, [cursor와 같이 움직이는 배열]은 [cursor로 현재 위치를 확인]하도록 while문을 작성한다. 이때, cursor업데이트 조건은 1칸씩 이동이다(데이터 추출이 아니라 데이터 존재유무 확인부터)</h4>

<ul>
  <li>
    <p>while문은 if매번확인후 action을 여러번 하는 것이며, 내부 확인변수를 업데이트도 시켜줘야한다</p>

    <ul>
      <li>
<strong>cursor가 json의 끝에 위치하여 -&gt; 자식정보 탐색이 끝났는지 매번확인</strong>하면서 자식데이터를 추출한다</li>
      <li>현재는 Test파일에 작성 중.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813135810385.png" alt="image-20220813135810385"></p>
  </li>
  <li>
    <p>while속 조건문은 매번 호출되는 확인문장이라서 <strong>메서드호출 결과가 상수라면, 지역변수로 빼서 상수로 검사한다</strong></p>

    <ul>
      <li><strong>조건문에 들어가는 메서드호출은 값이라서 -&gt; 조건문 속 메서드 호출을 피하는게 좋다.</strong></li>
      <li>만약 내수용으로 로직정리용이라면, 그대로 둔다.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813135912447.png" alt="image-20220813135912447"></p>
  </li>
</ul>

<h5 id="참고-command홀더객체-내-cmd객체들-외부저장소list배열과-cursor로-상태확인">
<a class="anchor" href="#%EC%B0%B8%EA%B3%A0-command%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4-%EB%82%B4-cmd%EA%B0%9D%EC%B2%B4%EB%93%A4-%EC%99%B8%EB%B6%80%EC%A0%80%EC%9E%A5%EC%86%8Clist%EB%B0%B0%EC%97%B4%EA%B3%BC-cursor%EB%A1%9C-%EC%83%81%ED%83%9C%ED%99%95%EC%9D%B8" aria-hidden="true"><span class="octicon octicon-link"></span></a>참고) command홀더객체 내, cmd객체들 외부저장소(List배열)과 cursor로 상태확인</h5>

<ol>
  <li>
    <p>redo는 undo로 인해 cursor가 원래배열의 끝보다 더 뒤에 있을 때, 한칸 앞으로 움직이므로</p>

    <ul>
      <li>
        <p><strong>cursor가 <code class="language-plaintext highlighter-rouge">배열의 맨끝</code>에 있지는 않은지</strong> 검사한다</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813132600229.png" alt="image-20220813132600229"></p>
      </li>
    </ul>
  </li>
  <li>
    <p>undo는 실행되어 기록이 저장된cmd가 1개라도 있어야한다.</p>

    <ul>
      <li>
        <p><strong>cursor가 <code class="language-plaintext highlighter-rouge">원소가 1개도 없을 경우인,  0보다 뒤에 있는지 확인</code></strong>한다</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813132731535.png" alt="image-20220813132731535"></p>
      </li>
    </ul>
  </li>
  <li>
    <p>execute후 add는, <strong>현재 add된 것이 배열의 제일 마지막에 위치</strong>하도록 <strong>(add를 단순 cursor++만 해선 안됨)</strong> 해야 <strong>add후 redo시 에러가 발생안하게</strong> 되는데, cursor는 undo로 인해 배열 끝보다 더 뒤에 있을 수 있으니, <strong>add하는 순간에는 cursor이동 전에, 배열 remove로직도 들어간다</strong>.</p>

    <ul>
      <li>
        <p>**cursor만 빽(undo)하고 redo를 위해 배열에는 cmd객체를 남겨놓는데, <code class="language-plaintext highlighter-rouge">cursor가 빽 한 상태에서 add한 것이 배열의 제일 끝에 위치하여, redo는 불가능</code>하도록 만들어놔야한다 **</p>
      </li>
      <li>
        <p><strong>그럴려면, <code class="language-plaintext highlighter-rouge">현재cursor(빽한 상황)보다 더 앞에 있는 cursor +  1 ~ 마지막까지는 먼저 배열에서 삭제</code>해놓아야 한다</strong></p>
      </li>
      <li>
        <p>그리고 난 뒤, <strong>요소를 배열 맨마지막에 add했으면, cursor의 업데이트는 불변식 size()-1로 업데이트</strong>한다</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813133653313.png" alt="image-20220813133653313"></p>
      </li>
    </ul>
  </li>
</ol>

<h4 id="15-sub--1칸-뒤에서부터-cursor를-1개씩-증가시키면서-문자열1개씩-확인하며-자식존재여부를-판단한다">
<a class="anchor" href="#15-sub--1%EC%B9%B8-%EB%92%A4%EC%97%90%EC%84%9C%EB%B6%80%ED%84%B0-cursor%EB%A5%BC-1%EA%B0%9C%EC%94%A9-%EC%A6%9D%EA%B0%80%EC%8B%9C%ED%82%A4%EB%A9%B4%EC%84%9C-%EB%AC%B8%EC%9E%90%EC%97%B41%EA%B0%9C%EC%94%A9-%ED%99%95%EC%9D%B8%ED%95%98%EB%A9%B0-%EC%9E%90%EC%8B%9D%EC%A1%B4%EC%9E%AC%EC%97%AC%EB%B6%80%EB%A5%BC-%ED%8C%90%EB%8B%A8%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>15 <code class="language-plaintext highlighter-rouge">sub: [</code> 1칸 뒤에서부터 cursor를 1개씩 증가시키면서 문자열1개씩 확인하며, 자식존재여부를 판단한다.</h4>

<h5 id="데이터-추출이전에-cursor에-있는-문자열-1개씩-jsoncharatcursor으로-뽑아-검사하여-if-자식데이터-존재유무를-확인한다-cursor업뎃-중에-if에-안걸린다면-건너띈다는-의미이다">
<a class="anchor" href="#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B6%94%EC%B6%9C%EC%9D%B4%EC%A0%84%EC%97%90-cursor%EC%97%90-%EC%9E%88%EB%8A%94-%EB%AC%B8%EC%9E%90%EC%97%B4-1%EA%B0%9C%EC%94%A9-jsoncharatcursor%EC%9C%BC%EB%A1%9C-%EB%BD%91%EC%95%84-%EA%B2%80%EC%82%AC%ED%95%98%EC%97%AC-if-%EC%9E%90%EC%8B%9D%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A1%B4%EC%9E%AC%EC%9C%A0%EB%AC%B4%EB%A5%BC-%ED%99%95%EC%9D%B8%ED%95%9C%EB%8B%A4-cursor%EC%97%85%EB%8E%83-%EC%A4%91%EC%97%90-if%EC%97%90-%EC%95%88%EA%B1%B8%EB%A6%B0%EB%8B%A4%EB%A9%B4-%EA%B1%B4%EB%84%88%EB%9D%88%EB%8B%A4%EB%8A%94-%EC%9D%98%EB%AF%B8%EC%9D%B4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>데이터 추출이전에, cursor에 있는 문자열 1개씩 json.charAt(cursor)으로 뽑아 검사하여, if 자식데이터 존재유무를 확인한다. cursor++업뎃 중에 if에 안걸린다면 건너띈다는 의미이다.</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813143125087.png" alt="image-20220813143125087"></p>

<h5 id="담에-나온-문자열이-라면-자식이-최소-1개-존재한다는-의미이다---자식데이터들을-추출한-뒤-add자식-해준다">
<a class="anchor" href="#%EB%8B%B4%EC%97%90-%EB%82%98%EC%98%A8-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%B4-%EB%9D%BC%EB%A9%B4-%EC%9E%90%EC%8B%9D%EC%9D%B4-%EC%B5%9C%EC%86%8C-1%EA%B0%9C-%EC%A1%B4%EC%9E%AC%ED%95%9C%EB%8B%A4%EB%8A%94-%EC%9D%98%EB%AF%B8%EC%9D%B4%EB%8B%A4---%EC%9E%90%EC%8B%9D%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%93%A4%EC%9D%84-%EC%B6%94%EC%B6%9C%ED%95%9C-%EB%92%A4-add%EC%9E%90%EC%8B%9D-%ED%95%B4%EC%A4%80%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>[담에 나온 문자열이 <code class="language-plaintext highlighter-rouge">{</code>라면, 자식이 최소 1개 존재한다는 의미이다. -&gt; 자식데이터들을 추출한 뒤, add자식 해준다.</h5>

<ul>
  <li>root 자신 데이터 추출시 사용했던 코드를 복사해와서 수정한다.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/9c39923f-947a-42dd-a610-37199a41e9ab.gif" alt="9c39923f-947a-42dd-a610-37199a41e9ab"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813143330517.png" alt="image-20220813143330517"></p>

<ul>
  <li>root.add( )에 들어갈 데이터들을 추출하고, <strong>파싱까지 한 뒤 add</strong>해준다.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/fac47099-491e-4f8e-949c-0451b1be4c1b.gif" alt="fac47099-491e-4f8e-949c-0451b1be4c1b"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813143713131.png" alt="image-20220813143713131"></p>

<h4 id="현재-availableboolean에-대한-setter메서드는-toggle만-커맨드로-만들어줬다-여기서-available의-setter를-추가해줘야한다">
<a class="anchor" href="#%ED%98%84%EC%9E%AC-availableboolean%EC%97%90-%EB%8C%80%ED%95%9C-setter%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-toggle%EB%A7%8C-%EC%BB%A4%EB%A7%A8%EB%93%9C%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A4%AC%EB%8B%A4-%EC%97%AC%EA%B8%B0%EC%84%9C-available%EC%9D%98-setter%EB%A5%BC-%EC%B6%94%EA%B0%80%ED%95%B4%EC%A4%98%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>현재 Available(boolean)에 대한 setter메서드는 toggle만 커맨드로 만들어줬다. 여기서 available의 setter를 추가해줘야한다.</h4>

<h5 id="객체를-생성하면-기본-default로-정해져서-toggle만-정의하고-setter는-무시했지만-save된-jsonstring으로-load할때는-기본값이-아닌-저장된-값으로-채워줘야한다">
<a class="anchor" href="#%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%83%9D%EC%84%B1%ED%95%98%EB%A9%B4-%EA%B8%B0%EB%B3%B8-default%EB%A1%9C-%EC%A0%95%ED%95%B4%EC%A0%B8%EC%84%9C-toggle%EB%A7%8C-%EC%A0%95%EC%9D%98%ED%95%98%EA%B3%A0-setter%EB%8A%94-%EB%AC%B4%EC%8B%9C%ED%96%88%EC%A7%80%EB%A7%8C-save%EB%90%9C-jsonstring%EC%9C%BC%EB%A1%9C-load%ED%95%A0%EB%95%8C%EB%8A%94-%EA%B8%B0%EB%B3%B8%EA%B0%92%EC%9D%B4-%EC%95%84%EB%8B%8C-%EC%A0%80%EC%9E%A5%EB%90%9C-%EA%B0%92%EC%9C%BC%EB%A1%9C-%EC%B1%84%EC%9B%8C%EC%A4%98%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>객체를 생성하면 기본 default로 정해져서 toggle만 정의하고, setter는 무시했지만, save된 jsonstring으로 load할때는, 기본값이 아닌 저장된 값으로 채워줘야한다</h5>

<ul>
  <li>
    <p>기본값을 가지고 태어나서, setter를 정의안해준 Composite객체의 available</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813144002483.png" alt="image-20220813144002483"></p>
  </li>
  <li>
    <p>command#addMenu의 파라미터 / composite#add시 파라미터에 available이 빠져있다.</p>

    <ul>
      <li>
        <p>CommandMenu
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813144206109.png" alt="image-20220813144206109"></p>
      </li>
      <li>
        <p>CompositeMenu</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813144251724.png" alt="image-20220813144251724"></p>
      </li>
    </ul>
  </li>
</ul>

<h5 id="compositemenu생성자에-available을-받아서-생성되는-것까지-test에서부터-추가해-나가야한다">
<a class="anchor" href="#compositemenu%EC%83%9D%EC%84%B1%EC%9E%90%EC%97%90-available%EC%9D%84-%EB%B0%9B%EC%95%84%EC%84%9C-%EC%83%9D%EC%84%B1%EB%90%98%EB%8A%94-%EA%B2%83%EA%B9%8C%EC%A7%80-test%EC%97%90%EC%84%9C%EB%B6%80%ED%84%B0-%EC%B6%94%EA%B0%80%ED%95%B4-%EB%82%98%EA%B0%80%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>CompositeMenu생성자에 available을 받아서 생성되는 것까지, Test에서부터 추가해 나가야한다.</h5>

<ul>
  <li>
    <p>현재 Test</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813144516507.png" alt="image-20220813144516507"></p>
  </li>
</ul>

<ol>
  <li>
    <p>command객체에 available을 포함하여 자식을 추가하는 <strong>서비스 메서드를</strong> 만든다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813162209782.png" alt="image-20220813162209782"></p>
  </li>
  <li>
    <p>커맨드객체는, 래핑할메서드의 <strong>파라미터가 완전히 달라</strong>지면 <strong>새로운 커맨드객체를 생성</strong>해야하지만, <strong>파라미터가 추가되는 경우는, 기존 커맨드객체의 생성자를 추가함으로써 가능하다. 대신 기존 생성자는 기본값 처리 + 오버로딩해줘야한다</strong></p>

    <ul>
      <li>기억해야하는 context의 종류가 달라짐 -&gt; 필드종류가 달라짐 -&gt; 새객체</li>
      <li>context가 추가해됨 -&gt; 필드 추가 -&gt; 생성자 추가 및 기존은 부생성자로 변경</li>
    </ul>
  </li>
  <li>
    <p>기존 Add 커맨드객체에 기억context추가에 따른 필드를 추가하고, 그 전에 파라미터가 없던 것은 기본값을 초기화해보자.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813162442384.png" alt="image-20220813162442384"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813162526864.png" alt="image-20220813162526864"></p>
  </li>
  <li>
    <p>execute에 추가 기억한 context를 넣어서 작동시키자. 만약 안들어왔으면, 기본값 true로 초기화되었다가 들어간다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813162621142.png" alt="image-20220813162621142"></p>
  </li>
  <li>
    <p>execute되는 원본 composite객체의 add도 파라미터 추가된  메서드를 추가한다.
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813162805494.png" alt="image-20220813162805494"></p>
  </li>
</ol>

<h4 id="커맨드홀더-소유객체composite의-필드가-추가되었으면-add만-수정하지-말고----remove도-다-처리해줘야한다-필드에-대해-oldxxxx처리">
<a class="anchor" href="#%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94-%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4composite%EC%9D%98-%ED%95%84%EB%93%9C%EA%B0%80-%EC%B6%94%EA%B0%80%EB%90%98%EC%97%88%EC%9C%BC%EB%A9%B4-add%EB%A7%8C-%EC%88%98%EC%A0%95%ED%95%98%EC%A7%80-%EB%A7%90%EA%B3%A0----remove%EB%8F%84-%EB%8B%A4-%EC%B2%98%EB%A6%AC%ED%95%B4%EC%A4%98%EC%95%BC%ED%95%9C%EB%8B%A4-%ED%95%84%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%B4-oldxxxx%EC%B2%98%EB%A6%AC" aria-hidden="true"><span class="octicon octicon-link"></span></a>커맨드홀더 소유객체(Composite)의 필드가 추가되었으면, Add만 수정하지 말고 -&gt;  Remove도 다 처리해줘야한다. (필드에 대해 oldXXXX처리)</h4>

<ol>
  <li>
    <p>현재 remove커맨드 작동시, 삭제execute 전 old필드들을 기억했다가, undo시, old필드들로 되살리는데, <strong>available도 기억했다가 되살리기 해야한다.</strong></p>

    <ul>
      <li>
        <p>기존</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813163239902.png" alt="image-20220813163239902"></p>
      </li>
      <li>
        <p>기억해야할context를 필드로 추가</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813163330555.png" alt="image-20220813163330555"></p>
      </li>
    </ul>
  </li>
</ol>

<h4 id="command홀더객체는-addremoveundoredo-이외에-소유객체의-필드setter들도-커맨드객체-처리해줘야했다">
<a class="anchor" href="#command%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4%EB%8A%94-addremoveundoredo-%EC%9D%B4%EC%99%B8%EC%97%90-%EC%86%8C%EC%9C%A0%EA%B0%9D%EC%B2%B4%EC%9D%98-%ED%95%84%EB%93%9Csetter%EB%93%A4%EB%8F%84-%EC%BB%A4%EB%A7%A8%EB%93%9C%EA%B0%9D%EC%B2%B4-%EC%B2%98%EB%A6%AC%ED%95%B4%EC%A4%98%EC%95%BC%ED%96%88%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>command홀더객체는, add/remove/undo/redo 이외에 소유객체의 필드setter들도 커맨드객체 처리해줘야했다.</h4>

<h5 id="available은-tf라서-toggle만-만들어줬었는데-객체-재활용을-통한-생성을-하기-위해-setter로-만들어줘야한다">
<a class="anchor" href="#available%EC%9D%80-tf%EB%9D%BC%EC%84%9C-toggle%EB%A7%8C-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A4%AC%EC%97%88%EB%8A%94%EB%8D%B0-%EA%B0%9D%EC%B2%B4-%EC%9E%AC%ED%99%9C%EC%9A%A9%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%83%9D%EC%84%B1%EC%9D%84-%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%B4-setter%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A4%98%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>available은 t/f라서 toggle만 만들어줬었는데, 객체 재활용을 통한 생성을 하기 위해 setter로 만들어줘야한다.</h5>

<ul>
  <li>
    <p>기존</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813163551300.png" alt="image-20220813163551300"></p>
  </li>
</ul>

<ol>
  <li>
    <p>command홀더객체내 available setter 서비스 메서드를 만들어주고</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813163701356.png" alt="image-20220813163701356"></p>
  </li>
  <li>
    <p>setter에 대한 cmd객체를 만들어준다.</p>

    <ul>
      <li><strong>setter의 execute는 set전에 old값 기억후, undo가능하게 하기다</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813163932799.png" alt="image-20220813163932799"></p>
  </li>
</ol>

<h5 id="다시-test로-넘어와서-자식데이터-중에-available까지-뽑아서-자식menu를-추가해준다">
<a class="anchor" href="#%EB%8B%A4%EC%8B%9C-test%EB%A1%9C-%EB%84%98%EC%96%B4%EC%99%80%EC%84%9C-%EC%9E%90%EC%8B%9D%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A4%91%EC%97%90-available%EA%B9%8C%EC%A7%80-%EB%BD%91%EC%95%84%EC%84%9C-%EC%9E%90%EC%8B%9Dmenu%EB%A5%BC-%EC%B6%94%EA%B0%80%ED%95%B4%EC%A4%80%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>다시 Test로 넘어와서, 자식데이터 중에 available까지 뽑아서 자식menu를 추가해준다</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813164238446.png" alt="image-20220813164238446"></p>

<h4 id="16-sub-담에-를-발견해서-자식데이터-추출후-add했다면--닫히기-전에-로-자식의-자식이-있는지-확인해야한다">
<a class="anchor" href="#16-sub-%EB%8B%B4%EC%97%90-%EB%A5%BC-%EB%B0%9C%EA%B2%AC%ED%95%B4%EC%84%9C-%EC%9E%90%EC%8B%9D%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B6%94%EC%B6%9C%ED%9B%84-add%ED%96%88%EB%8B%A4%EB%A9%B4--%EB%8B%AB%ED%9E%88%EA%B8%B0-%EC%A0%84%EC%97%90-%EB%A1%9C-%EC%9E%90%EC%8B%9D%EC%9D%98-%EC%9E%90%EC%8B%9D%EC%9D%B4-%EC%9E%88%EB%8A%94%EC%A7%80-%ED%99%95%EC%9D%B8%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>16 sub[ 담에 <code class="language-plaintext highlighter-rouge">{</code>를 발견해서 자식데이터 추출후 add했다면, <code class="language-plaintext highlighter-rouge">}</code> 닫히기 전에 <code class="language-plaintext highlighter-rouge">[로 자식의 자식</code>이 있는지 확인해야한다</h4>

<h5 id="하지만--자식-발견하도-바로-continue로-넘어가는게-아니라-이어서-추출cursor업뎃자식add후-자식의-자식이-있는지-vs--가-바로-나와서-sub가-닫히는지-검사하는-중이다">
<a class="anchor" href="#%ED%95%98%EC%A7%80%EB%A7%8C--%EC%9E%90%EC%8B%9D-%EB%B0%9C%EA%B2%AC%ED%95%98%EB%8F%84-%EB%B0%94%EB%A1%9C-continue%EB%A1%9C-%EB%84%98%EC%96%B4%EA%B0%80%EB%8A%94%EA%B2%8C-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%9D%B4%EC%96%B4%EC%84%9C-%EC%B6%94%EC%B6%9Ccursor%EC%97%85%EB%8E%83%EC%9E%90%EC%8B%9Dadd%ED%9B%84-%EC%9E%90%EC%8B%9D%EC%9D%98-%EC%9E%90%EC%8B%9D%EC%9D%B4-%EC%9E%88%EB%8A%94%EC%A7%80-vs--%EA%B0%80-%EB%B0%94%EB%A1%9C-%EB%82%98%EC%99%80%EC%84%9C-sub%EA%B0%80-%EB%8B%AB%ED%9E%88%EB%8A%94%EC%A7%80-%EA%B2%80%EC%82%AC%ED%95%98%EB%8A%94-%EC%A4%91%EC%9D%B4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>하지만, <code class="language-plaintext highlighter-rouge">{</code> 자식 발견하도 바로 continue로 넘어가는게 아니라 이어서 <code class="language-plaintext highlighter-rouge">추출+cursor업뎃+자식add</code>후 <code class="language-plaintext highlighter-rouge">자식의 자식[</code>이 있는지 vs ` ]가 바로 나와서 sub[가 닫히는지 `검사하는 중이다.</h5>

<ul>
  <li>
    <p>일단 자식발견해서 add하는 부분을 리팩토링하자</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813165356011.png" alt="image-20220813165356011"></p>
  </li>
</ul>

<h5 id="if로-1개의-작업이-끝났다면-빠른-continue를-해주는게-좋은데-뒤에-공통로직인-반복문변수-업데이트로직-cursor가-남아있다면-continue로-끝내면-안된다">
<a class="anchor" href="#if%EB%A1%9C-1%EA%B0%9C%EC%9D%98-%EC%9E%91%EC%97%85%EC%9D%B4-%EB%81%9D%EB%82%AC%EB%8B%A4%EB%A9%B4-%EB%B9%A0%EB%A5%B8-continue%EB%A5%BC-%ED%95%B4%EC%A3%BC%EB%8A%94%EA%B2%8C-%EC%A2%8B%EC%9D%80%EB%8D%B0-%EB%92%A4%EC%97%90-%EA%B3%B5%ED%86%B5%EB%A1%9C%EC%A7%81%EC%9D%B8-%EB%B0%98%EB%B3%B5%EB%AC%B8%EB%B3%80%EC%88%98-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%A1%9C%EC%A7%81-cursor%EA%B0%80-%EB%82%A8%EC%95%84%EC%9E%88%EB%8B%A4%EB%A9%B4-continue%EB%A1%9C-%EB%81%9D%EB%82%B4%EB%A9%B4-%EC%95%88%EB%90%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>if로 1개의 작업이 끝났다면, 빠른 continue를 해주는게 좋은데… <code class="language-plaintext highlighter-rouge">뒤에 공통로직인 [반복문변수 업데이트로직] cursor++</code>가 남아있다면, continue로 끝내면 안된다.</h5>

<ul>
  <li>
    <p><strong>최대한 if로 어떤처리가 끝나면 <code class="language-plaintext highlighter-rouge">continue</code>로 다음 루프로 넘어가자</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813170636557.png" alt="image-20220813170636557"></p>
  </li>
  <li>
    <p><strong>하지만, 반복문에서는 <code class="language-plaintext highlighter-rouge">continue전에 반복문변수 업데이트</code>를 해줘야한다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813171145554.png" alt="image-20220813171145554"></p>
  </li>
</ul>

<h5 id="매번-if---continue할때마다-cursor업데이트할지-vs-if만-처리하고-continue없이-공통으로-cursor업데이트할지-정해야한다">
<a class="anchor" href="#%EB%A7%A4%EB%B2%88-if---continue%ED%95%A0%EB%95%8C%EB%A7%88%EB%8B%A4-cursor%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%ED%95%A0%EC%A7%80-vs-if%EB%A7%8C-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B3%A0-continue%EC%97%86%EC%9D%B4-%EA%B3%B5%ED%86%B5%EC%9C%BC%EB%A1%9C-cursor%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%ED%95%A0%EC%A7%80-%EC%A0%95%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>매번 if - continue할때마다 cursor업데이트할지 vs if만 처리하고 continue없이 공통으로 cursor업데이트할지 정해야한다</h5>

<ul>
  <li>
    <p>매번 해준다면, 코드가 반복될 것이다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813171252697.png" alt="image-20220813171252697"></p>
  </li>
</ul>

<h5 id="반복문내-모든-if에-대해-밑에-반복문-업데이트-같은-공통로직이-남아있다면-if에서-early-continue하면-안된다">
<a class="anchor" href="#%EB%B0%98%EB%B3%B5%EB%AC%B8%EB%82%B4-%EB%AA%A8%EB%93%A0-if%EC%97%90-%EB%8C%80%ED%95%B4-%EB%B0%91%EC%97%90-%EB%B0%98%EB%B3%B5%EB%AC%B8-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EA%B0%99%EC%9D%80-%EA%B3%B5%ED%86%B5%EB%A1%9C%EC%A7%81%EC%9D%B4-%EB%82%A8%EC%95%84%EC%9E%88%EB%8B%A4%EB%A9%B4-if%EC%97%90%EC%84%9C-early-continue%ED%95%98%EB%A9%B4-%EC%95%88%EB%90%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>반복문내 모든 if에 대해 밑에 반복문 업데이트 같은 공통로직이 남아있다면, if에서 early continue하면 안된다</h5>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">모든 if에 대해 밑에 반복문 업데이트 같은 공통로직</code>이 남아있다면, if에서 early continue하면 안된다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813171411961.png" alt="image-20220813171411961"></p>
  </li>
</ul>

<h5 id="이대로-반복문이-흘러가면-자식-발견후-같은level의-다음자식들은-다-발견될시-데이터-추출후-add가-끝날-것이다">
<a class="anchor" href="#%EC%9D%B4%EB%8C%80%EB%A1%9C-%EB%B0%98%EB%B3%B5%EB%AC%B8%EC%9D%B4-%ED%9D%98%EB%9F%AC%EA%B0%80%EB%A9%B4-%EC%9E%90%EC%8B%9D-%EB%B0%9C%EA%B2%AC%ED%9B%84-%EA%B0%99%EC%9D%80level%EC%9D%98-%EB%8B%A4%EC%9D%8C%EC%9E%90%EC%8B%9D%EB%93%A4%EC%9D%80-%EB%8B%A4-%EB%B0%9C%EA%B2%AC%EB%90%A0%EC%8B%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B6%94%EC%B6%9C%ED%9B%84-add%EA%B0%80-%EB%81%9D%EB%82%A0-%EA%B2%83%EC%9D%B4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>이대로 반복문이 흘러가면, 자식 발견후, 같은level의 다음자식들은 다 <code class="language-plaintext highlighter-rouge">{</code>발견될시 데이터 추출후 add가 끝날 것이다.</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813170810889.png" alt="image-20220813170810889"></p>

<h4 id="17--확인으로-자식의-데이터를-추출해-add했다면-다음-해야할-일은-자식의-가-열리고-가-발견되어-또다른-depth자식의-자식이-열리는지-확인해야한다-그리고-이것은--가-발견되어서-최소-1개의-자식이-있고-거기서-sub-가-열리는지-확인하는-것이다">
<a class="anchor" href="#17--%ED%99%95%EC%9D%B8%EC%9C%BC%EB%A1%9C-%EC%9E%90%EC%8B%9D%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%B6%94%EC%B6%9C%ED%95%B4-add%ED%96%88%EB%8B%A4%EB%A9%B4-%EB%8B%A4%EC%9D%8C-%ED%95%B4%EC%95%BC%ED%95%A0-%EC%9D%BC%EC%9D%80-%EC%9E%90%EC%8B%9D%EC%9D%98-%EA%B0%80-%EC%97%B4%EB%A6%AC%EA%B3%A0-%EA%B0%80-%EB%B0%9C%EA%B2%AC%EB%90%98%EC%96%B4-%EB%98%90%EB%8B%A4%EB%A5%B8-depth%EC%9E%90%EC%8B%9D%EC%9D%98-%EC%9E%90%EC%8B%9D%EC%9D%B4-%EC%97%B4%EB%A6%AC%EB%8A%94%EC%A7%80-%ED%99%95%EC%9D%B8%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%9D%B4%EA%B2%83%EC%9D%80--%EA%B0%80-%EB%B0%9C%EA%B2%AC%EB%90%98%EC%96%B4%EC%84%9C-%EC%B5%9C%EC%86%8C-1%EA%B0%9C%EC%9D%98-%EC%9E%90%EC%8B%9D%EC%9D%B4-%EC%9E%88%EA%B3%A0-%EA%B1%B0%EA%B8%B0%EC%84%9C-sub-%EA%B0%80-%EC%97%B4%EB%A6%AC%EB%8A%94%EC%A7%80-%ED%99%95%EC%9D%B8%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>17  <code class="language-plaintext highlighter-rouge">{</code>확인으로 자식의 데이터를 추출해 add했다면, 다음 해야할 일은, 자식의 <code class="language-plaintext highlighter-rouge">[</code>가 열리고 <code class="language-plaintext highlighter-rouge">{</code>가 발견되어 또다른 depth(자식의 자식)이 열리는지 확인해야한다. 그리고 이것은  <code class="language-plaintext highlighter-rouge">{</code>가 발견되어서 <code class="language-plaintext highlighter-rouge">최소 1개의 자식이 있고, 거기서 sub: [</code>가 열리는지 확인하는 것이다.</h4>

<h5 id="반복문-속에서-특정if에-걸린-것을-확인하는-방법은-가변변수를-통해-결과물or불린flag을-챙겨놓는-방법-밖이다">
<a class="anchor" href="#%EB%B0%98%EB%B3%B5%EB%AC%B8-%EC%86%8D%EC%97%90%EC%84%9C-%ED%8A%B9%EC%A0%95if%EC%97%90-%EA%B1%B8%EB%A6%B0-%EA%B2%83%EC%9D%84-%ED%99%95%EC%9D%B8%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80-%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98%EB%A5%BC-%ED%86%B5%ED%95%B4-%EA%B2%B0%EA%B3%BC%EB%AC%BCor%EB%B6%88%EB%A6%B0flag%EC%9D%84-%EC%B1%99%EA%B2%A8%EB%86%93%EB%8A%94-%EB%B0%A9%EB%B2%95-%EB%B0%96%EC%9D%B4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>반복문 속에서 특정if에 걸린 것을 확인하는 방법은 가변변수를 통해 결과물or불린Flag을 챙겨놓는 방법 밖이다.</h5>

<ul>
  <li>if에 걸려서 결과물이 있다면, 그것을 형으로 하는 가변변수 = None초기화로 챙겨놓으면 된다.
    <ul>
      <li>만약 결과물이 없는 void로직이라면, bolean가변변수 = false;초기화의 Flag변수를 챙겨야한다</li>
    </ul>
  </li>
</ul>

<h5 id="원래-load는-composite객체의-add로-자식을-넣지만-테스트에서는-포장된-command홀더객체를-사용하고-커맨드홀더객체들의-메서드들은-결과물이-없는-void라서-지연실행한다고-했다---지금은-boolean으로-플래그를-챙기고-내부에서는-add결과물로-if걸린-것을-확인하도록-바꾸자">
<a class="anchor" href="#%EC%9B%90%EB%9E%98-load%EB%8A%94-composite%EA%B0%9D%EC%B2%B4%EC%9D%98-add%EB%A1%9C-%EC%9E%90%EC%8B%9D%EC%9D%84-%EB%84%A3%EC%A7%80%EB%A7%8C-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C%EB%8A%94-%ED%8F%AC%EC%9E%A5%EB%90%9C-command%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B3%A0-%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4%EB%93%A4%EC%9D%98-%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4%EC%9D%80-%EA%B2%B0%EA%B3%BC%EB%AC%BC%EC%9D%B4-%EC%97%86%EB%8A%94-void%EB%9D%BC%EC%84%9C-%EC%A7%80%EC%97%B0%EC%8B%A4%ED%96%89%ED%95%9C%EB%8B%A4%EA%B3%A0-%ED%96%88%EB%8B%A4---%EC%A7%80%EA%B8%88%EC%9D%80-boolean%EC%9C%BC%EB%A1%9C-%ED%94%8C%EB%9E%98%EA%B7%B8%EB%A5%BC-%EC%B1%99%EA%B8%B0%EA%B3%A0-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C%EB%8A%94-add%EA%B2%B0%EA%B3%BC%EB%AC%BC%EB%A1%9C-if%EA%B1%B8%EB%A6%B0-%EA%B2%83%EC%9D%84-%ED%99%95%EC%9D%B8%ED%95%98%EB%8F%84%EB%A1%9D-%EB%B0%94%EA%BE%B8%EC%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>원래 load는 composite객체의 add로 자식을 넣지만, 테스트에서는 포장된 command홀더객체를 사용하고, 커맨드홀더객체들의 메서드들은 결과물이 없는 void라서 지연실행한다고 했다. -&gt; 지금은 boolean으로 플래그를 챙기고. 내부에서는 add결과물로 if걸린 것을 확인하도록 바꾸자.</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/3de730bd-f4bd-4250-ac1a-ce5297a6beb0.gif" alt="3de730bd-f4bd-4250-ac1a-ce5297a6beb0"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813174409922.png" alt="image-20220813174409922"></p>

<h4 id="18-자신의-처리후---반복문으로-데이터뽑아-자식들을-채우다가-자식의-자식을-발견한-순간부터는-재귀를-돌려야한다">
<a class="anchor" href="#18-%EC%9E%90%EC%8B%A0%EC%9D%98-%EC%B2%98%EB%A6%AC%ED%9B%84---%EB%B0%98%EB%B3%B5%EB%AC%B8%EC%9C%BC%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%BD%91%EC%95%84-%EC%9E%90%EC%8B%9D%EB%93%A4%EC%9D%84-%EC%B1%84%EC%9A%B0%EB%8B%A4%EA%B0%80-%EC%9E%90%EC%8B%9D%EC%9D%98-%EC%9E%90%EC%8B%9D%EC%9D%84-%EB%B0%9C%EA%B2%AC%ED%95%9C-%EC%88%9C%EA%B0%84%EB%B6%80%ED%84%B0%EB%8A%94-%EC%9E%AC%EA%B7%80%EB%A5%BC-%EB%8F%8C%EB%A0%A4%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>18 자신의 처리후 -&gt; 반복문으로 데이터뽑아 자식들을 채우다가, [자식의 자식]을 발견한 순간부터는 재귀를 돌려야한다</h4>

<h5 id="자신에서-자식들의-처리는--반복문--자식-1개처리로-여러자식들을-처리하도록-정의된다-이-때-반복문을-포함한-자식들처리-전체-부분을-재귀함수로-추출해야-내부에서-자식의-자식이-등장할-때-똑같이-반복문--자식1개로-처리--자식의-자식들-재귀로-처리-처리를-할-수-있다">
<a class="anchor" href="#%EC%9E%90%EC%8B%A0%EC%97%90%EC%84%9C-%EC%9E%90%EC%8B%9D%EB%93%A4%EC%9D%98-%EC%B2%98%EB%A6%AC%EB%8A%94--%EB%B0%98%EB%B3%B5%EB%AC%B8--%EC%9E%90%EC%8B%9D-1%EA%B0%9C%EC%B2%98%EB%A6%AC%EB%A1%9C-%EC%97%AC%EB%9F%AC%EC%9E%90%EC%8B%9D%EB%93%A4%EC%9D%84-%EC%B2%98%EB%A6%AC%ED%95%98%EB%8F%84%EB%A1%9D-%EC%A0%95%EC%9D%98%EB%90%9C%EB%8B%A4-%EC%9D%B4-%EB%95%8C-%EB%B0%98%EB%B3%B5%EB%AC%B8%EC%9D%84-%ED%8F%AC%ED%95%A8%ED%95%9C-%EC%9E%90%EC%8B%9D%EB%93%A4%EC%B2%98%EB%A6%AC-%EC%A0%84%EC%B2%B4-%EB%B6%80%EB%B6%84%EC%9D%84-%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EB%A1%9C-%EC%B6%94%EC%B6%9C%ED%95%B4%EC%95%BC-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EC%9E%90%EC%8B%9D%EC%9D%98-%EC%9E%90%EC%8B%9D%EC%9D%B4-%EB%93%B1%EC%9E%A5%ED%95%A0-%EB%95%8C-%EB%98%91%EA%B0%99%EC%9D%B4-%EB%B0%98%EB%B3%B5%EB%AC%B8--%EC%9E%90%EC%8B%9D1%EA%B0%9C%EB%A1%9C-%EC%B2%98%EB%A6%AC--%EC%9E%90%EC%8B%9D%EC%9D%98-%EC%9E%90%EC%8B%9D%EB%93%A4-%EC%9E%AC%EA%B7%80%EB%A1%9C-%EC%B2%98%EB%A6%AC-%EC%B2%98%EB%A6%AC%EB%A5%BC-%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>자신에서 [자식들의 처리]는  [반복문 + 자식 1개처리]로 여러자식들을 처리하도록 정의된다. 이 때, [반복문을 포함한 자식들처리 전체] 부분을 재귀함수로 추출해야, 내부에서 자식의 자식이 등장할 때, 똑같이 [반복문 + 자식1개로 처리 + 자식의 자식들 재귀로 처리] 처리를 할 수 있다.</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813175744358.png" alt="image-20220813175744358"></p>

<h5 id="재귀함수에서는-반복문내-자식1개-객체--재귀에서-자식의-자식으로-업데이트되어서-호출되어야하므로-재귀함수-파라미터에는-반복문내-자식1개-객체가-포함된-후---자식의-자식으로-업뎃하여-호출되어야-한다">
<a class="anchor" href="#%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EC%97%90%EC%84%9C%EB%8A%94-%EB%B0%98%EB%B3%B5%EB%AC%B8%EB%82%B4-%EC%9E%90%EC%8B%9D1%EA%B0%9C-%EA%B0%9D%EC%B2%B4--%EC%9E%AC%EA%B7%80%EC%97%90%EC%84%9C-%EC%9E%90%EC%8B%9D%EC%9D%98-%EC%9E%90%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%90%98%EC%96%B4%EC%84%9C-%ED%98%B8%EC%B6%9C%EB%90%98%EC%96%B4%EC%95%BC%ED%95%98%EB%AF%80%EB%A1%9C-%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EC%97%90%EB%8A%94-%EB%B0%98%EB%B3%B5%EB%AC%B8%EB%82%B4-%EC%9E%90%EC%8B%9D1%EA%B0%9C-%EA%B0%9D%EC%B2%B4%EA%B0%80-%ED%8F%AC%ED%95%A8%EB%90%9C-%ED%9B%84---%EC%9E%90%EC%8B%9D%EC%9D%98-%EC%9E%90%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EC%97%85%EB%8E%83%ED%95%98%EC%97%AC-%ED%98%B8%EC%B6%9C%EB%90%98%EC%96%B4%EC%95%BC-%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>재귀함수에서는 [반복문내 자식1개 객체]-&gt; [재귀에서 자식의 자식으로 업데이트]되어서 호출되어야하므로 [재귀함수 파라미터에는 반복문내 자식1개 객체가 포함된 후 -&gt; 자식의 자식으로 업뎃하여 호출]되어야 한다.</h5>

<ul>
  <li>
    <p>위에서 값이 초기화되어 필요한 변수인 json이나, 가변변수들은 알아서 파라미터로 뽑힌다.</p>
  </li>
  <li>
    <p><strong>재귀함수를 정의할 때 고려해야할 것은</strong></p>

    <ol>
      <li>
        <p>다음stack결정변수</p>

        <ol>
          <li>
            <p>값이라면: cnt(0)-&gt; cnt+1, n-&gt;n-1</p>

            <ul>
              <li>종착역 if cnt == 2, n == 1 등</li>
            </ul>
          </li>
          <li>
            <p><strong>연결된 객체라면:</strong></p>

            <ol>
              <li>객체 -&gt; <code class="language-plaintext highlighter-rouge">객체 = 객체.next</code>,</li>
              <li><strong>객체 -&gt; <code class="language-plaintext highlighter-rouge">반복문속 자식객체</code>,</strong></li>
              <li>외부에서 사용한다면 <code class="language-plaintext highlighter-rouge">객체.재귀메서드() -&gt; 다음객체로 업뎃 -&gt; 다음객체.재귀메서드()</code>
</li>
            </ol>

            <ul>
              <li>종착역
                <ul>
                  <li>if  객체 == 시작특이점객체</li>
                  <li>
<strong>아예 자식객체가 없어서 반복문 x -&gt; 다음재귀 호출x</strong>
                    <ul>
                      <li><strong>반복문속의 자식객체.재귀호출()는 종착역이 따로 필요없다</strong></li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ol>
      </li>
      <li>
        <p>필요정보 변수(전역변수면 노상관이지만 객체에선 x)</p>
      </li>
      <li>
        <p>계속 업데이트되는 가변변수</p>
      </li>
      <li>
        <p>연산식을 직접 적어서 업데이트하는 누적결과값</p>
      </li>
    </ol>
  </li>
</ul>

<h4 id="19-직접-composite객체의-자식객체들-생성을-위한-재귀로-만들어보기">
<a class="anchor" href="#19-%EC%A7%81%EC%A0%91-composite%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%9E%90%EC%8B%9D%EA%B0%9D%EC%B2%B4%EB%93%A4-%EC%83%9D%EC%84%B1%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9E%AC%EA%B7%80%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>19 직접 composite객체의 자식객체들 생성을 위한 재귀로 만들어보기</h4>

<h5 id="root의-자신처리는-재귀에서-제외한다--자식들부터만-자신의-처리가-반복문--자신처리1개의-여러번-반복되기-때문이다">
<a class="anchor" href="#root%EC%9D%98-%EC%9E%90%EC%8B%A0%EC%B2%98%EB%A6%AC%EB%8A%94-%EC%9E%AC%EA%B7%80%EC%97%90%EC%84%9C-%EC%A0%9C%EC%99%B8%ED%95%9C%EB%8B%A4--%EC%9E%90%EC%8B%9D%EB%93%A4%EB%B6%80%ED%84%B0%EB%A7%8C-%EC%9E%90%EC%8B%A0%EC%9D%98-%EC%B2%98%EB%A6%AC%EA%B0%80-%EB%B0%98%EB%B3%B5%EB%AC%B8--%EC%9E%90%EC%8B%A0%EC%B2%98%EB%A6%AC1%EA%B0%9C%EC%9D%98-%EC%97%AC%EB%9F%AC%EB%B2%88-%EB%B0%98%EB%B3%B5%EB%90%98%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%9D%B4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>root의 자신처리는 재귀에서 제외한다.  [자식들부터만, 자신의 처리가 반복문 + 자신처리1개의 여러번 반복되기 때문]이다.</h5>

<h5 id="01-root의-자식들처리를-위한-반복문부터-재귀메서드로서-메서드-추출한다">
<a class="anchor" href="#01-root%EC%9D%98-%EC%9E%90%EC%8B%9D%EB%93%A4%EC%B2%98%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%B0%98%EB%B3%B5%EB%AC%B8%EB%B6%80%ED%84%B0-%EC%9E%AC%EA%B7%80%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C%EC%84%9C-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%B6%94%EC%B6%9C%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>01 root의 자식들처리를 위한 반복문부터 재귀메서드로서 메서드 추출한다.</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/da0966c2-7f16-41e9-b52f-9f18f5f2b52c.gif" alt="da0966c2-7f16-41e9-b52f-9f18f5f2b52c"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813182545351.png" alt="image-20220813182545351"></p>

<h5 id="02-객체의-반복문처리-재귀는-반복문내-자식객체1개---자식의-자식-등장---자식의-자식객체-1개로-업데이트된-재귀-호출을-하면-된다--그러기-위해서는-파라미터로-자식객체-1개의-형이-올라와야하며-인자는-child---파라미터는-parent로-명명해준다">
<a class="anchor" href="#02-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B0%98%EB%B3%B5%EB%AC%B8%EC%B2%98%EB%A6%AC-%EC%9E%AC%EA%B7%80%EB%8A%94-%EB%B0%98%EB%B3%B5%EB%AC%B8%EB%82%B4-%EC%9E%90%EC%8B%9D%EA%B0%9D%EC%B2%B41%EA%B0%9C---%EC%9E%90%EC%8B%9D%EC%9D%98-%EC%9E%90%EC%8B%9D-%EB%93%B1%EC%9E%A5---%EC%9E%90%EC%8B%9D%EC%9D%98-%EC%9E%90%EC%8B%9D%EA%B0%9D%EC%B2%B4-1%EA%B0%9C%EB%A1%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%90%9C-%EC%9E%AC%EA%B7%80-%ED%98%B8%EC%B6%9C%EC%9D%84-%ED%95%98%EB%A9%B4-%EB%90%9C%EB%8B%A4--%EA%B7%B8%EB%9F%AC%EA%B8%B0-%EC%9C%84%ED%95%B4%EC%84%9C%EB%8A%94-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A1%9C-%EC%9E%90%EC%8B%9D%EA%B0%9D%EC%B2%B4-1%EA%B0%9C%EC%9D%98-%ED%98%95%EC%9D%B4-%EC%98%AC%EB%9D%BC%EC%99%80%EC%95%BC%ED%95%98%EB%A9%B0-%EC%9D%B8%EC%9E%90%EB%8A%94-child---%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%8A%94-parent%EB%A1%9C-%EB%AA%85%EB%AA%85%ED%95%B4%EC%A4%80%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>02 객체의 반복문처리 재귀는 [반복문내 자식객체1개 -&gt; 자식의 자식 등장 -&gt; 자식의 자식객체 1개로 업데이트된 재귀 호출]을 하면 된다.  그러기 위해서는, [파라미터로 자식객체 1개의 형]이 올라와야하며 [인자는 child -&gt; 파라미터는 parent로 명명]해준다.</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/06624dc6-9225-4a79-9419-b2eeecc74e7f.gif" alt="06624dc6-9225-4a79-9419-b2eeecc74e7f"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813183206801.png" alt="image-20220813183206801"></p>

<h5 id="03-문제상황1-객체반복문-재귀메서드의-stack결정-파라미터-초기값이-반복문내-자식1개-객체가-아니라-root-자신이-들어간다---아-재귀에서-인자는-필요한-현재상태-값root일-뿐이고-실제--내부-작동하는-것은그-상태값으로-만들어진-다음-자식객체child-내부에서-만들어지거나-getter로-불려져서-그놈이-다음재귀에-상태값으로-들어가는-구나">
<a class="anchor" href="#03-%EB%AC%B8%EC%A0%9C%EC%83%81%ED%99%A91-%EA%B0%9D%EC%B2%B4%EB%B0%98%EB%B3%B5%EB%AC%B8-%EC%9E%AC%EA%B7%80%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-stack%EA%B2%B0%EC%A0%95-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-%EC%B4%88%EA%B8%B0%EA%B0%92%EC%9D%B4-%EB%B0%98%EB%B3%B5%EB%AC%B8%EB%82%B4-%EC%9E%90%EC%8B%9D1%EA%B0%9C-%EA%B0%9D%EC%B2%B4%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC-root-%EC%9E%90%EC%8B%A0%EC%9D%B4-%EB%93%A4%EC%96%B4%EA%B0%84%EB%8B%A4---%EC%95%84-%EC%9E%AC%EA%B7%80%EC%97%90%EC%84%9C-%EC%9D%B8%EC%9E%90%EB%8A%94-%ED%95%84%EC%9A%94%ED%95%9C-%ED%98%84%EC%9E%AC%EC%83%81%ED%83%9C-%EA%B0%92root%EC%9D%BC-%EB%BF%90%EC%9D%B4%EA%B3%A0-%EC%8B%A4%EC%A0%9C--%EB%82%B4%EB%B6%80-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%80%EA%B7%B8-%EC%83%81%ED%83%9C%EA%B0%92%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A7%84-%EB%8B%A4%EC%9D%8C-%EC%9E%90%EC%8B%9D%EA%B0%9D%EC%B2%B4child-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A7%80%EA%B1%B0%EB%82%98-getter%EB%A1%9C-%EB%B6%88%EB%A0%A4%EC%A0%B8%EC%84%9C-%EA%B7%B8%EB%86%88%EC%9D%B4-%EB%8B%A4%EC%9D%8C%EC%9E%AC%EA%B7%80%EC%97%90-%EC%83%81%ED%83%9C%EA%B0%92%EC%9C%BC%EB%A1%9C-%EB%93%A4%EC%96%B4%EA%B0%80%EB%8A%94-%EA%B5%AC%EB%82%98" aria-hidden="true"><span class="octicon octicon-link"></span></a>03 문제상황1) 객체반복문 재귀메서드의 stack결정 파라미터 초기값이 반복문내 자식1개 객체가 아니라, [root 자신]이 들어간다. -&gt; “아~! 재귀에서 인자는 필요한 현재상태 값(root)일 뿐이고, 실제  내부 작동하는 것은,그 상태값으로 만들어진 다음 자식객체(child) 내부에서 만들어지거나 getter로 불려져서, 그놈이 다음재귀에 상태값으로 들어가는 구나~!”</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813183958568.png" alt="image-20220813183958568"></p>

<h5 id="04-문제상황2-root가-들어갔으면-반복문내-자식객체1개가-만들어져서-변수로-활용되어야-다음-재귀의-root대신-들어가서-자신이-root역할을-한다">
<a class="anchor" href="#04-%EB%AC%B8%EC%A0%9C%EC%83%81%ED%99%A92-root%EA%B0%80-%EB%93%A4%EC%96%B4%EA%B0%94%EC%9C%BC%EB%A9%B4-%EB%B0%98%EB%B3%B5%EB%AC%B8%EB%82%B4-%EC%9E%90%EC%8B%9D%EA%B0%9D%EC%B2%B41%EA%B0%9C%EA%B0%80-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A0%B8%EC%84%9C-%EB%B3%80%EC%88%98%EB%A1%9C-%ED%99%9C%EC%9A%A9%EB%90%98%EC%96%B4%EC%95%BC-%EB%8B%A4%EC%9D%8C-%EC%9E%AC%EA%B7%80%EC%9D%98-root%EB%8C%80%EC%8B%A0-%EB%93%A4%EC%96%B4%EA%B0%80%EC%84%9C-%EC%9E%90%EC%8B%A0%EC%9D%B4-root%EC%97%AD%ED%95%A0%EC%9D%84-%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>04 문제상황2) root가 들어갔으면, [반복문내 자식객체1개]가 만들어져서 변수로 활용되어야, 다음 재귀의 root대신 들어가서 자신이 root역할을 한다?!</h5>

<ul>
  <li>
    <p>원래 커맨드홀더객체#load내에서는, 소유한 composite객체로 처리하며, add결과 <strong>add된 자식객체 1개가 추출된다</strong></p>

    <ul>
      <li><strong>하지만 지금은 cmd객체를 사용하고 있어서, void로 add결과 아무것도 안나온다</strong></li>
      <li><strong>억지로 맨 마지막것을 뱉어내도록 getter를 만들어줘야하나??</strong></li>
      <li>기존의 자식들을 불러내주는 getter가 있으므로 이것의 제일 마지막 것을 대신 사용하자</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/f331f88b-f453-48b5-8167-9c0b21f7610b.gif" alt="f331f88b-f453-48b5-8167-9c0b21f7610b"></p>
  </li>
  <li>
    <p><strong>add후 추가된 child 객체 1개를 뽑아냈다면, flag 가변변수를 대체하고, 사용하자</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813184838503.png" alt="image-20220813184838503"></p>
  </li>
</ul>

<h5 id="05-이제-자식의-자식이-발견된-시점에서-자식의-자식을---자식처럼-처리하기-위해-재귀메서드를-parent---child로-바꿔호출해준다">
<a class="anchor" href="#05-%EC%9D%B4%EC%A0%9C-%EC%9E%90%EC%8B%9D%EC%9D%98-%EC%9E%90%EC%8B%9D%EC%9D%B4-%EB%B0%9C%EA%B2%AC%EB%90%9C-%EC%8B%9C%EC%A0%90%EC%97%90%EC%84%9C-%EC%9E%90%EC%8B%9D%EC%9D%98-%EC%9E%90%EC%8B%9D%EC%9D%84---%EC%9E%90%EC%8B%9D%EC%B2%98%EB%9F%BC-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%B4-%EC%9E%AC%EA%B7%80%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-parent---child%EB%A1%9C-%EB%B0%94%EA%BF%94%ED%98%B8%EC%B6%9C%ED%95%B4%EC%A4%80%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>05 이제 자식의 자식이 발견된 시점에서, 자식의 자식을 -&gt; 자식처럼 처리하기 위해, 재귀메서드를 [parent -&gt; child로 바꿔]호출해준다.</h5>

<ul>
  <li>
    <p>자식을 억지로 가지고이 위해 child가 composite객체로 가져와서 재귀에 넣었더니, <strong>재귀메서드 자체가 최초인자가 command홀더객체라서 -&gt; composite객체로 바꾸도록 변경하고, cmd홀더객체에 getter를 써서 넣어주었다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/4493f315-361e-4769-970a-7a2792a2a994.gif" alt="4493f315-361e-4769-970a-7a2792a2a994"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813185503954.png" alt="image-20220813185503954"></p>
  </li>
  <li>
    <p>이렇게 된다면, <strong>cmd로부터 억지로 child객체를 빼올 필요없이 composite객체.add의 결과로 나온 child를 챙겨주자</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813185635818.png" alt="image-20220813185635818"></p>
  </li>
</ul>

<h5 id="06-일반적인-반복문-객체재귀의-for-자식객체들---다음재귀와-다르게-종착역-자식들-소유안해서-for가-안돌고-끝나는-곳이-종착역이-아니다-----반복문이-json과-cursor로-돌아가고-있으므로-해당depthstack의-처리가-끝나는-곳을-직접-알려줘야한다---를-만나는-순간-해당-stack을-종료해야한다">
<a class="anchor" href="#06-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EB%B0%98%EB%B3%B5%EB%AC%B8-%EA%B0%9D%EC%B2%B4%EC%9E%AC%EA%B7%80%EC%9D%98-for-%EC%9E%90%EC%8B%9D%EA%B0%9D%EC%B2%B4%EB%93%A4---%EB%8B%A4%EC%9D%8C%EC%9E%AC%EA%B7%80%EC%99%80-%EB%8B%A4%EB%A5%B4%EA%B2%8C-%EC%A2%85%EC%B0%A9%EC%97%AD-%EC%9E%90%EC%8B%9D%EB%93%A4-%EC%86%8C%EC%9C%A0%EC%95%88%ED%95%B4%EC%84%9C-for%EA%B0%80-%EC%95%88%EB%8F%8C%EA%B3%A0-%EB%81%9D%EB%82%98%EB%8A%94-%EA%B3%B3%EC%9D%B4-%EC%A2%85%EC%B0%A9%EC%97%AD%EC%9D%B4-%EC%95%84%EB%8B%88%EB%8B%A4-----%EB%B0%98%EB%B3%B5%EB%AC%B8%EC%9D%B4-json%EA%B3%BC-cursor%EB%A1%9C-%EB%8F%8C%EC%95%84%EA%B0%80%EA%B3%A0-%EC%9E%88%EC%9C%BC%EB%AF%80%EB%A1%9C-%ED%95%B4%EB%8B%B9depthstack%EC%9D%98-%EC%B2%98%EB%A6%AC%EA%B0%80-%EB%81%9D%EB%82%98%EB%8A%94-%EA%B3%B3%EC%9D%84-%EC%A7%81%EC%A0%91-%EC%95%8C%EB%A0%A4%EC%A4%98%EC%95%BC%ED%95%9C%EB%8B%A4---%EB%A5%BC-%EB%A7%8C%EB%82%98%EB%8A%94-%EC%88%9C%EA%B0%84-%ED%95%B4%EB%8B%B9-stack%EC%9D%84-%EC%A2%85%EB%A3%8C%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>06 일반적인 반복문 객체재귀의 [for 자식객체들 -&gt; 다음재귀]와 다르게 [종착역: 자식들 소유안해서 for가 안돌고 끝나는 곳이 종착역]이 아니다.   -&gt; <code class="language-plaintext highlighter-rouge">반복문이 json과 cursor로 돌아가고 있으므로, 해당depth(stack)의 처리가 끝나는 곳을 직접 알려줘야한다 -&gt; ']'를 만나는 순간 해당 stack을 종료</code>해야한다.</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/25517375-9420-4c37-89bf-d36eaf8e1c2a.gif" alt="25517375-9420-4c37-89bf-d36eaf8e1c2a"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813190713631.png" alt="image-20220813190713631"></p>

<h5 id="07-정해진-소스json을-돌며-모든-재귀stack에서-cursor를-업데이트하고-공유해야한다면-해당-stack이-끝나더라도-외부에서-초기화된-가변변수-cursor를-반환해줘야-다음-또다른-stack이-쓸-수-있다---자식객체-for문이-아니라-외부-컨트롤타워를-두고-초기화된-가변변수-cursor를-쓰는-재귀문이라면-stack끝나고-빽할-때마다-업데이트된-cursor를-종착역에서-반환해줘야한다-종착역반환---자식재귀-반환---재귀정의부-반환---외부에-반환">
<a class="anchor" href="#07-%EC%A0%95%ED%95%B4%EC%A7%84-%EC%86%8C%EC%8A%A4json%EC%9D%84-%EB%8F%8C%EB%A9%B0-%EB%AA%A8%EB%93%A0-%EC%9E%AC%EA%B7%80stack%EC%97%90%EC%84%9C-cursor%EB%A5%BC-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%ED%95%98%EA%B3%A0-%EA%B3%B5%EC%9C%A0%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4%EB%A9%B4-%ED%95%B4%EB%8B%B9-stack%EC%9D%B4-%EB%81%9D%EB%82%98%EB%8D%94%EB%9D%BC%EB%8F%84-%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-%EC%B4%88%EA%B8%B0%ED%99%94%EB%90%9C-%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98-cursor%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%B4%EC%A4%98%EC%95%BC-%EB%8B%A4%EC%9D%8C-%EB%98%90%EB%8B%A4%EB%A5%B8-stack%EC%9D%B4-%EC%93%B8-%EC%88%98-%EC%9E%88%EB%8B%A4---%EC%9E%90%EC%8B%9D%EA%B0%9D%EC%B2%B4-for%EB%AC%B8%EC%9D%B4-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%99%B8%EB%B6%80-%EC%BB%A8%ED%8A%B8%EB%A1%A4%ED%83%80%EC%9B%8C%EB%A5%BC-%EB%91%90%EA%B3%A0-%EC%B4%88%EA%B8%B0%ED%99%94%EB%90%9C-%EA%B0%80%EB%B3%80%EB%B3%80%EC%88%98-cursor%EB%A5%BC-%EC%93%B0%EB%8A%94-%EC%9E%AC%EA%B7%80%EB%AC%B8%EC%9D%B4%EB%9D%BC%EB%A9%B4-stack%EB%81%9D%EB%82%98%EA%B3%A0-%EB%B9%BD%ED%95%A0-%EB%95%8C%EB%A7%88%EB%8B%A4-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%90%9C-cursor%EB%A5%BC-%EC%A2%85%EC%B0%A9%EC%97%AD%EC%97%90%EC%84%9C-%EB%B0%98%ED%99%98%ED%95%B4%EC%A4%98%EC%95%BC%ED%95%9C%EB%8B%A4-%EC%A2%85%EC%B0%A9%EC%97%AD%EB%B0%98%ED%99%98---%EC%9E%90%EC%8B%9D%EC%9E%AC%EA%B7%80-%EB%B0%98%ED%99%98---%EC%9E%AC%EA%B7%80%EC%A0%95%EC%9D%98%EB%B6%80-%EB%B0%98%ED%99%98---%EC%99%B8%EB%B6%80%EC%97%90-%EB%B0%98%ED%99%98" aria-hidden="true"><span class="octicon octicon-link"></span></a>07 정해진 소스(json)을 돌며, 모든 재귀stack에서 cursor를 업데이트하고 공유해야한다면, 해당 stack이 끝나더라도, 외부에서 초기화된 가변변수 cursor를 반환해줘야, 다음 또다른 stack이 쓸 수 있다. -&gt; 자식객체 for문이 아니라, [외부 컨트롤타워를 두고 초기화된 가변변수 cursor를 쓰는 재귀문]이라면, [stack끝나고 빽할 때마다 업데이트된 cursor를 종착역에서 반환]해줘야한다. (<code class="language-plaintext highlighter-rouge">종착역반환 -&gt; 자식재귀 반환 -&gt; 재귀정의부 반환 -&gt; 외부에 반환</code>)</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/f60806aa-be49-4a99-a7c4-09f1358d46a7.gif" alt="f60806aa-be49-4a99-a7c4-09f1358d46a7"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813191422827.png" alt="image-20220813191422827"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813191531002.png" alt="image-20220813191531002"></p>

<h5 id="08-재귀로-더해진-자식들을-확인하기-위해-cmdgetmenu객체를-지역변수로-빼고---composite객체를-출력하라면-rendere에-consolevisitor를-주입하고-메서드인자-compoiste--report로-만들어서-넣어줘야한다">
<a class="anchor" href="#08-%EC%9E%AC%EA%B7%80%EB%A1%9C-%EB%8D%94%ED%95%B4%EC%A7%84-%EC%9E%90%EC%8B%9D%EB%93%A4%EC%9D%84-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%B4-cmdgetmenu%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98%EB%A1%9C-%EB%B9%BC%EA%B3%A0---composite%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%B6%9C%EB%A0%A5%ED%95%98%EB%9D%BC%EB%A9%B4-rendere%EC%97%90-consolevisitor%EB%A5%BC-%EC%A3%BC%EC%9E%85%ED%95%98%EA%B3%A0-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%B8%EC%9E%90-compoiste--report%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%84%9C-%EB%84%A3%EC%96%B4%EC%A4%98%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>08 재귀로 더해진 자식들을 확인하기 위해 cmd.getMenu()객체를 지역변수로 빼고 -&gt; composite객체를 출력하라면 rendere에 consolevisitor를 주입하고, 메서드인자 compoiste-&gt; report로 만들어서 넣어줘야한다</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/a754e036-8c93-4644-bc98-2ab66426e50f.gif" alt="a754e036-8c93-4644-bc98-2ab66426e50f"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813192334937.png" alt="image-20220813192334937"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813192407412.png" alt="image-20220813192407412"></p>

<h5 id="09-이제-command홀더객체-load-내부로-옮긴-뒤-재활용이-완성된-소유composite객체를-반환하도록-load메서드의-시그니쳐를-바꾼다">
<a class="anchor" href="#09-%EC%9D%B4%EC%A0%9C-command%ED%99%80%EB%8D%94%EA%B0%9D%EC%B2%B4-load-%EB%82%B4%EB%B6%80%EB%A1%9C-%EC%98%AE%EA%B8%B4-%EB%92%A4-%EC%9E%AC%ED%99%9C%EC%9A%A9%EC%9D%B4-%EC%99%84%EC%84%B1%EB%90%9C-%EC%86%8C%EC%9C%A0composite%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%98%EB%8F%84%EB%A1%9D-load%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B3%90%EB%A5%BC-%EB%B0%94%EA%BE%BC%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>09 이제 command홀더객체# load 내부로 옮긴 뒤, 재활용이 완성된 소유Composite객체를 반환하도록 load메서드의 시그니쳐를 바꾼다.</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/6be89aea-8b70-4b72-b7a1-d4000ee1249d.gif" alt="6be89aea-8b70-4b72-b7a1-d4000ee1249d"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813193011387.png" alt="image-20220813193011387"></p>

<h5 id="10-test에서는-load의-반환이-string-json---재활용완성된-composite객체를-받도록-수정하고-다시-한번-출력해보자">
<a class="anchor" href="#10-test%EC%97%90%EC%84%9C%EB%8A%94-load%EC%9D%98-%EB%B0%98%ED%99%98%EC%9D%B4-string-json---%EC%9E%AC%ED%99%9C%EC%9A%A9%EC%99%84%EC%84%B1%EB%90%9C-composite%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%B0%9B%EB%8F%84%EB%A1%9D-%EC%88%98%EC%A0%95%ED%95%98%EA%B3%A0-%EB%8B%A4%EC%8B%9C-%ED%95%9C%EB%B2%88-%EC%B6%9C%EB%A0%A5%ED%95%B4%EB%B3%B4%EC%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>10 test에서는 load의 반환이 string json -&gt; 재활용완성된 composite객체를 받도록 수정하고 다시 한번 출력해보자.</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/a8b43b66-c8b6-456e-8f7e-12c65918c84b.gif" alt="a8b43b66-c8b6-456e-8f7e-12c65918c84b"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220813193248817.png" alt="image-20220813193248817"></p>

  </div><a class="u-url" href="/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/menu/command/memento/side/2022/07/31/menu%EB%A5%BC-%EB%A7%8C%EB%93%A4%EB%A9%B0-%EC%9D%B5%ED%9E%88%EB%8A%94-command,-memento%ED%8C%A8%ED%84%B4.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>평범한 한의사 돌범의 엔지니어 도전기</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/is2js" target="_blank" title="is2js"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/is2js" target="_blank" title="is2js"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
