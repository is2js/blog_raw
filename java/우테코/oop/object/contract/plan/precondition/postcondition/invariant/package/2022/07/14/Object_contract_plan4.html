<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Object) 정책적용관련 객체들의 계약관계(Plan4)</h1><p class="page-description">정책적용과 관련된 객체들의 계약관계와 전파</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-07-14T00:00:00-05:00" itemprop="datePublished">
        Jul 14, 2022
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      6 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/categories/#java">java</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#우테코">우테코</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#oop">oop</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#object">object</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#contract">contract</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#plan">plan</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#precondition">precondition</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#postcondition">postcondition</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#invariant">invariant</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#package">package</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <!-- toc가 먼저 나오므로 h3로 안내하기 -->
    <h3>📜 제목으로 보기</h3>
    <ul class="section-nav">
<li class="toc-entry toc-h3"><a href="#계약">계약</a>
<ul>
<li class="toc-entry toc-h4"><a href="#계약조건-4가지">계약조건 4가지</a></li>
<li class="toc-entry toc-h4"><a href="#계약조건-적용하기">계약조건 적용하기</a>
<ul>
<li class="toc-entry toc-h5"><a href="#invariantplansetter로-초기화된다면-그-전에-null객체로-미리-초기화해놓기">Invariant#Plan#setter로 초기화된다면, 그 전에 null객체로 미리 초기화해놓기</a></li>
<li class="toc-entry toc-h5"><a href="#preconditionplan파라미터로-넘어온-인자의-null검증-by-thr">Precondition#Plan#파라미터로 넘어온 인자의 null검증 by thr</a></li>
<li class="toc-entry toc-h5"><a href="#preconditionplan파라미터로-넘어온-인자의-상태null객체-도메인검증-by-thr">Precondition#Plan#파라미터로 넘어온 인자의 상태(NULL객체, 도메인)검증 by thr</a></li>
<li class="toc-entry toc-h5"><a href="#postconditionplanreturn해줄-결과값에-대한-도메인-검증재료가-있을-땐-결과값이-null객체가-아니어야한다">postcondition#plan#return해줄 결과값에 대한 도메인 검증(재료가 있을 땐, 결과값이 NULL객체가 아니어야한다)</a></li>
<li class="toc-entry toc-h5"><a href="#precondition위임plan인자-객체의-상태검증에-this-context가-사용되지-않으면-묻지말고-시켜서-스스로-죽도록-코드를-옮기고--변화의여파를-없앤다">precondition위임#Plan#인자 객체의 상태검증에, this context가 사용되지 않으면 묻지말고 시켜서 스스로 죽도록 코드를 옮기고 + 변화의여파를 없앤다.</a></li>
<li class="toc-entry toc-h5"><a href="#postcondition위임plan결과값검증-과정에서-this-context가-사용되지-않으면-결과값-검증로직도-결과값-계산로직-내부로-위임한다">postcondition위임#Plan#결과값검증 과정에서 this context가 사용되지 않으면, 결과값 검증로직도 결과값 계산로직 내부로 위임한다.</a></li>
<li class="toc-entry toc-h5"><a href="#precondition위임calculator외부client가-아닌-계약자가-넘겨준-precondition의-상태검증은-애초에-계약자가-삼항연산자-등을-통해--검증된-precondition을-넘겨주도록-계약조건을-명시할-수-있다">precondition위임#Calculator#외부Client가 아닌 계약자가 넘겨준 precondition의 상태검증은 애초에 계약자가, 삼항연산자 등을 통해  검증된 precondition을 넘겨주도록 계약조건을 명시할 수 있다.</a></li>
<li class="toc-entry toc-h5"><a href="#precondition위임-invariantplan-calculatorsetter를-가져--runtime시-상태변화하는-책임위임객체전략주입-구상클래스는-생성주입시점--precondition-상태검증가-의미없어----해당객체의-계약된위임된책임메서드-호출시마다-invariant으로서-자신의-상태를-매번-검증하도록-위임하여-보장해야한다">precondition위임-&gt;Invariant#Plan-&gt;Calculator#setter를 가져  runtime시 상태변화하는 책임위임객체(전략주입 구상클래스)는 생성(주입)시점  precondition 상태검증가 의미없어 -&gt;  해당객체의 계약된(위임된)책임메서드 호출시마다 invariant으로서 자신의 상태를 매번 검증하도록 위임하여 보장해야한다.</a></li>
<li class="toc-entry toc-h5"><a href="#preconditioncalculator계약자가-넘겨주는-깨끗한-인자가-아니라-외부에서-들어오는-인자라면-precondition검증null-및-가진-상태값을-해야한다">precondition#Calculator#계약자가 넘겨주는 깨끗한 인자가 아니라 외부에서 들어오는 인자라면 precondition검증(null 및 가진 상태값)을 해야한다.</a></li>
<li class="toc-entry toc-h5"><a href="#계약의전파preconditioncalc전략객체들계약전파된-메서드는-precondition-검증이-없다">계약의전파precondition#Calc(전략객체들)#계약전파된 메서드는 precondition 검증이 없다.</a></li>
<li class="toc-entry toc-h5"><a href="#계약의전파preconditionpackage계약된-좋은-인자-보장을-위해-위임된-계약객체들의-계약된-책임메서드부터는-internal가시성을-이용하여-계약자에게-독점공급한다--만약-public-default의-인터페이스면-추상클래스로-변경한다">계약의전파precondition#package#계약된 좋은 인자 보장을 위해, 위임된 계약객체들의 계약된 책임메서드부터는 internal가시성을 이용하여 계약자에게 독점공급한다.  만약 public default의 인터페이스면 추상클래스로 변경한다.</a></li>
<li class="toc-entry toc-h5"><a href="#계약의전파preconditionpackage계약의전파로-인해-같은-병행package를-유지하여-internal독점공급하는-것은-부모와-protected관계인-구상체들에게는-해당사항이-없다-구상체들만-따로-내부package를-파서-넣어준다">계약의전파precondition#package#계약의전파로 인해 같은 병행package를 유지하여 internal독점공급하는 것은 부모와 protected관계인 구상체들에게는 해당사항이 없다. 구상체들만 따로 내부package를 파서 넣어준다.</a></li>
<li class="toc-entry toc-h5"><a href="#계약의전파postcondition훅구상체들postcondition검사는-계약전파된-pre의-더-상위레이어-계약체결로-인한-생략과-달리-매번-검증해야한다">계약의전파postcondition#훅구상체들#postcondition검사는, 계약전파된 pre의 더 상위레이어 계약체결로 인한 생략과 달리, 매번 검증해야한다.</a></li>
<li class="toc-entry toc-h5"><a href="#계약의전파postcondition구상체들계약전파-메서드의-postcondition을-검사하기-전에-결과값-계산시-사용된-상태값의-invariant를-먼저-검증하자">계약의전파postcondition#구상체들#계약전파 메서드의 postcondition을 검사하기 전에 결과값 계산시 사용된 상태값의 invariant를 먼저 검증하자.</a></li>
</ul>
</li>
</ul>
</li>
</ul><h3 id="계약">
<a class="anchor" href="#%EA%B3%84%EC%95%BD" aria-hidden="true"><span class="octicon octicon-link"></span></a>계약</h3>

<h4 id="계약조건-4가지">
<a class="anchor" href="#%EA%B3%84%EC%95%BD%EC%A1%B0%EA%B1%B4-4%EA%B0%80%EC%A7%80" aria-hidden="true"><span class="octicon octicon-link"></span></a>계약조건 4가지</h4>

<ol>
  <li>
<strong>precondition</strong>: 전달받은 메세지(인자, 파라미터)의 검증
    <ol>
      <li>validation이라고 한다.</li>
      <li>인자들의 null검증 + 인자들의 상태(도메인)검증
        <ol>
          <li>if로 무시 with 불린flag 토해내기(my early return false;로 null검증)</li>
          <li>ifThrow로 멈추기 with 메시지</li>
        </ol>
      </li>
      <li>내가 만든 형 객체라면, 형에게 시켜 스스로 검증해서 죽도록하여, 묻지않아 변화의여파가 없어진다.</li>
    </ol>
  </li>
  <li>
<strong>postcondition</strong>: 전달할 메세지(결과값)의 검증
    <ol>
      <li>반환하기 전, 결과값을 검증하는 것은 도메인검증이다.</li>
    </ol>
  </li>
  <li>
<strong>class invariant</strong>: 메세지 처리전, 클래스의 상태값(필드)의 불변성(or 필수조건 확보) 검증
    <ol>
      <li>필드초기화 하지 않고 &amp; setter로 런타임에 받아서 초기화된다면, 그전에 null객체를 넣어 초기화 해주기</li>
      <li>생성자type으로 초기화한다면, 생성자내에서 null검사하기</li>
    </ol>
  </li>
  <li>
<strong>위임된 책임의 context</strong>: 내가 계약조건을 검증하는지 확인
    <ol>
      <li>precondition위임: <strong>발동은 받은 내가 해준다.</strong>
</li>
      <li>postcondition위임: <strong>나한테는 코드가 안보인다.</strong>
</li>
    </ol>
  </li>
</ol>

<h4 id="계약조건-적용하기">
<a class="anchor" href="#%EA%B3%84%EC%95%BD%EC%A1%B0%EA%B1%B4-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>계약조건 적용하기</h4>

<ul>
  <li>
    <p><a href="https://github.com/is2js/object2/tree/dd9a367c03ad8f38cb207354500420e7c04b40e5/src/main/java/goodComposition">시작커밋</a></p>
  </li>
  <li>
    <p><strong>Plan - Calculator(전략주입 구상클래스) - Calc(전략인터페이스) - 전략객체들</strong></p>
    <ul>
      <li><strong>Plan과 1차 계약자 Calculator의 pre/post/invariant를 체크한다.</strong></li>
      <li><strong>이후 계약의 전파를 생각한다.</strong></li>
    </ul>
  </li>
</ul>

<h5 id="invariantplansetter로-초기화된다면-그-전에-null객체로-미리-초기화해놓기">
<a class="anchor" href="#invariantplansetter%EB%A1%9C-%EC%B4%88%EA%B8%B0%ED%99%94%EB%90%9C%EB%8B%A4%EB%A9%B4-%EA%B7%B8-%EC%A0%84%EC%97%90-null%EA%B0%9D%EC%B2%B4%EB%A1%9C-%EB%AF%B8%EB%A6%AC-%EC%B4%88%EA%B8%B0%ED%99%94%ED%95%B4%EB%86%93%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>Invariant#Plan#setter로 초기화된다면, 그 전에 null객체로 미리 초기화해놓기</h5>

<ol>
  <li>
    <p>setter로 주입받는 <strong>Calculator필드</strong>는 <strong>런타임 때 받기기능을 부르기 전에, calculateFee()를 호출한다면, NullPoint예외가 발생할 것이다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713162535510.png" alt="image-20220713162535510"></p>

    <ul>
      <li>calculateFee()에 <strong>throws도 안달려있어서 NP예외를 예상할 수도 없다.</strong>
</li>
    </ul>
  </li>
  <li>
    <p>이럴 경우, Calculator필드를 <strong>new Calculator()의 빈객체를 <code class="language-plaintext highlighter-rouge">NULL객체</code>로서</strong>를 임시로 넣어두면 되는데</p>

    <ol>
      <li>
        <p>Calculator자체가 <strong>생성자를 요구하는데 안에 null</strong>을 넣어두면 된다?</p>

        <ol>
          <li><strong>Calculator 자체의 생성자 검증(invariant) 작성시시 걸린다</strong></li>
        </ol>
      </li>
      <li>
        <p><strong>Calculator를 살펴보니, <code class="language-plaintext highlighter-rouge">자기가 일하는 것이 아니</code>라 컬렉션필드를 돌면서 일처리를 하고 있으니, <code class="language-plaintext highlighter-rouge">NULL객체용 아무것도 안받는 생성자를 추가</code>해주고, <code class="language-plaintext highlighter-rouge">작동해도 빈 컬렉션을 for문으로 돌면 아무일도 안하고 그대로 반환</code>해주니 괜찮을 것 같다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713160759941.png" alt="image-20220713160759941"></p>
      </li>
    </ol>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/d5903c77-880f-467c-8770-4843b64a3d07.gif" alt="d5903c77-880f-467c-8770-4843b64a3d07"></p>
  </li>
</ol>

<h5 id="preconditionplan파라미터로-넘어온-인자의-null검증-by-thr">
<a class="anchor" href="#preconditionplan%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A1%9C-%EB%84%98%EC%96%B4%EC%98%A8-%EC%9D%B8%EC%9E%90%EC%9D%98-null%EA%B2%80%EC%A6%9D-by-thr" aria-hidden="true"><span class="octicon octicon-link"></span></a>Precondition#Plan#파라미터로 넘어온 인자의 null검증 by thr</h5>

<ul>
  <li>
    <p>기본적으로 <code class="language-plaintext highlighter-rouge">외부</code>(package내 계약된 깨끗한 인자가 아닌)에서 넘어노는 인자는 만능키 null의 가능성이 있다.</p>

    <ol>
      <li>
        <p><strong>Null일때는 if에 안걸리고 빠져나가면서 return false를 반환</strong>하도록 <strong>최소한 불린flagf를 반환하도록</strong>짠다.</p>

        <ul>
          <li>
            <p><strong>null일때는 로직자체가 안걸리게 무시하고, != null일때만 로직을 통과하게 하던지 <code class="language-plaintext highlighter-rouge">null일때 early return false;로 무시</code>해도 된다.</strong></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713163047953.png" alt="image-20220713163047953"></p>
          </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/44cdde08-ec9d-49b5-8e42-86093550f40f.gif" alt="44cdde08-ec9d-49b5-8e42-86093550f40f"></p>
      </li>
      <li>
        <p><strong>불린flag반환없이 <code class="language-plaintext highlighter-rouge">if Throw로 멈춰서 죽</code>도록 null검증을 해도된다.</strong></p>

        <ul>
          <li>if로무시하며 불린반환하는 것보다 더 강력하다.</li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/fa27b172-ac1b-4392-93be-27c04cf9d708.gif" alt="fa27b172-ac1b-4392-93be-27c04cf9d708"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713163650091.png" alt="image-20220713163650091"></p>
      </li>
    </ol>
  </li>
</ul>

<h5 id="preconditionplan파라미터로-넘어온-인자의-상태null객체-도메인검증-by-thr">
<a class="anchor" href="#preconditionplan%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EB%A1%9C-%EB%84%98%EC%96%B4%EC%98%A8-%EC%9D%B8%EC%9E%90%EC%9D%98-%EC%83%81%ED%83%9Cnull%EA%B0%9D%EC%B2%B4-%EB%8F%84%EB%A9%94%EC%9D%B8%EA%B2%80%EC%A6%9D-by-thr" aria-hidden="true"><span class="octicon octicon-link"></span></a>Precondition#Plan#파라미터로 넘어온 인자의 상태(NULL객체, 도메인)검증 by thr</h5>

<ul>
  <li>
    <p>calculator는 <strong>내부에 전략객체가 없는 것이 넘어오면 사실상 null의 객체다</strong></p>

    <ul>
      <li>
        <p>도메인으로서 의미가 있을라면, <strong>해당 도메인이 <code class="language-plaintext highlighter-rouge">NULL객체와 같은 상태가 아닌 의미있는 상태를 가짐을 검증</code>해야한다.</strong></p>

        <ul>
          <li><strong>실제로 <code class="language-plaintext highlighter-rouge">해당객체의 필드들(상태값)들을 살펴보고</code> 의미있는 상태임을 코드로 적는다.</strong></li>
          <li>Calculator는 내부에 가진 calcs(전략객체들)의 갯수가 1개 이상인 상태여야 한다.</li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/063d4321-8417-4e78-b887-ec91ecafa6ff.gif" alt="063d4321-8417-4e78-b887-ec91ecafa6ff"></p>
      </li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713170411232.png" alt="image-20220713170411232"></p>
  </li>
  <li>
    <p><strong>이렇게, <code class="language-plaintext highlighter-rouge">precondition으로서 날아가는 메세지 객체</code>는 <code class="language-plaintext highlighter-rouge">자신에 대한 validation의 책임을 외부에 서비스로 제공</code>해야하므로 <code class="language-plaintext highlighter-rouge">자신의 상태에 대한 validation책임(메서드)이 늘어난다</code></strong></p>
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">client에서 보이지 않지만</code> 메세지로 들어가는 객체들은, precondition검증으로 쓰이는 내부 메소드가 많다.</strong></li>
    </ul>
  </li>
</ul>

<h5 id="postconditionplanreturn해줄-결과값에-대한-도메인-검증재료가-있을-땐-결과값이-null객체가-아니어야한다">
<a class="anchor" href="#postconditionplanreturn%ED%95%B4%EC%A4%84-%EA%B2%B0%EA%B3%BC%EA%B0%92%EC%97%90-%EB%8C%80%ED%95%9C-%EB%8F%84%EB%A9%94%EC%9D%B8-%EA%B2%80%EC%A6%9D%EC%9E%AC%EB%A3%8C%EA%B0%80-%EC%9E%88%EC%9D%84-%EB%95%90-%EA%B2%B0%EA%B3%BC%EA%B0%92%EC%9D%B4-null%EA%B0%9D%EC%B2%B4%EA%B0%80-%EC%95%84%EB%8B%88%EC%96%B4%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>postcondition#plan#return해줄 결과값에 대한 도메인 검증(재료가 있을 땐, 결과값이 NULL객체가 아니어야한다)</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713170908634.png" alt="image-20220713170908634"></p>

<ul>
  <li>
    <p>객체는 <strong>직접 자기의 로직을 수행하기보다는, <code class="language-plaintext highlighter-rouge">메세지를 통해 적합한 객체에게 책임을 위임해서 시킨 뒤, 값을 받아</code>오는 경우가 많다. <code class="language-plaintext highlighter-rouge">위임객체에 받아온 결과값도 반환하기 전에 도메인 검증</code>해야만한다.</strong></p>

    <ul>
      <li><strong>검증하기 위해서는 <code class="language-plaintext highlighter-rouge">지역변수로 받아서 확인</code>한다</strong></li>
      <li>
<strong>계산값은 <code class="language-plaintext highlighter-rouge">calls가 1개이상인 경우</code>에만 &amp;&amp; <code class="language-plaintext highlighter-rouge">0원이 되어선 안된다.</code></strong>
        <ul>
          <li>calls가 0개인 경우는 0원이 나와도 상관없다.</li>
        </ul>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">재료가 1개이상일 때는, NULL객체가 아닌 결과값</code>가 나와야한다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/01dd6af0-6c66-4b92-b40a-4dbbe7341ec2.gif" alt="01dd6af0-6c66-4b92-b40a-4dbbe7341ec2"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713171834436.png" alt="image-20220713171834436"></p>
  </li>
</ul>

<h5 id="precondition위임plan인자-객체의-상태검증에-this-context가-사용되지-않으면-묻지말고-시켜서-스스로-죽도록-코드를-옮기고--변화의여파를-없앤다">
<a class="anchor" href="#precondition%EC%9C%84%EC%9E%84plan%EC%9D%B8%EC%9E%90-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%83%81%ED%83%9C%EA%B2%80%EC%A6%9D%EC%97%90-this-context%EA%B0%80-%EC%82%AC%EC%9A%A9%EB%90%98%EC%A7%80-%EC%95%8A%EC%9C%BC%EB%A9%B4-%EB%AC%BB%EC%A7%80%EB%A7%90%EA%B3%A0-%EC%8B%9C%EC%BC%9C%EC%84%9C-%EC%8A%A4%EC%8A%A4%EB%A1%9C-%EC%A3%BD%EB%8F%84%EB%A1%9D-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%98%AE%EA%B8%B0%EA%B3%A0--%EB%B3%80%ED%99%94%EC%9D%98%EC%97%AC%ED%8C%8C%EB%A5%BC-%EC%97%86%EC%95%A4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>precondition위임#Plan#인자 객체의 상태검증에, this context가 사용되지 않으면 묻지말고 시켜서 스스로 죽도록 코드를 옮기고 + 변화의여파를 없앤다.</h5>

<ul>
  <li>precondition의 null검증은 메세지 객체에게 위임할 수 없다.
    <ul>
      <li>객체 대신 null이 들어오므로, 아예 다른 범주다.</li>
    </ul>
  </li>
  <li>
<strong>만약, 물어보고 여기서 죽인다? -&gt; <code class="language-plaintext highlighter-rouge">해당 객체가 변할시, 기존 물어보는 것 자체가 의미가 없어진다.</code></strong>
    <ul>
      <li>시켜서, 알아서 물어보고 알아서 죽으라고 한다.</li>
      <li><strong>my) <code class="language-plaintext highlighter-rouge">객체 자신의 상태검증은, 물어보고 여기서 죽일 이유가 없으니 스스로 죽게 만들면, 변화의 여파가 안오며, 내가 만든형으로서 검증코드가 그쪽으로 이동되는 효과가 있다</code></strong></li>
    </ul>
  </li>
  <li>해당객체에게 시킬 때는
    <ul>
      <li>내수용 메서드로 추출 -&gt; 해당 객체로 이동</li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/70c99a6b-82cd-4582-85a7-e1aa6c2d1067.gif" alt="70c99a6b-82cd-4582-85a7-e1aa6c2d1067"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713181026214.png" alt="image-20220713181026214"></p>

<h5 id="postcondition위임plan결과값검증-과정에서-this-context가-사용되지-않으면-결과값-검증로직도-결과값-계산로직-내부로-위임한다">
<a class="anchor" href="#postcondition%EC%9C%84%EC%9E%84plan%EA%B2%B0%EA%B3%BC%EA%B0%92%EA%B2%80%EC%A6%9D-%EA%B3%BC%EC%A0%95%EC%97%90%EC%84%9C-this-context%EA%B0%80-%EC%82%AC%EC%9A%A9%EB%90%98%EC%A7%80-%EC%95%8A%EC%9C%BC%EB%A9%B4-%EA%B2%B0%EA%B3%BC%EA%B0%92-%EA%B2%80%EC%A6%9D%EB%A1%9C%EC%A7%81%EB%8F%84-%EA%B2%B0%EA%B3%BC%EA%B0%92-%EA%B3%84%EC%82%B0%EB%A1%9C%EC%A7%81-%EB%82%B4%EB%B6%80%EB%A1%9C-%EC%9C%84%EC%9E%84%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>postcondition위임#Plan#결과값검증 과정에서 this context가 사용되지 않으면, 결과값 검증로직도 결과값 계산로직 내부로 위임한다.</h5>

<ul>
  <li>this(현재class의 필드들)가 없으면, 나의 코드, 나의 메서드가 아니다.</li>
</ul>

<ol>
  <li>
    <p>결과값 검증 로직에 this가 사용되는지 확인한다.</p>

    <ol>
      <li>
        <p><strong>만약, plan의 필드들이 사용되었다면, postcondition은 그대로 두어야 하고, <code class="language-plaintext highlighter-rouge">처리전에 상태값들의 invariant</code>부터 검증한다</strong></p>
      </li>
      <li>
        <p><strong>만약, plan의필드들(this)가 사용안되었다면, 결과값 계산로직 속으로 위임한다.</strong></p>
      </li>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">필드가 사용되었어도 계산위임된 메소드의 인자로 넘어갔다면, this로 안보고 결과값 검증 로직도 위임할 수 있다.</code></strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713183415777.png" alt="image-20220713183415777"></p>
      </li>
    </ol>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/12ae6fb1-89de-4c61-8c37-b82b1b11407d.gif" alt="12ae6fb1-89de-4c61-8c37-b82b1b11407d"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713184028517.png" alt="image-20220713184028517">
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713184125893.png" alt="image-20220713184125893"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713184047325.png" alt="image-20220713184047325"></p>
  </li>
  <li>
    <p><strong>postcondition 검증이 안보인다면, 검증에 this가 사용안되서, 결과값계산로직 내부로 결과값 검증 로직이 위임됬음을 생각하자</strong></p>

    <ul>
      <li>
<strong>precondition에서 인자 상태검증은 this가 사용안되더라도, 명시적으로 호출은 해야해서 보인다.</strong>
        <ul>
          <li>cf) 만약 안보인다면, 메서드 호출하는 인자에서 이미 검증된 인자를 보냈을 수도 있다.</li>
        </ul>
      </li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712175645352.png" alt="image-20220712175645352"></p>

    <ul>
      <li><strong>pre/postcondition의 책임은 작성하고 나면, <code class="language-plaintext highlighter-rouge">대부분 위임받은 객체들이 가져가게 된다. 그 pre/postcondition검증 코드가 안보인다면, 이미 계약관계라고 생각</code>할 수 있다.</strong></li>
    </ul>
  </li>
  <li>
    <p><strong>precondition은 위임되더라도 받은쪽이 발동은 시켜줘야하고, postcondition은 위임한 객체 내부에서 처리되어 안보인다.</strong></p>
    <ol>
      <li>postcondition은 return해주는 쪽에서 다 처리해줘</li>
      <li>preconditiond은 받은 쪽에서 검증해줘</li>
    </ol>
  </li>
</ol>

<h5 id="precondition위임calculator외부client가-아닌-계약자가-넘겨준-precondition의-상태검증은-애초에-계약자가-삼항연산자-등을-통해--검증된-precondition을-넘겨주도록-계약조건을-명시할-수-있다">
<a class="anchor" href="#precondition%EC%9C%84%EC%9E%84calculator%EC%99%B8%EB%B6%80client%EA%B0%80-%EC%95%84%EB%8B%8C-%EA%B3%84%EC%95%BD%EC%9E%90%EA%B0%80-%EB%84%98%EA%B2%A8%EC%A4%80-precondition%EC%9D%98-%EC%83%81%ED%83%9C%EA%B2%80%EC%A6%9D%EC%9D%80-%EC%95%A0%EC%B4%88%EC%97%90-%EA%B3%84%EC%95%BD%EC%9E%90%EA%B0%80-%EC%82%BC%ED%95%AD%EC%97%B0%EC%82%B0%EC%9E%90-%EB%93%B1%EC%9D%84-%ED%86%B5%ED%95%B4--%EA%B2%80%EC%A6%9D%EB%90%9C-precondition%EC%9D%84-%EB%84%98%EA%B2%A8%EC%A3%BC%EB%8F%84%EB%A1%9D-%EA%B3%84%EC%95%BD%EC%A1%B0%EA%B1%B4%EC%9D%84-%EB%AA%85%EC%8B%9C%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>precondition위임#Calculator#외부Client가 아닌 계약자가 넘겨준 precondition의 상태검증은 애초에 계약자가, 삼항연산자 등을 통해  검증된 precondition을 넘겨주도록 계약조건을 명시할 수 있다.</h5>

<ul>
  <li>
    <p>Calculator는 계약자 Plan가 넘겨준 메세지의 상태검증을 직접하지말고, Plan에서 미리 검증된 인자만 넘겨주도록 할 수 있다.
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713235815539.png" alt="image-20220713235815539"></p>

    <ul>
      <li><strong>메세지 calls의 상태검증을 precondition으로 여기서 하지말고, 계약자가 건네주기전에 미리 검증해서 줄 수 있다.</strong></li>
    </ul>
  </li>
  <li>
    <p><strong>메세지가 1개이상만 넘어가도록, 외부가 아닌 계약자는 <code class="language-plaintext highlighter-rouge">1개이상의 메세지</code>만 넘어가도록 <code class="language-plaintext highlighter-rouge">미리 검증하고 넘겨주는 계약내용을 추가</code>할 수 있다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/9b5499c9-29c9-4414-8ee0-7c6a02d0391f.gif" alt="9b5499c9-29c9-4414-8ee0-7c6a02d0391f"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714000212797.png" alt="image-20220714000212797"></p>
  </li>
  <li>
    <p>삼항연산자도 ealry return형식으로 바꿔준다.</p>

    <ul>
      <li><strong>1건이상이면 진행 -&gt; 0건이면 NULL결과값 반환</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/338943bc-0006-4e9d-94cc-9af78e24f385.gif" alt="338943bc-0006-4e9d-94cc-9af78e24f385"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714000524157.png" alt="image-20220714000524157"></p>
  </li>
  <li>
    <p><strong>결과값 반환로직을 보고 <code class="language-plaintext highlighter-rouge">계약조건을 확인</code>할 수 있다.</strong></p>

    <ul>
      <li>calls가 0건이면 계약안함 -&gt; <strong>1건이상일 때만 계약진행</strong>
</li>
    </ul>
  </li>
  <li>
    <p><strong>메소드 위임으로 진행되는 계약은, 계약서의 제목일 뿐이다. 구체적인 계약조건들은 코드로 나타나있다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712190149813.png" alt="image-20220712190149813"></p>
  </li>
</ul>

<h5 id="precondition위임-invariantplan-calculatorsetter를-가져--runtime시-상태변화하는-책임위임객체전략주입-구상클래스는-생성주입시점--precondition-상태검증가-의미없어----해당객체의-계약된위임된책임메서드-호출시마다-invariant으로서-자신의-상태를-매번-검증하도록-위임하여-보장해야한다">
<a class="anchor" href="#precondition%EC%9C%84%EC%9E%84-invariantplan-calculatorsetter%EB%A5%BC-%EA%B0%80%EC%A0%B8--runtime%EC%8B%9C-%EC%83%81%ED%83%9C%EB%B3%80%ED%99%94%ED%95%98%EB%8A%94-%EC%B1%85%EC%9E%84%EC%9C%84%EC%9E%84%EA%B0%9D%EC%B2%B4%EC%A0%84%EB%9E%B5%EC%A3%BC%EC%9E%85-%EA%B5%AC%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EC%83%9D%EC%84%B1%EC%A3%BC%EC%9E%85%EC%8B%9C%EC%A0%90--precondition-%EC%83%81%ED%83%9C%EA%B2%80%EC%A6%9D%EA%B0%80-%EC%9D%98%EB%AF%B8%EC%97%86%EC%96%B4----%ED%95%B4%EB%8B%B9%EA%B0%9D%EC%B2%B4%EC%9D%98-%EA%B3%84%EC%95%BD%EB%90%9C%EC%9C%84%EC%9E%84%EB%90%9C%EC%B1%85%EC%9E%84%EB%A9%94%EC%84%9C%EB%93%9C-%ED%98%B8%EC%B6%9C%EC%8B%9C%EB%A7%88%EB%8B%A4-invariant%EC%9C%BC%EB%A1%9C%EC%84%9C-%EC%9E%90%EC%8B%A0%EC%9D%98-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%A7%A4%EB%B2%88-%EA%B2%80%EC%A6%9D%ED%95%98%EB%8F%84%EB%A1%9D-%EC%9C%84%EC%9E%84%ED%95%98%EC%97%AC-%EB%B3%B4%EC%9E%A5%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>precondition위임-&gt;Invariant#Plan-&gt;Calculator#setter를 가져  runtime시 상태변화하는 책임위임객체(전략주입 구상클래스)는 생성(주입)시점  precondition 상태검증가 의미없어 -&gt;  해당객체의 계약된(위임된)책임메서드 호출시마다 invariant으로서 자신의 상태를 매번 검증하도록 위임하여 보장해야한다.</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714002654300.png" alt="image-20220714002654300"></p>

<ol>
  <li>Plan에 주입되는 Calculator 객체는, <strong>setter로 상태변화가 가능한 놈</strong>이기 때문에, invariant보장이 안된다 -&gt; <strong>precondition 상태검증은 의미없다</strong>
    <ul>
      <li><strong>받은 해당 객체의 책임(계약)메소드 호출시마다 자신의 상태를 검증하는 invariant로 위임해서 처리한다.</strong></li>
    </ul>
  </li>
</ol>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/a21577e5-0164-4f3a-8588-2be678bd4571.gif" alt="a21577e5-0164-4f3a-8588-2be678bd4571"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714003458677.png" alt="image-20220714003458677"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714003135958.png" alt="image-20220714003135958"></p>

<ol>
  <li>
<strong>compile타임에 invariant가 확정되려면, 생성자type으로 초기화해야만한다</strong>
    <ul>
      <li>만약, <strong>setter type으로 상태변화가 런타임으로 미뤄진다면, 호출시마다 매번 invariant 검증을 해야한다.</strong>
</li>
      <li><strong>life cycle처럼 순서를 가지도록 짜더라도, 중간에 메서드 호출을 빠트리는 것은 컴파일러가 확정시켜줄 수 없다. 런타임으로 미뤄진다면, 101번째 에러가 발생한다. 모든 경우의 수를 알아야하며, 매번 검사해야한다.</strong></li>
    </ul>
  </li>
</ol>

<h5 id="preconditioncalculator계약자가-넘겨주는-깨끗한-인자가-아니라-외부에서-들어오는-인자라면-precondition검증null-및-가진-상태값을-해야한다">
<a class="anchor" href="#preconditioncalculator%EA%B3%84%EC%95%BD%EC%9E%90%EA%B0%80-%EB%84%98%EA%B2%A8%EC%A3%BC%EB%8A%94-%EA%B9%A8%EB%81%97%ED%95%9C-%EC%9D%B8%EC%9E%90%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-%EB%93%A4%EC%96%B4%EC%98%A4%EB%8A%94-%EC%9D%B8%EC%9E%90%EB%9D%BC%EB%A9%B4-precondition%EA%B2%80%EC%A6%9Dnull-%EB%B0%8F-%EA%B0%80%EC%A7%84-%EC%83%81%ED%83%9C%EA%B0%92%EC%9D%84-%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>precondition#Calculator#계약자가 넘겨주는 깨끗한 인자가 아니라 외부에서 들어오는 인자라면 precondition검증(null 및 가진 상태값)을 해야한다.</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/2a28fe4d-803e-48f3-9df6-0d0ff6a72899.gif" alt="2a28fe4d-803e-48f3-9df6-0d0ff6a72899"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714004435561.png" alt="image-20220714004435561"></p>

<ul>
  <li>
    <p>만약, 계약자가 넘겨준 인자라면</p>

    <ol>
      <li>
        <p><strong>메세지 처리전, 나의 invariant를 검증한다. setter를 가져 상태가 변한다면, 상태검증을 매번해줘야한다.</strong></p>
      </li>
      <li>
        <p>계약자가 이미 검증된 인자를 넘겨주는지 확인한다.</p>
      </li>
    </ol>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714004621589.png" alt="image-20220714004621589"></p>
  </li>
</ul>

<h5 id="계약의전파preconditioncalc전략객체들계약전파된-메서드는-precondition-검증이-없다">
<a class="anchor" href="#%EA%B3%84%EC%95%BD%EC%9D%98%EC%A0%84%ED%8C%8Cpreconditioncalc%EC%A0%84%EB%9E%B5%EA%B0%9D%EC%B2%B4%EB%93%A4%EA%B3%84%EC%95%BD%EC%A0%84%ED%8C%8C%EB%90%9C-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-precondition-%EA%B2%80%EC%A6%9D%EC%9D%B4-%EC%97%86%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>계약의전파precondition#Calc(전략객체들)#계약전파된 메서드는 precondition 검증이 없다.</h5>

<ul>
  <li>
    <p>Plan(계약자) - Calculator(계약메서드) - Calc(인터페이스) - Calc구상체들(<strong>계약전파 메서드</strong>)</p>

    <ul>
      <li><strong>계약메서드 이미 검증된 메세지들을 받은 상태이며, 그것을 그대로 받았는지 확인한다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713101625017.png" alt="image-20220713101625017"></p>

    <ul>
      <li>calls는 1건이상의 좋은 인자 + result는 초기값으로 좋은 인자가 들어온다
        <ul>
          <li><strong>하지만, Plan(계약자)와 Calculator(계약메서드)사이에만 최초인자가 계약된 깨긋한 인자로 들어감이 보장된다.</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">계약메서드, 계약전파 메서드들은 public으로 유지되는 한</code>, 계약자들 이외에 객체들이 호출할 수 있기 때문에, <code class="language-plaintext highlighter-rouge">좋은인자라는 보장이 없다</code>.</strong></p>

    <ul>
      <li><strong>계약자들만 호출할 수 있도록 하려면 <code class="language-plaintext highlighter-rouge">생성자는 public으로 외부에서 생성되도록 하되, 계약메서드들은 한 package내 internal</code>로 처리해야한다.</strong></li>
      <li><strong>plan은 public으로서 외부에서 호출되어야한다.</strong></li>
    </ul>
  </li>
</ul>

<h5 id="계약의전파preconditionpackage계약된-좋은-인자-보장을-위해-위임된-계약객체들의-계약된-책임메서드부터는-internal가시성을-이용하여-계약자에게-독점공급한다--만약-public-default의-인터페이스면-추상클래스로-변경한다">
<a class="anchor" href="#%EA%B3%84%EC%95%BD%EC%9D%98%EC%A0%84%ED%8C%8Cpreconditionpackage%EA%B3%84%EC%95%BD%EB%90%9C-%EC%A2%8B%EC%9D%80-%EC%9D%B8%EC%9E%90-%EB%B3%B4%EC%9E%A5%EC%9D%84-%EC%9C%84%ED%95%B4-%EC%9C%84%EC%9E%84%EB%90%9C-%EA%B3%84%EC%95%BD%EA%B0%9D%EC%B2%B4%EB%93%A4%EC%9D%98-%EA%B3%84%EC%95%BD%EB%90%9C-%EC%B1%85%EC%9E%84%EB%A9%94%EC%84%9C%EB%93%9C%EB%B6%80%ED%84%B0%EB%8A%94-internal%EA%B0%80%EC%8B%9C%EC%84%B1%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EA%B3%84%EC%95%BD%EC%9E%90%EC%97%90%EA%B2%8C-%EB%8F%85%EC%A0%90%EA%B3%B5%EA%B8%89%ED%95%9C%EB%8B%A4--%EB%A7%8C%EC%95%BD-public-default%EC%9D%98-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A9%B4-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C-%EB%B3%80%EA%B2%BD%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>계약의전파precondition#package#계약된 좋은 인자 보장을 위해, 위임된 계약객체들의 계약된 책임메서드부터는 internal가시성을 이용하여 계약자에게 독점공급한다.  만약 public default의 인터페이스면 추상클래스로 변경한다.</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713105833512.png" alt="image-20220713105833512"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713121342208.png" alt="image-20220713121342208"></p>

<ol>
  <li>
    <p>최초 계약자 Plan을 특정package <code class="language-plaintext highlighter-rouge">plan</code>을 만들어서 이동시킨다.</p>

    <ul>
      <li>패키지는 계약관계에 의해 이루어진다.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714103033484.png" alt="image-20220714103033484"></p>
  </li>
  <li>
    <p><strong>위임된 계약객체들</strong>도 <strong>특정package이동</strong> 후 메서드는 <strong>접근제한자를 지워 internal 가시성을 통해, Plan에 메서드를 독점 공급한다.</strong></p>

    <ul>
      <li>패키지내 부를 수 있지만, Plan만 해당 메서드를 호출하는 것은 개발자가 통제한다.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714103219907.png" alt="image-20220714103219907"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/20eac00e-f19a-410a-b0e6-f230ba59bf57.gif" alt="20eac00e-f19a-410a-b0e6-f230ba59bf57"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714103423965.png" alt="image-20220714103423965"></p>

    <ul>
      <li>접근제한자가 없는 <strong>internal가시성을 보면 -&gt; <code class="language-plaintext highlighter-rouge">package내 호출하는 쪽에 독점공급</code>하겠구나 생각한다.</strong>
</li>
    </ul>
  </li>
  <li>
    <p><strong>다음 계약전파메서드를 보면, <code class="language-plaintext highlighter-rouge">인터페이스로서 가시성누수 문제로 인해 public으로 만들어야하는 제한</code>이 있으므로 <code class="language-plaintext highlighter-rouge">internal가시성 적용</code>을 위해  <code class="language-plaintext highlighter-rouge">전략패턴을 템플릿메소드패턴으로 변경</code>한 뒤, <code class="language-plaintext highlighter-rouge">public 템플릿메소드의 접근제한자를 삭제하여 internal가시성으로 변경</code>한다</strong></p>

    <ul>
      <li>
        <p><a href="https://blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/strategy/templatemethod/convert/2022/07/12/Object_strategy_templatemethod_convert_text.html">참고 내 블로그 글(전략 to 템플릿메소드패턴)</a></p>

        <ol>
          <li>
            <p>추상클래스로 변경 및 전략메서드 삭제<img src="https://raw.githubusercontent.com/is3js/screenshots/main/4732b904-4b4c-41b1-8a99-a5934fcef736.gif" alt="4732b904-4b4c-41b1-8a99-a5934fcef736"><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714104257895.png" alt="image-20220714104257895"></p>
          </li>
          <li>
            <p>1개 구상체에 대해 추상클래스 상속 후, 개별구현 로직을 private내수용 메서드로 추출하여, 훅메서드를 만들어 올린다. 올린 메서드의 접근제한자를 final or protected abstract로 수정한다.</p>

            <ul>
              <li>
                <p><strong>개별로직만 존재하더라도, 템플릿메서드만 올리지말고, <code class="language-plaintext highlighter-rouge">해당로직을 다시 한번 메서드추출</code>하여 <code class="language-plaintext highlighter-rouge">공통로직 내부 개별로직</code>형태로 만들어야, 템플릿메소드패턴이 된다.</strong></p>
              </li>
              <li>
                <p>만약, 공통필드가 있다면, 생성자가 아닌 setter를 만든 후 setter를 올리면서 필드를 올린다.</p>

                <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/8e8deb5f-f1e0-4b07-83a6-330f75fdf0cb.gif" alt="8e8deb5f-f1e0-4b07-83a6-330f75fdf0cb">
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714104733634.png" alt="image-20220714104733634"></p>
              </li>
            </ul>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714104532056.png" alt="image-20220714104532056"></p>
          </li>
          <li>
            <p>구상체들이 올라간 템플릿메소드 + 훅메서드를 구현하면서, 전략메서드를 내용만 복붙후 삭제한다.</p>

            <ul>
              <li>훅메서드 추출시, 특정 구상체에서 템플릿메서드로 넘어온 인자들이 사용안됬다면, <strong><code class="language-plaintext highlighter-rouge">ctrl + F6</code>을 통한 시그니쳐 변경</strong>이 필요할 수 있다</li>
            </ul>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/82263936-e878-4d12-b940-492a7ac45b77.gif" alt="82263936-e878-4d12-b940-492a7ac45b77"></p>
          </li>
        </ol>
      </li>
      <li>
        <p><strong>이제 추상클래스의 템플릿메소드를 public이 아닌 internal로 변경하여, <code class="language-plaintext highlighter-rouge">추상클래스도 전파된 책임메서드가 독점공급</code>되도록 한다.</strong>
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/878264c4-0848-4f56-a0aa-059e6e44d228.gif" alt="878264c4-0848-4f56-a0aa-059e6e44d228"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714105405237.png" alt="image-20220714105405237"></p>
      </li>
    </ul>
  </li>
</ol>

<h5 id="계약의전파preconditionpackage계약의전파로-인해-같은-병행package를-유지하여-internal독점공급하는-것은-부모와-protected관계인-구상체들에게는-해당사항이-없다-구상체들만-따로-내부package를-파서-넣어준다">
<a class="anchor" href="#%EA%B3%84%EC%95%BD%EC%9D%98%EC%A0%84%ED%8C%8Cpreconditionpackage%EA%B3%84%EC%95%BD%EC%9D%98%EC%A0%84%ED%8C%8C%EB%A1%9C-%EC%9D%B8%ED%95%B4-%EA%B0%99%EC%9D%80-%EB%B3%91%ED%96%89package%EB%A5%BC-%EC%9C%A0%EC%A7%80%ED%95%98%EC%97%AC-internal%EB%8F%85%EC%A0%90%EA%B3%B5%EA%B8%89%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%80-%EB%B6%80%EB%AA%A8%EC%99%80-protected%EA%B4%80%EA%B3%84%EC%9D%B8-%EA%B5%AC%EC%83%81%EC%B2%B4%EB%93%A4%EC%97%90%EA%B2%8C%EB%8A%94-%ED%95%B4%EB%8B%B9%EC%82%AC%ED%95%AD%EC%9D%B4-%EC%97%86%EB%8B%A4-%EA%B5%AC%EC%83%81%EC%B2%B4%EB%93%A4%EB%A7%8C-%EB%94%B0%EB%A1%9C-%EB%82%B4%EB%B6%80package%EB%A5%BC-%ED%8C%8C%EC%84%9C-%EB%84%A3%EC%96%B4%EC%A4%80%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>계약의전파precondition#package#계약의전파로 인해 같은 병행package를 유지하여 internal독점공급하는 것은 부모와 protected관계인 구상체들에게는 해당사항이 없다. 구상체들만 따로 내부package를 파서 넣어준다.</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713121307458.png" alt="image-20220713121307458"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714105737547.png" alt="image-20220714105737547"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/bbe7d9d7-0c95-4724-af29-789ec6e47dfe.gif" alt="bbe7d9d7-0c95-4724-af29-789ec6e47dfe"></p>

<h5 id="계약의전파postcondition훅구상체들postcondition검사는-계약전파된-pre의-더-상위레이어-계약체결로-인한-생략과-달리-매번-검증해야한다">
<a class="anchor" href="#%EA%B3%84%EC%95%BD%EC%9D%98%EC%A0%84%ED%8C%8Cpostcondition%ED%9B%85%EA%B5%AC%EC%83%81%EC%B2%B4%EB%93%A4postcondition%EA%B2%80%EC%82%AC%EB%8A%94-%EA%B3%84%EC%95%BD%EC%A0%84%ED%8C%8C%EB%90%9C-pre%EC%9D%98-%EB%8D%94-%EC%83%81%EC%9C%84%EB%A0%88%EC%9D%B4%EC%96%B4-%EA%B3%84%EC%95%BD%EC%B2%B4%EA%B2%B0%EB%A1%9C-%EC%9D%B8%ED%95%9C-%EC%83%9D%EB%9E%B5%EA%B3%BC-%EB%8B%AC%EB%A6%AC-%EB%A7%A4%EB%B2%88-%EA%B2%80%EC%A6%9D%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>계약의전파postcondition#훅구상체들#postcondition검사는, 계약전파된 pre의 더 상위레이어 계약체결로 인한 생략과 달리, 매번 검증해야한다.</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713121538506.png" alt="image-20220713121538506"></p>

<ul>
  <li>precondition은 계약전파시, internal가시성을 통해 계약된 메세지들만 받아서 생략이 가능했다.</li>
  <li><strong>하지만 postcondition(반환될 결과값 검증)은 매번 해야한다.</strong></li>
</ul>

<h5 id="계약의전파postcondition구상체들계약전파-메서드의-postcondition을-검사하기-전에-결과값-계산시-사용된-상태값의-invariant를-먼저-검증하자">
<a class="anchor" href="#%EA%B3%84%EC%95%BD%EC%9D%98%EC%A0%84%ED%8C%8Cpostcondition%EA%B5%AC%EC%83%81%EC%B2%B4%EB%93%A4%EA%B3%84%EC%95%BD%EC%A0%84%ED%8C%8C-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-postcondition%EC%9D%84-%EA%B2%80%EC%82%AC%ED%95%98%EA%B8%B0-%EC%A0%84%EC%97%90-%EA%B2%B0%EA%B3%BC%EA%B0%92-%EA%B3%84%EC%82%B0%EC%8B%9C-%EC%82%AC%EC%9A%A9%EB%90%9C-%EC%83%81%ED%83%9C%EA%B0%92%EC%9D%98-invariant%EB%A5%BC-%EB%A8%BC%EC%A0%80-%EA%B2%80%EC%A6%9D%ED%95%98%EC%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>계약의전파postcondition#구상체들#계약전파 메서드의 postcondition을 검사하기 전에 결과값 계산시 사용된 상태값의 invariant를 먼저 검증하자.</h5>

<ul>
  <li><strong>결과값 검증하기 전에, <code class="language-plaintext highlighter-rouge">내 필드값들이 눈에 밟혀서 invariant검증이 안된 것이 눈에 밟혀야한다.</code></strong></li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714114601626.png" alt="image-20220714114601626"></p>

<ul>
  <li>
    <p>계약전파 메서드들의 precondition은 가기성확보로 좋은인자가 확보되어어 생략했지만, <strong>postcondition은 검사해야하는데, 그 전에 계산에 사용된 보라색 상태값들의 invariant부터 NULL/상태 검증하자.</strong></p>

    <ul>
      <li>
        <p>price는 Money형으로서 NULL검사 외 상태검증(0원이하면 의미 없음)을 검증해야한다.</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/be1225e8-2cd6-47a1-9f46-bddcda236ce4.gif" alt="be1225e8-2cd6-47a1-9f46-bddcda236ce4"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714115057917.png" alt="image-20220714115057917"></p>

        <ul>
          <li><strong>내가 만든형이므로 스스로 죽도록 묻지않고 상태검증을 시킬 수 있다.</strong></li>
        </ul>
      </li>
      <li>
        <p>second는 Duration형으로서 NULL검사 외 상태검증(0초이하면 의미없음)을 해야한다.</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/de5f1080-80bf-4e46-b6ff-49573d923c87.gif" alt="de5f1080-80bf-4e46-b6ff-49573d923c87"></p>

        <ul>
          <li><strong>외부객체이므로 새로운 wrapper형을 만들 것이 아니라면, 물어서 검증해야한다.</strong></li>
        </ul>
      </li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220714115646264.png" alt="image-20220714115646264"></p>
  </li>
</ul>


  </div><a class="u-url" href="/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/contract/plan/precondition/postcondition/invariant/package/2022/07/14/Object_contract_plan4.html" hidden></a>
</article>