<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Object)중복로직제거 Strategy to Templatemethod(Plan3) | 돌범텤놑</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Object)중복로직제거 Strategy to Templatemethod(Plan3)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="next필드 + setter + 다음타자 재귀호출 중복로직을 추상클래스로 제거" />
<meta property="og:description" content="next필드 + setter + 다음타자 재귀호출 중복로직을 추상클래스로 제거" />
<link rel="canonical" href="https://blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/strategy/templatemethod/plan/connectobject/2022/07/12/Object_strategy_to_template_for_duplicate.html" />
<meta property="og:url" content="https://blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/strategy/templatemethod/plan/connectobject/2022/07/12/Object_strategy_to_template_for_duplicate.html" />
<meta property="og:site_name" content="돌범텤놑" />
<meta property="og:image" content="https://blog.chojaeseong.com/images/posts/java.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-07-12T00:00:00-05:00" />
<script type="application/ld+json">
{"datePublished":"2022-07-12T00:00:00-05:00","url":"https://blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/strategy/templatemethod/plan/connectobject/2022/07/12/Object_strategy_to_template_for_duplicate.html","@type":"BlogPosting","image":"https://blog.chojaeseong.com/images/posts/java.png","headline":"Object)중복로직제거 Strategy to Templatemethod(Plan3)","dateModified":"2022-07-12T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/strategy/templatemethod/plan/connectobject/2022/07/12/Object_strategy_to_template_for_duplicate.html"},"description":"next필드 + setter + 다음타자 재귀호출 중복로직을 추상클래스로 제거","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<!-- 폰트추가를 위한 link태그 삽입 -->
  <!-- 폰트1:  기본 spoqa 웹폰트 -->
  <!-- css에서 * {} 다 뒤집어씀. -->
  <link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSansNeo.css' rel='stylesheet' type='text/css'>
  <!-- 폰트2:  블로그 제목들 sunflower 웹폰트 -->
  <!-- 쥬피터 등 포스트 내부 글자 h1, h2 제목은 sunflower체 도입 -->
  <link href="//fonts.googleapis.com/css?family=Sunflower:300,500,700" rel="stylesheet"> 

  <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://blog.chojaeseong.com/feed.xml" title="돌범텤놑" /><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">돌범텤놑</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About Me</a><a class="page-link" href="/search/">Search</a><a class="page-link" href="/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Object)중복로직제거 Strategy to Templatemethod(Plan3)</h1><p class="page-description">next필드 + setter + 다음타자 재귀호출 중복로직을 추상클래스로 제거</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-07-12T00:00:00-05:00" itemprop="datePublished">
        Jul 12, 2022
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      5 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/categories/#java">java</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#우테코">우테코</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#oop">oop</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#object">object</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#strategy">strategy</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#templatemethod">templatemethod</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#plan">plan</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#connectobject">connectobject</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <!-- toc가 먼저 나오므로 h3로 안내하기 -->
    <h3>📜 제목으로 보기</h3>
    <ul class="section-nav">
<li class="toc-entry toc-h4"><a href="#전략패턴-to-추상-템플릿메소드패턴-for-전략객체-중복코드실습">전략패턴 to 추상 템플릿메소드패턴 for 전략객체 중복코드(실습)</a></li>
<li class="toc-entry toc-h4"><a href="#next필드로-연결되는-합성객체용-생성자-주입-대신-void-setter를-가진-추상클래스에-구상층-객체별-체이닝-받기기능으로-대체하기">next필드로 연결되는 합성객체용 생성자 주입 대신, void setter를 가진 추상클래스에 [구상층 객체별 체이닝 받기기능]으로 대체하기</a>
<ul>
<li class="toc-entry toc-h5"><a href="#next필드용-생성자-체이닝을-대신하는-void-setter를-구상층-객체별-체이닝-받기기능으로-만들기-실습">next필드용 생성자 체이닝을 대신하는 void setter를 [구상층 객체별 체이닝 받기기능]으로 만들기 (실습)</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#연결되는-합성객체를-가지는-추상템플릿메서드패턴---여러개의-전략객체를-가지고-누적용시키는-전략주입-구상클래스를-가지는-전략패턴으로-변경실습">연결되는 합성객체를 가지는 추상템플릿메서드패턴 -&gt; 여러개의 전략객체를 가지고 누적용시키는 전략주입 구상클래스를 가지는 전략패턴으로 변경(실습)</a></li>
</ul><h4 id="전략패턴-to-추상-템플릿메소드패턴-for-전략객체-중복코드실습">
<a class="anchor" href="#%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4-to-%EC%B6%94%EC%83%81-%ED%85%9C%ED%94%8C%EB%A6%BF%EB%A9%94%EC%86%8C%EB%93%9C%ED%8C%A8%ED%84%B4-for-%EC%A0%84%EB%9E%B5%EA%B0%9D%EC%B2%B4-%EC%A4%91%EB%B3%B5%EC%BD%94%EB%93%9C%EC%8B%A4%EC%8A%B5" aria-hidden="true"><span class="octicon octicon-link"></span></a>전략패턴 to 추상 템플릿메소드패턴 for 전략객체 중복코드(실습)</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712003834206.png" alt="image-20220712003834206"></p>

<ul>
  <li><a href="https://github.com/is2js/object2/tree/d1c394694f3495aa78a485546756e06c7ef19f4c/src/main/java/goodComposition">해당 커밋</a></li>
  <li>전략 to 추상템플릿패턴 방법 정리
    <ol>
      <li>전략인터페이스를 추상클래스로 변경하고, 전략메서드를 삭제한다.</li>
      <li>구상체(전략객체) 1개를 택하여, 추상클래스를 상속후, 중복되는 필드(next)를 생성자 삭제후 setter 먼저 만들어 같이 올린다. 올라온 필드는 privte을, 템플릿메소드도 final을 달아준다.</li>
      <li>다른 전략객체들도, 추상클래스를 상속하고, 삭제된 중복필드 및 생성자주입부를 삭제한다.</li>
      <li>구상체들을 compare files이후, 인자로 넘어온 객체context를 많이 사용하는 구상체를 택하여, 예비훅메서드를 private내수용 메서드로 추출한 뒤, 공통로직을 가진 전략메서드를 템플릿메서드로 올린다.</li>
      <li>다른 구상체들은 올라간 템플릿메서드와 훅메서드에 대해, 훅메서드를 구현하여, 전략메서드 중 개별로직을 붙여넣고, 전략메서드를 삭제한다.</li>
      <li>추상클래스가 좋은 부모인지 확인한다. (private필드, final메서드 or protected abstract 메서드)</li>
      <li>연결되는 합성객체인 경우, setter에 return this + 추상체 응답이후, client에서는 생성자체이닝처럼 setter를 체이닝한다.</li>
    </ol>
  </li>
</ul>

<ol>
  <li>
    <p><strong>전략적용객체(Plan)에 주입되는 추상체</strong>를 전략인터페이스 -&gt; <strong>추상클래스로 변경</strong>하고,  구상체에서 템플릿메소드로 올릴 예정이므로 <strong>전략메서드 오퍼레이터는 삭제</strong>한다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220711113646965.png" alt="image-20220711113646965"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/7959c650-1b4d-4bf4-9450-54c73db63b06.gif" alt="7959c650-1b4d-4bf4-9450-54c73db63b06"></p>
  </li>
  <li>
    <p>**<code class="language-plaintext highlighter-rouge">구상체(기존 전략객체) 중 1개를 선택</code>하여, <code class="language-plaintext highlighter-rouge">추상클래스를 상속 후 -&gt; 중복되는 필드 + setter 메서드를 올린</code>다. **</p>

    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">이 때, 생성자 주입 상태라면 setter를 먼저 만들고 setter 주입으로 변경(생성자 주입 삭제)해서, setter메서드를 올리면서 필드를 같이 올린다.</code></strong></li>
      <li><strong><code class="language-plaintext highlighter-rouge">올라간 필드는 private을 통해 자식이 변경못하도록 막는다.</code></strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/8d2c07a1-9137-4656-8d36-b83db2396907.gif" alt="8d2c07a1-9137-4656-8d36-b83db2396907"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220711120949357.png" alt="image-20220711120949357"></p>
  </li>
  <li>
    <p><strong>다른 구상체들도</strong> 모두 추상클래스를 상속하고, <strong>생성자 주입부분 + 공통필드를 삭제한다.</strong></p>
  </li>
  <li>
    <p><strong>각 구상체들의 <code class="language-plaintext highlighter-rouge">개별로직을 compare files로 확인</code>이후 <code class="language-plaintext highlighter-rouge">전략메서드로 넘어온 인자들을 내부context라 생각하고, 가장 많은 인자를 사용하는 구상체를 택</code>하여 <code class="language-plaintext highlighter-rouge">훅메서드생성을 위한 개별로직을 private내수용 메서드 추출</code>을 해놓고 <code class="language-plaintext highlighter-rouge">템플릿메소드</code>로 올린다.</strong></p>

    <ul>
      <li>이 때, 내수용 private메서드 추출시, <strong><code class="language-plaintext highlighter-rouge">템플릿메서드 파라미터를 기준</code>으로 하여 <code class="language-plaintext highlighter-rouge">필요한 인자를 가장 많이 사용한 구상체를 기준으로 private 예비 훅메서드를 만들</code>어야, 나중에 인자가 모자라지 않는다.</strong>
        <ul>
          <li>템플릿메소드가 부모context이며, <strong>그 파라미터들이 훅메서드가 인자로 가질 수 있는 객체context</strong>임을 생각해야한다.</li>
          <li><strong>그외 보라색 내부context로직들은  내수용 private내부 훅메서드에 추출되어도, <code class="language-plaintext highlighter-rouge">추상템플릿으로 올린 뒤, @Override protected 개별구현 훅메서드</code>로서, 내부context로 개별구현하게 된다.</strong></li>
        </ul>
      </li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/5e1f28e7-1ca2-4624-ad9a-4fc952c1dfc3.gif" alt="5e1f28e7-1ca2-4624-ad9a-4fc952c1dfc3"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220711122800626.png" alt="image-20220711122800626"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220711122906210.png" alt="image-20220711122906210"></p>
  </li>
  <li>
    <p>나머지 구현체들은 <strong>올라간 훅메서드들을 구현</strong>하면서, <strong>기존 전략메서드 속의 공통로직을 제외한 개별구현 로직만, 훅메서드로 옮긴후, 전략메서드를 삭제</strong>한다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/021b48cf-ec69-419a-984d-8129ab503621.gif" alt="021b48cf-ec69-419a-984d-8129ab503621"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220711123556671.png" alt="image-20220711123556671"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220711123611514.png" alt="image-20220711123611514"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220711123620376.png" alt="image-20220711123620376"></p>
  </li>
  <li>
    <p><strong>생성된 추상클래스는 좋은 상속의 부모로서 <code class="language-plaintext highlighter-rouge">변수는 private, 메서드는 final or protected abstract, 생성자없이 setter로</code></strong>확인하여 달아준다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/68a3a521-5cbc-40a0-a186-99b07cd7f2ec.gif" alt="68a3a521-5cbc-40a0-a186-99b07cd7f2ec"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220711124830443.png" alt="image-20220711124830443"></p>
  </li>
  <li>
    <p><strong>부모클래스로 올릴 때 <code class="language-plaintext highlighter-rouge">삭제한 생성자 주입</code>으로 인해, <code class="language-plaintext highlighter-rouge">next필드에 다음 전략객체 주입시, 변수로 먼저 선언후 setter메서드 호출()</code>까지 해야하는 번거로움이 생긴다.</strong></p>

    <ul>
      <li><strong>생성자 주입은 setter메서드호출을 안해도 되니, 따로 변수로 선언후 호출하는 번거로움은 없었다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/628fdeb3-b7b5-4faf-97f1-6f5437e3098c.gif" alt="628fdeb3-b7b5-4faf-97f1-6f5437e3098c"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220711152318617.png" alt="image-20220711152318617"></p>
  </li>
</ol>

<h4 id="next필드로-연결되는-합성객체용-생성자-주입-대신-void-setter를-가진-추상클래스에-구상층-객체별-체이닝-받기기능으로-대체하기">
<a class="anchor" href="#next%ED%95%84%EB%93%9C%EB%A1%9C-%EC%97%B0%EA%B2%B0%EB%90%98%EB%8A%94-%ED%95%A9%EC%84%B1%EA%B0%9D%EC%B2%B4%EC%9A%A9-%EC%83%9D%EC%84%B1%EC%9E%90-%EC%A3%BC%EC%9E%85-%EB%8C%80%EC%8B%A0-void-setter%EB%A5%BC-%EA%B0%80%EC%A7%84-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90-%EA%B5%AC%EC%83%81%EC%B8%B5-%EA%B0%9D%EC%B2%B4%EB%B3%84-%EC%B2%B4%EC%9D%B4%EB%8B%9D-%EB%B0%9B%EA%B8%B0%EA%B8%B0%EB%8A%A5%EC%9C%BC%EB%A1%9C-%EB%8C%80%EC%B2%B4%ED%95%98%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>next필드로 연결되는 합성객체용 생성자 주입 대신, void setter를 가진 추상클래스에 [구상층 객체별 체이닝 받기기능]으로 대체하기</h4>

<ul>
  <li>
<strong>생성자 단계별 주입 방식이 아닌 형태로 <code class="language-plaintext highlighter-rouge">객체별 체이닝 받기</code>를 시행하려면</strong>
    <ol>
      <li>(호출주체객체 ==  응답형자리에 자신class응답 )<code class="language-plaintext highlighter-rouge">1개 class 모아서 받는다</code>면 -&gt;  매번 변한 상태의 객체를 <code class="language-plaintext highlighter-rouge">return this</code>한다</li>
      <li>
<strong>(구상층들은 같은 class가 아니더라도 1type 응답가능하므로)<code class="language-plaintext highlighter-rouge">각 class의 필드에 다음 객체 받는다</code>면 -&gt; <code class="language-plaintext highlighter-rouge">응답형은 추상체 + return this(구상체)</code>한다</strong>
        <ul>
          <li><strong>여기서는 각 전략객체별로 다음 타자를 받도록 한다.</strong></li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<ol>
  <li>
    <p>현재는 각 전략객체별로 <code class="language-plaintext highlighter-rouge">void setter받기기능</code>을 이용해야하므로 <strong>변수로 빼서 받기기능()을 호출해야한다.</strong>(문제점)</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220711153022536.png" alt="image-20220711153022536"></p>
  </li>
  <li>
    <p><strong>원하는 방향은, <code class="language-plaintext highlighter-rouge">생성된 전략객체를 지역변수 추출없이 [객체별 체이닝 받기기능]을 구현</code>하고 싶다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220711153222306.png" alt="image-20220711153222306"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220711153245677.png" alt="image-20220711153245677"></p>
  </li>
  <li>
    <p>대신 이렇게 구현할 경우, <strong>변수가 없으니 외부에서 받아놓은 객체들을 직접적으로 접근하는 것이 힘들어진다.</strong></p>
  </li>
</ol>

<h5 id="next필드용-생성자-체이닝을-대신하는-void-setter를-구상층-객체별-체이닝-받기기능으로-만들기-실습">
<a class="anchor" href="#next%ED%95%84%EB%93%9C%EC%9A%A9-%EC%83%9D%EC%84%B1%EC%9E%90-%EC%B2%B4%EC%9D%B4%EB%8B%9D%EC%9D%84-%EB%8C%80%EC%8B%A0%ED%95%98%EB%8A%94-void-setter%EB%A5%BC-%EA%B5%AC%EC%83%81%EC%B8%B5-%EA%B0%9D%EC%B2%B4%EB%B3%84-%EC%B2%B4%EC%9D%B4%EB%8B%9D-%EB%B0%9B%EA%B8%B0%EA%B8%B0%EB%8A%A5%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%8B%A4%EC%8A%B5" aria-hidden="true"><span class="octicon octicon-link"></span></a>next필드용 생성자 체이닝을 대신하는 void setter를 [구상층 객체별 체이닝 받기기능]으로 만들기 (실습)</h5>

<ol>
  <li>
    <p><strong>구상체 1개만 들어가는 자리에 .setNext()를 호출하여 빨간줄</strong>을 만들고 <strong>void setter -&gt; <code class="language-plaintext highlighter-rouge">추상체 setter</code>로 시그니쳐를 변경</strong>한다. <strong>자동완성시, <code class="language-plaintext highlighter-rouge">return this</code>가 되는지 확인하고 변경해준다.</strong></p>

    <ul>
      <li>
<strong>변수 추출후 setNext()는 빨간줄이 안만들어진다. void라서, 만들려면 좌측에 추상체 변수에 할당해서 만들어야 <code class="language-plaintext highlighter-rouge">체이닝 받기의 형이 틀림</code>의 에러가 뜬다.</strong>
        <ul>
          <li>에러의 확인은 <code class="language-plaintext highlighter-rouge">Ctrl + F1</code>의 Error Description을 활용한다.</li>
        </ul>
      </li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/3cdc6d84-036f-4f20-8b38-55df43fabb0b.gif" alt="3cdc6d84-036f-4f20-8b38-55df43fabb0b"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220711171341015.png" alt="image-20220711171341015"></p>
  </li>
  <li>
    <p><strong>체이닝 받기시, <code class="language-plaintext highlighter-rouge">1개의 객체가 변화하면서 다 받는 구조가 아니</code>므로 <code class="language-plaintext highlighter-rouge">메서드 체이닝을 하면 안된다</code></strong></p>

    <ul>
      <li>
<strong>조심) <code class="language-plaintext highlighter-rouge">1개의 class내부에서 1개의 객체가 연속해서 받는 것이 아니</code>므로 <code class="language-plaintext highlighter-rouge">진정한 메서드 체이닝</code>이 아니라  <code class="language-plaintext highlighter-rouge">new 1번재객체().setNext( new 2번째객체().setNext() )</code>로서 <code class="language-plaintext highlighter-rouge">생성자 체이닝 모양</code>이다.</strong>
        <ul>
          <li>**<code class="language-plaintext highlighter-rouge">1개 객체가 연속해서 체이닝하여 받는 경우</code> -&gt;  <code class="language-plaintext highlighter-rouge">변화된 객체를 반환</code>하므로 <code class="language-plaintext highlighter-rouge">메서드호출 끝나고 체이닝</code>하지만, **</li>
          <li><strong>여기서는 <code class="language-plaintext highlighter-rouge">new 객체 생성() 하자마자 .setter로 다음타자 넣어준 객체를 생성자에 넣어준다</code>는 느낌이므로 <code class="language-plaintext highlighter-rouge">마치 생성자 체이닝과 같은 형태</code>가 유지되어야한다.</strong></li>
        </ul>
      </li>
      <li>만약, 메서드체이닝을 해버리면, <strong>return this되는 첫번째 객체의 next에 들어가는 객체만 돌아가면서 바뀐다.</strong>
</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/40fcf84d-44a7-469a-ae35-4c4d83052413.gif" alt="40fcf84d-44a7-469a-ae35-4c4d83052413"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220711172830756.png" alt="image-20220711172830756"></p>
  </li>
</ol>

<h4 id="연결되는-합성객체를-가지는-추상템플릿메서드패턴---여러개의-전략객체를-가지고-누적용시키는-전략주입-구상클래스를-가지는-전략패턴으로-변경실습">
<a class="anchor" href="#%EC%97%B0%EA%B2%B0%EB%90%98%EB%8A%94-%ED%95%A9%EC%84%B1%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EA%B0%80%EC%A7%80%EB%8A%94-%EC%B6%94%EC%83%81%ED%85%9C%ED%94%8C%EB%A6%BF%EB%A9%94%EC%84%9C%EB%93%9C%ED%8C%A8%ED%84%B4---%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EC%A0%84%EB%9E%B5%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EA%B0%80%EC%A7%80%EA%B3%A0-%EB%88%84%EC%A0%81%EC%9A%A9%EC%8B%9C%ED%82%A4%EB%8A%94-%EC%A0%84%EB%9E%B5%EC%A3%BC%EC%9E%85-%EA%B5%AC%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A5%BC-%EA%B0%80%EC%A7%80%EB%8A%94-%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4%EC%9C%BC%EB%A1%9C-%EB%B3%80%EA%B2%BD%EC%8B%A4%EC%8A%B5" aria-hidden="true"><span class="octicon octicon-link"></span></a>연결되는 합성객체를 가지는 추상템플릿메서드패턴 -&gt; 여러개의 전략객체를 가지고 누적용시키는 전략주입 구상클래스를 가지는 전략패턴으로 변경(실습)</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712003807839.png" alt="image-20220712003807839"></p>

<ul>
  <li>
    <p><a href="https://github.com/is2js/object2/tree/637a62919ac7e16e0993bcfa48de506fe116f80c/src/main/java/goodComposition">시작커밋</a></p>
  </li>
  <li>추상클래스는 객체화 될 수 없어서, 공통필드next를 한 곳에 모아서 사용할 수 없다.
    <ul>
      <li><strong>개별 구상체들이 next를 소유하는 방법을 버리고 -&gt; 1개의 구상클래스가 컬렉션필드를 가지고 모으는 구조를 구상클래스를 가지는 전략패턴을 통해 구현 가능하다.</strong></li>
    </ul>
  </li>
  <li>
<strong>next필드를 각 구상체마다 가지려면, 데코레이터 패턴의 생성자 체이닝이나 setter체이닝을 해야만한다.</strong>
    <ul>
      <li>**템플릿메소드 -&gt; 전략패턴으로 변경하면서 생기는 <code class="language-plaintext highlighter-rouge">전략주입 구상클래스</code>는 <code class="language-plaintext highlighter-rouge">적용할 전략객체들을 모아서 누적 적용</code>시킨다. **</li>
    </ul>
  </li>
  <li>
    <p>템플릿메소드 패턴 -&gt; 전략패턴 변경 방법 정리</p>

    <ul>
      <li>전략적용대상의 class가 추상클래스로 개별로직을 가지는 상태</li>
    </ul>

    <ol>
      <li>추상class를 일반클래스로 변경 및 훅메서드 정의부 삭제
-&gt; 훅메서드를 alt+del로 삭제하면, 구상체들의 개별로직이 재활용안되므로 그냥 삭제한다.</li>
      <li>내수용 private훅메서드 호출부를, 주입된 전략객체.전략메서드()호출로 변경
-&gt; 전략객체명은, 전략메서드(구 훅메서드)를 바탕으로 or로 만드는게 일반적이다.</li>
      <li>전략 인터페이스 만들고, 전략메서드를 올린다.</li>
      <li>전략객체를 생성자 주입받는다 (생성자 or 확장(좋은 상속 가능성)있으면 setter로 받기)
-&gt; 일단은 1개만 필수로 받도록 생성자 주입 받는다.</li>
      <li>훅메서드구현 개별자식들을 [구상내용+전략인페명]으로 변경하고, 전략인터페이스 구현시킨다.</li>
      <li>
        <p>@Override 개별구현 proected훅메서드 -&gt;  public전략메서드로 시그니쳐 변경</p>
      </li>
      <li>전략주입 구상클래스가 된 부모클래스의 템플릿메소드 공통로직 with 내부 context변수들 -&gt; 전체를 전략메서드에 인자로 context위임
        <ul>
          <li>내부context변수들(보라색)을 지역변수로 추출 이후 -&gt; 제외하고 메서드 추출 -&gt; 인라인으로 메서드인자로 context 넘겨주기</li>
        </ul>
      </li>
      <li>delegate로 추출한 전체로직을 전략메서드에 default메서드로 위임</li>
      <li>
        <p>위임된 default메서드 로직에서, default를 지우고 로직을 개별 전략객체들에게 구현-&gt;전달후, 기존 전략메서드(context인자X)는 삭제</p>
      </li>
      <li>전략주입 구상클래스가 여러개의 전략을 받는다면, <strong>Set컬렉션 전략객체 필드</strong>를 만들고
        <ol>
          <li><strong>1번째 전략객체는 필수로서 생성자 주입 받되, add해준다.</strong></li>
          <li>
<strong>2번째 전략객체부터는 setter로 add하여 받는다.(setNext())</strong>
            <ul>
              <li><strong>만약, 메서드 체이닝으로 받고 싶다면, add 후 return this로 컬렉션필드를 가진 구상클래스를 반환해서, 체이닝하여 계속 받도록 하면 된다.</strong></li>
            </ul>
          </li>
        </ol>
      </li>
      <li>전략객체를 사용하는 기존 템플릿메서드에서, for문으로 컬렉션필드를 돌면서 누적적용해준다.</li>
      <li>client에서 전략주입 구상클래스에 1번째 전략객체는 생성자 주입 -&gt; 2번재부터는 setNext의 메서드체이닝으로 전략객체들을 받아준다.</li>
    </ol>

    <ul>
      <li>전략적용객체에는 전략주입 구상클래스를 set해줘야한다.</li>
    </ul>
  </li>
</ul>

<ol>
  <li>
    <p>추상클래스를 일반클래스로 내리고, 훅메서드 정의부를 단순삭제한다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/cca63d74-f36a-45db-a60e-ffa961b116ea.gif" alt="cca63d74-f36a-45db-a60e-ffa961b116ea"></p>
  </li>
  <li>
    <p>내수용 훅메서드 호출부를 <code class="language-plaintext highlighter-rouge">생성자 or setter 주입</code>받을 전략객체 <code class="language-plaintext highlighter-rouge">(소문자)필드</code>로 채운 뒤, 전략인터페이스를 생성한다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/6d72324f-267e-463b-a47c-dc2a7ffeabf5.gif" alt="6d72324f-267e-463b-a47c-dc2a7ffeabf5"></p>
  </li>
  <li>
    <p>전략객체를 일단 1개는 필수로 생성자 주입 받는다.
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/6305538a-7eb5-4640-be32-d68076f21c45.gif" alt="6305538a-7eb5-4640-be32-d68076f21c45"></p>
  </li>
  <li>
    <p>훅구상체들의 class명을 [구상내용 + 전략인페명]으로 변경하고, 전략인터페이스를 구현하도록 변경한다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/604441d2-1b84-40eb-a8ed-6023702981a2.gif" alt="604441d2-1b84-40eb-a8ed-6023702981a2"></p>
  </li>
  <li>
    <p>@Override + <code class="language-plaintext highlighter-rouge">proected</code>의 훅메서드를 -&gt; <code class="language-plaintext highlighter-rouge">public</code> 전략메서드로서 개별구현하도록 접근제한자를 바꿔준다.
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/6329ea32-9bc2-483a-91bb-eb65478bd084.gif" alt="6329ea32-9bc2-483a-91bb-eb65478bd084"></p>
  </li>
  <li>
    <p>전략주입 구상클래스가 된 부모클래스의, 템플릿메소드 로직 중, 전략메서드로 넘겨줘야할 부분이 남아있으면 SRP원칙에 맡게 메서드추출하여 넘겨준다.</p>

    <ul>
      <li><strong>여기선 없다. 여러 전략객체 적용부만 남은 상태</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712000522775.png" alt="image-20220712000522775"></p>
  </li>
  <li>
    <p>전략주입 구상클래스가 여러개의 전략을 받는다면, <strong>Set컬렉션 전략객체 필드</strong>를 만들고</p>

    <ol>
      <li><strong>1번째 전략객체는 필수로서 생성자 주입 받되, add해준다.</strong></li>
      <li>
<strong>2번째 전략객체부터는 setter로 add하여 받는다.</strong>
        <ul>
          <li><strong>만약, 메서드 체이닝으로 받고 싶다면, add 후 return this로 컬렉션필드를 가진 구상클래스를 반환해서, 체이닝하여 계속 받도록 하면 된다.</strong></li>
        </ul>
      </li>
    </ol>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/68f79285-e6b1-4a73-a44d-d13dea9019fb.gif" alt="68f79285-e6b1-4a73-a44d-d13dea9019fb"></p>
  </li>
  <li>
    <p>모은 전략객체 컬렉션필드를 돌면서, 구 템플릿메소드 현 전략객체 호출 메서드를 누적적용해준다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712002553173.png" alt="image-20220712002553173"></p>
  </li>
  <li>
    <p>client에서 전략주입 구상클래스에 1번째 전략객체는 생성자 주입 -&gt; 2번재부터는 setNext의 메서드체이닝으로 전략객체들을 받아준다.</p>

    <ul>
      <li>전략적용객체에는 전략주입 구상클래스를 set해줘야한다.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/307c9079-7eb0-45f2-bc5d-0ce760cb131b.gif" alt="307c9079-7eb0-45f2-bc5d-0ce760cb131b"></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712002635893.png" alt="image-20220712002635893"></p>
  </li>
</ol>

  </div><a class="u-url" href="/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/strategy/templatemethod/plan/connectobject/2022/07/12/Object_strategy_to_template_for_duplicate.html" hidden></a>
</article>


<!-- <script src="https://utteranc.es/client.js"
        repo="is2js/blog_raw"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script> -->
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="https://blog.chojaeseong.com/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>평범한 한의사 돌범의 엔지니어 도전기</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
  <a href="/feed.xml" target="_blank" title="rss">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://github.com/is2js/" target="_blank" title="github">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#github"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://twitter.com/yarotheslav" target="_blank" title="twitter">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#twitter"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://www.linkedin.com/in/yshmarov/" target="_blank" title="linkedin">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#linkedin"></use>
    </svg>
  </a>
</li>
</ul>
</div>

  </div>

</footer>
</body>

</html>
