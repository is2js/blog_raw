{
  
    
        "post0": {
            "title": "window terminal 단축키 매핑",
            "content": "Window Terminal 단축키 설정 . vscode와 비슷하게 추가 매핑해준다. . actions 부분에 추가해주면 된다. | . { &quot;command&quot;: &quot;find&quot;, // 검색키 매핑 // &quot;keys&quot;: &quot;ctrl+shift+f&quot;, &quot;keys&quot;: &quot;ctrl+shift+f&quot; }, // 수직분할 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;vertical&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+plus&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;vertical&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;ctrl+ &quot; }, // 수평분할 매핑(추가) //{ &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;horizontal&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+-&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;horizontal&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+0&quot; }, // 탭 끄기 매핑(추가) { &quot;command&quot;: &quot;closePane&quot;, &quot;keys&quot;: &quot;ctrl+w&quot; }, // 포커스key 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;down&quot; }, &quot;keys&quot;: &quot;alt+down&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;down&quot; }, &quot;keys&quot;: &quot;ctrl+alt+down&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;left&quot; }, &quot;keys&quot;: &quot;ctrl+alt+left&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;right&quot; }, &quot;keys&quot;: &quot;ctrl+alt+right&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;up&quot; }, &quot;keys&quot;: &quot;ctrl+alt+up&quot; }, // 창이동 단축키 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 0 }, &quot;keys&quot;: &quot;ctrl+alt+1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 0 }, &quot;keys&quot;: &quot;ctrl+1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 1 }, &quot;keys&quot;: &quot;ctrl+2&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 2 }, &quot;keys&quot;: &quot;ctrl+3&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 3 }, &quot;keys&quot;: &quot;ctrl+4&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 4 }, &quot;keys&quot;: &quot;ctrl+5&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 5 }, &quot;keys&quot;: &quot;ctrl+6&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 6 }, &quot;keys&quot;: &quot;ctrl+7&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 7 }, &quot;keys&quot;: &quot;ctrl+8&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 8 }, &quot;keys&quot;: &quot;ctrl+9&quot; }, // Rename a tab to &quot;Foo&quot; { &quot;command&quot;: { &quot;action&quot;: &quot;renameTab&quot;, &quot;title&quot;: &quot;server&quot; }, &quot;keys&quot;: &quot;f1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;renameTab&quot;, &quot;title&quot;: &quot;jupyter&quot; }, &quot;keys&quot;: &quot;f2&quot; }, . | .",
            "url": "blog.chojaeseong.com/configuration/windowsterminal/shortcut/2022/06/02/windows_terminal_shortcut.html",
            "relUrl": "/configuration/windowsterminal/shortcut/2022/06/02/windows_terminal_shortcut.html",
            "date": " • Jun 2, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "screen to gif(짤 생성)",
            "content": "screen to gif를 검색해서 프로그램을 다운 받는다. . | 설정 프로그램: 수동으로 시작 + 복수의 프로그램 허용 | 처음화면: 화면녹화기 | 색 설정: 중간 | 모든 창이 닫혀 있어도 프로그램을 종료하지 않습니다. | 트레이 &gt; 종료 체크해제 | 업데이트 확인 2개 체크해제 | . | 녹화기: 새 버전 체크 | 녹화모드: BitBit -&gt; DirectX 체크 | 기타: 이전 녹화구역 저장 체크해제 | . | 편집기: 색 설정: 중간 | 일반: 확인하기 3종 체크 해제 | . | 기타: FFmpeg 다운로드후 경로 지정: 동영상 &gt; screentogif폴더생성 &gt; 저장 | . | 단축키: 화면 녹화기:ctrl+alt+shift + F12 이 설정을 해주고 직전 편집기(캡처 후 저장하는 창)상태에서 하나 더 켜놔야, (편집기 종료 -&gt; 프로그램 종료) 추가로 gif촬영을 지속할 수 있다. | 만약 편집기를 [닫기]하면, 프로그램 자체도 종료되어버린다. 만약, 녹화기가 추가로 열리면, 편집기 닫아도 프로그램 안꺼진다. | 편집기 상태에서 다음 촬영할거면, 하나 더 켜두자. | . | 종료: ctrl+alt+shift + F4 | 녹화 취소 &gt; F9 녹화 취소할 때, 중지(F8) -&gt; 취소(F9) 연타 치면 된다. | . | . | 편집기-저장탭(첫 녹화 종료F7-&gt;F8시 설정 가능) 파일종류: 2번째를 screentogif -&gt; FFmpeg - high qualyity 선택 | 중복 픽셀 감지 체크해제 | 지정 경로에 파일 저장하기 체크해제 | 클립보드에 복사하기 체크 &gt; 파일 선택 | 세팅이 끝난 뒤, autosave 탭 &gt; +해서 저장시키기 | . | | 단축키 사용하기 ctrl+alt+shift + F12: (프로그램 킨 상태)화면 녹화기 바로 켜기 활용은, 첫번째 촬영 후, 편집기를 닫기 전에, 추가촬영을 이어가야할 때, 미리 하나 켜둔다. 안켜두면 프로그램 종료 | . | F7 : 녹화 시작 -&gt; 일시 중지 | F8: 녹화 종료 및 편집기 열기 | F9: (F7 2번 눌러 일시중지 상태시) 녹화 취소 F7 녹화 중에 F7-&gt; F9 연달아서 사용 | . | Ctrl+S: (편집기 열린 상태) 녹화한 것 저장 | ctrl+alt+shift + F4: 프로그램 종료 | . |",
            "url": "blog.chojaeseong.com/configuration/windows/git/screentogif/%EC%A7%A4/2022/06/02/screen_to_gif.html",
            "relUrl": "/configuration/windows/git/screentogif/%EC%A7%A4/2022/06/02/screen_to_gif.html",
            "date": " • Jun 2, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "github codereview PR comment",
            "content": "commit link 복붙 . 현재 PR의 커밋을 복붙한 경우: commit번호으로 표기된다. 링크: https://github.com/woowacourse/java-racingcar/pull/330/commits/a1815b89cf878c8e92a27f274e0f857605aa40ff | 표시 | 직접 commit번호를 입력하면 링크가 안된다. | . | 다른 PR의 커밋을 복붙한 경우: upstream레포@commit번호으로 표기된다. 링크: https://github.com/woowacourse/atdd-subway-path/commit/89e7df5a653dc1109b2c18f261a9ee7f81582708 | 표시 | . | comment link 복붙(위 empty line유무) . 현재 PR의 comment를 복붙한 경우: commit번호으로 표기된다. comment link위에 글이 있는 경우(PR 이쁘게 + (comment) text 나옴) | comment link위에 글이 없는 경우(#PR번호 comment text만 나옴) | | 다른 PR의 커밋을 복붙한 경우: upstream레포@commit번호으로 표기된다. comment link위에 emptyline 유무는 똑같이 반영되지만 | emptyline을 줘서 text만 표기 될 때, 앞에 upstream레포url이 붙게 된다. | . | #은 upstreamREPO 속 PR들 탐색 / @는 사용자 탐색 . # upstream PR들 탐색 . | @ 사용자 탐색 . |",
            "url": "blog.chojaeseong.com/git/github/comment/pr/codereview/2022/05/27/github-comment.html",
            "relUrl": "/git/github/comment/pr/codereview/2022/05/27/github-comment.html",
            "date": " • May 27, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Microsoft Whiteboard",
            "content": "설치 . 시작메뉴에서 Microsoft or store 검색 | whiteboard 검색 |",
            "url": "blog.chojaeseong.com/configuration/ms/microsoft/whiteboard/%ED%99%94%EC%9D%B4%ED%8A%B8%EB%B3%B4%EB%93%9C/2022/05/26/windows_ms_whiteboard.html",
            "relUrl": "/configuration/ms/microsoft/whiteboard/%ED%99%94%EC%9D%B4%ED%8A%B8%EB%B3%B4%EB%93%9C/2022/05/26/windows_ms_whiteboard.html",
            "date": " • May 26, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "windows xbox record in chrome",
            "content": "windows xbox 녹화 단축키 . win + alt + R : 빠른 녹화 . | win + g : xbox 녹화 설정 . | 크롬 소리 녹화가능하게 하기 . 게임+마이크 기반으로 녹화되는 것이 기본 설정이다 . | 아래 그림과 같이 설정을 바꿔야한다. . | . . win + g를 눌러 xbox 기능으로 들어간다. | 우측 상단의 톱니바퀴 &gt; 캡처 중으로 들어간다 | 아래 2가지를 체크한다. 게임 플레이 중 백그라운드 녹화 | 게임(게임, 사용가능 마이크) 옵션을 -&gt; [x] 모두(게임, 사용가능 마이크, 앱, 시스템)로 변경한다 | . |",
            "url": "blog.chojaeseong.com/configuration/windows/xbox/record/2022/05/22/windows_xbox_record_setting.html",
            "relUrl": "/configuration/windows/xbox/record/2022/05/22/windows_xbox_record_setting.html",
            "date": " • May 22, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "vscode markdown link shortcut",
            "content": "keybindings.json 열어 아래 코드 복붙하기 . F1 &gt; keyboard 검색후 &gt; 바로가기 키 열기 (JSON)을 선택한다. . | 아래 코드를 맨 위에 붙여넣는다. // 스니펫 참고: https://code.visualstudio.com/docs/editor/userdefinedsnippets // 마크다운일 때, 링크 삽입 태그 추가 { &quot;key&quot;: &quot;ctrl+k&quot;, &quot;command&quot;: &quot;editor.action.insertSnippet&quot;, &quot;args&quot;: { &quot;snippet&quot;: &quot;[${TM_SELECTED_TEXT}](${CLIPBOARD})&quot; }, &quot;when&quot;: &quot;editorHasSelection &amp;&amp; editorLangId == &#39;markdown&#39;&quot; }, . | 이후 clipboard에 url을 복사한 상태에서, markdown 내 텍스트에 ctrl + k를 눌러서 링크를 바로 건다 |",
            "url": "blog.chojaeseong.com/configuration/vscode/2022/05/18/vscode-markdown-ctrl-k.html",
            "relUrl": "/configuration/vscode/2022/05/18/vscode-markdown-ctrl-k.html",
            "date": " • May 18, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "intellij, pycharm Run in WindowsTerminal",
            "content": "intellij bin 폴더를 Path에 등록하여 idea .으로 실행 . 탐색기 &gt; 내컴퓨터우클릭 &gt; 속성 선택 win + R -&gt; sysdm.cpl | . | 환경변수 클릭 . | 사용자 변수 &gt; Path(기본으로 인식될 경로 모음) 선택 . | 새로 만들기 선택 후 intellij의 bin폴더까지의 경로 입력 intellij의 파일위치 열기 -&gt; bin 내부 폴더임 C: Users cho_desktop AppData Local JetBrains Toolbox apps IDEA-U ch-0 221.5591.52 bin . | . | 프로젝트 폴더 경로에서 idea .으로 실행 . 빠지면 기존 실행중이던 것만 깜빡이는 것 같다. 항상 붙여주자. | . | pycharm도 bin 등록하여 pycharm .으로 실행 . Path에 pycharm의 bin경로를 걸어준다. C: Users cho_desktop AppData Local JetBrains Toolbox apps PyCharm-P ch-0 221.5591.52 bin . | 터미널에서 pycharm .명령어로 실행한다. |",
            "url": "blog.chojaeseong.com/configuration/intellij/pycharm/cmd/terminal/2022/05/18/intellij-cmd-setting.html",
            "relUrl": "/configuration/intellij/pycharm/cmd/terminal/2022/05/18/intellij-cmd-setting.html",
            "date": " • May 18, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "vscode image uploader(picGo+token)",
            "content": "vscode picGo setting . typora picGo 설정을 참고할 준비를 한다. . { &quot;picBed&quot;: { &quot;current&quot;: &quot;github&quot;, &quot;github&quot;: { &quot;repo&quot;: &quot;is2js/screenshots&quot;, &quot;token&quot;: &quot;ghp_&quot;, &quot;path&quot;: &quot;&quot;, &quot;customUrl&quot;: &quot;https://raw.githubusercontent.com/is2js/screenshots/main&quot;, &quot;branch&quot;: &quot;main&quot; } }, &quot;settings&quot;: { &quot;showUpdateTip&quot;: true, &quot;autoStart&quot;: true, &quot;uploadNotification&quot;: true, &quot;miniWindowOntop&quot;: true }, &quot;needReload&quot;: false, &quot;picgoPlugins&quot;: {} } . | vscode 확장에서 picGo를 검색하여 설치한다. . . | 설정(ctrl + ,)로 들어가 picGo를 검색한다. . Pic Bed: Current를 github로 선택 . | Branch를 main으로 선택 . main . | Custom Url을 계정/내 스크린샷폴더/branch를 입력한다. . https://raw.githubusercontent.com/is2js/screenshots/main . | Path는 생략 . | Repo는 계정/내 스크린샷폴더를 입력 . is2js/screenshots . | Token은 typora설정시 받아왔던 github token을 가져온다. . ghp_ . 그외 설정은 비워둔다. | . | | 내 대문자변환 단축키c+a+U과 겹친 기본 붙여넣기 단축키를 따로 설정한다. . ctrl + k + s 으로 단축키 설정으로 들어간다 . | upload를 검색하여 해당 picgo 업로드 단축키를 ctrl + alt + v로 설정해준다. . . | | 단축키 . ctrl + alt + v(클립보드 그림 붙여넣기) . [ctrl + k] + v (측면 미리보기) -&gt; shift+alt+0 (아래로 내리기) . . . .",
            "url": "blog.chojaeseong.com/configuration/vscode/picgo/github-token/settings/2022/05/17/vscode-image-uploader(picGo+token).html",
            "relUrl": "/configuration/vscode/picgo/github-token/settings/2022/05/17/vscode-image-uploader(picGo+token).html",
            "date": " • May 17, 2022"
        }
        
    
  
    
        ,"post8": {
            "title": "github command shortcut",
            "content": "Repo 탐색 . searchbox(/) . / : 메인화면 왼쪽 상단 searchbox . . | . file finder(T) . T: repo 내에서 file finder 열기 . 일일히 파일클릭해서 찾아들어가기 안해도 됨 . . | . | . command pallete(ctrl + k) -&gt; #, &gt;, tab, enter . ctrl+K: 커맨드 팔렛 . repo들 다 확인 가능 . | enter시 해당 레포로 완전 이동 . | 팔렛트 유지하려면 tab으로 진입 . | 모두 지운 상태(계정명까지)에서 #을 누르면 PR이 나옴 . 계정 있는 상태 is2js / #하면 내가 참여한 PR/merge/issue | . . | &gt; : github command들 나옴 . . | . | . 단축키 확인 (?) . PR관련 . hide comments (i) . i를 통해 PR &gt; Files changed에서 코멘트 숨기기 . . . | . 닷닷닷&gt; view file 상태 . line jump(L) . . git blame 모드(B) . . 마우스를 올리면, 커밋내역이 자세히 보인다 | . . code 공유 . permalink 만들기 . 01 view file상태 &gt; line 좌측 클릭(닷닷닷) . . 02 shift + 클릭으로 여러line 만들기 . . 03 주소창 or Copy permalink를 영구link(canonical)로 변경하기(Y) . 이미 default로 적용된 듯? | 파일경로 주소 -&gt; github commit기반의 주소 파일명이 변경되어도 계속 주소가 유지 된다. | . | . . 04 팔렛트 &gt; 관심 레포 &gt; &gt; issue (PR or issue 속 readme, markdown )에 link 복붙시 코드스니펫도 제공된다. . . . . . . 마크다운 팁 . kbd 태그 / 백틱 + hexcode#hexcode / diff . . . . . 계정 주소 뒤에 .png . . . . 그외 . or 주소맨앞에 vscode.dev/추가해서 enter . comment 남기기 . 모든 comment 모아보기 . . .",
            "url": "blog.chojaeseong.com/git/github/2022/05/12/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%8B%A8%EC%B6%95%ED%82%A4.html",
            "relUrl": "/git/github/2022/05/12/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%8B%A8%EC%B6%95%ED%82%A4.html",
            "date": " • May 12, 2022"
        }
        
    
  
    
        ,"post9": {
            "title": "레벨1 레벨 인터뷰 및 피드백",
            "content": "레벨 인터뷰 관련 . 레벨로그를 작성해서 공유하여 레벨 1학습한 것을 정리 . | 메타인지: 자신이 아는지 모르는지 성찰하는 능력, 자신의 생각에 대해 생각하는 능력 . | 6명: 1인터뷰이 -&gt; 3인터뷰어(질문자) + 2옵져버(피드백 기록-어떤점이 부족하고 어떤점을 보완했으면 좋겠다.) . | 명당 30분(인터뷰 20분 + 피드백 10분) 내가 인터뷰어일 때, 해당하는 인터뷰이의 레벨로그를 읽어보고 참석해야한다 | 내가 옵져버일 때, 말하기 역량에 대한 피드백을 준비한다. | . | 레벨 2 시작하고 수, 목 14시~17시 . 코치들이 난이도 있는 질문을 추가적으로 한다. | . . | . 준비 . 레벨 로그 . TDD . test 파일부터 만들어서 개발을 시작한다. 메서드명은 한글로 사용해도 상관 없으며 단위테스트가 의미하는 바를 잘 나타내야한다. | 테스트시 코드를 작성할 때 당장 존재하지 않는 클래스, 메서드를 사용해서 작성한 뒤, red(error)를 발생시킨다. red를 제거하여 green(pass)이 되는 방향으로 프로덕션 코드를 작성한다. | pass된 프로덕션 코드를 바탕으로 기존 프로덕션 코드를refactoring한다. | 더이상 refactoring할 것이 없다면 새로운 단위테스트를 만들어서 이어나간다. | 요약하면 fail하는 test -&gt; pass하도록 빠르게 production 수정 -&gt; refactoring | . | 할 수 있다면 주석으로 //given //when //then 3단계로 나누어서 테스트코드를 작성하여 예상값과 실제값을 비교한다. | 직전과 비슷한 test case를 작성한다면 코드를 복사하여 붙여넣기를 활용하면 좋다. | . 테스트 하기 힘든 것을 전략패턴으로 . 자동차 미션의 랜덤한 값에 따라 자동차가 움직임 , 로또 미션의 자동 로또를 랜덤하게 생성함, 블랙잭 미션의 랜덤한 카드덱을 매번 생성, 체스 미션의 매번 DB에 연결하는 Dao | 각 미션마다 테스트하기 힘든 부분을 어느 추상체에 대한 구현체 중 1개로 보고 해당코드를 추상화한다. 이 때, 추상화된 인터페이스를 파라미터에서 받아 외부에서 주입받도록 한다면 전략패턴이 되는 것이다. 이제 테스트 하기 힘든 구현체와 같은 레벨의 테스트 하기 쉬운 구현체를 작성하여 Test코드에서 외부에서 주입할 수 있다. | . 상속, 추상클래스, 조합 . 상속은 같은 레벨의 클래스들이 중복된 코드를 가질 때 고려해볼 수 있다. 공통된 메서드나 필드가 발견되면 그것들을 모아놓은 부모클래스를 생성하고 그 메서드나 필드를 받아 쓸 자식클래스들은 해당 클래스를 상속한다. | . | 이후 공통적이지 않은 메서드들에 대해서는 구현부는 다를지언정 메서드명을 추상화할 수 있는지 고려해보아야한다. 자식클래스들에 대해 서로 다른 구현부를 가진 메서드에 대해서 메서드명이 추상화가 된다면, 추상화된 메서드명으로 abstract method를 정의해주자. intellij가 알아서 abstract class로 변경하라고 메세지를 보내준다. | 메서드명의 추상화 성공시, 또다른 중복코드가 발생할 수 있는데 다시 abstract class로 공통 부분들을 올려주면 된다. | . | 조합은 공통되는 코드를 부모클래스를 생성하여 올리는 것이 아니라, 따로 클래스로 추출한 뒤, 기존 클래스의 생성자호출시 주입하여 상태값(필드)로 가지고 있게 된다. 코드중복을 상태값으로 간 객체의 메서드호출로 해결할 수 있다. 상속의 단점이자 조합의 장점 기존 클래스의 변화에 영향이 적어지며, 안전하다. | 메서드를 호출하는 방식으로 동작하기 때문에 캡슐화를 깨뜨리지 않는다. | . | 조합대신 상속을 고려해볼만 할 때 확장을 고려했는데도 설계한 확실한 is - a 관계(부모가 변할일이 없을 때) | . | . | . 대본 . TDD . 정의: 켄트 백에 의해 창시된 TDD는, 기존의 [ 설계-&gt; 개발-&gt; 테스트 ]의 과정과 다르게, [설계 -&gt; 테스트 -&gt; 개발]의 과정으로 진행되며, 테스트 자체도 red-&gt;green-&gt;refactoring 3가지 cycle로 돌아갑니다. 1) red로 테스트를 작성하고 2) green으로 기능을 완성하되 빠르게 완성시킵니다. 3) 다음 case로 넘어가기 전에 refactoring을 실시합니다. . | 장점: 마음에 안정감이 생기면서, 디버깅 시간을 줄이면서, 그 자체로 명세 역할을 할 수 있습니다. 1) 안정감이 생기는 이유는, 자연스럽게 작은 단위를 테스트하도록 작성하므로, 단일책임원칙을 지키면서 코딩할 수 있었습니다. 하지만, TDD에 실패하는 대부분의 이유가 추상체가 아닌 구현체를 테스트하는 경우임을 인식해야합니다. 인터페이스를 테스트해서 무엇보다도, 초록색불을 보면 안정감이 생겼습니다. 2) 디버깅 시간을 줄인다는 의미는 프로덕션 코드 이전에 설계 후 테스트가 이어지기 때문에, 테스트과정에서 설계가 바뀐다면 빠르게 설계를 수정할 수 있습니다. 처음에는 오히려 시간이 많이 걸릴지도 모르지만, 엎어지는 설계를 하는 과정에서도 도메인 지식이 쌓이게 되어 장기적으로는 빠르게 코드를 완성할 수 있습니다. 3) 자체로서 명세역할을 한다는 의미는, 팀원이 TDD의 과정으로 개발된 프로젝트는 테스트 코드만 봐도, 로직을 이해할 수 있게 되기 때문입니다. . | 상속 . 같은 레벨의 클래스들이 중복코드를 가져서 코드중복 제거을 위해 고려해볼 수 있다. . 상속의 예시: 체스판 위의 기물들, 예를 들면 킹,퀸,룩,비숍,나이트,폰 등을 표현하고자 할 때, 각 기물들은 구현하다보면, move라는 공통 기능을 발견하게 됩니다. 이 때, 각 기물들을 자식클래스라고 생각하고 Piece라는 부모클래스를 만들어서 공통기능을 위임하고 코드 중복을 제거할 수 있습니다. . 하지만, 상속에서 자식은 이미 부모가 불변할 것이라고 가정하고, 추가적인 역할을 얹어 사용하는 경우가 많은데, 이렇게 사용할 경우, 부모가 더이상 base문제를 해결하지 못하게 되면, 그 위에 쌓인 자식의 기능들도 다같이 무용지물이 되게 됩니다. . 이럴 때, 고려하는 것이 조합입니다. 조합은 부모의 코드를 바로 내려받는 것 아니라, 공통 기능을 외부 주입으로 통해 받아 변화에 대응할 수 있게끔 합니다. 마치, 원신값 대신 VO를 사용하듯이, 포인터의 포인터를 사용해 공통기능의 변화가 발생하면, 변화된 코드를 받아 사용할 수 있습니다. . 만약, 상속을 유지하겠다면, 자식에게는 최소한의 역할만 배정하는 게 좋습니다. 추상클래스를 하면서, 템플릿메소드패턴을 사용해서 위임할 수 있는 가장 작은 구현책임만 자식에게 위임할 수 있습니다. . 하지만, 여러 기물들을 차례로 하다보면 구현하다보면 공통된 기능이 아니라 서로 다르게 구현해야함을 발견할 수 있습니다. 이 때, 메서드명만 추상화한 추상클래스로 정의해볼 수 있습니다. 더욱이, move뿐만 아니라 canMove? 등의 메서드를 구현하다보면, 자식들마다 구현이 다른 코드가 축적되게 되고, 특히 폰의 경우 그렇습니다. . 이렇게 자식의 책임이 커질 때는, 부모클래스가 더이상 필요 없을 수 있습니다. . 혹은 공통된 기능만 주입받는 조합을 고려해볼 수 있고, 부모의 역할에상속을 이용하는 것보다, 모든 책임을 위임하도록 인터페이스와 구현체로 전환을 고려해볼 수 있습니다. . 이 때, 조합이나 인터페이스로 변경을 통해, 상속이 가지는 단점인 부모 코드에 대한 의존성, 높은 결합도를 줄여볼 수 있습니다. . 전략패턴 -&gt; 로또미션 + 체스dao로 예시들기 . 피드백 . 같은 조 인터뷰 피드백 전체 . 경험을 바탕으로 말하라. | 실패 사례도 같이 예시 들기 | 학습 방식도 같이 말하기 | 뜻을 잘 모르겠으면 다시 질문의 묻기 | 생각할시간달라하기 | 물어본 것부터 답변후 사례나열하기 . 주관식답변 + 3줄 정도만 답변후, 더 답변을 원하는 눈빛을 보이면 하기 | . | 말하기 전 3~5초 잠깐 생각하고 말하기 . 아는 것 나왔다고 바로 답변하지 않기 | . | 잘모르는 키워드, 단어는 꺼내지도 마라 . ex&gt;일급컬렉션 -&gt; 불변으로 연결안되면 꺼내지도 마라. . | “그것에 대해서는 학습이 많이 필요한 상태입니다.!” . | . | 계속 질문한다면 고집스런 모습이 없는지 파악하는 것일 수 있다. 다른쪽으로 유도 되는 질문을 잘 파악하기 | 상상력을 요구하는 꼬리질문에 대해서, 단정짓게 끝내지마라. | 급한 느낌을 받았다. 내가 말할 수 있는 목적을 간단명료하게 하는 것이 학습로그의 목적&gt; 질문 듣고, 말하기 전에 3~5초는 잠깐 생각하고 말하기 | 주관식답변 + 3줄 정도만 답변후, 더 답변을 원하는 눈빛을 보이면 하기 | . | 잘하는 부분과 못하는 부분 같이 말하며 현장감이 드는 설명하기 | . 레벨1 피드백 . 일급컬렉션 반례: 객체생성비용이 많이 드는 경우도 있다. ex&gt; db컨넥션, 웹소켓 객체들은.. 생성비용 크다 -&gt; 일급x | 재사용 및 상태변경이 일어남 -&gt; 일급X | . | . | mvc 장점: 레이어간의 책임분리(레이어분리)로 요구사항 변경에 대한 확산이, 딱 그 레이어까지만 일어나게 | . | 중복된 코드 제거의 목적 : 가독성 뿐만 아니라, 요구사항 변경의 전파를 막기(격리) 위해 중복코드를 제거함. By한 부분만 수정 | . | 어필하기 위한 글쓰기도 전략 어려운 것 질문하기 쉽게 내지마라. | 예) 수달님의 레벨로그 방어적 복사 vs Unmodifiable vs CopyOf | 답변: 방어적 복사: 파라미터로 넘어오는 객체(컬렉션)에 대해서 연결을 끊어놓고 받아 사용하고 싶을 때 new ArrayList&lt;&gt;( 파라미터로 넘어온 컬렉션 ) | . | Unmodifiable &lt; CopyOf getter 내가 가지고 있는 컬렉션을 끊어서 줄 때 | . | . | . | . | 개념 -&gt; 사례순으로 나열하기 | . 개인 피드백 . 할 말이 많아도 천천히 말하기 -&gt; 못 따라간다. | 사례를 많이 말한다 -&gt; 말이 빠르다 + 정정하는 말이 많았다. -&gt; 많은 사례에 비해 들리는 것이 없었다. | 중간 중간 분위기를 풀어주는 농담이 좋았다. | 여러 사례에서 넘어갈 때 텀과 포인트가 필요하다. | 모범답안이 아니라, 주관적인 답변이 개발적 가치관을 알 수 있어 좋았다. | 작은 질문에 비해, 답변을 많이 했다. 밸런스가 중요한데, 질문할 텀을 좋은 것 같다. | 경험이 잘 전달되는 인터뷰라 좋았지만, &lt; 급한 느낌을 받았다. 내가 말할 수 있는 목적을 간단명료하게 하는 것이 학습로그의 목적&gt; . | 질문듣고, 말하기 전에 3~5초는 잠깐 생각하고 말하기 | 내 인터뷰 답변 내용 기록 . 테스트 네이밍 메소드 명과 같이 카멜케이스 사용 혼자서 작성할 때는 한글, 그렇지 않은 경우는 영어로 . | 중복된 코드를 줄이기 위해 인터페이스가 아닌 상속을 사용한 이유 . | 같은 레벨에 있는 클래스를 작성할 때 중복 코드가 발생 | 인터페이스를 사용하지 않는 이유는 부모의 역할이 클 때는 상속을 사용하고, 확장성이 있다면 조합이나 인터페이스를 사용해서 진행 | . 조합을 사용해본 경험 프로젝트에서 조합을 사용해보려 했으나 실패, 상속에 비해 조합이 부모 클래스에 대한 의존을 줄일 수 있음 . | 전략패턴 분기를 줄이는데도 사용, 테스트를 줄이기 위해 사용 . | TDD의 장점 | 테스트 코드 안정감 | 단일 책임 원칙을 지킬 수 있음 | 디버깅 시간을 줄일 수 있음 + 숙달 시 설계 시간을 줄임 | 자체로 명세가 될 수 있음 . | TDD의 단점 시간이 너무 오래 걸린다. 절충이 필요한 점. 작은 프로젝트에 적합하지 않다고 생각 . | 큰 프로젝트에서 요구사항 변경이 생긴다면 TDD가 적합하지 않지 않을까 TDD가 익숙하다면 무조건 유리할거 같다. . | TDD를 학습하기 위한 전략 메인 로직을 짜다가 작은 단위를 테스트하고 올라오고 반복 . | TDD를 큰 로직을 성공 후 작은 로직을 개발하다가 전체가 문제가 생긴 경험? | TDD가 실패를 기반으로 개발하다 보니 전체가 문제가 생긴 경험이 많음. | . 테스트 코드 + 프로덕션 코드 변경이 많은 경우 | 주요 로직이 아니라면 삭제, 삭제가 불가능한 경우 테스트 코드 자체를 리팩토링 해야한다고 생각 | . 추상화란 무엇인지 | 비슷한 역할을 하는 것들이 보이면 추상화의 대상이 된다고 판단. 최초로 코드를 짤 때는 추상화를 고민하지 말고, 리팩토링 할 때 추상화를 고려해보아야 한다. | . 중복된 코드는 왜 제거해두어야 할까? | 다른사람이 읽거나 찾아가는데 방해가 되는 경우 중복된 코드를 내버려두어도 된다.” | .",
            "url": "blog.chojaeseong.com/%EB%A0%88%EB%B2%A81/%EC%9D%B8%ED%84%B0%EB%B7%B0/%EB%A0%88%EB%B2%A8%EC%9D%B8%ED%84%B0%EB%B7%B0/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/19/%EB%A0%88%EB%B2%A81-%EB%A0%88%EB%B2%A8%EC%9D%B8%ED%84%B0%EB%B7%B0.html",
            "relUrl": "/%EB%A0%88%EB%B2%A81/%EC%9D%B8%ED%84%B0%EB%B7%B0/%EB%A0%88%EB%B2%A8%EC%9D%B8%ED%84%B0%EB%B7%B0/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/19/%EB%A0%88%EB%B2%A81-%EB%A0%88%EB%B2%A8%EC%9D%B8%ED%84%B0%EB%B7%B0.html",
            "date": " • Apr 19, 2022"
        }
        
    
  
    
        ,"post10": {
            "title": "데스크탑 iptime RDP 설정",
            "content": "iptime에 물린 컴퓨터/테블릿 중 원격접속할 [데스크탑 내부ip]를 확인한다. . 192.168.0.1 &gt; 관리도구 . | 고급 설정 &gt; 네트워크 관리 &gt; 내부 네트워크 정보 . | 원격접속할 데스크탑의 내부ip 확인 . 192.168.0.11 D8-BB-C1-5F-99-3A DESKTOP-CJROKE9 유선:자동할당 . | 데스크탑 내부ip를 포트포워딩 설정(외부:4444 1~100빼고 맘대로, 내부:3389 rdp고정) . 고급 설정 &gt; NAT/라우터 관리 &gt; 포트포워딩 설정 외부포트는 1~100를 제외한 맘대로(4444)로 설정해준다. | 내부포트는 3389가 고정이어야한다(3389로 보내야, RDP로서 컴퓨터가 port 오픈해줌) | . | . . . 기본 설정 &gt; 시스템 요약정보에서 [외부IP]확인 or DDNS 사용하기 . 외부IP는 동적IP이기도 해서 외부IP는 사용하지 않는다. | IP대신 DDNS를 제공받아서 chodesktop.iptime.org 자체를 내 외부ip로 사용한다. | . 원격 제어되는 컴퓨터 설정(원격 설정 활성화/계정 비번설정/계정 확인) . 시작메뉴에서 원격 설정 검색 &gt; 원격 데스크톱 설정 &gt; [x] 원격 데스크톱 활성화 | 현재 사용자 비밀번호가 없다면 설정 win + i &gt; 계정 &gt; 로그인 옵션 &gt; 비밀번호 &gt; 추가 | . | 시작메뉴에서 control userpasswords2로 사용자 이름 확인 | mstsc &gt; chodesktop.iptime.org:4444 &gt; cho_desktop로 RDP 접속하기 .",
            "url": "blog.chojaeseong.com/rdp/iptime/%EC%9B%90%EA%B2%A9/configuration/2022/04/19/%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91-iptime-RDP-%EC%84%A4%EC%A0%95-%EC%B4%9D%EC%A0%95%EB%A6%AC.html",
            "relUrl": "/rdp/iptime/%EC%9B%90%EA%B2%A9/configuration/2022/04/19/%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91-iptime-RDP-%EC%84%A4%EC%A0%95-%EC%B4%9D%EC%A0%95%EB%A6%AC.html",
            "date": " • Apr 19, 2022"
        }
        
    
  
    
        ,"post11": {
            "title": "강의) 제이슨 SQL 기본 강의",
            "content": "복습 정리본 . 해석 보고싶은 것을 f어떤 테이블(j)에서 w조건으로 보는데 | g그루핑한다면 h어떤조건으로 볼건지 정하고 | s어떤 데이터를 볼 것인지 정한다. | 보는 데이터를 o어떤순서로, l몇개 볼 것인지도 정해준다. | 문제 해석은 수식어는 join될, fk가진 테이블 속 재료 / 명사가 먼저 찾을 테이블속 재료로 먼저 찾는다. | | 문제1 풀이 첫번째 재료를 어떤테이블에서 어떤조건으로... 어떤 데이터를 볼 지 정해서 찾는다. 탐색용 select *에는 항상 limit 100을 붙여서 탐색하자. | . | 첫번째 재료에 달린 조건 속 숨은 재료도 첫번째 재료가 담긴 테이블에 없다면, 첫번째 재료 테이블에 연결될 수 있게 fk_id가지면서, 숨은 재료를 가진 테이블을 찾는다.(연결 재료는 조건이 +1) my) 첫재료테이블id를 fk로 가지는지부터 확인해서 필터링하자 | 첫번째 재료가 포함된 테이블명_id를 기억해서 fk로 가진 테이블만 연결된다는 것을 생각하자. | 연결된 재료 찾기는 연결될 재료 뿐만 아니라 연결에 필요한 첫번째 재료의 테이블_id(fk)까지 필요하여, 조건이 2개가 필요한 것이 차이점이다. | . | 연결에 필요한 첫재료테이블_id -&gt; join을 통해 -&gt; 첫재료자체로 연결하여 변환할 수 있다. fk자리를 join연결을 통해 첫재료로 바꿔볼 수 있다.(ProductId -&gt; ProductName)의 새로운 관점 | 실제 join은 fk테이블(다)에 자리바꿔들어가는게 아니라, PK테이블(일)에 left로 꽂는다. left로 꽂으면서 첫재료의 데이터가 (다)로 늘어나는데, fk테이블은 꽂으면서 fk를 PK테이블의 원하는 데이터 중 1개로 대체한다는 관점으로 가져가보자 | . | 연결조건을 갖춰 연결하여 fk를 통해 left에 꽂아 연결한 뒤, 원하는 데이터로 대체해서 볼 수 있지만, 1:1관계가 아닌 이상 1 &lt;- m을 갖다 꼽았다면, 꽂임 당한 PK테이블 쪽은 없던 중복이 생길 수 밖에 없다 꽂힘 당하면서 중복이 생긴 PK테이블은 select에서 id를 distint()를 걸어 중복제거후 count()를 씌워 갯수를 확인한다. (고객이) 상품(목적어m)을 주문(동사, 1)한다. -&gt; 주문:상품 = 1:m관계 반대로, 1상품이 여러개의 주문에 들어갈 수 도 있으니 m:n관계다. 어디든 m이 꽂히는 입장이니, 중복은 생긴다. | . | 주로 fk를 가진 m이 꽂히며 -&gt; join결과 1쪽에 대해 중복이 발생한 상태이다. 1주문당 m이꽂히므로, 주문갯수 n x 꽂힌 m 상품이 총 데이터 갯수다. 주문당 여러개란 뜻이지 항상 m개를 가지고 있지 않으므로 그만큼 많이 중복?! | . | join후 1(PK)에 생긴 중복을 고려해서 select에서 id를 distinct로 중복제거하여 실제 사용된 데이터 갯수를 준비를 하자 | . | distinct(pk.id)는 첫재료(1)쪽의 사용된 갯수 확인일 뿐이다. 연결된 중복 데이터에 대해 집계하여 중복제거를 하기 위해서는 group by + 집계함수로 해야한다. 이 때, 1쪽에 대한 group by는 원본재료의 id를 통해하는 것이다.필요한 재료는 select절에서 id이후 1쪽은 나열, m쪽은 집계해서 가져온다. id를 통해 groupby 집계해놓고, 거기에 select절에서는 id기본 + 타 컬럼정보를 가져다가 1쪽은 어차피 중복제거되었으니 나열, m쪽은 집계할 수 있다. | m쪽을 집계안하면? 첫번째 데이터만 올라오니 조심 m쪽을 집계안하고, 1쪽처럼 나열만 한경우 | 1쪽은 나열, m쪽은 집계한 경우 | . | . | m쪽 집계까지 끝난 뒤에야, having으로 m쪽 집계한 메서드를 그대로 가져와 조건을 걸어준다. having의 작성은 groupby -&gt; select 1id, 1칼럼나열, m집계 -&gt; m집계에 대해 조건순이지만 | having의 실제 실행은 select이후이므로 select에서 작성한 AS는 사용불가이다. select에서 준 m집계함수를 그대로 having에 걸어줘야한다. | . | join후 집계, 집계조건 걸기까지 끝난 뒤, 순서없는 것에 대해 order by/limit 등을 걸어준다. order by는 m집계함수를 그대로 걸어줘도 되지만 | select이후라서 alias를 걸어줘도 된다. | . | alias주는 리팩토링 from 에 걸린 대문자TABLE에 대해 AS 소문자로 alias를 준다. | 대문자로 쓰였던 TABLE_NAME들을 소문자alias로 교체한다. | select에서 준 소문자 칼럼alias는 having까지는 못준다. order by에서는 집계함수라도 alias로 줄 수 있다. | | select c.CustomerId as &quot;고객ID&quot;, c.CustomerName as &quot;고객이름&quot;, sum(od.Quantity) as &quot;총 주문횟수&quot; from Customers c left join Orders o on c.CustomerId = o.CustomerId left join OrderDetails od on o.OrderId = od.OrderId group by c.CustomerId order by sum(od.Quantity) desc; . | 문제2 풀이 customer(1) &lt;- Orders(n) &lt;- OrderDetails(m)을 join해놨어도, 중복이 n x m으로 생긴 customer에 대해 id로 group by하더라도 customer에 대해서만 하면 된다. Orders x OrderDetails(n x m)에 대해 집계하면 집계메서드에 의해 다 모이게 되어있다. Orders는 OrderDetails에 대해 집계로 중복제거 안해도 되나? -&gt; 목표가 고객별 집계니까,, 알아서 다 집계된다. 목표가 고객별/주문별 집계가 아니라는 점을 인식하자. | . | m:1 관계에서 fk를 가진 m에다가 pk - 1쪽의 데이터를 left join할 수 있다. Customers(1) &lt;- Orders(k-830) &lt;- OrderDetails(n-2155, Quantity) &lt;- Products(1, prices) 필요재료는 총 구매금액 = quantity * prices을 customers별 집계해야한다. | . | 이 경우, join을 받는 m쪽에 데이터 중복이 안생기고 row 당 1개 정보만 추가된다. | my) left join을 받는 쪽은 받는 쪽 row 1개당 정보가 추가되는데 보통은 1(PK)쪽에 &lt;— M(fk)를 left join으로 박아서, row 1개당 대략 m개의 데이터 중복이 생긴다고 생각한다. 다른 의미로는 m(fk)테이블 쪽에 있는 fk(pk_id)대신 (join된 테이블에서) pk테이블의 칼럼 중 택하여 정보를 바꿔 볼 수 있다. pk테이블의 칼럼 기반으로 나열하여 집계 + fk테이블(m)은 집계메서드하여 살펴볼 수 있다. | . | 연결하다보니 M(fk) &lt;— 1(PK)를 **left join으로 박아서, (m쪽이지만) row 1개당 중복없이 1개의 정보 추가만 발생한다고 생각하자. my) left join을 fk(연결당할 놈이 fk를 가지고 있는 경우) &lt;— (연결할 놈이지만 fk를 안가지고 있는)pk방향으로 하는 것은 row 1개당 1:1로 추가정보만 1개 더 추가한다고 생각하자. | . | | my) fk를 안들고 있는데 연결해야한다? -&gt; 최초 박힘의 테이블 or fk는 없지만, fk있는 곳에 1row당 1개 정보를 제공해주는 테이블 | my) 현재 테이블이 fk를 들고 있다면, m &lt;- 1 left join을 통해서 pk테이블로, fk를 들고 있는 현재 테이블에 row당 1개 정보 를 제공한다. ex&gt; 고객의 주문정보들(fk_productId) &lt;— (productId) 1row당 상품정보(prices)를 중복없이 정보만 제공 | . | my) 1쪽을 두고 m(fk)를 박아야, group by시 id로 해놓고, 1쪽칼럼은 나열 vs m쪽칼럼은 집계를 편하게 할 수 있을 것 같다. select c.CustomerId, c.CustomerName AS name, sum(od.Quantity * p.price) AS total from Customers c left join Orders o on c.CustomerId = o.CustomerId left join OrderDetails od on o.OrderId = od.OrderId left join Products p on od.ProductId = p.ProductId group by c.CustomerId order by total desc . | . | | SQL . update . where을 안주면 테이블 전체가 바뀐다. . . | . distinct 와 groupby로 중복제거 . distinct : 종류별로 1개만 남기도록 중복제거 . . | group by 로 인해 그루핑으로 기준칼럼별 중복제거된 데이터로 보기가 편해진다 . select이니까 결국엔 보이는 중복만 제거하지만, 같은 그룹기준별로 보여주니 그룹기준칼럼이 종류별로 1개가 되는 점 + 그 1개에 대한 여러 중복데이터들은 필요시 강제집계을 이용하는 것이다. | 원래 그룹바이는 1000000개의 데이터를 보기 편하게 묶어서 보기위함이다. 그 과정에서 그룹의 기준이되는 칼럼은 중복이 제거되어 1개가 된다. | . | . | group by이 궁극적인 목적은 기준칼럼의 중복제거가 아니라 -&gt; 중복제거된 기준칼럼에 속하는 단일 or 여러데이터들의 집계가 목적이다 . . | having으로 그루핑한 상태에서 where를 걸 수 있다. . | select(셀렉)시 limit 100, limit 1000을 버릇화해야한다. . order by | limit 체스게임 같은 경우, 생성날짜가 있다면 orderby limit1을 적용할 수 있다. | . | . | . select(쎌렉!) . 보는 순서 . . from부터 where, group by, having까지 내려가되, select한 뒤 order by+limit . . from 부터 볼 건데 join이 올 수 도 있다. . | where로 조건을 줘서 어떤 범위들을 볼 지 조건으로 지정하고 | group by로 그룹별로 묶어서 보고 | having 그룹 중 어떤 그룹을 볼지 조건으로 지정하고 . | f(j)-w/g-h으로 만들어진 데이터 중 select으로 어떤 데이터만 골라서 볼 것이며 . | select이후 order by, limit으로 어떤 정렬로, 얼만큼 짤라 볼 것인지 지정한다 | 쎌렉이 제일 마지막 같지만, 5.쏄렉에서 지정한 alias를 -&gt; 6. order by + limit에서 사용할 수 있다. -&gt; where은 fw gh 다음 select이라 select의 별칭이 안먹힌다 . sql해석방법 . from부터 내려가면서 [어떤 테이블f에 어떤범위w로부터 그룹핑g을 한다면, 어떻 그룹h을 골라볼 것인지 정해지면 -&gt; 어떤데이터s만 골라서 볼지 정한 뒤 -&gt; 그 데이터를 어떻게 정렬orderby하고 어떻게 짜를limit 것인지는 [쎌렉이후 칼럼선택 + alias주고] 본다 . 해석시 쎌렉은 fw-gh- 다음인줄알았는데, 직접 작성시에는 groupby까지하고 쎌렉에 집계메서드로 집계해놓고 -&gt; 그대로 칼럼처럼 가져와 having에 조건을 추가한다. . 심지어 order by에서도 쎌렉에 있는 [[집계칼럼메서드를 칼럼]]으로 그대로 가져다 쓴다. . 주의! 작성은 쎌렉 집계후 having에서 갖다썼지만, 실행은 having후 쎌렉이라서-&gt; having절(+where절)에 쎌렉alias못쓴다! . . 실습 . 실습 사이트 w3schools: https://www.w3schools.com/sql/trymysql.asp?filename=trysql_func_mysql_concat | . 주의점: 서브쿼리X + innerjon외 left or right 1개만 섞을 것 . 문제1 . 1. 200개 이상 팔린 상품명과 그 수량을 수량 기준 내림차순으로 보여주세요. | . 풀이1 . # 1. 200개 이상 팔린 상품명과 그 수량을 수량 기준 내림차순으로 보여주세요. ## 1-1. 재료가 일단 어디있는지, 재료가 속한 &lt;테이블&gt; 찾는다. [상품명] -&gt; [수량] 단독 재료같지만, [상품명] 앞에 200개 이상 팔린 -&gt; (연결된 조건재료)에 속한다. ## [상품명]은 왠지 Products테이블에 있을 것 같다 -- select * from Products; -- 지금은 77개 밖이지만, 테이블 전체데이터 쎌렉시 limit 100, 1000을 고려하자 -- * from Products limit 100; ## ProductName의 [상품명]이 있는 테이블을 찾았다. ## 1-2. [재료:상품명]에 (수식어)가 있으니 ([재료]와 연결된=찾은테이블+Id를 Fk로 가져 연결이 가능한 (조건 연결재료))로서 (200개 이상 팔린)의 (주문량,팔린량)을 가진 &lt;테이블&gt;을 찾아야한다. ## (팔린) -&gt; 주문과 관련있는 것 같아서 &lt;Orders&gt;테이블을 조회해본다. -- select * from Orders limit 100; -- OrderID CustomerID EmployeeID OrderDate ShipperID ## 뭐야 (팔린량,주문량)도 없고 [상품명과 연결될 ProductId]도 안가지고 있다. ## my) 추가정보를 얻기 위해선 ## 다시 테이블을 보니, &lt;OrderDetails&gt;가 있다. -- select * from OrderDetails limit 100; -- OrderDetailID OrderID ProductID Quantity -- 1 10248 11 12 -- 2 10248 42 10 -- 3 10248 72 5 ## 여기에 [상품명]과 연결시켜주는 [ProductID]와 + (주문량, 팔린량 Quantity)가 동시에 있다. ## my) 수식어, 조건 재료를 찾을 때는 (수식재료) 뿐만 아니라 [원본재료의 테이블과 연결된 원본재료테이블ID]도 가지고 있어야한다. ## FK인 ProductId는, Product테이블입장에서 [상품명]을 대표하는 그야말로 Id이므로, ## -&gt; (연결재료)찾을 시 [FK테이블+ID]의 FK자체를 -&gt; [연결된 기존재료]로 해석해도 된다. ## --&gt; [FK 테이블Id]를 [상품명]등 [재료]로 바꿔보기위해선 join이 필요한 것 -- OrderID ProductID Quantity -- 10248 11 12 ## ex&gt; ProductId(FK)가 11인 것은 주문량이 12다 ## = [해당 11번 상품명]은 12개 팔렸다 ## -&gt; join으로 연결해서보면 [11번 상품명] [주문량 12개 팔림]으로 보인다. ## 1-3. 재료들을 다 찾았다면, join해서 보는 것으로 결정낸다. ## -&gt; join시 on자리에 &lt;기존테이블&gt;.[기존재료]의PK_ID - &lt;연결재료테이블&gt;.(연결 재료)를 찾을 때 보이던 [FK_id]로 연결해주면 된다. select * from Products inner join OrderDetails on Products.ProductId = OrderDetails.ProductID; ## 이 때, Products &gt;- Orders : (고객이) 상품을 주문한다 -&gt; 주문:상품 = 1:m 관계다. ## -&gt; 1주문당 여러개의 상품을 가질 수있으며 -&gt; 주문들을 모아놓은 테이블은, 각 주문마다의 상품들이 겹칠 수 밖에 없다. ## 즉, 1:m 을 join했다면, 1(주문량, 상품FK)에서 m에 있는 정보(상품명 with 상품PK)를 얻기위해 붙인 것으로 [중복이 발생할 수 밖에] 없다 . ## 2. 재료들을 합친 상태라면, 이제 (조건재료)속 조건 or 요구사항을 만족시켜줘야한다. -- select * from Products -- inner join OrderDetails on Products.ProductId = OrderDetails.ProductID; ## 2-1. (200개 이상 팔린) [상품명]의 (요구사항)은 어떻게 처리? ## 2-2. 1:m의 join에서 1order당 mProduct명 -&gt; n order : n x m Product -&gt; n X m개의 row속에 중복이 무조건 존재한다. ## -&gt; 일단 m쪽에서 제공해준 FK을 [[ 쎌렉 distinct( FK ) ]]로 중복제외한 종류별로 1개씩이라면 총 몇개가 사용됬는지 확인한다. ## -&gt; on에 걸린 아무FK or PK를 가져와서 쎌렉으로 복붙해서 * 대신 -&gt; distinct( FK )를 넣어준다 ## --&gt; 1쪽인 order도 자기가 가졌던 m개의 product에 대해 모두 같은 orderId를 가져 중복이 된다. ## --&gt; 1쪽은 1:m으로 1order라도, m쪽에서 본다면, m개의 order를 가지게 되는 것. ## my) 1:m에서 1개 데이터라도 m입장에서는 기본 m개 중복이네! ## my) 오히려 1입장에서 1개 데이터라면, m은 중복없기 수량칼럼을 가질 듯. ## my) 1:m은 join전에는 m이 미중복, 1은 m개만큼 중복 -&gt; [[1개 데이터일 땐 미중복 m개의 데이터]] join후 [[1이었떤 order가 늘어남에 따라 m에서도 중복이 생길 가능성이 높아진다]] ## 2-3. &lt;&lt;distinct()&gt;&gt;로 [join전 1개 order에 대해 미중복이던 m쪽 Product]가 join후 중복됬는데, ## &lt;&lt; join으로 생긴 중복들 속에 [[ 실제 사용된 m쪽의 데이터]]는?&gt;&gt; by &lt;&lt;distinct( on에 걸려있는 m의 FK)&gt;&gt; -- select * from Products -- 2155 -- inner join OrderDetails on Products.ProductId = OrderDetails.ProductID; -- 77 : 중복이 발생한 m Product 중에 실제로는 77종류(distinct종류별 1개씩이니)만 사용되었다. select distinct(Products.ProductId) from Products inner join OrderDetails on Products.ProductId = OrderDetails.ProductID; . # 3. join후 생긴 m쪽 Product가 중복된 상황에서 (77개 -&gt; 2155개 데이터로 중복된 상태) ## - cf) 1쪽 Order는 1개의 order에 대해 m개의 OrderId가 동일한 중복상태 -&gt; join하더라도, order의 갯수만큼만 distinct함. ## - my) 1쪽은 join시, 달라붙는 order만 추가되고 매번 그 안의 m개 Product에 대해 중복이므로, -&gt; Order의 row수 == join시 distinct()한 orderId수 동일함. ## - my) m쪽은 1order시 중복없다가, join시 중복이 발생할 가능성이 있으니 [[m쪽만 중복을 필수 확인]]해야함. -- select distinct(Products.ProductId) -- from Products -- inner join OrderDetails -- on Products.ProductId = OrderDetails.ProductID; ## 3-1 요구사항을 보면 (200개 이상 팔린) [상품명] -&gt; 중복가능성이 있는 m쪽이므로 ## -&gt; distinct가 아닌 [[m쪽의 Id로 groupby]]해서 중복을 제거와 함께 집게해야 [수량]을 판단할 수 있게 된다. select * from Products inner join OrderDetails on Products.ProductId = OrderDetails.ProductID group by Products.ProductID; -- 77; -- Number of Records: 77 ## (m쪽id)로 groupby하여 집계를 하면, distinct(m쪽Id)한 것과 동일한 갯수가 나온다 -&gt; 집계로 중복제거 #### 근데 집계함수를 안쓰고 group by 만 상태 -&gt; distinct하기만 하고 집계는 안되어있는 상태다! #### -&gt; group by는 되어있는데, 첫데이터만 대표로 내어놓은 상태 . # 4. 집계준비가 되었다면, 쎌렉에서 집계한다. ## 현재 [group by 재료ID]로 -&gt; [ distinct한 mProduct별로 집계된 데이터] &amp;&amp; 쎌렉에서 집계는 안해줬다면, 첫데이터만.. ## 4-1. 일단 쎌렉절에 각 테이블에서 가져온 [재료]들과 그 [ID]까지 쎌렉해야한다. group by는 id로 하는 것이다. ## -&gt; &lt;타테이블&gt;.(연결재료)는 꼭 ID가 없어도 되긴한다. ## -&gt; 마지막으로 집계(연결재료) 등 집계대상을 집계해준다. ## --&gt; &lt;해당테이블&gt;.[재료ID] &lt;해당테이블&gt;.[재료(상품명)] &lt;타테이블&gt;.(연결재료) ## --&gt; &lt;해당테이블&gt;.[재료ID] &lt;해당테이블&gt;.[재료(상품명)] sum ( &lt;타테이블&gt;.(연결재료) ) -- select * -- select Products.ProductID, Products.ProductName, OrderDetails.Quantity select Products.ProductID, Products.ProductName, sum( OrderDetails.Quantity ) from Products inner join OrderDetails on Products.ProductId = OrderDetails.ProductID group by Products.ProductID; -- Number of Records: 77 -- ProductID ProductName sum( OrderDetails.Quantity ) -- 1 Chais 828 -- 2 Chang 1057 -- 3 Aniseed Syrup 328 . ## 4-2. 집계가 완료된 데이터에서 having을 건다. ## my) 해석시 쎌렉은 fw-gh- 다음인줄알았는데, 직접 작성시에는 groupby까지하고 쎌렉에 집계해놓고 -&gt; 그대로 가져와 having에 조건을 추가한다. ## -&gt; 쏄렉: sum( OrderDetails.Quantity ) -&gt; having : sum( OrderDetails.Quantity ) &gt;= 200 select Products.ProductID, Products.ProductName, sum( OrderDetails.Quantity ) from Products inner join OrderDetails on Products.ProductId = OrderDetails.ProductID group by Products.ProductID having sum( OrderDetails.Quantity ) &gt;= 200; . ## 4-3. 심지어 order by에서도 쎌렉에 있는 [[집계칼럼메서드를 칼럼]]으로 그대로 가져다 쓴다. select Products.ProductID, Products.ProductName, sum( OrderDetails.Quantity ) from Products inner join OrderDetails on Products.ProductId = OrderDetails.ProductID group by Products.ProductID having sum( OrderDetails.Quantity ) &gt;= 200 order by sum( OrderDetails.Quantity ) desc; . 쎌렉에 집계 alias 리팩토링 for order by, limit . ## 4-4. 이제 쎌렉을 가져다 쓰는 놈들(order by, limit ) 을 위해 [[ 쎌렉에 alias주는 리팩토링 ]] 하기 ## -&gt; 주의! 작성은 쎌렉후 having에서 갖다썼지만, 실행은 having후 쎌렉 -&gt; having절에 쎌렉alias못쓴다! ## 1) select 집계에 alias주기 -&gt; total ## 2) order by, limit에서 alias로 바꾸기 select Products.ProductID, Products.ProductName, sum( OrderDetails.Quantity ) as total from Products inner join OrderDetails on Products.ProductId = OrderDetails.ProductID group by Products.ProductID having sum( OrderDetails.Quantity ) &gt;= 200 order by total desc; . from(+join)에서 에만 테이블 as 소문자 별칭 -&gt; 이후 fw-gh-select까지 보이는 테이블 모두 alias주는 리팩토링 . ## 4-5. from(+join)에 주어지는 테이블의 대문자만 따서 alias로 주는 리팩토링 -&gt; fw-gh-s까지 다 리팩토링 가능해진다. ## from에만 as 소문자 -&gt; 그 뒤로는 테이블들 모조리 소문자로 변경 select p.ProductID, p.ProductName, sum( od.Quantity ) as total from Products as p inner join OrderDetails as od on p.ProductId = od.ProductID group by p.ProductID having sum( od.Quantity ) &gt;= 200 order by total desc; . 문제2 . 2. 많이 주문한 순으로 고객 리스트(ID, 고객명)를 구해주세요. (고객별 구매한 물품 총 갯수) | . 풀이2 . -- 후니 select c.CustomerID, c.CustomerName, sum(od.Quantity) total from Customers c join Orders o on c.CustomerID = o.CustomerID join OrderDetails od on o.OrderID = od.OrderID group by c.CustomerID order by total desc; -- 아리 SELECT Customers.CustomerID , Customers.CustomerName , SUB.Quantity FROM Customers JOIN (SELECT Orders.CustomerID AS ID , SUM(OrderDetails.Quantity) AS Quantity FROM Orders JOIN OrderDetails ON Orders.OrderID = OrderDetails.OrderID GROUP BY Orders.CustomerID ) AS SUB ON Customers.CustomerID = SUB.ID ORDER BY SUB.Quantity DESC; -- 아서 SELECT c.customerid &quot;고객 ID&quot;, c.customername &quot;고객 이름&quot;, sum(od.quantity) &quot;총 주문갯수&quot; FROM Customers c join Orders o ON c.customerid = o.customerid JOIN OrderDetails od ON o.orderid = od.orderid JOIN Products p ON p.productID = od.productId GROUP BY c.customerid ORDER BY SUM(od.quantity) DESC -- 필즈 SELECT c.CustomerId, c.CustomerName, od.orderQuantity FROM Orders o inner join ( SELECT OrderId, sum(Quantity) &quot;orderQuantity&quot; FROM OrderDetails group by OrderId ) od on o.OrderId = od.OrderId inner join Customers c on c.CustomerId = o.CustomerId order by orderQuantity desc ; -- 베루스 select c.CustomerId as ‘고객 아이디‘, c.CustomerName as ‘고객 이름‘, sum(od.Quantity) as ‘주문량’ from Customers as c left join Orders as o on c.CustomerId = o.CustomerId left join OrderDetails as od on o.OrderId = od.OrderId group by c.CustomerId order by sum(od.Quantity) desc -- 루키 SELECT Customers.CustomerID, Customers.CustomerName FROM Customers inner join Orders on Customers.CustomerID = Orders.CustomerID GROUP BY Customers.CustomerID ORDER BY COUNT(Orders.CustomerID) DESC; -- 유콩 SELECT Customers.CustomerID AS `고객아이디`, Customers.CustomerName AS `고객이름`, sum(Quantity) AS `주문량` FROM Orders JOIN OrderDetails ON Orders.OrderID = OrderDetails.OrderID RIGHT JOIN Customers ON Orders.CustomerID = Customers.CustomerID GROUP BY Customers.CustomerID ORDER BY `주문량` DESC; -- 케이 SELECT Orders.CustomerId, Customers.CustomerName, sum(Quantity) FROM OrderDetails join Orders on OrderDetails.OrderId = Orders.OrderId join Customers on Orders.CustomerId = Customers.CustomerId group by Customers.CustomerName order by sum(Quantity) desc -- 배카 . 문제3 . 3. 많은 돈을 지출한 순으로 고객 리스트를 구해주세요. | . 풀이3 . -- 아서 SELECT c.customerid &quot;고객 ID&quot;, c.customername &quot;고객 이름&quot;, sum(od.quantity * p.price) &quot;총 주문가격&quot; FROM Customers c join Orders o ON c.customerid = o.customerid JOIN OrderDetails od ON o.orderid = od.orderid JOIN Products p ON p.productID = od.productId GROUP BY c.customerid ORDER BY SUM(od.quantity * p.price) DESC -- 케이 SELECT Orders.CustomerId, Customers.CustomerName, sum(Quantity*Price) FROM OrderDetails join Orders on OrderDetails.OrderId = Orders.OrderId join Customers on Orders.CustomerId = Customers.CustomerId join Products on OrderDetails.ProductId = Products.ProductId group by Customers.CustomerName order by sum(Price*Quantity) desc -- 베루스 select c.CustomerId as ‘고객 아이디‘, c.CustomerName as ‘고객 이름‘, sum(od.Quantity*p.Price) as ‘지출액’ from Customers as c left join Orders as o on c.CustomerId = o.CustomerId left join OrderDetails as od on o.OrderId = od.OrderId left join Products as p on od.ProductId = p.ProductId group by c.CustomerId order by sum(od.Quantity*p.Price) desc -- 디우 select Customers.CustomerID, Customers.CustomerName, sum(OrderDetails.Quantity * Products.price) from Customers, OrderDetails, Orders, Products where Customers.CustomerID = Orders.CustomerID AND OrderDetails.OrderID = Orders.OrderID AND Products.ProductID = OrderDetails.ProductID group by Customers.CustomerID order by sum(OrderDetails.Quantity * Products.price) desc; -- 후니 SELECT c.CustomerID, c.CustomerName, (p.Price * od.Quantity) total FROM Customers c join Orders o on c.CustomerID = o.CustomerID join OrderDetails od on o.OrderID = od.OrderID join Products p on od.ProductID = p.ProductID order by total desc; -- 코린 select c.CustomerID, c.CustomerName, sum(od.Quantity * p.price) as total_price from Orders o join OrderDetails od on o.OrderID = od.OrderId join Customers c on o.CustomerID = c.CustomerID join Products p on od.ProductId = p.ProductId group by c.CustomerID order by total_price desc; -- 이프 select c.CustomerID, c.CustomerName, sum(od.Quantity * p.Price) as total from Customers as c join Orders as o on c.CustomerID = o.CustomerID join OrderDetails as od on o.OrderID = od.OrderID join Products as p on p.ProductID = od.ProductID group by c.CustomerID order by total desc -- 루키 SELECT Customers.CustomerName FROM Customers INNER JOIN Orders ON Customers.CustomerID = Orders.CustomerID INNER JOIN OrderDetails ON Orders.OrderID = OrderDetails.OrderID INNER JOIN Products ON Products.ProductID = OrderDetails.ProductID GROUP BY Customers.CustomerID ORDER BY SUM(OrderDetails.Quantity * Products.price) DESC; -- 더즈 select c.CustomerId, sum(p.Price) as &#39;총지출&#39; from Customers c inner join Orders o on c.CustomerId = o.CustomerId inner join OrderDetails od on od.OrderId = o.OrderId inner join Products p on p.ProductId = od.ProductId group by c.CustomerId order by sum(p.Price) desc; -- 필즈 SELECT c.CustomerId, c.CustomerName, od.quantity * p.price &quot;orderPrice&quot; FROM Customers c inner join Orders o on c.CustomerId = o.CustomerId inner join OrderDetails od on o.OrderId = od.OrderId inner join Products p on od.ProductId = p.ProductId order by orderPrice desc; -- 유콩 SELECT Customers.CustomerID AS `고객아이디`, Customers.CustomerName AS `고객이름`, sum(Price * Quantity) AS `지출금액` FROM Orders JOIN OrderDetails ON Orders.OrderID = OrderDetails.OrderID JOIN Products ON OrderDetails.ProductID = Products.ProductID RIGHT JOIN Customers ON Orders.CustomerID = Customers.CustomerID GROUP BY Customers.CustomerID ORDER BY `지출금액` DESC; -- 썬 select c.CustomerID, c.CustomerName, sum(od.quantity * p.price) as price_total from Customers c inner join Orders o on c.CustomerID = o.CustomerID inner join OrderDetails od on o.OrderID = od.OrderID inner join Products p on p.ProductID = od.ProductID group by c.CustomerID order by price_total desc; -- 수달 select c.CustomerName as &#39;고객명&#39;, sum(d.Quantity * p.price) as &#39;지출금액&#39; from Customers c inner join Orders o on c.CustomerID = o.CustomerId join OrderDetails d on o.OrderID = d.OrderId join Products p on d.ProductID = p.ProductID group by c.CustomerID having sum(p.price * d.Quantity) order by sum(p.price * d.Quantity) desc; -- 릭 SELECT c.CustomerID AS `ID`, c.CustomerName AS `고객명` FROM Customers AS c INNER JOIN Orders AS o ON c.CustomerID = o.CustomerID GROUP BY o.CustomerID ORDER BY SUM(o.CustomerID) DESC; -- 연로그 select c.CustomerID , c.CustomerName , sum(p.Price * od.Quantity) total from Customers c join Orders o on o.CustomerID = c.CustomerID join OrderDetails od on o.OrderID = od.OrderID join Products p on p.ProductID = od.ProductID group by c.CustomerID order by total desc; -- 봄 SELECT c.customerId, c.customerName, sum(p.price * od.quantity) as total FROM Customers as c JOIN Orders as o ON c.customerId = o.customerId JOIN OrderDetails as od ON o.orderId = od.orderId JOIN Products as p ON od.productId = p.productId GROUP BY c.customerId ORDER BY total DESC; -- 라라 select c.CustomerID, c.CustomerName, sum(p.Price * od.Quantity) as total from Customers as c inner join Orders as o on c.CustomerID = o.CustomerID inner join OrderDetails as od on od.OrderId = o.OrderId inner join Products as p on p.ProductId = od.ProductId group by c.CustomerID order by total desc .",
            "url": "blog.chojaeseong.com/sql/jason/%EC%9A%B0%ED%85%8C%EC%BD%94/%EA%B0%95%EC%9D%98/2022/04/05/%EC%A0%9C%EC%9D%B4%EC%8A%A8-sql%ED%95%B4%EC%84%9D-%EA%B0%95%EC%9D%98.html",
            "relUrl": "/sql/jason/%EC%9A%B0%ED%85%8C%EC%BD%94/%EA%B0%95%EC%9D%98/2022/04/05/%EC%A0%9C%EC%9D%B4%EC%8A%A8-sql%ED%95%B4%EC%84%9D-%EA%B0%95%EC%9D%98.html",
            "date": " • Apr 5, 2022"
        }
        
    
  
    
        ,"post12": {
            "title": "while 반복문 -> 재귀함수 변환",
            "content": "반복문(while) to 재귀 . 01 while문 내부 전체로직을 1개메서드로 추출 . . public void run() { final PairProgram pairProgram = new PairProgram(); while (!pairProgram.isOff()) { final Menu menu = Menu.from(inputView.inputMenu()); menu.execute(inputView, outputView, pairProgram); } } . . public void run() { final PairProgram pairProgram = new PairProgram(); while (!pairProgram.isOff()) { start(pairProgram); } } private void start(final PairProgram pairProgram) { final Menu menu = Menu.from(inputView.inputMenu()); menu.execute(inputView, outputView, pairProgram); } . 02 while문을 벗겨내고, 반복되도록 마지막에 한번더 호출한다.(필요연산이 있다면, 재귀함수 파라미터 속에서 변수와 함께) . . public void run() { final PairProgram pairProgram = new PairProgram(); // while (!pairProgram.isOff()) { start(pairProgram); // } } private void start(final PairProgram pairProgram) { final Menu menu = Menu.from(inputView.inputMenu()); menu.execute(inputView, outputView, pairProgram); start(pairProgram); } . 03 while문의 ! 탈출조건을 -&gt; 재귀함수 맨위의 종착역으로서 if 탈출조건 early return;으로 지정해준다. . . public void run() { final PairProgram pairProgram = new PairProgram(); // while (!pairProgram.isOff()) { start(pairProgram); // } } private void start(final PairProgram pairProgram) { if (pairProgram.isOff()) { return; } final Menu menu = Menu.from(inputView.inputMenu()); menu.execute(inputView, outputView, pairProgram); start(pairProgram); } . 04 에러발생시 다시시작하고 싶은 부분(입력부분)부터 try{}로 째려보게 한다. -&gt; 에러안나도 재귀함수는 flag에 걸리기전까지 반복해야하므로 재귀호출부까지 다 째려본다 . . . private void start(final PairProgram pairProgram) { if (pairProgram.isOff()) { return; } try { final Menu menu = Menu.from(inputView.inputMenu()); menu.execute(inputView, outputView, pairProgram); start(pairProgram); } catch (Exception e) { System.out.println(&quot;[ERROR]&quot; + e.getMessage()); start(pairProgram); } } . . 꼬리재귀 . 참고블로그 | . 재귀 사용 이유 . 반복문보다 가독성이 좋다 f(n) = f(n - 1) + f(n - 2) ) : f(n)을 구하기 위해선 f(n - 1), f(n - 2)라는 자기자신의 함수를 인자만 바꾸고 다시 호출해야 한다. | . | 변수가 줄어들어 -&gt; 사이드이펙트가 줄어든다. | 가독성 = 유지보수비용 &gt; 성능유지비용 | 꼬리재귀를 사용하면, 단점인 스택오버플로우를 방지할 수 있다. 실행할 작업을 없애 함수 호출 위치를 저장하지 않도록하여 스택이 넘치는 경우를 방지 | 파일 옵션에서 코드 최적화가 되도록 설정해 주어야 한다. | 꼬리 재귀는 결국 반복문 실행이기 때문에 일반 재귀 함수에서 발생하는 스택 오버 플로우나 성능저하가 발생하지 않는다. | . | 연산을 재귀함수의 인자에서만시행하여 재귀의 업데이트되는 상태변수(count, n)의 시작값 뿐만 아니라 누적연산 등 연산의 초기값도 같이 가져간다. | . | 재귀 작성법 . base case를 input을 0 또는1과 관련지어서 생각한다. . 문제에서 주어진 요구사항 및 예시를 무시하고 0 또는 1과 관련지어서 생각하자 . 예시로 주어진 인풋값을 보고, 어떻게 이걸 답으로 만들지? 라고 생각하면 안 된다. 자꾸 함수 실행 순서를 생각하게 되기 때문이다. | 최대한 재귀적으로 생각하지 않고, 마치 1차원 문제인 것처럼 푸는 게 우리 전략이다. | . 이 때 가장 간단한 인풋값은 0 혹은 1인 경우가 많다. 만약 정수 타입이 들어온다면, 인풋이 0이나 1인 상황을 생각해보자. 만약 배열이 들어온다면? 그러면 배열의 길이가 0인 경우(빈 배열), 배열의 길이가 1인 경우를 생각해보자. 만약 트리가 들어온다면? 인풋값이 nil인 경우, 혹은 자식 노드가 nil(잎 노드)인 경우를 생각해보자. 만약 인풋값이 2차원이라면? 인풋값이 m x n 그리드 (이차원 배열)이라면, 둘 다 0이거나 (m = 0, n = 0), 둘 중 하나가 1이거나 (m = 0, n = 1) (m = 1, n = 0) 둘 다 1인 (m=1, n=1) 케이스를 생각해보자. 0과 1을 사용한 인풋값이 들어왔을 때 즉각 답을 구할 수 있는가? 만약 YES라면, 그게 베이스 조건과, 베이스 조건에서의 결과값이 된다. . | . | 꼬리재귀 연습 . public class MyTest { //https://velog.io/@eddy_song/you-can-solve-recursion @DisplayName(&quot;&quot;) @Test void for_loop() { int sum = 0; // 0부터 100까지 누적합 for (int i = 0; i &lt;= 100; i++) { sum += i; } System.out.println(&quot;sum = &quot; + sum); } @DisplayName(&quot;&quot;) @Test void recursive() { //1. 재귀함수는 일단 메서드를 호출해서 실행하므로, 메서드부터 만든다. // -&gt; 기본적으로 인자는 시행횟수가 들어가서 +1, -1, /2 등으로 업데이트되서 다음 재귀를 호출한다. System.out.println(&quot;recursiveSum(100) = &quot; + recursiveSum(100)); } private int recursiveSum(final int n) { //1. 줄어들면서, input과 0과 1과 관련시켜 가장 간단한 base case를 찾아 문제를 풀어 return하기 // 0 -&gt; 0까지의 합 return 0 // 1 -&gt; 1까지의 합 return 0 + 1 // 2 -&gt; return 0 + 1 + 2 //2. base값에 가까운 윗단계로 input값 조정 후 input(n)과 관련지어 계산하기 // 3 -&gt; 0 + 1 + 2 + 3 = f(2) + n // 0 + 1 까지의 합에서 base는 n=0이 들어오는 경우이다. if (n == 0) { return 0; } return recursiveSum(n - 1) + n; } @DisplayName(&quot;&quot;) @Test void recursive_to_tail() { // recursiveSumByTail(100); //1. 연산(덧셈)의 초기값(0) 또한 파라미터로 건네주어, 인자내에서 연산 후 다음 재귀의 초기값으로 호출되게 한다. System.out.println(&quot;recursiveSumByTail(100, 0) = &quot; + recursiveSumByTail(100, 0)); } private int recursiveSumByTail(final int n, final int acc) { //2. 종착역에서 반환값이 있었다면, 꼬리재귀에서는 해당재귀호출()자체가 최종 값이 되므로 // -&gt; 최종값이 아니라-&gt; 연산의 결과 파라미터를 찍어주면 된다. // -&gt; 종착역에서 연산이 이루어지지 않고 [return 연산변수]로 끝나기 때문에, 종착역을 마지막연산n보다 1개 더갔을 때 연산변수를 반환하도록 한다. // if (n == 0) { // return 0; // return acc; // } // 종착역을 최종연산지점보다 1개 더 주어서 걸리게하고, 직전까지의 계산 = n최종지점까지의연산 의 결과인 acc를 return한다. if (n &lt; 0) { return acc; } return recursiveSumByTail(n - 1, acc + n); } @DisplayName(&quot;&quot;) @Test void zero_to_100_sum_by_tail() { //1. 꼬리재귀는 [횟수관련 초기값] + [연산관련 초기값] 모두를 가지고 들어간다. // - 0부터 시작하고, 덧셈의 초기값은 0이다 System.out.println(&quot;recursiveSumReverse(0, 0) = &quot; + recursiveSumReverse(0, 0)); } private int recursiveSumReverse(final int count, final int acc) { //2. basecase는 0,1과 관련지어서 input을 만들어 풀어주는데, 여기서 종착역은 99, 100이다. // -&gt; 꼬리재귀에서는 종착역을 최종지점(100)을 1단계 넘어서 지정해준다. // -&gt; 직전까지 = 최종지점(100)까지의 [파라미터에서 연산]한 결과물이 [오버지점 파라미터]로 들어왔을 것이니까 그것을 반환해준다. if (count &gt; 100) { return acc; } //3. 횟수변수 및 연산변수를 [파라미터에서 연산 하여 업데이트]해준다. // -&gt; 직전까지의 연산값 acc를 현재n번째 (count) 와 관련시켜 연산해주면 된다. return recursiveSumReverse(count + 1, acc + count); } } .",
            "url": "blog.chojaeseong.com/java/try/catch/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98/%EA%BC%AC%EB%A6%AC%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98/%EC%9E%AC%EC%9E%85%EB%A0%A5/%EC%B2%B4%EC%8A%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/04/%EB%B0%98%EB%B3%B5%EB%AC%B8(while)-to-%EC%9E%AC%EA%B7%80(%EA%BC%AC%EB%A6%AC%EB%AC%B4%EB%8A%94).html",
            "relUrl": "/java/try/catch/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98/%EA%BC%AC%EB%A6%AC%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98/%EC%9E%AC%EC%9E%85%EB%A0%A5/%EC%B2%B4%EC%8A%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/04/%EB%B0%98%EB%B3%B5%EB%AC%B8(while)-to-%EC%9E%AC%EA%B7%80(%EA%BC%AC%EB%A6%AC%EB%AC%B4%EB%8A%94).html",
            "date": " • Apr 4, 2022"
        }
        
    
  
    
        ,"post13": {
            "title": "generic 개인공부 2",
            "content": "참고 유튜브 | . 개념 . 모던 자바(5이후) 가장 대표적인 기술 2가지 제네릭 | 람다 하나 더 추가한다면, 애노테이션 | 애노테이션은 프레임워크 개발자, 라이브러리 개발자들이나 만들 것. 우리가 만들 일은 없다. | . | 코드 작성시 가장 많이 만지는 것 제네릭과 람다 | 잘 활용해야한다. | . | . | . 제네릭과 raw type . 제네릭 -&gt; 사실 타입 파라미터를 사용하면 제네릭이다~! | 제네릭 사용이유 .add() : 컴파일 시점에서, 컴파일에게 타입을 건네주어, 데이터 일관성 있게 모을 때, 정확하게 타입체킹한다. 타입정보를 안주면, List는 T자리에는 Object로 대체하여, 컴파일러가 타입체크를 못해준다. 컴파일러가 몰랐기 때문에, compile에러 대신 runtime시 에러가 난다. | 즉, runtime시에만 발생하는 버그(모은 데이터가 일광성이 없는 버그)를 미리 방지한다. | . | 해당 list에는 어떤 타입만 들어갈지 정해서, 일관성있게 코드를 작성해야하는데, 이런 부분을 도와준다. intellij 빨간줄 -&gt; compile에러 by 제네릭 | . | . | .get(): 1번에서 일관성 없게 모은 Object타입의 list라면? 꺼내서 사용할 때, 매번 다운캐스팅해야한다. 실수 할 수도 있음. 제네릭은 적절한 타입캐스팅(다운캐스팅)을 알아서 해준다. | . | 똑같은 코드 Type만 다른 class를 또 생성할 필요 없다 Type만 바꾼 class재사용이 가능해진다. | . | | raw Type 좁은 것을 타입 파라미터 없는 raw Type List에 할당해주는 것은 가능하지만 그 순간부터 가지고 있던 내용물의 Type을 잃어먹는다. | . | 다시 좁은 쪽으로 할당시키면, 일단 해당 타입 파라미터에 맞게 할당은 되지만 꺼내는 순간부터 가지고 있던 내용물 Type &lt;-&gt; 타입파라미터 타입이 달라 에러가 난다. | . | raw Type을 쓰지마라. 더불어, 컴파일시 Problems에 뜨는 워닝을 그냥 넘어가지마라. 워닝을 체크하고 Build &gt; Rebuild Project로 해결하면서 확인하자. | 상세하게 워닝을 보는 방법은 설정 &gt; java compiler &gt; 추가 파라미터 -&gt; 에러창에 나온 -Xlint등을 붙혀서 다시 컴파일한다. | . | . | . | raw Type으로 중간에 넣어도 컴파일 에러가 안나는 이유 . java 5 제네릭 이전의 코드는 모두 raw Type List이었기 때문에 . 개발자가 체크하고, 변환해서 사용해야한다. . | 개발자가 raw Type List를 좁은 곳으로 할당할 때 생기는 문제인 Unchecked assignment에서는 @SuppressWarning(“unchecked”)로 옛날 코드임을 명시해준다 . final List&lt;Integer&gt; ints = Arrays.asList(1, 2, 3); List rawInts = ints; // 3) 반대의 상황은? // -&gt; raw Type을 -&gt; 다시 변&lt;구&gt;제에 넣으면? @SuppressWarnings(&quot;unchecked&quot;) final List&lt;Integer&gt; ints2 = rawInts; . | . | . | . public class Generics { //2. staic main에 사용할 static 클래스를 만드는데, 클래스 옆에 &lt;T&gt; 뻐금괄호로 [타입파라미터]를 추가한다. // - 타입 파라미터는 type variable로 불린다. 내부에서 변수처럼 T t;로 쓸 수 있기 때문 static class Hello&lt;T&gt; { //6. Hello&lt;T&gt; class에 옆에 선언한 타입 파라미터에 매핑이 되어서 // -&gt; 클래스 내부에서는 1) 필드Type 2) 메서드 파라미터의 Type 3) 메서드 응답Type으로 사용되기도 한다. //new Hello&lt;String&gt;(); -&gt; //1) T t; //2) Object method(T t) {return null;} //3) &lt;T&gt; Obejct method(T t){return null}; } //3. 일반적인 (메서드)파라미터는 파라미터 자리에 신언 -&gt; 밖에서 해당Type의 input(값, 객체)를 넣어준다. static void print(String value) { System.out.println(value); } //1. main메서드 ps vm으로 만들기 public static void main(final String[] args) { //4. print(&quot;Generics&quot;); //5. 타입 파라미터에도 메서드 파라미터와 마찬가지로 실제 뭔가(타입)를 넣어주는데 [타입 인자]라고 한다. // -&gt; 실제 &lt;Type&gt;정보(타입 인자)를 타입 파라미터 T자리에 넣어주면 -&gt; 6. //new Hello&lt;String&gt;(); //type argument //7. 제네릭 사용이유 List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 1) 넣을 때, 컴파일 에러가 나서, 일관성있게 타입체킹을 해준다 //list.add(4) list.add(&quot;str&quot;); // 2) 꺼내서 사용할 때, 매번 다운캐스팅해야한다. 실수 할 수도 있음. //final String s = (String) list.get(0); final String s = list.get(0); //3) 타입만 바꿔서 class재사용이 가능해진다. //8. raw Type?! (구체형 지정했는데 타입파라미터 없이 변수로 받는 경우) // 1) 우항은 호.&lt;구&gt;.제를 해놨는데, -&gt; 변&lt;구&gt;제로 변환없이 -&gt; 좌측 변수는 제네릭 타입 없는 변수(raw Type)에 받는 경우 // -&gt; 괜찮다?! //new ArrayList&lt;Integer&gt;(); List rawList = new ArrayList&lt;Integer&gt;(); // 2) 호&lt;&gt;.구.지 -&gt; 변.&lt;구&gt;.제 를 -&gt; 다시 그대로 제네릭 타입 없는 변수(raw Type)에 할당하는 경우 // -&gt; 괜찮다?! final List&lt;Integer&gt; ints = Arrays.asList(1, 2, 3); List rawInts = ints; // 3) 반대의 상황은? // -&gt; raw Type을 -&gt; 다시 변&lt;구&gt;제에 넣으면? @SuppressWarnings(&quot;unchecked&quot;) final List&lt;Integer&gt; ints2 = rawInts; // Unchecked assignment: &#39;java.util.List&#39; to &#39;java.util.List&lt;java.lang.Integer&gt;&#39; // --&gt; raw Type으로 받는 순간, 다시 어떤 Type인지 모르는 상태가 된다. // --&gt; T상태를 다시 type argument가 있는 곳에 넣어줬으니, // --&gt; Object(우) -&gt; Integer(좌)로 캐스팅해서 넣는 것이다. // &gt; 위험하다. 만약 Object에 integer 들어있는 것을 List&lt;String&gt;에 캐스팅해서 넣으면... @SuppressWarnings(&quot;unchecked&quot;) final List&lt;String&gt; strs = rawInts; // raw type에 들어간 순간, 안에 내용물의 타입은 잊어먹고, 좁은 곳으로 캐스팅되서 들어갈 수 있게 된다. // -&gt; 문제는, type argument에 맞춰서 다운캐스팅되서 들어가 컴파일은 되지만, 꺼내올 때부터 문제가 된다. // --&gt; 내용물은 int, type은 final String s1 = strs.get(0); // class java.lang.Integer cannot be cast to class java.lang.String (java.lang.Integer and java.lang.String are in module java.base of loader &#39;bootstrap&#39;) // at Generics.main(Generics.java:67) } } . 제네릭 메서드 . 인스턴스 메서드 . | 스태틱 메서드 : class level type parameter꺼는 못씀 . class level의 type paramter는 인스턴스 생성시 class&lt;T&gt;의 T가 정해져 사용되기 때문 | . | 생성자 . public class GenericsMethod { //0. class 혹은 interface 옆에 타입파라미터가 붙어서 시작하는 경우도 있지만, static class Hello&lt;T&gt; { } //1. method에서도 타입 파라미터를 붙일 수 있다. // -&gt; String을 파라미터 받아서 출력했었지만 void print(String value) { System.out.println(value); } // --&gt; 이젠 어떤 타입이든 받아서 .toString()으로 출력하면 어떤 타입이든 다 출력된다. // --&gt; 이 때, class, interface옆에 &lt;T&gt;를 붙인 것처럼, [응답형 앞에 &lt;T&gt;를 붙여줘야한다.] &lt;T&gt; void print(T t) { System.out.println(t.toString()); } //3. static 메서드(인스턴스 안만들고 쓰는 메서드)에도 적용가능하다. static &lt;T&gt; void staticPrint(T t) { System.out.println(t.toString()); } //5. 주의!! // class&lt;T&gt; type variable은 -&gt; 해당 class의 인스턴스가 만들어질 때 인자를 받아오게 되는데 // -&gt; static은 인스턴스 만들지를 않고 사용하니, T를 모르는 상태 그대로 // -&gt; static 메서드는, 인스턴스생성때 T를 채우는 class level이 아닌, method level에서 Type parameter를 사용해야한다. // --&gt; class level type paramter로는 사용 불가능했던 static method는 // method level에서는 type paramter를 static method에서 사용 가능하다. //6. class level과 다르게 메서드 level type parameter를 지정하자. static &lt;S&gt; void staticPrint2(S s) { System.out.println(s.toString()); } //7. &lt;,&gt;로 2개 level(class, method)의 Type paramter를 섞어 쓸 수 있다. // -&gt; 1개는 class level, 1개는 method level일 것이다. // 1) method level에 정의한 타입파라미터 -&gt; 메서드 파라미터에서 사용 // 2) class level에 정의한 타입파라미터 -&gt; 메서드 응답형에서 사용 가능 &lt;S, T&gt; T staticPrint3(S s) { System.out.println(s.toString()); return null; } //8. method level 1) 인스턴스메서드 2) 스태틱메서드(new)에 추가로 // -&gt; 3) 생성자에서도 method level type paramter를 쓸 수 있다.(class level과 별개로) public GenericsMethod() {} // 생성자에서도 class level과 별개로 아무Type이나 받을 수 있다. // 생성자는 응답이 없으므로 생성자 메서드앞에 &lt;&gt;를 작성해주면 된다. public &lt;S&gt; GenericsMethod(S s) { } public static void main(final String[] args) { //2. 어떤 타입이든 받아서 출력되는지 확인해보자. new GenericsMethod().print(&quot;Hello&quot;); new GenericsMethod().print(1); //4. method level의 타입파라미터는 static method에도 적용가능하다 GenericsMethod.staticPrint(&quot;Hello&quot;); GenericsMethod.staticPrint(1L); } } . | Bounded Type paratmer : 내부 로직에 의해 제한이 필요한 Type paramter . 다양한 Type을 다 받을 수 있다 -&gt; generic한 method | 내부 알고리즘상 꼭 필요한 제약조건(Comparable을 구현한 Type만 들어와서 비교가능해야함)이 걸고 싶다 -&gt; bound type parameter | . public class GenericBounded { // 0. default로는 타입제한이 없은 &lt;T&gt;가 오지만 &lt;T extends List&gt; 등 // -&gt; Bounded Type parameter ? // 1. 인스턴스 or static(for main) 메서드에서도 쓸 수 있다. // -&gt; 변.&lt;구&gt;.제와 비슷하게, 메서드용 &lt;구체형&gt;제한은, 응답형 앞에 표기하는 &lt;T&gt;에서 해준다. //static &lt;T extends List&gt; void print(T t) {} // 2. bound제한을 줄 때, 1개만 할 수 있따 생각하지만, &amp; 1개로 여러개 형을 줄 수 있다. // -&gt; multiple bound ( 공통으로서 다 만족해야한다. OR옵션은 없다.) //static &lt;T extends List &amp; B &amp; C&gt; void print(T t) {} // -&gt; class가 올 경우는 1개만, interface는 여러개 구현하는 것처럼 여러개 가능 static &lt;T extends List &amp; Serializable &amp; Comparable &amp; Closeable&gt; void print(T t) { } //3. 예시) array + 기준값을 받아서, 기준값보다 큰 것의 갯수 구하기 // -&gt; 제네릭 사용하지 않고, Integer로 fix static long countGreaterThan(Integer[] arr, Integer elem) { return Arrays.stream(arr) .filter(s -&gt; s &gt; elem) .count(); } // 6. type만 다르니 generic method을 도입하자.(구체형 -&gt; T로 변경) // static &lt;T&gt; long genericCountGreaterThan(T[] arr, T elem) { // 10. 내부 비교로직이 들어가는 method level type paramter는 Comparable&lt;T&gt;로 구현한 Type으로 제한을 걸어줘야한다 // -&gt; 이제 genericCountGreaterThan() 인자는 comparable구현하여 비교가능한 애들만 넘어온다. // --&gt; cf) Comparable은 impl시 해당 class형을 제네릭파라미터를 받았었다. -&gt; 여기선 T static &lt;T extends Comparable&lt;T&gt;&gt; long genericCountGreaterThan(T[] arr, T elem) { return Arrays.stream(arr) // 7. 문자는 크기비교를 숫자Type만 가능한 부등호로 비교하고 있었다. //.filter(s -&gt; s &gt; elem) // 8. 숫자 이외에 더 일반적으로 &amp; Type(객체)의 순서를 비교(크기 비교)하려면 // - Comparable &lt;- 이 인터페이스를 작성해서 찾아 들어가서 확인도 같이해보자. //Comparable // - Comparable 구현후 -&gt; 내부 compareTo 라는 메서드를 구현해서 비교할 수 있지만. // - s는 T타입 이라서 .compareTo가 있는지 도 모른다는게 문제다 //.filter(s -&gt; s.compareTo(elem)) //9. 그렇다면 T타입은... 미리 좀 내부에서 Comparable을 구현해서 비교가 되는 놈으로 제한하자 // -&gt; type parameter를 (비교가능한 객체로) 제한하려면? -&gt; bounded type parameter를 쓰면 된다. //11. 이제 s가 bounded type parameter로서 comparable구현Type으로 보장되었다 // -&gt; compareTo가 사용가능하다. 이 return값은 int 1, 0, 1이니.. t/f가 아님을 조심하자. .filter(s -&gt; s.compareTo(elem) &gt; 0) .count(); } public static void main(final String[] args) { final Integer[] integers = {1, 2, 3, 4, 5, 6, 7}; System.out.println(&quot;countGreaterThan(integers, 4) = &quot; + countGreaterThan(integers, 4)); //4. 숫자말고, 다른Type인 문자도 크기 비교가 가능하다~ final String[] strings = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;}; //countGreaterThan(strings) -&gt; 구체형이 fix되어있으니 컴파일 에러 //5. generic 도입을 고민한다. //12. generic + 비교를 위한 bound type paramter가 적용이 끝났으면 사용해보자 // -&gt; string도 String을 찍어서 들어가보면, impl Comparabel&lt;String&gt;을 구현하고 있기 때문이다. System.out.println(&quot;genericCountGreaterThan(strings, &quot;3 &quot;) = &quot; + genericCountGreaterThan(strings, &quot;2&quot;)); } } . | 제네릭과 상속 . 타입 파라미터의 상속관계는, 제네릭 적용 class 상속관계에 아무 영향을 주지 않는다. . | 같은 추상체의 SubType(추상체가 가진 type paramter도 같으면)이면 . 구상체만의 type paramter는 달라고 할당된다. . static class MyList&lt;E, P&gt; implements List&lt;E&gt; {} // final List&lt;String&gt; s1 = new MyList&lt;String, Integer&gt;(); final List&lt;String&gt; s2 = new MyList&lt;String, String&gt;(); . | . | . 제네릭 타입 추론 . java 7이하는 type paramter를 추론 못하는 경우도 있을 수 있다. 이 때는 메서드 호출() 앞에 &lt;Type&gt;를 붙여준다. . | Collections.emptyList(); 같은 경우, 들어가는 parameter가 없기 때문에 추론이 안될 수 있다. -&gt; 메서드앞에 &lt;Type&gt;을 명시해준다. . //java 7이하 타입추론안될 때 명시해주기 final List&lt;String&gt; c = Collections.&lt;String&gt;emptyList(); . | . 제네릭과 와일드카드 . ?: wildcards -&gt; 모르고, 알필요도 없다. | T: 선언시점에서 T는 뭔지 모르지만, 타입 정해지면 그것으로 사용하겠따 . | &lt;?&gt; . &lt;? extends Object&gt;와 동치이다. Object의 기능만 사용한다 . | List&lt;?&gt; : 구상체들 기능은 필요없고, 추상체 List의 기능만 사용한다. . | **명확하게 형을 정해놓는 것에 비해, 아무형이나 올 수 있고, 그 기능은 가장 추상형 기능만 사용한다.( bound 제한있을 시)** . public class GenericsWildcards { static void printList(List&lt;Object&gt; list) { list.forEach(s -&gt; System.out.println(s)); } static void printList2(List&lt;?&gt; list) { list.forEach(s -&gt; System.out.println(s)); } public static void main(final String[] args) { final List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3); // 1. Object-Integer와 달리, List&lt;Object&gt; 와 List&lt;Integer&gt;는 SubType의 관계가 아니므로 인자로 못 넣는다. // - my) 추상형 변수 = 구상형 객체 [할당] == 호출시( 구상형 인자 ) -&gt; 메서드 선언부(추상체 파라미터) 호출이나 마찬가지 // -&gt; 인자 대입은 구상형 -&gt; 내부 파라미터는 추상형으로서, SubType만 올 수 있는데 // --&gt; List&lt;Integer&gt; 인자 -&gt; List&lt;Object&gt; 파라미터는 SubType관계가 아니므로 들어갈 수 없다. // --&gt; 즉, integer는 Object의 서브타입이지만, 리스트integer는 리스트object의 서브타입이 아니므로 호출시 대입 불가능 // -&gt; 명확하게 &lt;형&gt;을 정해놓으면, SubType만 할당/대입 가능하다!!! //printList(integers); //compile Error //2. ? 와일드카드는 명확하게 어떤형X, 어떤 형이든 상관없이 받아서, 추상형의 기능만 이용한다. printList2(integers); } } . | . | 와일드카드 제한점?! . public class GenericsWildcards { static void printList(List&lt;Object&gt; list) { list.forEach(s -&gt; System.out.println(s)); } static void printList2(List&lt;?&gt; list) { list.forEach(s -&gt; System.out.println(s)); } //3. class 2개를 만들어보자 static class A { } static class B extends A { } public static void main(final String[] args) { final List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3); // 1. Object-Integer와 달리, List&lt;Object&gt; 와 List&lt;Integer&gt;는 SubType의 관계가 아니므로 인자로 못 넣는다. // - my) 추상형 변수 = 구상형 객체 [할당] == 호출시( 구상형 인자 ) -&gt; 메서드 선언부(추상체 파라미터) 호출이나 마찬가지 // -&gt; 인자 대입은 구상형 -&gt; 내부 파라미터는 추상형으로서, SubType만 올 수 있는데 // --&gt; List&lt;Integer&gt; 인자 -&gt; List&lt;Object&gt; 파라미터는 SubType관계가 아니므로 들어갈 수 없다. // --&gt; 즉, integer는 Object의 서브타입이지만, 리스트integer는 리스트object의 서브타입이 아니므로 호출시 대입 불가능 // -&gt; 명확하게 &lt;형&gt;을 정해놓으면, SubType만 할당/대입 가능하다!!! //printList(integers); //compile Error //2. ? 와일드카드는 명확하게 어떤형X, 어떤 형이든 상관없이 받아서, 추상형의 기능만 이용한다. printList2(integers); //4. final List&lt;B&gt; bList = new ArrayList&lt;&gt;(); // 4-1. A 이하의 SubType형 list를 받을 수 있게하고, List&lt;B&gt;를 넣었더니.. List&lt;? extends A&gt; la = bList; // 4-2. 호.&lt;구&gt;.지로 완전 내부가 바꼈나??? A를 add하면 compile error //la.add(new A()); //compile Error // 4-3. 그렇다고 치기엔, B도 add가 안된다. //la.add(new B()); // 4-4. 와일드카드의 제한점으로서... add는 null밖에 안된다. -&gt; why? la.add(null); } } . | . 심화 . type paramter를 필요로 하는, 제네릭 메서드의 파라미터(List&lt; &gt;)에 대해 Type Paramter 적용 vs WildCards 적용 . Type Paramter 적용 . 와일드카드를 적용한 것과 다르게 . 한번 정의된 type parameter는 추가 파라미터, body내부 인스턴스 변수, 응답 값 등 메서드 내부 다양한 곳에서 T를 활용할 수 있다. . //1. type paramter를 메서드 파라미터(List&lt; &gt;)에 사용한 경우 static &lt;T&gt; void method1(List&lt;T&gt; list) { } . //1. type paramter를 메서드 파라미터(List&lt; &gt;)에 사용한 경우 static &lt;T&gt; T method1(List&lt;T&gt; list, T t) { // 1) 메서드파라미터 // 2) 내부 인스턴스 변수의 Type T value; // 3) 응답Type으로도 type paramter를 활용할 수 있다. return null; } . | . | . unbounded WildCards 적용 . 내부에서 활용할 수 도 없는 와일드 카드를 type paramter로 왜 사용하는 것일까? . static void method2(List&lt;?&gt; list) { } . | . 컬렉션를 받고 싶다면, 컬렉션&lt;?&gt; 와일드카드를 이용해야한다. . List&lt;Object&gt;로 형이 명시된 경우, List&lt;SubType&gt;의 자손이 아니므로 파라미터가 인자를 받을 수 없게 됨. List&lt;?&gt;는 List&lt;Obejct의 SubType&gt; 아무거나 다 받을 수 있다. | . | . | 그러나 unbound wild card인 &lt;?&gt;사용시에는 제약이 있다. . 특정 Type의 값을 add등 넣지 못한다. . | 특정 Type의 원소들과 관련된 기능은 사용못하고 -&gt; 가장 추상체List, Object만의 기능만 사용한다. . static void method2(List&lt;?&gt; list) { //3.그러나 `unbound wild card`(extends 등 사용안한 것)인 `&lt;?&gt;`사용시에는 제약이 있다. //3-1. 해당 자료구조에 구체적인 Type의 값(객체)을 넣을 수 없다. // -&gt; 해당 자료구조에는 null만 넣을 수 있다. //list.add(&quot;1&quot;); //compile error //list.add(1); //compile error //list.add(null); // runtime UOE error //3-2. 가장 추상체 = List만의 기능 + Object만의 기능만 사용가능하며, 각 Type의 원소들과 관련된 기능은 사용 못한다. //3-2-1. List만의 기능 //list.clear();// runtime UOE error list.size(); final Iterator&lt;?&gt; iterator = list.iterator(); //3-2-2. Object만의 기능 list.toString(); list.equals(null); } . | | unbound wild card 사용 예시1 . list를 받아 비어있으면 true반환하는 isEmpty() . | list의 원소가 어느type이든, 어떤 종류의 list라도 받을 수 있게 &lt;T&gt; 와일드카드로 파라미터 지역변수를 지정해주자 . . private static &lt;T&gt; boolean isEmpty(final List&lt;T&gt; list) { return list.size() == 0; } . | 메서드 파라미터속 type parameter T를 내부에서 사용하지 않았다면, T -&gt; 언바운드 wild card로 바꿀 수 있다. . //메서드 파라미터속 type parameter T를 내부에서 사용하지 않았다면 // -&gt; 타입 파라미터 대신 와일드카드를 적용시킬 수 있다. // -&gt; (타입파라미터 안쓰면 -&gt; 응답형 앞에 명시한 것도 삭제해주기) private static boolean isEmpty(final List&lt;?&gt; list) { return list.size() == 0; } //4. unbound wild card 사용 예시를 들기 위해 // -&gt; 어느 list를 받아 비어있으면 true를 반환하는 isEmpty()를 만든다 가정한다. final List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3, 4, 5); System.out.println(isEmpty(integerList)); . | | 지네릭 메소드를 쓰는 이유: 지네릭 type parameter로 정의된 T type의 원소에 관심 있어, 메서드 내부 T를 사용해야만 하는, add/remove/set 원소단위로 기능이 들어가는 경우 . | 지네릭 메소드 대신 와일드카드를 쓰는 이유: 자료구조 속 원소에는 관심X -&gt; List단위로서의 기능만 + Object의 기능만 쓸 경우 . | unbound wild card 사용 예시2 . frequnecy( list, 3) -&gt; 특정 원소가 몇번 중복되어있는지 . . . | List의 원소 Type, 개별원소Type 모두 T로 대체해준다. . private static &lt;T&gt; long frequency(final List&lt;T&gt; list, final T elem) { return list.stream() .filter(s -&gt; s.equals(elem)) .count(); } . | 빈도 검사에서도 내부에서 T가 안쓰였으니.. 와일드카드로 변환이 가능할 것 같은데 . type parameter를 정의하는 곳에만 들어갈 수 있다. | 컬렉션&lt;T&gt;의 파라미터 변수는 컬렉션&lt;Object&gt;로 컬렉션&lt;Subtype&gt;을 받을 수 없지만, 단일 TypeParameter는 추상-구상 SubType관계가 유지되므로 Object로 어느 타입이든 받는 T를 대신할 수 있다. 즉 메서드 파라미터 속 T t -&gt; ? t(X) -&gt; Object t (O)로 바꿔도 된다! | . | . . . | 내부 로직에서 사용되는 메서드를 봐도 . equals -&gt; Object에 정의된 기능 -&gt; ?로 변환 가능! | 와일드카드의 사용법 중에 1가지는 Object에 정의된 기능은 사용 허용!이다 | . private static long frequency(final List&lt;?&gt; list, final Object elem) { return list.stream() .filter(s -&gt; s.equals(elem)) .count(); } //5. 빈도를 세는 것(list + 개별원소)도 내부에서는 개별원소 기능이 없다 -&gt; filter + equals기능만 사용 -&gt; 지네릭 메서드 대신 와일드카드로 final List&lt;Integer&gt; duplicateIntegerList = Arrays.asList(1, 2, 3, 4, 5, 3, 2); System.out.println(&quot;frequency(duplicateIntegerList, 3) = &quot; + frequency(duplicateIntegerList, 3)); . | | bounded WildCards 적용 . max 메서드 생성 . . | 원래는 integer로 시작해서 T로 변환해야하지만, 바로 제네릭 메서드로 작성해보자. . stream을 이용해서 max를 구한다면 . loop -&gt; 제일 작은 초기값 세팅후 -&gt; 업데이트 방식과 다르게 | reduce의 초기값 없이 바로 BinaryOperator 사용방식으로, 누적해서 2개의 값씩 비교해나간다 | . | optional반환인데 값만 강제로 꺼내고 싶다면 .get()을 때리면 된다. . 만약 Optional에서 .get()으로 값을 못꺼낸 상황일 땐, NoSuchElementException을 낸다. | . //2. 원래는 Integer부터 만들어야 정상이지만, 제네릭을 계속 썼다보니 제네릭 메소드로 만들어보자. //private static &lt;T&gt; void max(final List&lt;T&gt; list) { //2-2. 제네릭 메서드의 type parameter에서 upper bound는 파라미터 자리가 아닌 [응답형 앞]에서 준다. private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;T&gt; list) { return list.stream() //2-1. max를 loop를 구할 땐, 가장 작은값을 후보 변수에 세팅 -&gt; 계속 업데이트하면서 구하는데, stream으로는? // -&gt; reduce의 2번째 방식(초기값 identity 따로 안주고 첫+둘 -&gt; 합+셋 -&gt; 순으로 연산 하기위해)으로 작성해보자. // -&gt; 연산후 연산결과의 Type이 현재 원소들과 같은 Type으로 되돌려줘야한다. // -&gt; 누적해가면서 &lt;2변수를 비교후 큰값을 남기기&gt;가 max값이다. // --&gt; Integer였다면 a &gt; b ? a : b 의 3항연산자를 써서 (비교후 t/f별 return) 했을 것이다. //.reduce((a,b) -&gt; a &gt; b ? a : b) // -&gt; 하지만, 제네릭을 통해 아무Type T -&gt; [부등호를 통한 숫자비교]이외의 비교를 위해서 // --&gt; Comparable 구현으로 제한한 Type에 대해 compareTo로 비교한다. .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) //2-3.stream에 원소가 없을 경우 optional로 반환하는데, get()을 통해 값만 강제로 꺼낼 수 도 있다. // -&gt; 값이 없는데 get을 시도했을 때 예외가 발생하는데, 이것은 자연스런 예외라고 생각할 수 있다. // NoSuchElementException: No value present // default값이나 or 특정예외를 발생시키는 코드를 작성안해도, 없는 값 get시도시 예외는 자연스러운 것으로 봐도 된다. .get(); } . | . | 내부T 안쓴 것처럼 보이지만, stream -&gt; 개별 원소 접근 -&gt; T쓴 것 과 마찬가지로 wildcard로 변환 불가능.의 상태이다. 하지만, wild cards가 개입될 여지가 있다. . wild card 도입 전 . private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;T&gt; list) { return list.stream() .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) .get(); } . | stream 아니였으면, 내부 T를 사용 -&gt; wildcard로 변환은 불가능한 상태 . T currentMax = list.get(0); for (final T t : list) { if (t.compareTo(currentMax)&gt;0) { currentMax = t; } } return currentMax; . | . | 내부에 개별원소 T의 사용으로 &lt;?&gt; 대신 &lt;T&gt;의 제네릭 메서드로 정해졌어도 . 내부에서 사용되는 파라미터 속 컬렉션의 type parameter는 upper bound with ?으로 수정가능하고 | 외부에서 사용되는 응답형 앞의 Comparable&lt;T&gt; type paramter는 lower bound with ?로 수정 가능하다 | . //3. 내부T 안쓴 것처럼 보이지만, stream -&gt; 개별 원소 접근 -&gt; T쓴 것 과 마찬가지로 wildcard로 변환 불가능.의 상태이다. //3-1. 비교메서드compareTo() 의 사용은 T type 원소뿐만 아니라, T의 SubType들도 인자로 들어와 비교될 수 있다. // 비교메서드의 인자뿐만 아니라 컬렉선&lt;T&gt;에서 각 원소가 [메서드 내부에서 사용=소모]되는 경우라면 [와일드카드를 사용한 upper bound type paramter]로 넘긴다는 가이드라인 있다. // -&gt; 메서드 파라미터의 [개별 원소가 메서드 내부에 사용되는 컬렉션의 type parameter] List&lt;T&gt; -&gt; List&lt;? extends T&gt; // private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;T&gt; list) { //3-2. 반대로, Comparable&lt;T&gt;에 걸린 T는 메서드내부에서 정해져 사용되지 않고, 메서드 밖에서 사용되는 Type paramter라서 // -&gt; lower bound로 정의해준다. // private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;? extends T&gt; list) { private static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(final List&lt;? extends T&gt; list) { return list.stream() .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) .get(); } . | wild card로 정의 가능하다면 지네릭 메소드 대신 와일드카드로 메서드 작성하는 이유 . oracle문서: T type parameter의 지네릭 메소드는 내부 로직에 T type을 사용해서 처리하겠다라는 의미가 담겨있다고 한다. Type parameter는 내부 구현이 노출이 된다. | . | 와일드 카드로 작성을 권장한다. | . 와일드카드를 사용한 상태에서 비교를 위한 compareTo 사용을 위해 bound wild card인 &lt; ? extends Comparable&gt;은 허용한다. 하지만 메서드 내부에 T를 이용하느 코드가 나온다면, 응답형 앞에 T를 &lt;T extends Comparable&gt;로 바꿔주면 된다. . private static boolean isEmpty(final List&lt;?&gt; list) { return list.size() == 0; } private static boolean isEmpty2(final List&lt;? extends Comparable&gt; list) { return list.size() == 0; } private static &lt;T extends Comparable&gt; boolean isEmpty3(final List&lt;T&gt; list) { return list.size() == 0; } . PECS는 사실… 메서드내부 사용되는 T는 E / 메서드외부에서 사용되는 T는 S 이다. . 어느타입의 List든 List&lt;T&gt;를 받아 max(list)를 구현 . reduce로 누적하여 연산하되, 둘중에 큰 값만 남기도록 한다. . 초기값 없이 바로 BinaryOperator작성하여, 1과2 -&gt; 연산값과 3번째, … , | 매번 연산값은 첫번째 요소와 동일한 Type이 되어야한다. | 둘 중에 큰 값만 남겨 return해야하므로 삼항연산자를 활용했다. | . | Integer로 시작했었지만, Number Type 이외의 값도 비교해야하므로 . 들어오는 T에 대해 응답형앞에서 &lt;T extends Comparable&lt;T&gt;&gt;로 Comparable 인페를 구현한 Type으로 bound한다. | . private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;T&gt; list) { return list.stream() //2-1. max를 loop를 구할 땐, 가장 작은값을 후보 변수에 세팅 -&gt; 계속 업데이트하면서 구하는데, stream으로는? // -&gt; reduce의 2번째 방식(초기값 identity 따로 안주고 첫+둘 -&gt; 합+셋 -&gt; 순으로 연산 하기위해)으로 작성해보자. // -&gt; 연산후 연산결과의 Type이 현재 원소들과 같은 Type으로 되돌려줘야한다. // -&gt; 누적해가면서 &lt;2변수를 비교후 큰값을 남기기&gt;가 max값이다. // --&gt; Integer였다면 a &gt; b ? a : b 의 3항연산자를 써서 (비교후 t/f별 return) 했을 것이다. //.reduce((a,b) -&gt; a &gt; b ? a : b) // -&gt; 하지만, 제네릭을 통해 아무Type T -&gt; [부등호를 통한 숫자비교]이외의 비교를 위해서 // --&gt; Comparable 구현으로 제한한 Type에 대해 compareTo로 비교한다. .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) //2-3.stream에 원소가 없을 경우 optional로 반환하는데, get()을 통해 값만 강제로 꺼낼 수 도 있다. // -&gt; 값이 없는데 get을 시도했을 때 예외가 발생하는데, 이것은 자연스런 예외라고 생각할 수 있다. // NoSuchElementException: No value present // default값이나 or 특정예외를 발생시키는 코드를 작성안해도, 없는 값 get시도시 예외는 자연스러운 것으로 봐도 된다. .get(); } . | . | (stream안썼으면) 내부에서 T가 사용되는 상황(stream으로는 개별원소에 접근하는 상황)이므로 &lt;T&gt; 대신 &lt;?&gt; = 추상체 자체기능 + Object의기능만 사용은 불가능한 지네릭 메소드여야만 한다 . 하지만 와일드카드가 끼어들만 여지가 남겨져있다 | . private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;T&gt; list) { return list.stream() .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) .get(); } . | 위에서 보는 것처럼 . 내부에서 개별적으로 사용되는 메서드 파라미터 속 List&lt;T&gt;에서의 T는 a.비교메서드( b )에서 a와 b 자리에는 T type대신 SubType도 들어가서 비교될 수 있기 때문에 T의 subtype을 의미하는 List&lt;? extends T&gt;를 대신사용할 수 있다. . | 외부 Comparable 클래스에서 compareTo정의시 사용될 Comparable&lt;T&gt;의 T는 비교메서드를 구성하는 Type이라고 볼 수 있다. . Integer끼리의 비교는 a - b 처럼 compareTo가 간단하게 구성될지 몰라도 | 어느타입이든 비교되려면, Object객체 2개를 비교할 수 있는 compareTo가 만들어져야한다. | 그래서 Comparable처럼 외부에서 사용될 T는 T에 대해 SuperType으로 구성되어도 된다. | . private static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(final List&lt;? extends T&gt; list) { return list.stream() .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) .get(); } . | | 바깥에서 쓰는 T의 대한 예시 -&gt; Collections.max( list , comparator) . public static void main(final String[] args) { final List&lt;Integer&gt; list = Arrays.asList(1, 2, 3); //4. 바깥에서 쓰일 Comparable&lt;T&gt;의 T는 &lt;T extends Comparable&lt;? super T&gt;&gt;처럼 SuperType이 들어가도 된다?? 를 증명해보기 // 4-1. List 예시는, 자체 comparator가 내부에 내장 되어있어, Comparable를 구현안해도 알아서 집계함수내에서 집계된다. System.out.println(&quot;Collections.max(list) = &quot; + Collections.max(list)); // 4-2. 이번엔 비교대상obj의 class가 직접 Comparable을 구현하는 것이 아니라, // 한 단계 위층에서, 직접 2개의 원소를 받아 비교가능하도록 만드는 비교자 Comparator인터페이스를 만드는 경우 // 집계메서드의 다음인자로 만들어서 던진다. //Collections.max(list, Comparator) //Comparator의 내부 구현을 보기 위해 잠시 적어두고 타고 들어갔다옴. // -&gt; Comparator은 인터페이스로 증 @FunctionalInterface로서, 외부에서 인자를 던질 때, 람다식으로 구현가능하다. // --&gt; int compare(T o1, T o2); 파라미터 2개 -&gt; (a,b)로 시작 &amp;&amp; 응답 int -&gt; 1개 int로 나오도록 람다식 마무리 //Collections.max(list, (a, b) -&gt; a - b ); // &gt; 그러나, T 타입을 받아 비교하도록 되어있으므로 [람다식의 Type paramter 다운? 캐스팅]을 사용할 수 있다. // cf) 람다식은 타입을 캐스팅할 수 있는 것이 장점이라고 한다. // -&gt; Integer List의 원소들끼리 비교라면, Compator&lt;Integer&gt;로 람다식의 T타입을 캐스팅해서 쓰면 되지만 // 여기에서는 지네릭 -&gt; 모든 타입 -&gt; Object로 [람다식 타입 캐스팅]을 시도하여 obj vs obj 비교가 가능하게 한다. // --&gt; 이렇게 되면, object - object 의 부등호 비교가 말을 안듣게 된다. //Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a - b); // a-b error! // &gt; a와 b가 integer가 아니라 object가 되었다고 가정하고 // **object의 공통 .toString()**을 통해 compareTo로 비교한다고 가정하고 작성한다. Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString())); // a-b error! //4-3. 이렇게 2개의 obj로 비교하는 Comparator 인터페이스 구현체를 람다식타입캐스팅해서 인자로 던졌는데 잘 동적을 한다 System.out.println( &quot;Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString())) = &quot; + Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString()))); // 4-4. 여기서 하고 싶은말은, Comparable or Comparator에 붙은 &lt;T&gt;는 비교할 객체 2개의 type이며 // -&gt; 그 T에는 SuperType이 와도 된다는 이야기를 하고싶은 것 // --&gt; 하위 경계만 list의 T인 Integer로 잡혀있을 뿐 -&gt; ? super T 로서, Integer의 SuperType이 와도 된다. //5. 이제 Comparable&lt; ? super T&gt;를 통해 -&gt; compareTo를 사용할 객체는 T보다 더 SuperType 특히, Object를 줘도 가능하다는게 밝혀졌다. // -&gt; Comparable내부 구조를 object. 비교메서드 ( object )로 바꿔놓은 상태다. // 그렇다면, max(final List&lt;? extends T&gt; list) 에서 list의 원소는 [비교될 객체 a, b자리에 구현체 SubType이 들어갈 수 있다]는 어떻게 확인할까? // -&gt; 비교 구조는 SuperType 특히, Object1. 비교메서드 ( Object 2)로 잡힌 상태로서, // --&gt; 각각의 Object1, 2 자리에 SubType(구현체)가 들어가는 것은 자연스러운 일로 이해할 수 있다. // -&gt; SubType의 원소가 비교메서드 자리에 들어갈 수 있는지 판단하려면 // &gt; max()함수의 T를 Integer의 추상체인 Number로 고정시켜 호출하면, // 파라미터속 T -&gt; NumberType인데, 인자로 던진 Integer 타입이 들어가도 잘 동작하는 것을 확인할 수 있다. System.out.println( &quot;Collections.&lt;Number&gt;max(list, (Comparator&lt;Object&gt;)(a,b) -&gt; a.toString().compareTo(b.toString())) = &quot; + Collections.&lt;Number&gt;max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString()))); //6. 어떨때는 upper bound? 어떨때는 under bound? -&gt; java에서 설명하는 기준이 있다. // 1) 넘기는 파라미터 type이 메서드 내부에서 사용되는 경우 -&gt; 상위경계(upper bound)를 쓰면 되고 // 2) 외부에서 정의되는 메서드에 사용될 경우 ex&gt; Comparable내부에서 사용될 T -&gt; 하위 경계(under bound)를 쓰면 된다. // -&gt; 가장 잘보여주는 예가 Collections 내부의 copy()메서드다 // cf) alt+7(Structure)에서 ctrl+f에서 찾아보기 // public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) { // 소스 src는 안에서 copy메서드 내부에서 소모되는 것이므로 &lt;? extends T&gt; 구현체 와도 된다. // 데스티네이션 dest는 copy메서드 내부에서 [만들어진 뒤 밖으로 내보내 사용 될 것] -&gt; 구조를 추상체로 잡아주도록 &lt;? super T&gt;로 와일드카드를 준다. // - 안에서 만들어지긴 하지만 ouput으로서 밖에서 사용되는 것임. /// 3) 귀찮으면, 잘모르겠으면 그냥 &lt;T&gt;로만 지정해서 쓰면 된다.. } . | public class GenericsWildCard { public static void main(final String[] args) { final List&lt;Integer&gt; list = Arrays.asList(1, 2, 3); //1. list가 들어오면 그 원소들 중 가장 큰 값을 반환하도록 한다. 만든다. System.out.println(&quot;max(list) = &quot; + max(list)); //4. 바깥에서 쓰일 Comparable&lt;T&gt;의 T는 &lt;T extends Comparable&lt;? super T&gt;&gt;처럼 SuperType이 들어가도 된다?? 를 증명해보기 // 4-1. List 예시는, 자체 comparator가 내부에 내장 되어있어, Comparable를 구현안해도 알아서 집계함수내에서 집계된다. System.out.println(&quot;Collections.max(list) = &quot; + Collections.max(list)); // 4-2. 이번엔 비교대상obj의 class가 직접 Comparable을 구현하는 것이 아니라, // 한 단계 위층에서, 직접 2개의 원소를 받아 비교가능하도록 만드는 비교자 Comparator인터페이스를 만드는 경우 // 집계메서드의 다음인자로 만들어서 던진다. //Collections.max(list, Comparator) //Comparator의 내부 구현을 보기 위해 잠시 적어두고 타고 들어갔다옴. // -&gt; Comparator은 인터페이스로 증 @FunctionalInterface로서, 외부에서 인자를 던질 때, 람다식으로 구현가능하다. // --&gt; int compare(T o1, T o2); 파라미터 2개 -&gt; (a,b)로 시작 &amp;&amp; 응답 int -&gt; 1개 int로 나오도록 람다식 마무리 //Collections.max(list, (a, b) -&gt; a - b ); // &gt; 그러나, T 타입을 받아 비교하도록 되어있으므로 [람다식의 Type paramter 다운? 캐스팅]을 사용할 수 있다. // cf) 람다식은 타입을 캐스팅할 수 있는 것이 장점이라고 한다. // -&gt; Integer List의 원소들끼리 비교라면, Compator&lt;Integer&gt;로 람다식의 T타입을 캐스팅해서 쓰면 되지만 // 여기에서는 지네릭 -&gt; 모든 타입 -&gt; Object로 [람다식 타입 캐스팅]을 시도하여 obj vs obj 비교가 가능하게 한다. // --&gt; 이렇게 되면, object - object 의 부등호 비교가 말을 안듣게 된다. //Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a - b); // a-b error! // &gt; a와 b가 integer가 아니라 object가 되었다고 가정하고 // **object의 공통 .toString()**을 통해 compareTo로 비교한다고 가정하고 작성한다. Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString())); // a-b error! //4-3. 이렇게 2개의 obj로 비교하는 Comparator 인터페이스 구현체를 람다식타입캐스팅해서 인자로 던졌는데 잘 동적을 한다 System.out.println( &quot;Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString())) = &quot; + Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString()))); // 4-4. 여기서 하고 싶은말은, Comparable or Comparator에 붙은 &lt;T&gt;는 비교할 객체 2개의 type이며 // -&gt; 그 T에는 SuperType이 와도 된다는 이야기를 하고싶은 것 // --&gt; 하위 경계만 list의 T인 Integer로 잡혀있을 뿐 -&gt; ? super T 로서, Integer의 SuperType이 와도 된다. //5. 이제 Comparable&lt; ? super T&gt;를 통해 -&gt; compareTo를 사용할 객체는 T보다 더 SuperType 특히, Object를 줘도 가능하다는게 밝혀졌다. // -&gt; Comparable내부 구조를 object. 비교메서드 ( object )로 바꿔놓은 상태다. // 그렇다면, max(final List&lt;? extends T&gt; list) 에서 list의 원소는 [비교될 객체 a, b자리에 구현체 SubType이 들어갈 수 있다]는 어떻게 확인할까? // -&gt; 비교 구조는 SuperType 특히, Object1. 비교메서드 ( Object 2)로 잡힌 상태로서, // --&gt; 각각의 Object1, 2 자리에 SubType(구현체)가 들어가는 것은 자연스러운 일로 이해할 수 있다. // -&gt; SubType의 원소가 비교메서드 자리에 들어갈 수 있는지 판단하려면 // &gt; max()함수의 T를 Integer의 추상체인 Number로 고정시켜 호출하면, // 파라미터속 T -&gt; NumberType인데, 인자로 던진 Integer 타입이 들어가도 잘 동작하는 것을 확인할 수 있다. System.out.println( &quot;Collections.&lt;Number&gt;max(list, (Comparator&lt;Object&gt;)(a,b) -&gt; a.toString().compareTo(b.toString())) = &quot; + Collections.&lt;Number&gt;max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString()))); //6. 어떨때는 upper bound? 어떨때는 under bound? -&gt; java에서 설명하는 기준이 있다. // 1) 넘기는 파라미터 type이 메서드 내부에서 사용되는 경우 -&gt; 상위경계(upper bound)를 쓰면 되고 // 2) 외부에서 정의되는 메서드에 사용될 경우 ex&gt; Comparable내부에서 사용될 T -&gt; 하위 경계(under bound)를 쓰면 된다. // -&gt; 가장 잘보여주는 예가 Collections 내부의 copy()메서드다 // cf) alt+7(Structure)에서 ctrl+f에서 찾아보기 // public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) { // 소스 src는 안에서 copy메서드 내부에서 소모되는 것이므로 &lt;? extends T&gt; 구현체 와도 된다. // 데스티네이션 dest는 copy메서드 내부에서 [만들어진 뒤 밖으로 내보내 사용 될 것] -&gt; 구조를 추상체로 잡아주도록 &lt;? super T&gt;로 와일드카드를 준다. // - 안에서 만들어지긴 하지만 ouput으로서 밖에서 사용되는 것임. /// 3) 귀찮으면, 잘모르겠으면 그냥 &lt;T&gt;로만 지정해서 쓰면 된다.. } //3. 내부T 안쓴 것처럼 보이지만, stream -&gt; 개별 원소 접근 -&gt; T쓴 것 과 마찬가지로 wildcard로 변환 불가능.의 상태이다. //3-1. 비교메서드compareTo() 의 사용은 T type 원소뿐만 아니라, T의 SubType들도 인자로 들어와 비교될 수 있다. // 비교메서드의 인자뿐만 아니라 컬렉선&lt;T&gt;에서 각 원소가 [메서드 내부에서 사용=소모]되는 경우라면 [와일드카드를 사용한 upper bound type paramter]로 넘긴다는 가이드라인 있다. // -&gt; 메서드 파라미터의 [개별 원소가 메서드 내부에 사용되는 컬렉션의 type parameter] List&lt;T&gt; -&gt; List&lt;? extends T&gt; // private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;T&gt; list) { //3-2. 반대로, Comparable&lt;T&gt;에 걸린 T는 메서드내부에서 정해져 사용되지 않고, 메서드 밖에서 사용되는 Type paramter라서 // -&gt; lower bound로 정의해준다. // private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;? extends T&gt; list) { private static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(final List&lt;? extends T&gt; list) { return list.stream() .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) .get(); } //2. 원래는 Integer부터 만들어야 정상이지만, 제네릭을 계속 썼다보니 제네릭 메소드로 만들어보자. //private static &lt;T&gt; void max(final List&lt;T&gt; list) { //2-2. 제네릭 메서드의 type parameter에서 upper bound는 파라미터 자리가 아닌 [응답형 앞]에서 준다. private static &lt;T extends Comparable&lt;T&gt;&gt; T max2(final List&lt;T&gt; list) { return list.stream() //2-1. max를 loop를 구할 땐, 가장 작은값을 후보 변수에 세팅 -&gt; 계속 업데이트하면서 구하는데, stream으로는? // -&gt; reduce의 2번째 방식(초기값 identity 따로 안주고 첫+둘 -&gt; 합+셋 -&gt; 순으로 연산 하기위해)으로 작성해보자. // -&gt; 연산후 연산결과의 Type이 현재 원소들과 같은 Type으로 되돌려줘야한다. // -&gt; 누적해가면서 &lt;2변수를 비교후 큰값을 남기기&gt;가 max값이다. // --&gt; Integer였다면 a &gt; b ? a : b 의 3항연산자를 써서 (비교후 t/f별 return) 했을 것이다. //.reduce((a,b) -&gt; a &gt; b ? a : b) // -&gt; 하지만, 제네릭을 통해 아무Type T -&gt; [부등호를 통한 숫자비교]이외의 비교를 위해서 // --&gt; Comparable 구현으로 제한한 Type에 대해 compareTo로 비교한다. .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) //2-3.stream에 원소가 없을 경우 optional로 반환하는데, get()을 통해 값만 강제로 꺼낼 수 도 있다. // -&gt; 값이 없는데 get을 시도했을 때 예외가 발생하는데, 이것은 자연스런 예외라고 생각할 수 있다. // NoSuchElementException: No value present // default값이나 or 특정예외를 발생시키는 코드를 작성안해도, 없는 값 get시도시 예외는 자연스러운 것으로 봐도 된다. .get(); } } . 와일드카드 사용시 캡처 문제 . reverse . public class GenericsCapture { public static void main(final String[] args) { final List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5); //1. 이번엔 어느타입의 list든 revese시키는 함수를 만들어보자. // -&gt; 제일 쉽게 구현하는 것은 list를 1개 temp에 방어적 복사(새로운 list로 복제)해놓고, // -&gt; i번째에, temp에서는 n-i-1번재로 뒤에서부터 꺼내서, 원본 list값을 바꿔버리는(set) 전략이다. reverse(list); System.out.println(&quot;list = &quot; + list); } private static &lt;T&gt; void reverse(final List&lt;T&gt; list) { //2. reverse전략: temp list 1개를 방어적 복사 -&gt; index를 돌면서 뒤에서부터 temp에서 꺼낸 값을 -&gt; 원본 list의 값에 set final List&lt;T&gt; temp = new ArrayList&lt;&gt;(list); for (int i = 0; i &lt; list.size(); i++) { list.set(i, temp.get(list.size() - i - 1)); } } } . | List는 사용됬지만, 개별원소 T t의 type관련 기능이 사용되지 않았다. . T type정보가 내부에서 의미있게 사용되는가? 생성자에 list집어넣기 / size / get in List/ set in List -&gt; 전부 List자체 기능 | . | type paramter대신 와일드카드 사용가능하다 . 응답형 앞에 T 삭제 | type parameter List&lt;T&gt;를 List&lt;?&gt;대체하기 | . | 와일드 카드로 바꿔줬더니, capture에러가 뜬다. . . | . | 와일드카드로 Type을 모르고 관심없다고 했는데 그 ?의 Type을 추론해야하는 상황 = 캡처의 상황이 찾아오기도 한다 . 캡처=와일드카드의 타입추론 | listd에 .set을 할려고보니, temp에서 꺼내온 Type을 어떤 형으로 정해서 넣어줘야하지? 모르는 상황 | . | 다시 지네릭메서드로 돌아가도 되지만, 자바 설계상 헬퍼메서드를 만들어준다 . reverse()메소드 내부에 private revserseHelper( list )메소드를 만들고, 지네릭메소드로 돌린 코드를 helper메서드에 넣어준다. . 구조상 원본메서드는 List&lt;?&gt; list의 와일드카드를 사용중이고 | 내부 helper메서드는 와일드카드 list를 던졌는데 -&gt; 파라미터는 List&lt;T&gt; list의 지네릭 메서드를 사용하게 된다. | . . | List&lt;?&gt; list -&gt; List&lt;T&gt; list 메서드에 대입이 가능한가? . SubType 인자만 -&gt; SuperType파라미터가 받을 수 있을 텐데? 일치하거나 List 가 ?의 SuperType(추상체)여야 인자로 던지기 가능함 | . | 사실 그런관계는 없다. 그러나 컴파일러가 자동으로 ? -&gt; T 대입시 T로 캡쳐를 해준다고 한다. why 이런구조를 쓸까? 그냥 지네릭 메서드를 쓰면 편할텐데 T라는 type도 내부구현으로서 감출 수 있으면 감추기 위해 | . | . | . public class GenericsCapture { public static void main(final String[] args) { final List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5); reverse(list); System.out.println(&quot;list = &quot; + list); } private static void reverse(final List&lt;?&gt; list) { reverseHelper(list); } private static &lt;T&gt; void reverseHelper(final List&lt;T&gt; list) { final List&lt;T&gt; temp = new ArrayList&lt;&gt;(list); for (int i = 0; i &lt; list.size(); i++) { list.set(i, temp.get(list.size() - i - 1)); } } } . | 와일드카드로 변환했는데, 구체적인 Type정보가 필요한 코드를 만나서 캡처문제가 발생했구나 정도로 이해하고 있으면 된다. . | public class GenericsCapture { public static void main(final String[] args) { final List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5); //1. 이번엔 어느타입의 list든 revese시키는 함수를 만들어보자. // -&gt; 제일 쉽게 구현하는 것은 list를 1개 temp에 방어적 복사(새로운 list로 복제)해놓고, // -&gt; i번째에, temp에서는 n-i-1번재로 뒤에서부터 꺼내서, 원본 list값을 바꿔버리는(set) 전략이다. reverse(list); System.out.println(&quot;list = &quot; + list); } //3. List&lt;T&gt;는 사용됬지만, 개별원소 T t의 type관련 기능이 사용되지 않았다. // -&gt; T type정보가 내부에서 의미있게 사용되는가? // 생성자에 list집어넣기 / size / get in List/ set in List -&gt; 전부 List자체 기능 // -&gt; type paramter대신 와일드카드 사용가능하다 private static void reverse(final List&lt;?&gt; list) { //2. reverse전략: temp list 1개를 방어적 복사 -&gt; index를 돌면서 뒤에서부터 temp에서 꺼낸 값을 -&gt; 원본 list의 값에 set // final List&lt;?&gt; temp = new ArrayList&lt;&gt;(list); // // for (int i = 0; i &lt; list.size(); i++) { // list.set(i, temp.get(list.size() - i - 1)); // } //4. 지네릭 -&gt;와일드카드로 변환시 캡처 문제가 발생할 경우, private helper메서드를 만들고 // 그 내부를 다시 지네릭메서드로 돌린다. reverseHelper(list); } //5. List&lt;?&gt; list -&gt; final List&lt;T&gt; list 메서드에 대입이 가능한가? // -&gt; SubType 인자만 -&gt; SuperType파라미터가 받을 수 있을 텐데? // (일치하거나 List&lt;T&gt; 가 ?의 SuperType(추상체)여야 인자로 던지기 가능함) // --&gt; 사실 그런관계는 없다. 그러나 컴파일러가 자동으로 ? -&gt; T 대입시 T로 캡쳐를 해준다고 한다. private static &lt;T&gt; void reverseHelper(final List&lt;T&gt; list) { final List&lt;T&gt; temp = new ArrayList&lt;&gt;(list); for (int i = 0; i &lt; list.size(); i++) { list.set(i, temp.get(list.size() - i - 1)); } } } . Lambda . 람다식을 인자로 받는 메서드를 만들고 . . . | 인자의 빨간줄은 파라미터를 뭘로 바꾸면 람다식 인자가 사라질까? . IDE가 아직 람다식을 java.util.Function으로는 파라미터 자동생성을 안해준다. . . | . | 해석해보기 . Function은 람다식 구현을 하나의 구현체 인자로 받는 변수/파라미터 속 추상체이자 인터페이스이다. . | 내부를 보면, 메서드가 1개만 있는 함수형인터페이스다 . 람다식으로 구현 가능 == 인터페이스에 구현해야할 함수가 1개만 있어서 그자리에서 구현 == 함수형 인터페이스 | . | **그렇다면 람다식 구현 자체가 메서드 1개인 인터페이스의 구현체가 되어, 인터페이스(추상체)를 파라미터로 받는 메서드의 인자로서 구현체로서 던져진다. ** . . | 함수형인터페이스는 지네릭 인터페이스로서, 인자/응답의 type paramter를 지정한 메서드 파라미터로 지정할 수 있다. . private static void hello(final Function&lt;String, String&gt; o) { } . | 람다식 구현 인자를 받는 함수형인페에 제네릭 type parameter여부는 parameter hint로 확인하면서 람다식을 구현하면 된다. . | . | 람다식 구현 이전, 익명클래스로 구현 . //4. 사실 람다식을 -&gt; 익명클래스라는 [인터페이스를 객체처럼 생성후 -&gt; 중괄호로 그자리에서 인터페이스속 1개 메서드를 Override구현]한 뒤, 변수 추출하여, 익클로 구현 변수를 함수형 인터페이스 인자 자리에 넣어줄 수 있다. //new Function&lt;String, String&gt;(){} // -&gt; generate -&gt; impl method // new Function&lt;String, String&gt;(){ // @Override // //4-1. 그자리에서 구현했지만, 들어오는 인자는 s // public String apply(final String s) { // //4-2. 그자리에서 구현했지만, 응답값은 s // return s; // } // }; // 4-3. 인터페이스를 객체처럼 -&gt; {}중괄호 그자리 구현 했다면 -&gt; 그것을 사용하기 위해선 -&gt; 익클은 변수 추출로 빼야한다. final Function&lt;String, String&gt; function = new Function&lt;&gt;() { @Override public String apply(final String s) { return s; } }; // 4-4. 이제 익클로 구현한 function를 람다식이 있던 자리 == 함수형인터페이스를 파라미터로 받는 메서드(인자) 자리에 넣어줄 수 있다. // -&gt; 그러면 내부에서 apply가 자동으로 호출된다.?! //hello(function); // 4-5. 하지만, 메소드1개인 함수형 인터페이스의 구상체 구현은 익클구현보다는, 람다식으로 해당 메서드를 구현하면 된다. hello(s -&gt; s); . 익명 클래스 구현 -&gt; 람다식 구현으로 옮겨오는 과정 . //5. 메소드1개 인터페이스의 익명클래 구현에서 // 1) 익명클래스 관련 코드 삭제(new ~ @Override) // 2) 응답형은 알아서 추론&lt;, R&gt; // 3) 메서드명 필요없어 삭제 // 하면 아래와 같다 hello( (String s ) -&gt;{ return s; } ); // 4) 지네릭을 쓰는 함수형인페에서 이미 인자의 type을 정해놨을 것이므로 // -&gt; 인자 type도 추론 가능해서 삭제 // 5) 응답쪽 statement가 1줄인 경우, 중괄호 + return + 세미콜론 생략 hello( s -&gt; s); . cf) type추론은 compile time에 이루어진다. | . | . IntersectionType 기본 . 람다식 구현인자를 받는 함수형인페 파라미터의 메서드를 쓰는 데, 마커 인터페이스를 붙여야할 경우가 생긴다면 . 해당 메서드의 파라미터를 Function t -&gt; T t를 받는 제네릭메서드로 바꾸고 . | upper bound를 &lt;T extends Function&gt;으로 준다. | 이제type parameter에 &lt;T extends 함수형인페 &amp; 마커인터페이스&gt;형식으로 intersectionType type parameter를 사용해서 상한시 요구되는 타입을 여러 interface를 섞어 제한하면 된다. | | . public class GenericsIntersectionType { public static void main(final String[] args) { //1. [람다식 구현]을 인자로 받는 [메서드]를 만들자. // -&gt; why? 람다식 구현을 받는 추상체 파라미터는 [메소드 1개의 함수형인페 구현을 받아주는 중 &amp;&amp; 인자-&gt;응답T를 지네릭으로 정의]해놓았기 때문이다. // cf) 람다식으로 구현해도, 익명클래스는 아니지만, 비슷한 클래스가 내부에 정의되서 익클처럼 작동한다... hello(s -&gt; s); //3. 람다식은 앞에 (소괄호를 통한 타입 캐스팅)이 가능하다고 했다. // -&gt; type없이 캐스팅을 해줘도 된다. 불필요 하지만.. hello((Function) s -&gt; s); //4. 람다식의 캐스팅은 사실 intersectionType을 위해 사용된다. // -&gt; 메서드 1개는 이미 함수형인페것을 구현하고 있는 람다식이지만 // --&gt; 메서드가 내부에 없는 marker interface를 &amp;를 통해 추가 구현한다는 개념이다. // 대표적인 marker interface를 [Serializable]로 생각하자. // impl Comparable처럼, impl Serializable을 하면 -&gt; [파일/네트워크에서 직렬화 가능한 class임을 마킹]하는 인터페이스다. // impl로 구현즉시, instanceof로 확인해보면, Serializable Type이 되어버린다. // -&gt; Type만 가지고도 전송가능한지 확인할 수 있어서 좋다. // 5. 람다식 구현 유지조건은, intersectionType을 사용하더라도, 총 구현 메서드가 1개기만 하면 된다. // 1 &amp; 0 &amp; 1 -&gt; 람다식구현에서 에러가 난다. 람다식은 메서드 1개만 구현 //hello((Function &amp; Serializable &amp; Closeable) s -&gt; s); // 1 &amp; 0 // -&gt; 내부적으로 class를 정의하는데, 3가지 인터페이스를 모두 impl한 class를 정의함. hello((Function &amp; Serializable) s -&gt; s); } //2. 이번엔 함수형인페속 type paramter를 지금 정의하지 않았고 -&gt; raw type으로 지네릭 인터페이스를 사용한다. // -&gt; 이 경우, &lt;T, R&gt; 자리에는 &lt;Object, Object&gt;가 들어가 있다. private static void hello(final Function o) { throw new UnsupportedOperationException(&quot;GenericsIntersectionType#hello not write.&quot;); } //6. [람다식구현을 받는 함수형인페 Type]의 메서드 파라미터(final Function o)에다가 // -&gt; bounded type parameter으로 명시되는 제네릭 메서드(T o)로 변환할 수 있다. // -&gt; 원래는 지네릭메서드를 고려할 땐, 어느타입이든 받을 수 있게 T로 놓았지만 // -&gt; 여기서는 [직렬화가능한 &amp; 람다식 구현]을 인자로 넘기는 경우가 있으며, 그 때 제한을 걸어줄 때 // --&gt; 여기선 최소 해당조건을 구현하거나 그 자식 구현체로 제한하는 Type을 type parameter로 넣어준다. // &gt; 이렇게 할 경우 class Myclass implements Function, Serializeable의 여러 인터페이 구현한 클래스의 객체를 생성할 필요가 없어진다. //-&gt; 요약) 마커인터페이스를 붙일 필요가 있는데, 람다식으로 간결하고 표현하고 싶다 -&gt; 지네릭 메서드를 intersectionalType을 써서 정의해라 private static &lt;T extends Function &amp; Serializable&gt; void hello2(final T o) { throw new UnsupportedOperationException(&quot;GenericsIntersectionType#hello not write.&quot;); } } . 그러나 요즘 직렬화가능한 것을 넘겨주는 것은 잘안한다고 한다. | 새로운 class를 만들지 않고도, IntersectionType을 통한 인터페이스 조합을 통해 새로운 class = 새로운 익명의 Type을 만들어내는 효과를 만들어낼 수 있다. | . IntersectionType으로 marker interface의 default method을 합친 익명 객체 만들어보기(제한점 존재) . 기존 함수형인페의 기능(apply) + 마커인페의 default method들의 기능을 모두 합쳐서 가지고 있는 새로운 객체가 생성된다. 문제점: 람다식구현 인자 던질 때 캐스팅 해준 만큼 -&gt; 제네릭 메서드의 상한에도 또 명시 | . | . public class GenericsIntersectionType2 { //1. 새로운 default메서드만 가지는 인터페이스를 하나 생성한다. interface Hello { //2. 인터페이스안에는 default 메서드를 1개 만들어 -&gt; 부연코드를 넣을 수 있다(아니면 다 공통 추상메서드만 있어야함) // -&gt; 제한이 있긴하다 (상속x/ public만/ 필드정의 후 사용x) // -&gt; 가능한 것 : 인터페이스 내 추상메서드 / static메서드 호출 가능 default void hello() { System.out.println(&quot;Hello&quot;); } } //2. 또 default메서드만 가지는 인터페이스를 하나 생성 interface Hi { default void hi() { System.out.println(&quot;Hi&quot;); } } public static void main(final String[] args) { //3. 람다식 구현을 인자로받는 [함수형인터페이스]를 파라미터로 받는 메서드를 정의한다. //hello( s -&gt; s); //4. 람다식 구현은, 해당 추상체인 [함수형인페]로 캐스팅할 수 있다 // hello((Function) s -&gt; s); //5. 람다식 구현시 사용하는 캐스팅에 Intersection Type으로서 &amp;로 여러 market 인터페이스를 구현할 수 있다. // -&gt; 람다식 캐스팅은 총 method개수가 1개여야하지만, default method는 0개로 친다! hello((Function &amp; Hello &amp; Hi) s -&gt; s); } //6. Function 및 그 구상체(람다식구현)만 받았었지만 // -&gt; 3개 인터페이스 다 구현한 이후만 받도록 만들기 위해서 //private static void hello(final Function function) { // 6-1. 제네릭 메서드로 변환한다. Function function -&gt; T function // 6-2. T에 상한을 Function으로 둔다 //private static &lt;T extends Function&gt; void hello(final T function) { // 6-3. T에 상한 인터페이스에다가 &amp; Intersection로 마커인터페이스들을 추가한다. private static &lt;T extends Function &amp; Hello &amp; Hi&gt; void hello(final T function) { //6-4. T function는 &lt;Function &amp; Hello &amp; Hi&gt; Type으로 제한된 상태이므로 // -&gt; Function이 가지고 있는 apply를 적용할 수 있다. function.apply(&quot;s&quot;); // 7. 신기한 점은 market interface내에 있는 default method도 호출이 가능하다는 점이다. // -&gt; 함수형 인터페이스의 기능(apply) + 마커인터페이스의 default method들의 기능을 모두 합침 function.hello(); function.hi(); } //8. 제네릭메서드의 상한과 insectionType + 인터페이스의 defaul method를 활용하면 // -&gt; 기능 자체를 계속 추가해줄 수 있는데, // [문제]는 [1) 람다식구현시 캐스팅 일일히 해놓고] -&gt; 또 호출을 받는 [2) 제네릭 메서드의 upper bound에도 일일히 명시]해줘야하기 때문에 // -&gt; 의미가 없다. } . Consumer파라미터 추가를 통한, 콜백형식으로 IntersectionType에 기능 하나씩 확장하기(제한점 존재) . 각각 따로 기능을 구현한 interface의 method기능들을 모았어도 -&gt; 공통정보를 활용하는 방법이 없으니, 모아도 별로 의미가 없어 보이는 제한점… | . public class GenericsIntersectionType3 { interface Hello { default void hello() { System.out.println(&quot;Hello&quot;); } } interface Hi { default void hi() { System.out.println(&quot;Hi&quot;); } } public static void main(final String[] args) { //1. run이라는 메서드를 만들어 (intersectionType)으로 캐스팅된 람다식구현을 인자로 받는다. //run((Function &amp; Hello &amp; Hi) s -&gt; s); //5. 컨슈머T로 넘어갈 컨슈머용 람다식(인자O -&gt; return값 없는 사용만 우항에 몰빵) run((Function &amp; Hello &amp; Hi) s -&gt; s, o -&gt; { o.hello(); o.hi(); }); //6. 누락된 개념: // 6-1. 제네릭메서드의 상한으로 3개 인페 정의부분을 -&gt; 첫번째 파라미터의 람다식 캐스팅에 의존한다 (컨슈머T는 첫번째 상한제한T를 그대로 이용하기 때문에 다 미리 타입이 추론되어있다) // 6-2. 제네릭메서드 내부에서 호출된 로직을, 바깥의 ConsumerT 구현 람다식으로 뺐다.-&gt; 2번째 인자의 람다식구현 우항(lambda object) // - 요곤 6-1.을 이용하기 위함함 //7. s-&gt;s는 의미가 없다. Function의 람다식구현을 가장 짧게 나타냈을 뿐이다. // -&gt; 주요기능은 intersectionType으로 추가되는 marker 인터페이스의 &lt;default method&gt;기능이다. //9. 새로운 마커인터페이스+그 default method기능을 추가시켜서 사용해보자. // 9-1. 람다식 캐스팅에 추가한다. run((Function &amp; Hello &amp; Hi &amp; Printer) s -&gt; s, o -&gt; { o.hello(); o.hi(); // 9-2. 새로운 default method 기능 추가 사용 in Consumer o.print(&quot;sadsf&quot;); }); //10. 각자 따로 노는 기능들을 그냥 단순 조합만 하면 무슨 의미가 있을까? // 그냥 static메서드 모아놓은 것과 같은 효과일뿐이다? // -&gt; 1개의 Type안에 method가 여러개다? -&gt; 공유하고 있는 필드정보가 있어야 의미가 있는 것이다. // --&gt; delegate를 활용하여 각각 따로 기능을 구현한 interface가 공통정보를 활용하는 방법이 있다.?! } //8. 이제 marker인터페이스 및 default method를 추가하여 새로운 기능을 추가한 Type으로 확장해보자. interface Printer { default void print(String str) { System.out.println(str); } } // cf) 일반 람다식은 파라미터를 함수형인페로 안잡아주는데, 캐스팅하니까 바로 잡아준다. // 2. 일단은 함수형인페 이하로 upper bound를 준 제네릭 메서드로 변경한다. //private static void run(final Function function) { //3. 이번엔 upperbound에 intersection을 거는 것이 아니라 // -&gt; [함수형인페 Consumer&lt;T&gt;]를 메소드 파라미터로 추가한다. // --&gt; 컨슈머T(void accept(T t);)는 accept기능을 가지는데, return은 없고 파라미터만 있다 // &gt; 반대로 Supplier&lt;T&gt;는 get기능을 가지는데, 파라미터는 없고, return만 T type이다. // [컨슈머T를 썼다 -&gt; 뭔가 Lambda object(람다식 구현의 우항)를 갖다주면, &lt;&lt; 그걸 파라미터로 받는 메소드 내부에서 응답없이 .accept( 인자 )로 넘어온 lambda object(우항)을 사용하기만 할 수 있다&gt;&gt; 는 뜻이다] //private static &lt;T extends Function&gt; void run(final T t) { private static &lt;T extends Function&gt; void run(final T t, final Consumer&lt;T&gt; consumer) { // 4. 그렇다면, run내부에서 호출되었던 t.hello();, t.hi();들을 // -&gt; consumer 인자부분에서 lambda object(우항)에 담아서 던져주고 // consumer.accept(t)로 lambda object(컨슈머 람다식 우항)를 return없이 실행만 시킨다. consumer.accept(t); } } . 람다식구현 인자용 함수형인페&lt;T&gt;를 상속한 인터페이스로, default method내부에서 변경가능한 람다식에 따른 기능 수행하는 메서드가 된다. . . . . . . . . public class GenericsIntersectionTypeWithDelegate { //1. 지네릭으로서 type 정보 1개를 가진 interface 선언 interface DelegateTo&lt;T&gt; { //2. supplier처럼 인자안받고, 응답만 T type의 객체로 하는, 추상메서드 1개를 선언한다. T delegate(); } //3. 이제 delegateTo 지네릭 인터페이스를 extends로 상속하는 인터페이스를 만든다. // -&gt; 이 때, 지네릭 인터페이스의 type parameter에 구체형을 줘야한다! // -&gt; 또한 확장기능을 추가하기 위해 default method를 추가한다. (총합 1개메서드의 람다식에 카운팅 안되는 메서드) interface Hello extends DelegateTo&lt;String&gt; { default void hello() { //4. 이제 확장기능 뿐만 아니라 + default메서드 속에서 상속한 (함수형)인터페이스의 기능(delegate())를 호출할 수 잇다. // -&gt; 함수형인페 추상메서드는 인자없이 T응답인데 -&gt; DelegateTo&lt;String&gt;으로 박아서 상속했으니 String을 응답할 것이다. System.out.println(&quot;Hello &quot; + delegate()); } } public static void main(final String[] args) { //5. 아까랑 조금 다르다. // -&gt; 바깥에 호출하는 메서드 + 일단 람다식 캐스팅부터 작성한다. // -&gt; 상속한 마지막 인터페이스가 뿐만 아니라, 부모인 함수형인페도 같이 처음부터 적어줘야 // -&gt; 함수형 인페로 인한 람다식 작성이 가능하다. //run((DelegateTo&lt;String&gt; &amp; Hello)) //6. 이번엔 [함수형인페 속 메서드가 인자X의 supplier -&gt; 람다식 구현시 좌항이 빈 ()-&gt;로 출발해야한다] //run((DelegateTo&lt;String&gt; &amp; Hello) () -&gt; ) //7. 인자없는 ()-&gt; 지만, 응답은 T 타입 -&gt; String 이므로 [우항=lambda object]는 String으로 반환해주자. //run((DelegateTo&lt;String&gt; &amp; Hello) () -&gt; &quot;ChoJaeSeong&quot;) //8. 이제 기본적으로 제네릭메서드로서 상한 2개 &amp;&amp; 내부에서 기능호출하는 메서드에서 // 내부호출을 2번재 인자에 [return없이 메서드 호출만 하는 로직 옮기기용 Consumer&lt;T&gt;의 람다식] 작성 // -&gt; 이것을 통해, 상한을 일일히 제네릭 상한으로 안적어주고, Consumer&lt;T&gt;가 1번째 람다식에서 추론해서 갖다쓰게 된다. run((DelegateTo&lt;String&gt; &amp; Hello) () -&gt; &quot;ChoJaeSeong&quot;, o -&gt; { }); //12. 해석 // 1) 람다식 구현() -&gt; &quot;ChoJaeSeong&quot;는, 함수형인터페이스DelegateTo&lt;String&gt; 의 추메 T delegate()의 실제 구현 코드가 되어버린다. // 2) Consumer가 받아온 로직 중 default 메소드 hello 호출 -&gt; 그 내부에 함수형인페 속 추메 delegate() 호출이 있다면? // -&gt; 여기 정해둔 람다식구현이 빨려 들어가 실행된다. // 3) 그 이유는, 타입캐스팅 속 InterSectionType &amp; 로 인해, 뒤쪽 인페의 default method안에 들어있는 부모인터페이스의 메서드 호출시, 앞에 함수형인페의 추상메서드를 그대로 가져와 호출한다.(자바가 인식해준다) run((DelegateTo&lt;String&gt; &amp; Hello) () -&gt; &quot;ChoJaeSeong&quot;, o -&gt; { // 13. 앞에서 intersectionType으로 추가해준 인터페이스는 // 그 앞의 deletage를 상속한 뒤, 그 속의 추메를 내부에서 사용할 수 있게 된다. // -&gt; default 고정 기능이 아닌, 함수형인페를 부모로 상속한 뒤, default method에서 사용 -&gt; // 호출시 람다식에 의해 언제든지 변경가능한 기능을 수행하게 됨됨 o.hello(); }); //14. 람다식 캐스팅 부분에 인터섹션Type을 추가한 뒤, // consumer block에서 새로운 기능을 호출하면, 람다식구현이 그대로 추상메서드 호출 자리에 사용되면서 기능이 추가된다 run((DelegateTo&lt;String&gt; &amp; Hello &amp; UpperCase) () -&gt; &quot;ChoJaeSeong&quot;, o -&gt; { o.upperCase(); }); //15. 이제 람다식을 동적으로 바꿔도 바뀐 체로 기능이 합쳐진다. run((DelegateTo&lt;String&gt; &amp; Hello &amp; UpperCase) () -&gt; &quot;abcde&quot;, o -&gt; { o.upperCase(); }); } //13. 이제 Consumer block안에 새로운 기능을 추가하고 싶다! 하지만, 새로운 클래스를 만들거나 하고 싶진 않다면? // -&gt; 람다식 캐스팅에 인터섹션Type을 추가할 default method의 interface추가 -&gt; [람다식으로 구현하는 delegate()기능 + @]로 기능 추가할 수 있다. //13-1. 똑같이 함수형인페는 상속해서 -&gt; 내부에서 함수형인페를 호출할 수 있어야한다. interface UpperCase extends DelegateTo&lt;String&gt; { default void upperCase() { System.out.println(delegate().toUpperCase()); } } //9. 기본 제네릭 메서드로 정의하며, 람다식의 추상체 파라미터인 인터페이스(DelegateTo&lt;String&gt;) 대신 -&gt; T t로 쓴다. // -&gt; 여기서 말하는 T는 람다식캐스팅 맨 앞의 인터페이스를 T로 본다. // -&gt; 이제 인터페이스를 구현한 것 이후로의 SubType만 받기 위해, T의 상한을 응답형 앞에서 받아준다. // --&gt; 여기서, T는 DelegateTo&lt;&gt;인데, DelegateTo 자체의 type paramter는 다른 것으로 표기해줘야한다. // run은 2개의 type paramter &lt;T, S&gt; 2개를 가지게 된다. // -&gt; Consumer는 delegate에 해당하는 T를 받아와서 람다식에서 호출되도록 한다. // 10. 아까는 Function이라는 함수형인페를 바로 사용했지만, // -&gt; 지금은, DelegateTo라는 자체제작 (메소드1개의 인터페이스-&gt;) 함수형인페 + type이 중요해서 Function에서 안쓰던 제네릭을 붙여서 type을 살린 상태로 // 좀더 복잡해졌다. private static &lt;T extends DelegateTo&lt;S&gt;, S&gt; void run(final T t, final Consumer&lt;T&gt; consumer) { //11. Consumer의 람다식으로 뺀 로직을, 실행context는 여기 메서드 내부에서 시켜주게 한다. // -&gt; my) 람다식구현 인자로 받은 로직 -&gt; 함수형인페로 파라미터로 받아서 -&gt; 로직.실행()의 context는 메서드 내부에서 실행되게 한다. 함수실행로직 작성만 밖에서 // -&gt; my2) 구현체 객체 -&gt; 인터페이스 파라미터 -&gt; 구현체 객체.의 기능 실행()은 메서드 내부에서... consumer.accept(t); } } . 새로운 아이디어와 최종 예제 . 기존: (구현class 후 구현체 인자 대신) 람다식 구현 인자 -&gt; 함수형인페 파라미터 (구현체.추클()호출 대신 정해진메서드()호출하여 내부context로 실행) -&gt; 제네릭 메서드로 변환하되 함수형인페를 T상한으로 -&gt; 여러Type 동시구현을 상한경계 대신 람다식 캐스팅 + Consumer로 밖으로 빼기 . 현재: 일반 인터페이스(메서드 2개이상) 의 기능 다 가지면서 + 새로운 기능을 람다식 캐스팅 했던 것처럼 동적으로 추가하고 싶다 . 더이상 수정할 수 없는 라이브러리에 기능추가 . Repository의 findAll()이 List가 아닌 iterator를 리턴하는데, list로 받으려고 별도의 메서드 만드는 것이 관련있을까? 아님… . | 예제 인터페이스는 이미 4개의 메서드를 가진 인터페이스가 base라서… 람다식 구현(함수형인페-메소드1개를 인자에서 구현)을 받을 수 가 없다. . 람다식의 우항에서 해당 구현체객체를 넘겨주는 람다식을 작성하더라도.. 캐스팅은 안된다?! | . . | . public class GenericsIntersectionTypeWithDelegateExample { //1. List는 구현해야할 추메가 너무 많아서, Pair&lt;T&gt;라는 인터페이스를 하나 정의해준다. interface Pair&lt;T&gt; { // 2. 값을 2개 가질 수 있어서 각각을 꺼낼 수 있는 메서드 2개를 가진다( 함수형인페X -&gt; 람다식으로 인자에서 구현X) // + setter도 2개 가진다. T getFirst(); T getSecond(); void setFirst(T first); void setSecond(T second); } //2. 이제 일반 인터페이스를 구현하는 class를 만든다. // -&gt; 인터페이스 impl할 때, 제네릭 인터페이스면 -&gt; 직접 명시해서 구현하자. static class Name implements Pair&lt;String&gt; { //3. class라서 이제 필드를 만들어, 정보를 보관할 수 있다. private String firstName; private String lastName; public Name(final String firstName, final String lastName) { this.firstName = firstName; this.lastName = lastName; } @Override public String getFirst() { return firstName; } @Override public String getSecond() { return lastName; } @Override public void setFirst(final String first) { this.firstName = first; } @Override public void setSecond(final String second) { this.lastName = second; } } interface DelegateTo&lt;T&gt; { T delegate(); } private static &lt;T extends DelegateTo&lt;S&gt;, S&gt; void run(final T t, final Consumer&lt;T&gt; consumer) { consumer.accept(t); } //7. Forwarding인터페이스를 만들어준다. (~를 넘긴다는 의미) //7-1. 람다식으로 쓰기 위해 함수형인페 Delegate 인터페이스를 상속한다. // - 동적으로 쓰고 싶은 인터페이스 Pair&lt;T&gt;를 함수형인페&lt;T&gt;의 type paramter에 넣어준다. // - Delegate뿐만 아니라, Pair 인터페이스도 상속한다. interface ForwardingPair&lt;T&gt; extends DelegateTo&lt;Pair&lt;T&gt;&gt;, Pair&lt;T&gt; { //7-2. 인터페이스에 있는 여러개의 추상메서드를 -&gt; 상속후 default method로서 오버라이딩 하는 방법이 있다. // (1) 오버라이딩 해서 다 가져온 다음 -&gt; (2) @Override 지우고, default메서드로 바꾸주고 // (3) getter의 경우, DelegateTo 상속으로 호출가능한 delegate()를 호출한다. // -&gt; delegate는 들어오는 T를 응답해주는 supplier 역할인데, 그 T자리에 Pair&lt;T&gt;가 들어가 있으니 // -&gt; pair내부의 여러 추상메서드를 호출하도록 작성한다. // @Override // T getFirst(); default T getFirst() { //8. delegate()하면, elegateTo에 적힌 Type인 pair&lt;T&gt; 타입이 오고 -&gt; 거기서 정의된 메서드를 호출한다. // -&gt; supplier형태의 T응답 DelegateTo&lt;T&gt; 인페를 상속한 인페는 // -&gt; DelegateTo&lt;T&gt;의 T 자리에 넣은, extends DelegateTo&lt;Pair&lt;T&gt;&gt; 상의 [Pair&lt;T&gt;]를 반환해주게 된다. // --&gt; delegate()로 반환된 인터페이스 Pair&lt;T&gt;는.. 그 내부 추상메서드를 호출할 수 있다. return delegate().getFirst(); } default T getSecond() { return delegate().getSecond(); } default void setFirst(T first) { delegate().setFirst(first); } default void setSecond(T second) { delegate().setSecond(second); } } //9. ForwardingPair를 만들면, 인터페이스는 Delegate만 남는다. // -&gt; 그 뒤의 Pair는 이미 안에서 구현된 상태기 때문이다. public static void main(final String[] args) { //4. 생각하면서 람다식구현을 인자로 받는 메서드 -&gt; 그것을 제네릭으로 받는 메서드를 run을 호출해보자. //run(()-&gt;&quot;&quot;, o-&gt;{}); //5. 우리가 원하는 것: 일반인페 기능구현 + 동적으로 기능추가 하고 싶다. // 5-1. 메서드 2개이상의 일반 인터페이스 의 기능을 다 가진다 -&gt; 람다식구현 대입 불가 -&gt; 구현체객체를 만들어, [넣어줘야할 구현체 객체를 람다식 우항에서 제공]해주기 // - 참고) 추상체 인터페이스 파라미터에 넣을, 구현체 객체를 생성할 때도, 변수(좌항)은 추상체로 받아주자.! //final Name name = new Name(&quot;Toby&quot;, &quot;Lee&quot;); final Pair&lt;String&gt; name = new Name(&quot;Toby&quot;, &quot;Lee&quot;); // 5-2. 람다식으로 함수형인페 1개 전체 구현이 아니라, 일반 인페가 받는 구현체 객체를 람다식으러 넣어주면 된다. //run(() () -&gt; name, ); //6. 하지만, 람다식의 우항으로 넘기는 name은 Pair라는 인터페이스를 넘길 수 없는 상황?이다. // -&gt; 람다에서 사용하게 만들고 싶다~! 새로운 아이디어가 필요하다. //10. 이제 람다식 캐스팅을 ForwardingPair라고 놓는다. // -&gt; FP는 DelegateTo를 상속한 상태이므로 // -&gt; DelegateTo를 상한경계로 받는 run의 첫번재 인자 T에 넣어줄 수 있고 ( 람다식의 우항에 supplier -&gt; T t ) // -&gt; 메서드 내부호출될 로직을, 함수형인페로 받아 -&gt; 외부에서 [첫번째 인자에 의해 자동 추론된 Type] 람다식으로 제공 받을 수 있어 // -&gt; 2번째 인자 람다식을 동적으로 넣어줄 수 있다. run((ForwardingPair&lt;String&gt;) () -&gt; name, o -&gt; { System.out.println(&quot;o.getFirst() = &quot; + o.getFirst()); System.out.println(&quot;o.getSecond() = &quot; + o.getSecond()); }); //11. 컨슈머 쪽의 o의 Type은 사실 ForwardingPair이다. // -&gt; ForwardingPair이다는 delegateTo에 해당하는 것이고 // -&gt; delegateTo를 구현하는 메서드는 () -&gt; name 밖이다. // -&gt; 그 우항에서 반환되어 입력되는 name속 메서드는 // -&gt; ForwardingPair가 delete상속후 다 정의를 해놓았으니 // -&gt; o에서 호출해서 쓰기만 하면 된다?! //람다식 타입캐스팅 쓸 수 있는 인터페이스 -&gt; default method는 0개로 침. 함수형 인터페이스..?! //https://www.youtube.com/watch?v=PQ58n0hk7DI&amp;list=PLv-xDnFD-nnmof-yoZQN8Fs2kVljIuFyC&amp;index=11 //1:43:00 c참고하기 } } . 제네릭 기본 적용 예시 모음 . print . //before void print(String value) { System.out.println(value); } //after &lt;T&gt; void print(T t) { System.out.println(t.toString()); } . | countGreaterThan(arr, elem) . //before static long countGreaterThan(Integer[] arr, Integer elem) { return Arrays.stream(arr) .filter(s -&gt; s &gt; elem) .count(); } public static void main(final String[] args) { final Integer[] integers = {1, 2, 3, 4, 5, 6, 7}; System.out.println(&quot;countGreaterThan(integers, 4) = &quot; + countGreaterThan(integers, 4)); } . //after static &lt;T extends Comparable&lt;T&gt;&gt; long genericCountGreaterThan(T[] arr, T elem) { return Arrays.stream(arr) .filter(s -&gt; s.compareTo(elem) &gt; 0) .count(); } public static void main(final String[] args) { final Integer[] integers = {1, 2, 3, 4, 5, 6, 7}; System.out.println(&quot;genericCountGreaterThan(integers, 4) = &quot; + genericCountGreaterThan(integers, 4)); final String[] strings = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;}; System.out.println(&quot;genericCountGreaterThan(strings, &quot;3 &quot;) = &quot; + genericCountGreaterThan(strings, &quot;2&quot;)); } . | isEmpty(list) - 지네릭 메소드 버전 . private static &lt;T&gt; boolean isEmpty(final List&lt;T&gt; list) { return list.size() == 0; } . isEmpty - 내부 로직에 type paramter 미사용으로 unbound wild card로 변경한 버전 | . private static boolean isEmpty(final List&lt;?&gt; list) { return list.size() == 0; } . | frequency(list, elem) - 지네릭 메소드 버전 . private static &lt;T&gt; long frequency(final List&lt;T&gt; list, final T elem) { return list.stream() .filter(s -&gt; s.equals(elem)) .count(); } . frequency - 와일드 카드 버전 **equals비교가 제대로 되려면 List의 원소 vs 원소1개 T를 비교하는 지네릭 메소드가 낫지 않을까?** | equlas의 비교는 사실, 똑같은 Type일 이유가 없다. equals비교 대상으로 허용하지 않는다면, 에러가 날 것이다. | list의 원소Type와 비교할 원소는 다른 Type을 가져가는 경우도 있다. ex&gt; SubType | 동일한Type으로만 비교시, 지네릭 메서드를 쓰면 되겠지만… SubType(구상체)와의 비교도 하기도하고, 자바 api에도 이렇게 설계되어있다. | . | . | . private static long frequency(final List&lt;?&gt; list, final Object elem) { return list.stream() .filter(s -&gt; s.equals(elem)) .count(); } . | max - 제네릭 메소드 버전 . private static &lt;T extends Comparable&lt;T&gt;&gt; T max2(final List&lt;T&gt; list) { return list.stream() .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) .get(); } . wild card 개입 by 메서드 내부 사용시 upper / 메서드 외부용 super | . private static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(final List&lt;? extends T&gt; list) { return list.stream() .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) .get(); } . max - collections(인자인 List내장 Comparator 사용 버전) | . Collections.max(list) . max - collections + Comparable&lt;? super T&gt;예시를 위해, 비교메서드 구성을 Object로 해버리는 직접 Comparator(객체 비교방법) 제시 with 람다 캐스팅 | . Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString())); . | reverse: 지네릭 메서드로는 1개로 표현가능 . private static void reverse(final List&lt;?&gt; list) { final List&lt;?&gt; temp = new ArrayList&lt;&gt;(list); for (int i = 0; i &lt; list.size(); i++) { list.set(i, temp.get(list.size() - i - 1)); } } . private static void reverse(final List&lt;?&gt; list) { reverseHelper(list); } private static &lt;T&gt; void reverseHelper(final List&lt;T&gt; list) { final List&lt;T&gt; temp = new ArrayList&lt;&gt;(list); for (int i = 0; i &lt; list.size(); i++) { list.set(i, temp.get(list.size() - i - 1)); } } . |",
            "url": "blog.chojaeseong.com/java/generic/lambda/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/03/%EC%A0%9C%EB%84%A4%EB%A6%AD2.html",
            "relUrl": "/java/generic/lambda/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/03/%EC%A0%9C%EB%84%A4%EB%A6%AD2.html",
            "date": " • Apr 3, 2022"
        }
        
    
  
    
        ,"post14": {
            "title": "generic 개인공부 1",
            "content": "기본개념 . 제네릭(generic)이란? . 컴파일타임에 타입체크 하여 코드의 안전성을 높여준다. | 우리는 항상 사용하고 있다. . | 정의시 &lt;T&gt;를 타입매개변수라 한다. | List&lt;String&gt;자리에 뭔가를 주었다면 매개변수화된 타입이라고 부른다. | . 제네릭 [타입 지정] 사용 이유 . 컴파일러가 을 알게되어, 런타임 전에 [다른형 생성(add)시] 컴파일 에러가 나 해결됨 . @DisplayName(&quot;&quot;) @Test void lesson9_techTalk_sadly_runtimeError() { // 여러타입 가능한 자료구조라 ArrayList내부에 제네릭으로 정의해놨는데 // 1. 제네릭을 지정 안했줬다면? // 1) 변수추출시, Object로 변&lt;구&gt;제 된다. final List&lt;Object&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;woowacourse&quot;); list.add(1); // 2) 제네릭을 타입 미지정 결과, 아무 형이나 (실수에 의해) 넣을 수 있다. //3) 타입이 다른 것이 들어갔는데, 확인안하고 하나의 타입으로 지정해서 써버리면, 형의 차이때문에, runtimeError가 발생한다. //4) Object형이기 때문에 casting해서 하나의 형으로 받아줬다 -&gt; 그 과정에서 실수로 들어간 다른형이, 런타입 에러를 발생시킨다? final String result = (String) list.get(0) + (String) list.get(1); //5) 즉, 여러형이 들어갈수 잇는 자료구조에서, 제네릭을 안쓴다면, 꺼낼때마다 확인해서 써야한다. } @DisplayName(&quot;&quot;) @Test void lesson9_techTalk_lovely_compileError() { // 여러타입 가능한 자료구조라 ArrayList내부에 제네릭으로 정의해놨는데 // 2. 제네릭&lt;T&gt;타입매개변수를 지정해서 사용한다면? // 1) 컴파일러님께서 알 수 있게 되어, runtime 전에 해결된다. final List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;woowacourse&quot;); // 1) runtimeError까지 가기전에, CompileError를 발생시켜 아무 형이나 집어넣을 수 없게 형 검사를 해준다. list.add(1); } . 컴파일러가 아는 것만 받다보니, [꺼낼 때 (타입검사 후 -&gt;) 캐스팅(타입변환)] 안해줘도됨 . @DisplayName(&quot;&quot;) @Test void lesson10_techTalk() { final List&lt;Object&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;woowacourse&quot;); final Object o1 = list.get(0); // 1) 제네릭 타입미지정시, 캐스팅 안해주면 Object final String result = (String) list.get(0); // 2) 캐스팅 해줘야 생성했던 형/원하는 형으로 구체형 추출가능 } @DisplayName(&quot;&quot;) @Test void lesson10_techTalk_2() { final List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;woowacourse&quot;); final String result = list.get(0); // 1) 제네릭 타입지정해줬다면, 컴파일러가 아는 것만 들어가 있어서, 꺼낼때 캐스팅이 필요없다. } . 주의점) 배열과 다르게, 호..제는 변제와 동치이므로, 완전히 동치일때만 가능하다. . 우항의 호출시 &lt;구체형&gt; 제한은 좌항의 변.&lt;구&gt;.제와 완전히 동치이다. 반면, 우항의 호출시&lt;&gt;. 구체형.지정사용은 변수에 들어가는 놈일 뿐이다. | . | 즉, 좌항의 변구제와 우항의 호구제는 동일해야만 한다. 우항의 호구지와는 다른 개념 | . | . @DisplayName(&quot;&quot;) @Test void lesson11_techTalk_3() { final Object[] arrays = new Integer[1]; List&lt;Object&gt; list1 = new ArrayList&lt;Integer&gt;(); // 호.&lt;구&gt;.제 는 좌변과 완전히 형이 동치여야한다. // 컴팔일러가 알고 있는 변수와 다른 형이기 때문에 컴파일에러가 난다. List&lt;Object&gt; list2 = new ArrayList&lt;&gt;(List.of(1)); // 반면 호&lt;&gt;구.지는 object에 들어가는 것으로서 가능하다. } . . 제네릭 타입 . **형(T)를 파라미터로 가지는 class or interface를 말한다. ** class나 인터페이스 이름 뒤에 꺽쇠로 타입매개변수 class&lt;T&gt; or interface&lt;T&gt;가 붙는다. | . | . 제네릭 [T] 사용 이유 . 상태값(필드값) 등을 Object타입을 사용한 것처럼 모든 타입을 받아들여 저장할 수 있게 된다. . Object타입으로 상태값을 저장할 때 . private class Category { private final Object value; private Category(final Object value) { this.value = value; } public Object getValue() { return value; } } . | 제네릭타입(class)를 쓸 때 . private class GenericCategory&lt;T&gt; { private final T value; public GenericCategory(final T t) { this.value = t; } public T getValue() { return value; } } . | . | Object때와는 다르게, 컴파일러에게 타입을 지정해주고 사용하면 . 컴파일러가 알아서 에러를 내준다. . | 타입확인 -&gt; 타입변환 안해줘도 된다. . | | . 제네릭 메서드 . 메서드 선언부에 제네릭타입이 선언된 것 타입매개변수의 범위가 메서드내로 한정되어, 제네릭타입의 변수와 전혀 별개의 변수임. | . | . 생성자 대신 주입자 메서드(setter) vs 제네릭 메서드 . setter는 상태값(필드)에 주입하는 것이고 . | 제네릭 메서드는 상태값(필드)와는 별개로 지역변수에서 사용하는 타입매개변수를 사용한다. . | 제네릭 메서드 정의 . public &lt;K&gt; void printClassName(K k) { System.out.println(&quot;제네릭 타입의 필드 타입매개변수 = &quot; + this.value.getClass().getName()); System.out.println(&quot;제네릭 메서드 타입매개변수 = &quot; + k.getClass().getName()); } . 생성자든, 메서드든, 호&lt;&gt;.구체형.지정사용하기 | . //1. 제네릭 타입(class)에 저장하는 T는 Noodle형 객체를 호&lt;&gt;.구.지 -&gt; 변.&lt;구&gt;.제로 자동으로 형 제한 final GenericCategory&lt;Noodle&gt; noodleGenericCategory = new GenericCategory&lt;&gt;(new Noodle()); //2. 제네릭 메서드의 타입은, Pasta형을 호&lt;&gt;.구.지정사용 noodleGenericCategory.printClassName(new Pasta()); . 출력 | . 제네릭 타입의 필드 타입매개변수 = MainTest$Noodle 제네릭 메서드 타입매개변수 = MainTest$Pasta . | . 제네릭 타입을 모든형이 아닌, 제한된 타입으로 제한 . Noodle 및 Noodle 자식형들로만 넣고 싶을때? Coke 타입은 못들어오게 막고 싶을 때가 있을 것이다. . . | . P-E, C-S 원칙 + Extends의 와일드카드를 사용하여 T에는 본인 및 그 자식들만 들오게 -&gt; 나머지는 컴파일에러 . P-E, C-S 원칙: 생성자/add 등의 Produce상황에서는 &lt;? Extends &gt;의 와일드카드를 사용하여 T에는 본인 및 그 자식들만 들오도록 상한 경계를 준다. . 컴파일러들이 상한경계+그자식들만 알고 있어 나머지는 컴파일에러를 낸다. | . . | 와일드카드는 코드속 ?로서, 모든 타입이 다 가능하게 한다 . | 그외에 &lt;? super &gt;의 하한 경계는 Consume을 정의할 때 사용한다. . | . . 파라미터 정의시 사용되는 제네릭타입의 타입제한(와일드 카드) . 제네릭타입(class)는 1개 타입 or 상/하한의 타입을 받아 저장하는 자료구조(?)에 사용된다. . | 제네릭타입 자료구조의 타입 지정(제한)을 하면서 &amp;&amp; 그 제네릭타입의 (생성)기능호출은 더 바깥에서 Helper (Static)클래스의 메서드 파라미터에서 변.&lt;구&gt;.제로서 정하여 사용한다고 가정한다. . 참고로.. 호&lt;&gt;.구.지정사용시.. 와일드카드를 사용못하네… 상한 지정해주고 -&gt; 정의부에서 ? extends 상한 으로 바꿔서 파라미터 정의해주기 | . . | 해석 . 01 생성자or메서드 파라미터에 상한의 와일드카드 쓴 제네릭 자료구조 -&gt; (외부에선 하위객체위주로 인자대입)내부 하위class 형 타입을 필드로 가짐 -&gt; 상한class를 setter는 못해줌 But 하위필드를 꺼내 상한(상위class)변수에 할당 및 생성은 가능. . private static class GenericCategoryHelper { public static void popNoodle(final GenericCategory&lt;? extends Noodle&gt; extendsNoodleCategory) { // 1) Noodle 및 그이하가 꺼내지면 -&gt; 하위class로 생각 -&gt; 우항에 꺼낼 수 있다. -&gt; 경계이면서 상위class인 Noodle에 다 받을 수 있다. (모든 경우) final Noodle noodle = extendsNoodleCategory.getValue(); // 2) 하지만, 내부 하위class 필드를 가진다고 보면 -&gt; 경계이면서 상위class인 Noodle의 값을 우항으로 대입할 수 없다. // -&gt; 모든 경우가 만족안되서 컴파일 에러가 난다. // extendsNoodleCategory.setValue(new Noodle()); } . . 제네릭타입은 주로, 해당 자료구조 사용처 메서드에서, 파라미터에서 상하한제한을 와일드카드로 건다 파라미터쪽으로 외부에서는 최상위 형이하로 들어온다 | 이하로 들어온다고 보장받으면 꺼내는 것(getter), 꺼낸 것을 주입하여 생성하는 것은 OK이다. 꺼낸 값을 변수가 부모&amp;추상체에 해당하는 상한을 지정해주면로 그 이하를 모저리 받을 수 있기 때문이다. 우항: 꺼낸 것 -&gt; Noodle과 Noodle이하 | 좌항: 변수, 주입되서 생성 -&gt; Noodle로 지정해주면 그 이하 다 받아줌 | . | . | | 02 생성자or메서드 파라미터에 하한의 와일드카드 쓴 제네릭 자료구조 -&gt; (외부에선 상위객체위주로 인자대입)내부 상위class필드를 가짐 -&gt; 하한이하의 하위class 대입(저장) 가능 + 꺼내면, 상위class기 때문에 경계의 하위class에 값꺼내 할당은 불가능 . public static void pushNoodle(final GenericCategory&lt;? super Noodle&gt; superNoodleCategory) { //1) Noodle 및 그 이상이 꺼내지면 -&gt; 그 자료구조(내부 변수) 상위class 필드에 &lt;- 하위class객체(Noodle)를 setter할 수 있다 superNoodleCategory.setValue(new Noodle()); //2) 하지만, 상위class 필드를 꺼내 -&gt; 하위타입인 하한(Noodle) 담을 순 없다. //final Noodle noodle = superNoodleCategory.getValue(); } . . 예시1) 제네릭타입 E -&gt; 제네릭메서드에 E(타입매개변수)에 대한 상/하한 제한 with PECS . 제네릭메서드에 ? extends E(제네릭타입의 타입매개변수)로 상한제한(내부하위필드or하위값)을 하면, 꺼낸 값(E하위)이 내부필드(제타의 내부필드 E고정)에 대해 안전하여 제타E에, 외부에서 들어올 제네릭메서드 파라미터 값들을 안전하게 값 할당 -&gt; 제타필드를 Produce해주기가 가능 . . 제네릭메서드에 ? super E(제네릭타입의 타입매개변수)로 하한제한(내부상위필드or상위값)을 하면, 상위필드를 가진 자료구조로 생각하고 내부필드(제타의 내부필드 E고정)가 하위값으로 소비하는 것에 안전하여 외부에서 들어올 제네릭메서드 파라미터 값들(X) 상위필드 자료구조 -&gt; 제타E의 하위값들 안전하게 대입 -&gt; 제타필드를 Consumer해주기가 가능 . . PECS에서 P와 C는 제네릭타입(class, interface)속 필드를 생성(초기화)해주느냐, 갖다쓰느냐의 이야기였다. . 제네릭 타입소거 . 컴파일타임에 타입을 검사 | 런타임에는 소거 해당 정보를 알 수 없다. | Java 5에서 등장했기 때문 | . | 4이전 기존코드도 돌아가게 하기 위해 타입소거가 등장함. | . . 오브젝트 . 오브젝트 속 if instanceof(타입검사)를 줄이는 generic . 내 생각 . Object가 모든 타입을 받아들였지만, 각 instance검사후 타입캐스팅(타입변환후) 작업하는 것처럼하는것 처럼 | 추상체는 여러 구상체를 받을 수 있지만, 각 구상체마다 하는 일이 달라진다면, 전략패턴을 썼었고 | 여러 구상체를 받는 외부 추상체를 파라미터로 받아 들어오는 구상체마다 instanceof로 자신 내부의 일이 달라지는 클래스가 있다면 외부 추상체를 T형으로 받고, class옆에는 ? extends T의 상한제한을 걸어주면 | 외부 추상체로만 알아서 instanceof를 쓰던 타 클래스에서 제네릭 적용을 통해 외부 특정 구상체를 아는 타 클래스가 되도록 한다. | . | 외부 특정 구상체를 아는 제네릭 타클래스가 만약, 추상클래스 + 템메패턴이라면 -&gt; 자식클래스 또한 제네릭 타클래스&lt;T&gt;의 제네릭을 받는 추상클래스로 선언할 수 있고, new 자식()을 만들어도, 추상클래스로서 {}중괄호로 실시간 다르게 구현해야만 한다. | |",
            "url": "blog.chojaeseong.com/java/generic/%ED%85%8C%EC%BD%94%ED%86%A1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/03/%EC%A0%9C%EB%84%A4%EB%A6%AD1.html",
            "relUrl": "/java/generic/%ED%85%8C%EC%BD%94%ED%86%A1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/03/%EC%A0%9C%EB%84%A4%EB%A6%AD1.html",
            "date": " • Apr 3, 2022"
        }
        
    
  
    
        ,"post15": {
            "title": "command 분기 제거를 인터페이스+enum",
            "content": "전략패턴처럼 분기를 추상화하되, 외부주입 대신 enum에서 구현체 받아오기 . 01 일단 1개 분기에 대해서 전략package&gt;구현체1개 -&gt; 내부 구현체클래스.전메()로 1개만 먼저 만들기 . 각 분기별 전체 로직이 추상체변수. 전메()로 실행될 수 있도록 1개 분기를 예시로 구현체class생성 -&gt; 전메로 로직 일괄호출()하도록 메서드를 만든다. | | . public void run() { final PairProgram pairProgram = new PairProgram(); while (!pairProgram.isOff()) { final Menu menu = Menu.from(inputView.inputMenu()); if (menu == Menu.MENU_1) { pairMatch(pairProgram); } if (menu == Menu.MENU_2) { pairSelect(pairProgram); } if (menu == Menu.MENU_3) { pairProgram.initPairs(); } if (menu == Menu.MENU_Q) { pairExit(pairProgram); } } } . . . . . . . . 02 1개 구현체속 전메가 완성 -&gt; @override를 붙여서 인터페이스로 뺀다. . . . . 03 뽑아낸 전략추상체.전메()로 로직상의 구현체.전메()를 대신해야한다. 구현체들의 외부주입의 전략패턴이 아니라면? -&gt; enum의 필드에 함형로 구현체들을 매핑해놓고 가져다 사용해야한다. enum필드 = 함형 Type이다. . . 원래는 구현체 1개 -&gt; 추상체로 바꾸고 -&gt; 그 추상체를 변수or파라미터에서 받아서 외부제공해줘야하는데, 여기서는 enum에게 메세지를 던져서 해당 구현체가 나오도록 던져져야한다. . . 분기마다 구현체실행되니 -&gt; 선택된 enum의 field에 분기별 구현체 생성 매핑해둔다. 이 때, enum의 구현체 매핑 필드 변수가 구현체 생성호출하는 함수형인터페이스&lt;추상체&gt;가 된다. | . | enum에게 메세지를 던져 현재 선택된 구현체에 구현체.전메()를 쓸 수 있도록 추상체.전메()로 정의해준다. | enum에게 메세지를 던질 시, . | enum으로 가서, 각 필드마다, 분기에서 추상체.전메()형태로 사용될 new 구현체()들을 생성할 수있게 함수형인터페이스로 정의해주고, 필드의 변수명을 함형&lt;추상체&gt;로 받아준다. . | . 1) 추상체 객체 통로를 통한 구현체 외부주입(전략패턴)이 아니라, 2) 추상체 객체 통로없이 enum의 추상체 필드에 매핑된 구현체 가져오는 방법을 쓴다. (외부주입될 구현체들은 enum에 메달려 있고(매핑), 그것을 enum특성으로 돌면서 찾아거 가져온다.) . . 변수자리에 함수호출(생성자호출하여 객체생성)을 매핑하고 싶다면, () -&gt; {} 람다로 정의해두고 필드는 함수형인터페이스로 정의해주면 된다. . . . . 이넘에 넣어줄 생성자호출함수 정의하면서 나머지 분기도 다 정리해준다. . . 그냥 기존 구현체 1개를 드래그해서 복붙해서 생성하는게 더 빠를지도? . . | . . 그냥 첨부터 enum. 메달린구현체getter()로 해주면 된다. 이제 알아서 구현체를 가져온 상태 -&gt; 전메만 호출시켠 알아서 각 분기속 로직이 작동된다. . . . . public void run() { final PairProgram pairProgram = new PairProgram(); while (!pairProgram.isOff()) { final Menu menu = Menu.from(inputView.inputMenu()); new PairMatch().execute(inputView, outputView, pairProgram); final Supplier&lt;CommandMenu&gt; commandMenuGenerator = menu.getCommandMenuGenerator(); final CommandMenu commandMenu = commandMenuGenerator.get(); commandMenu.execute(inputView, outputView, pairProgram); } } . input -&gt; output -&gt; input 꼬리를 무는 controller 속 순서로직 -&gt; 메세지보내서 내부에서 처리 . 최초 시작 객체에 메세지를 던지면 된다. 메세지를 던질 때는, 첨부터 필요한 재료를 다 던져서, 책임을 위임한다. . 첫시작객체.메세지를 가장 마지막 메서드()로 | . . | . . 메서드추출로 해주는게 편하다 -&gt; 메세지를 보낼 시작객체만 앞으로 빼면 된다. . . | . . 빨간줄뜨는 메소드내 없는 객체 -&gt; 파라미터로 추출 . 자기자신이 메세지보내고 있는 객체. -&gt; 생략 | 자기자신이 파라미터로 들어간다? -&gt; this | . . | . .",
            "url": "blog.chojaeseong.com/java/%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%8C%A8%ED%84%B4/%EB%B6%84%EA%B8%B0%EC%A0%9C%EA%B1%B0/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/enum/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%B2%B4%EC%8A%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/03/%EB%B6%84%EA%B8%B0%EC%A0%9C%EA%B1%B0-%EC%9D%B8%ED%8E%98%EC%B6%94%EC%83%81%ED%99%94%ED%9B%84-%ED%86%B5%EB%A1%9C+%EA%B5%AC%ED%98%84%EC%B2%B4-%EC%A3%BC%EC%9E%85%EC%9D%84-enum%EC%97%90%EC%84%9C-%EB%B0%9B%EA%B8%B0.html",
            "relUrl": "/java/%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%8C%A8%ED%84%B4/%EB%B6%84%EA%B8%B0%EC%A0%9C%EA%B1%B0/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/enum/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%B2%B4%EC%8A%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/03/%EB%B6%84%EA%B8%B0%EC%A0%9C%EA%B1%B0-%EC%9D%B8%ED%8E%98%EC%B6%94%EC%83%81%ED%99%94%ED%9B%84-%ED%86%B5%EB%A1%9C+%EA%B5%AC%ED%98%84%EC%B2%B4-%EC%A3%BC%EC%9E%85%EC%9D%84-enum%EC%97%90%EC%84%9C-%EB%B0%9B%EA%B8%B0.html",
            "date": " • Apr 3, 2022"
        }
        
    
  
    
        ,"post16": {
            "title": "while 분기속 if break; 리팩토링",
            "content": "while(true) if break; 로 먼저 작성하기 . 01 while(ture)의 무한반복문에서 break;분기부터 작성해보기 . public class MyApplication { public static void main(final String[] args) { // 0. input객체 + 메인로직 특정객체 미리 만들어두기 final InputView inputView = new InputView(); final 특정객체 특정객체 = new 특정객체(); // 1. 일단 while(true) {} 로 돌아가면서 break부터 생각해본다. while (true) { // 1-1. 매번 받는 입력도 돌아가야한다. final String inputCommand = inputView.inputCommand(); // 1-2. 가장 간단한 경우부터 생각해본다. 어차피 if break; if continue; 일듯 싶어서 if (inputCommand.equals(&quot;end&quot;)) { } } private static class 특정객체 { } } . public class MyApplication { public static void main(final String[] args) { final InputView inputView = new InputView(); final 특정객체 특정객체 = new 특정객체(); while (true) { final String inputCommand = inputView.inputCommand(); // 1-3. if 종료버튼 + if 특정객체 종료조건 까지 걸려서 멈춘다고 한다. // -&gt; end를 눌럿을 때, ready / running / finished 중 finished 상태만 -&gt; 로직종료 + 입력도 종료(break;) if (inputCommand.equals(&quot;end&quot;)) { if (특정객체.isNotRunning()) { break; } } } } private static class 특정객체 { public boolean isNotRunning() { return true; } } } . 02 break;를 가진 분기를 만들었다면, 편하게 나머지 분기들을 늘려도 된다. 대신, if 속 break;는 flag로 밖에 처리 못하니, while문 맨 끝에 배치하고, 위로 채워가자?! . 여기선, if 종료버튼 눌른 뒤, if 특정조건 아니면 break;종료를 안한다. (게임 결과 출력은 Finished상태가 아니라, RunningToFinished되는 game.end()호출 순간이다.) . public class MyApplication { public static void main(final String[] args) { final InputView inputView = new InputView(); final 특정객체 특정객체 = new 특정객체(); while (true) { final String inputCommand = inputView.inputCommand(); // 1-3. if에 if 특정객체에 조건 까지 걸려서 멈춘다고 한다. // -&gt; end를 눌럿을 때, ready / running / finished 중 finished 상태만 -&gt; 로직종료 + 입력도 종료(break;) if (inputCommand.equals(&quot;end&quot;)) { // 1-4-1. end눌렀을 때 상태3개 중 ready/running/finished , 바로 finished 상태면 바로 종료?? ready -&gt; 바로 종료 if (특정객체.isNotRunning()) { break; } //1-4-2. break;로 바로 종료(ready/finished)의 배반인 running 상태 // -&gt; if early return처럼 early break 아래부분도 [if의 배반]이다. // -&gt; end 눌렀는데 아직 특정객체가 Running 중 이라면? // (1) running중인 정보(board)를 가지고 finished상태로 만들도록 명령한 뒤 특정객체.end(); // (2) 이 때만(ready(X), finsihed(X) running to finished by .end() )시에만 게임결과를 출력한다. // my) running -&gt; finished 순간을 캐취해서 게임결과를 출력해줘야한다. (가만히 있는 finished는 출력할 필요도 없이 종료) System.out.println(&quot;게임 하다가 끝났기 때문에, 게임 결과를 출력합니다.&quot;); } } } private static class 특정객체 { private String state; public 특정객체() { this.state = &quot;running&quot;; } public boolean isNotRunning() { if (this.state.equals(&quot;running&quot;)) { System.out.println(&quot;running상태입니다.&quot;); return false; } System.out.println(&quot;ready or finished상태입니다.&quot;); return true; // ready나 finished상태 } public void end() { System.out.println(&quot;상태가 running -&gt; finished&quot;); this.state = &quot;finished&quot;; } } } . state패턴으로서 start명령어가 있다면, ready가 기본이 된다. (end만 있을 땐 running을 기본으로 해서 게임-&gt;종료되는 상황 연출) . public class MyApplication { public static void main(final String[] args) { final InputView inputView = new InputView(); final 특정객체 특정객체 = new 특정객체(); while (true) { final String inputCommand = inputView.inputCommand(); //1-5-1. start명령어를 받는 순간부터, ready가 default이며, start에 의해 ready to Running으로 넘어간다. if (inputCommand.equals(&quot;end&quot;)) { if (특정객체.isNotRunning()) { break; } // (1) running중인 정보(board)를 가지고 finished상태로 만들도록 명령한 뒤 특정객체.end(); // (2) 이 때만(ready(X), finsihed(X) running to finished by .end() )시에만 게임결과를 출력한다. // my) running -&gt; finished 순간을 캐취해서 게임결과를 출력해줘야한다. (가만히 있는 finished는 출력할 필요도 없이 종료) System.out.println(&quot;게임 하다가 끝났기 때문에, 게임 결과를 출력합니다.&quot;); } } } private static class 특정객체 { private String state; public 특정객체() { // this.state = &quot;running&quot;; this.state = &quot;ready&quot;; // 1-5-2. start명령어가 있다면, ready가 기본이 된다. } public boolean isNotRunning() { if (this.state.equals(&quot;running&quot;)) { System.out.println(&quot;running상태입니다.&quot;); return false; } System.out.println(&quot;ready or finished상태입니다.&quot;); return true; // ready나 finished상태 } public void end() { System.out.println(&quot;상태가 running -&gt; finished&quot;); this.state = &quot;finished&quot;; } } } . 03 아주 만약, 모든 분기마다 자기일 끝나고 맨 마지막에 공통로직을 처리해줘야한다면, 굳이 continue;(반복문의 ealry return)로 아래로 내려가는 것을 안 막는다. . 각 분기 중 택1을 작업후, 다 제끼고 내려와, 분기없이 실행되는 로직(ex&gt; 무한반복문 아니라면 while조건속에 들어갈 count++변수 업데이트?) . my) 반복문 속 분기이후 공통로직/업데이트로직이 있는 남아있다면, continue;를 안쓴다. 만약, 맨 아래 공통로직 없이 분기 택1의 로직만 일어난다면 continue;로 아래로 내려가는 것을 막아 검사조차 안되게 하자. . public static void main(final String[] args) { final InputView inputView = new InputView(); final 특정객체 특정객체 = new 특정객체(); while (true) { final String inputCommand = inputView.inputCommand(); if (inputCommand.equals(&quot;start&quot;)) { 특정객체.start(); System.out.println(&quot;게임을 시작합니다.&quot;); //continue; // while continue 여부는 분기외에 아래 달릴 로직을 거치느냐 안거치느냐 차이 // -&gt; [공통로직 ]있으면 continue를 빼고 거치게 하지만, 택1의 분기라면 continue;를 달아주자. // -&gt; 지금은 맨 아래 print가 공통로직이라고 치고 있으니 continue;를 제거하자. } if (inputCommand.equals(&quot;end&quot;)) { if (특정객체.isNotRunning()) { break; } 특정객체.end(); System.out.println(&quot;게임 하다가 끝났기 때문에, 게임 결과를 출력합니다.&quot;); } // 공통로직을 매 입력-회전마다 거치는 경우에는 continue;를 쓰면 안된다. System.out.println(&quot;공통로직입니다. 한바퀴돌고 재입력받기 직전입니다.&quot;); } } . while(true) 반복문 속 if break;의 메서드 추출 . 01 if 종료조건 break; 는 메서드 추출을 위해 -&gt; if 종료조건 flag변수(Enum) Off처리; + continue;로 while조건문으로 보낸 뒤 -&gt; while조건문에 flag검사( not isOff()? )로 변경한다. . break; 대신 돌아가는 로직 객체의 flag변수(enum)에 .end()처리를 하고, continue;로 아래론 못가고, while문으로 가서 조건 검사를 바로 하게 한다. . 그림에선 boolean변수에 true/false를 주지만 캡슐화 및 확장성을 고려하여 enum으로 flag변수를 가지게 한다. . 메인로직을 담당하는 객체에 flag(enum)변수를 항상 변할수있는 상태값으로 가지게 한다. | . . ​ ​ . | . while (true) { final String inputCommand = inputView.inputCommand(); if (inputCommand.equals(&quot;start&quot;)) { 특정객체.start(); System.out.println(&quot;게임을 시작합니다.&quot;); } if (inputCommand.equals(&quot;end&quot;)) { if (특정객체.isNotRunning()) { //break; 특정객체.exit(); // flag isEnd = true; continue; // break; 대신 밑으로 못내려가게 일단 막아주자. } 특정객체.end(); System.out.println(&quot;게임 하다가 끝났기 때문에, 게임 결과를 출력합니다.&quot;); } if (inputCommand.equals(&quot;status&quot;)) { System.out.println(&quot;갑자기 결과를 출력합니다. &quot;); } } . private static class 특정객체 { private String state; private boolean isEnd; //... public void exit() { this.isEnd = true; } } . 02 flag .off() 처리후 continue;로 올라간 조건문 검사를 while (true) -&gt; 플래그변수가.isOff()인지 검사로 변경한다. . flag isEnd = true; 하는 순간, 다 continue (or return되서 ) while 조건문으로 보내야한다 조건문에서는 flag를 확인하여 입력과 반복을 종료시킨다 | . | . . 반복문은 break;였던 자리가 flag에 걸려서 종료되기 전까지 돌아야한다 !를 달아준다. | . | . . public class MyApplication { public static void main(final String[] args) { final InputView inputView = new InputView(); final 특정객체 특정객체 = new 특정객체(); //while (true) { while (!특정객체.isEnd()) { final String inputCommand = inputView.inputCommand(); if (inputCommand.equals(&quot;start&quot;)) { 특정객체.start(); System.out.println(&quot;게임을 시작합니다.&quot;); } if (inputCommand.equals(&quot;end&quot;)) { if (특정객체.isNotRunning()) { //break; 특정객체.exit(); // flag isEnd = true; continue; // break; 대신 밑으로 못내려가게 일단 막아주자. } 특정객체.end(); System.out.println(&quot;게임 하다가 끝났기 때문에, 게임 결과를 출력합니다.&quot;); } if (inputCommand.equals(&quot;status&quot;)) { System.out.println(&quot;갑자기 결과를 출력합니다. &quot;); } } } private static class 특정객체 { private String state; private boolean isEnd; //... public boolean isEnd() { return this.isEnd; } } } . 03 if break; -&gt; if flagOff + contine + while flag isOff()검사 해줬어도 if조건식에 extract method는 depth를 못 줄인다 . if + if전체를 추출하려고 하면, . 바깥if의 boolean문만 파라미터 추출 -&gt; t/f 메서드로 추출하여 통째로 넘어간다 | . . | 내부if 부분만 추출하려고 하면 . 내부 if 조건문 속 boolean문만 파라미터 추출 -&gt; true/false의 메서드 추출하여 통째로 넘어간다 . . . | . | 04 if조건문의 메서드추출은 수동으로 통째로 . if 문 위에 추출할 메서드를 빨간줄 작성후 생성 . . . 05 복붙으로 코드 옮겨가고 flag변수.Off() 처리후 continue; 대신 -&gt; 1) early return; + 2) 추출메서드를 while문 맨 뒤에 배치하여 flag처리 직후 while조건문 검사하는 continue;효과내기 . . . public static void main(final String[] args) { final InputView inputView = new InputView(); final 특정객체 특정객체 = new 특정객체(); //while (true) { while (!특정객체.isEnd()) { final String inputCommand = inputView.inputCommand(); if (inputCommand.equals(&quot;start&quot;)) { 특정객체.start(); System.out.println(&quot;게임을 시작합니다.&quot;); } if (inputCommand.equals(&quot;end&quot;)) { depth줄이기위한if통째로추출(); } if (inputCommand.equals(&quot;status&quot;)) { System.out.println(&quot;갑자기 결과를 출력합니다. &quot;); } } } private static void depth줄이기위한if통째로추출() { if (특정객체.isNotRunning()) { 특정객체.exit(); // flag isEnd = true; //continue; return; // 통째로 추출이기 때문에 return;하면 해당 분기 종료되므로 break; continue; early return기능은 있지만 + flag처리 직후 while조건문 검사기능은 구현불가능하다. // -&gt; 지금은 분기 택1의 로직만 일어나므로 바로 while문 검사하러 간다. // -&gt; 만약, return 아래로 더 내려간다면? 남은로직 or 공통로직이 있다면? -&gt; continue;를 return;후에 처버려야할듯? // depth추출 메서드를 빠져나갔는데 바로 while문으로 안가면 -&gt; 빠져나가 만나는 분기마다 continue; } 특정객체.end(); System.out.println(&quot;게임 하다가 끝났기 때문에, 게임 결과를 출력합니다.&quot;); } . while문을 재귀로 고치기 . 01 while속 돌아가는 모든 (분기)로직들을 통으로 1개 메서드로 추출 . . inputView는 원래 컨트롤러 속이라면 상태값을 가지고 있을 예정이기 때문에 일단 파라미터에 제외시켜야함 . . | . public static void main(final String[] args) { final InputView inputView = new InputView(); final 특정객체 특정객체 = new 특정객체(); while (!특정객체.isEnd()) { playGame(특정객체); } } private static void playGame(final 특정객체 특정객체) { final String inputCommand = new InputView().inputCommand(); if (inputCommand.equals(&quot;start&quot;)) { 특정객체.start(); System.out.println(&quot;게임을 시작합니다.&quot;); } if (inputCommand.equals(&quot;end&quot;)) { depth줄이기위한if통째로추출(); } if (inputCommand.equals(&quot;status&quot;)) { System.out.println(&quot;갑자기 결과를 출력합니다. &quot;); } } . 02 while !EndFlag 조건문 = flag 확인문 -&gt; 재귀 속 break(EndFlag)하는 종착역으로서 먼저 if early return로 정의해주기 . 기존 while (! 끝나는 조건) -&gt; if 끝나는조건 : 재귀함수 return . . . | . . 재귀함수는 종착역인 if flag isEND() :return;이 반복문의 break와 동일하게 반복을 제거한다 . . 03 반복되던 로직의 if return종착역까지 완성됬으면 -&gt; 함수 끝날 때 자신(메서드) 부르기 . 내부 if return의 종착역만 있다면, 편하게 마지막에 한번 더 호출하여 반복하는 재귀함수를 만들 수 있다. . . public static void main(final String[] args) { final 특정객체 특정객체 = new 특정객체(); playGame(특정객체); } private static void playGame(final 특정객체 특정객체) { if (특정객체.isEnd()) { return; } final String inputCommand = new InputView().inputCommand(); if (inputCommand.equals(&quot;start&quot;)) { 특정객체.start(); System.out.println(&quot;게임을 시작합니다.&quot;); } if (inputCommand.equals(&quot;end&quot;)) { depth줄이기위한if통째로추출(); } if (inputCommand.equals(&quot;status&quot;)) { System.out.println(&quot;갑자기 결과를 출력합니다. &quot;); } playGame(특정객체); } . 04 while to 재귀로 만든 이유 -&gt; inputView가 포함된&amp;&amp;입력받는 것부터 시작하는 로직은 try로 살펴보는 시작이 input부터이면서 &amp;&amp; catch시 다시 input부터 시작하도록 재귀함수형태를 만들어하므로 . 01 1번만 성공적으로 input받는 로직과 다르게 try 끝에 성공했어도 반복되기 위해 재귀호출을 한다. 1번만 호출되려면 catch로 실패시 재귀호출하여 시도함 . . 02 catch에서 실패한 경우 input부터 다시 받기 위한 재귀호출 vs try끝에 thr없는 성공했는데도 반복을 위한 재귀호출 . . private static void playGame(final 특정객체 특정객체) { if (특정객체.isEnd()) { return; } //1. 일단 input부터 try로 살펴봐야한다. try { final String inputCommand = new InputView().inputCommand(); if (inputCommand.equals(&quot;start&quot;)) { 특정객체.start(); System.out.println(&quot;게임을 시작합니다.&quot;); } if (inputCommand.equals(&quot;end&quot;)) { depth줄이기위한if통째로추출(); } if (inputCommand.equals(&quot;status&quot;)) { System.out.println(&quot;갑자기 결과를 출력합니다. &quot;); } //2. 실패하지 않았지만, if 종착역 = flag걸리기 전까지 반복을 위해 재귀호출 playGame(특정객체); } catch (Exception e) { System.out.println(&quot;[ERROR] &quot; + e.getMessage()); //3. try로 [input부터 시작하는 로직]살펴보다가 thr걸릴 때, [input부터 다시 받기 위한 재귀 호출] playGame(특정객체); } } . my) input부터 시작하는 로직을 재귀함수로 만들면, try input부터 살펴보는 중에 실패하면 -&gt; catch에서 재귀호출하여 다시 input부터 시작할 수 있다. . Enum과 명령어 문자열 캡슐화 + 외부input시 검증까지 . 01 갯수가 정해진 input명령어들(문자열상수)은 분기비교에 사용시 enum객체필드에 캡슐화해놓고 사용하기 . 명령어 객체 -&gt; 복붙해서 문자열에 넣고 소문자로 만들기 | . . . . 02 일단은 분기 속 input문자열 vs 비교문자열 -&gt; Enum from정펙매( input ) VS enum객체로 바꿔서 비교하기 . my) 컨트롤러에서 상수 쓰지말고input을 정펙매에 넣어 찾아진 ENum객체 vs 상수캡슐화한 enum으로 비교 + enum은 스태틱변수라 메모리값 1개 -&gt; equals 안써도 된다. . . . input -&gt; 정펙메에서 전체 돌기 + filter로 해당 enum객체를 구분하여 생성한다 | . . 마찬가지로 input -&gt; enum.from( input ) | “문자열” -&gt; Enum.문자열캡슐화한객체 | . | . . private static void playGame(final 특정객체 특정객체) { if (특정객체.isEnd()) { return; } try { final String inputCommand = new InputView().inputCommand(); //if (inputCommand.equals(&quot;start&quot;)) { if (MyCommand.from(inputCommand) == MyCommand.START) { 특정객체.start(); System.out.println(&quot;게임을 시작합니다.&quot;); } if (MyCommand.from(inputCommand) == MyCommand.END) { depth줄이기위한if통째로추출(); } if (MyCommand.from(inputCommand) == MyCommand.STATUS) { System.out.println(&quot;갑자기 결과를 출력합니다. &quot;); } playGame(특정객체); } catch (Exception e) { System.out.println(&quot;[ERROR] &quot; + e.getMessage()); playGame(특정객체); } } . 03 외부 input으로 찾는 Enum정펙매은 기본적으로 이넘객체들에 캡슐화되어매핑된 문자열들로 -&gt; contains thr 검증이 자동 되며 + 외부input NullOrEmpty를 여기서도 할 수 있다. . enum 외부input 검증01 - 기본적으로 filter사용 == contains 검증 : filter에서 외부input이 내부캡슐화된 문자열에 속하지 않아 못찾으면 orElseThrow에서 에러thr나게 됨. . 외부 input -&gt; Enum정펙매 from -&gt; filter( 캡슐화된 문자열 .equals 외부 input) . filter에 안걸리는 것 = 캡슐화된 문자열에 속하지 않은 것 -&gt; thr | try로 input부터 보고있었으면 검증되서 다시 받는다. | . . | . enum 외부input 검증02 - 추가적으로 checkNullOrEmpty : 찾아들어가기전에 외부 input의 nullOrEmpty검사를 정펙매 여기서 해줄 수 있다. 왜냐? 재귀에서 input부터 처다보고 있는 상황이니까 반복됨. . . . . public enum MyCommand { START(&quot;start&quot;), END(&quot;end&quot;), STATUS(&quot;status&quot;), ; private final String value; MyCommand(final String value) { this.value = value; } public static MyCommand from(final String inputCommand) { checkNullOrEmpty(inputCommand); return Arrays.stream(MyCommand.values()) .filter(it -&gt; it.value.equals(inputCommand)) .findFirst() .orElseThrow(() -&gt; new IllegalArgumentException(&quot;잘못된 명령어입니다.&quot;)); } private static void checkNullOrEmpty(final String inputCommand) { Objects.requireNonNull(inputCommand, &quot;빈칸 입력은 허용하지 않는다.&quot;); if (inputCommand.trim().isEmpty()) { throw new IllegalArgumentException(&quot;빈칸 입력은 허용하지 않는다.&quot;); } } } . 외부input으로 찾는 Enum의 filter에 정규식을 쓰면? . 01 equals()는 Pattern.matches()에 포함되며 일치를 포함하여 일치를 포함하여 패턴을 가지는 문자열도 처리 . . 추가 캡슐화 문자열 -&gt; Enum객체가 생겼다. 어차피 개별 비교라서 상관은 없다 | . | 하지만 개별비교가 equals에서 패턴매칭으로 달라진다면? 상관없다. 패턴매칭은 equals를 포함한다 | . | . . 원래 Pattern 클래스는 .complie()로 패턴을 만들고 . 이후 Matcher.matches()를 써서 비교했던 것 같은데 . Matches없이 한번에 matches()로 t/f를 반환시킬 수 있다. | . . | . | . 02 equals() -&gt; Pattern.matches()로 교환했다면 nullOrempty 검증도 패턴매칭에 포함된다. . enum 외부input 검증03 - Patter.matches()를 쓸 경우 : nullOrEmpty검증도 매칭안되는 것에 걸려 검증된다. . . . . . enum으로 분기 제거까지 적용하려면? . 외부input + 정펙매로 해당 enum객체 -&gt; 해당 분기로직을 분기별 해당enum field에 함수형인터페이스 필드-&gt; 전략객체들 생성자 -&gt; 호출까지 따로 or 함수형인터페이스 1개 지정 -&gt; 람다식 가져가야한다. . 01 분기 제거를 가정하려면, 추상화된 객체(인페orEnum).메서드()로 빨간줄을 만든다. . . . 01 if 정펙매( input ) == 예상Enum의 분기마다 알아서 작동하게 하려면, 분기내 로직을 모두 해당Enum의 field로 가져올 수 있는지 봐야한다. . private boolean isRunning() { if (gameSwitch.isOff()) { return false; } return !isNotRunning(); } private boolean isStatusInRunning() { if (gameSwitch.isOff()) { return false; } return state.isStatus(); } private boolean isEndInRunning() { if (gameSwitch.isOff()) { return false; } return state.isFinished(); } .",
            "url": "blog.chojaeseong.com/java/break/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/%EC%B2%B4%EC%8A%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/02/while-if-break;%EB%A5%BC-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95.html",
            "relUrl": "/java/break/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/%EC%B2%B4%EC%8A%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/02/while-if-break;%EB%A5%BC-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95.html",
            "date": " • Apr 2, 2022"
        }
        
    
  
    
        ,"post17": {
            "title": "피드백) 1-3(블랙잭) 코드리뷰",
            "content": "PR . 1단계 PR | 2단계 PR | . 블랙잭 1단계 피드백 . domain package내에서도 쌓인 class들을 용도에 package를 구분해라. . | 큰규모가 아니면, Contoller를 쓰지말고 Game/Program/Machine을 run하자. . | 자식class에서 상속받은 메서드에 대해 @Override는 강제가아니지만 표기하자 . | 확인할 때는, 실제로 계산로직과 별개로, 확인만 하는 메서드를 만들자 . 예를 들어, isBust()를 확인할 때, 카드를 직접 받아서 Bust를 만들어보고 rollback이 아니라 카드를 받아서 계산하는 실제 로직과 비슷하더라도 로직을 포함해 물어보자 | . . | getXXX는 getter가 아니면 다른 용어를 쓰자. ex&gt; .receiveXXXX() . . | 블랙잭-CardDeck 요소는 정해져 있지만 셔플로 랜덤이 생기는 경우도 전략패턴으로 외부주입 가능하게 해서 테스트 . . 자동차경주: 랜덤한 조건식을 테스트를 위해 전략패턴으로 빼서 외부주입 . | 로또: 랜덤로또생성을 테스트하기 위해 전략패턴으로 빼서 외부주입 . . | 블랙잭: 요소들은 정해져있지만 셔플된 CardDeck을 테스트하기 위해 전략패턴으로 빼서 외부주입 . . | 체스: (예정) 요소들은 정해져있지만 너무 규모가 커서 테스트하기 힘든 map을 작은 Map.of(,)으로 만들어서 테스트하기 위해 전략패턴으로 빼서 외부 주입 . | . | java에서는 Stack대신 Deque자료구조를 사용 . | Enum도 결과 계산로직 등 중요로직을 가지고 있으면 EnumTest하기 . | list와 단일요소를 합칠 때는 .stream() + Stream.of() 으로 stream으로 통일한 뒤, concat하여 묶음을 만들 수 도 있다. 다만 묶은 Stream을 forEach를 사용할 경우는 생각해봐야한다. . | my) 이미 정해진 자료를 db가 아닌 프로그램에서 초기화하려면, . 프로그램 시작부터 초기화는 상수static final변수에 -&gt; static { }블럭에서 초기화시키면 된다. | . public class RandomCardGenerator implements CardGenerator { static final List&lt;PlayingCard&gt; cardDeck; static { cardDeck = Arrays.stream(Suit.values()) .flatMap(RandomCardGenerator::getPlayingCardStream) .collect(Collectors.toList()); } . | 초기화되어있는 컬렉션을 Collections.shuflle()만 해줘도 랜덤이다. . 원본을 보호하고 싶다면, new ArrayDeque&lt;&gt; ( 컬랙션 )처럼 복사후 shuffle하고 return해준다?! | . | 입력받은 값을 확인하는 메서드 내에서 바로 t/f return이 아닌, return전 또다시 물어본 대답에 따라 로직을 수행후 return t/f return하는 경우도 있다.** -&gt; **isXXX Then YYY ()` . 만약 카드받는 로직이 없이 물어보기만 했다면? . private boolean isHit(final Player gambler) { final BlackJackCommand inputCommand = askHitOrStay(gambler); return inputCommand.isHit(); } . | 물어본 대답에 따라 로직이 추가되는 경우 -&gt; xxxThenyyy() . private boolean isHitThenReceiveCard(final Player gambler, final CardDeck cardDeck) { final BlackJackCommand inputCommand = askHitOrStay(gambler); if (inputCommand.isHit()) { gambler.receiveCard(cardDeck); // isHit인 경우, 추가로직 수행후, return한다. return true; } return false; } . | . | 블랙잭 2단계(베팅) 피드백 . 같은 상태값을 공유하는 테스트들만 따로 @Nested를 적용해줘도 된다. 예를 들어, setUp에 버스트의 상황이 없는 경우에 한하여테스를 작성할 때 | . | 전략패턴으로 빼고 랜덤까지만 production의 domain 패키지에, 테스트를 위한 수동전략객체Class는 test코드&gt; testutil&gt; XXXXFixtureGenerator로 만들어준다. . 전략객체라도 테스트를 위한 수동전략객체는 -&gt; production에 생성하면안된다. | . . getter가 아니라면 -&gt; .receiveXXX() or .createXXXX() . . | 조건이 여러개 있을 땐, 포함관계인지 확인하자 . . | | 객체에 역할수행을 위해 메세지를 보낼 때, 역할수행에 필요한 재료들만를 보내야지, 역할을 가진 도메인을 보내지마라 . 역할을 가진 cardDeck을, 역할을 가진 players에게 보낸다?? -&gt; (X) -&gt; (O) . 내부에서 cardDeck이 역할을 수행해야하는데, 다른 도메인내부에서 다른 도메인이 역할하게 하지말고 재료만 보내자. . | 만약, players에 있는 복수의 player에게 서로 다른 재료를 제공하려면, 복수의 재료를 제공해야하고, 매번 1개씩 재료를 제공해준다면, 재료를 1개씩 제공하는 역할의 도메인은 넘겨도 된다. . | 중요한 것은, 메세지를 받는 players, player를, 다시 내부에서 재료로 들어간 cardDeck 역할 수행시, 그 재료로 쓰면 안된다. . . | . private void spreadCards(final Players players, final CardDeck cardDeck) { // 변경 전: //players.receiveCard(cardDeck); // 중간 변경: // 컬렉션(복수)에 넘겨주는 재료는 &lt;-- 1개만 주면 안된다. //players.receiveCard(cardDeck.pop()); // 최종 변경: // 컬렉션(복수)에 메세지 던질 때는, 재료컬렉션(복수)나, 재료를 매번 제공해주는 역할의 도메인을 넘겨도 된다. // 복수 &lt;-- 재료도 복수 or 내부에서 복수재료를 만드는 역할은 수행해도 된다. players.receiveCard(cardDeck); } . public void receiveCard(final CardDeck cardDeck) { for (Player player : value) { //cardDeck.drawTo(player, DEFAULT_DRAW_COUNT); // player들을 돌면서, 매번 새로운 재료를 공급받는다. final PlayingCard firstCard = cardDeck.pop(); player.receiveCard(firstCard); // 2장씩 제공받는다. -&gt; 2번이라서 반복문 굳이 안써도 된다?? final PlayingCard secondCard = cardDeck.pop(); player.receiveCard(secondCard); } } . | . | 상한이 있는 경우, 점수보정은 작은 것으로 출발하는 것이 좋다. . blackjack의 ace를 1or11 중 큰 점수를 유지하고 싶어서 default 11로 하고, -10점씩 보정시켜줬지만 | 애초에 상한 점수(21)점이 정해져있으면, ace 3장을 가져도 33으로의 보정은 아예 불가능한 상황이기 때문이다. ace2장만 있다고 치더라도, 22점은 아예 불가능한 점수기 때문에, ace를 작은 점수 1을 default로 하고, 보정도 22를 못넘어도록 1번만 +10보정이 가능하므로 while문을 돌릴 필요도 없다 | . | . . | 구초리 . domain과 view(m&lt;-&gt;v)분리할 수없다면, mvc패턴이 아니므로 컨트롤러를 쓰지마라 . | inputView에도 . input메서드() 전에 출력로직이 있어야한다. | .scanXXX() 애매 -&gt; 탐색/검색의 의미임. -&gt; .inputXXX()로 가자, | view에서 형변환까지 완료해서 return 해보면 어떻까? 고민 | | view로직이 조금이라도 포함된다면? domain패키지에서 빼라 . | 지역변수 추출을 활용해서 가독성을 높이자 . | scanAndGetBetMoney : controller에서 내부 2가지 하는 일(로직 + 출력)을 하도록 묶은 메서드에 대해 . 메서드명에 내부 여러가지 일을 명시하여 노출하면 캡슐화 위배 | controller(M+V가 섞인 class)에서 메인로직 + View출력을 1개 함수로 묶지마라 | | controller or M+V메인로직에서 반복문 등 로직을 수행하지마라 -&gt; 로직을 담당하는 클래스에 메세지를 보내 책임을 넘겨라 . 메인로직 클래스가 일이 많아지거나 로직을 수행하게되면 객체에게 넘겨라 | . | scanAndGetBetMoney -&gt; . 내부 .scanXXXX() -&gt; 의미상 inputXXXX()으로 변경 | scanAnGetBetMoney -&gt; createBetMoney로 변경 get -&gt; getter아니면 receive(다른데서 받기) or create(생성) | . | . | A &amp;&amp; B &amp;&amp; C -&gt; 드모르간으로 단순화시킬 수 있다. . not A return false; | not B return false; | (자동 A &amp;&amp; B) return C | . . | 스트림의 결과를 변수로 추출하라 . . //변경 전 public static BlackJackResult from(final Players players) { return new BlackJackResult(players.getGamblers() .stream() .collect(Collectors.toMap( Function.identity(), gambler -&gt; calculateProfit(players, gambler), (x, y) -&gt; y, LinkedHashMap::new) )); //변수로 추출 public static BlackJackResult from(final Players players) { final Map&lt;Player, Double&gt; ProfitsPerPlayer = players.getGamblers() .stream() .collect(toMap(Function.identity(), gambler -&gt; calculateProfit(players, gambler), (x, y) -&gt; y, LinkedHashMap::new)); return new BlackJackResult(ProfitsPerPlayer); } . //변경 전 public double calculateDealerProfit() { return this.value.values() .stream() .mapToDouble(Double::valueOf) .sum() * DEALER_FLIP_UNIT; } //변수로 추출 public double calculateDealerProfit() { final double dealerTotalProfit = this.value.values() .stream() .mapToDouble(Double::valueOf) .sum(); return dealerTotalProfit * DEALER_FLIP_UNIT; } . | dto -&gt; 필요case : 시스템커졌을때, 레이어 나눠서 (도-&gt;서) 관리, 계층넘어갈때 문제 . | 페어간 새롭게 안 사실들 . 추상클래스를 사용하는 많은 경우가 인페에서는 공통적으로 못쓰는 공통 상태값을 공유하기 위해서 . | 여러 구상체(자식들) 존재시 변수는 무조건 추상체로 받아 -&gt; 컬렉션&lt;추상체&gt;로 묶어서 처리가 가능 . 변수, 파라미터, 응답값 모두 추상체로 주기 . // given String expected = &quot;pobi&quot;; final Player pobi = new Gambler(expected); final Player rich = new Dealer(&quot;rich&quot;); . | 만약 단수로 구현체로 받는 경우는 , 추상체로 묶어 사용할 것을 포기한 상태로, 구현체 전용 메서드를 사용하는 순간이다. . @Test @DisplayName(&quot;딜러는 현재 합산 17이상인지 확인할 수 있다&quot;) void over_than_sixteen() { // given final Dealer rich = new Dealer(&quot;rich&quot;); rich.addCard(PlayingCard.of(Suit.HEARTS, Denomination.KING)); rich.addCard(PlayingCard.of(Suit.SPADES, Denomination.KING)); // when boolean actual = rich.isUnderSixteen(); // then assertThat(actual).isFalse(); } . | . | 값 비교시, null가능한 값은 메서드 파라미터로, 확실한 값만 좌항으로 + 소문자 가능하려면 equalsIgnoreCase . 비교시 확실한 값을 왼쪽에 넣어서 null에러 안나게 + ignoreCase . . | . | 싱글톤 . static + final으로 클래스변수로서 애초에 생성해놓고 초기화도해놓음 | 정펙매로 이미 생성된 것만 반환함 ( 객체 생성 생성자 제공 안함. getInstance로만 사용함.) my) 프로그램 시작시부터 생성되어야할 놈들 static +final 상수 변수에 담아야함 | static { } 블럭에 초기화 - &gt; 프로그램 작동중에 다시 초기화할 때는? | 싱글톤 -&gt; new 기본생성자 제공도 안함.?! | . | . | . | 디버깅 찍고 싶은데, 아래 아무것도 없으면 sout만들어놓고, 그 위에 디버깅 표시 . . . | 도메인1 vs 도메인2 비교계산 로직이 같은 객체/일급컬렉션이 아닐 때의 비교 -&gt; 결과도메인이 1,2를 각각알고 서로는 모르게 . my) 같은형의 일급컬렉션 or 객체면, 상관없이 그냥 메세지&gt; 도메인1.메세지( 도메인2 ) . | 서로 전혀 다른 도메인인데, 각 도메인에서 최종결과값만 꺼내서 비교될 예정이라면? -&gt; 제3의 도메인을 만들어서 비교 . dealer vs players 점수비교하여 승패비교 . dealer. compare ( players )? | players . compare ( dealer)? | Result.of ( dealer, players ) | . . | 로또 비교도 마찬가지..? . LottoResult.of( winningLotto, Lottos ) | . . | . | |",
            "url": "blog.chojaeseong.com/java/feedback/review/%EB%B8%94%EB%9E%99%EC%9E%AD/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/31/%EB%B8%94%EB%9E%99%EC%9E%AD-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0.html",
            "relUrl": "/java/feedback/review/%EB%B8%94%EB%9E%99%EC%9E%AD/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/31/%EB%B8%94%EB%9E%99%EC%9E%AD-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0.html",
            "date": " • Mar 31, 2022"
        }
        
    
  
    
        ,"post18": {
            "title": "분기문과 드모르간 법칙",
            "content": "분기문에 적용하는 드모르간 . 문제 상황 . 루피 피드백 중 1개를 발취 . @Override public final boolean isMovable(Position source, Position target, ChessBoard chessBoard) { return !existSameColorPiece(source, target, chessBoard) &amp;&amp; isMovableByDirection(source, target); } . | 드모르간의 법칙을 참고하면 아래와 같이 변경할 수 있을 것 같아요. . &amp;&amp; : 작성자는 이해하기 쉬운 경우이나 라인 수는 줄어들지만 라인을 끝까지 다 읽어봐야 이해할 수 있을 것 같아요. | . | &amp;&amp; -&gt; || -&gt; if문 분기로 찢 : 반대로 분리해서 if 문으로 연산을 제거하면 라인 수는 늘어나지만 어떤 조건에서 if 조건을 실행하는지 좀 더 이해하기 쉬워질 것 같은데요. | 저는 최대한 and 연산을 지양하고 or 연산을 변환한 뒤 if 문으로 분리하는 편 입니다 ㅎㅎ | . | . @Override public final boolean isMovable(Position source, Position target, ChessBoard chessBoard) { if (existSameColorPiece(source, target, chessBoard)) { return false; } if (!isMovableByDirection(source, target)) { return false; } return true; } . | . boolean식 분기 적용법: ` &amp;&amp; -&gt; ||으로 분리후 -&gt; 드모르간 적용` . 01 return A &amp;&amp; B 로 작성해놓았다면, replace with ||로 분리한다. . private boolean isRunning() { return gameSwitch.isOn() &amp;&amp; state.isRunning(); } . . . private boolean isRunning() { return !(!gameSwitch.isOn() || !state.isRunning()); } . 02 가장 바깥 !( )는 무시한 체, return || 는 순서가 중요 -&gt; 아래쪽 순서대로 if return true문으로 찢는다. . ||의 or는 앞에 것 통과하면 뒤에것 안보고 통과하는 성격이 있다. . if 앞에 것 통과시 return되도로 if문으로 찢어보자. | 아래에다가 점진적으로 찢어보자. | . | . ` ||에서 앞에것 통과 못했으면 == if 분기에서 위에 것 통과 못했으면으로 동치다 -&gt; if A? ||오른쪽orif아래쪽은 자동notA` . ||에서 앞에것 통과 못했으면 == if 분기에서 위에 것 통과 못했으면으로 동치다 . 순서가 중요한 ||와 if분기 | . . | . private boolean isRunning() { return !( !gameSwitch.isOn() || !state.isRunning() ); //A통과 if (!gameSwitch.isOn()) { return true; } //(notA) B통과 if (!state.isRunning()) { return true; } } . 03 return || 오른쪽 끝까지 모두 통과X -&gt; false 이므로 if return true; 여러개 맨 아래 까지 통과x시 -&gt; return false; . . private boolean isRunning() { return !( !gameSwitch.isOn() || !state.isRunning() ); //A통과 if (!gameSwitch.isOn()) { return true; } //(notA) B통과 if (!state.isRunning()) { return true; } //(자동 notA &amp;&amp; notB) ||에서 순서대로 다 통과못할시 false다 return false; } . 04 무시했던 바깥 !()을 적용시키려고 return true/false 반대로작성하기 . . . private boolean isRunning() { //A통과 -&gt;!() 적용시켜서 A false -&gt; not A if (!gameSwitch.isOn()) { //return true; return false; } //(notA) B통과 -&gt;!() 적용시켜서 (A) B false -&gt; not B if (!state.isRunning()) { //return true; return false; } //(자동 notA &amp;&amp; notB) -&gt;!() 적용시켜서 ( A &amp;&amp; B ) //return false; return true; } . 05 암기 및 정리: (if를 다지난 마지막자리에 주석 //A &amp;&amp; B와 함께 자동 자리에)retun true를 주고 -&gt;if notA return false -&gt; if notB return false; . 06 사실 boolean이라면 if not A -&gt; (자동A) return B를 해버리면 된다. (로직일 경우 not B도 개별 처리해줘야하니까 다름) . 기본 로직 적용법 및 암기법: A &amp;&amp; B는 if notA -&gt; if notB -&gt; 맨마지막 자동 A &amp;&amp; B에서 처리되도록 . 예시1) row &amp;&amp; col의 대각선 . . public List&lt;Position&gt; pathTo(Position otherPosition) { List&lt;Row&gt; rowPath = row.pathTo(otherPosition.row); List&lt;Column&gt; columnPath = column.pathTo(otherPosition.column); // 2. [ not A ] row(X) -&gt; rowSize == 0 (자동으로 col) 부터 한다 if (rowPath.size() == NO_SIZE) { return getVerticalPositions(columnPath); } // 3. (A &amp;&amp;) [ not B ] col(X) -&gt; colSize == 0 (자동으로 row) 을 한다 if (columnPath.size() == NO_SIZE) { return getHorizontalPositions(rowPath); } // 1. [ ( A &amp;&amp; B ) ] row &amp;&amp; col == 대각선 -&gt; 맨 뒤에서 자동으로 return getDiagonalPositions(rowPath, columnPath); } . 예시2) 누구 king이 잡혔냐? -&gt; (자동 둘다 &amp;&amp;안잡힌 상황) . private static GameResult findWinner(final Board board, final double statusOfWhite, final double statusOfBlack) { // 2. not A -&gt; black잡힘 if (board.hasBlackKingCaptured()) { return GameResult.WHITE_WIN; } // 3. (black안잡혔는데 ) not B -&gt; white잡힘 if (board.hasWhiteKingCaptured()) { return GameResult.BLACK_WIN; } // 1. ( 자동 black안잡힘 &amp;&amp; white안잡힘 ) -&gt; 점수 비교 로직 return getResultWhenNoKingCaptured(statusOfWhite, statusOfBlack); } . 예시3) boolean에서 A &amp;&amp; B . . private boolean isStatusInRunning() { return gameSwitch.isOn() &amp;&amp; state.isStatus(); } . 01 (자동으로 될 A &amp;&amp; B를 주석처리와 함께)맨 끝에서 return true . . private boolean isStatusInRunning() { //gameSwitch.isOn() &amp;&amp; state.isStatus(); return true; } . 02 if not A를 만들고 return false; . . private boolean isStatusInRunning() { // if not A -&gt; return false; 주기 if (!gameSwitch.isOn()) { return false; } // (자동 gameSwitch.isOn() &amp;&amp; state.isStatus();) return true; } . 03 if not B 만들고 return false; . . private boolean isStatusInRunning() { // if not A -&gt; return false; 주기 if (!gameSwitch.isOn()) { return false; } // if not B -&gt; return false; 주기 if (!state.isStatus()) { return false; } // (자동 gameSwitch.isOn() &amp;&amp; state.isStatus();) return true; } . 04 boolean이라 따로 로직이 필요없다면 if not A return false;후 -&gt; return (자동 A &amp;&amp;) B . . private boolean isStatusInRunning() { // if not A -&gt; return false; 주기 if (!gameSwitch.isOn()) { return false; } // if not B -&gt; return false; 주기 //if (!state.isStatus()) { // return false; //} // (자동 A &amp;&amp; B == gameSwitch.isOn() &amp;&amp; state.isStatus();) //return true; // (자동A ) return state.isStatus(); } . my) A &amp;&amp; B의 처리는 if A부터 처리 못한다?(if not A) -&gt; 바로 탈락(return false;) 시킨다. OR로 본다면 앞에거 먼저 만족하면 return True로 전체 종료되는 개념과 유사하다. . my) boolean A&amp;&amp;B 이라면, notA || notB + 원랜 앞에것 통과시 true로 끝 But 여기선 !땜에 return false; -&gt; A부터 만족 못할시 빠르게 false로 종료처리되도록 -&gt; if로 찢어 if not return false시켜버린다. . my) boolean이라면, if not 앞쪽A -&gt; return false; 이후 (if문 아래쪽은 자동 A &amp;&amp;상태이므로) 마지막 분기식은 바로 return (자동A&amp;&amp;) B해버려도 된다. ( if not B로직이 필요없는 상황) . my) boolean처럼 로직도 if notA return -&gt; if notB return -&gt; (자동 A &amp;&amp; B) return 을 사용한다. . my-역) if return false -&gt; A &amp;&amp; B 조건에서 앞쪽 A를 먼저 만족시키지못해 애초에 탈락이구나 -&gt; not A 상황이라서 &amp;&amp; B보기전에 빨리 거르기 + 밑으로는 (A &amp;&amp;)상태구나 . my-역) if return false + return B -&gt; A||B의 앞쪽 A라 notA라 거르고, 밑에서 A &amp;&amp; B 이며, true시 true니까.. A &amp;&amp; B시 true리턴이구나.. . 해석 연습해보기 . BOOLEAN 中 and 조건문 . private boolean isRunning() { if (gameSwitch.isOff()) { return false; // 1. return false -&gt; end boolean식이 전제이며, A &amp;&amp; B에서 A를 만족못시키는 [A &amp;&amp; B에서 not A라서 먼저 false;로 걸러지는구나] } // 2. 자동 not A(! .isOff() == isOn()) 상태 &amp;&amp; 로서 A(스위치On)&amp;&amp;이면서 B가 와야하구나. // 3. 만약, 조건식이 1개가 남았다면 바로 return 조건문으로 끝낸다. // -&gt; [ (자동 isOn &amp;&amp;) !notRunning 이어야 end조건의 boolean식이 최종 true가 되는 구나] // -&gt; is ON &amp;&amp; running 상태여야 true return !isNotRunning(); } java private boolean isStatusInRunning() { if (gameSwitch.isOff()) { return false;//1. early false -&gt; and조건에서 빨리 걸러지는 상황으로 [앞쪽 not A -&gt; off ] } //2. (자동 A -&gt; on &amp;&amp;) 상태에서 if status상태여야 true구나. return state.isStatus(); } . private boolean isEndInRunning() { if (gameSwitch.isOff()) { return false; // 1. not A 가 off로 먼저 걸러진다 -&gt; A = on상태 &amp;&amp; } //2. on &amp;&amp; finihsed상태여야 true return state.isFinished(); } . BOOLEAN이 아닌 단순 경우의 수라면? -&gt; 마지막 경우의수만 자동으로 가져간다.?! -&gt; 복잡한 조건을 뒤에서 if없이 자동으로 가져가게 하자. . A OR B OR C 경우의수: 편한 순서대로 ealry return하면서 마지막 경우의 수만 if없이 자동으로 가져간다 참고: boolean OR 조건문 -&gt; (이왕이면 잘 걸리는 것을 앞A에 배치해놓고)early true return으로 빨리 끝내기 (&amp;&amp;조건문시 앞에것부터 early false return처럼) | . | . public void move(Position beforePosition, Position afterPosition) { Piece beforePiece = this.value.get(beforePosition); // 로직 or : 순서 상관없이 [early return] + 마지막만 자동 경우의수로 가져가기** // 단순 같은위상의 3가지 경우의 수 -&gt; 순서상관엇이 if A return 로직A; if B return 로직B; (if없이 자동 자동3번째) 로직C; // A: after에 빈칸이 있을 경우 if (isMoveToBlank(afterPosition)) { beforePiece.move(beforePosition, afterPosition, moveFunction(beforePosition, afterPosition)); return; } // B: after에 적이 있을 경우 if (isMoveToOtherCampPiece(beforePosition, afterPosition)) { beforePiece.capture(beforePosition, afterPosition, moveFunction(beforePosition, afterPosition)); return; } // C: (자동 빈칸도X 적X) -&gt; (자동 after에 같은편이 있을 경우) throw new IllegalArgumentException(CANT_MOVE_TO_SAME_CAMP); } . A OR B OR C -&gt; A+B OR C로 통합된 경우 -&gt; 마찬가지 마지막 경우의수만 if없이 자동 if OR의 경우의수 2개를 통합했더니 -&gt; A와 B의 로직이 다르면, 내부에서 다시 나눠야하는 부작용 있었음. | A+B통합이 더 크므로, 차라리 C OR A+B로 보고 규모가 작은 것을 앞에 배치시키면 if문 없이 자동이 편해짐(아래서 함) | . | . public void move(Position beforePosition, Position afterPosition) { // 빈칸 + 적의 내부로직이 통합됨 OR로 연결됨 - ( A OR B = D) // D OR C -&gt; if D return 로직D; (자동C)-&gt; if A return(true); 자동B if (board.get(beforePosition).isNullPiece() || !board.get(beforePosition) .isSameCampWith(board.get(afterPosition))) { movePiece(beforePosition, afterPosition); return; // OR는 early (true) return 필수다. 로직이라면 그냥 earyl return;필수 } // (자동C: 같은 진영의 기물인 경우) throw new IllegalArgumentException(CANT_MOVE_TO_SAME_CAMP); } . A+B OR C라면 규모가 작은 C를 먼저 ealry return | . public void move(final Positions positions) { if (isAfterPieceSameCamp(positions)) { throw new IllegalArgumentException(CANT_MOVE_TO_SAME_CAMP); } movePiece(positions); } .",
            "url": "blog.chojaeseong.com/java/if/conditionalstatements/a&&b/earlyreturn/boolean/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/30/%EB%B6%84%EA%B8%B0%EB%AC%B8%EA%B3%BC-%EB%93%9C%EB%AA%A8%EB%A5%B4%EA%B0%84.html",
            "relUrl": "/java/if/conditionalstatements/a&&b/earlyreturn/boolean/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/30/%EB%B6%84%EA%B8%B0%EB%AC%B8%EA%B3%BC-%EB%93%9C%EB%AA%A8%EB%A5%B4%EA%B0%84.html",
            "date": " • Mar 30, 2022"
        }
        
    
  
    
        ,"post19": {
            "title": "강의) 네오 3단계 블랙잭 피드백(4/4)",
            "content": "추상화레벨 맞추기는 나중에 . 중요) 클라이언트 관점에서 더 필요한 기능이 남았는지 꼭데기 인터페이스에서 고민하기 . 중요) 기존 [상태패턴용 인페 메서드]들 고민해보기 . . my+ 깨닮음 ) 메서드는 (1)(인자-&gt;파라미터로 오는) 추가정보가 있냐/없냐에 따라 -&gt; 추가정보을 유발된 상태값 업데이트냐/ 원래 상태값의 조회해서 처리냐를 구분 + (2) 응답값을 통해 추상체 or 객체냐/상태값/값이냐 -&gt; 처리내용이 같은 상카아래의 구현체 중 1개 객체 생성이냐/ 내부값 단순 조회/ 연산이냐가 나눠진다. . public interface State { State draw(final Card card); // [추가 정보]를 받아서 [상태값을 업데이트해서 -&gt; 새 객체를 만들어내겠군] // 응답이 추상체(인터페이스)? -&gt; 서로 다른 구현체로 바뀔 수도 있겠군 // 구현체끼리 바뀌려면 -&gt; 같은 상태값 &amp;&amp; 상태값을 재료로 받는 생성자가 있어야겠지 State stay(); // 추가 정보가 없는 메서드? 상태값을 업데이트보단 [조회해서 처리] 확률이 높겠다. // -&gt; 아무래도 [현재 상태값을 조회하여 -&gt; 무엇인가 처리]할텐데, // -&gt; 응답값 [추상체다? ] -&gt; [조회해서 다른 구현체 객체]로도 갈 수 있을 듯? Cards cards(); // 추가 정보가 없는 메서드? 상태값을 업데이트보단 [조회해서 처리] 화률이 높겠다. // -&gt; 아무래도 [현재 상태값을 조회하여 -&gt; 무엇인가 처리]할텐데, // -&gt; 응답값이 } . 54) 상태패턴 상카에서 빠진 기능 살펴보기 . public interface State { State draw(final Card card); State stay(); Cards cards(); } . 현재 상태 종류 (1) 끝난 상태 3개 (2) 최초시작&amp;&amp;진행가능 상태 1개 (3) 중간 진행가능상태 (1) . . 상태 상카의 현재기능 (1)상태변화 트리거(draw(추정)) + (2) (자의)종료상태 만들기(stay) + (3)현재상태 상태값getter(cards) - (중복제거으로 올렸더니 자식들 개별구현시 상태값 뽑아쓰기용) . 3개 기능 이외에 더 필요한 기능은? (4) 매번 끝났느지 안끝났는지 확인하는 기능은 필수로 제공되어야한다. . 중요) 특정클래스(추상클래스, 중카)에 속하는지 확인하기 위해 개별객체. isInstanceof 클래스.class 대신 -&gt; 객체.is특정추클? 특정클래스는 true/ 나머지클래스는 false를 반환하는 &amp;&amp; is특정클래스()의 이름을 딴boolean확인메서드를 새 메서드로서 추메/전메에 올려서 구현한다. . 55) isInstanceof(중카.class) 안쓰고 매번 끝난 상태(중카, 추상클래스)인지 아닌지 확인하는 기능 -&gt; 해당(끝난상태) 중카true vs 나머지 중카false를 반환하는 [확인클래스이름을 딴 boolean확인메서드]를 상카에 추가하기 . . 까먹) Finished처럼, 중카/추클 전체에 적용되는 메서드들은, 자식들이 딴짓 못하게 final로 막아주기 . . 중요) instanceof를 썼다면, 잘못된 설계다? -&gt; 메서드에 메세지보내서 t/나머지f를 받을 수 있게 메서드로 관리하자. . 56) 특정추클이 맞는지 확인메서드이지만, 모든 상태 객체가 대상이다 -&gt; 새 메서드는 일단 추메/전메에 올려서 먼저 개발 . 상카인페에 새 추메/전메를 올릴 때 인페 안에서 접근제한자 생략 -&gt; 자동public 이므로 returnType + 파라미터의 시그니처만 정의한다. . . public interface State { State draw(final Card card); State stay(); Cards cards(); // 하위 특정클래스 확인후 t/f를 반환해줄 메서드 추가 boolean isFinished(); } . 중요) 개별구현이 예상되면(t/f확인메서드) -&gt; 개별구현되는 곳까지 중간에 추클들은 무시하고 내려가서 구현해야한다. 중간/추클에 구현 impl == 중복코드 제거용으로 다시 추상메서드를 정의하지말고 무시하면 -&gt; 자식들이 화내면서 개별구현해야한다 -&gt; 즉, 개별구현해야된다면, 중간추클을 만나더라도 추상메서드 줄 필요없이 무시하면 개별구현자식들에게 자동전과되서 빨간줄 띄운다 . 최상위 중카인 Started가 있지만, Finished &lt;-&gt; 그외 중카의 개별구현이 예상되면, 개별구현되는 상위 중카추클까지 내려가서 구현한다. (최상위 중카를 무시하고 내려가면, 자식들에게 전과되어 개별구현하게 한다) . . 암기) 상카 인터페이스에서 추메/전메로 올려서 개발시작하되, 개별구현되는 곳까지는 중카-추클을 무시해서 개별구현 전과를 돌려도 된다 -&gt; 중간에 있다고 해서 미구현 추상메서드로 구현해 둘 필요없다 . 57) isXXXX() 대상 중카/추클까지 내려가서 개별구현으로서 true를 반환해준다 . 상카인 State에서 추메/전메로 올려서 시작했으면서 &amp;&amp; 중카인 Started를 건너띄었다면? . (추가 중카인 Finished 역시 필수 구현체X &amp; 중복코드라도 아직은 구현안해준 상태)에서 . **중카 추클이 구현impl을 무시했다면, 개별구현 책임이 자식들한테 넘어가 화가나있다 ** . . | . | 일단 isFinished()의 true를 대답해줄 그룹에 대해서 추클에 중복코드로서 구현해준다. . . | 깜빡!) 중복제거를 위해 상카-추메/전메 -&gt; 중카/추클에서 먹어서 정의하러 왔으면, 중카/추클 정의시는 항상 final로 자식 딴짓 못하게 막기 . 아래 일부사진들을 보면 중복제거용 부모 먹어주는 코드인 isFinished가 final이 안달려있다. | . 58) isFinished() 개별구현 책임이 전과된 isFinished 중카추클에 속하지 않은 중카추클이 아닌 개별구현체들 -&gt; 중복코드제거 해줄 추클이 위에 없다면, 전과받은 개별구현체들이 모두 직접 구현 . 현재 isFinished가 아닌 Ready와 Hit에 불이 나있다. . . . Ready . 전과된 직접 개별구현 -&gt; 끝난상태냐? false . . | . | Hit 역시 마찬가지 -&gt; 끝난상태냐? false . . | . | . 중요) 또 상태패턴의 상카 인터페이스에서 빠진 기능이 없는지 확인한다 블랙잭 라이브러리를 받아와서 이 기능들로 다 구현가능한지를 생각해보면 된다. . 상태변화 유발 메서드 with 파라미터(추가정보) -&gt; draw(card) | 자의로 끝난상태로 종료시키기 -&gt; stay | 구현체에서 부모상태값정보 받아먹기용 getter -&gt; cards | 현재 끝난 상태인지 확인 -&gt; isFinished | ??? | 중요) 상태패턴의 상태객체가 cards정보를 가지고 있으니 -&gt; 필수 기능외에 계산로직도 상태 상카의 추메/전메로 추가해준다. . public interface State { State draw(final Card card); State stay(); Cards cards(); boolean isFinished(); } . 중요) 계산profit() 하려면, 상태객체마다. isBust()인지 / isBlackjack() / isStay() 인지 구현체(상태객체) 종류마다 [isinstanceof 대신 boolean확인메서드]가 필요해지는데??? . . 초대박) isinstanceof 특정 중카(추클)을 대신하는 boolean확인메서드가 아니라 개별 구현체마다 확인이 필요하다면, boolean확인메서드가 구현체 종류마다 필요해지고, 나머지는 모두 예외처리?해야만 한다 -&gt; 개별구현체마다 다른 로직을 가지고 있으면서 &amp;&amp; 굳이 (종료상태냐?) 확인할 필요없다면 : 추메/전메 -&gt; [중카무시의 개별구현 책임전과]를 통해 [구현체마다 다른 로직을 구현]해서 다형성에서 알아서 처리되도록 구현하자 . 암기) 같은 카테고린데, 개별구현해야한다면? isInstanceof (x) -&gt; is특정구현체? (x,그룹일경우만) -&gt; 묻지말고 전략메서드처럼 추메/전메로 개별구현해서 알아서 작동하도록 . . . my) 전체가 크게 나뉘는 (종료상태들&lt;-&gt;진행상태들 등)그룹에 대한 확인이면서 &amp;&amp; isintanceof인지 꼭 물어봐야한다? isBoolean메서드를 추메/전메 올려서 개별구현까지 가서 구현 . my) 모든 구현체마다 다르게 구현되고 &amp;&amp; 물어보면서 그에 따른 로직이 정해져있다? -&gt; 공통메서드 로 추메/전메에 올리고 -&gt; 물어보지말고 구현체들마다 직접 개별구현 시키자 . my+깨닮음) 어떤 것을 할 때마다, 해당 상태(객채)인지 물어보고 + 거기에 맞는 로직까지 정해져있다 -&gt; 근데 그 상태가 제한된 종류로서 묶인다? -&gt; 상카-구현체들로서 안물어보고 추메/전메로 전략패턴처럼 만들어주면 -&gt; 구현체마다 알아서 작동하도록 개별구현해놓으면 -&gt; if instanceof가 사라진다. . 중요) 상태패턴에서 state구현체들은, 다음state의 판단을 위해 상태값에 정보를 가져야만한다. -&gt; 정보를 상태값으로 가졌다면, 계산로직도 거기(state 구현체, 상태객체들)에서 구현(다르다변 추메/전메 -&gt; 개별구현) 되어야한다. . 59) state의 구현체들이 정보인 cards를 상태값도 가지고 있으니, 계산로직도 여기서 처리해야한다. 계산: 대상은 Finished된 state들만 대상이 되며, 계산(기본 정보로 계산) 중 &lt;외부 입력을 받아 + 정보바탕으로 계산&gt;: input으로 들어온 betMoney(double)을 [구현체별 다르게 계산 로직 구현]하여 -&gt; 새로운 계산값을 output 응답하는 계산이 있다. . my) 정보를 통한 계산이 아니라, 외부 금액input 등 정보를 가진 곳에서 계산로직을 가질 때, 외부재료를 input으로 받아서 -&gt; 가진 상태객체의 정보cards를 바탕으로 -&gt; 새 재료?로 return응답 해주는 계산로직도 생각하자. + 계산로직은 State패턴의 구현체객체들 중 finished에 해당한 애들만 계산로직을 가질 수 있다. . 상태에 따라, 외부input인 배팅금액을 받아 -&gt; 상태마다 개별적으로 다르게 계산해서 새로운 배팅금액을 output으로 응답한다. . 이 때, Finished아래의 구현체들만 결과 계산 로직을 가진다. | . . | my) 계산시 외부재료가 필요한 경우도 있다. 그 외부재료에 계산한 값을 돌려주는 경우가 있다는 것을 생각 . 참고) 돈 계산의 원시형은 일단 double로 받아서 double로 내어주자 . public interface State { State draw(final Card card); State stay(); Cards cards(); boolean isFinished(); double profit(double money); // 계산 중에 외부에서 받은 것을 계산해서 응답해준다. } . 60) 외부재료받아 계산하는 로직의 [구현체마다 다르게 개별 구현] (finished 아래 구현체들만) . . blackjack -&gt; 외부재료(input money)를 * 2 하는 계산후 응답해준다. . 개별구현을 위해 중카/추클에서 impl무시하면, 자식들이 불나있다. . . public final class Blackjack extends Finished { Blackjack(final Cards cards) { super(cards); } @Override public double profit(final double money) { return money * 1.5; } } . | . | bust : 외부입력만큼, 손해로 작용한다면 * -1을 해주면 된다. . public final class Bust extends Finished { Bust(final Cards cards) { super(cards); } @Override public double profit(final double money) { return money * -1; } } . | 61) 개별 구현체 상태에서의 계산이… 추가 정보가 필요한 상태 -&gt; 임의로 input 그대로 응답해놓는 버릇을 들여보자. . stay상태에서는 추가정보로서 딜러의 cards와 비교를 해야한다. -&gt; 일단 무시하고 원본을 돌려놓는다. . public final class Stay extends Finished { Stay(final Cards cards) { super(cards); } @Override public double profit(final double money) { return money; } } . | . 62) 추가 처리가 필요한 예외상황 -&gt; 바깥에서 처리하기로 하고, 도메인내 자신의 역할만 생각해서 완성한다 . 참고) 상호작용의 검증/조건이 있더라도, 개별 도메인 작성시에는 자기역할만 순수하게 완성한다. . 현재 state가 blackjack 일때? 상대도 blackjack? 체스로 치면 king이 움직이는 것? 앞에 기물이 있는 예외상황은 바깥(board)에서 처리하고 일단 king자신 이 갈 수 있는 조건으로 계산한다. | . | 상대방도 blackjack이면, 이익은 0배로 무승부인데?, 일단 내가 blacjakc일때의 상금 1.5배만 생각해서 완성한다 | . | . 63) hit와 ready는 profit계산자체가 불가 -&gt; input있는 계산함수라도 개별구현시 예외처리 . @Override public double profit(final double money) { throw new IllegalStateException(); } . 대박) 개별구현 하다가 중복코드가 보인다? 무시했던 추클에서 impl -&gt; 후 중복부분만 구현(중클/추카 구현 메서드면 final) &amp;&amp; 개별구현체마다 다른 부분 = 개별class들이 아는 부분 -&gt; abstract메서드로 빼서 내려주기 . . 중요) 중카/추클이 무시하고 내려보내 -&gt; 개별 구현된 메서드들 중에서 상수 or 일부분만 중복이어도 -&gt; 중카/추클에서 중복제거용impl 구현시행 &amp;&amp;상수(일부분)만 다시 abstract로 내려보내주기 . 중요+암기) 개별구현 전과시키려고 [impl구현 무시한 중카/추클 내]에서 새로운 중복 발견인 경우, impl구현 무시한 곳 -&gt; impl시행하여 아래부분 중복제거를 시행하며 -&gt; 상수든 뭐든 구현체별로 달라지는 부분은 상수라도 -&gt; 메서드응답으로 빼고 -&gt; abstract 메서드로 정의해서 자식들에게 [응답메서드로 상수(일부분) 개별구현]으로 내려주기 . 64) Finished내부, 상수만 구현체별로 다르고 메서드가 중복된다면? -&gt; 제한된 중카/추클로만 올린 뒤, 달라지는 부분만 메서드로 추출하여 응답받도록 한 뒤 -&gt; abstract메서드로 내려보내서 자식들이 상수응답하도록 하기 . . Finished에서 무시했던 노필수 impl구현을 해줘서, 중복제거용 코드로 먹어준다. . . . | 중요) 중카/추클은 상카 존재 시 개별구현 -&gt; 무시하고 내려보내기 or 중복제거 -&gt; final로 막아두고 구현 or 중카/추클 자식들의 중복시 -&gt; 자신이 추메/전메처럼 abstract로 정의해서 뿌려준다. + 상수도 응답 메서드로서 뺀 뒤 -&gt; protected? abstract로 정의하여, 추메/전메처럼 내려준다 . **개별 클래스들이 알고 있는 부분(메서드 구현 뿐만 아니라 상수도!!)은 개별 클래스(구현체)들이 응답해줄 abstract메서드로 뺀다 ** . 상수를 메서드로 뺄 때, 상수이름을 메서드로 네이밍()해주는 센스 | . . 중카/추클에 정의하는데 final로 중복구현 vs 개별구현의 최상위라면, 중복코드는 final로 정의해주되, 내부에 개별구현 코드가 보인다면, 메서드로 뺀 뒤 -&gt; 추메/전메처럼 뿌려주려면, abstract 메서드로 내려주기 . . | 개별구현시키려고 abstract메서드로 뽑았더니, 자식들 구현하라고 protected로 찍혀있다. . . | abstract로 추메/전메처럼 개별구현으로 내려보내면 -&gt; 자식들 불 들어온다. . . | . | 암기) 중카-추클이 개별구현을 내려줘야한다면, 중복제거 코드내라도 가능하며, 상수, 일부분이라도 (1) 메서드로 빼고 -&gt; (2)abstract로 내려준다. . 개별 구현체들이 알고 있는 개별 상수들을 메서드로 구현해준다. . blackjack . 올린 중복코드는 제거한다. . | 중복코드를 제외한 상수의 개별구현을 abs -&gt; impl해줘서 응답해준다. . . public final class Blackjack extends Finished { Blackjack(final Cards cards) { super(cards); } @Override protected double earningRate() { return 1.5; } } . | | 나머지 들도, 중복코드를 삭제하고, 상수를 응답하는 개별구현 메서드를 구현한다 . . . public final class Bust extends Finished { Bust(final Cards cards) { super(cards); } @Override protected double earningRate() { return -1; } } . | stay: 원본 그대로 돌려주고 밖에서 나중에 예외처 계산함 . public final class Stay extends Finished { Stay(final Cards cards) { super(cards); } @Override protected double earningRate() { return 1; } } . | . | 중복제거 등, 추상화/상속 관련작업이 끝날 때마다, diagram을 보자 . ​ . profit()중복코드로서 중카/추클에서 정의해줬다 중복코드 -&gt; 외부에서 호출할 놈 -&gt; public | . | profit()내에서 구현체별 달라지는 부분(상수)는 내부에서 메서드추출 -&gt; 추카/중클에서 (protected)abstract로 전메/추메처럼 개별구현으로 내려보낸다 earningRate()는 개별구현체별 다르게 구현되는 상수를 추출한 메서드 | . | . . . 참고) 중카/추클(부모클래스)의 usage(extends)를 확인해보면, 같은 레벨의 자식들만 볼 수 도 있어서 -&gt; 레벨이 맞는지 확인할 수 있다 . . Started의 추클에서 usage(shift+F12)를 통해, extends자식들이 어떤 것들이 있는지를 보고 레벨을 확인해보자. 추클Finished | 구현체Hit | 구현체Ready | . | . 65) 2개 남은 쌩구현체들에 대해, 공통메서드 확인후 중카/추클 추가해서 묶어주기 . 중카/추클아래 구현체(자식들)은 본인의 역할만 잘하고 있는 것 같은데, hit와 ready는 좀 더러운 것 같다 . blackjack . public final class Blackjack extends Finished { Blackjack(final Cards cards) { super(cards); } @Override protected double earningRate() { return 1.5; } } . | . 쌩구현체들의 공통점 찾기 . Hit . @Override public boolean isFinished() { return false; } @Override public double profit(final double money) { throw new IllegalStateException(); } . | Ready . @Override public boolean isFinished() { return false; } @Override public double profit(final double money) { throw new IllegalStateException(); } . | . 66) 반대편 추클과 동일한 레벨의 추상화(중카/추클) 만든 후, 기존에 개별구현들은 무시하여 자식들에게 전과된 체 두고 + 중복제거용 메서드들만 뽑아서 impl하여 final -&gt; 자식들의 중복코드 제거한다 . . Finished의 반대 Running(중카/추클)만들기 . . | 중카/추클 생성하는데, 더 위의 중카/추클이, 상태값+생성자 (for getter?) 내려준다면, super()로 내려주는 상태값 초기화는 기본적으로 해줘야함 . . . Running &lt;-&gt; Finished . public abstract class Running extends Started { protected Running(final Cards cards) { super(cards); } } . | . 67) 추가 중카/추클은 기존 개별구현 메서드들을 제외시키면서 &amp;&amp; 중복처리를 해줄 메서드들을 -&gt; [implement Methods...] -&gt;상카의 추메/전메들 중 선택해서 처리한다. . 중간에 추가된 Finished대항마 Running은 impl해서 중복들을 상카-추메/전메중에 확인해서 처리해야한다. . | isFinihsed는 피니쉬의 대항마 추상레이어로서 아래 똑같이 중복 return false . 마찬가지로 profit도 아직 안끝났으면, 수익률계산불가 -&gt; 예외처리를을 중복처리한다. . public abstract class Running extends Started { protected Running(final Cards cards) { super(cards); } @Override public boolean isFinished() { return false; } @Override public double profit(final double money) { throw new IllegalStateException(); } } . | 중요) 중복처리하는 중카/추클의 중복처리 메서드는 final로 자식딴짓못하게 막아야하며, final을 달아줬다면 -&gt; 자식들이 extends 추가한 중카/추클하도록 넘어가자 . 68) 추클상 정의하는 메서드들은 무조건 접근제한자 확인할 것! 추클상 중복처리한다면, 자식에선 딴짓 못하게 final도 함께!! . . public abstract class Running extends Started { protected Running(final Cards cards) { super(cards); } @Override public final boolean isFinished() { return false; } @Override public final double profit(final double money) { throw new IllegalStateException(); } } . 69) final 중복처리 메서드로 중복처리까지 끝냈다면 -&gt; 새로운 자식들에게 가서 자식들이 extends &amp;&amp; 기존 중복코드들 제거해주기 . Running Hit | Stay | . | . 1. 새 부모로서 extends 처리된 중복메서드만 삭제(final로 막아놔서 -&gt; extends한 자식은 @Override시 빨간줄) . | Ready도 똑같이 처리한다. . | 중요+암기) 추상클래스에서 중복처리시 final을 달아서 처리해주면 -&gt; 기존 개별구현하던 자식들이 extends한 순간부터 딴짓했다고 빨간줄내면서지워달라고 해준다. . 70) 최종 다이어그램 확인하기 . . 중요) 추상클래스에서 전메/추메의 abstract가 나온다면, protected로서 자식들이 개별구현하도록 풀어준다. ex&gt; final 중복처리 메서드 내부에서 상수만 개별구현 . . 중요) 상태패턴 최종 기능파악 + 인터페이스로 약속만 정의 -&gt; 바깥에서 인페 추상체 state를 상태값으로 가진다면, 내부 구현 정보를 모르고 사용만 한다. (인페 추상체는 밖에서 주입해도 되고, 내부에서 즈그들끼리 변해도 되고.. 모른다) &lt;-&gt; state를 추클로 정의하면, 바깥에서 내부 정의를 다안다.? . public interface State { State draw(final Card card); State stay(); Cards cards(); boolean isFinished(); double profit(double money); } . isFinished()가 판단가능해서 끝나지 않았으면, 추가정보로 계속 상태변화 draw( ) | 끝났으면, 그 상태에서 결과계산 profit( ) | | stay()로 주체(Player)가 원할 때, isFinished()에 걸리도록 끝내주고 종료도.. 종료상태를 먼저 만들어주고, isFinished()에 걸려야하는 구나! | . | cards()로 출력이나, 상태업데이트를 위해 현재상태를 가져온다 | 인페는 말그대로 인터페이스만 제공해주고, 내부구현은 모른다. -&gt; 인터페이스로 연결되었다면, Player입장에서는 state 가 어떻게 동작하는지 1도 모른다. (내부동작을 모른다) . 인터페이스는 바깥에서 사용할 때, 내부 구현을 모르는 상테로, 약속에만 맞게 동작하는구나정도만 알 수 있다 Player -&gt; private State state;로 상태값으로 가지긴 하지만, 인페 객체(추상체)를 갖다쓰는 순간 내부 구현고 직접 구현체가 들어갈 때만 거기에 맞게 작동하므로) | . | 인터페이스가 좋다고 해도, 많아지면 장황해진다 | 추클과의 논쟁은 끝이 없다. | . 인페로 정의한 State는 사용자가 내용은 모른체, 원하는 대로 사용할 수 있다. . 71) Player가 인터페이스 객체(추상체)의 state를 상태값으로 가지는 순간, 그 내부 구현은 모르게 된다. . state와는 다른 .player패키지 -&gt; Player를 만들기 . . | State의 사용처는 인페객체 = 추상체를 상태값으로 가져, 내부구현은 모른다. . | 중요) 상태객체가 단독 public으로 열린 최초시작상태Ready 객체가 있다면, 시작이 그것 밖에 없으니, 생성자가 아니더라도 필드에서 바로 new Ready(); = (최초시작상태 객체)로 초기화`해줘도 된다. . 암기) 상태패턴은 필드에서부터 열려있는 접근제어자는 Ready객체 밖에 없어서 private State state = new Ready();로 시작 . Ready로 시작할 수 밖에 없다면, 생성자에서 초기화 안하고 필드에서 해도 된다. . public class Player { private State state = new Ready(); } . . | 72) 상태사용자 Player 등은, 상태업데이트 메서드 state.draw(card)를 사용하는 메서드를 한번더 만들어줘야한다( 객체를 포장하는 조합처럼). + 이 때, 필요한 재료(card)를 바로 줄지, 아니면 더 바깥상태의 재료를 받아서 내부에서 꺼내서서 넘길지(Deck.pick() -&gt; card)는 사용자 맘이다. -&gt; 어떻게 되었든 Player는 인터페이스로 연결된 State를 모른다. . . public class Player { private State state = new Ready(); // state사용 객체 입장에서, 재료 뭉태기를 한번에? public void draw(Deck deck) { state = state.draw(deck.pick()); } //or 1개 재료만? -&gt; 선택 가능함. public void draw(Card card) { state = state.draw(card); } } . 73) 사용자 가 끝나기전 호출가능 메서드들(draw, stay)을 호출하는 메서드를 작성할 때는, 항상 내부에서 현재State가 아직 안 끝난 상태인지 확인후 호출되도록 해야한다. . public interface State { State draw(final Card card); State stay(); Cards cards(); boolean isFinished(); double profit(double money); } . . . 74) state사용자가 상태변화메서드draw()의 재료뭉태기를 파라미터로 + while + is끝난상태객체 될대까지로 돌리면 한번에 계속 호출할 수 도 있다. . . public class Player { private State state = new Ready(); public void draw(Deck deck) { while (!state.isFinished()) { state = state.draw(deck.pick()); } } } . my) 매번 끝났는지 확인가능 + 끝날때까지 재료가 매번 제공되면 -&gt; if로 1동작만 할 것을 -&gt; while로 여러동작할 수 있다. . 메서드가 card를 파라미터로 받는다고 해서 외부에서 card를 직접꺼내주지말고, 외부에서는 card덩어리의 객체를 파라미터로 받아보자 . . Player . draw &lt;- Deck ( = cards by .pick() ) if ! isFinished() state &lt;- card &lt;- Deck.pick() | . | while ! isFinished() state &lt;- card &lt;- Deck.pick() | . | . | draw &lt;- card if ! isFinished() state &lt;- card | . | . | . public class Player { private State state = new Ready(); public void draw(Deck deck) { while (!state.isFinished()) { state = state.draw(deck.pick()); } } public void draw(Card card) { if (!state.isFinished()) { state = state.draw(card); } } } . | . | . 남은일 . 상태패턴에서 stay일 때 profit구현(임시로 money 1배로 반환) | .",
            "url": "blog.chojaeseong.com/java/pattern/state/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/29/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD%EA%B3%BC-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B44.html",
            "relUrl": "/java/pattern/state/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/29/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD%EA%B3%BC-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B44.html",
            "date": " • Mar 29, 2022"
        }
        
    
  
    
        ,"post20": {
            "title": "강의) 네오 3단계 블랙잭 피드백(3/4)",
            "content": "상태객체의 재료검증은 -&gt; 시작후 자기내들끼리 만드니 -&gt; 패키지파서 default로 몰아 내부생성만 가능 except 최초시작객체 -&gt; 검증이 필요없게 된다. . 재료(카드2장)에 대한 각 상태별 예외처리를 해줘야한다? -&gt; 구현체들의 생성자 접근제한자를 default + 패키지 따로 챙기기로 막아, 접근된 코드에서만 만들어지도록 제한하기 (최초시작상태 객체Ready제외) . my+중요) default 접근제한자는 같은 패키지내에서 만 접근 가능해진다 -&gt; 테스트 외 다른 곳에서는 생성못하게 패키지를 실시간으로 1개파서 생성의 안전성을 보장해준다. . 중요) Ready최초시작객체만 public(코드에서 생성가능) 제외 나머지 구현체 상태객체들은 오로지 트리거 메서드 내부 응답시만 생성되도록 패키지에 파서모으고 + default 생성자로 막아 -&gt; 패키지 내부에서만 생성 except Ready최초시작객체만 public 밖에서 생성 -&gt; 외부에서 이상한 재료가지고 생성하는 검증이 필요없이 안전하게 패키지내 서로에 의해서만 생성 + 시작은 Ready객체에서 . 35) 각 상태객체들을 state패키지를 파서 모으고 -&gt; 외부에서 생성되는 Ready를 제외하고default제한자로 바꿔서 -&gt; 테스트를 제외하곤 외부에서 생성X . 패키지를 만들어 추+구현체들을 모으고, 시작Ready를 제외한 다른 구현체들을 패키지내에서만 생성될 수있게 생성자를 default(접근제한자 삭제)해보자. . 몰기 전 . | 패키지 1개에 몰기 . . | . | 중요) 패키지 1개로 파서 몰 때, Test도 같은 이름으로 파서 몰아줘야, default가 작동된다. . . . 중요) 우리가 코드짜면서 외부에서 잘못된 재료로 객체Hit 등을 생성할일은 없다. 클라이언트가 실수하므로 강제로 패키지내에서만 생성되도록 Ready제외 접근제어자를 삭제해서 default로 만들어 외부생성X내부에서만 돌면서 생성되도록 바꿔주자 . my) 특정 객체에서부터만 시작하는 구현체들?? -&gt; 패키지 파서 모으고 1개만 public으로 열어두고 나머지는 default . 시작Ready만 public으로 그대로 둔다. . | 나머지 상태객체들은, state패키지내부에서만 생성가능하게 접근제한자를 삭제해준다. . . . public final class Hit implements State { private final Cards cards; Hit(final Cards cards) { this.cards = cards; } . | 참고) 생성자 정의 안해주면,아직 (재료를 가지고) 생성 한번도 안해봤었다? 상태이며 , 기본이 public 생성자 상태이다. 유틸클래스는 이것을 막아주기 위해 private 빈 상태로 재정의를 해줬던 것이다. . **만약, 생성자 없다? -&gt; 확인해보니, public으로 열려있다. -&gt; 나중에 Bust정의할 때,default로 닫아줘야한다. ** . . | 이제부터는 new Hit( 재료카드2장)으로 생성할 땐, state패키지내 메서드에 의해 생성되어, 외부 잘못된 카드로 인한 생성은 검증이 필요없이 안전한 상태가 된다. . | Ready만 열어줬다고 해서, Ready시작만 되는 것은 아닌 상태임. . | Hit(카드받기 가능)에서 -&gt; Stay안받아의 상태 추가 개발 . 가능한 상태 다시 생각 . 첨 카드 2장만 받고 최대(11+10)으로 bust는 불가능하고 -&gt; blackjack이 최대 높은 사태다 ready +2장 blackjack | hit +1장 bust | blackjack : 블랙잭은 2장일때만 가능이다. | hit | . | hit +stay(): hit상태에서 +1장이 아니라 테스트에선 생략하는 view로 물어보고 -&gt; 추가 메서드를 통해 stay상태로 갈 수 있다. stay | . | . | . | . 35) 기존 트리거 메서드외에 직접 추가한 메서드로 특정상태로 갈 수 있다. (hit -&gt; draw()말고 stay()) -&gt; view에서 물어보고 갈 case를 -&gt; 바로 메서드 호출()하여 case로서 가버리자 . 참고) Test에서는 inputView의 물어보는 과정을 아예 생략하고 그 이후 case로 진행해 나간다. ex&gt; stay할거냐? 안물어보고 바로 stay()로 가는 메서드를 호출 -&gt; 테스트에서 빨간줄로 호출하며 메서드 + 상태객체 다 만들자. . 참고) public외부에서 Ready시작객체로 시작해야하지만, Test에서는 패키지명 동일 -&gt; default 생성자 사용가능 -&gt; 바로 특정 구현체 객체 생성 가능~! . hitTest에서 -&gt; 빨간줄 Stay상태객체로 가는 빨간줄 메서드를 만들자. . . @Test void hitStay() { // given: hit(2,10) State state = new Hit(new Cards(SPADE_TWO, SPADE_JACK)); //when: draw(X) -&gt; stay() -&gt; Stay //state = state.draw(SPACE_TEN); state = state.stay(); //Stay객체가 나와야함. assertThat(state).isInstanceOf(Stay.class); } . | 참고) Test에서 클래스 생성시 -&gt; 빨간줄 -&gt; Create Class -&gt; 패키지명 확인후 tab + ↓ + ↑로 프로덕션 명시해주느 단축키 외우기 . 구현체에서 상태변화 메서드 stay()이전에 Stay클래스 부터 만들어준다. . . 단축키 tab + ↓ + ↑ 를 활용해서 프로덕션으로 빠르게 경로지정해주자. | . | . 상태객체의 class를 생성했따면 -&gt; impl State부터 . 추상체 구현후 generate -&gt; im을 검색해서 추상체 구현메서드를 오버라이딩이랑 구분해서 빠르게 정의해주는 버릇들이자. . . . . | . | 36) Stay클래스 State구현 후 공통 구현메서드는 일단 나중에! Test에서 하던 .stay()부터 개발 . 일단 구현해야하는 메서드는 두자. | 대박) 구현체 메서드 개발시 -&gt; 기본 공통 추메/전메로 올리고 -&gt; 나머지들도 구현해주는데 호출불가시 Thr illegalState -&gt; 호출불가 너무많다? -&gt; 구현체들 impl시 중복되는 코드들을 &lt;부모로써 먹어 자동구현 해주는&gt; 중간 카테고리를 추클(추메/전메를 다 필수구현안해해도 되는 성질)로 추가한 뒤, [추상체-impl-&gt;중간 추클] + 그 아래 구현체들을 [추클-extends-&gt;구현체]로 연결을 바꾼다. . 중요) 추상체변수로 받은 상태에서의 특정 구현체(Hit)에서 불러야하는 메서드(.stay()) 개발은?? 그냥 생성하면 추상체의 추메/전메로 생성되어 -&gt; 나머지 구현체들도 다 구현해야하는… 강제성을 가지게 된다. -&gt; 일단 원하던 특정 구현체에서만 추메/전메를 impl하여 구현 -&gt; 이후 다 구현해줘야하는데, 호출불가 상태에서는 thr예외처리로 해결 . hit상태에서 빨간줄 .stay();를 호출하면 Stay를 생성해줘야한다 . | 그냥 생성해주면.. 추상체의 추메/전메로 정의되어 -&gt; 나머지 구현체들이 구현해야한다 . 현재는 Hit에서 .stay()만 필요한 상태인데??? 일단은 추메/전메로 올려놓고 -&gt; 다시 Hit로 가서 구현해준다. | . | . . | 중요) 특정구현체에만 필요한 메서드 (hit에서 .stay())라도, 추상체 변수상태의 추메/전메로 생성된다 -&gt; (여러구현체 다 빨간색 impl요구 된 상태지만) 특정구현체로 먼저 가서 추메/전메를 구현해준다. -&gt; 이후 호출할 수 없는 구현체는 thr illegalState 예외처리로 해결한다 . Hit용 메서드가 -&gt; 추상체State의 추메/전메로 올라와 버리는 바람에 구현체 다 빨간줄상태지만, Hit부터 가서 추메/전메를 구현해서 정의해준다. . public interface State { State draw(final Card card); State stay(); } . | 원래 해당 메서드가 필요했던 특정구현체Hit로 먼저 가서 구현까지 해준다. . 호출시 바로 Stay상태가 되어야하므로 객체 생성해서 건네준다. | . . @Override public State stay() { return new Stay(); } . | 정리용) . 37) 나머지 구현체들도 강제로 구현해야한다. 호출불가 상태객체에서는 thr illegalState 처리 . hit를 제외하고 . @Override public State stay() { return new Stay(); } . Blackjack이 stay가능?(X) . | Bust이 stay가능?(X) . | Ready이 stay가능?(X) . Stay이 stay가능?(X) | 다 구현후 thr illegalState 처리 . | alt+insert -&gt; impl검색 -&gt; stay()구현 -&gt; thr 처리 | . @Override public State stay() { throw new IllegalStateException(); } . | . | 이제 hitStay에서 .stay()를 테스트할 수 있다. . @Test void hitStay() { // given: hit(2,10) State state = new Hit(new Cards(SPADE_TWO, SPADE_JACK)); //when: draw(X) -&gt; stay() -&gt; Stay //state = state.draw(SPACE_TEN); state = state.stay(); //Stay객체가 나와야함. assertThat(state).isInstanceOf(Stay.class); } . | . ### . 중요) 특정구현체용 메서드를 추상체에 올린후-&gt;구현-&gt;나머지 처리했더니 대부분이 사용안하고 예외처리다? -&gt; [중복코드를 부모로써 먹어주는 중간 카테고리 추클]을 [추상체-impl-&gt;추클]로 추가한 추상화를 하고 그 아래 구현체들을 [추클-extends-&gt;구현체]로 연결한다. . 기존 상태 . State(I, 첫 상카, 추상체) - Ready포함 여러 구현체들(final Class) | . . | . 38) 추메/전략을 구현하는 구현체or구현체들을 제외하고 나머지 대부분의 구현체들이 -&gt; 구현하면안되서 illegalState처리하는 그룹이 많아지면, 중복코드를 부모로써 먹어주는 추클로 중간 카테고리를 끼워넣되, 구현체들의 구조 상카impl-&gt; 중카extends -&gt; 구현체로 바뀐다. . 중요) 구현체용 단독메서드를 위에서 올려서 구현하다보니, 일부 구현체들은 안쓰는 코드로서 코드중복 -&gt; 특정 구현체들 묶음으로 묶어 코드중복을 없애줄 중간카테고리로 추상화하는 생각 + 중카는 추클로 추가한다. -&gt; 이름을... 구현체들 왜?? 묶는지로 생각해서 작명해주자. . 중요) 상카-추상체에서 타고 내려오는 메서드들의 코드중복만 추클이 먹어줄 수 있다. -&gt; 구현체들이 interface 공통인 추메/전메 이외에 다른 것을 구현했어도, 공통인 추메/전메에서 중복되는지만 확인해서 중간 카테고라이징해준다. . 중요) 특정 메서드의 중복발생이지만 -&gt; 중간 추클로 코드중복 제거시 -&gt; 상카의 전메/추메의 목록을 다 보면서 중간 카테고라이징 한다 . public interface State { State draw(final Card card); State stay(); } . stay()에 의해 코드 중복이 발생했지만, draw()도 같이 중복이 일어나는지 살펴서 중간 카테고라이징 한다. . | Hit만 stay된다. -&gt; 나머지 구현체들은 다 예외처리로 구현되어 중복이 발생했다. . Ready는 stay예외처리는 똑같지만, draw에서 코드 중복이 안일어난다. . | Blackjac, Bust, Stay는 이미 다 끝난 최종 상태객체로서 더이상 트리거 메서드 모두(draw, stay) 다 호출 불가 -&gt; 모든 추메/전메의 구현이 중복된다. . @Override public State draw(final Card card) { throw new IllegalStateException(); } @Override public State stay() { throw new IllegalStateException(); } } . | . | . 중간에 중간카테고리를 추상클래스로 추가하고, 상위카테고리 State를 imple해줘야한다. . 중간 카테고리 이름은? .stay() 못해서 thr처리 된 이유?를 생각해보면 Finished로 이미 끝났기 때문이다. 사실 Stay는 이미 stay를 호출해서 끝난 것 | . | State(최초상카, I) &lt;—&gt; 구현체들(final Class) 사이에 들어가 특정 구현체들 묶음으로 묶어 코드중복을 없애줄 중카 Finished를 끼워놓자 | 네오는 인터페이스에 정의한 필수 구현 추메/전메를 default메서드라고 불렀다. | . | 중요-용어) 추메/전메로 타고 개발한 구현체용 메서드가 추메/전메로 정의된 default메서드로서 구현체들에게 중복코드를 계속 imple시킨다면, 상카 &lt;-&gt; 구현체들사이 [중복코드를 부모로써 먹어주는 중간 카테고리] 추클로 추상화를 고려한다. . 구현체들의 중복된 예외처리 코드를 부모로써 먹어서 자동구현해주는 추상클래스를 중간카테고리로 추가한다. . 이미 stay로 가기엔 hit가 아닌 끝난 상태라서 .stay()를 호출못해서 예외처리코드로 코드 중복이 되는 상태이므로 중간 카테고리 추상클래스이름을 Finished로 끝난 상태라 stay못함.으로 지어준다. 여기에 Stay도 포함되어있다. | . | . . | 중요) 상카(interface)가 존재한 상태에서 [코드중복 먹어 자동구현시킬려고 끼운 중간카테고리 추상클래스]는 상카인 interface를 impl시켜야한다 . 중간 카테고리로서 끼어들어간 추클은 상카 State(I)를 impl해야한다. 클래스와 달리, 추상클래스는 추메/전메impl 필수구현이 아니다. | 그래도 추메/전메를 모두 구현해놔야 기존 상카 구현체들로서 모든 추메/전메를 받아먹게 된다 | . | . 중요) 상카(I)를 impl한 클래스와 달리, 상카를 impl한 추상클래스는 상카의 추메/전메가 필수 구현이 아니다. (cf.abstract를 지우면 필수구현하라고 뜸) -&gt; 추상체 중 원하는 메서드만 구현할 수 있기 때문에, 구현체들에서 발생하는 코드 중복의 [특정 메서드]만 대신 구현이 가능해진다. 하지만, 일단 모든 추메/전메를 impl구현해야 -&gt; 하카 속 자식들이 [원래 목적인 상카Interface의 구현체=상태객체]로서 성질이 유지될 것이다. + 중카 추클을 안끼워놓은 상카 구현체(상태객체들)이랑도 상호 호환되어야하는데, 중카 추클 있는데, 상카의 추메/전메가 없는 구현체(상태객체)가 되면 의미가 없다 -&gt; 중복제거 특정메서드 + 모든 상위 카테고리 추상체의 추메/전메 모두 받아먹을 수 있도록 -&gt; 중카 추클은 상카 인터페이스 impl시 모든 추메/전메를 impl구현해야만 한다. . 추메/전메를 가진 상카 인터페이스를 impl했지만, 전메/추메/default메서드 구현하라고 빨간줄이 안뜬다 중간 추클은 구현체가 아니다. 필수 구현 안해도 된다. -&gt; 그러나 중카 추클 추가 전에 상태 Interface의 구현체역할이 더 중요하므로 추메/전메도 같이 받아먹어야한다. | . | abstract를 지우면, 인터페이스의 구현체로서 필수 구현해야한다. . | 추클은 구현안해도 되지만, 추클 중간에 끼워넣기 이전에 interface의 구현체 성질(상태객체)가 먼저다! | . 중요) 잔소리말고, 코드 중복 제거를 위한 중간카테고리=추클은 -&gt; 기존 구현체 성질 유지를 위해서, 무조건 [필수는 아니지만 모든 추메/전메 impl구현] 하자! . 39) 중간 추클은 구현체가 아니라서 필수구현 안해도 된다. -&gt; 이 성질을 이용해서 특정메서드만 구현가능하지만, 일부 구현체그룹 중복발생 메서드stay()이외에 공통 추메/전메인 draw()도 impl해서 같이 중복처리를 해주는 버릇을 들이자. . 참고) 구현체들의 중복코드를 추클로 올릴 땐, impl로 껍데기는 구현 -&gt; 내부 코드는 중복되는 코드를 가진 구현체에서 직접 복사 붙혀넣기해서 대신 구현해주는게 젤 좋다.(100%중복되니까) . 현재 hit를 제외한 구현체들에서 stay() { 예외처리 }부분만 코드 중복이었지만, 상카의 구현체로서의 역할유지를 위해 모든 추메/전메를 impl해서 카테고라이장 하려고 해보자. . . . 일부구현체 코드 중복은 stay()에서만 발생했지만, 모두 impl해서 살펴보자 . . | . | 중요) 특정 메서드의 코드중복 -&gt; 다른 공통메서드들도 같이 살펴 볼 것!! . 살펴보니, stay뿐만 아니라 draw에서도 공통적으로 코드 중복이 일어나는 클래스들이 발견되었다. . | 중복코드는 직접 impl구현하지말고, 구현체 1개에서 다 똑같은 중복코드를 복붙해오자 . . public abstract class Finished implements State { @Override public State draw(final Card card) { throw new IllegalStateException(); } @Override public State stay() { throw new IllegalStateException(); } //blackjack, bust, stay 중복 -&gt; 중간 추클을 extends하도록 변경해야함. } . | my) 뜬금포: 중간 카테고리는 특정 상태가 많을 것이다. 상카는 전체 대명사에서 시작 -&gt; 중카는 대명사에서 이어지는 상태 형용사?! ( State -&gt; Finished(state)의 형용사) . 이제 중복코드를 가진 중간 카테고리 아래 구현체들이 코드 중복을 대신 구현해주는 부모로서 중간 추클(Finished)을 extends하도록 변경해준다. . 코드 중복 하위 카테고리 -&gt; blackjack, bust, stay . | 가장 상위 카테고리 상위카테고리 추상체 State를 impl -&gt; 코드중복 먹어주는 중간 추클 Finished를 부모로서 extends로 변경 . | . - . . | ​ . ​ . 중요) extends가 보인다면, extends로 부모(추클)의 중복코드 받아먹는 중 -&gt; 내부 코드는 제거된 상태로 먼저 생각하자!! . 중요) impl한 구상체에 @overriding은 필수구현 추메/전메 구현중이라고 생각 + cf) impl한 추클이라도 필수가 아닌 것 같지만, 모든 추메/전메를 구현해야 의미가 있다 . 중요) extends한 자식내부에서 @overriding이 있다면, 부모가 중복코드 먹어 구현해주는 데도 @또 고쳐쓴다로 해석하자. + 원래는 딴짓 못하게 부모인 추클 메서드 [모두impl]하여 정의시 final로 막아야한다 . **extends가 보이면, 부모가 중복코드를 먹어 대신 구현해 내려주는 중이라고 생각하고 ** . 추상체 인페의 impl하는 구상체에서의 @overrding == 필수 추메/전메 구현중은 지우고, extends로 중복먹어 내려주는 것을 받아먹자 | . . . public final class Blackjack extends Finished { private final Cards cards; Blackjack(final Cards cards) { this.cards = cards; } } . | . 중요) extends를 치는 순간부터, 부모가 중복코드 내려주는 중이니, 생략된체 받아먹자. 생각 -&gt; 만약, 자식으로 받아먹기 이전에, 구현체로서 impl + @Overriding의 추메/전메 필수 구현이 있었다면 -&gt; 삭제하여 자식으로서 받아먹고, 구현체로서 받아오는 역할은 추클(중카)에게 맡기자 . . . . 나머지 2개 중간카테고리 아래자식들도 다 extends로 중복코드 받아먹고 코드는 제거하자 | . ​ . java public final class Bust extends Finished { } . ​ . Stay도 이미 Finished된 상태로 draw/stay예외처리하는 코드 중복이 발생하니 . extends 중간추클(부모) -&gt; 중복코드 받아먹기 -&gt; impl + @overridng 추메/전메 필수구현은 삭제 | . . . . public class Stay extends Finished { } . | . extends로 중카=추클=부모가 중복코드 구현해주고 받아먹는 중인데, 자식들이 중복코드 받아먹는 와중에 extends + @또 고쳐쓸 수 있다면? 불안한다 -&gt; 추클이 중복 코드 impl구현 부모 역할시의 모든 상카 추메/전메 impl구현할 때 -&gt; final or abstract를 달아줘서 중복코드 받아먹는 자식들이 딴짓 못하게한다. . 40) 중복코드 구현 추클 부모(중간 카테고리)는 내려줄 때, 자식이 extends후 받아먹기만 하고, @고쳐쓰는 것은 못하도록 -&gt; 추클 메서드에는 final (or abstract)를 미리 달아서 정의해놓는다. . 중요) 특정구현체 메서드 개발에서 비롯된, 코드중복 제거용 추클(중간 카테고리)이 예의상 추메/전메를 모두 구현해서 코드중복을 해결해줬는데, 추클이 중복제거할라고 impl 구현한 추메/전메에는 final (or abstact)을 달아서, 받아먹는 자식들이 딴짓(extends받아먹은 후 @또 고쳐쓰기)못하게 막자 . 상카 구현체들 중 특정 카테고리의 추메/전메의 중복코드를 구현해주는 추상클래스에서는 자식들이 extends로 받아먹게만 하고, extends후 @또 고쳐쓰기 못하게 final or abstract를 달아주자. . my) 추메가 중간에서 중카로서 중복제거 역할로서 끼워진다면 . impl 상카(추상체,interface)할 때부터 모든 추메/전메 impl구현 . . . . | . | . | ​ . - **추클은 부모로서 자식들이 중복코드 받아간다 -&gt; `추메/전메impl 직후 -&gt;자식을 가진 부모라면 내부 final or abstract부터 정해주기`** ![image-20220321212127531](https://raw.githubusercontent.com/is2js/screenshots/main/image-20220321212127531.png) - 추클의 2가지 작업(모든impl 구현 + final or abstract 달아주기)가 **구현체(자식될 놈)들 중 1개에서 중복코드를 복붙해와서 메소드 구현해준다.** ![image-20220321212255907](https://raw.githubusercontent.com/is2js/screenshots/main/image-20220321212255907.png) java public abstract class Finished implements State { @Override public final State draw(final Card card) { throw new IllegalStateException(); // 구현체 블랙잭한테 복사해온 중복코드 } @Override public final State stay() { throw new IllegalStateException(); // 구현체 블랙잭한테 복사해온 중복코드 } } . . 중요+정리) 코드 중복을 먹어서 자식에게 제공해주는 추클 끼워넣을 시, 해줘야하는 2가지 작업 . 기존 상위카테고리로서 interface의 모든 추메/전메를 구현한다 그래야 기존 상카(interface) 추메/전메&lt;—&gt; 구현체들(Class) 추메/전메 필수 구현의 관계가 유지된다. | 추상클래스는 상카(interface)를 impl해도 추메/전메 필수구현이 아닌 상태다. 그래도 생각말고, 모두 impl해주자 | . | . | impl 추메/전메의 모든 구현 직후 추클은 중복먹어 내려보내주는 부모인데 자식들이 가져가서 고쳐쓰거나 딴짓 못하게 final or abstract으로 메서드들 막아주기 | 41) 중카 추클 끼워넣기로 중복제거 완료후 -&gt; stay로 다시 돌아와서 -&gt; 도메인 테스트를 해준다. 개발기능: Stay상태객체 개발 및 hit이외에 나머지는 .stay() 호출안되는 예외처리 . hit-&gt; Stay를 테스트하는 와중이었다 . | Stay 도메인이 개발되었고, .stay()호출 기능도 개발되었다. . hit Stay는 통과했다. | 나머지 state(blackjack, Bust, Stay) -&gt; .stay() -&gt; 예외발생 테스트 굳이 Stay | | | 중요) new 구현체 () 생성시에는 항상 변수를 추상체로 바꿔서 받아주자! . new 구현체 생성시, 변수추출하는데, 변수형은 추상체로 바꿔받자 . . @Test void stay() { final State stay = new Stay(); } . | 참고) 호출시 예외발생하여 종료 테스트 -&gt; assert문 내부에서 호출하기~ . 이미 끝난 상태로서 Stay상태에서느 .stay() 호출시 예외발생하고 종료되어야할 때 . @Test void stayStay() { // stay -&gt; .stay() 호출 불가 final State state = new Stay(); // stay에서 stay()하면 안됨 -&gt; 예외발생되서 종료되야 정상 -&gt; assert문에서 호출 assertThrows(IllegalStateException.class, () -&gt; state.stay()); } . | 추가로 Stay상태에서 .draw()호출해도, 이미 끝난 상태로서 예외발생하고 종료해야한다. . @Test void stayDraw() { // stay -&gt; .draw(카드1장) 호출 불가 final State state = new Stay(); // stay에서 stay()하면 안됨 -&gt; 예외발생되서 종료되야 정상 -&gt; assert문에서 호출 assertThrows(IllegalStateException.class, () -&gt; state.draw(SPADE_ACE)); } . | 중요) 중복코드 구현체들을 위해 중카(추클)을 하나만 끼워넣으면, Layer가 안맞다 -&gt; 중복없는 구현체들도 Layer용 중카 추클을 끼워넣어준다 . . 현재 Finished만 중간 카테고리 (추상클래스 Layer)를 가져서 Layer구조가 안맞다. | . 참고) Stay class에 final을 안붙혀줬더니 다이어그램상 *모양이 없다 . . . . 42) Ready.start() 부분을 모두 리팩토링 -&gt; 돌아가서 회색메서드가 되면 안전삭제 . 중요) 메서드 테스트, 통합테스트는 개별적인 도메인 테스트와 달리, 객체들이 합쳐졌을 때 잘 작동하는지 확인할 수 있다. -&gt; 여러 객체들을 복합적으로 테스트 but 자기맘 . State객체의 모든 상태객체들은 결국 판단 및 새 객체응답판단시 뿐만 아니라 -&gt; 결과 보여주기 or View에 넘겨주기 위해 정보(상태값) 뿐만 아니라 getter조회메서드까지 무조건 가지고 있어야한다. -&gt; 전체 공통 메서드이므로 추메/전메로서 interface에 올려서 개발시작하며 중간카테고리가 존재한다면, 속하는 구현체(자식들)이 코드중복인지 아닌지 한번더 살핀다 . 43) 모든 상태객체는 결국엔 정보값에 + [getter메서드]를 가져야한다. 메서드이므로 interface에 올려서 개발시작하자 -&gt; getter는 getXXXX보다는 필드명 or 일급명을 소문자로 네이밍하자 . 참고) .getValue() 대신 상태응답값(returnType)과 함께 .인스턴스변수(상태값)명() or .일급상태값()으로 getter메서드를 네이밍 해보자. . 모든 상태객체마다 상태값(Cards)를 조회하는 메서드를 정의하기 위해 상카 추상체 State에 추메/전메로 올려서 개발시작한다 . public interface State { State draw(final Card card); State stay(); Cards cards(); } . Cards는 상태값 일급컬렉션이다. | . | 중요) 구현체들의 공통메서드를 추가할 땐, 최상위 상카 인터페이스에 추메/전메로 올린 뒤 -&gt; 구현체 개별구현인데, 인페추클구현체들로서 중복코드제거용 중카가 껴있다면? 해당하는 자식(구현체)들이 코드 중복인지 아닌지 먼저 살핀다 . . 중요) 중간에 추클로 코드중복제거해서 묶인 구현체들(자식들)은 이제 무조건 통해서 오는 추클의 자식들이 됬으므로, 항상 개별 구현 전에, 묶어서 부모에서 중복 먹일 수 있나 없나부터 먼저 생각해야한다. . 중요) 중카, 추클은 필수구현이 아니지만, 중간자식들의 구현체 성질 유지를 위해 모든 추메/전메impl 해야만 했다. 추메/전메에 새 메서드가 올라갔어도 [중카, 추클은 필수impl아니라서 놔둬도 빨간줄 안날줄 알았는데...] -&gt; 자식들이 빨간줄로 화나있다. -&gt; 살펴보니, 중카-추클이 impl안한, 상카-추메/전메에 대해서, 모두 구현안해주면, 자식들이 화를 난다. . . . 하위 자식들(구현체) 3개를 임시로 삭제하면, 추클에서는 에러 안난다. . | 이번엔, 추클이 impl구현한 메서드2개 중 1개를 삭제했더니 -&gt; 자식들이 화를 낸다. . . | . 중요) 결론적으로, 중카 추클은 추메/전메의 모든 impl구현이 필수가 아닌 것 같지만, 모두 impl안해주면, 자식들이 에러가 난다. . 추클 자체에러는 없지만, 자식들이 위에서 화를 내고 있다. -&gt; 추가되는 전메/추메는 모두 구현해줘야한다. . . | . 중요) 뭐야.. 중카 추클이 모두impl안해도 화내던 자식들에서 개별 impl구현해도 된다?!! . 중카 추클 Finished에서 .cards() 구현안해서 자식들이 화난 상황 . | 화난 개별 자식들에서 빨간줄 제거를 위해 impl해보았더니, 에러가 사라진다. . | . ​ . ​ . 인터페이스가 상위 인터페이스 - 구현 추상클래스 -의 자식들 중 하나인 blackjack을 추클 구현impl이 없다면, 직접적인 구현체들처럼 실제 구현으로 받아들인다. . . | . 정리 그림 . . 45) 새롭게 상카 추메/전메에 올린 getter(.cards())에 대해, 구현체들 개별 필수구현전에, 중간카테고리 추클의 하위 자식(구현체)들 Blackjack, Bust, Stay에 중복이라면, 추클에서 정의해줘서 받아먹게 해준다. -&gt; `중카 추클은 코드중복을 위해 묶여있기 때문에… . 중요) 새로운 메서드가 상카-인터페이스부터 타고 추가될건데, 중카-추클에 걸린다면, 추클의 목적상 하위자식들의 코드중복이므로, 중복되는 상황인지 보고 중복되면 중카에 vs 중카-추클에 구현안하고 개별 자식들에게 책임전과하여 개별구현도 가능하니 중복 안되면 중카-추클에서 정의하지말고 내려오는 추메/전메에 대해 중카-추클 무시 맨 끝 자식들에서 개별구현으로 구현책임 전과해도 된다. 반대로 여러 구현체에서 전체 중복이면 -&gt; 상카 인터페이스 직전에 중카-추클을 끼워넣어 전체 중복코드만 먹일 수 있다. ex&gt; 이후 Started가 그 예시 . getter인 cards()메서드는 3개 자식들에 대해 중복적으로 필요하다. . 그렇다면, 중카 추클에서 중복코드로서 대신 구현해서 -&gt; 자식들이 개별구현안해도 받아먹을 수 있게 해줘야한다 추클에서 필수아니라고 새로생긴 추메/전메를 impl구현 안해놓으면, 자식들에게 필수 구현으로서 전과됨을 참고하자 | . | . . | . 중요) getter를 구현할 때 필요한 상태값(인스턴스변수)도 있어야한다. getter는 중복이라서 추클에 대신구현으로 정의했는데, 상태값 -&gt; 자연스럽게 따라오는 [(최초시작 아니라면 -&gt; 여기선 끝난 상태객체 3개) 외부에서 재료를 받아 최초 상태값을 초기화해줄 재료받는 생성자] 정의도 중복이다! -&gt; 추클에선 자식들(구현체) 생성자 중복을 protected로 정의해줘야, 구현체(자식들)이 자기들 public생성자에서 &lt;주생성자 대신 부모것을 주생이라 여이고&gt; super() == 중복된 코드를 갖다써서 외부에서 재료를 받아 가공할 수 있게 된다. . 46) getter메서드가 끝난상태객체에서도 공통필수메서드면 -&gt; 상태값도 모든 구현체들에게 필수이다. -&gt; getter에 대한 상태값들도 중복코드로서 추클에서 정의해주자. . 중요) 상태값(인스턴스변수) = 필드를 생성할 땐, 가공전 raw상태값을 재료로 받는 or 최초시작이면 재료없이 내부 빈 상태값으로 초기화해주는 생성자 2개를 먼저 생각한다. . 현재 getter인 cards()에 쓸 상태값을 가져야하는 상황이 왔다면, -&gt; 가공전raw상태값 재료 생성자 or 내부 빈재료 생성자를 먼저 선언해주는 버릇을 가지자. . . 생성자 선언전에 가공전raw상태값을 재료로? 재료없이 내부에서 빈 상태값으로? 먼저 선택한다. 끝난 최종상태객체이므로 무조건 직전까지 업데이트된 상태값을 재료로 받아 가공하여 생성되는 객체다 | . | . | 중요) 추클속 코드중복 제거용 생성자는 &lt;외부에서 쓰는 구현체.메서드()와 달리 [자식 내부에서 주생this()쓰듯이 부모super()를 갖다쓰도록 하기 위해 -&gt; protected로 선언한다 . my) 추클, 부모에서 생성자 중복코드는 protected로 선언해줘야, 자식들이 주생성자를 this()로 갖다쓰듯이, 부모생성자를 super()로 갖다써서 자기들 생성자를 정의한다. . . . public abstract class Finished implements State { protected Finished() { } . 참고로 파라미터도 바꿀꺼면, 접근제한자도 같이 ctrl+F6의 change signature로 바꿀 수 있다. . | 추클의 생성자를 change signature로 public or proteced상태로 생성자 리팩토링 한다면 -&gt; extends 자식들에게 자동으로 직접구현까지 해준다 . public으로 추상클래스(부모)에서 생성자 리팩토링 예시 . . | . | . 중요) 생성자를 정의할 땐, 미리 생각해둔 초기화할 상태값 생각후 -&gt; 가공전 raw상태의 외부 재료를 생각해서 기입한다 . 상태값은 일급인 Cards를 가질 예정이다 -&gt; raw상태의 일급Cards가 들어올만한게… 그냥 직전 상태객체의 Cards가 들어와 만들 것임. . 생성자의 파라미터 변경은 ctrl+F6의 change signature를 계속 연습하자. . . public abstract class Finished implements State { protected Finished(final Cards cards) { } . | change signature로 생성자를 수정하면, 추클 -&gt; 자식들에 super()로 내부에서 직접 갖다쓰도록 코드까지 짜준다. . . . . | 근데… Cards cards의 재료를 받는 생성자를 protected로 리팩토링 했는데 -&gt; 재료안받는 생성자로 정의해줬다 -&gt; 삭제해도 될듯.. . 삭제하고 -&gt; 직접 생성자 다시 생성해줌 | . . . | . | . 중요) 상태값을 정의해야한다면, 무조건 생성자부터 -&gt; (재료로 가공후 ) 생성자 내부에서 this.예비상태값 = 에 초기화 하면서 -&gt; 빨간줄로 예비상태값 자동 생성/선언되도록 해주자. . 생성자가 완료되었으면, 생성자 내부에서 상태값을 초기화화면서 상태값을 선언해준다 . . . public abstract class Finished implements State { private final Cards cards; protected Finished(final Cards cards) { this.cards = cards; } . | 47) 재료받는 생성자 -&gt; 상태값 초기화 -&gt; 상태값 선언이후, getter메서드를 완성해준다. . . @Override public Cards cards() { return cards; } . . getter메서드 완성시 (1) 나가는 값이 불변객체하냐 안하냐에 따라 Dto없이 + public으로 열어두기 가능해지며 + (2) 추클내 메서드라면 자식딴짓 방지용 final/abstract를 정해주자 . 48) getter로 응답되는 값이 불변객체(현재 불변 일급컬렉션)이라면 public으로 열어두기가 가능하며 -&gt; dto도 없어도 된다 . 참고) 암기 : getter정의시 return 불변객체라면, public열어두기 가능 + dto없어도 됨 . . 추클내 메서드라면 final or abstract . 추클의 메서드가 getter가 아니더라도 중복코드제거용으로 추가된다면 . final/abstract를 결정해주자 | . . @Override public final Cards cards() { return cards; } . | 49) 추클의 중복제거 중간카테고리에 속하지 않은 개별 구현체(Hit, Stay)들에도 추메/전메(getter) 직접 구현해주기 + if 상태값도 없으면 return 상태값 -&gt; 생성자부터 . . Ready(최초상태객체)도 .cards()의 getter로 상태값을 보여줘야할까? -&gt; 필요없으면 thr처리를 하면되므로 구현체라면, 일단은 필수로 impl해줘야한다. . . . 중요) getter를 짠다고 해서 view에서 보여주는 방식을 생각하지마라 . 딜러 카드를 view에서 1장만 보여준다고해서, 도메인을 설계할 때 반영되면 안된다. | . Ready는 재료없이 빈 재료로 최초 생성되는 상태객체로서 getter로 외부에 보여줄 필요 없는 것 같지만, 1장 만 받아서 아직 다른 구현체 상태객체로 가기 전단계도 있다. -&gt; 선택이다. -&gt; 무조건 2장으로 다채워지기 전까지 cards를 외부에 보여주지말자 vs 1장 받았을 때 보여줘도 될 것 같다 —&gt; 여기선 1장 일때 보여줘도 되니까, Ready에서도 getter가지도록 설계해보자. . . 1장을 가져도 못보게할려면 예외처리하면 된다. | . Hit에서도 getter인 cards구현 . . 새롭게 추가된 추메/전메(getter) 구현 후 기존 중간카테고리-추클(Finished)을 포함한 다른메서드/중카를 무시하고 오로지 모든 구현체의 특정메서드 1개 중복제거를 위한 추가 [중카-추클] 더 위쪽에서 집어넣기 . . 중요) 기존에 이미 중간카테고리=추상클래스=구현체들 중복코드 제거용이 있음에도 -&gt; 새로운 추메/전메 1개의 중복코드 제거를 위한 추클을 더 위쪽에 끼워넣는다 . 중요) 만약, getter같이 ALL 중복 메서드가 추가되었다면, 기존 중간카테고리=추클로 묶인 구현체자식들을 포함한 새 중카=추클을 더 위쪽에서 한번 더 먹어준다고 생각하자 . 중요+정리) 새롭게 추가된 모든 구현체의 추메/전메의 중복코드 제거를 위한 중간카테고리 - 추상클래스 추가 후 할일: 1 abstract달기 2 인페를 impl후 &lt;자식들이 아직 구현안하고 있으면 전과되서 화내니&gt; 상카(인페) 모든 추메/전메 impl하기 or &lt;자식들이 이미 개별 구현하고 있는 상황 == 현재 묶이는 범위가 아니라면ex.중카의 중카추가 상황&gt; 기존 추메/전메는 그대로 전과시켜놓고 새로 추가된 중복되는 추메/전메만 impl구현하기 3 추메메서드 impl되었다면, 자식들딴짓못하게 막기 4 만약 getter등 상태값을 필요로 하는 메서드다? -&gt; 인페가 중복이어도 못먹어주던 상태값 중복 + protected생성자 중복도 고려해서 먹어주기(추클로 묶이는 놈들은 대부분-&gt; 정보를 가진놈이니 상태값+생성자는 거의 같이 묶일거라고 본다.) 5 중복코드 특정 구현체 1개에서 가져와 복붙해주기 6 구현체들(여기선 중카도 포함)을 인터페이스 구현체 -&gt; 추클의 자식으로 바꾸면서, 중복코드들 제거해주기 . my) 메서드명 중복이 우선 -&gt; 인터페이스 —&gt; (모든or일부) 구현체들의 (특정)메서드 내용까지 중복 발생 —&gt; 추상클래스 —&gt; 추클 중복코드제거시 인터페이스가 못하던 상태값과 그에 필요한 생성자도 중복제거를 고려해줄 것 . getter cards()는 모든 구현체+ 추클(자식들-&gt;추클에서 먹기)이 중복이다 이럴 경우, 다 묶고 싶어서 새로운 중카-추클을 더 위쪽에 집어넣는다. | . | 중간 카테고리는 상위카테고리 State(대명사)의 특정 상태로서 형용사로 네이밍하면 편하다 State &lt;— 형용사Started —&gt; Finished + 아직 덜 끝난 개별구현체 상태들 | . | . public abstract class Started implements State { } . 중카추클1) abstract (or final)을 class앞에 달아주기 . public final class Started { } . . 중카추클2) 인터페이스 impl후 구현체들+기존중카추클이 기존 메서드들에 대해 이미 구현 전과되어서 개별구현 중인 추메/전메는 그냥 두고 -&gt; 새롭게 추가되어 impl(개별)구현없이 중복 되어있는 메서드에 대해서만 중복제거용으로 먹어주기 . . 추클은 impl하라고 빨간줄 안뜨니 직접 챙겨서 해야한다. . . | 추클 impl시 이미 자식들or기존 중카 추클에서 전과되어 개별 구현하고 있는 내용은 그대로 둔다. . | . . **stay+draw는 이미 전과 개별구현 중이다. + 전체중복도 아니라서 고려대상도 아니다. ** 아래로 묶일 녀석들(구현체+@중카추클)에 대해 모두 중복되는 메서드만, 추클에 정의한다 | . | . . . 중카추클3) 추클에 impl되는 메서드들은 자식들에게 내려주는 놈들이니 final or abstract를 달자 . . 중카추클4) 추클이 메서드 먹어주는 와중에, 상태값이 필요로하면 -&gt; protected생성자와 상태값도 중복코드인지 확인하고(대부분 중복일 듯) -&gt; 추클에서 먹어준다. . 현재 기존 추가된 중카=추클인 Finished에서도, 3개 구현체-&gt;자식들에 대해, 상태값과 생성자는 중복이라서 중복코드로서 추클이 먹어준 상태 . . | 여기(Started)에서도 모든 상태객체는 모두 getter를 가지며 -&gt; 그에 따라 상태값+생성자 역시 모두 가질 것이니 -&gt; 상태값과 그에 필요한 protected생성자를 추클에 정의해주자 . 상태값을 생각해서 -&gt; 생성자에 가공안된 raw상태값을 파라미터로 받아주도록 정의 . . | protected생성자에 따라서, 필드는 빨간줄 자동생성 해준다. . | | . 중카추클5) 중복코드 구현체 중 1개 복붙해오기 (여기선getter + protected생성자 + 상태값이라 라 간단해서 복붙하는 것은 생략됨) . . . public abstract class Started implements State { private final Cards cards; protected Started(final Cards cards) { this.cards = cards; } @Override public final Cards cards() { return cards; } } . 중카추클6) &lt;&lt; 기존 추클 &gt;&gt; -&gt; 개별 구현체 순으로 기존 상카-인페를 impl하던 구현체에서 -&gt; 끼어들어가는 새로운 추클을 부모로 extends하면서, 내려받을 중복코드를 삭제해주자 . 기존 중간카테고리가, 기존 연결을 끊고 더 위쪽에 생긴 새로운 중간카테고리를 부모로서 받아와 보자. . 기존 구조 . . | State - Finished의 관계인 impl State을 끊고 -&gt; impl State를 하고 있는 새로운 카테고리 Started를 끼워놓고 기존 추클의 부모 추클로서 extends new중카(추클)해주자 . . | . 중요) 추클은 protected의 생성자 중복(+상태값)도 정의해서 내려준다. -&gt; extends하는 구현체성질 자식들은 주생성자호출 하듯 생성자 정의를 super()로 중복코드를 갖다쓴다 . . 에러 해결할 때, 자식 생성자 내부에 super()를 써서, 부모생성자를 this주생성자처럼 사용하여 -&gt; 상태값 초기화 중복을 해결해라고 한다. | . 중요) protected생성자를 내려주는 추클을 extends를 하는 순간, 생성자 없으면 super()로 생성자도 갖다쓸거다 or 이미 자식에 생성자 있었다면, (내려주는 super생성자 vs 기존 생성자가 [상태값 초기화 부분에서 부딪혀] 빨간줄 나는데) -&gt; this.상태값 = 초기화 ] 대신, [내려주는 생성자super()를 주생성자로 생각]하여, 외부재료를 가공해서 넣어주자라고 생각하자. -&gt; 내려주는 생성자가 부딪힌다면 상태값 초기화 부분이 내려주는 생성자 vs 기존 생성자가 부딪히니 -&gt; 기존 생성자에서 super()를 활용해 초기화하여 해결한다. . 기존 추클이, 새로운 추클을 부모로 extends했다. . | 그 순간부터 **중복코드 메서드 + 중복코드 protecetd생성자를 super()로 내려준다고 생각해야하며 ** . 기존 생성자가 있다면, 내려주는 생성자 vs 기존 생성자가 가장 중요한 역할인[상태값 초기화 부분]에서 부딪힌다. | . | . 암기) 부모가 내려주는 생성자 vs 기존 생성자의 해결은 자식의 생성자 내부에에서 super()를 this()처럼 사용하여 상태값 초기화 역할의 중복을 해결해준다. . 부모의 protected생성자를 super()로 내려주고 있다면, 자식 자체 생성자가 존재하긴 하나 상태값 초기화는 super에게 미룬다. | protected를 통해 호출가능해진 부모가 내려주는 생성자 super()를 자식 자체 생성자 내부에서 서서 | 물려받는 생성자 vs 본인 생성자의 충돌인 상태값 초기화는 super()에 양보하고, 외부에서 재료받아 가공하는 것만 자식생성자에서 해줘서 충돌을 피한다. | . | . 암기) 추클을 받는 기존 추클도 역시, protecetd생성자 정의된 추클을 extends 한다면, 자식으로 자신 생성자 안에서 [스스로 상태값 초기화 하던 부분 this.value= value는 삭제] 하고 -&gt; 부모내려주는 super()로 상태값 초기화 해줘야하는 것은 동일하다. . protected생성자는 추클로서 자식들에게 내려보내는 중인데, 다시 자기가 extends로 추가된 중카=추클에서 protected생성자를 super()로내려받는 꼴이 되었다. . 기존에 자식 생성자들 속에서 protected로 물려주면 호출되는 super()로 상태값 초기화부분만 차지한다 . | 현재 . 그 위에 중카 추클이 또다시 protected로 생성자초기화 부분을 대신하도록 super()로 물려준다 | 추클을 받은 기존추클도 super()로 상태값 초기화해줘야한다 | . . | . | 중요) protected생성자를 내려 받는 자식으로서 super()를 호출해서 상태값 초기화로 바꿔줬다면? 부모 추클이 protected생성자만 가지고 있겠냐? 부모 추클이 상태값도 같이 가져서 자기꺼는 자기가 초기화하겠지 -&gt; 그러면 부모한테 private 상태값도 정의되어 있으며 &lt;그 상태값도 물려받으나 private으로 호출만 못할 뿐이다 -&gt; 그래서 상태값 초기화를 super()에 맡기는 것 . 기존 추클도 내려받아보자. . 스스로 상태값 초기화하는 부분 삭제 . . | protected생성자를 내려 받는 자식으로서 super()를 호출해서 상태값 초기화 . . | . | 암기) protected생성자를 물려받아, super()로 상태값 초기화를 대신한다? -&gt; 부모 추클에서 protected가 초기화해주는 상태값도 private이든 protected든 물려받는다 -&gt; 자식들이 중복코드로서 정의안한다 -&gt; super()로 넘겨서 초기화하는 상태값은 부모에게 물려받는 상태값이니 -&gt; 자식에게 선언될 필요없이 삭제한다. . protected 생성자를 물려받아, 상태값 초기화를 super()에 맡겼다면, 호출가능(protected)하든 호출안되고 숨어있든(private) 상태값도 자연스럽게 같이 내려받으니, 자식에게선 삭제해줘야한다. . . | 애초에 중복코드로서, 추클을 끼워넣어 먹어주려던 대상인 getter메서드도 구현체 중1개가 가지고 있는 중복코드로 간주하여 삭제해준다. . . public abstract class Finished extends Started { protected Finished(final Cards cards) { super(cards); } @Override public final State draw(final Card card) { throw new IllegalStateException(); } @Override public final State stay() { throw new IllegalStateException(); } } . | 50) 중카 추클을 끼워넣어서 중복코드 제거했던 [기존 추클 + 상카 구현체1(Hit) + 상카 구현체2(Stay) ] 중 구현체1,2 들의 중카 자식으로 변환처맇 해보자. . 중요) 추클 자식으로서, 자신의 생성자 내부지만 상태값 초기화를 위해 재료를 super()에 넘긴다?? 그에 해당하는 부모가 내려주는 상태값도 같이 존재하며, 보이지 않지만 그것을 그 내려주는 상태값을 초기화 -&gt; 보통 private으로 선언해서 내려주므로 호출 불가 -&gt; 상태값을 가지고 있었다면 중복코드로서 제거한다 . 기존 인터페이스의 구현체 -&gt; 그 사이에 끼워진 중간카테고리 추상클래스의 자식으로 바꿔주기 . Hit | . . | 생성자 -&gt; 상태값까지 가진 추클을 extends하면 . 자신의 생성자 내부에서 상태값 초기화를 super()에게 맡긴다 | 사실 상태값 초기화 재료가 super()넘어갔다는 말은 보이지 않지만, 상태값도 같이 내려오고 있다 상태값을 가지고 있었다면 중복코드로서 제거한다 | . | . . . | 51) 사실 protected생성자-&gt;super() + 보이지 않는 상태값 -&gt; 기존상태값 중복코드로서 삭제 가 중요한게 아니라 getter인 cards()의 중복제거가 목적이었으며, 그 목적코드를 구현하는데 있어서, 추클에도 상태값-&gt;생성자까지 정의해줘야해서, 물려줄 수 밖에 없었다. . 중복제거 목적 코드 삭제 | 기존에서는 직접 상태값을 선언해서 사용하였으나, 추클 자식으로서 물려받다보니 기존 코드에 깔려있는 호출불가한 상태값 cards는 어떻게 처리할 것인가? 부모 속 private 상태값을 protected로 호출가능하게 풀지말고 유지하되-&gt; 상태값을 응답해주는 getter or 타 메서드()를 호출해서 처리한다 | . | . 대박) 추클의 자식클래스가 물려받아 안보이는 &amp;&amp; private이라 호출불가한 상태값을 호출가능한 곳인 부모에서 상태값 응답(getter) or 변형 상태값을 응답해주는 메서드를 통해, 자식에서 상태값이 필요한 곳에 조달해준다. -&gt; 상태값과 더불어 getter도 같이 물려받아야하며, 네이밍을 상태값()로 정의해서 받으면 -&gt; 자식의 상태값 자리 -&gt;상태값()로 바꿔주면 된다. . 52) 상태값을 부모private을 물려받게 된다면, 기존 상태값을 사용하는 자식내 메서드들은 -&gt; 부모 내에서 호출해서 상태값을 응답해주는 메서 메서드 또한 물려받으면 된다. = 부모내 상태값 응답 getter메서드까지 물려받는다. . 중요) 자식이 부모에게 물려받는 priavate상태값을 자식내부에서 받는 방법은? getter까지 물려받는다 -&gt; 부모내에서, 부모가 가진 private상태값을 응답해주는 메서드를 정의하고 -&gt; 그것을 자식이 물려받아 호출하면 된다. + 상태값이 cards였으면 cards()로서 getter네이밍해서 자식의 cards -&gt; cards()로 바꿔주기 . my +중요) 어차피 상태값 + 생성자가 물려진다면 -&gt; 중복코드가 상태값 or 중복코드가 상태값이 필요한 메서드(추클에 정의해줘야함)라서 어쩔수 없이 상태값+생성자도 물려줌 —&gt; 중복코드가 상태값이 필요메서드라서, 상태값+생성자도 추클에 정의되어 물려준다면 -&gt; 상태값 이름으로 getter도 같이 정의하고 -&gt; 물려지게 해서, 기존 자식들이 쓰던 상태값들을 상태값()의 getter로 대체하게하자 . 부모에게 물려받게 되어, 기존 상태값을 삭제한 상태 . | 부모 속 private 상태값은 물려받더라도 자식내에서 호출할 수가 없다. . 부모내에서 가진 상태값을 응답해주는 메서드를 정의하고 그것을 자식이 물려받아 호출하면 된다. . | 즉, getter까지 같이 물려받는다 . 기존 상태값 호출 cards | 부모에서 물려받는 부모내 상태값 응답 매서드 cards() | . //final Cards currentCards = cards.add(card); final Cards currentCards = cards().add(card); . . | . | Ready도 똑같이 처리해준다. . . . . | 암기+중요) 자식이 주/부 생성자가 있더라도, 부생성자는 받는 재료만 다르지 내부에서는this()로 주생성자에 의존하므로 -&gt; 생성자 물려주는 추클 extends후에는 주생성자만 -&gt; super() 만 바꿔주면 된다. this()를 사용하는 부생성자는, this()에 이미 변경된 주생성자(내부에super())를 이용할 것이기 때문에 그대로 두어도 된다. . . 부생성자는 this()를 쓰고 있어도 바꿔줄 필요없다 -&gt; 그 this()가 주생성자며, super()를 통해 부모물려받는 상태값을 초기화하는 코드로 바껴있을 것이다. . . . 부생성자는 그대로 바뀐 this() 주생성자를 그대로 사용하면 된다. | . | 생성자를 super()를 사용하도록 물려받았다면 -&gt; 상태값도 중복으로 물려받은 것이니, 기존 자체 상태값 삭제 . . . | . 중요) 자식이 이미 자체 상태값을 사용하고 있는 상황이라면 -&gt; 부모야. 상태값 물려받은 후 자체 상태값 삭제할 부분을 대체할 getter 상태값()도 같이 물려줘라를 생각해야한다. . 자식의 자체 상태값을 지워서 나타나는 빨간줄은 부모야 이미 상태값 사용하던 자식들이 있다면, getter메서드도 같이 물려줘라 . . . | . 중요) getter물려주다가 private상태값+protected생성자도 물려줌 -&gt; 구현체 레벨들이 super()를 쓰도록 생성자 재정의 하다가 접근제한자가 바뀔 수도 있다 -&gt; 상태객체는 Ready(public) + 중카 추상클래스(proected)를 제외하고 default생성자를 확인해주자. . my+중요) 상속/추상화 관련 문제에서 생성자 열린상태(접근제한자) 및 재료 확인은 다이어그램으로 하자 . 생성자만 on 시킨 뒤, 추상클래스들 -&gt; 물려줄 생성자가 있다면 노란색좌물쇠의 protected가 맞는지 생성자 물려준다? -&gt; 상태값도 물려준다 -&gt; 자식들이 자기꺼 쓰고 있다면 부모에서 정의한 getter도 물려주기 | . | 중간or최종 상태객체들 -&gt; 검은색 점의 deafult가 맞는지 | 최초 상태객체(Ready) -&gt; pubic 및 상황에 따라 재료없는 생성자(부) + 이후 트리거에 의해 다음 상태갈 수 있도록 재료받는 생성자(주)2개를 가지는지 | . | 다른데서 생성되면 안되고, 상태객체 -&gt; 상태객체의 트리거에 의해서 변해야한다. . | 일단 구현체레벨의 상태객체들 생성자를 재확인해보자 . . bust는 어쩌다보니… public으로 바껴있네 -&gt; default로 생성자 접근제한자 변경 . . public final class Bust extends Finished { Bust(final Cards cards) { super(cards); } } . | Ready는 재료안받고 내부에서 빈재료로 최초 시작하는 생성자 하나만 public . | . | . 53) Stay는 재료없이, stay부터 시작하도록 테스트를 했었었네? 최종상태객체로서 다른카드에서 -&gt; 트리거 -&gt; 메서드 내부에서 재료받아 생성되야하므로 -&gt; 재료받는 것으로 테스트도 수정 . . . public final class Stay extends Finished { Stay(final Cards cards) { super(cards); } } . 중요) 각 상태가 정보를 받아 상태값으로 유지하는 이유? (1) 현재 상태객체 속에서 가진 상태값으로 if 현재상태값.is다음객체인지()를 물어보고 맞으면 new 다음상태객체( 다음상태객체를 만족하는 현재 상태값정보를 가지고 만들어줘야하기 때문에) . my+깨닮음+중요) 생성자에 재료가 없다면 항상 똑같은 new 객체()만 만들 수 있다. 하지만 ` 상태값을 (가공전이라도 괜찮으니) 생성자의 재료로 받게 되면 -&gt; new 동일Type의 새로운 객체( 를 업데이트된 상태값를 재료로` ) 만들 수 있게 되며 . . my+깨닮음+중요) 현재 상태값의 업데이트 by 메서드()에 외부 추가정보가 필요하다면, 메서드(파라미터)를 활용할 수 밖에 없다. 현재 상태값을 사용가능한, this 객체내 메서드내에서, 메서드 파라미터 == 외부 추가정보를 받는 곳을 활용해서 -&gt; 추가 정보를 활용해 상태값 업데이트를 하고 -&gt; 새 객체를 생성해서 응답해주면 된다. . . . my+깨닮음+중요) 만약, 업데이트된 상태값을 가졌어도, 동일Type의 새객체가 아닌 다른Type의 새객체를 생성할 수도 있다 -&gt; 어떤Type이든 해당 정보를 재료로 받는 생성자만 있으면, 상태값업데이트=새객체를 생성할 수 있는 능력을 가지게 된다. -&gt; 동일Type이든, 다른Type이든 해당 상태값을 재료로한 생성자를 가진 객체라면, 상태값 업데이트 로직을 가진 메서드내에서, [if 업데이트된 상태값이, 생성자는 허락된 다른 객체Type으로 갈 수있는 상태값이됬니? ]를 물어본다면, 다른Type객체로 응답되어 [업데이트 객체 생성 메서드 뿐만 아닌 객체변환의 메서드]도 될 수 있다. . draw( 추가정보 card1장)은 if문이 없으면 추가 정보로 업데이트된 new Hit객체 반환 메서드d일 뿐이다. . @Override public State draw(final Card card) { final Cards cards = cards().add(card); return new Hit(cards); } . | **하지만, 업데이트된 상태값에 [if문으로 다른객체가 될 수도 있는 상태값으로 업데이트 됬니?]물어본 뒤, [같은 상태값을 재료로 받는 생성자]를 가진 다른Type의 객체로도 변할 수 있다. ** . if 업데이트된 상태값이 -&gt; 다른객체로 변할수 있는지 물어본다. . | 아니라면, 업데이트된 상태값으로 -&gt; 같은객체의 새객체를 생성하도록 한다. . @Override public State draw(final Card card) { // 4. (+추가정보를 활용해) 업데이트된 상태값으로 -&gt; 새객체를 생성후 응답해주면, 객체 업데이트 메서드가 완성된다. final Cards cards = cards().add(card); if (cards.isBust()) { return new Bust(cards); } return new Hit(cards); } . | | my+깨닮음+중요) 다른Type객체의 new 객체( 현재객체의 상태값 재료 ) 가 보여도, 아~ 업데이트된 상태값으로 -&gt; 비슷한or같은 상태값을 공유하며 - 상태값을 재료를 받아 생성한 객체라서 그 객체로 생성가능하구나. -&gt; if로 물어봐서 다른Type객체 생성후 -&gt; 응답을 통해 외부에서 넘어갈 수 있구나 정도로 생각한다. . 중요+요약) 같은 상태값 + 상태값을 재료로 받는 생성자를 가진 다른 Type 객체는 상대방 상태값 업데이트시 언제든지 넘어갈 수 있다. ( 같은Type의 업데이트 된 새객체 생성은 당연한 것임) . Ready는 같은 상태값을 공유하는 구현체-레벨의 상호교환가능한 여러 상태객체들이 같은 재료(가공전?/직접 상태값)를 받는 생성자를 가진다 -&gt; 같은 상태값을 가지는 객체들로 해석 한 뒤 . if문으로 물어보면서, 같은 상태값 &amp;&amp; 같은 상태값을 재료로 받는 생성자를 가진 객체를 생성하여 응답해서 넘어갈 수 있다. | . . . | . 중요) 중간, 최종상태 객체는 Ready or 다른객체에서 현 객체 내부에서 상태값 업데이트후에 -&gt; if 상태값.is다른거니?() 판단후에 넘갈 수도 있므로 같은 상태값 &amp;&amp; 그 상태값을 재료로 받는 생성자를 가지고 있는 상태여야한다. . 기존 테스트 오류 1 : Cards가 아니라 개별 카드 2장을 받아? -&gt; 지금 통일된 상태값의 재료로 받고 있어! . | 기존 테스트 오류 2: 재료가 없어? 중간상태 or 최종상태객체가? -&gt; Ready빼고는 같은 재료를 생성자로 받아서 넘어갈 수 있는 상태다. . . | . 현재까지 다이어그램 -&gt; 추상화 레벨이 안맞다 . . 현재 Fininshed의 중간카테고리만 있어서 다른쪽과 추상화 레벨이 맞지 않은 상태이다 . . | .",
            "url": "blog.chojaeseong.com/java/pattern/state/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/28/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD%EA%B3%BC-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B43.html",
            "relUrl": "/java/pattern/state/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/28/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD%EA%B3%BC-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B43.html",
            "date": " • Mar 28, 2022"
        }
        
    
  
    
        ,"post21": {
            "title": "함수형인터페이스 만들어 로직넘기기",
            "content": "문제 상황 . 어떤 객체 로직이 [타 객체.행위() 성공여부]에 따라 갈린다면, 응답값을 억지로 받지말고 -&gt; [타 객체 context] 내부로 넘기자 . public final class Board { private void movePiece(final Position beforePosition, final Position afterPosition) { Piece beforePiece = this.value.get(beforePosition); beforePiece.move(beforePosition, afterPosition); // .move()의 결과에 따라 실행/안실행되는 -&gt; piece내부로 넘겨주고 싶은 Board 로직 this.value.put(afterPosition, beforePiece); this.value.put(beforePosition, new NullPiece(null)); } . Board의 this.value(map)에 pu하는 로직을 **타 객체인 beforePiece.move( , )의 성공여부에 따라 실행시키고 싶다 ** | 그러려면 beforePiece.move( , )의 성공여부를 .move()의 응답값을 받아와 if 그 결과에 따라 실행시켜야한다. | 특정 로직의 결과에 따라 움직인다면, 결과를 응답받지말고, 그 객체 text에 함형으로 넘겨주자 | . | . 예시1: thr가능성있는 타객체.메세지() 이후의 로직들을 타객체메세지보낼때 같이 보내기 . 01 넘기고 싶은 로직을 () -&gt; {}; 람다를 이용하여 함형을 만든다. . 일단 넘기고 싶은 로직을 {}아웃풋 자리에 넣고 람다식()-&gt;{};을 만든다. . () -&gt; { this.value.put(afterPosition, beforePiece); this.value.put(beforePosition, new NullPiece(null)); } . | 02 타 객체가 내부에 사용됬다면, 람다식의 (input) -&gt; {};으로 받아 -&gt; 함형.메서드( this );로 사용되도록 해야한다. . . . beforePiece.move(, )에 넘겨줄 예정이므로 piece를 함형 람다의 input으로 지정해주고, 고치자 . private void movePiece(final Position beforePosition, final Position afterPosition) { Piece beforePiece = this.value.get(beforePosition); beforePiece.move(beforePosition, afterPosition); (piece) -&gt; { this.value.put(afterPosition, piece); this.value.put(beforePosition, new NullPiece(null)); }; } . | 03 람다식의 input이 정해지면, [변수추출]로 함형종류 + inputType을 지정해준다 -&gt; 변수추출하면 메서드 추출도 응답값 지정이 잘됨. . . 함형의 inputType에는 넘겨받을 타 객체Piece로 정해줘야한다. . private void movePiece(final Position beforePosition, final Position afterPosition) { Piece beforePiece = this.value.get(beforePosition); beforePiece.move(beforePosition, afterPosition); final Consumer&lt;Piece&gt; function = (piece) -&gt; { this.value.put(afterPosition, piece); this.value.put(beforePosition, new NullPiece(null)); }; } . | 04 타 객체의 메서드(인자)로 넘겨주기 위해, 함형의 = 제외한 우항만 메서드 추출 . 추출할 메서드의 응답Type -&gt; 타객체. 메서드( 인자로 들어갈 Type )이 될 것이니 응답값이 함수형 인터페이스가 되도록 = 우항만 메서드 추출해준다. 만약, 변수추출 안했다면 추론이 안되서 함형을 응답값으로 못빼주더라 | =를 포함시켜서 추출하면 추출안됨. | =제외시키고 함형 메서드추출하면 잘된다. | . | . =을 제외하고 우항만 메서드 추출해서, 응답값이 함수형 인터페이스로 잘 뽑히는지 확인한다. . private void movePiece(final Position beforePosition, final Position afterPosition) { Piece beforePiece = this.value.get(beforePosition); beforePiece.move(beforePosition, afterPosition); final Consumer&lt;Piece&gt; function = getMoveConsumer(beforePosition, afterPosition); } private Consumer&lt;Piece&gt; getMoveConsumer(final Position beforePosition, final Position afterPosition) { return (piece) -&gt; { this.value.put(afterPosition, piece); this.value.put(beforePosition, new NullPiece(null)); }; } . | 05 추출한 로직의 함형을, 타객체 메서드에 건네줘서 -&gt; 내부에서 this를 사용해 실행되도록 옮긴다. . . . private void movePiece(final Position beforePosition, final Position afterPosition) { Piece beforePiece = this.value.get(beforePosition); beforePiece.move(beforePosition, afterPosition, getMoveConsumer(beforePosition, afterPosition)); } . 06 함형으로 로직을 넘겨받은 타 객체는 내부에서 (this)를 인자로 주고 호출한다 . . @Override public void move(Position beforePosition, Position afterPosition, Consumer&lt;Piece&gt; moveFunction) { if (!canMove(beforePosition, afterPosition)) { throw new IllegalArgumentException(NOT_MOVABLE_POSITION); } moveFunction.accept(this); } . 예시2: 아래쪽 분기별 OutputView 로직이 도메인 샌드위치 사이에 위치한 경우 -&gt; Runnable?객체면 Consumer?로 위쪽 도메인 메서드 인자에 함형메서드로 쏴서 넘겨주기 . 문제상황 . public void run() { OutputView.printStartMessage(); while (gameSwitch.isOn()) { //도메인로직 final String command = InputView.inputCommand(); final GameCommand gameCommand = GameCommand.from(command); gameCommand.execute(command, this); //view로직 ( State에 따라서 출력 ) printBoardInfo(); //도메인로직2 (샌드위치유발) -&gt; 특정상태인 경우, 다시 돌려주는 로직 if (state.isStatus()) { state = state.toRunningState(); } } } private void printBoardAndBeRunningIfStatus() { if (isReadyOrRunning()) { OutputView.printBoard(getBoard()); } if (isStatusInRunning()) { OutputView.printStatus(calculateStatus()); } if (isFinishedAndGameEnd()) { OutputView.printFinalStatus(calculateStatus()); } } . 01 view로직을 도메인 메서드 안에서 출력시키고 싶은데, view 사용 == view를 알면 안된다. -&gt; view는 알면 안되지만, 함수형 인터페이스는 알아도 된다 -&gt; view로직 전체 -&gt; 람다를 통한 함형 -&gt; 메서드추출후 응답에 함형 . private Runnable printBoardInfo() { return () -&gt; { if (isReadyOrRunning()) { OutputView.printBoard(getBoard()); } if (isStatusInRunning()) { OutputView.printStatus(calculateStatus()); } if (isFinishedAndGameEnd()) { OutputView.printFinalStatus(calculateStatus()); } }; } . 02 도메인메서드의 인자에 함형 응답 메서드호출로 인한 함형인자를 추가하기 . public void run() { OutputView.printStartMessage(); while (gameSwitch.isOn()) { final String command = InputView.inputCommand(); final GameCommand gameCommand = GameCommand.from(command); gameCommand.execute(command, this, printBoardInfo()); //도메인로직2 (샌드위치유발) -&gt; 특정상태인 경우, 다시 돌려주는 로직 if (state.isStatus()) { state = state.toRunningState(); } } } . 03 view로직을 함형으로 넘겨받은 도메인 메서드에서는 함형.메서드()로 가동시키기 . 함형으로 넘겨서 실행만 시키면 도메인은 view를 모르고 view로직이 담겨 실행직전인 함수형인터페이스만 알아도 된다. | . . public final class Status implements CommandStrategy { @Override public void execute(final String command, final ChessGame chessGame, final Runnable runnable) { chessGame.status(); runnable.run(); } } . 04 샌드위치를 만들던 도메인로직2도 해당분기에 맞게 도메인 내부로 옮겨준다. . . public final class Status implements CommandStrategy { @Override public void execute(final String command, final ChessGame chessGame, final Runnable runnable) { chessGame.status(); runnable.run(); // if (state.isStatus()) { // state = state.toRunningState(); // } chessGame.start(); } } . [람다식을 통한 함형]이 유용할 경우 3가지 . list.sort( ) 속 [Comparator]의 역정렬 + thenComparing 2개이상 정렬 . // 1 inventory.sort(Comparator.comparing(Apple::getWeight) .reversed()); // 역으로 정렬 // 2 inventory.sort(Comparator.comparing(Apple::getWeight) .reversed() // 역으로 정렬 .thenComparing(Apple::getCountry)); // 두 사과의 무게가 같으면 국가별로 정렬 . 참고) 그냥 Comparable안에서 2개 정렬 . @Override public int compareTo(Position o) { return Comparator.comparing(Position::getRow, Comparator.reverseOrder()) .thenComparing(Position::getColumn) .compare(this, o); } . Predicate 1개에 .negate() 반전 이외에 .and( 람다 ) .or( 람다 )로 연쇄할 경우 . Predicate&lt;Apple&gt; notRedApple = redApple.negate(); // 결과를 반전 Predicate&lt;Apple&gt; redAndHeavyApple = redApple .and(apple -&gt; apple.getWeight() &gt; 150); Predicate&lt;Apple&gt; redAndHeavyApple = redApple .or(apple -&gt; apple.getWeight() &gt; 150); Predicate&lt;Apple&gt; redAndHeavyAndGreenApple = redApple .and(apple -&gt; apple.getWeight() &gt; 150) .or(apple -&gt; GREEN.equals(apple.getColor())); // 빨간 사과 중 무게가 150 넘는 사과 혹은 초록 사과 (오른쪽 연결) . 수식용 Function 들을 여러개 만들어놓고 .andThen( ) or .compose( )로 조합 . compose( )는 뒤에 람다부터 계산 | . Function&lt;Integer, Integer&gt; plus10 = (number) -&gt; number + 10; Function&lt;Integer, Integer&gt; multiply3 = (number) -&gt; number * 3; Function&lt;Integer, Integer&gt; multiply3AndPlus10 = plus10.compose(multiply3); System.out.println(multiply3AndPlus10.apply(4)); // 결과 22 Function&lt;Integer, Integer&gt; plus10AndMultiply3 = plus10.andThen(multiply3); System.out.println(plus10AndMultiply3.apply(4); // 결과 42 .",
            "url": "blog.chojaeseong.com/java/lambda/%ED%95%A8%EC%88%98%ED%98%95%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/comparator/predicate/consumer/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/27/%EB%9E%8C%EB%8B%A4%EB%A1%9C-%EB%A7%8C%EB%93%A0-%ED%95%A8%ED%98%95(%EB%A1%9C%EC%A7%81-%EB%84%98%EA%B8%B0%EA%B8%B0,-%EC%9C%A0%EC%9A%A9%ED%8C%A8%ED%84%B4).html",
            "relUrl": "/java/lambda/%ED%95%A8%EC%88%98%ED%98%95%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/comparator/predicate/consumer/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/27/%EB%9E%8C%EB%8B%A4%EB%A1%9C-%EB%A7%8C%EB%93%A0-%ED%95%A8%ED%98%95(%EB%A1%9C%EC%A7%81-%EB%84%98%EA%B8%B0%EA%B8%B0,-%EC%9C%A0%EC%9A%A9%ED%8C%A8%ED%84%B4).html",
            "date": " • Mar 27, 2022"
        }
        
    
  
    
        ,"post22": {
            "title": "강의) 네오 3단계 블랙잭 피드백(2/4)",
            "content": "도메인이 쌓이고 난 후 이름 리팩토링 . Game(서비스같은)Test로 Game.메서드들 테스트 -&gt; 구체적으로 클래스명 정하기 . 현재 Game.start() 이후 응답되는 상태 객체 state의 .draw()들만 테스트하고 있다. Game에서 카드 2장받아 start를 하면 -&gt; state를 반환한다? | . | Game대신… 상태패턴의 state가 시작되기 전을 의미하는 Ready의 준비를 .start( 카드1,카드2)받는 식은 어떨까? Ready가 start하면 state를 응답해준다? | . | . 26) Game.start() -&gt; Ready.start()로 이름 리팩토링 . 이름 리팩토링은 해당 파일로 가서 class명을 붙잡고 F2 -&gt; RenameTest도 같이 바꾸도록 select All선택 후 Okay해줘야 바뀐다. 클래스명 클릭 -&gt; F2 -&gt; RenameTest 에서 alt +a후 tab 2번 한 뒤 okay enter | . | . . 중요) 상태변화패턴이 시작되는 [최초 state가 나오기 전 상태]로서 Ready라는 이름으로 시작 -&gt; 이것 역시 State의 카테고리인 상태객체로 바꿔보기 . 27) Ready도 스태틱 로직메서드를 위한 class가 아니라 State로 만들어보자 . 상카(추상체) 구현을 시작으로 카테고라이징 된다. . 현 class상태에서 State를 구현하여 카테고라이징 . . impl해야하는 메소드를 가장 위로 올려, State임을 나타내주자 | . | [잘못설계] Ready 상태는 start(card1, card2)를 활용하여 Hit or Black상태임을 상태값으로 가지고 있다? . Hit, bust 등 처럼, 이전 정보cards + 추가정보card로 정보 업데이트후 -&gt; 업데이트된 정보로 객체 생성을 위해 상태값형태로 cards를 가지고 있었다. | Ready의 경우, 재료인 card1, card2가 들어와서처음 초기화되어 시작되며, cards정보를 통한 업데이트된 Ready를 만들 일 없이 한번 만들어지고 끝이다? 다른 State처럼 cards를 받는게 아니다? | 그러면 State와 동일한 상태객체일까? 고민이 된다. | . | . Ready는 어떻게 되었든 card1, card2를 재료로 받아 가공되어 내부에 가지는 상태값을 가지게 될 것이다. . . | 기존 메서드를 보니 재료를 받았지만, 가공은 State로 될 가능성이 높다. . 재료 가공을 State로 해서 상태값으로 가지고 있자 . | 복사해놓고 활용하면 더 쉬울 듯 . 생성자는 재료를 받아서 this.상태값=을 초기화해줘야하는 의무를 가진다. 그 상태값은 메서드로 치면 State들이다. . . . | . | . | 문제점: 아직 state로 가기전의 상태인데, 초기화로 Hit 나 Blackjack상태를 가지게 된다. -&gt; 메소드의 역할만 하고 있고 상태객체가 아니게 된다. . 중요) Ready라는 시작 상태는 고유하며, 생성시 아무재료(정보)도 없이 시작되며 -&gt; draw트리거메서드에 의해 바뀔 수 있다. . Ready는 생성시 Card1, card1를 받는게 아니라 재료가 없는 빈 생성자로 시작해야한다. 1장 씩 draw하면서 아직 ready인지 물어보고 | 2장을 draw했을 때, hit or blackjack 상태로 바껴야한다. by draw메서드에 의해 | . | . my) 인페를 상카로 뽑아 카테고라이징 했다면, 구현체의 단독 상태, 메서드 개발은 자유롭다 -&gt; 규칙에 맞는 메서드만 오버라이딩해서 개별구현하면 된다. . 중요) 시작 State도 마찬가지로 다른 구현체(상태)로 넘어갈지 판단에 필요한 정보 cards를 상태값으로 가진다 -&gt; 재료로 받진 않지만, 추가정보를 받아서 채우면서 판단 -&gt; 상태값인 cards의 갯수에 따라 현재상태인지 -&gt; 다른 상태로 넘어가야할지 판단할 수 있다. . 28) 재료없이 생성되는 객체라도 -&gt; 내부에서 빈 재료로 초기화하는 상태값을 가질 수 있다. . 참고) 일급을 빈재료로 넣어야할 때 -&gt; this.value = new 일급();으로 일급생성자에 재료를 빼고 넣어주고 -&gt; 일급으로 가서 [재료받는 것을 주생성자this]로 하여 -&gt; 재료없이 내부 빈재료로 초기화하는 부생성자를 추가 생성해줘야한다. . Ready의 재료없이 내부 빈재료로로 상태값을 만드는 생성자를 먼저 선언하고 -&gt; 상태값도 만들어주자. . | 이 때, 필요한 재료는 안받아오지만, 필요한 내부 빈 재료가 빈 일급컬렉션이다… . . . | 일급컬렉션에 재료받아 생성되는 주생성자를 this로 활용하여 그 위에 재료없는 부생성자를 추가로 만들어주자. . 상태값 및 재료가 원래 있던 놈들인데 없는 부생성자 만들시 -&gt; Select None으로 생성하면 된다. . | new ArraysList&lt;&gt;()로 빈 재료를 넣어주면 된다. . public final class Cards { private final List&lt;Card&gt; value; public Cards() { this(new ArrayList&lt;&gt;()); } . | . | draw는 아직 처리안되어있으니 return null로 State를 응답해주자. . | 29) Ready도 draw(card)를 한다. . 내부 일급상태값.add()는 보이기에만 add시 기존 상태값+업데이트정보로 -&gt; 업데이트 상태값으로 새 일급을 반환해주는 업데이트 일급 응답함수다. 이 업데이트된 일급으로 다음 상태를 판단한다. . 업데이트된 상태값으로 새 일급 반환받기 . @Override public State draw(final Card card) { //1. 다른 상태에서의 draw처럼 (1) 현재 정보들 + (2) 추가 정보를 가지고 내부업데이트해서 불변 새일급을 반환받는다. final Cards currentCards = this.cards.add(card); return null; } . | 업데이트된 상태값으로 -&gt; 일급이니 메세지를 보내서 다음 객체를 판단한다 . | 30) Ready가 가능한 상태를 생각해본다 -&gt; 1장씩 받으니 Ready 그대로 or 2장 다받으면 Hit or Blackjack -&gt; 업데이트된 상태값으로 isReady()로 물어봐야한다. . . . . 아직 카드갯수가 2보다 작은 1개 상태의 ready상태라면, 업데이트 된 상태값으로 -&gt; new 상태객체(상태값)를 만들어 응답해주자. . . | 참고) 늦게 생성됬어도 재료받는 생성자가 주생성자라는 개념을 가지고 가자 -&gt; 기존의 재료없는 생성자는 this를 활용해서 부생성자로서 재정의 해줘야한다. . 아직 재료없이 생성되는 Ready 생성자만 정의된 상태이니 생성자도 만들어줘야한다. . **재료를 받게 되는 순간부터 늦게 생성됬어도 재료받는 생성자가 주생성자라는 개념을 가지고 가자 ** | . . | 참고) 부생성자에서 주생성자 활용하여 정의: 기존 = 우항; 코드들을 복사하고 this()내부로 복붙한 다음, 가공해서 주생성자의 파라미터에 맞춰주면 된다. . 재료받은 주생성자가 생겼지만, 이놈은 외부에서는 호출안될 것 같으니 private으로 처리해주고 부생성자를 this로 다시 정의해주자 . . . . | . 리팩토링과 함께 . 상태로서의 Ready를 Test하기 . 기존 테스트들이 Ready.start( card1, card2)로 많이 만들어졌기 때문에 일단은 살려둔 상태다. . . 31) 상태로서의 Ready 테스트하기 . 기존에 카드 2장을 받아서, 상태를 만들어주는 정적메서드의 주체자 Ready였다. . public class ReadyTest { @Test void hit() { // given &amp; when : hit final State state = Ready.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK)); // then assertThat(state).isInstanceOf(Hit.class); } . | 참고) 코드 수정이나 개발은 기존 코드보다 위에, 기존코드를 복붙해놓고 새 기준 코드를 작성한다 . 2장 받아 상태반환 메서드 -&gt; 재료없이 최초 상태로서 출발하는 상태객체의 코드로 변경하려면 기존코드를 남겨두고, 위쪽에 복붙해서 수정한다. . . | 중요) 최초 시작상태 객체는 재료를 안받고 생성되며, 상태 변환 트리거 메서드를 호출하면서 다른 구현체 상태객체가 되는 조건까지 재료없이 내부 빈 재료로 초기화시켜 만든 상태값을 통해 확인하면서 진행하면 된다. . Ready(Class)로 시작하는 .start() 메서드호출 대신 직접 재료 없이 생성하여 최초 상태가 시작된다. . 과정 . . | . | 중요) 상태객체.트리거메서드()는 경우의 수 구현체를 다 받을 수 있는 추상체를 응답하므로 -&gt; 계속 체이닝으로 해서 호출이 가능하다. . 상태변화 트리거인 draw()를 호출하면서 내부에서 확인하면서 다른 상태로 간다. . 2번 draw()가 될때까지 내부에서 확인한다 | 상태변화 트리거 메서드는 추상체로 응답을 하는 덕분에, 체이닝으로 여러번 호출이 가능하다. | . @Test void readyHit() { // given &amp; when : ready -&gt; 2 -&gt; ready -&gt; 10 -&gt; 2장뽑는 순간 Hit상태(or Blackjack)로 최초 Ready객체 탈출된다. final State state = new Ready().draw(Card.of(Suit.SPADES, Denomination.TWO)) .draw(Card.of(Suit.SPADES, Denomination.JACK)); // then assertThat(state).isInstanceOf(Hit.class); } . | 중요) 최초Ready상태객체 + 트리거 했는데도 아직 Ready상태인 것도 테스트 . . @Test void ready() { // given &amp; when : ready -&gt; 2 -&gt; ready final State state = new Ready().draw(Card.of(Suit.SPADES, Denomination.TWO)); // then assertThat(state).isInstanceOf(Ready.class); } . 32) 기존 테스트코드를 전체 리팩토링 ( Ready.start -&gt; new Ready.draw().draw()로) . 일단 메서드의 통합테스트에서 -&gt; 특정 객체 테스트로 좁혀들어갔으니 -&gt; 개별 상태 객체들도 자기테스트로 테스트를 옮겨가도 된다. . . 테스트 가져가기 (ReadyTest -&gt; HitTest) . . | . 다시 Ready.start( 재료1, 재료2) -&gt; new Ready() 재료없는 최초 상태객체로 시작하도록 리팩토링 . 기존 돌아가는 코드의 위에 복붙 후 수정 | . @Test void hitHit() { // given &amp; when : ready -&gt; draw 2,10 -&gt; hit -&gt; draw 1 -&gt; hit State state = new Ready().draw(Card.of(Suit.SPADES, Denomination.TWO)) .draw(Card.of(Suit.SPADES, Denomination.JACK)) .draw(Card.of(Suit.SPADES, Denomination.ACE)); //State state = Ready.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK)); //state = state.draw(Card.of(Suit.SPADES, Denomination.ACE)); // draw호출이 가능해서 assertThat(state).isInstanceOf(Hit.class); } . | 33) 개별 상태객체부터 시작하는 Test로 고치기(Ready시작 안해도 됨) . 중요) 상태값을 가지는 객체라면, 그 상태값을 만드는 재료만 넣어주면, 그 정보를 가공하여 반영된 객체를 생성할 수 있다. . 사실 특정객체Test는 Ready최초시작객체부터 시작할 필요가 없다. . **객체 = 최초시작객체가 아니라면, 대부분 재료를 받아 -&gt; 가공 -&gt; 상태값으로 가지는 로직을 가지므로 Hit객체부터 재료를 줘서 만들어서 테스트하면된다. ** . | hit 만드는 테스트부터 만들자. . | . . . . | 참고) 객체 생성시, 재료를 넘겨줄 때, 사용성을 고려하여 생성자 추가는 해도 괜찮다. -&gt; new단일객체()도 귀찮은데 2개이상 생성하면서 List.of()로 묶어줘야한다? -&gt; 클라이언트 배려한 가변인자 파라미터 빨간줄 생성 . 리팩1) 외부에서 인자전달시 List.of()로 묶어서 전달한다? -&gt; 인자는 콤마로 + 파라미터는 가변으로 수정 by Ctrl+F6(change signature) . . 인자에 new 생성자(List.of(객체1, 객체2)) 형태라면 . new 생성자( ` 객체1, 객체2 ) **로 **List.of()의 묶어주는 과정을 제외하여 빨간줄 생성`한 뒤, 생성자를 추가해주자. . | 카드 2개로 인식하지만, 우아한 파라미터 개선의 change signature ctrl+F6으로 가변인자 파라미터로 바꿔주자 . . | 부생성자일 것이니 위치를 위로 옮겨가서 this()를 활용한다. . . | 배열 -&gt; List로 바꿔줄려고 배열.stream을 썼으나… . . | . | 참고) 가변인자는 밖에서 없애줬떤 List.of를 그대로 쓰면 된다. stream대신 -&gt; 내부 List.of()로 처리 . . public Cards(final Card... cards) { this(List.of(cards)); } . @Test void hit() { final State state = new Hit(new Cards(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK))); assertThat(state).isInstanceOf(Hit.class); } . 34) 카드 2장으로 new Hit() 시작하여 hit -&gt; hit 테스트 . . 2장으로 Hit를 만들고 체이닝으로 트리거메서드를 호출해했지만 가독성이 엉망이다. | . | . | . 리팩3) 가독성을 위한 긴 파라미터부분을 -&gt; 위에 변수로 추출 . . 선택된 부분이 윗줄에 변수로 추출되어야한다. . 파라미터 추출은 메서드의 파라미터로 이동된다. 조심 | . . @Test void hitHit() { // 2,10 으로 hit -&gt; draw 1 -&gt; hit final Cards cards = new Cards(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK)); State state = new Hit(cards); //when state = state.draw(Card.of(Suit.SPADES, Denomination.ACE)); //then assertThat(state).isInstanceOf(Hit.class); } . | . 리팩4 &amp; 중요) 많이 쓰이는 Test속 일급재료인 상수기반 단일객체는 Fixtures클래스에 모아두고 static import해서 단일객체가 객체지만, 상수처럼 갖다쓰자. . 중요) Test에서 자주쓰는 단일객체(일급의 재료)를 Fixures클래스에서 상수로 선언하여 모아두자.-&gt; new 단일() or 단일.of() / 단일.from() 등 인자에서 호출되는 단일객체 생성자(정펙매) 호출부분을 ctrl+alt+C로 객체를 상수추출한 뒤, F6 -&gt; public(psf)으로 Fixtures 클래스로 옮겨주자. . cf) psf = public static final -&gt; 다른데서 갖다쓰는 상수 -&gt; Test Fixture아니면 쓸일 없을 듯 -&gt; 상수라도 각 도메인내부에서 쓰기! | cf) pr sf = pr ivate static final -&gt; 일반 클래스내 상수 | . Fixtures클래스를 만든다. . breadcrums(c+a+;)를 이용해서 같은 테스트내에서 편하게 만들 수 있다. | . . | 상수가 아니라 new 단일() or 단일.of() / 단일.from() 등 인자에서 호출되는 단일객체생성자를 추출해와야한다. . 오른쪽에 복제가 아닌 1개 창으로 띄우기 ctrl + (복제) -&gt; 왼쪽으로 넘어오기(tabmover의 c+a+s+[) -&gt; 왼쪽 창끄거나 다른창으로넘어가기 | . . | 직접 Fixutre에서 상수로 선언하지말고 상수로 추출 -&gt; F6으로 상수옮겨가기를 해보자. . . ctrl+alt+ C의 상수추출 | . . 상수 부분을 클릭후 F6으로 이동 실수로 Card 등의 Class부분을 잡고 F6을 하면, class이동이 되어버리니 조심 | . | . . . 갖다 쓸 상수(public sf)로 가는 것이기 때문에 Public도 지정해준다. 안해주면 default생성자가 되어버린다. | . | . . Fixtures클래스로 public으로 옮겨갔으며 + 기존 있던 Test에서는 Fixtures.상수로 사용되어진다. | . | 참고) 테스트용 갖다쓰는 객체상수 클래스 Fixtures는 Add on-demand static import를 통해 편하게 현재클래스내 상수처럼 쓸 수 있게 한다. . 상수전용 클래스 Fixture를 static import로 생략하고 상수(SPADE_TWO)만 사용할 수도 있다. . . . | 상수객체가 정상 단일객체럼 행동하는지 해당 객체 테스트에서 객체상수 isSamaAs 생성한 객체 테스트를 해보자 . 기존 테스트 . @Test void of() { final Card card = Card.of(Suit.HEARTS, Denomination.ACE); assertThat(card).isSameAs(Card.of(Suit.HEARTS, Denomination.ACE)); } . | 사용되는 단일객체를 -&gt; 상수객체로 뽑아서 옮겨놓고 상수로 가져오자. . | | . . . . . | . | 나머지 사용되는 단일객체들도 다 상수화 -&gt; Fixutre에 public 상수로 옮기기 해주자 . public class Fixtures { public static final Card SPADE_TWO = Card.of(Suit.SPADES, Denomination.TWO); public static final Card HEART_ACE = Card.of(Suit.HEARTS, Denomination.ACE); public static final Card SPADE_JACK = Card.of(Suit.SPADES, Denomination.JACK); //... } . | 참고) 객체 -&gt; 상수 만들다가 기존 Fixtures에 뽑아 놓은 객체상수 발견시 -&gt; ctrl+H로 일괄변경해주기. -&gt; 의심되는 객체는 ctrl+shit+F로 Fixtures에 만들어놓은게 없나 살펴보기 . 상수 만들었다, 이미 만들었떤 것이 나온다? -&gt; 찾아바꾸기로 한번에 다 바꿔주자. . . . . . | Fixture 목록에 없는 것들이 나타나면, 또 뽑아서 바꿔준다. . | 이미 만들어놓은 것 같은데 확인하고 싶다면, -&gt; 블럭 + ctrl+shift+F에서 Fixtures에 걸리는게 있나 훔쳐보기 . 있다면 windows에서 클릭해서 해당 Fixture상수 복사해와서 -&gt; ctrl+H에 복붙여넣고 찾아바꾸기 . . | . |",
            "url": "blog.chojaeseong.com/java/pattern/state/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/27/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD%EA%B3%BC-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B42.html",
            "relUrl": "/java/pattern/state/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/27/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD%EA%B3%BC-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B42.html",
            "date": " • Mar 27, 2022"
        }
        
    
  
    
        ,"post23": {
            "title": "강의) 네오 3단계 블랙잭 피드백(1/4)",
            "content": "블랙잭 . 도메인 공부후 시작점 찾기 . 정제된 rawInput이 들어온다고 가정하고 했었다. 자동차 경주: new Car(&quot;이름&quot;)의 string 생성부터 -&gt; 응답하는 메서드 테스트 | 로또: rawInput으로 1,2,3,4,5,6의 list | | 블랙잭 로직을 시작하려면 재료 시작전 포장된 카드 -&gt; 카드덱이 먼저 필요하다 카드덱이 카드를 2장씩 제공해야하는데, 포장된 카드만 있으면 카드덱에서 뽑아서 줬다고 가정하고 메인로직 시작하면 된다. | . | 카드를 &quot;문자열&quot;, 숫자의 정제된 rawInput으로 가정해도 되지만, 이것은 input으로 들어오는게 아니라 원래 생성되어 있어야하는 것이므로 가정하고 -&gt; 나중에 포장하는게 아니라 미리 만들고 시작한다 게다가 2개는 같이 붙어서 움직이는 것이므로 -&gt; 미리 클래스로 포장한다 로또당첨번호 lotto + bonusNumber | Player가 가지는 name + cards | . | . | 캐싱 . 재료인 Card먼저 만들기 . 01 Card에는 2가지정보가 붙어서 움직인다. . . test를 파서 필요한, 붙어다니는 2개의 정보로 new Card( , ) 생성부터 해본다. . . | 2가지 정보는 제한된 상수이므로 Enum으로 생성하고 1가지 예시 enum객체를 활용해서 생성한다. . enum의 예시 -&gt; enum클래스.대문자_상수로 사용 | . . @Test void create() { //new Card(new Suit(), new Denomination()); //1. 2가지 정보는 제한된 수의 상수 -&gt; enum으로 받는다고 가정 -&gt; 예시로 생성한다. new Card(Suit.HEART, Denomination.ACE); } . . | enum 정보를 복사해오는데, 필드값이 지금 당장 필요하지 않으면 삭제하자. . public enum Denomination { ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING, ; } . package blackjack; public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES } . . | 2가지 정보로 new 객체생성 템플릿 주생성자를 일단 생성해줘야한다. . 캐싱을 하더라도 먼저 기본생성자부터 생성해주자. | . . . public class Card { private final Suit suit; private final Denomination denomination; public Card(final Suit suit, final Denomination denomination) { this.suit = suit; this.denomination = denomination; } } . 파라미터는 좀 길다면 보기 좋게 2번재 줄로 이동시켜도 된다. | . | 02 class는 객체 100% 새로 생성 new 단순템플릿이 아니라 캐싱등의 능동적 객체 생성 관리자역할을 by 로직을 포함한 생성자 정펙매로 할 수 있다. . 캐싱은 생성에 관한 것이며, 정적팩토리메서드를 통해 능동적으로 로직을 포함한 생성으로 객체생성을 관리할 수 있다. . . @Test void create() { final Card card = new Card(Suit.HEARTS, Denomination.ACE); //2. [new + 재료]가 아니라, of/from등의 [정펙매 + 재료]로 생성해야 로직을 포함한 생성이 가능하다. Card.of(Suit.HEARTS, Denomination.ACE); } . . 메서드 생성후 파라미터 라인 + 명칭 수정해주고 나중가면 final도 달아준다? | . . | 캐싱을 하기 위해서는 2가지만 해주면 된다. 미리 pr sf 로 클래스 변수 = 상수로서 cache map만들어주기 psf는 public sf/ prsf은 private이다. | . | 정펙매에서 생성된 CACHE_MAP + .computeIfAbsent(, )로 없을 때만 new 100%생성 기본생성자로 생성 후 반환 | 캐싱될 객체는 VO로서 값 같으면 같은객체 취급해주기 위해 eq/hC 오버라이딩 | | 클래스 변수(상수)로 cache를 선언할 것이므로 -&gt; 메소드 내에서 변수 추출로 형완성을 해가자 . ctrl+alt+F로 메서드내부에서 바로 필드(인변/클변으로 뽑을 수 있다) | . | 2개의 변수를 동시에 가지고 다니는 inner class를 선언한 뒤, 그 class의객체를 Key로 가지고 가도 된다.(사용한할 것임. 참고만) . private static class Key { private final Suit suit; private final Denomination denomination; private Key(final Suit suit, final Denomination denomination) { this.suit = suit; this.denomination = denomination; } } . 변수 추출시 다형성도 항상 확인하자 | . | 2개의 변수를 들고다니는 클래스Key를 만들어줘도, Card와 동일한 상태다(2개를 인변으로). 그냥 .name()을 활용한 string+string의 &lt;String, 으로 unique한 1개의 key로 만들어준다. 캐싱의 valueType은 해당 객체로 준다. . . | enum은 enum객체 변수명을 그대로 출력해주는 .name()메서드를 제공해준다. . . System.out.println(Suit.HEARTS.name() + Denomination.ACE.name()); . . | 메소드내부에서 변수추출했지만, scope이동할 땐, pr를 포함한 sf로 변경하여 접근제한자를 수정해주자.. . 메서드내부에서는 pr이 안먹는다. public메서드라면.. | . . 갯수를 미리 알고 있으면 map의 () 생성자에 넣어준다. | . public class Card { private static final Map&lt;String, Card&gt; CACHE = new HashMap&lt;&gt;(52); . | 캐쉬에 들어갈 key를 1.name() + 2.name()의 스트링으로 작성해줬다. 만약, 그 key가 없을 경우, 해당 key값으로 자동으로 넣어줄 value를 지정해줘야한다. . 이 때, key값은 활용을 안하므로 value값을 만들어줄 Function 함수의 람다 시작인자로서 자리에 앞선 인자 key를 활용 안하므로 ignored로 명명해서 작성해주자. | . . public static Card of(final Suit suit, final Denomination denomination) { return CACHE.computeIfAbsent(suit.name() + denomination.name(), ignored -&gt; new Card(suit, denomination)); } . | 03 캐싱되는 객체는 VO처럼 eq/hC 오버라이딩 해줘야한다. + 정펙매 사용하면 기본생성자는 private로 바꿔서 잠궈줘야한다. . 같은 값(2개 정보)를 가지면 -&gt; 같은 객체로 판단되어야 재사용시 같은 것으로 확인이 된다. . generate 띄운 후 eq로 빠르게 검색해서 사용하기 | . . | 리팩토리으로서 메서드 인자에, 메소드 연산을 하고 있다. -&gt; 메서드추출 . // return CACHE.computeIfAbsent(suit.name() + denomination.name(), // return CACHE.computeIfAbsent(toKey(suit, denomination), . . | 정펙메 사용순간부터 기본 생성자는 private으로 변경 . . 테스트 코드에 사용했던 new 기본생성자를 .of로 변경 | . . 테스트 메서드명도 변경 create -&gt; of | . | . . | . 만든 카드 캐싱 테스트 . 참고) assertThat()의 import는 qualify static call.. 이후 add static import로 ?? . . . . . . 캐싱 테스트: 만든것 .isSameAs( 방금 만든 것 )같은지 . class CardTest { @Test void of() { final Card card = Card.of(Suit.HEARTS, Denomination.ACE); assertThat(card).isSameAs(Card.of(Suit.HEARTS, Denomination.ACE)); } } . TDD 시작점 어디서부터 . 핵심 로직은? . 카드 2장을 받는 것? | 2장 받은 상태에서 판단을 한다. 21이면 블랙잭 if문이 등장했다. -&gt; 다형성/enum 등… | . | 21보다 낮으면(21 아니면) sit 그만 할 수 있다. stay 추가적으로 받을 수 없다. | . | hit시, 21보다 아래면 sit상태로 계속 받을 수 있다. | . | . | . | 행위는 사용자input에 의해 진행되지만, 특정 메서드(카드받기)에 의해 서로 바뀌는 &lt;상호 연결된 상태값&gt;이라는 밀접한 관계를 가지고 있다. 응답값이 상태이며, | (동일)메서드에 의해 실시간으로 바뀌는 상태다.. | if문이 엄청 나올 것이다 -&gt; 추상화로 if문을 제거한다 객체생활 체조원칙 -&gt; 체조는 어디에 좋은지 모르는데, 하다보면 좋아진다. | . | . | 시작점은 어디서? . 재료인 카드 2장을 뽑은 상태에서부터 시작하여 상호 연결된 다른 상태로 바뀌는 메서드를 호출하면서 시작한다. | . 01 핵심로직(like Service)의 클래스이름이 안정해졌으면 GameTest클래스 -&gt; Game.start(재료)메서드로 시작 . . . . 02 재료를 넣고 -&gt; 예상 응답값으로 뭐가 나올지 먼저 고민한 뒤 여러개면 만만한 1 case 선택 -&gt; 재료:예상 인자값도 맞춰서 정해준다. . 테메당 1case이므로 여러 응답(상태)이 나온다고 예상되면 -&gt; 그 중 1개를 예상응답값으로 선택하고 -&gt; 예상응답값에 맞는 재료를 넣어줘야한다. . 메인로직 클래스(game)의 static메서드()에 정제된 rawInput(재료)으로서 포장 카드 2장을 넣어야한다. . | 메서드를 짜기 전, 예상 응답을 먼저 생각해보고 여러 응답값이 나올 수 있다면, 만만한 응답값부터 예상값으로 정해놓고 1 case testmethod를 작성하자. . blackjack은 ace처리도 해줘야하기 때문에 만만하지 않다. | case가 정해지면 그에 따라 테스트 메서드 이름도 바꿔준다. (start-&gt; hit) | . @Test void hit() { //1. 재료: 카드 2장을 넣을 때 -&gt; 응답: if max21 Blackjack or if Hit(orStay)가 나올 수 있다. // -&gt; 먼저 만만한 것을 고른다. // -&gt; 21 아래 값인 hit를 먼저 예상응답으로 정한다. Game.start(); } . | 예상응답값에 대한 예상인자를 맞춰서 작성해줘야한다. . hit를 먼저 예상응답값으로 정했다면 | hit를 만드는 재료 카드 2장도 예상인자값으로 맞춰서 넣어줘야한다. | . . @Test void hit() { //1. 재료: 카드 2장을 넣을 때 -&gt; 응답: if max21 Blackjack or if Hit(orStay)가 나올 수 있다. // -&gt; 먼저 만만한 것을 고른다. // -&gt; 21 아래 값인 hit를 먼저 예상응답으로 정한다. //2. 카드2 -&gt; hit (예상응답값) -&gt; 거기에 맞는 재료 넣어주기 Game.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.FIVE)); } . . | 응답값이 상수/enum이 행위에 의해 다른 것으로 바뀔 수 있는 상태라면 -&gt; class의 객체로 미리 작성한다. . 03 테스트는 내부로직 완성전에 응답값 -&gt; then assert문을 미리 작성 -&gt; 클래스와 메서드는 껍데기만 일단 작성해놓기 . 참고) 앞으로 클래스가 상속예정없으면 다 final로 선언하는 버릇 들이기 . . 메인로직 메서드 보유 클래스(Game)을 만들어주고 **응답값을미리 ** 작성해야한다. . 클래스 생성만 해주고 넘어가야한다 | 이 때 class가 상속예정이 없으면 final로 선언하는 버릇을 들이자. | . public final class Game { } . . | 응답값 아직 작성안된 class의 객체가 있을 예정이라면 Object로 응답해주고 (실패용)return null;하는 메서드 작성하기 . 빈 메서드 완성해주기 . . . 응답값 객체가 있을 예정이면 Object로 일단 응답시키고 return null;로 작성하자 return null;로 초기 작성해줘야 실패를 해서 고친다. | . | 순서가 있는 파라미터는 first, second로 네이밍해놓자 | 파라미터는 줄맞춤 해도 된다. | . public final class Game { public static Object start(final Card first, final Card second) { return null; } } . . | 04 Object 응답객체로 받아서 null이 넘어와 실패할 assert문 작성과 동시에 expected에 기입할 응답객체.class로 응답클래스만들어주기 . 객체 응답은 .isInstanceOf( 클래스.class)로 확인하면서 class작성해주기 . . Object [미완성응답객체]로 받아주고 -&gt; 확인을 .isIntanceOf(Hit.class)로 해주면서 클래스를 만든다 . @Test void hit() { // given &amp; when : hit final Object hit = Game.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.FIVE)); // then assertThat(hit).isInstanceOf(Hit.class); } . . public final class Hit { } . | 클래스를 채우거나 완성하지 않고 테스트를 돌린다. . return null;의 미완성 상태라 실패한다. | . . | 05 첫번째 응답객체로 메서드 응답(응답Type+return) 바꿔주기 . null이 넘어가는 상황을 현재 case의 응답객체로 바꿔줘야 케이스가 통과될 것이다. . 기존 | . public final class Game { public static Object start(final Card first, final Card second) { return null; } } . 변경 후 | . public final class Game { public static Hit start(final Card first, final Card second) { return new Hit(); } } . . | 테스트 돌려보면 통과된다. . | 06 2번째 예상응답인 blackjack case로 만들어 주고 로직 추가해주기 -&gt; given예상인자값도 바꿔주자! . 다형성 적용전까진, 바뀔 수 있는 응답객체의 변수Type을 Object로 유지해주기 . 그래야 다형성 적용 전, case 추가해서 받아줘도 테스트들이 다 통과될 것이다. | . 테메 복사 -&gt; 테메이름 -&gt; 변수이름 -&gt; 예상 응답값 -&gt; 예상인자값given -&gt; expeceed 모두 해당case로 바꿔주기 . . | 없으면 해당 클래스도 만들어준다. -&gt; final + enter 활용 . tab누르면 추가가 아니라 단어 덮어쓰기 되서 class가 사라지더라. | . public final class Blackjack { } . | 예상인자값도 바꿔주야한다. . ace + jack으로 바꿔줌 | . . | 테스트는 로직 추가/수정이 없으니 통과안한다. . | 07 복잡한 case통과를 위한 로직 추가해주기 . blackjack은 단순if문으로 통과할 순 없다. | . 카드의 합이 21이 될 때 return new Blackjack() 해주면 되는데, 지금은 점수를 가지고 올 수 없다. . Card -&gt; Denomination -&gt; 점수를 가지고 와야함. | . public static Hit start(final Card first, final Card second) { return new Hit(); } . | . | 필요에 의해 enum에 필드 추가해주기 . 여러개 선택은 커서가 물리는 중간에서 시작해서 -&gt; 같이 움직인다. . 1~2자리 숫자면, 2자리 숫자로 입력해서 지우는 식으로 가자. | . . | . 참고) enum에 필드를 만들어줬다는 말은 밖에서 갖다 쓸거라는 말이다 -&gt; getter가 될 준비를 한다. . 나중에 필요에 의해 작성할것이지만, 미리 작성해줘도 된다. . getValue대신 특정필드명이 있다면 .필드명()으로 게터를 대신한다. | . public int point() { return point; } . | . 08 최대한 빨리 테스트 통과시키기 . 참고) 도메인vs같/다른도메인의 비교 는 서비스(메인로직 구동) 메서드 내부에서 일단 getter이용해서 하고 -&gt; 도메인로직으로서 클래스를 추출하거나 해서 옮겨야한다. . 현재 getter를 쓰는 것에 대한 정당성 확보 -&gt; 같은 도메인끼리라도 내부 비교로직이라면 현재 서비스 로직에서 일단 작성해주고 추출해줘야한다. . but 같은 도메인끼리 or 도메인1개에 대해 단순 상수비교/ 메서드없이 단순집계 등는 개별 일괄처리 or 집계라면 묶어서 -&gt; 메세지 보내서 물어본다` -&gt; 현재의 상황 . 참고) [객체] 내부의 [포장변수 속 변수]를 가져올 때도 getter대신 .최종 나올 변수명()으로 메서드 지어 들어가기 . 예시) Player 속 Cards 속 cards에 접근하고 싶을 때 Player.getCards()가 아니라 Player.cards() 메세지를 보낸 뒤 Cards 내부에서 return this.cards로 보내주는 식으로 자기 변수처럼 바로 꺼내보도록 하자. get중간포장변수()가 아닌 .최종변수xxxx() | . | . . . . blackjack을 응답해주는 코드를 최대한 빠르게 작성해보자. . . . | if분기에 따라 서로 다른형의 객체를 응답해야할 떄 -&gt; 다시 응답을 Object형으로 바꿔주고 -&gt; 다형성을 생각한다 -&gt; 일단 테스트통과부터 확인한다. . . . 테스트가 실패한다. -&gt; ace는 기본 1 point로 시작하고, 11로 계산처리를 안해줘서 . public static Object start(final Card first, final Card second) { if (first.point() + second.point() == 21) { return new Blackjack(); } return new Hit(); } . . | . ACE에 대한 처리 . if문에 들어가있던 도메인끼리 연산을 밖으로 빼서 처리후 넣어줘야한다. . == 21정답과의 비교는 빼고 처리해야한다. | . public static Object start(final Card first, final Card second) { final int sum = first.point() + second.point(); if (sum == 21) { return new Blackjack(); } return new Hit(); } . . | . 참고) 2개이상의 같은 형이 개별 일괄처리가 필요할 땐 list에 넣고 -&gt; stream으로 일괄처리 -&gt; 도메인끼리가 아니라 stream 도메인 개별 처리 -&gt; 꺼내지말고 메세지보내서 처리한다 . 받은 first와 second가 같은형의 같은 도메인이 때문에 -&gt; list(List.of())에 넣어서 일괄처리한다. . | 도메인 1개에 대한 것이므로 (같/다른 도메인끼리의 연산이 아닌 순간 메세지보내서 처리) 메세지를 보내서 ace있는지부터 확인한다. . . . 이넘에게 연산이라서 .is메서드()로 물어봐야할 것 같지만 일단 넘어가보자. | . . 여러개에 대해 isAce가 anyMatch로 가지고 있다면, hasAce가 된다. | . public static Object start(final Card first, final Card second) { final boolean hasAce = List.of(first, second) .stream() .anyMatch(it -&gt; it.isAce()); final int sum = first.point() + second.point(); if (sum == 21) { return new Blackjack(); } return new Hit(); } . . intellij가 list에 담아서 stream하지말고 Stream.of()로 한번에 묶어라고 한다. . final boolean hasAce = Stream.of(first, second) .anyMatch(Card::isAce); . . | . | ace는 비록 1이지만, 합계 계산시 ace객체의 point를 11로 변경하지말고 21의 블랙잭 기준상수를 11로 낮추자? . . public static Object start(final Card first, final Card second) { final int sum = first.point() + second.point(); final boolean hasAce = Stream.of(first, second) .anyMatch(Card::isAce); if (hasAce &amp;&amp; sum == 11) { return new Blackjack(); } return new Hit(); } . 테스트는 통과하게 된다. | . . | 다양한class의 객체들 응답시 Object로 응답? 메서드가 많은 일을한다? . Object응답 | 메서드가 너무 많은 일을 한다. 같은형이라도, 도메인vs도메인 비교로직이라면일단 getter 서비스로직에 작성하되 -&gt; 추후 도메인로직으로 넘긴다. | 하지만… 지금과 같은 일괄처리/내부변수단순집계-&gt; 묶어서 메세지보내서 일괄처리 한다. | | 09 메서드가 길어져서 너무 많은 일 -&gt; 도메인1개or같은도메인끼리 상수or단순연산/집계 -&gt; 묶어서 메세지보내 일괄처리 or 내부변수 단순집계로 일괄처리한다. . 첫번째, 두번째 카드의 합계는 같은 도메인이면서 단순집계다 -&gt; 묵어서 일괄처리가 가능하다. . . | . 같은 도메인이라면 List.of()나 Stream.of()로 묶어서 일괄처리 or 단순집계가 가능하다. . 같은 도메인이라면 List.of()나 Stream.of()로 묶어서 일괄처리 or 단순집계가 가능하다. . . public static Object start(final Card first, final Card second) { final int sum = Stream.of(first, second) .mapToInt(it -&gt; it.point()) .sum(); //final int sum = first.point() + second.point(); final boolean hasAce = Stream.of(first, second) .anyMatch(Card::isAce); if (hasAce &amp;&amp; sum == 11) { return new Blackjack(); } return new Hit(); } . | 일괄처리/내부변수단순집계가 2번이상 필요하면 -&gt; List.of( , ,) 묶어놓고 개별 list.stream() 때린다. . . public static Object start(final Card first, final Card second) { //1. 같은형의 [일괄처리/단순집계]가 2번이상 필요할 땐 -&gt; 무조건 List.of()로 일단 묶어 변수로 뺀다. final List&lt;Card&gt; cards = List.of(first, second); // final int sum = Stream.of(first, second) // 일괄처리1: 내부변수 단순집계 final int sum = cards.stream() .mapToInt(it -&gt; it.point()) .sum(); // final boolean hasAce = Stream.of(first, second) // 일괄처리2: 일괄처리로 메세지보내기 final boolean hasAce = cards.stream() .anyMatch(Card::isAce); if (hasAce &amp;&amp; sum == 11) { return new Blackjack(); } return new Hit(); } . 서비스로직내 도메인로직의 class로 추출 . 10 서비스 로직 내 같은형 객체 2개이상의 일괄처리 로직 -&gt; 일급컬렉션으로 추출 . 객체일괄처리를 위해 뽑아낸 List.of() -&gt; 객체List -&gt; 일괄처리가 메서드로 가는 일급컬렉션 추출과정이 된다. . public static Object start(final Card first, final Card second) { // 1) 도메인vs도메인 비교로직 후 새 결과값(생성자) 포장(class)후 // -&gt; 그것의 추가 로직(메서드)이 아니더라도 // 2) 같은도메인 객체 2개이상의 묶어서 일괄처리(메세지보내 일괄처리 or 내부변수 변환후 단순집계)도 // -&gt; 일괄처리하려면 List&lt;객체&gt;를 뽑아내야하고 (상태값, 인스턴스변수) // -&gt; 일괄처리로직이 도메인로직(메서드)가 되어서 // -&gt; 포장하는 일급컬렉션을 만들어낸다. final List&lt;Card&gt; cards = List.of(first, second); final int sum = cards.stream() .mapToInt(it -&gt; it.point()) .sum(); final boolean hasAce = cards.stream() .anyMatch(Card::isAce); if (hasAce &amp;&amp; sum == 11) { return new Blackjack(); } return new Hit(); } . sum하는 부분/ hasAce로 뽑아내는 부분 -&gt; 일괄처리로 간주했지만 어떠한 역할이며 도메인 class를 만들어 위임해야한다. | . 서비스 메서드 내에서 발견된 역할과 객체List -&gt; 메서드 로직 내에서 일급컬렉션 추출해보기 . 서비스 메서드 내지만, 기존 List생성 코드라인을 복붙후 재료로서 사용해서 빨간줄 컬렉을 만든다. . . 완성되면 객체list는 삭제해준다. | . | 포장전 내부까는 코드였다면, 포장전 복붙 or 복사해놓은 상태로 최종메서드만 남기고 -&gt; 내부처리코드를 잘라내 들고들어가 -&gt; list자리에 -&gt; 내부포장되어있던 value만 바꿔넣어준다. . 객체list삭제로 인한 list.stream()에서의 list부분에 빨간줄처리해준다. . 비교메서드가 빨간줄이었다면, 그대로 일급내부에서 생성해도 됬찌만 . | getter/stream 등이 내부를 까는 메서드가 빨간줄이라면 복사후 지우면서 -&gt; 최종메서드 남겨 메세지 던지고 -&gt; 내부처리 코드를 들어가 내부처리한다. . 기존 . | 일급적용: 복사해놓고, 위에 올려놓고, 내부까는코드는 지우고, 최종만 남겨 메세지보낸다. . . | 일급적용: 최종 메세지 메서드를 만들면서, 내부처리코드를 잘라내서 들고들어가자. . . . . . | . | . public final class Cards { private final List&lt;Card&gt; value; public Cards(final List&lt;Card&gt; value) { this.value = value; } public int sum() { return value.stream() .mapToInt(it -&gt; it.point()) .sum(); } } . | 마찬가지로 hasAce로직도 . 복사 -&gt; 내부처리코드 삭제 -&gt; 최종만 남기고 -&gt; 내부로 잘라내서 복사 -&gt; list자리에 일급컬렉내부value(list)로 바꿔주기 . | 기존 . | 처리 . 최종메서드명이 따로 없다면 뽑아놓은 변수명(hasAce)나 최종 체인된 메서드(anyMatch + isAce)로 유추한 메서드로 메세지보낸다. | . . 내부로 들고들어갈 코드복사된 상태로-&gt; 최종메서드로 이름바꿔주기 . . | 코드 복붙후 list 자리에 포장변수value + return 등 처리해주기 . | . | . | 1번만 쓰인다면 지역변수 제거하고 inline화 . . public static Object start(final Card first, final Card second) { final Cards cards = new Cards(List.of(first, second)); if (cards.hasAce() &amp;&amp; cards.sum() == 11) { return new Blackjack(); } return new Hit(); } . 참고) 너무빠른 리팩토링이지만, if문이 하나의 도메인에 대한 여러 boolean문장이면, 메세지를 넘길 수 있다. (메서드추출이랑 다름) . 두 boolean문장이 cards에 관한 것이므로 -&gt; cards에 메세지를 던질 수 있다. . . | 메서드추출을 한다면? -&gt; 한 도메인에 대한 것임을 고려하지 못한 체 해당 로직class내에서 추출한다. -&gt; 메세지를 던지지 못한다. . . | . 참고-연결) 메세지를 던지려면, 내부처리로직 코드복사후 -&gt; 최종메서드로 던지기 -&gt; 밖에서 list가 아니라 일급그대로를 썼던 코드는? 내부에서 바로 메서드()형태로 내부메서드를 이용하면 된다. . 여기서 최종메서드로 메세지 던지는 이름은 is + Blackjack()으로 한다. . . 복사후, 바꿔주고 -&gt; 내부로 들고들어가 -&gt; 변수명만 처리해주면 되는데, 포장된 일급을 쓰던 코드를 메세지보냈다. -&gt; 일급변수명 빼고 내부에 존재하는 메서드를 메서드()로 호출만 해주면 -&gt; 내부의 this.value를 이용한 메서드를 알아서 호출해서 쓴다. . . | move staetment up/down 변수없이 호출되는 내부메서드들보다 위쪽으로 올려준다. . . | . | . 메서드의 응답을 Object -&gt; 응답되는 객체들을 뽑아내서 추상화or상위Type 생성으로 카테고라이징 . 11 서로 변하는 Blackjack 상태, Hit상태들을 상위타입으로 뽑아내기 -&gt; 일단 상위카테고리는 인터페이스로 뽑아낸다. . . State인터페이스를 만든다. . . public interface State { } . | 다형성으로서 응답값을 상카인 interface로 응답해준다 . public static State start(final Card first, final Card second) { final Cards cards = new Cards(List.of(first, second)); if (cards.isBlackjack()) { return new Blackjack(); } return new Hit(); } . | 참고) 상카로 카테고라이징하려고 인터페이스를 만들었다면 -&gt; 하위카테고리 구현체들이 impl 전에 응답값/ 변수/파라미터 등의 길목 선언부 먼저 인터페이스로 바꿔주자 -&gt; 거기로 향하는 예비 구현체들이 빨간줄 -&gt; 쉽게 + 자동 impl된다 . 길목(변수,파라미터,응답값의 선언부)응답값을 인터페이스로 먼저 바꿔줬더니, 응답될 예비구현체들이 구현되려고 빨간줄이 뜬다. . . . | . 묶여서 카테고라이징 되는 놈들은 인터페이스를 모두 구현한다 . public final class Hit implements State { } public final class Blackjack implements State { } . | 메서드의 응답값을 바꿔줬다면 -&gt; 까먹지 말고 밖에서 받아주는 변수도 Object에서 -&gt; 다형성-상카-인터페이스로 + 변수명도 인터페이스명으로 바꿔주자 . . 테스트코드라면 단순하게 현재파일에서 Ctrl+H로 찾아서 replace ALL해주면 된다. 찾은 갯수만 잘 확인해서 바꿔주자. | . | 변수명도 바꿔주자. . . public class GameTest { @Test void hit() { // given &amp; when : hit final State state = Game.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK)); // then assertThat(state).isInstanceOf(Hit.class); } @Test void blackjack() { // given &amp; when : blackjack final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); // then assertThat(state).isInstanceOf(Blackjack.class); } . | . 중요1) 왜? 추클이 아니라 인터페이스?로 상카뽑아 카테고라이징) . 어떤 메서드 or 변수들이 추상화 or 공통메서드로 뽑힐지 모르며. 카테고라이징이 목적이다 상카뽑는 목적이면 인터페이스부터 뽑는다. 추클로 바뀔 수도 있다. | . | . 중요2) 제한된 수의 상태값들인데, 왜 Enum이 아니라 클래스 객체로 상태 응답? . hit과 blackjack사이에 서로 연결되어 &lt;메서드호출로 인해&gt; 서로 바뀔 수 있는 묶인 상태들이다. -&gt; **서로 바뀌더라도 인페구현의 다형성으로 들어가 [상태를 바꿔주는 같은 이름의 메서드]를 계속 호출할 수 있는 상태값으로 상태 패턴 객체를 선택할 수 밖에 없다. ** . | 추가로 enum도 가능한 형태 뿐만 아니라 다음 상태로 바뀌기 위한 판단을 위해 내부에 인변=상태로 가지고 있어야한다. . 이넘은 상태값을 가지면서 공유할 수 없다. | TDD의 D는 디자인이 아니다 -&gt; 미리 설계되어있고 development만 한다. | . | . 참고) 상속/추상화/카테고리 작업후엔 클래스 다이어그램 보기 . 프로덕션을 봐야한다. -&gt; 프로덕션의 패키지폴더를 클릭한 상태로 단축키 ctrl+alt+shift + U + edge create mode는 기본적으로 켜두자 . . | . 다음 상태로 이어가기 -&gt; 기본 2장받고 가능한 상태:Hit or Blackjack -&gt; 다음엔?? -&gt; 둘 중에 더 만만한 것에서부터상태 변화를 이어나간다. . 12 hit 과 blackjack 두 상태 중 blackjack은 다음이 게임종료라 구현이 더 쉽우니 blackjack에서 이어나간다. . 특정상태에서 이어나가는 테스트메소드의 작성 . 직전까지 작성된 blackjack이 된 상태응답 테스트코드를 그대로 복붙한다 -&gt; 테메이름에 현재상태 + 이어질 작업을 더해준다. . @Test void blackjackDraw() { // given : blackjack -&gt; 더이상 게임을 할 수 없다. (hit에서 이어지는 것보다 쉽다) final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); } . | 예외발생이 정답인 메서드호출 -&gt; 메서드 호출시 끝남 = 메서드호출시 예외 -&gt; 생성자처럼 assertThrows() 문에서 해당예외 명시하며 + 호출하며 테스트 . **blackjack에서 카드받는다고 하면 -&gt; 호출시 예외발생으로 작업이 끝나야하므로 **생성자처럼 예외발생이 정답인 호출이 된다. . @Test void blackjackDraw() { // given : blackjack -&gt; 더이상 게임을 할 수 없다. (hit에서 이어지는 것보다 쉽다) final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); // 1. blackjack은 끝난 상태로 -&gt; [상호 상태 변화 전략메서드()] 호출시 예외가 발생하도록 짜야한다. // -&gt; blackjack상태에서 .상호상태변화 전략메서드()호출시 -&gt; 문제가 생겨야한다. state.draw(); } . | 생각해보니, 상태변화에는 카드1장 받기의 재료(인자)가 필요하다. . @Test void blackjackDraw() { // given : blackjack -&gt; 더이상 게임을 할 수 없다. (hit에서 이어지는 것보다 쉽다) final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); // 1. blackjack상태에서 .상호상태변화 전략메서드()호출시 -&gt; 문제가 생겨야한다. // 2. 상태변화에는 card1장이 필요하다. state.draw(Card.of(Suit.SPADES, Denomination.TEN)); . | 예외발생이 정답인 호출이라면, assert문 내부에서 예외명시하며 호출한다 . @Test void blackjackDraw() { // given : blackjack -&gt; 더이상 게임을 할 수 없다. (hit에서 이어지는 것보다 쉽다) final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); // 1. blackjack상태에서 .상호상태변화 전략메서드()호출시 -&gt; 문제가 생겨야한다. // 2. 상태변화에는 card1장이 필요하다. //state.draw(Card.of(Suit.SPADES, Denomination.TEN)); // 3. 예외발생이 통과인 호출 -&gt; assert문 내부에서 예외명시하며 호출 assertThrows(IllegalStateException.class, () -&gt; state.draw(Card.of(Suit.SPADES, Denomination.TEN))); } . | 특정 구현체[끝 상태]에서 [상태변화의 전략메서드] 호출인지 / 아니면 단독메서드 호출인지 고민해보기 . 13 게임끝의 상태에서 더 진행하는 상태변화 메서드 호출시 에러발생인데, blackjack상태에서도 재료(인자, card1장)를 받는 공통 전략메서드를 부를 수 있나? . . @Test void blackjackDraw() { // given : blackjack -&gt; 더이상 게임을 할 수 없다. (hit에서 이어지는 것보다 쉽다) final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); // 1. blackjack상태에서 .상호상태변화 전략메서드()호출시 -&gt; 문제가 생겨야한다. // 2. 상태변화에는 card1장이 필요하다. // 4. 근데, blackjack은 끝난 상태인데 게임상 재료로서 들어올 수 있나??? (읹 //state.draw(Card.of(Suit.SPADES, Denomination.TEN)); // 3. 예외발생이 통과인 호출 -&gt; assert문 내부에서 예외명시하며 호출 } . 만약, 공통전략메서드가 아니라 특정 구현체만 가능한 단독 메서드라면 . 만약, blackajck에서 가능한지? 가 아니라 . | 하위카테고리 중 1개인 blackjack에서만 가능하다면 . 억지로 쓴다면 (특정카테고리)다운 캐스팅후 써야한다. | . . | . 중요3) 상카(추상체)가 잡힌이후 메서드의 추가는 (모든 카테고리 구현체 다 가능할 것 같은데, 혹시 모르니) 현재 특정상태(구현체) 1개만 호출 가능한 메서드라고 가정하고 해당 구현체에만 메서드가 생기도록 구현체변수 -&gt; 다운캐스팅 -&gt; 메서드호출() 빨간줄생성하여 코드를 짜보자. . 14 draw(Card card)가 hit와 blackjack 모든 카테고리가 호출가능할 것 같지만, 보수적으로 blackjack에서만 호출가능한 단독메서드라고 가정해놓고 짜보자. . 특정 구현체만 호출가능한 메서드를 호출하고 싶다면, 다형성으로 받던 곳에서 변수 먼저 특정 구현체Type으로 받아주고 -&gt; (= 우항 빨간줄 다운캐스팅)해서 -&gt; 단독메서드 호출()하여 -&gt;단독 빨간줄 생성해줘야한다. . 상카(추상체)가 있는 상황의 구현체(blackjack)에서, **특정 구현체만 호출가능한 메서드를 호출한다? ** . 다형성(추상체)으로 받는 변수 먼저 바꿔주고 . | ide빨간줄로 (우항에서 다운캐스팅)`하여 구현체로 받아서 단독메서드를 호출해야한다. . . . . @Test void blackjackDraw() { //1. 구현체 blackjack만의 단독메서드라고 가정 -&gt; 다운캐스팅해서 받아야한다. // final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), // Card.of(Suit.SPADES, Denomination.JACK)); final Blackjack state = (Blackjack) Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); assertThrows(IllegalStateException.class, () -&gt; state.draw(Card.of(Suit.SPADES, Denomination.TEN))); } . | | 구현체로 받은 상태에서 빨간줄 create method -&gt; 구현체에서 정의 or 추상체에서 정의 선택할 수 있다. . 다운 캐스팅 이후 구현체로 받은 상태에서 메서드 호출 -&gt; 구현체에만 메서드 생성해보자. . 구현체로 받은 상태에서 빨간줄 create method하면, 구현체에만 정의할 수 있게 선택할 수 있다. | . . | draw() 호출시 에러나야 통과하지만, 일단은 응답값으로 추상체를 넣고 정의해주자.(결국엔 추상체Type응답 -&gt; 다형성으로 응답하여 -&gt; 상호 바뀔 수 있는 카테고리내 상태 아무거나로 가능하게 바뀔 것임.) . public final class Blackjack implements State { public State draw(final Card card) { throw new IllegalStateException(); } } . | my) 인터페이스로 추상화했다면, 다운캐스팅 or 구현체변수 상태에서는 단독메서드 생성이 가능하다. . 다운캐스팅 + 구현체 변수가 거슬리지만, 예외발생으로 통과가 잘되는 것 같다. . @Test void blackjackDraw() { // final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), // Card.of(Suit.SPADES, Denomination.JACK)); //1. 구현체 blackjack만의 단독메서드라고 가정 -&gt; 다운캐스팅해서 받아야한다. final Blackjack state = (Blackjack) Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); //2. 다운캐스팅해서 blackjack에만 구현되도록 했지만. assertThrows(IllegalStateException.class, () -&gt; state.draw(Card.of(Suit.SPADES, Denomination.TEN))); } . . | 고민 - state가 card를 .draw()로 받아도 되느냐? . my) 상태값(인변)을 가진다-&gt; 재료로 받아서 시작되거나 재료없이 빈재료로 내부초기화되어서 시작 하며 -&gt; 추가정보 등 내부 상태값이 업데이트 되고, 그 변화된 상태값을 재료로해서 업데이트된 새 객체를 반환해주려면 상태값으로 가져야한다. . 어떤 값을 받았다 -&gt; 메서드호출로 업데이트 했다. -&gt; 인변 , 상태값으로 가지고 있어야 그것을 재료로 해서 new 새객체(업데이트재료)로 업데이트된 객체를 생성할 수 있게 된다. 상태값은 객체의 이전값을 유지 + 업데이트해서 새객체 반환을 할 수 있는 것이다. | . | . my) 요약: 클래스의 상태값은 재료로 들어와 포장되며 (가공된 뒤 적은 수로)내부에서 가지고 있어야, 변화를 반영한 새객체도 생성시에도 재료로서 생성시 쓰인다라고 할 수 있다. . 중요4 my) 추상체로서 여러 구현체 state를 가지는 state를 사용하는 순간부터 state 변화를 판단하는 정보들은 state가 내부에서 실시간 반영되는 상태값(인변)가지며 + 전략메서드를 통해 바로 바뀌거나, 필요한 추가정보를 현 정보들과 같이 판단하여 다른 구현체로 바뀐다 . player는 name과 cards를 가질 수 있다. cards에 담긴 정보를 메세지를 보내 물어봐서-&gt; 현재 state를 판단한다. | . | player는 name과 현재 상태이자 메서드호출시 다른 것으로 바뀔 수 있는state를 추상체를 가질 수 있다. state를 사용하는 순간부터 state판단에 필요한 정보들(cards 등)들을 state 내부에서 관리한다. state는 메소드를 호출을 통해 실시간으로 현재 상태에 맞는 구현체를 응답하여 상태를 바꾼다. 그 상태변화의 트리거가 추상체의 전략메서드 .draw()다. | 상태를 바꾸는 트리거 메서드는 전략메서드로서 공통이며 상태 변화를 유발하는 추가정보(card 1장)을 인자로 받을 수 있다. | . | . | . 15 blackjack상태는 끝났다면, hit상태에서 진행해보자. . 진행되는 테스트는 테메를 복사후 -&gt; 확인된 given을 유지한체 다음 상태를 유발한다 . 테메 복사후, 테스트_이름만 기존상태+트리거 로 바꾼다. . given만 hit상태를 유지 | . . @Test void hit2() { // given &amp; when : hit final State state = Game.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK)); } . | 특정상태에서 먼저, 상태변화 트리거인 메서드를 호출할 수 있는지(예외발생 안하는지)부터 고민한다. . 현재 hit상태에서의 목적: 카드1장받는 상태변화 트리거 메서드를 호출하더라도 에러안나고 호출가능 = 응답값 제대로 반환받음(isInstanceOf)증명해야한다. . 16 hit상태에서 또 draw로 카드받을 수 있나? 받을 수 있다면 단독메서드로서 다운캐스팅후 구현체 변수로 받아놓고 단독메서드로서 가정하고 개발을 시작한다. . 인터페이스의 상카를 가졌더라도, 보수적으로 구현체 단독메서드로서 일단 개발한다. . 구현체로 다운캐스팅 | 좌항을 구현체 변수로 받아주고 -&gt; 구현체 단독메서드로서 개발 | @Test void hit2() { // given &amp; when : hit -&gt; draw -&gt; hit //1. 구현체 (Hit)로 다운캐스팅한다. final Hit state = (Hit) Game.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK)); } . . | 다운캐스팅 하더라도, 우항에 체이닝으로 개발하면, 다운캐스팅 안먹고 응답되는 추상체로 메서드 개발됨. -&gt; 반드시 좌변 구현체 변수로 받아야 구현체-단독메서드 개발이 가능하다. . 구현체 변수로 변경이후 메서드 체이닝을 통해, 바로 이어서 단독메서드를 호출하여 단독메서드를 개발해보자. . 아래는 체이닝으로 했더니.. 다운캐스팅해도, 좌변 변수 받아도 단독메서드 빨간줄 생성 안됨. | . . | 참고) 어차피 직전 테메를 복붙해온 given의 hit상태가 보장되어있으니, 편하게 다운캐스팅 + 구현체 변수로 받아놓고 -&gt; 단독메서드 개발 . . . 일단 단독메서드 개발시 . 응답값은 추상체 State로 가야할 것이다. | 첫 개발이니까 return null;을 주고 실패하는 코드로 돌리자 | . public final class Hit implements State { public State draw(final Card card) { return null; } } . | blackjack과 다르게, 예외없이 다음에 올 구현체 상태를 응답해야하므로 밖에서는 state변수를 재할당시켜 업데이트해줘야한다. 하지만, 단독메서드 개발을 위해, 구현체 변수로 받아둔 state를 returnType State의 응답으로 재할당이 불가능하다. . . . . 다음 상태 트리거 전략메서드는 공통메서드, 추메라면 -&gt; 다양한 구현체 응답을 위해 State 응답이 맞으나 단독메서드 -&gt; 단독구현체로 응답하도록 임시대응 한다. . . . 중요5) 마지막 구현체(hit)의 단독메서드 구현 와중에 -&gt; 상카 아래 모든 구현체(hit, blackjack)들이 &lt;구현은 다르지만 모두 호출 가능&gt;한 공통메서드 -&gt; 인터페이스에선 추메로 추상화하고, 직접 추상화이후 @Override 직접 붙이기 . 중요6 my) 추메로 추상화해도 구상체별로 개별 구현해줘야하는데??? —&gt; 인페의 추메로 추상화 핵심은 코드 중복제거가 아니라 구현체 모두 호출가능시 구현체전용 단독메서드를 올려 다운캐스팅 제거+ 파라미터/응답/변수에서 추상체로 받아 일괄처리 가능해진다. . 16 구현체 모두가 호출가능할 수 있다면, 인페-추메(전메)로 추상화해서 -&gt; 다운캐스팅 제거후 추상체.전략메서드호출()로 호출이 가능해진다.. 그전에… . 참고) 구현체 단독메서드 -&gt; 추메/전메로 올리기 전 확인은 다이어그램+ creation mode + method로 하자 . . 현재 hit와 blakcjack의 구현체 모두 단독메서드(draw)들을 구현은 달라도 호출가능이라면 올릴 준비를 한다. | 중요7) 구현체 단독메서드 -&gt; 추메/전메로서 (선언부 시그니쳐만) 위로 올릴 때, 받는 변수/응답값/파라미터 등에 구현체가 있다면, 그것들도 추상체로 바꿔서 올려줘야한다. . 구현체의 단독메서드 -&gt; (선언부 시그니쳐만) 추상체의 전메/추메로 올릴 때 -&gt; 복붙해서 가져간 뒤 구현체로 응답이 보인다면 추상체로 바꿔줘야한다. . hit의 draw() 단독메서드를 올린다고 가정하보자. . . | 올리기 위해 추상부인 선어부만 복사 . . | 선언부 복붙후, 구현체 응답이 보이면 -&gt; 추상체로 변경 . . | . | 추메 선언부에서 추상체응답으로 바꿔두면, 기존 구현체 구상체응답으로 개별구현이 계속 허용된다. | . | . 참고) 인페의 추메/전메로 선언부를 올릴 때, 접근제한자 제거해서 default로 일단 시작하기 . . 중요) 인페의 추메/전메로 수동 추상화 올린 다음엔하고 난 뒤, usage-impl 수를 확인해서 개별 구현남아있어야하니 @오버라이딩만 직접 가서 해준다. . . . . 중요) 추상화 끝난 단독메서드는 더이상 구현체만의 단독메드가 아니다 == 다운캐스팅 안해도 (오버라이딩된) 추상체변수로 받은 상태에서 추메/전메로서 호출가능해진다. -&gt; 다운캐스팅 제거하고 추상체변수로 받도록 수정하기 . 기존 Hit 구현체에만 단독이라고 믿어서 개발했던 단독메서드가 . 추상화 -&gt; 추메/전메가 되었고 + 오버라이딩 @도 달게되었다면 | 다운캐스팅을 제거한 추상체변수로 받아 -&gt; 바로 호출이 된다. | . . . . | . 17 hit 에서 메서드 호출가능해서 -&gt; 모든 구현체 호출가능 -&gt; 메서드 추상화 해준 이후 -&gt; 응답으로서 또 여러 경우의수가 나온다. -&gt; hit + ?? -&gt; 복사해놓고 구체적으로 1case를 또 정해주고 빠른통과하도록 메서드짜기 . 참고) 다음 가능한 상태가 여러개로 나올 경우, 변화전 given현재 상태의 테메를 그만큼 복사해놓고, case를 정해놓고 진행해나가자 . . hit -&gt; draw(card) -&gt; ??? hit or stay 중에 만만한 것으로 가면 된다. hit부터 한다고 가정한다. | . | . given된 상태의 테메를 복사해서 . 예상응답값: hit | 가정인자: 다음 응답도 hit가 되도록 +1(ACE)를 draw()한다. | . . @Test void hitToHit() { // given &amp; when : hit -&gt; draw -&gt; 2,10,1 -&gt; hit State state = Game.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK)); state = state.draw(Card.of(Suit.SPADES, Denomination.ACE)); // draw호출이 가능해서 assertThat(state).isInstanceOf(Hit.class); } . | 이제 case에 맞게 메서드를 수정한다. . 일단 new Hit()만 반환해주면 된다. . . . @Override public Hit draw(final Card card) { return new Hit(); } . | . | hit담에 hit가 나오므로 통과한다. . | 18 hit에서 새로운 응답값(= 객체 상태)가 나오는 case에서는 테메이름 + case로 가정인자 조절 + expected로서 assert-isInstanceOf의 새객체.class등 미리 작성하고 하나씩 만들어나간다. . hit -&gt; hit 뿐만 아니라 다른 경우의 수인 hit -&gt; Bust를 위해 기존hit가 확인된 테스를 복사해뒀었다. -&gt; 테메이름을 변경하자 테메이름을 변경하자 -&gt; 기존 + 다음상태case | . | 주어진 hit상태에서 가정인자들도 다음상태를 유도하는 것으로 바꿔주자 . . | 예상값이 Bust의 상태객체가 나와야한다. . 빨간줄로 만들어가자 | . . | 참고) 카테고라이징(추상체 인페보유)된 상태들에 -&gt; 새 객체를 추가한다면? -&gt; class생성(fi or ab)후 해당 추상체를 impl -&gt; 그에 따라 추메/전메를 impl하여 카테고리에 추가해준다. . . . . . . Bust 상태에서 추메/전메를 impl하면 다음 상태로는 뭘 줘야할까? 끝나야할까? 일단은 return null;로 비워두기 . 아직 버스트에서 draw가능한지 / 다음 상태는 뭘로 줄지가 안정해졌으므로 구현체 단독메서드지만 일단 State응답 -&gt; return null;로 비워둔다. . . | . public final class Bust implements State { @Override public State draw(final Card card) { return null; } } . . 19 hit 상태에서 개별구현되고 있는 트리거 메서드에서 호출시 Bust가 응답되도록 메서드 로직 짜주기 . ctrl+F12를 통해, 추상체 변수.추메()로 보이는 구현체 Hit의 메서드로 찾아간다. 현재는 구현체hit에서 호출시 new Hit()만 반환하게 되어있다. | . | 중요) 개별구현중인 구현체 메서드에서 다른 구현체로 넘어가는 로직짜기 -&gt; 이전 정보를 받아와 by 재료를 생성자를 통해 현재 상태를 나타내줄 정보들을 상태값(인변)로서 내부에 가지고 있어야만 상태패턴의 상태객체다. . . @Override public Hit draw(final Card card) { // 0. 현재는 무조건 hit -&gt; draw -&gt; hit를 응답하지만 return new Hit(); // 1. if 21이 넘으면 -&gt; Bust를 응답해줘야한다. } . 20 필요에 의해 현 상태 -&gt; 다음 상태로 넘어가는데 필요한 정보들을 상태값(인변)으로 가지고 있어야하며 -&gt; 트리거 메서드에 의해 실시간으로 바뀌는 상태값으로서 State가 내부에서 직접 상태값으로 이미 가지고 있어야만 한다. . hit 상태에서 . if 21이 넘으면 bust객체로 응답 21이 넘는지는 내부에 필요정보인 cards를 들고 있어야만 가능하다. | . | . @Override public Hit draw(final Card card) { // 0. 현재는 무조건 hit -&gt; draw -&gt; hit를 응답하지만 return new Hit(); // 1. if 21이 넘으면 -&gt; Bust를 응답해줘야한다. // 2. draw()시 21이 넘는지 안넘는지 판단하기 위해서는 // -&gt; 들어오는 card에 대해, 현재 cards의 정보가 필요하다. } . | 중요) 현재 상태값(인변)으로 이미 정보를 가진다? -&gt; 상태값 필드(인변) + 생성자에서 재료받아 초기화형태가 있어야 이전 정보를 가져와 실시간 업데이트 가능한 정보로 보유한 셈이 된다. . 일단 필요한 정보로서 상태값(인변)을 private final로 가지자 . public final class Hit implements State { //3. card1장을 받기전에, [현재 상태를 상태값 cards]으로 가지고 있어야한다. // -&gt; 상태값(인변)을 가진다? -&gt; 생성자에서 재료받아 초기화한다. private final Cards cards; . . . public final class Hit implements State { //3. card1장을 받기전에, [현재 상태를 상태값 cards]으로 가지고 있어야한다. // -&gt; 상태값(인변)을 가진다? -&gt; 생성자에서 재료받아 초기화한다. private final Cards cards; public Hit(final Cards cards) { this.cards = cards; } . | 21) 상태값(정보)를 추가를 위해 필드+재료받는 생성자를 추가했더니 기존의 재료없이 기본생성자를 이용한 것들이 에러가 난다. . . 참고) new()로 생성자정의없이 기본생성자로 테스트에서 미리 많이 쓴 경우 -&gt; 재료받는 생성자가 생기는 순간 재료받는 생성자가 주 생성자 -&gt; 위에 this를 활용해서 재료 안받고 -&gt; 내부 빈 재료로 정보 초기화 하는 부새성자를 추가해주자. . 재료없는 생성자 생성방법은 -&gt; genearte 후 consructor -&gt; Select None으로 생성하면 된다. . public Hit() { } . | 재료받는 생성자가 주생성자이며, 재료 생성말고 빈 재료로 정보 초기화해주자. . 그 전에.. 사용처를 보니 new Hit()의 재료없는 기본생성자로 사용한 경우가 1usage로 현재 여기 Hit class내부 밖인 상황이다. -&gt; 기존 테스트 유지를 위한 생성자 추가 생성을 할 필요가 없는 상황임 . . | F12눌러서 따라가도 현재 상황 . | 그렇다면 굳이, 코드 유지를 위한 재료안받고 빈재료로 정보초기화해주는 기본생성자가 필요하지 않다. . | . | 중요) 추가정보(by트리거 메서드 인자)를 받아 현재 정보(인변으로 보유)를 업데이트해서 판단한다 . 일급컬렉션 정보(상태값)의 add/remove()는 내부 정보를 변화시키지말고 변화된 내부정보로 일급을 만들어 반환하여 불변 &amp;&amp; 밖에서 반환된 것을 이용 . 22) 이전 카드정보들을 상태값으로 보유하고 있는 상황에서 -&gt; 다음 상태로 가기위에 카드1장의 추가정보(메서드인자)를 받아 현재 정보(인변으로 보유)를 업데이트하자 . . . 일급 내부변수를 변경시키려한다면(list.add/remove) -&gt; 불변 일급으로 만들어서 -&gt; 변경된 list(정보)로 새 일급을 새로 만들어 반환해주면 -&gt; getter로 상태값을 열람할 필요가 없어진다. . 일급.add( )후 상태값 확인시 -&gt; 불변이면서 add가 새 일급을 응답하도록 불변 일급컬렉션만들어주기 비슷한 사례: Count VO의 +=로 내부 상태값 변화시키고 그게 필요 | 일급컬렉션의 add로 내부 상태값 변화시키고 그게 필요 | . | . | . 기존 상태값은 변경하기 전에, 복사를 먼저 한다. . 나쁜예: 기존 상태값에 .add()로 자체변경을 먼저 가하면 안된다. . | 기존 상태값은 건들지말고, 변경을 가할 복사본을 먼저 만든다 . | . | 복사된 상태값에 변경을 가한다. . public void add(final Card card) { //1. 기존 상태값을 변경없이 먼저 복사한다. (기존 상태값을 .add()로 바로 변경하지 않는다) final List&lt;Card&gt; newValue = new ArrayList&lt;&gt;(value); //2. 복사된 상태값에 증감을 가한다. newValue.add(card); } . | 증감이 반영된 복사된 새 상태값을 외부이므로 상태값이 아닌 포장된 일급객체로 응답해줘야한다. . public Cards add(final Card card) { final List&lt;Card&gt; newValue = new ArrayList&lt;&gt;(value); newValue.add(card); //3. 증감이 반영된 복사 상태값을 -&gt; **외부에서 일급**으로 쓰이니 // -&gt; [새 일급으로 포장해서 응답]** return new Cards(newValue); } . | 참고) 외부에서 내부(증감)변화의 메세지를 보낸 뒤 -&gt; 그 내부상태를 가져다 쓰고 싶다면 -&gt; 불변 포장객체로 응답해서 밖에서 사용가능하게 하라 . 23) 불변 일급컬렉션으로 증감시 새객체를 반환해주면 -&gt; 외부에서 .add 해줘도 내부만 변화되는게 아니라 외부에서는 증감이 반영된 내부정보를 포장한 일급을 받아쓴다 -&gt; 메세지 보내서 업데이트된 내부 정보에 대해 물어보기만 하면 된다. . 일급.add( 추가정보 )로 내부만 변화될 것 같지만 . 불변 일급은 내부에서 변화가반영된 새 일급을 응답해주니 그 정보를 밖에서 이용하면 된다. | . . | 이제 변화가 반영된 정보를 포장한 일급 컬렉션으로 메세지를 보내서 현재 상태를 물어보면 된다. . @Override public Hit draw(final Card card) { final Cards currentCards = cards.add(card); // 21이면 블랙잭 // 21넘으면 Bust // 21이하면 return new Hit(); } . | 변화된 정보를 담은 일급에게 21넘으면 Bust인지 물어보자. . 물어볼 때, 내부에서의 this.value는 변화가 반영된 정보상태임을 인지하자. | . . this.value나 value등을 사용하지 않는 같은 class에서 정의되었으며, 내부에서는 잘 사용되고 있는 이미 정의해놓은 메서드()를 호출해서 물음에 답(합)을 구할 수 있다. | . public boolean isBust() { return sum() &gt; 21; } . | 이제 또다른 Hit 구현체에서 정의한 draw()는 또다른 상태의 구현체도 return 메서드가 되었다. . . . | 24) 다른 구현체가 안되더라도, 같은 구현체로 응답(hit-&gt;hit) 되더라도 추가정보를 반영하여 응답된 업데이트된 정보 by 불변 일급를 담아서 -&gt; 업데이트된 구현체로 응답되어야한다. . . @Override public State draw(final Card card) { final Cards currentCards = cards.add(card); // 21이면 블랙잭 // 21넘으면 Bust if (currentCards.isBust()) { return new Bust(); } // 21이하면 return new Hit(currentCards); } . 다시 테스트로 돌아와서, hit -&gt; bust로 잘 업데이트 되는 것을 확인할 수 있다. . @Test void hitBust() { // given &amp; when : hit -&gt; draw -&gt; 2,10,10 -&gt; bust State state = Game.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK)); state = state.draw(Card.of(Suit.SPADES, Denomination.TEN)); assertThat(state).isInstanceOf(Bust.class); } . | . 중요) 끝상태에서 -&gt; 트리거 호출시 예외발생으로 종료까지 마무리 해줘야한다. . hit or blackjack blackjack -&gt; 뽑을 시 예외발생해서 종료 | hit hit | bust -&gt; 뽑을 시 예외발생해서 종료 « 먼저 처리해주자 | blackjack? | . | . | . 25) bust에 온 상태의 테메를 복붙하여 bust까지를 세팅해놓고 -&gt; 뽑으면 종료되는 case를 처리하자. . bust까지 온 상태의 테메를 복붙한다. . 테메이름을 다음상태는 없으니 현상태 + 뽑았다정도로 짓는다. | . . | 참고) 원하는 상태까지 업데이트 트리거 메서드를 체이닝으로 호출해서 한번만 할당해놓자 . 참고) 추상체 응답Type의 구현체 상태 업데이트 트리거 메서드(draw)는 체이닝으로 원하는 상태 만들 때까지 갈 수 있다. . 재할당으로 업데이트 하는 순간 -&gt; assert문에서 람다캡처링에 걸려 메서드호출이 안되더라 . . | . bust도달까지를 given으로 주고, 추가로 카드를 하나 더 뽑기 전에 -&gt; 추상체 변수에 담기전에, 체이닝으로 트리거 메서드 호출하도록 해주자. . 참조변수 재할당시 -&gt; assertThrows의 람다캡처링 때문에 호출이 불가능 한 문제 발생 . | 기존 . State state = Game.start(Card.of(Suit.SPADES, Denomination.TWO),//2 Card.of(Suit.SPADES, Denomination.JACK));//10 state = state.draw(Card.of(Suit.SPADES, Denomination.TEN)); //10 -&gt; 여기까지 bust . | 체이닝으로 한번만 할당된 체로 bust 세팅완료 . State state = Game.start(Card.of(Suit.SPADES, Denomination.TWO),//2 Card.of(Suit.SPADES, Denomination.JACK))//10 .draw(Card.of(Suit.SPADES, Denomination.TEN)); //10 -&gt; 여기까지 bust by 메서드체이닝으로 업데이트 . | . | 테스트시 예외발생안해서 통과안되어야한다. 아직 로직을 안짠 실패하는 코드 상태이므로 . @Test void BustDraw() { // given : hit -&gt; draw -&gt; 2,10,10 -&gt; bust State state = Game.start(Card.of(Suit.SPADES, Denomination.TWO),//2 Card.of(Suit.SPADES, Denomination.JACK))//10 .draw(Card.of(Suit.SPADES, Denomination.TEN)); //10 -&gt; 여기까지 bust by 체이닝 // 예외발생해야 통과 메서드호출은, when으로 미리 호출하지 않고 -&gt; assert문에서 바로 호출한다. // 2,10,10 bust -&gt; 3 받을 시 예외발생해서 종료되어야한다. assertThrows(IllegalStateException.class, () -&gt; state.draw(Card.of(Suit.SPADES, Denomination.THREE))); } . | 중요) 추상체 변수로 받은 구현체 메서드의 로직개발시 추상체변수.메서드()의 외형이라도 현 구현체 상태에 잘맞게 ctrl+f12로 잘타고가서 개발하자 . 겉으로 보기엔 추상체 메서드를 개발하는 것 같다 | 하지만 현 구현체(Bust)를 잘타고 들어가서 개발해야한다. | . Bust의 .draw()메서드로 가서 예외발생로직을 짜주자. . . public final class B ust implements State { @Override public State draw(final Card card) { throw new IllegalStateException(); } } . | 테스트가 통과된다(호출시 예외발생으로 종료) . | 참고) 다이어그램에서, return이 Null이거나 Thr라면 물음표?가 찍혀있게 된다. ( 업데이트 안됨) . return을 억지로 new Bust()로 준 상태ㅁ . . | return null;로 준 상태 . | .",
            "url": "blog.chojaeseong.com/java/pattern/state/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/27/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD%EA%B3%BC-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4.html",
            "relUrl": "/java/pattern/state/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/27/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD%EA%B3%BC-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4.html",
            "date": " • Mar 27, 2022"
        }
        
    
  
    
        ,"post24": {
            "title": "람다 캡처링 문제",
            "content": "람다 캡쳐링 . 람다는 새로운 stack을 생성해서 처리한다 -&gt; 밖(heap)영역에 있던 변수 변경에 제한이 걸린다. . 밖에서 선언된 원시변수의 값 변경은 불가능하다 (값만 복사해와서 사용만 한다) . | 밖에서 선언된 컬렉션은 주소만 가지고 와서 처리하니, 주소값의 변경은 애초에 하지도 않으며, 이미 생성된 것에 대해 add/remove 등이 가능하다 . | **밖에서 재할당한 참조변수의 경우에 메서드 호출이 불가능했다. ** . 참조변수가 할당만 1번 했다면, 호출이 가능하다. | . . | . | 참고 블로그 . | .",
            "url": "blog.chojaeseong.com/java/lambda/%EB%9E%8C%EB%8B%A4%EC%BA%A1%EC%B2%98%EB%A7%81/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/21/%EB%B8%94%EB%9E%99%EC%9E%AD_%EB%9E%8C%EB%8B%A4-%EC%BA%A1%EC%B3%90%EB%A7%81.html",
            "relUrl": "/java/lambda/%EB%9E%8C%EB%8B%A4%EC%BA%A1%EC%B2%98%EB%A7%81/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/21/%EB%B8%94%EB%9E%99%EC%9E%AD_%EB%9E%8C%EB%8B%A4-%EC%BA%A1%EC%B3%90%EB%A7%81.html",
            "date": " • Mar 21, 2022"
        }
        
    
  
    
        ,"post25": {
            "title": "강의) 네오 클래스 인스턴스 심화",
            "content": "지금까지 클래스 . 지금까지의 Class는 객체를 찍어내는 Factory일 뿐이었다. | 조금 더 나아가서 객체 생성 Factory(찍어내는 템플릿)일 뿐만 아니라 객체의 능동적인 관리자의 역할도 할 수 있다. | . 제한적인 자바의 new 키워드 . java에서는 new키워드가 제한을 가지고 있다. 무조건 응답해야하며 | 무조건 객체가 생성되어야한다. | | . 정펙매로 Class를 객체(생성의) 능동적 관리자로 승격 . 정펙매를 통한 캐싱 -&gt; [new처럼 매번 새로 생성]안해도 되는 객체 생성 . 01 프로덕션 원시값을 포장 -&gt; [public 주생성자]만 빨간줄 자동생성 . 기본적으로 클래스내 원시값int를 인스턴스 변수 = 상태값으로 포장하여 선언하면 빨간줄로 생성자 만들라고 한다. . . . public class LottoNumber { //1. 내부 포장 상태값 -&gt; 빨간줄 private final int value; //2. 빨간줄 -&gt; add constructor parameter // -&gt; private으로 생성하면 좋겠지만, public으로 기본 생성함 public LottoNumber(final int value) { this.value = value; } } . | 02 도메인 Test코드에서 생성자를 테스트하는데, [new 키워드의 public 주생성자]는 템플릿일 뿐이며, 항상 new사용과 동시에 100% 객체를 새로 생성(하여 할당) 할 수 밖에 없다. . LottoNumberTest를 만들고 생성자 생성 연습시작 . go to test(직접지정 ctrl+shift+t)로 생성하거나 이동하기! . . | . | new키워드를 사용해한다면객체를 생성하는 public 주생성자로서 사용과 동시에 항상 객체를 100% 새로 생성해야만한다. . class LottoNumberTest { @Test void create() { //new 키워드(public주생)는 템플릿으로서, 항상 사용과 동시에 객체를 100% 새로 생성해야만 한다. final LottoNumber lottoNumber = new LottoNumber(1); final LottoNumber lottoNumber2 = new LottoNumber(2); } } . | 03 정펙매로 객체 생성을 능동적으로 관리(100% 생성이 아니라 재사용 = 캐싱) . 01 캐싱될 객체는 미리 생성자가 받는 raw파라미터가 제한된 범위로 예외처리 되어있다 . public class LottoNumber { private final int value; public LottoNumber(final int value) { // 생성자로 들어오는 재료인 raw파라미터에 대해 // 범위 검증(예외처리)를 해주면, 객체가 -&gt; 제한된 raw값 범위만 가지게 된다. // 제한된 raw값의 범위라면 미리 생성해두는 캐싱이 가능하다. if (value &lt; 1 || value &gt; 45) { throw new IllegalArgumentException(); } this.value = value; } } . 02 new키워드가 아니라 정적팩메(Class.of(, ), Class.from())를 사용하고, 정펙매 내부에서 캐싱한다. . 객체 생성을 100% 새로 생성하는 new Class대신 Class.of( , )나 Class.from()으로 생성해보자. . 빨간줄로 public static 정적 메서드 생성 . . | 파라미터명은 value로 수정해놓고 시작 . public static LottoNumber of(final int value) { throw new UnsupportedOperationException(&quot;LottoNumber#of not write.&quot;); } . | . | 03 캐싱은 &lt;외부에서 요청하며 메서드 파라미터로 들어오는 rawType, 현재 내부인 캐슁 객체Class&gt;로 hashMap 제네릭 타입을 결정 + 사이즈를 알면 initialcapacity로 미리 준다. + 정펙매 내부에서 만드는 척만 해서 변수추출 . 변수 블럭에서 적상하면 변수 추출안되니, 편의상 정펙매 내부에서 캐쉬 만드는 척하자 . 외부에서 들어오는 rawType과 동일한 Type으로 key타입을 맞춰줘야 꺼내쓸 수 있다. | . . | . 04 캐싱객체는 private + static final의 싱글톤으로서 상수처럼 미리 빈 map을 초기화해놓는다. . 변수추출로 변수Type이 자동생성되었다면, private static final로 싱글톤 형태의 빈 map을 클래스 변수로 선언하게 한다. . . . public class LottoNumber { private static final int MIN = 1; private static final int MAX = 45; private static final Map&lt;Integer, LottoNumber&gt; cache = new HashMap&lt;&gt;(45); private final int value; . | 05 캐싱의 핵심은 요청이 왔을 때, if없으면 -&gt; 빈 맵에 생성해서 넣고 || 맵에서 그외 꺼내주기인데, hashMap.computeIfAbsent(확인할 key, 없으면key 해당 value자리에 넣어줄 값 생성 Function)을 제공해주므로 없으면 new로 새로 생성 로직만 넣어주면 된다. . . 람다용 Function자리의 변수추천은 map의 keyType에 따라 바껴서 추천된다. Map&lt;Integer, 객체&gt;일 경우 -&gt; integer -&gt; {} 추천 | Map&lt;Long, 객체&gt;일 경우 -&gt; aLong -&gt; {}추천 | . | . public static LottoNumber of(final int value) { // 1. 정펙매로 부터 rawType변수로 요청이 온다. // -&gt; cache에서 없으면 map의 value에 넣어줄 값을 생성하는 람다식 --&gt; 있으면 꺼내주기 // 2. 없을 때, new 생성자로 객체새로 생성하는데, [람다에 쓰이는 변수명은 파라미터와 다르게] 수정만 해주면 된다. // -&gt; i를 눌러주면 알아서 integer -&gt; 로 람다 작성하라고 뜬다. return cache.computeIfAbsent(value, integer -&gt; new LottoNumber(integer)); } . 06 정펙매 사용순간부터는 주생성자 private으로 잠궈주기 . . public으로 남게 되면, 의도했던 능동적 객체관리와 다르게 코드가 돌아갈 수 있다. . 정펙매 사용으로 유도하고 기본생성자를 private로 막고 사용 . | 테스트를 위해 잠시 여기서는 허용 . | . | . 07 최종 필요한 것 정리 . private static final Map&lt;외부생성자로 들어올 rawType, 현재객체Class&gt; cache = new HashMap&lt;&gt; (갯수); . | 정펙매 내부에서 cache.compuateIfAbsent( 외부 key로 꺼낼 raw값, 없으면 key에 해당하는 value로 넣어줄 객체생성해줄 new 생성자 &amp; Function으로 객체 생성) . public class LottoNumber { private static final int MIN = 1; private static final int MAX = 45; private static final Map&lt;Integer, LottoNumber&gt; cache = new HashMap&lt;&gt;(45); . public static LottoNumber of(final int value) { return cache.computeIfAbsent(value, integer -&gt; new LottoNumber(integer)); } . | Q. 생성자 테스트를 위해 기본생성자를 private말고 default로 열어두어도 되나? . 테스트를 위해 생성자를 열어둬야하는데, 클래스 분리를 고려한다. 과하다 싶으면 -&gt; default를 열어주는 case도 있다. | . | . 04 캐싱 객체는 isSameAs로 비교하면 된다. . 메모리 주소까지 같은 것만 True로 나오기 때문에 캐싱된 것인지 검사를 isSameAs로 하면 된다. . @Test void create() { final LottoNumber lottoNumber = new LottoNumber(1); final LottoNumber lottoNumber2 = new LottoNumber(1); // isSameAs: 메모리 주소가 같은지, 오버라이딩된 VO도 같다고 안나옴. 더 엄격한 완전히 같은 객체일 때, True assertThat(lottoNumber).isSameAs(lottoNumber2); // false } . | . 05 삭제도 안되는데 cache? . 01 변수명을 cache -&gt; pool로 바꾸기 . 02 캐쉬 때문에 메모리가 가득찼을 때 GC대상으로 삭제시켜주는 hashMap인 -&gt; WeakHashMap으로 선언 . . private static final Map&lt;Integer, LottoNumber&gt; cache = new WeakHashMap&lt;&gt;(45); . 06 없을 때 생성 이 아니라 미리 만들고 -&gt; 요청시 조회get만? -&gt; static 블록 생기는게 짜증 . . . public class LottoNumber { private static final int MIN = 1; private static final int MAX = 45; private static final Map&lt;Integer, LottoNumber&gt; cache = new WeakHashMap&lt;&gt;(45); // 1. 미리 생성을 위한 static 블럭 static { for (int i = MIN; i &lt;= MAX; i++) { cache.put(i, new LottoNumber(i)); } } private final int value; public LottoNumber(final int value) { if (value &lt; MIN || value &gt; MAX) { throw new IllegalArgumentException(); } this.value = value; } public static LottoNumber of(final int value) { //return cache.computeIfAbsent(value, integer -&gt; new LottoNumber(integer)); // 2. 없으면 생성 과정이 없어지고 오로지 get으로 조회만 return cache.get(value); } } . static으로 인해 코드량도 늘어나서 처음 분석하는데 힘이 들어감. | . 여러 쓰레드에서 접근한다면? -&gt; ConcurrentHashMap + 미리 생성해두는게 좋다 . 참고) 블랙잭 카드 캐싱 . key 2개를 원소로 가지는 클래스를 두고 한다? | . . Map의 key를 String1개로 바꾸고 -&gt; toString()으로 2개를 더해서 key1개로 사용해도 된다 . . . | enum이라면, .name() + ,name()로 스트링으로 더해서 key1개로 만들면 된다. . | . 생성자가 많으면, 응집도가 높고 견고한 클래스가 된다. . 다른Type 추가 정펙매 . . 여러가지 방식으로 제공해주면 클라이언트 입장에서 사용하기 좋은 코드가 된다. | . 대박) 포장이 아닌 다른Type 입력 제공으로 인한 추가 정펙매 제공은 부생성자로서 위에 위치 + convert후 기존 정펙매(=기준 정펙매)를 호출한다. . 01 포장으로 인한 메서드 추가의 상황이라면 -&gt; [새기준 메서드 생성+내용복붙후 처리 완성]후 [기존 rawInput메서드는 포장후 새기준 호출]하도록 변경 . 02 다른Type입력을 위한 생성자/정펙매를 제공한다면 -&gt; 기존 생성자/정펙매가 기준 메서드라 생각하고 내부convert후 호출 . 새 기준 포장하는 파라미터 변화가 아니라 편의를 위해 다른 type의 입력을 제공한다고 치고 빨간줄 생성하자 . . | 포장이 아닐 경우, 다른Type메서드는 기준메서드가 아니다 -&gt; 부 생성자로서 기존생성자보다 위에 + 포장해서 기존생성자=기준메서드로 호출해준다. . . public class LottoNumber { private static final int MIN = 1; private static final int MAX = 45; private static final Map&lt;Integer, LottoNumber&gt; cache = new WeakHashMap&lt;&gt;(45); private final int value; public LottoNumber(final int value) { if (value &lt; MIN || value &gt; MAX) { throw new IllegalArgumentException(); } this.value = value; } //1. 다른Type입력 생성자 -&gt; 부생성자 -&gt; 위치는 [기존생성자=기준생성자]보다 위에 위치한다. public static LottoNumber of(final String value) { //2. convert해서 기존생성자=기준생성자를 호출해준다. return of(Integer.parseInt(value)); } public static LottoNumber of(final int value) { return cache.computeIfAbsent(value, integer -&gt; new LottoNumber(integer)); } } . | 정리) 너무 많은 Type Or 방식의 생성자는 제공하면 문제가 된다. but 일반적으로 생성자는 많은 것이 좋다. . 메서드와 다르게 많이 제공할 수록 좋단다. | . 다른Type 추가 생성자 . 여러 Type의 생성자 제공이라도 인스턴스 변수(상태값) 초기화는 주생성자 1개에서만 -&gt; 나머지는 위에서 주생성자를 convert후 -&gt; 기존 생성자를 this()로 호출만 해주는 부생성자들로 -&gt; 중복을 피하자 . . 자바만 부생성자라는 관례적이 이름이 있다. 무조건 주생성자에서만 인변을 초기화 하기 위해 관례적으로 지은 이름 | . | 다른언어는 무조건 주 생성자를 이용해서만 호출하도록 지원하는 것이 많다. | . 01 다른Type의 생성자 추가는 부생성자로서 convert후 this()로 주생성자를 호출해야한다. -&gt; 직접 주생성자의 역할인 인스턴스변수 초기화를 해주면 안된다 . 직접 주생성자의 역할인 인스턴스변수 초기화를 해주면 안된다. | . . . 02 다른Type용 생성자 -&gt; 부생성자 -&gt; 주생성자 위에 정의 + convert후 this로 주생성자호출-&gt; convert후 원래Type의 주생성자 코드(검증후 인변 초기화)를 반복하지마라. . 위치를 주생성자보다 위로 올려준다. . . | 대부분 다른 Type 으로서 String을 받아주므로 rawInput에 해당하는 rawValue로 네이밍 해보자. . //부 : rawValue public LottoNumber(final String rawValue) { //주 : value public LottoNumber(final int value) { . | convert만 하고, 원래Type이 했던 검증+ 인변 초기화해주면 똑같이 해주면 코드 중복이다. . 코드중복 = 나쁜 예 . | 생성자 내부코드는 주생성자를 호출해서 인스턴스 변수 초기화의 중복 = 코드 중복을 막자. . public LottoNumber(final String rawValue) { this(Integer.parseInt(rawValue)); } . . | . | 정리) 생성자 코드 중복 in 부생성자 -&gt; 인수 늘어날 때, 코드 변경될 때 -&gt; 모든 부생성자까지 다 초기화 해줘야한다 -&gt; 그러니 convert후 this() 주생성자를 호출해주자. . 주 생성자는 객체 초기화 프로세스의 유일한 장소 -&gt; 추가 생성자에서 초기화 하지말자 | . 상속 . . 상속 잘 사용 하기 (부작용이 크니까) . 상속은 나쁜 것이다? 고민을 해봐야한다. 내가 쓰레기처럼 쓰는 것은 아닌지.. | 스프링에서도 상속을 잘 쓴다. | . | . 상속 부작용 . 부모 변화(탑레벨 클래스 기능 변경) -&gt; 자식 모두 수정(하위 클래스 모두 변경) 안좋은 결합도가 높아짐. | 나쁜 것도 물려준다. 선택이 없다. | . | . 부-&gt;자로 상속되서 사용되는 변수/메서드는 부모 내부에서 정의되어 사용되는 메서드라도 자식에 오버라이딩된 메서드부터 찾는다. -&gt; 오버라이딩 전 메서드를 호출하는 방법이 없다? . 동일한 형태, 구조를 가질 예정이므로 is-a에 해당하여 상속을 했다. cf) has-a구조라면 조합을 사용한다. | . | 합리적으로 보이지만, 자식이 물려받고 오버라이딩 안한 length()호출시 부모 content()? 자식오버라이딩한 content() 어느것이 호출될까 자식에서 호출했으면 오버라이딩 된 것이 호출된다. | . | 사용하는 클라이언트는 구현안한 메서드라면, 내부 호출도 부모 것만 원할 수 도 있다. 따로 구현안하고 물려받은 메서드를 호출한다면, 내부에서도 부모 것만 사용하도록 원할 수 도 있다. | . | . 상속 문제점 예제 만들어보기 . 객체List 일급컬렉션( 포장 ) 요구사항이 없었다면? 컬렉션&lt;객체Type&gt;를 상속해서 컬렉션메서드의 기능을 다사용하도록 했다. . 객체List는 일급컬렉션으로 포장했었다. . public class LottoNumbers { private final List&lt;LottoNumber&gt; value; } . | 예전에는 extends 컬렉션&lt;원소Type&gt;을 통해 클래스를 생성했다. . . | 사용과 생성은 c+s+t로 지정한 go to test로 가서 생성하고 테스트하자. . . | 문제01) 부모인 컬렉션 기능 다 사용되서 좋아보이지만, 위험한+필요없는 기능들도 강제로 제공된다. . . 찍어보면 사용하지 필요없는 기능들도 다 물려받는다. . | 위험한 기능도 다 받은 상태라 클라이언트에도 노출되서 위험하다 . | . 문제02) 부모 물려받은 메서드에 오버라이딩해서 super.메서드()로 쓰고 있지만, 그 메서드의 내부 작동방식을 모른다 -&gt; add기능추가 후 addAll 기능추가 시 의도와 다르게 작동 . 02-1 가장 원초적인 super.메서드() ex&gt; .add() 의 경우, 기능을 추가해도 문제가 없다 . 오버라이딩부터 한다. . 선택할 메서드가 너무 많으면 add 를 검색하면 된다 . . | . | 부모에서 물려받은 것(super생략가능)을 쓰기 전에, 누적하는 기능 -&gt; 매 인스턴스마다 상태값을 누적할 인스턴스 변수도 필요하다. . 누적전에 0으로 초기화해야할텐데, int는 기본적으로 0으로 초기화 해준다. | . . . | 내부 상태값을 얻기 위해서 getter가 필요하다. . 이것도 generate 띄운 상태에서 검색으로 빠르게 생성할 수 있다. . . | . | public class LottoNumbers extends HashSet&lt;LottoNumber&gt; { private int addCount; @Override public boolean add(final LottoNumber lottoNumber) { addCount ++; return super.add(lottoNumber); } public int getAddCount() { return addCount; } } . class LottoNumbersTest { @Test void add() { final LottoNumbers lottoNumbers = new LottoNumbers(); lottoNumbers.add(LottoNumber.of(1)); lottoNumbers.add(LottoNumber.of(2)); lottoNumbers.add(LottoNumber.of(3)); lottoNumbers.add(LottoNumber.of(4)); lottoNumbers.add(LottoNumber.of(5)); lottoNumbers.add(LottoNumber.of(6)); assertThat(lottoNumbers.getAddCount()).isEqualTo(6); } } . 02-2 내부에서 add()를 사용하고 있는지도 모르고, addAll()를 오버라이딩 + 기능 추가하면 -&gt; 기능이 2배로 추가 된다. . addAll()을 호출하는 테스트를 만들어보자. . 새 자료구조 ex&gt; Set, List를 만들 땐 .of를 쓴다.** . | addAll()은 가변인자에 원소가 아니라 같은 자료구조의 묶음은 add한다. . ex&gt; 빈 셋 -&gt; 빈셋.addAll( 셋묶음 ) | . | 위에서 add로 여러번 선언한 것들 중 인자들만 복사해서, 활용할 수 있다. . @Test void addAll() { final LottoNumbers lottoNumbers = new LottoNumbers(); lottoNumbers.addAll(Set.of( LottoNumber.of(1), LottoNumber.of(2), LottoNumber.of(3), LottoNumber.of(4), LottoNumber.of(5), LottoNumber.of(6) )); assertThat(lottoNumbers.getAddCount()).isEqualTo(6); } . | . | addAlll() 갯수 세는 기능을 추가해보자. . Generate띄우고, over라이딩도 검색할 수 있다 . 오버라이딩할 메서드고 검색해서 오버라이딩하자. | . . . | . | add시마다 더해주는 기능을 추가 해보자. . @Override public boolean addAll(final Collection&lt;? extends LottoNumber&gt; c) { //넘어오는 단일객체를 원소로 가지는 Collection의 사이즈를 더해주자 addCount += c.size(); return super.addAll(c); } . | 6개가 더해져야하는데, 12가 나온다. . | 문제02 디버깅) sout로 찍어보기 -&gt; 정상이면 타고 올라가보기 . 디버깅으로서 일단, size가 잘못더해지는지 찍어볼 것이다. . @Override public boolean addAll(final Collection&lt;? extends LottoNumber&gt; c) { addCount += c.size(); System.out.println(&quot;c.size() = &quot; + c.size()); return super.addAll(c); } . . | 더해주는게 정상인데…? 메서드를 직접 까봐야한다. . 컨트롤 클릭으로 타고 올라가기 . . | . | 분석하기 . addAll()은 내부에서 매번 add()를 호출한다. | add()는 추상메서드로서 우리가 오버라이딩=재정의해준 add()가 호출되어, 개별 count기능까지 작동하게 된다. | | . 기본적으로 제공하는 api들 내부작동방식을 모르므로 상속후 기능 추가를 위한 재정의시 조심해서 사용해야하므로 상속을 비추한다. -&gt; 상속 대신 조합-&gt; 포장도.. 조합?! . 상속을 제거하고 기존 클래스(HashSet&lt;객체&gt;)의 인스턴스를 -&gt; 인스턴스 변수로 가지도록 바꾸자. . 필드 선언을 위해 변수추출부터 하고 싶다면 메서드 내부로 잠시 이동해서 하자 . . | 필드의 자료형은 shift+tab으로 앞으로 넘어와서 다형성을 적용시켜서 완성하자 . . | private가 아닌 메서드에서 선언했다면 접근제한자도 확인을 해주자. . . | 다시 필드 선언부로 가지고 오자. . | . | 상속에서 기능추가한 오버라이딩삭제 + super.대신 -&gt; value.로 변경해주자. . public class LottoNumbers { private final Set&lt;LottoNumber&gt; value = new HashSet&lt;&gt;(); private int addCount; public boolean add(final LottoNumber lottoNumber) { addCount++; return value.add(lottoNumber); } public boolean addAll(final Collection&lt;? extends LottoNumber&gt; c) { addCount += c.size(); return value.addAll(c); } public int getAddCount() { return addCount; } } . | 참고-&gt; .add()의 결과로는 boolean을 반환한다 -&gt; 호출시마다 if를 달아서 실패시 예외내야하는 건 아닌가? . 실패하는 케이스가 거의 없다 -&gt; 응답할 필요 없다. -&gt; 잘못 설계된 것으로 추정된다. capacity가 정해져있어도 내부적으로 resizing해서 실패를 안함. | . | . | 참고) super -&gt; 자식이 생성자 재정의할라고 갖다쓰는 것은 주생성자 쓰는 것처럼 가능하다 -&gt; but 메서드 호출까지 super를 호출한다면, 부모의 구조를 다알아야해서 결합도가 너무 커져 안좋다. . 조합 . 3기 예시 블로그 . 조합 블로그 | 블랙잭에서 조합 적용 블로그 그 사람의 branch -&gt; 적용안하고 인터페이스만 | . | [이펙티브 자바] 추상 클래스보다는 인터페이스를 우선하라 우테코에서 언급 | 인-추(코드중복제거?)-상속 | . | 매트 추상화 글 | 연록조합글 연록 다음 인터페이스와 골격구조 | . | 대놓고 추상-골격구현클래스으로 PR 리뷰 받았다! 젤 참고 | 동기인듯? 코드중복 제거 및 상태를 가지므로 추클이 더 적합 | 인터페이스 &gt; 추클의 옛날 글 | cf) 합성: 조합의 수만큼 클래스로 나누어서 외부에서 주입 어려움 -&gt; 블로그 | . public class Man { public void move() { System.out.println(&quot;걷는다&quot;); } public void eat() { System.out.println(&quot;먹는다&quot;); } } class SuperMan { private final Man man = new Man(); public void move() { man.move(); } public void eat() { man.eat(); } public boolean canTouchKryptonite(){ return false; } public void fly() { System.out.println(&quot;날아간다.&quot;); } } // 다형성을 위해서는 인터페이스나, 추상 클래스를 이용한 구현을 고려해보자. // 상속을 기능의 재활용보다는, 정제를 위해 사용하자! // 이런 경우에는 상속을 고려해보자. // 코드 재사용을 주목적으로 하기보다는 확장성, 유연성을 고려해야할때 // IS-A 관계가 명확할때 // 부모 메소드에 이미 구현된 내용이 절대 바뀌지 않는다고 확신이 들때 . | . . 상속은 is-a관계가 기본 조건(모두 내려받아야하고+내용변경만 재정의용) -&gt; 재사용성 . 앞서 예제인 Document도 완전 동일한 is-a관계지만, 상황에 따라 상속시 원하지 않는 결과를 가져올 수 있다. . | 더군다나 모두 받을 필요 없거나 + 더 추가될 기능이 있다면 상속은 포기해야한다. . . | . 안받아도 되거나 추가될 기능이 존재한다면, 상속은 ㅂㅂ2 extends는 확장개념이 아니라 refine개념(is-a로 일치하면서 일부만 바꿔쓰기용) . . 과거에, OOP 처음 나왔을 때는 재사용성 -&gt; 상속받아서 필요한 부분만 변경해서 쓰자.의 개념이었다. | 지금은 부작용이 많은 설계법 -&gt; 현대는 유연성이 더 중요 | . 추가 얘기거리 -&gt; class 생성자 final or abstract를 붙이자 . . . . 테스트를 위해 interface를 쓸 수 있다. 추상메서드 1개 -&gt; 바깥에서 람다로 구현 가능 -&gt; 테스트에서 람다로 추상메서드까지 구현 | 추상클래스도 가능?? -&gt; 가능해진다. 하지만 람다=익클처럼 사용이 오히려 부작용으로 작용한다. | . | 상속을 염두에 안두었다면 final을 붙여서 class를 설계하라. final을 붙여서 상속안되게 해라. | . | 최소 1곳 이상을 개별 구현해야하는 추상화된 메서드를 포함하고 is-a관계로 개별구현 빼고는 기능이 모두 똑같아서 상속해야하는 class라면 abstract 붙여서 설계해라. 추메 1개면 인터페이스로 가고 -&gt; 익클,람다,테스트가 가능한 것이 된다. | 추메 + @(상태or공통메서드)로 메서드 2개 이상이면 abstract를 붙혀 is-a관계의 상속만 가져갈 예정이라고 생각하자 | 일부자식이 추메를 기능 구현 안할라면 -&gt; 추상클래스로 만들지 말자 | . | . is-a의 abstract 상속 클래스에 -&gt; 일부자식만 새로운 기능추가의 확장 포인트가 생겨 필요하다? -&gt; final을 풀지말고 포장으로 확장해서 사용하면 된다 . class를 final class로 막아뒀다. -&gt; 상속 및 재정의가 불가능하다. . public final class LottoNumbers { private final Set&lt;LottoNumber&gt; value = new HashSet&lt;&gt;(); . | 기능을 추가해서 확장해야하는 경우가 생긴다면 -&gt; 기존 상속은 건들지말아야함. . | 자식들 모두 공통메서드 or 각각 모두 개별구현 가능이 아니라면 -&gt; 포장하는클래스를 파고 내부에서 확장하자 . | 좀더 세부적이고 확장된 이름으로 포장 클래스를 파서 확장하는 조합개념을 쓴다. . . 확장하고 싶은 클래스의 인스턴스를 인스턴스 변수로 가지게 한다. . public class SomeLottoNumbers { private LottoNumber lottoNumber; } . | . | 불변 일급컬렉션의 증감메서드 . VO처럼, 불변 일급컬렉션이라면 VO.증감() -&gt; 새객체 응답처럼 컬렉션.add/remove호출()시 가변 가능한 new 새컬랙션&lt;&gt;()을 복사한 새 컬렉션를 응답해줘야한다. . 기존 add: 기존 내부 포장 컬렉션에 add후 증감은 -&gt; 내부증감처리후 노응답 . public final class LottoNumbers { private final Set&lt;LottoNumber&gt; value = new HashSet&lt;&gt;(); public boolean add(final LottoNumber lottoNumber) { return value.add(lottoNumber); } } . | . 01 컬렉션의 add/remove()메소드를 호출받는 일급컬렉션 객체로 그대로 응답되어야한다. . 원래 add/remove boolean 응답 하나 사용안함 | . . public final class LottoNumbers { private final Set&lt;LottoNumber&gt; value = new HashSet&lt;&gt;(); //1. add/remove등 컬렉션의 증감호출시 -&gt; 응답이 일급컬렉션 자신이어야한다.(원래 add/remove boolean응답하나 사용안함) public LottoNumbers add(final LottoNumber lottoNumber) { return value.add(lottoNumber); } } . 02 가변 컬렉션을 new 키워드로 복사해준다 . . . 03 복사한 컬렉션에 add/remove등 컬렉션 증감해준다 . . 04 증감된 복사컬렉션으로 새 일급컬렉션을 만들어서 반환한다. -&gt; 생성자 필요 . . 05 대박) 재료(인자)에 의해 일급컬렉션에 [재료(컬렉션) 파라미터 생성자만 최초]로 생긴다면 그것을 주생성자로 -&gt; 파라미터 없이 내부 빈컬랙션으로 초기화 with this()의 부생성자도 같이 만들어주자. -&gt; 멋도 모르고 과거에 테코 등에서 쓴 기본생성자 = 주생성자this()를 이용한 빈 컬렉션으로 초기화 넣어주는 부생성자 . 필요에 의해 컬렉션을 재료로 받는 생성자가 생겼다. . . | 파라미터 받아 초기화 해주는 생성자가 생겨나는 순간, 인변의 선언과 동시에 초기화는 무용지물이 된다. . . | 기존 외부 인자(재료)없이 빈컬렉션으로 초기화하는 일급컬렉션의 사용이 에러가 난다. . 재료 사용 생성자가 주생성자 . | 처음에 멋도 모르고 쓴 것이 부생성자 . . | . | generate -&gt; construct -&gt; Select None으로 빠르게 파라미터 없는 빈 기본생성자를 생성해준다. . . . . . . | 재료받는 주생성자 this를 활용해서, 초기화용 빈 컬렉션을 주생성자의 재료에 넣어준다. . | 인변을 직접 초기화 해줬던 부분을 삭제한다. . | 05 원소 추가시마다 새 가변 컬렉션이 복사 후 add한 뒤 새 일급컬렉션 객체가 반환되므로 호출부에서는 원소추가/제거 메서드 호출후 다시 할당해야된다. -&gt; 확인은 .size()를 추가 정의해줘서 확인하면 된다. . VO의 경우 count +=1; -&gt; Count count = 는 호출부 그대로 두고 -&gt; +1의 증감부분에 새객체 반환 | . | 일급컬렉션의 경우 .add(원소) -&gt; 일급형 일급 = 는 호출부로 두고 -&gt; .add(원소)의 원소추가제거 부분에 복사된 가변 새컬렉션에 add해서 반환 | . | . public final class LottoNumbers { private Set&lt;LottoNumber&gt; value; public LottoNumbers() { this(new HashSet&lt;&gt;()); } public LottoNumbers(final Set&lt;LottoNumber&gt; value) { this.value = value; } public LottoNumbers add(final LottoNumber lottoNumber) { final Set&lt;LottoNumber&gt; lottoNumbers = new HashSet&lt;&gt;(value); lottoNumbers.add(lottoNumber); return new LottoNumbers(lottoNumbers); } } . 이제부터 일급컬렉션의 add는 새 일급 객체를 응답하므로 -&gt; 호출부에서는 할당으로 받아줘야한다. . 기존: 기존 내부값이 변했음 . | 불변: 변화된 새 컬렉션이 응답된다. -&gt; 기존값 변화가 아니라 새로 생기므로 1 변수에서 받아줘야한다. . . . | . | getter후 .size()때리지말고, .size()를 정의해서 사용하다가 필요없으면 지우자 . . | . void add() { LottoNumbers lottoNumbers = new LottoNumbers(); // lottoNumbers = lottoNumbers.add(LottoNumber.of(1)); lottoNumbers = lottoNumbers.add(LottoNumber.of(2)); lottoNumbers = lottoNumbers.add(LottoNumber.of(3)); lottoNumbers = lottoNumbers.add(LottoNumber.of(4)); lottoNumbers = lottoNumbers.add(LottoNumber.of(5)); lottoNumbers = lottoNumbers.add(LottoNumber.of(6)); assertThat(lottoNumbers.size()).isEqualTo(6); } . (변화 전 기존 객체의)불변 일급컬렉션의 장점 정리 . 기존 객체의 변화가 아니라 불변을 유지하면서 새로운 객체로 응답 한번 생성한 객체는 불변하며, 변화를 요구시 새로운 객체가 반환된다. | 기존 객체는 불변유지로 안전하다. | . | 그로 인해 final 사용할 때 처럼 동일하게 안정화된다. . 반대로 가변 객체는 여러 클래스에서 동시 접근(시간처 접근)시 굉장히 불안하다 . 다른데서 중간에 접근해서 내부값을 변화시키면, 또다른 곳에선 변화된 객체가 반영된다. | 포장(포인터의 포인터)은 업데이트 상태를 반영해주지만, 동시 접근시 불안해지니 기존 객체는 불변으로 접근 한곳에서는 복사본을 이용한 새 객체를 제공해준다. | . | 기존객체만 불면이고 호출시 복사된 새 객체를 제공해주니 DTO처럼 view에 막 던져도 안정적이다 . 건들이고 싶어도 기존 객체는 불변이라 못건들이게 되니 -&gt; view에서도 복사된 가변 새컬렉션을 새 객체로 넘겨주면 된다. | . | 불변객체를 map의 key로 사용하게 될 경우 식별자 변경의 문제가 발생하지 않는다. . key로 사용하는 객체는 불변객체여야한다. | . . | 도중에 실패하는 경우, 일부만 달라질 수 있다. -&gt; 기존 객체는 불변을 유지하게 해줘서 그런 문제(실패 원자성)를 막자. . | |",
            "url": "blog.chojaeseong.com/java/%EC%A0%95%EC%A0%81%ED%8C%A9%ED%86%A0%EB%A6%AC%EB%A9%94%EC%84%9C%EB%93%9C/%EC%BA%90%EC%8B%B1/cache/%EC%83%81%EC%86%8D/%EB%B6%88%EB%B3%80%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/20/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%8B%AC%ED%99%94.html",
            "relUrl": "/java/%EC%A0%95%EC%A0%81%ED%8C%A9%ED%86%A0%EB%A6%AC%EB%A9%94%EC%84%9C%EB%93%9C/%EC%BA%90%EC%8B%B1/cache/%EC%83%81%EC%86%8D/%EB%B6%88%EB%B3%80%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/20/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%8B%AC%ED%99%94.html",
            "date": " • Mar 20, 2022"
        }
        
    
  
    
        ,"post26": {
            "title": "jupyter nbextension & toggle",
            "content": "nbextension 설치 . 관리자 권한으로 터미널 열기 . | 아래 커맨드 2개 치기 pip install jupyter_contrib_nbextensions . jupyter contrib nbextension install . | jupyter notebook 실행 후 [체크해제] disable configuration for nbextensions | Table of Contents 선택 | | jupyter용 toggle code . 클릭으로 토글할 수 있게 된다. from IPython.core.display import HTML display( HTML(&#39;&#39;&#39;&lt;script&gt; code_show=true; function code_toggle() { if (code_show){ $(&#39;div.input&#39;).hide(); } else { $(&#39;div.input&#39;).show(); } code_show = !code_show } $( document ).ready(code_toggle); &lt;/script&gt; &lt;form action=&quot;javascript:code_toggle()&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Click here to toggle on/off the raw code.&quot;&gt;&lt;/form&gt;&#39;&#39;&#39;) ) . | . 브라우저 지정(크롬 안될 경우) . cmd에서 config 파일 생성 jupyter notebook --generate-config . | 생성된 jupyter_notebook_config.py의 경로로 가서 열고, .browser 검색하여 아래처럼 수정 #c.NotebookApp.browser로 되어있는 주석을 풀고 windows10 크롬경로 + %s를 입력해주고 재시작 c.NotebookApp.browser = &#39;C:/Program Files (x86)/Google/Chrome/Application/chrome.exe %s&#39; . | 참고) 크롬을 기본 브라우저로 지정 . 크롬 열기 -&gt; 우측상단에 점점점 -&gt; 설정 | 내리다 보면 기본 브라우저 -&gt; 크롬으로 변경 |",
            "url": "blog.chojaeseong.com/configuration/jupyter/toc/nbextension/toggle/settings/2022/03/19/jupter_notebook_toc_setting.html",
            "relUrl": "/configuration/jupyter/toc/nbextension/toggle/settings/2022/03/19/jupter_notebook_toc_setting.html",
            "date": " • Mar 19, 2022"
        }
        
    
  
    
        ,"post27": {
            "title": "03 Measures of Association",
            "content": "상관관계를 제는 측도와 바이어스 위험요소 &lt;-&gt; 질병간의 상관관계는 산점도로 나오는게 아니다 | risk개념을 알고 -&gt; RR/OR을 통해서 상관관계를 젠다 | . | . &#47785;&#52264; . Absolute risk | RR(Relative risk) &amp; OR(odds ratio) | Attributable risk | Bias | 상관관계를 제기 위해서는 Absolute risk 및 이와 비교하는 메져(RR(Relative risk) &amp; OR(odds ratio), Attributable risk)들이 필요하게 된다. | bias: 상관관계 및 인과관계를 추론할 때 쓰이는 3가지 개념 중 첫번째 개념이다. 나머지 2 개념은 다음시간에 알아본다. | . | . Absolute risk . incidence(특정기간, 인구집단내, 새롭게 질병발생, 환자 비율)와 비슷한 개념이다. 비율이라 보통 1000명당, 10만명당 으로 표현된다. | . | Absolute risk: 말그대로 질병이 발생할 0~1사이의 확률 incidence와 비슷해보이나 incidence: 확률에 x (단위)명당 개념 -&gt; 주로 양수? vs Absolute risk: 0~1사이의 확률 | 줄여서 Risk라고도 하니 Risk는 질병발생 확률(0~1사이)이다라고 생각하자 | incidence와 달리 특정기간이 없이 생략되기도 한다. risk도 기간을 명시하는게 원칙이긴 하지만 생략됨. 예) &quot;어떤 위험에 노출된 이후 -&gt; 3년내 이 질병이 발생할 리스크(확률)&quot; -&gt; 3년내 가 생략된다 특정기간이 없는 리스크는 시간을 따지지 않고, 아무리 오래걸리더라도 1번이라도 발생될 확률로 해석 하면 된다. | . | . | 근본적으로 같은 개념이다. incidence의 몇명당의 개념 때문에 단위가 차이나 보일 뿐 예) &quot;어떤 집단에서 어떤 질병의 risk가 0.003이다&quot; risk는 0.003으로 0~1사이 확률이지만 | 1000명당으로 보고 X 1000 하면 양수 3이 된다. -&gt; incidence는 1000명당 3명이다. | . | incidence = risk X 단위사람 수로 생각하면 된다. | . | . | . . Absolute risk &#44228;&#49328; &#50696;&#51228; . 위험요소 - 질병에 대한 Risk를 계산하기 위해서는 위험요소 노출시 risk(확률) | 위험요소 노출X시 risk(확률) 2CASE를 각각 구해서 비교한다 | . | 흡연자 1000 | 비흡연자 1000명 각각 찾아서, 10년간 FU(팔로우업)해서, CHD(관상동맥질환) 발생여부를 조사했다 흡연자 1000명 중 28명 CHD 발병 -&gt; 흡연자의 Absolute risk(확률) = 28/1000 = 0.028 | 비흡연자 1000명 중 17명 CHD 발병 -&gt; 비흡연자의 Absolute risk(확률) = 17/1000 = 0.017 | . | . &#51656;&#48337;&#44284; &#50948;&#54744;&#50836;&#49548;&#51032; &#49345;&#44288;&#44288;&#44228; &#44228;&#49328;&#51012; &#50948;&#54620; Risk&#48708;&#44368; . 위험요소와 질병의 상관관계를 조사한다? == 위험요소 노출 -&gt; 질병 Risk vs 위험요소 노출X -&gt; 질병Risk 각각 구해서 비교해야한다. | 위험요소의 (O/X) 2Case 모두에 대해 -&gt; 질병 발생여부(O/X)를 조사 -&gt; 각각의 Risk(확률) 계산 -&gt; 비교를 해야한다 흡연자(위험요소 노출)의 CHD(질병) 발생여부를 통한 Risk계산 | 비흡연자(위험요소 노출)의 CHD(질병) 발생여부를 통한 Risk계산 | . | . | 위-질 상관관계를 위한 -&gt; 위험요소 노출 Risk vs 위험요소 노출X Risk의 2case Risk비교 -&gt; 2가지 비교법이 있다. 상대적 비교 relative risk (RR) = risk ratio | odds ratio (OR) | | 절대적 비교 risk difference (RD) = attributable risk(역학) | | | . . RR &amp; OR . 질병과 위험요소의 상관관계를 위한 상대적 risk비교 | 임상paper에서 rr보다 OR이 더 자주 등장한다. OR은 몇이고, 해석을 하면 어떻다 | OR을 설명해보라고 하면 잘 못하는 사람들이 많다. | . | 이번 강의에서는 개념을 읽히고, 다음 강의에서는 스터디별로 계산법을 배운다. | . Relative risk (RR) . RR: (분자:)위험요소 노출 됬을 때 질병발생확률(risk)이 / (분모:)위험요소 노출X일때 질병발생확률(risk)의 몇배인가 -&gt; 노출시 질병발생확률risk가 몇배냐 공식도 단순하다. 위험요소 노출X 질병발생 확률(risk)이 분모 | . | . RR해석 . 1을 기준으로 분자 or 분모 더 큰 것에 집중 RR&gt;1 분자가 더 큰 경우:위험요소 노출 O 일때가 질병발생확률(risk)이 더 높다 -&gt; 노출시 risk 높으면 양의 상관관계가 있다. or 노출X시 risk가 높으면 상관관계 음으로 있다. | RR&lt;1 분모가 더 큰 경우:위험요소 노출 X 일때가 오히려 질병발생확률(risk)이 더 높다 -&gt; 노출안될 시 risk 높으면 음의 상관관계가 있다 반대면 상관관계 없는 것이 아니므로 조심 | . | . | 1이면 노출O, 노출X risk같다 -&gt; 아예 상관관계 없다 | . | RR=1 : 위험요소 노출됬을 때와 / 노출되지 않았을 때의 질병발생확률이 같다 . 위험요소 &lt;-&gt; 질병발생확률(=질병발생여부)와 관계가 별로 없다 | 노출되든 말든 발생확률이 동일하니까 | 랠러티브 리스크가 1에 가깝다 -&gt; 상관관계가 없다 | . | RR&gt;1 : 분자가 더크다 = 위험요소 노출될 때가 질병발생확률(risk)가 더 높다 -&gt; positive association의 관계 | RR&lt;1 : 분모가 더크다 = 위험요소 노출되지 않았을때가 오히려 질병발생확률(risk)가 더 높다 -&gt; negative association, protective effect 최종 해석은 위험요소 노출시 낮아진다로 해석하자 | 반대로 분자인 위험요소 노출 시가 -&gt;질병이 덜 발생한다 -&gt; 위험요소라고 했지만 오히려 반대로 낮춰주는 보호 효과 | . | . . RR &#50696;&#49884; . . 앞에서 Absolute Risk를 구했었다. -&gt; 그냥 risk로서 RR계산시 사용된다. RR은 분자 = 흡연(위험요소 노출)시 risk = 0.028 / 0.17 = 분모 = 비흡연시(위험요소 노출X) risk 로 계산한다 | RR(=1.65) &gt; 1 해석 분자가 더 크다 -&gt; 위험요소 노출시가 질병발생확률(risk)가 더 높다 -&gt; 흡연과 CHD는 양의 상관관계다 | . | RR은 더 큰 위험요소라도 최종적으로는 분자(위험요소 노출기준)기준으로 해석하며 1에서 떨어진 범위의 %만큼 질병 발생 확률(질병 위험)이 % 높/낮다로 해석한다 분자가 크니 = 더 큰 흡연시 1.65에서 65만큼 %를 사용해 -&gt; CHD 위험(질병발생 확률)이 65%만큼 높다 | 분모가 크다 = 더 큰 비흡연시 0.65에서 1에서 35 -&gt; 질병발생확률이 35%만큼 커진다 -&gt; 흡연시 35%만큼 낮아진다 | . | . | . Odds . RR는 위험요소 노출 case에 따른 2개 risk의 비율(분모가 위험요소노출X)였다. | odds ratio는 risk가 아닌 2개 odds의 비율이므로 odds부터구해야한다. odds: 분자 질병발생 확률p(risk)이 / 분모 질병발생 안할 확률(1-risk, 1-p)의 몇배인가 | cf) rr: 위험요소 노출O 질병발생확률 / 위험요소 노출X 질병발생확률의 몇배인가 | . | risk와 odds의 관계 risk: 질병발생 확률(0~1) 그 자체 | odds: 질병발생 확률 risk(p)가 / 질병발생안할 확률 1-risk(1-p)의 몇배인가 risk가 커지면, risk / 1-risk의 odds역시 커지게 된다. | p/1-p(0&lt;=p&lt;=1) 그래프를 보면 or p를 조절해보면 oods의 범위는 0(p작) ~ 무한대 사이 값(p커) | . | . | . Odds ratio(OR) . risk로 odds = risk/1-risk 를 구해놓은 상태에서 RR와 비슷하게 위험요소 노출O/X case를 각각 분자/분모의 기준으로 놓고 odds 2개의 비율로 odds ratio를 구할 수 있다. | odds도 위험여부 노출O / 노출X 2 case를 미리 구해놔야 -&gt; odds ratio를 분자/분모 나눠서 구한다 | . | odds ratio: (분자:)위험요소 노출O 일때의 odds 가 / (분모:)위험요소 노출X 시의 odds의 몇배인가 risk=질병발생확률이 아니라 거기서 나아가 구한 odds가 사용되는 것을 인지하자 | . | . OR 해석: risk대신 odds가 사용된 비율이지만, 상관관계 해석은 비슷하다. 왜냐면 risk와 odds는 비례하기 때문에 OR=1 : 위험요소와 질병 간 상관관계가 없다 분모=분자 같다 -&gt; 위험요소 노출여부와 관계없이 odds가 같다 -&gt; risk도 같다 -&gt; 상관관계 없다 | . | OR＞1 : 위험요소에 노출되면 질병발생확률이 높아진다(positive association) 분자가 크다 -&gt; 위험요소 노출시 odds가 크다 -&gt; odds크면 risk도 같이 커졌다는 말 -&gt; 위험요소-질병 양의 상관관계 | . | OR＜1 : 위험요소에 노출되면 질병발생확률이 낮아진다(negative association, protective effect) 분모가 크다 -&gt; 위험요소 노출 안될시 odds = risk가 크다 -&gt; 위험요소-질병 음의 상관관계다 | 해석 최종은 위험요소 노출시 더 낮아진다로 위험요소노출O로 해석끝낸다 | . | . | . . OR &#49688;&#49885;&#51221;&#47532; . . p1(p서브원): 위험요소 노출시 risk | p0(p서브제로): 위험요소 노출 안될시 risk my) 위험요소 노출여부에 따라 p1/p0로 나눈다 | . | RR = 위험요소 노출여부에 따라 구한 risk 2개 -&gt; 2case risk의 비율 = p1/p0 = 위험요소 노출시 risk는 노출안되시의 몇배인가? | OR = 위험요소 노출여부에 따라 구한 risk 2개로 -&gt; 위험요소 노출여부에 따라 구한 odds 2개를 계산 -&gt; 2case odds의 비율 | . OR(Odds Ratio) &#50696;&#49884; . . 위험요소 노출O/x에 따른 risk 2개(질병발생확률)가 구해졌는지 확인 문제에서 주어져있다. | 각 risk = (위험요소 노출 O 및 X에 대한 새롭게 질병발생자 수 / 인구 수) | . | risk 2개로, 각각(위험요소 노출O 및 X)의 질병odds 2개를 구한다 . 위험요소 노출시 odds = 흡연시 질병(CHD)odds = 흡연시risk / 1-흡연시risk 0.028/(1-0.028) = 0.029 | . | 위험요소 노출X시 odds = 비흡연시 질병(CHD)odds = 비흡연시risk/1 - 비흡연시risk 0.017/(1-0.017) = 0.017 | . | | 질병odds 2개로 위험요소 노출 Odds가 /위험요소노출X Odds의 몇배냐로 나눠서 구한다. . 흡연자 오즈 / 비흡연자오즈 = 0.028 / 0.017 = 1.7 | . | OR해석: 혹시 1보다 작아도 결국엔 분자 위주로 해석(위험요소 노출시 질병발생여부는 n배) . OR &gt; 1.7: 흡연을 하면, 안할경우 비해, CHD Odds가 1.7배이다 흡연을 하면, 안할경우 비해, (1보다 멀어진만큼인 0.7을 보고) CHD odds가 70% 더 높다 | . | . | RR vs. OR . 랠러티브 리스크(RR)은 해석이 직관적이다 -&gt; 질병 발생 확률(0~1)의 (위험요소 노출에 대한 O/X)비율이니까(위험노출시 몇배 더 발생하냐?) -&gt; 이해가 잘된다 | 그러나 스터디 종류에 따라서 추정이 불가능한 경우가 있다. 즉, bias없는 추정치를, 얻을 수가 없는 경우가 있다. | 예를 들어, case-control study가 그렇다. | . | . | 오즈 레이시오(OR)은 질병 발생 확률의 비율(몇배?)가 아니라 오즈라는 개념을 한번 더 이용해야하므로 직관적으로 와닿지 않고 해석이 어렵다 | 그런데도 불구하고, OR이 훨씬 더 많이 임상논문에서 사용/보고된다. OR은 수학적으로 굉장히 좋은 성질을 가지기 때문 매쓰매틱스 미라클 현상을 보여주기도 하고, 어려운 수학문제를 간단하게 만들어주는 성질이 있다. | case-control 같은 경우도, RR 추정자체가 불가능한데, OR은 추정할 수 있다. | 즉, 스터디 종류를 타지 않고 다 사용된다 | . | . | . | 다행인 점은 질병발생 확률(risk)가 작은 경우에는 RR==OR이 비슷한 성질이 있다. 예시도 RR = OR처럼 나왔다. risk가 너무 작은 값인데, 소수2까지 반올림하니 같아졌음. | 아주 흔한 질병인 고혈압, 당뇨가 아닌 경우라면,대부분의 질병이 질병발생 확률(risk)이 낮다. == 스터디 디자인 때문에 RR이 추정되지 않아도 OR을 쓰면 된다. | . | 공식에서 보면, Odds = p1/1-p1 or p0/1-p0에서, p가 아주 작아진다면 -&gt; 분모는 1에 가까워지고 -&gt; 값 자체는 p1 or p0로서 risk에 가까워진다. | . | . . Attributable Risk . 위험노출된 개개인(흡연자)에 인터벤션(금연보조제) 작동시, 얼만큼의 질병risk감소 효과가 있을까?라는 질문에 대한 답을 AR(e)로 구한다. . 위험노출된 개개인(흡연자)에 인터벤션(금연보조제) 작동시, 얼만큼의 질병risk감소 효과가 있을까? | 위험노출된 개개인(흡연자)에 인터벤션(금연보조제) 작동시, 얼만큼의 질병risk감소 효과가 있을까? | 위험노출된 개개인(흡연자)에 인터벤션(금연보조제) 작동시, 얼만큼의 질병risk감소 효과가 있을까? | . | risk비교 중에 위험요소 노출o/x 집단간 상대적 비교가 아니라 절대적 비교 메저다 . | 예를 들어 인터벤션을 1개 생각해보자. ex&gt; 금연보조제(intervention) . &quot;금연보조제는 -&gt; 흡연 - CHD위험을 얼마나 줄일 수 있을까?&quot; &quot;흡연하던 사람이, 금연을 하면, CHD위험이 얼마나 줄어들까?&quot;와 같은 질문이다. | . | 즉, intervention으로 위험요소 노출 -&gt; 노출X의 상황으로 만들었을 때, 질병위험을 보는 것이다. | . | . 일단 인터벤션 작용 전에 위험요소(흡연자)-질병(CHD)위험의 구성 모델을 쪼개서 생각해본다. 흡연자 - CHD위험: background 질병risk + 흡연 때문에 증가하는 질병risk 위험요소 노출(흡연)과 관계없는 background risk도 있다. | 여기에 위험요소 노출을 통해 risk를 더 올린다. | . | . | 인터벤션 금연보조제이 작용해서 risk를 줄일 수 있는 부분은 흡연 때문에 증가하는 질병risk부분만 해당한다. 금연보조제로 금연을 하더라도, background risk는 줄이지 못한다. | . | . 다시 정리해보면, 위험요소에 노출된 사람의 질병위험 = . background risk(노출되지 않은 사람의 질병위험) 밑에 그래프에서 오른쪽 초록색 부분 | . | 위험요소 노출 때문에 증가하는 risk 위험요소 노출 질병위험은 = background가 기본으로 있고 + 위험요소노출 때문에 background에서 추가로 떠안은 질병위험을 더 떠안게 된다. | . | | 인터벤션으로 줄일 수 있는 risk = 위험요소 노출 때문에 background risk에 추가로 떠안은(증가된) 질병위험 부분이다. . = 위험요소 노출된 사람의 (전체)질병위험 - background risk(노출되지 않은 사람의 질병위험) | = 예방을 통해 달성할 수 있는 포텐셜 | . | my) 위험요소 노출 risk != 위험요소 노출 때문에 증가된(background에서 추가된) risk | my) background risk = (말은)위험요소에 노출되지 않은 경우의 risk = (뜻은) 위험요소 때문에 증가한게 아니라 원래 가지고 있는 risk | . Attributable risk (among the exposed) = ARe = risk difference (RD) . Attributable risk는 아래 개념 때문에 등장한 개념이다. . 위험요소 노출된 사람의 (전체)질병위험 - background risk(말은, 노출되지 않은(노출과 상관없이 가지는?) 사람의 질병위험) | . | among the exposed는 노출된 사람에 한하여 Attributable risk를 계산한 다는 것이다. . 그렇다면, 교재의 위험요소에 노출되지 않은 사람의 질병위험 = 노출여부에 상관없이 background로 가지는 질병위험이라는 뜻이겠다. | among the exposed가 안붙는 Attributable risk도 뒤에 다룰 것이다. | . | ARe(xposed) = RD(Risk Diferrence) = . 위험요소에 노출된 경우의 질병발생확률 - 위험요소에 노출되지 않은 경우의 질병발생확률 이라고 표기하지만 | . | 위험요소 노출된 경우 risk(default background risk 포함된 전체risk) - 위험요소 노출되지 않은 경우 risk(background risk) | = 위험요소 때문에 (background risk에)추가적으로 떠안게 된 risk | . | . Attributable risk fraction (among the exposed) = AFe . ARe = 위험요소 노출 때문에 (background risk에)추가적으로 떠안게 된 risk자체를 report하기도 하지만 | AFe로서 ARe / 위험요소 노출된 경우 risk(default background risk 포함된 전체risk)를 나눠서(전체 중 일부를 나누는 것) . (bg risk포함)위험요소 노출 전체 risk 중 위험요소 노출 때문에 추가적으로 떠안게 된 risk는 전체 중 몇%를 차지하는 가를 의미하는 것을 사용하기도 한다 | . | 예를 들면, 흡연자로서 가지고 있는 전체 CHD risk 중 흡연 때문에 떠안은(증가된 risk는 몇프로를 떠안은 것인가 -&gt; AFe로 계산한다 . | . . AR, AF &#49688;&#49885; &#51221;&#47532; . . ARe = RD로서 risk차이 = 전체risk - backround risk로 계산 . 뭐야.. 전체 risk라고 생각했던 것이 위험노출시 risk = p1이고 | background risk는.. 진짜 위험노출 안됬을 때의 risk= p0였네... 까고보면,, p1 = p0(background risk) + @(추가로 떠안은risk)겠지? | 일단 background risk = p0로 계산하는 것을 외워두자. | . | . | AFe = ARe=RD=risk차이=p1-p0로 계산 해놓은 상태에서 . ARe / p1로 p1자체를 전체risk로 생각하고 나눈다 | (p1-p0)/p1 | 해석: 전체인 p1 중에 attributable risk가 몇프로를 차지하는가? | . | . Attributable risk &#50696;&#49884; . 구하고자 하는 것은: 흡연 때문에 증가한 Attributable risk = ARe = RD = risk차이 = 흡연 때문에 떠안은 risk 및 전체 risk에서 그 것의 비율(%) = AFe = ARe/p1 | . . risk 2개를 구한다. 흡연(위험노출): 28/1000 = 0.028 (p1 = 전체risk) | 비흡연(위험노출X): 17/1000 = 0.017 (p0 = background risk) | . | risk 2개의 차이(p1-p0)가 ARe(RD)다 ARe = 0.028 - 0.017 = 0.011 | . | ARe(RD)를 전체risk(backgroud + RD)를 의미하는 p1으로 나눠 위험요소로 인해 떠안은(증가한) risk는 전체risk의 몇퍼를 차지하는지를 AFe를 구해서 본다. AFe = ARe / p1(전체risk) = 0.011 / 0.028 = 0.392 -&gt; 39% | . | 해석:ARe, AFe는 인터벤션이 작동하여 위험요소 노출O-&gt;X가 되면, 감소되는 risk로서 해석하자. ARe, AFe = 절대적 비교 -&gt; 인터벤션이 나타날 차이 | . 흡연자 금연하면 CHD확률이 0.011(ARe)만큼 줄어든다. | 흡연자 금연하면 CHD확률이 39%(AFe*100) 감소한다 | | Attributable risk for the population = ARp or PAR . ARe: 위험노출된 개개인(흡연자)에 인터벤션(금연보조제) 작동시, 얼만큼의 질병risk감소 효과가 있을까? | ARp: 위험노출된 커뮤니티(도시)(의 흡연자들)에 인터벤션(금연보조제, 금연 프로그램들을 시민에 제공) 작동시, 얼만큼의 &lt;도시전체 incidence&gt; 감소 효과가 있을까? 예시:“시청에서 성공적인 금연 프로그램을 제공하면 도시 전체의 CHD incidence는 얼마나 낮아질까?” | . | . 도시 전체의 CHD incidence(risk?)도 개개인처럼 total risk(p1)과 background risk(p0) -&gt; 그로 인해 구하는 위험요소 때문에 떠안은(증가하는) risk개념이 있을 것이다. . 도시 전체의 CHD incidence = background incidence + 흡연 때문에 증가하는 incidence 흡연을 안해도 기본적으로 CHD는 발생한다 = bg incidence가 있다. | . | 흡연 때문에 증가하는 incidence만큼이 시청 금연프로그램(인터벤션)이 줄일 수 있는 risk의 potential이다 | . | 계산시 주의사항: . 도시든 커뮤니티든..간에 모든사람이 위험에 노출되진 않는다. -&gt; 비흡연자가 포함되어 있을 것이다. but 시청 금연 프로그램 = 인터벤션은 위험노출 O(흡연자)에 대해서만 CHD risk를 줄인다. | 즉, 파퓰레이션 = 흡연자 + 비흡연자로 구성되어있다. 만약, all 비흡연자라면 인터벤션인 금연프로그램 효과는 0으로 나올 것이다. | 흡연자가 많았다면, 인터벤션인 금연프로그램 효과가 크게 나올 것임. | . | . | 인구집단 전체(도시, 국가...)의 질병위험 = background risk + 위험요소노출 때문에 증가하는 risk 인구집단 전체의 관점에서 위험요소노출 때문에 증가하는risk = | 인구집단 전체의 질병위험 – 위험요소에 노출되지 않은 사람의 질병위험(bg로 추정) : potential for prevention 달성할 수 있는 예방효과 포텐셜 | . | . | . . ARp or PAR &#44277;&#49885; . ARp= 인구집단 전체 risk - 위험요소에 노출되지 않은 그룹의 질병발생확률(bg로 추정) | AFp= ARp / 인구집단 전체 risk | . . ARp or PAR &#49688;&#49885; &#51221;&#47532; . . ARp를 계산하기 위해서는 추가적으로 r위험요소에 노출된 사람의 비율 in 전체 population을 알아야하며, r을 가중평균하여 total risk(p)를 구한다 . 전체인구 중 r만큼의 사람만 위험요소에 노출 되었다고 가정한다면, | 인구집단 전체risk 계산법은 가중평균(weighted sum)을 이용한다 p = p1*r + p0*(1-r) (노출된사람비율r에 대해 p1의 risk를 가지고 있고~) | . | . | p를 구했으면 p - p0 (전체rist-노출되지X risk(bg))로 ARp를 구한다. . | ARp/p로 AFp를 구한다. | ARp &#50696;&#51228; . . 아까와 같은 예제이지만, 단, 이 국가의 흡연자 비율은 20%에서 r = 0.2이며 ARp에 대한 문제임을 알아채야한다 국가 레벨에서, Attributable Risk와 Attributable Risk Fraction을 구해보자. | . | . r이 얼만지 확인한다. r = 0.2 | . | risk 2개(p1, p0)가 있는지 확인한다. 28 / 1000 = 0.028 | 17 / 1000 = 0.017 | . | risk와 r로 가중평균을 통해 p(total risk in population)를 구한다. p = p1 X r + p0(1-r) = 0.028 X 0.2 + 0.017 X 0.8 = 0.019 (국가전체의 CHD 위험) | . | ARp는 p1-p0가 아니라 p-p0로 구한다. p - p0 = 0.019 - 0.017 = 0.002 | . | AFp는 ARp(p-p0) / p로 구한다 . ARp / p = 0.002 / 0.019 = 0.104 | . | 해석(AR, AF는 인터벤션으로 인해 위험노출X가 된다면, ARp,AFp만큼 risk가 낮아지는 것을 얘기) . 흡연자가 금연하면 국가 전체의 CHD incidence가 1000명당 2명 줄어든다 확률이 0.002 -&gt; 소수3째자리의 확률(risk)은 -&gt; X1000한 뒤 1000명당을 붙인다 | . | 흡연자가 금연하면 국가 전체의 CHD incidence가 10.4% 감소한다 | | RR vs AR, Af&#51032; &#48708;&#44368; &#50696;&#51228; . . 흡연/비흡연자의 10만명당 사망률을 조사했는데, **이것이 계산이 필요한 질병발생확률인 risk가 된다??? 10만명당 사망률을 == 새롭게 질병발생환자수/인구수인 risk를 미리 계산한 것으로 취급한다 사망률도 risk로 사용될 수 있다. | . | . | . 10만명당 사망률을 risk로 취급해서 보는데, 위험요소O/X 이전에, 질병도 2case 상태라서 -&gt; 질병 1개(Lung Caner)를 먼저 선택해서 보자 . 질병 1개에 대해서 위험요소 노출O/X의 RR, OR, AR 등을 해석해야한다 | . | 질병 1개 Lung Caner에 대한 RR은 위험노출O risk가 / 위험노출X risk의 몇배냐 (발생확률의 비율)다. . RR = risk1/risk0을 계산해야하는데, 사망률 == 미리계산된 risk (새롭게발생환자수/인구수)로 보자. 위험요소노출O risk = 흡연자 사망률 = 140 / 100,000 | 위험요소노출O risk = 비흡연자 사망률 = 10 / 100,000 | RR: 140 / 10 = 14(양의 상관관계) | . | . | 질병 1개에 대한RR의 해석: 기본적으로 발생확률이 몇배냐?를 물어면서 1을 기준으로 상관관계 없다(=)/ 양의 상관관계(&gt;1) / 음의 상관관계 or 프로텍트이펙트(&lt;1)의 상관관계로 해석하기 위해 사용된다. . 1에서 떨어진 만큼이며 위험요소O기준으로 최종 해석을 만든다. | (더 큰 분자 = )흡연시 (1에서 떨어진 만큼)140% LungCancer 사망률(원래는 위험)이 높다. | . | 이제 나머지 질병 1개 CHD에 대해서도 RR 계산 및해석한다. . risk -&gt; 사망률로 -&gt; 위험O(흡연): 669/100,000 | 위험X(비흡연): 413/100,000 | RR -&gt; risk1 / risk0 = 사망률1 / 사망률0 = 669 / 413 = 1.6 (양의 상관관계) | RR의 해석 -&gt; 흡연시 60% CHD 사망률이 높다 | | 각 질병순으로 AR(더 간단)을 계산해보자. . AR = 위험O/X의 risk차이 = 사망률차이 = (p아닌 경우) p1-p0 cf) ARp = r로 구하는 전체/위험X의 risk차이 = 사망률차이 = p(by r)-p0 | LungCancer AR: 140 - 10 = 130 | CHD AR: 669 - 413 = 256 | . | | 질병간 RR로 위험요소와의 상관관계 비교 vs 질병간 AR로 실제 값 차이 + 인터벤션적용시 낮아지는 효과 비교를 해석해보자. . RR: 폐암RR(14.0)이 &gt; CHD RR(1.6)보다 훨씬 랠러티브 리스크가 훨씬 크다. 일단 둘다 1보다 크기 때문에 두 질병 모두 흡연과 양의 상관관계가 있다. (RR=1 상관관계없음) | 폐암이 비흡에 비해 흡연의 사망(원랜 질.발)확률이 훨씬 크다. | RR이 크다 = 흡연(위험요소)-질병간 상관관계(양)가 폐암이 CHD 더 크다 흡연과의 상관관계가 폐암 &gt; CHD보다 더 강력하다 | . | . | AR: 폐암AR(130)보다 CHD AR(256)이 AR이 더 크다. AR1-실제 값차이는 흡연으로 인한 10만명당 사망자수가 CHD가 더 많다. | AR2-인벤효과로 낮아질 %는 금연시 10만명당 사망자 수(원래risk) CHD가 더 낮아질 것이다. | | . | RR과 AR의 차이가 나타는 이유? 다른 종류의 메저인 것은 맞는데... . 흡연자 중 폐암으로 사망 보다 &lt; CHD으로 사망하는 수가 훨씬 더 많아서 그렇다.???!!! risk1(p1)이 LungCaner보다 CHD가 압도적으로 많아서 생기는 현상 | my) 질병간 p1의 실제 값차이가 많이 나면 RR비교/AR비교가 달라진다? my) risk의 비율은 LungCander 압도적 -&gt; RR 압도적이나, 절대적인 수가 CHD비에 딸려서... -&gt; AR(risk비율이 아닌 양차이)은 딸린다. | . | . | . | RR, AR을 통해 알 수 있는 정보 RR을 보니, 흡연은 폐암과 관련이 많긴 하겠지만(RR=(risk비율)상관관계) | AR을 보니, 효과적인 인터벤션(금연치료)를 통해 risk(여기선 사망)을 낮출 수 있는 효과는 CHD가 더 많이 낮아춰 -&gt; 효과가 더 좋다(AR=(risk실제갑차이)반대로 인으로 인한 위험노출X가 될 때 risk를 더 줄인다.) 사망 예방효과로서,은 CHD로 인한 사망이 폐암으로 인한 사망보다 더 save될 것이다. | . | . | &#50672;&#49845;&#47928;&#51228;(RR, OR) . 주 3회 이상 운동한 65세 이상 성인은 100명 당 15명에서 당뇨병이 발병하였고, 주 3회 미만으로 운동한 65세 이상 성인은 100명 당 40명에서 당뇨병이 발병하였다고 하자. 다음 중 틀린 설명은? . 주 3회 이상 운동’라는 인자에 대한 당뇨병의 relative risk는 0.375이다. | 주 3회 이상 운동’라는 인자에 대한 당뇨병의 odds ratio는 약 0.26이다. | relative risk가 1보다 작으므로 주 3회 이상 운동하면 당뇨병 발병 확률이 낮아짐을 의미한다. | odds ratio가 0.26이므로 주 3회 이상 운동하면 당뇨병 발병 확률이 74% 감소함을 의미한다. | RR, OR문제라면, . 위험요소 노출O/X를 행으로 주되, RR, OR은 분자가 위험노출여부O이므로 O-&gt;X순으로 행을 만든다. 위의 문제의 경우 언급되는 것을 위험노출여부 O로 본다. 비록... 주3회이상운동으로 노출X인 것 같지만... 노출O로 본다. | . | 그 외 |노출여부| 전체n | 질병여부 O | (Absolute) risk | Odds|순으로 칼럼으로 가지는 테이블(table)을 작성한다. . //table template //노출여부그룹별 n수 + 질병환자수를 각각 줘서, risk를 a/n으로 계산할 경우 |노출여부| 전체n | 질병 O | (Absolute) risk | Odds| |||||| |흡연|n|a| a/n |r1/1-r1| |비흡연|m|b|b/n|r0/1-r0| //노출여부그룹별 risk를 바로주거나, risk소수점을 없애려고 x k 해놓은 경우 |노출여부| k명당 발생자수(risk에 k곱) | (Absolute) risk | Odds| ||||| |흡연|rr1| rr1 / k |r1 / 1-r1| |비흡연|rr0|rr0 / k|r2 / 1-r2| . | . | 노출여부 k명당 발생자수(risk에 k곱) (Absolute) risk Odds . 주3회이상운동 | 15 | 0.15 | 0.176 | . 주3회미만운동 | 40 | 0.40 | 0.666 | . 각 노출여부그룹별 risk 2개 계산 -&gt; odds 2개 계산 -&gt; 분자:위험(여기선 주3회이상운동이 기준이므로 위험o로 본다/분모:위험X로 몇배냐?를 1을 기준으로 1에서 멀어진 만큼 % 줘서 생각한다. . RR: risk1/ risk0 -&gt; 위험노출될 때가 질병발생확률이 몇배냐(비율)? 0.375 | . | OR: odds1/ odds0 -&gt; 위험노출될 때가 발생비율이 몇배냐?(risk랑 비슷?) 0.264 | . | . | 해석: 1 기준으로 위험노출여부O 하면 ~1에서 멀어진 만큼을 %로 주고 %만큼 높다 /낮다를 말하면 된다. . RR:0.375 &lt; 1 : 주3회이상운동(위험노출여부O)하면, 0.625x100 = 62.5%만큼 질병발생확률이 낮아진다 | OR: 0.264 &lt; 1: 주3회이상운동(위험노출여부O)하면, 0.736x100 = 73.6%만큼 당뇨병 발병 odds(!=발병 확률)가 낮아진다 . OR는 risk에서 한 개념 더 간 것이기 때문에 -&gt; 1에서 멀어진 만큼 해당 질병 발병 오즈가 낮/높아지는 것이다. | 해당 질병 발병 확률의 낮/높은 RR이 판단한다. | . | OR 해석 예) 흡연(위험노출여부O)을 하면, 안할경우 비해, (1보다 멀어진만큼인 0.7을 보고) CHD 발병 odds가 1.7 - 1 = 0.70 -&gt; 70% 더 높다 . | . | . 문제는.. OR은 질병발생확률이 아닌 질병발생Odds의 비율차이가 난다는 것으로 알아라는 교훈 | .",
            "url": "blog.chojaeseong.com/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EC%83%81%EA%B4%80%EA%B4%80%EA%B3%84/rr/or/2022/03/19/03-1-Measures-of-Association.html",
            "relUrl": "/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EC%83%81%EA%B4%80%EA%B4%80%EA%B3%84/rr/or/2022/03/19/03-1-Measures-of-Association.html",
            "date": " • Mar 19, 2022"
        }
        
    
  
    
        ,"post28": {
            "title": "typora image uploader(picGo+token)",
            "content": "스샷 레포 생성 후 토큰 생성 . 레포 설정 참고 블로그 | . 빈 github_id로 로그인해서 스크린샷 레포를 만든다. . . | 프로필 &gt; Settings &gt; Developer settings로 넘어간다. . | Personal aceess tokens로 넘어와 &gt; Generate new token을 만든다. . 각종 필요한 설정을 해준다. . Note: 아무거나 . | Expiration: 무기한으로 . . | scopes . repo 전체 체크 . | write: packages 체크 . | admin:repo_hook 체크 . | write: discussion 체크 . . | . | 토큰을 챙겨놓는다. . | . | . | TYPORA에 적용 . . 서식 &gt; 이미지 &gt; 전역 이미지 설정 . when Insert : upload image로 선택 . | [x] 로컬 이미지에 위 규칙을 적용 체크 . | image Uploader: PicGo-Core(command line) 선택 . | Open Config File클릭후 아래 템플릿대로 작성 . 예시 | . { &quot;picBed&quot;: { &quot;current&quot;: &quot;github&quot;, &quot;github&quot;: { &quot;repo&quot;: &quot;is2js/screenshots&quot;, //변경 &quot;token&quot;: &quot;ghp_8nmOf//ymaH8bBHqXNsLRtoTHUEN8j1B6vh/&quot;, //변경 &quot;path&quot;: &quot;&quot;, &quot;customUrl&quot;: &quot;https://raw.githubusercontent.com/is2js/screenshots/main&quot;, //변경 &quot;branch&quot;: &quot;main&quot; } }, &quot;settings&quot;: { &quot;showUpdateTip&quot;: true, &quot;autoStart&quot;: true, &quot;uploadNotification&quot;: true, &quot;miniWindowOntop&quot;: true }, &quot;needReload&quot;: false, &quot;picgoPlugins&quot;: {} } . | | . 사용 중 레포지토리만 교체 . typora &gt; 서식 &gt; 이미지 &gt; 전역이미지 설정 &gt; Open config file &gt; . &quot;repo&quot;와 &quot;customUrl&quot;에서 폴더명만 바꿔주면 된다. . | 토큰은 계속 유지중이니.. 레포만 바꿔주면 끝. . . | . | .",
            "url": "blog.chojaeseong.com/configuration/typora/picgo/github-token/settings/2022/03/18/typora_screenshot_by_github_token.html",
            "relUrl": "/configuration/typora/picgo/github-token/settings/2022/03/18/typora_screenshot_by_github_token.html",
            "date": " • Mar 18, 2022"
        }
        
    
  
    
        ,"post29": {
            "title": "02 Morbidity and Mortality",
            "content": "&#47785;&#52264; . Measures of morbidity | Measures of mortality | 1강 연구진행의 단계에서 맨 처음 단계인 디스크립티브 스터디에서 쓸 수 있는 메저들이다. | . Measures of Morbidity(&#47784;&#48708;&#46356;&#54000; &#47700;&#51200;) . &#51656;&#48337;&#51032; &#48156;&#49373; &#51221;&#46020; . 질병 발생 정도(모비디티)의 측정은 크게 2가지 방법이 있다. 번역은 둘다 비율 같지만 다른 개념이다. Rate: 속도와 관련된 개념으로서 없었던 질병이 새롭게 &amp; 얼마나 빠른 속도로 퍼지고 하고 있는가 관련메저: Incidence | . | Proportion: 특정시점에서의 비율로서, 흐르고 있는 시간 중 딱 한 시점에서, 전체인구 중 질병 걸린 비율 관련메저 : prevalence | . | | . Incidence or Incidentce rate . 분모: 전체인구가 아니라 특정 기간동안 위험에 노출된 인구 수 위험에 노출된을 어떻게 정의? 언제든지 분자(새롭게 질병발생 환자)로 올라갈 수 있는 가능성이 있는 사람만 포함한다. | 즉, 새롭게 질병 발생이 가능한 사람만 분모에 ex&gt; 자궁암의 incidence rate 계산 -&gt; 자궁암 가능성이 있는 = 자궁이 있는 = 여성들만 분모에 넣어야한다(남성 빼야한다. 자궁적출술 여성은 빼야한다) | . | . | 분자: 새롭게 질병이 발생한 환자수 | 구체적으로 1000명당 인씨던트 레이트 -&gt; 분자/분모에 * 1000 . 1000대신 다른 숫자도 원하는 대로 곱해줘서 N명당 incidence rate으로 명명한다. . . | . | . incidence rate&#51032; &#48516;&#47784;&#51032; &#47928;&#51228; . incidence rated의 분모에는 특정기간 동안이라는 말이 붙어있는데, 연구자 관심기간 아무기간이나 설정할 수 있다. ex&gt; 1년, 5년, 한달... 마음대로 . | 특정기간은 맘대로 정했는데, 중간에 사라지는 사람이 있다 == 모든 사람이 관측되지 않았다의 문제가 있다. . 이사 감, 사라 짐. -&gt; 분모 중 일부만 관찰된다면? | 아래 사진은 5년동안, 5명의 환자 중 2명만 관찰되고 3명은 사라짐 사라진 사람이 질병이 새로 발생됬어도 포함안되게 된다. | . | . | . Person-time . 일부시간만 관측된 사람이 존재한다? 분모의 단위를 특정기간 ~ 새로운 환자수의 사람 수가 아니라 | person-time이라는 시간(구간)동안 관찰된 환자수새로운 분모를 적용한다. | 첫 1년 -&gt; 5명 다 관찰: year1 - 5 py | 2번째 1년 -&gt; 4명 관찰: yaer2 - 4 py | 마지막엔 py값만 다 더한다. 다 관찰되었다면 사람수 x 시간 수 = 25py이지만, 합친 결과 17py로 관찰되었다 -&gt; 일부만 관찰된 사람이 있었다. | 17py를 incidence rate의 분모로 쓴다. | . | . | . 연구자가 정한 특정기간동안 모든 사람 다 관측시 -&gt; 분모가 사람 수 Cumulative incidence 또는 incidence proportion이라고도 한다. | . | 연구자가 정한 특정기간동안 일부기간만 관찰되는 사람 1명이라도 존재시 -&gt; 분모가 py (Cumulative incidence와 구분해주기 위해서) incidence density, person-time incidence rate라고 한다. | . | incidence를 보면 분모를 보고 몇명당인지/몇py인지를 먼저 봐서 계산방법을 이해하자 | . Prevalence . rate가 아닌 proportion에 관련된 것으로 시간이 지나감을 고려하지 않고, 특정 시점만 잡아서 이야기한다. 특정 시점에, 관심집단내 질병에 걸려있는 사람의 비율 | 경우에 따라 N명당 -&gt; * N해주면 된다. | . | . Incidence vs. prevalence &#52264;&#51060; . 분자에 집중해보기 . prevalence 분자는 시간이 지나감을 고려하지 않으므로 어제 질병 걸린 사람과 몇십년전 질병 걸린 사람이 섞여있다. . 특정 시점 -&gt; 한 지점만 보기 때문에 언제 병에 걸렸는지는 상관 없게 된다. | . | incidence분자에는 특정기간동안 새롭게 발병한 new case만 들어간다. . | | . . 그림으로 보면, 관심있는 파퓰레이션(파란색)이 있을 때 특정시점에 질병을 가진 사람 = 주황색 | 특정시점에 질병을 가지고 있지 않은 사람 = 노란색 prevalence: 주황색 / 파란색 | . | 정해진 특정시점에 질병 없는 노란색을 시작으로 1년간 follow-up한다고 쳤을 때, incidence: 노란색(2nd, at baseline) 중 새롭게 발생한 빨간색테두리의 주황색(2nd) / 전체 노란색(2nd, at baseline) incidence는 분자가 새롭게 발생해야하기 때문에, 애초에 시작점에서 질병 발생위험을 가지고 있지만 질병이 없는 환자를 대상으로 한다 | . | . | . | . Incidence: 어떤 기간동안 새롭게 발병한 질병에 대한 것이므로 -&gt; 질병이 없는 사람이 새로 질병이 발생할 가능성에 대한 정보를 준다 -&gt; 질병에 걸릴 확률/위험에 대한 정보를 준다. risk(위험)의 척도 | 어떤 질병의 원인, etiology를 파악하고 싶을 때 유용 | . | Prevalence: 프리벌런스는 옛날에 걸린사람 + 지금 걸린 사람을 섞어서 다 포함하고 있기 때문에, 새로운 질병이 얼마나 발생하기 쉬운지에 대한 정보는 없고, 지금 상태에서 영향을 받고 있는 사람/고통받고 있는 사람이 어느정도냐를 제는 것 burden의 척도 | 원인보다는 집단내 메디컬서비스, 자원을 어떻게 배분할 것인가, 헬스 서비스 관련 정책을 어떻게 결정할 것인지(어디 질병 프로그램에 돈을 더 투자할 것인지 결정)에 유용 | 질병의 위험은 인씨던스가 더 유용하지만, **경우에 따라 인씨던스를 알기 어려운 질병도 있다. ex&gt; 천식 -&gt; 정의도 떨어지지 않고, 증상도 서서히 드러나기 때문에 언제부터 발병했는지 판단불가 -&gt; new case인지 알기 어려우므로 인씨던스 계산이 어렵다 -&gt; 집단간의 비교나 시간에 따른 비교가 어려우므로 특정시점에서 계산해버리는 prevalence를 계산이 더 유용하다 | . | . | . 공식: Prevalence = Incidence × Duration of disease Incidence가 시간에 따라 변하지 않고, | prevalence가 너무 높지 않고 | 인구유입과 유출이 같은 경우 성립 성립한다 질병 앓는 기간 x 인씨던스를 곱해서 프리벌런스를 구한다. | 대충 서로 비례한다고 직관적으로 생각할 수 있다. | . | . | 직관(공식처럼 비례)과 어긋나는 경우 . 인쓰던스는 높지만 x 상수역할을 하던 Duration of disease가 아주 짧은 경우(금방 치료or사망) -&gt; 인씨던스가 높아도 prevalence가 낮다 . | 인씨던스가 아주 낮지만 x 상수역할을 하던 Duration of disease가 아주 긴 경우(오래동안 치료되지 않은 체 생존하고 있음) -&gt; 인씨던스가 낮아도 prevalence가 높다 . . | . | . Measures of Mortality(&#49324;&#47581;&#47456;) . &#49324;&#47581;&#45936;&#51060;&#53552; . 사망데이터는 생각해보면, proportion 및 prevalence의 개념이 의미가 없다 . 언젠간 모두 사망하므로 -&gt; 언젠가 모두 사망O로 바뀜 -&gt; 사망 O/X의 비율보다는 사망시점(언제 사망)이 중요하므로 mortality rate를 본다. | . | Mortality Rate(사망률) . Risk of dying(사망 위험의 측도) | Disease severity(시비리티)의 측도 (이 질병에 걸렸을 때 사망 률 높다 -&gt; 질병의 심각도 높다) | 치료 효과의 측도: 반대로 확줄어든다면 좋은 치료의 측도도 된다. | Incidence rate의 proxy(대체자)로 기능할 수도 있다 조건 1) 치명률이 높은 병 | 조건 2) 투병기간이 짧은 병 새롭게 걸렸는데 금방 + 사망하는 병 -&gt; 발병 인씨던스와 사망과 비슷한 이벤트가 된다. -&gt; 사망률을 인씨던스 레이트 대신 쓰게 된다. | . | . | . | . . Mortality rate &#50668;&#47084; &#44228;&#49328;&#48277; . 국가통계에서는 보통사망률이라 부르는 사망률 계산법 사망률 = 보통사망률 = mortality rate = crude(보정하지 않은) death rate | 특정기간이라 적혀있지만, 사망률은 보통 1년을 많이 써써 연간사망률을 많이 쓴다. 연간사망률은 7월1일을 중앙시점으로 본다. | . | 중앙시점 인구수를 사용하는 이유: incidence rate는 py를 분모에 넣어 계산하기도 했었지만, 기간 평균 인구수에 대한 접근으로서 중앙시점 인구수를 사용 | . | . Specific mortality rate (subgroup &#49324;&#47581;&#47456;) . . 사망률을 집단 전체가 아니라 나이or성별or진단명으로 나눠진 subgroup에 대해서만 구할 수 도 있다. | age-specific rate : 분자와 분모에 같은 나이 조건을 걸어야 한다 예&gt; 10세 미만 아동의 연간사망률 -&gt; 분모도 10세 미만의 그해 7월1일 아동수 -&gt; 분자도 10세미만의 | . | Disease-specific mortality의 예 : 분모는 전체인구수 -&gt; 분자만 특정질병으로 사망 인구수 | . &#52824;&#47749;&#47456; (Case-fatality) (&#52992;&#51060;&#49828;-&#54168;&#51060;&#53448;&#47532;&#54000;) . 사망률(7월1일 전체 인구수)에 비해 치명률의 분모는 특정 질병을 가진 사람이 대상이다 곱하기 100을 하는 퍼센티지 개념을 많이 쓴다. | . | 어떤 질병에 걸린 사람 중 몇프로가 죽었냐?에 대한 것이다. 질병의 심각도에 대한 측도: 심각한 병이면 치명률이 높다 | 치료 효과의 측도: 좋아지만 치명률이 낮아진다. | . | . . Years of potential life lost . 줄여서 YP LL, 최근에 많이 쓰는 측도 | 나이가 많은 사람이 사망하는 것보다 어린 사람이 사망하는 것이 더 큰 손실임을 반영한 측도 | 계산할 때는 기대수명부터 계산하고 -&gt; 사망한 사람의 나이에서 뺀 뒤 총합 기대수명 계산법을 정하느냐에 따라 달라지니 먼저 확인한다. | . | . 아래 그림은 10만명당사망률에 대한 age-adjusted mortality rate vs YPLL비교 표 그냥 보면 Heart disease(심장병)가 제일 사망률이 높아보인다 mortality rate로만 보면, Heart disease(심장병)이 167 가장 큰 원인 같고, Accidents(사고사)를 보면, 40.5으로 1/4정도 밖에 안되는 것 같다 | 하지만, YPLL도 같이 보게 되면 Accidents(사고사)가 더 높다 -&gt; 어린사람이 더 큰손실이라는 YPLL개념 없이보면, 사망률은 1/4정도 였지만, YPLL로는 조금 더 높았다 -&gt; 사고사 한 사람이 젊은 사람들이 더 많아서 그로인한 손실이 높게 평가되었다` | Suicide도 심장병의 1/10정도였지만, YPLL로 보면 1/3수준으로 손실을 높제 잡아줬다 -&gt; 젊은 사람이 많았다. 심장병에 의한 사망률을 줄이는 것도 중요하지만, YPLL을 보니, 사고사+자살을 방지하는 정책이 포텐셜라이프(기대수명)을 더 늘리는 방법일 수 있다. | . | . | . | . &#49324;&#47581;&#47456;&#51032; &#48708;&#44368; . 사망률 비교시 항상 주의해야할 것은 나이라는 팩터다. 사망관련 자료를 볼 때 + 임상자료에서 생존분석시 항상 설명변수로 들어간다` 나이가 사망과 관련성이 깊은 인자이기 때문 | . | 다른 집단간 사망률 비교 -&gt; 집단간 나이 분포차이부터 고려 . 예시&gt; 1000명당 사망률 모든 나이대 : 백인 9.95 , 흑인 7.35명 사망 -&gt; 이렇게 보면 흑인이 더 의료서비스 접근성이 낮다거나 접근후 인종차별때문에 흑인이 좀 더 사망할 것 같은데, 이상하게 백인이 사망률이 높은 것 같다고 생각할 수 있다. | 나이대로 쪼개보면, 왜 이런 결과가 나왔는지 확인할 수 있다. 각 연령대 모두에서 흑인의 사망률이 더 높다. 오직 85세 이상에서만 백인이 더 높다 | 85세이상 그룹때문에, all alges에서 백인의 사망률이 더 높은 것처럼 보이게 된 것이다. | 이런 현상의 원인: 백인은 85세이상이 많았다(많이 살아남은 것) -&gt; 그만큼 많이 죽었다. 흑인은 85세이상이 너무나 적었다. -&gt; 이미 더 젊은 나이세 흑인들이 사망했지만, 그게 반영되지 않았음. + 85세 이상그룹이 인구수만 많이 측정되어 많이 반영되었다. -&gt; 전체적으로 백인 사망률이 더 높은 것처럼 보이게 된 것 | . | 이렇게 전체사망률을 crude death rate로 비교하게 되면, 집단간의 사망률 비교가 정확하지 않게 된다. | . | . . | . Age-adjustment . 예제 데이터 . 2개의 집단, 인구 수 전체=90만명, 1년간사망자 수 = A집단 860 vs B집단 1130 | . | Q. 어느쪽이 사망률이 높은가? . 전체적으로 봤을 때는, B집단의 사망자수가 많으니 -&gt; B집단의 사망률이 더 높은 것처럼 보인다. | 각 나이 그룹별 10만명당 사망률을 계산해보자. 각 나이 그룹별 사망자수 / ( 전체인구수 ) X 10만 -&gt; 10만명당 사망률 | . | 하지만, 나이 효과를 보정해서 보면 달라진다 | . | . Direct age adjustment &#50696;&#49884; . 각 집단별(칼럼) / 연령그룹별(행) / 인구수(칼1)와 10만명당 사망률(칼2) | . 그룹별 10만명당 사망률에 대해, 연령분포를 통한 보정을 하기 위해서는 . 먼저 표준집단을 상정해야한다. 국가 인구통계에서 나온 것으로 정할 수 도 있고 | 인구 수가 비슷한 2집단의 경우 -&gt; 두 집단의 합 =표준집단으로 잡을 수 있다. 각 그룹별 인구수합 -&gt; 3그룹 다 합치면 90 + 90 = 총 180만명이 표준집단 | . | . | 구해놓은 그룹별 / 집단별 10만명당사망자률을 이용해서 -&gt; 표준집단 나이분포라면 몇명이 사망했을지 표준집단이라면 사망자 수를 구한다 . 각 그룹별로 A,B서로 다른 나이분포를 가지고 있으니 -&gt; 미리 구해둔 사망률 + 표준집단으로 인구수 통일 -&gt; 사망자 수 계산 | ex&gt; 0-49집단: 80만명(800,000) X 각 집단의 10만명당 사망률(10만명당 12 = 12 / 100,000) . . | . | 기대되는 사망자수를 각 집단별로 각각 구한 뒤 다 더해준다. . | 각 집단별로 나온 기대되는 사망자수에다가 / 표준인구 총합을 나눈 뒤, X 10만을 곱해서 각 집단의 10만명당 age-adjusted mortality rate를 구한다. . | 전체적으로 사망률을 봤을 땐, B집단의 사망자수가 많으니 -&gt; B집단의 사망률이 더 높은 것처럼 보였지만, . 10만명당 에이지-어저스티드 모탈리티 레잇을 이용해서 보면, B집단보다 A집단의 사망률이 더 높다. | crude 모탈리티 레잇을 본 것과는 반대의 결과가 나온다. | . | | . Direct age adjustment &#51452;&#51032;&#51216; . 앞의 예처럼, 인구 수가 비슷하면 합을 이용하는 hypothetical population(하이포 세티칼 파퓰레이션)으로 실존하지 않는 가상의 인구집단을 만들어서 할 수 도 있다. | 아니면, 인구조사통계를 이용할 수 있다. | 주의점: 표준집단은, 비교하려는 비교집단이 너무 드라마틱하게 다르면, 비현실적인 통계량이 될 수 있다. . | 나이 말고도 다른 특성(성별, SES 등)의 분포 보정에도 사용할 수 있다. . | . . Indirect age adjustment . Direct age adjustment의 적용이 불가능할 때가 있다. . 이럴 때는 사실 할 수 있는 것이 많지는 않다 | . | 관심집단의 사망률을 -&gt; 이미 잘 알려진 참조집단과 비교하고 싶을 때 사용한다. . 관심집단의 전체 사망률만 알고 있고, 연령그룹별 인구 수는 알고 있으나, 연령그룹별 사망률을 모를 때 | 참조 집단의 연령그룹별 사망률이 있다고 가정할 때, 그것을 이용한다 | . | 참조집단의 연령별 사망률이 있고, 그것을 이용해, 몇명이 사망했을 것이라고 기대되는지 계산후, 그것의 비율로 계산한 SMR을 이용한다. 분모: 특정기간동안, 참조집단과 같은 연령별사망률을 가졌더라면 발생됬을거라 기대되는, 사망자의 수 | 분자: 특정기간동안, 실제로 관측된, 사망자의 수 | 곱하기 100한 뒤 % | . | . Indirect age adjustment &#50696;&#49884; . . A를 참조집단, B집단을 관심집단이라고 가정한다. . A집단은 참조집단으로서 연령그룹별 10만명당 사망률(사망률 분포)이 알려져있다 연령그룹별로 10만명당 몇명씩 사망했는지도 다 알려져있다. | . | B집단은 연령그룹별 인구수 + 실제 총 사망자수만 알고 있지만, 연령그룹별 사망자수는 모른다 연령그룹별로 1130명이 어떻게 분포하는지 모른다. 연령그룹별 10만명당 사망자수를 모른다. | . | . | Q. A집단과 비교해서 관심집단 B의 사망자률이 더 높을까? . | . B의 각 연령그룹별 인구수에서 X 참조집단 A의 10만명당 사망률을 가졌더라면 -&gt; 몇명이 죽었을까? 기대되는 사망자 수 를 계산한다 B집단에서는 참조집단의 연령그룹별 사망률을 참고 했을 때, 36명이 죽었을 거라 기대할 수 있다. | . | 1.의 방법으로 각 연령그룹별 사망자 수를 각각 구한 뒤 -&gt; 다 더한 기대되는 총 사망자수를 구한다. 참고로 실제 총 사망자수는 이미 알고 있는 상태에서, A집단 참조 기대되는 총 사망자수를 구한 상태다 기대되는 총 사망자수: 1,376 | 실제 총 사망자수 : 1,130 | . | . | 실제 총 사망자수 / A집단의 연령그룹별 사망률 참조 기대되는 총 사망자수를 계산하여 1보다 큰지 작은지 확인한다. 기대되는 것을 분모에 두고 -&gt; 기대되는 것 대비 0.82 &lt; 1-&gt; 기대의 82%만 사망했다. -&gt; B집단의 사망률이 A집단의 0.82로 사망률이 더 낫다 | . | &#51221;&#47532;&#54616;&#44592; . . 크게 인씨던스와 프리벌런스로 질병률을 계산했다. 인씨던스: 특정기간동안 위험 노출 인구집단 내 -&gt; 새롭게 질병 발생 비율 인씨던스의 분모를 계산시, 모든 기간이 아니라 일부만 관찰되는 환자 존재시 -&gt; 분모를 person 대신 person-time으로 계산하며 -&gt; person-time incidence rate이라 한다 | 질병 발생하는 속도 = 새롭게 질병발생하는 것에 대한 얘기 -&gt; risk의 척도 | . | 프리벌런스: 고정된 특정시점에서 질병에 거린 사람의 비율 특정시점에서 얼마나 힘든상탠지 -&gt; burden의 척도 | . | . | 모탈리티 레잇: 특정기간동안 발생한 사망자수를 / 특정기간 중앙시점의 인구수로 나눈 것 년간사망률 -&gt; 7월1일 인구수로 나눈다. | 그외 모탈리티를 보는 것으로는 case-fatality라던가 YPLL의 메저도 있다. | . | 집단간의 모탈리티 레잇을 비교시 반드시 연령분포를 고려해서 비교해야한다 연령분포 차이를 보정하는 2가지 방법이 있다. direct age adjustment : age-adjusted mortality rate | indirect age adjustment : SMR | . | . | . &#50672;&#49845;&#47928;&#51228; . 1&#48264; . . 다음 중 질병률에 대한 설명으로 틀린 것은? . 1 Incidence는 질병이 발생하는 속도에 대한 측도이다. . 2 Incidence를 계산하기 위해서는 관심집단의 구성원들이 모두 관심기간 내내 관측되어야 한다. . 3 Prevalence의 분자에는 방금 질병에 걸린 사람과 아주 오래 전에 질병에 걸린 사람이 섞여있다. . 4 Incidence가 높아도 질병이 금방 치료되거나 질병으로 인해 빨리 사망하게 되면 prevalence가 낮을 수 있다. . 정답입니다. 정답 : 2 해설 : 관심집단의 구성원 일부가 관심기간 중 일부분에서만 관측된 경우, person-time incidence를 사용할 수 있다. . 2&#48264; . . 다음 중 발병시점을 정확히 알기 어려운 질병의 위험을 평가할 때 incidence rate을 대신하여 disease-specific mortality rate를 사용하는 것이 적절한 경우는? . 1 치명율이 높고 투병기간이 긴 질병 . 2 치명율이 높고 투병기간이 짧은 질병 . 3 치명율이 낮고 투병기간이 긴 질병 . 4 치명율이 낮고 투병기간이 짧은 질병 . 정답입니다. 정답 : 2 해설 : 치명율이 높고 투병기간이 짧은 질병은 질병의 발생이 사망으로 이어지는 비율이 크고 시간차가 적기 때문에 mortality rate가 incidence rate의 proxy로서 기능한다. . 2&#48264; &#48512;&#50672;&#49444;&#47749; . 상관없는 개념이야기 . age-specific rate : 분자와 분모에 같은 나이 조건을 걸어야 한다 예&gt; 10세 미만 아동의 연간사망률 -&gt; 분모도 10세 미만의 그해 7월1일 아동수 -&gt; 분자도 10세미만의 | . | Disease-specific mortality의 예 : 분모는 전체인구수 -&gt; 분자만 특정질병으로 사망 인구수 | . | incidencate rate 대신 prevalence를 쓰는 예-&gt; 천식 . 천식 -&gt; 정의도 떨어지지 않고, 증상도 서서히 드러나기 때문에 언제부터 발병했는지 판단불가 -&gt; new case인지 알기 어려우므로 인씨던스 계산이 어렵다 -&gt; 집단간의 비교나 시간에 따른 비교가 어려우므로 특정시점에서 계산해버리는 prevalence를 계산이 더 유용하다 | . | incidencate rate 대신 (Disease-specific) mortality rate를 사용하는 경우 . 치명율이 높고 빨리 사망해서 인씨던스의 새롭게 발생 과 == 사망률의 이벤트가 비슷해진 경우 | 치명률이 높고 투병이가 짧은 질병 | . | . | . 3&#48264; . 다음은 2021년 A집단과 B집단의 연령별 인구분포와 사망자수이다. 두 집단을 합한 인구집단을 표준집단으로 해서 A집단과 B집단의 1000명당 age-adjusted mortality rate를 구하여라. . . &#45236;&#54400;&#51060; . . 표준집단 구하기: 두 인구수의 합 -&gt; 총 표준집단 인구수 : 18000 | 표준집단이였다면 기대되는 사망자수(해당 집단의 1000명당 사망률 X 표준집단 인구수)를 연령별로 집단별로 구하기 . 문제에서 주어진 단위(1000명당)으로 사망률도 계산할 것 | 각 연령그룹별/집단별 1000명당 사망률 부터 구하기 - 1000을 곱해서 %같은 률 A: 10 / 5000 1000 = 2 | B: 9 / 3000 1000 = 3 | A: 21 / 3000 1000 = 7 | B: 45 / 5000 1000 = 9 | A: 17 / 1000 1000 = 17 | B: 21 / 1000 1000 = 21 | . | 표준집단을 인구수로 가정 &amp;&amp; 구한 1000명당 사망률을 반영해 표준집단이었더라면 기대되는 사망자수 구하기 - 1000을 나눠서 실제 수 A: 2 x 8000 / 1000 = 16 | 3 X 8000 / 1000 = 24 | A: 7 x 8000 / 1000 = 56 | 9 X 8000 / 1000 = 72 | A: 17 x 2000 / 1000 = 34 | 21 X 2000 / 1000 = 42 | . | . | 집단별 기대되는 사망자수 더하기 . A: 106 | B: 114 | . | 각 집단별로 나온 기대되는 사망자수 / 표준인구 총합을 나눈 뒤, X 단위(1000)을 곱해서 각 집단의 단위명당 age-adjusted mortality rate를 구한다. . A: 106 / 18000 * 1000 = 5.8888 -&gt; 소수 2번째자리까지 반올림 -&gt; 5.89 | B: 138 / 18000 * 1000 = 7.6666 -&gt; 7.67 | . | &#51221;&#45813; . . &#44228;&#49328; &#50696;&#51228; &#52280;&#44256; . Direct age adjustment 예시 | 그룹별 10만명당 사망률에 대해, 연령분포를 통한 보정을 하기 위해서는 . 먼저 표준집단을 상정해야한다. 국가 인구통계에서 나온 것으로 정할 수 도 있고 | 인구 수가 비슷한 2집단의 경우 -&gt; 두 집단의 합 =표준집단으로 잡을 수 있다. 각 그룹별 인구수합 -&gt; 3그룹 다 합치면 90 + 90 = 총 180만명이 표준집단 | . | . | 구해놓은 그룹별 / 집단별 10만명당사망자률을 이용해서 -&gt; 표준집단 나이분포라면 몇명이 사망했을지 표준집단이라면 사망자 수를 구한다 . 각 그룹별로 A,B서로 다른 나이분포를 가지고 있으니 -&gt; 미리 구해둔 사망률 + 표준집단으로 인구수 통일 -&gt; 사망자 수 계산 | ex&gt; 0-49집단: 80만명(800,000) X 각 집단의 10만명당 사망률(10만명당 12 = 12 / 100,000) . . | . | 기대되는 사망자수를 각 집단별로 각각 구한 뒤 다 더해준다. . | 각 집단별로 나온 기대되는 사망자수에다가 / 표준인구 총합을 나눈 뒤, X 10만을 곱해서 각 집단의 10만명당 age-adjusted mortality rate를 구한다. . | 전체적으로 사망률을 봤을 땐, B집단의 사망자수가 많으니 -&gt; B집단의 사망률이 더 높은 것처럼 보였지만, . 10만명당 에이지-어저스티드 모탈리티 레잇을 이용해서 보면, B집단보다 A집단의 사망률이 더 높다. | crude 모탈리티 레잇을 본 것과는 반대의 결과가 나온다. | . | | .",
            "url": "blog.chojaeseong.com/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EC%9E%84%EC%83%81%EC%97%B0%EA%B5%AC/2022/03/18/02-Morbidity-and-Mortality.html",
            "relUrl": "/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EC%9E%84%EC%83%81%EC%97%B0%EA%B5%AC/2022/03/18/02-Morbidity-and-Mortality.html",
            "date": " • Mar 18, 2022"
        }
        
    
  
    
        ,"post30": {
            "title": "전략패턴 3(일급 수동생성 TestUtil)",
            "content": "일급컬렉션에 적용된 전략패턴의 수동 데이터 . 01 포장된 일급컬렉션 내부 변수(list&lt;단일객체&gt;)를 생성자에서 랜덤으로 생성하여 초기화하는 부분에 전략패턴 적용된 상태 . public class CardDeck { private final Deque&lt;PlayingCard&gt; playingCards; public CardDeck(final CardGenerator cardGenerator) { this.playingCards = cardGenerator.generate(); } . 02 문제는 수동으로 일급컬렉션 인스턴스 변수인 Deque&lt;PlayingCard&gt; playingCards = 를 테스트에서 case마다 가변변수 -&gt; Add or Push로 직접 만들어 줘야한다?! . 전략객체 주입 대신 전략메서드 응답값까지 넣어줘서 전략메서드를 무시하고 바로 처리되게 한다. . () -&gt; [Deque&lt;PlayingCard&gt; playingCards 미리 만들어서] | . private final Deque&lt;PlayingCard&gt; playingCards; public CardDeck(final CardGenerator cardGenerator) { this.playingCards = //전략메서드 호출() &lt;-- 자리에 람다 오른쪽 부분이 들어간다 // () -&gt; [전략메서드 호출()자리에 들어갈 수동 응답값] } . | . 빈 deque를 만든다. . | 수동으로 new PlayingCard(단일객체)를 만든다. . | 여러개 만들어서 빈 deque에 push한다. . @DisplayName(&quot;딜러가 버스트인 경우, 패배 결과 객체를 반환하는지 확인한다.&quot;) @Test void burst_dealer_lose() { //given PlayingCard card = new PlayingCard(Suit.CLUBS, Denomination.KING); PlayingCard burst1 = new PlayingCard(Suit.HEARTS, Denomination.KING); PlayingCard burst2 = new PlayingCard(Suit.HEARTS, Denomination.JACK); PlayingCard burst3 = new PlayingCard(Suit.HEARTS, Denomination.QUEEN); Deque&lt;PlayingCard&gt; rawCardDeck = new ArrayDeque&lt;&gt;(); rawCardDeck.push(card); rawCardDeck.push(burst1); rawCardDeck.push(burst2); rawCardDeck.push(burst3); cardDeck = new CardDeck(() -&gt; rawCardDeck); cardDeck.drawTo(dealer); cardDeck.drawTo(dealer); cardDeck.drawTo(dealer); cardDeck.drawTo(gambler); //when final GameResult result = GameResult.of(dealer, gambler); //then assertThat(result).isEqualTo(GameResult.LOSE); } . | 03) 대박) 수동으로 전략패턴 적용된 일급컬렉션 수동 생성하는 부분을 메서드 추출한 뒤 -&gt; 가변 인자 등 메서드화 해주자. . 01 (input)직접 넣어주는 단일객체는 인자로 받아 -&gt; (ouput)으로 원하는 일급이 나올 수 있게 -&gt; 메서드 추출부터 하자. . . . 02 직접 입력한 input(단일객체)들이 파라미터로 안나온다면-&gt; 파라미터 추출을 해주자. . 파라미터로 추출로 해줘야, 내부에 있던 실제 단일객체들이 외부에서 사용으로 빠져있다. . . | . . . 03 파라미터로 지역변수화 되었으니 변수는 이제 없애준다. . . private void createCardDeck(final PlayingCard card1, final PlayingCard card2, final PlayingCard card3, final PlayingCard card4) { Deque&lt;PlayingCard&gt; rawCardDeck = new ArrayDeque&lt;&gt;(); rawCardDeck.push(card1); rawCardDeck.push(card2); rawCardDeck.push(card3); rawCardDeck.push(card4); cardDeck = new CardDeck(() -&gt; rawCardDeck); cardDeck.drawTo(dealer); cardDeck.drawTo(dealer); cardDeck.drawTo(dealer); cardDeck.drawTo(gambler); } . 04 여러개 들어오는 단일객체에 대해서 null방지용으로 1 + 가변인자로 받아준다. . 첫번째 것만 직접 add . 가변인자는 배열로서 for문 / .stream 등을 활용한다. . addAll()같은 메서드가 있으면 바로 사용하면 된다. . | 예시 . public class CardFixtureGenerator { public static List&lt;Card&gt; createCards(Card firstCard, Card... remainCard) { final List&lt;Card&gt; cards = new ArrayList&lt;&gt;(); cards.add(firstCard); cards.addAll(Arrays.stream(remainCard) .collect(Collectors.toList())); return cards; } public static void pollCards(final CardDeck cardDeck, final int pollCount) { for (int i = 0; i &lt; pollCount; i++) { cardDeck.provideCard(); } } } . | . | . private void createCardDeck(final PlayingCard card1, final PlayingCard... cards) { Deque&lt;PlayingCard&gt; rawCardDeck = new ArrayDeque&lt;&gt;(); rawCardDeck.push(card1); for (PlayingCard card : cards) { rawCardDeck.push(card); } cardDeck = new CardDeck(() -&gt; rawCardDeck); cardDeck.drawTo(dealer); cardDeck.drawTo(dealer); cardDeck.drawTo(dealer); cardDeck.drawTo(gambler); } . | . 05 전략객체 대신 전메응답값이 포함된 람다를 주입하여 일급컬렉션 생성후 return으로 응답까지 . 생성외 부분은 다시 보낸다. . . . . | . private CardDeck createCardDeck(final PlayingCard card1, final PlayingCard... cards) { Deque&lt;PlayingCard&gt; rawCardDeck = new ArrayDeque&lt;&gt;(); rawCardDeck.push(card1); for (PlayingCard card : cards) { rawCardDeck.push(card); } return new CardDeck(() -&gt; rawCardDeck); } . 06 다른 곳에서도 쓸 수 있게 testutil &gt; xxxxFixtureGenerator &gt; public static method . 직접 잘라내서 붙여하므로 직접 고쳐줘야한다. . F6 move method는 (프로덕션 -&gt; 프로덕션 or Test -&gt; 프로덕션) 정도만 지원하는 것 같다. | . | public static 으로 만들어줘야 import후 객체생성없이 바로 갖다 쓰는 유틸이 된다. . | . . . . public class CardDeckFixtureGenerator { public static CardDeck createCardDeck(final PlayingCard card1, final PlayingCard... cards) { Deque&lt;PlayingCard&gt; rawCardDeck = new ArrayDeque&lt;&gt;(); rawCardDeck.push(card1); for (PlayingCard card : cards) { rawCardDeck.push(card); } return new CardDeck(() -&gt; rawCardDeck); } } . . 07 사용은 가변 변수 fixture &lt;—를 초기화해주는 해주도록 사용한다.(겹친다면 @beforeEach에서 초기화) . cardDeck = createCardDeck( new PlayingCard(Suit.CLUBS, Denomination.KING), new PlayingCard(Suit.HEARTS, Denomination.KING), new PlayingCard(Suit.HEARTS, Denomination.JACK), new PlayingCard(Suit.HEARTS, Denomination.QUEEN) ); . .",
            "url": "blog.chojaeseong.com/java/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/testutil/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/16/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4-3(%EC%9D%BC%EA%B8%89-%EC%88%98%EB%8F%99%EC%A0%84%EB%9E%B5-TestUtil).html",
            "relUrl": "/java/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/testutil/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/16/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4-3(%EC%9D%BC%EA%B8%89-%EC%88%98%EB%8F%99%EC%A0%84%EB%9E%B5-TestUtil).html",
            "date": " • Mar 16, 2022"
        }
        
    
  
    
        ,"post31": {
            "title": "피드백) 1-2(로또) 코드리뷰",
            "content": "PR- 로또 미션 피드백(제이) . 참고 강의: 제이) 중간피드백 Service와 Controller . | PR1 . | PR2 . | . 구조 . Collections.unmodifiableList(issuedLotto); / issuedLotto인스턴스변수를 넘겨줌 . getter or 메서드 return으로 넘겨주는 list가issuedLotto라는걸 인스턴스변수로 사용한다면, 객체의 어떤 메서드로 issuedLotto를 조작하게되면 반환된 issuedLotto값이 바뀔거에요. 생성자에서 계산후 생성될 때부터 초기화되는 변수가 아니면 인스턴스 변수로 가지지 마라. 메서드에 의해 바뀐다 | my) Collections.unmodifiableList() 대신 List.of() 불변 복사 / new ArraysList&lt;&gt;()가변 변 복사를 사용하자. | . | . . | null처럼 아예 입력이 들어오지 않는 것은 view가 아니라 도메인에서 검증 . nullOrEmtpy와 format정도의 공통검증만 inputView로 옮기겠습니다! | . . | 일급의 getter에서는 외부에서 내부 포장변수 수정 못하도록 수정불가 타입으로 응답하기 . 방어적 복해서 넘기기 | . . . | 누적합 + 카운트는 stream으로 depth줄이기 . . | 도메인 내부에서 toDto 쓰지말 것 컨트롤러에서 from도메인 , to도메인 등을 써서 변환해야한다. | . | 서비스에서 필요에 의해 만들어진 특정 도메인을 관련 로직들은 결국 사용되는 변수를 포장하도록 클래스를 파고( 사용하는 스태틱 클래스를 파도 됨) 그 내부로 로직을 가져간다 . . | 로직의 결과로 나온 데이터가 추가 계산이 필요할 경우 클래스로 파서 포장하는 대신 그 생성과정은 생성자에 넣어라 . | 메인로직을 담당하는 service에서는 인스턴스변수를 두지말고 input -&gt; output의 스태틱 형태를 유지해라. 중요하지 않은 컨트롤러에서 도메인 변수를 생성후 -&gt; 서비스에 input으로 줘도 되니까 . | 컨트롤러에서는 outputView를 메인로직과 같이 묵지말고, 들어가는 input들이 서비스 메서드에 확실히 필요한 것들인지 한눈에 파악하게 작성 . . | Dto는 민감한 데이터, 불필요한 데이터를 짤라 넘기는 것인데, 작은 프로젝트들에서는 다 쓰인다. 넘겨도 된다~ dto를 항상 만들라고 하지말자~ | . | 빈 List가 가능한 자리에는 early return + Collections.emptyList() 활용 | . | 서비스가 비대해진다면, 도메인 로직을 포함하고 있는지 점검하기 . 도메인 로직은 도메인 (없으면 추출해서) 클래스에서 처리하기 | . | 다른 도메인과 추가 검증, 비교로직이 필요할 경우, 이미 포장된 도메인이라도 한번더 포장할 수 있다. . 입력받은 당첨Lotto + 보너스볼은 같이 다니며 + 검증도 요구된다 | . . 추가 로직 없이 단순히 같이 다니는 것들을 포장해서 2개의 상태값으로 보관할 수 있다.` 블랙잭에서 dealer + gamblers -&gt; Players -&gt; this.dealer + this.gamblers | 같이 다녀서 포장 -&gt; 필요할 땐, 각각 getter로 바로 줘도 된다. | . | . | 네이밍 . final priavate -&gt; 접근제한자 final 순으로… . | 상수 &lt;-&gt; 변수 개행 -&gt; class 생성후 개행도 해주기 . | 도메인Factory는 정펙매가 너무 커서 static클래스로 뺀 것 . | 다른 크루들 PR 참고 . 베루스 - 앨런 리차드 - 루피 케이 - 던 후니 - 엘런 . 구조 . Lotto내 상수 1_000이 Lottos, Money도 알아야한다? . public 상수로 ? (X) . | 여러 도메인이 아는 상수라도 각 도메인패키지내에 도메인상수들을 class로 관리하는 것도 좋은 방법이라고 생각해요 . 1_000원 이라는 것이 로또와 금액, Lottos가 모두 알아야 한다면 1_000원이라는 금액이 Lotto 에 있는 것이 맞는 것인가? 어쩔 수 없이 각 객체별로 공유해야하는 상수가 있다면 그 값은 누가 갖는게 맞는가? 에 대해서도 고민해보면 좋을 것 같아요. 지금처럼 로또가 같는 것도 방법이고, 도메인패키지내에 도메인상수들을 관리하는 것도 좋은 방법이라고 생각해요🙂 . | . | 포맷팅(변환)은 view(입력)에 따라 달라지니 중요하지 않은 controller에서! . convert를 도메인에서하면, 입력달라질 시 -&gt; 도메인도 같이 수정되어야한다. . | formating, convert는 자주 바뀌는 view에 따라 달라지니, 중요하지 않은 controller에서 . 포맷팅은 분명 현재 로또게임에서 중요한 로직이지만 입력과 도메인을 분리하기 위해서는 저는 Controller 패키지에서 담당하는 것이 맞다는 생각이 들어요🙂 추가로 DTO와 같은 객체들을 통해서 각 패키지나 레이어에서 필요로 하는 포맷을 재정의할 수도 있습니다. . | . | controller에서는 상태값을 가지지 말 것 . 다른 사용자는 다른 controller 인스턴스 객체를 가질 것이라고 생각해서 문제가 없다고 생각했어요. . 다른 사용자라도 여러 사용자가 같은 인스턴스 객체사용 가능 -&gt; 상태값 오염 가능 | . `synchronized`의 잠금을 통해 멀티쓰레드 환경에서 안정성을 보장할 수 있지만, 현재는 인스턴스변수를 가지지 않는 것으로 충분할 것 같아요. . | . | controller에서 도메인 객체(domain) 생성 메서드 &lt;-&gt; 출력(view)메서드을 1개 메소드로 묶지말 것 . controller에서 전체 로직에 대한 행위들이 프로그램 전체를 나눠서 설명할 수 있게 끔만 나눌 것 . controller전체를 너무 간결하게 나누지 말것 | 실행과 출력도 나눌 것 | . 비즈니스로직을 실행하는 행위와 출력하는 행위는 분리되는 것이 관심사가 분리되는 것이라 생각이 되어요. 두 가지의 역할이 하나의 메소드에 들어가는 것 보단, 각각 관리될 때 역할이 하나기 때문에 유지보수하기 용이한 코드가 아닐까 라는 생각을 하고 있습니다.🙂 . | . | 일급컬렉션도 컬렉션이라서 add 메서드 추가해도 된다! 가변 컬렉션, 불변 컬렉션 따로 있는 듯. | . | (베) . inputView에서 커스텀Exception을 쓰는 순간 -&gt; view에서 백엔드의 Exception을 의존하게 된다 -&gt; 쓰지말 것 . | List&lt;일급&gt;도 일급컬렉션으로 포장할 것 . | 뭔가 인스턴스 변수를 인자없이 기본생성자초기화해놓고 -&gt; FOR문돌면서 add의 가변값처럼 사용하지마라. -&gt; **일급 가변 생성을 정펙매를 통해 생성과 동시에 + 값할당기능을 제공할 수 있다. ** . // 잘못된 예 Statistic statistic = new Statistic(inputMoney); for (Lotto lotto : lottoes) { statistic.addRank(getRankBy(lotto)); } return statistic; . Statistic를 생성해놓고, 값을 추가하고있는데요. 객체가 가변값처럼 사용되고 있는 것 같아요. Statistic에서 정잭팩토리를 제공해서, 생성과 동시에 값을 할당하는형태로 만드는건 어떨까요? . | list를 합칠 때 -&gt; 빈 리스트(가변값)에 add를 대신하는 stream . 기존list.stream() + 새list.stream() -&gt; Stream.concat() -&gt; collect( collectingAndThen( toList(), 포장생성자::new ) . 2stream 을 1개 list로 변환해서 모으고 -&gt; 포장까지 할 수 있다.!! | . public Lottoes combine(Lottoes other) { List&lt;Lotto&gt; result = new ArrayList&lt;&gt;(); result.addAll(lottoes); result.addAll(other.lottoes); return new Lottoes(result); } // 변환후 public Lottoes combine(Lottoes other) { return Stream.concat(lottoes.stream(), other.lottoes.stream()) .collect(collectingAndThen(toList(), Lottoes::new)); } . | . | . | (리) . controller에서 input받을때의 안내문 -&gt; InputView.printException(exception); . | 미래를 예측해서 코드를 짤 필요 없다? (확장가능성을 미리 X) . | 콘솔 출력만 하는데 InputView 로 분류하신 이유가 있으실까요 ? . 사용자와 직접 커뮤니케이션 사용자의 요청을 컨트롤러로 전달 컨트롤러의 응답을 최종적으로 사용자에게 전달 콘솔 출력은 사용자에게 오류 메시지 혹은 결과를 전달하는 과정이기 때문에 View의 역할이라고 생각했습니다! 혹시 제가 조금 더 생각해봐야할 지점이 있을까요?! 😅 . | . | (후) . 컨트롤러의 코드는 시나리오로서 글처럼 읽을 수 있게 == input/output명확하게는 . 사용자 시나리오로 글처럼 읽을 수 있는 코드를 만들려고 노력하고있는데요. 이 부분은 돈을 생성하는게 아닌, 돈을 입력받는 부분이 아닐까요? . | 일급이 중복을 허용하지 않는다 -&gt; List대신 Set을 상태값으로 가져도 . 중복검사가 제거된다 -&gt; 갯수검사만 하면 됨. | LinkedHashSet을 쓰면 정렬도 | . | 도메인 검증은 도메인 기본 생성자에서 . 1~45의 숫자인게 도메인 규칙인데요. 이 부분이 &#39;생성하는 곳&#39;에서 검증되어야한다고 생각 . | inputview에서 반복해서 입력받기 가능. . 그러나 stream 작성하면 디버깅이 어려울 수도 있음. | . public static List&lt;List&lt;Integer&gt;&gt; inputManualLottos(final int counts) { System.out.println(INPUT_MANUAL_LOTTO_NUMBER); return IntStream.range(0, counts) .mapToObj(index -&gt; inputManualLotto()) .collect(Collectors.toList()); } . | (중복) 가변으로 list 추가로 받기 . 기존과 들어올 list 모두 stream으로 concat하여 불변형태로 합치기 | . | 스트림내 스트림은 가독성 -&gt; 메서드 분리 . | . | (후) . LottoNumber 정적메서드만 있는 static Factory 클래스로 싱글톤(service, cahce)를 대체하자. . 블로그 | . | LottoResult -&gt; Map을 초기화시켜놓고, 거기에 하나씩 put하는 형태인데요. 집계함수(groupingBy)도 고려해볼 수 있을 것 같아요. 🙂 . map을 put이 아니라 replace로? ㄴㄴ . //수정 전 final Map&lt;Rank, Integer&gt; rankResults = Rank.initResultMap(); for (Lotto lotto : lottos.getLottos()) { Rank rank = winLotto.matchResult(lotto); rankResults.replace(rank, rankResults.get(rank) + 1); } return new LottoResult(rankResults); . replace를 사용함으로써 initialize한 key값 외 예외적인 값이 들어올 상황을 방지 개인적으로 방어적인 코드보다, 빠른 피드백을 받을 수 있도록 예외를 던지는게 더 좋다고 생각하고있어요. 근본적으로 Rank.initResultMap();로 씨드를 만든 Map으로 put해주는 구조가 조금 특이하긴 하네요..🤔 . | . | map을 거꾸로 출력도 view에서!!해야함 - &gt; values().stream -&gt; view의 책임이라 inputView에서 . toReverseList 는 뷰에 의존적인 코드라고 생각해요. 거꾸로 순서가 필요한 건 뷰의 책임이라고 생각하는데, 뒤집어주는 건 뷰에서 처리하는게 좋을 것 같아요. . | toString()활용보다는 그냥 getter . | . | NEW_LINE = System.lineSeparator() 도 상수화 . | 역순으로 출력안하고 title만 하드코딩 + 개별요소만 get하는 sense . public class ResultView { public static void printResult(LottoResult lottoResult) { System.out.print(System.lineSeparator()); System.out.println(&quot;당첨 통계&quot;); System.out.println(&quot;&quot;); System.out.println(&quot;3개 일치 (5000원) - &quot; + lottoResult.getLottoResultByRank(FIFTH).getCount() + &quot;개&quot;); System.out.println(&quot;4개 일치 (50000원) - &quot; + lottoResult.getLottoResultByRank(FOURTH).getCount() + &quot;개&quot;); System.out.println(&quot;5개 일치 (1500000원) - &quot; + lottoResult.getLottoResultByRank(THIRD).getCount() + &quot;개&quot;); System.out.println(&quot;5개 일치 보너스 볼 일치(30000000원) - &quot; + lottoResult.getLottoResultByRank(SECOND).getCount() + &quot;개&quot;); System.out.println(&quot;6개 일치 (2000000000원) - &quot; + lottoResult.getLottoResultByRank(FIRST).getCount() + &quot;개&quot;); System.out.println( &quot;총 수익률은 &quot; + lottoResult.getRateOfReturn() + &quot;입니다.(기준이 1이기 때문에 결과적으로 &quot; + getWinOrLoseByLottoResultDto(lottoResult) + &quot;라는 의미임)&quot;); } private static String getWinOrLoseByLottoResultDto(LottoResult lottoResult) { if (lottoResult.getRateOfReturn() &gt; 1) { return &quot;이익&quot;; } return &quot;손해&quot;; } } . | 만약 역순 출력한다면? . map을 돌고 있으니, 각 요소들이 comparable 상속 중이면 .sorted(Comparator.reverseOrder()) . If your stream elements implements Comparable then the solution becomes simpler: ...stream() .sorted(Comparator.reverseOrder()) . | values()만 역순으로 하고 싶다면.. list로 바꿔서.. . List&lt;Rank&gt; ranks = Arrays.asList(Rank.values()); Collections.reverse(ranks); . | . | . docs . 어떠한 프로그램이다(요구사항), 혹은 실행결과 등도 같이 정의 . 문서에 이 프로그램이 그래서 어떠한 프로그램이다, 혹은 실행결과 등을 같이 보여준다면 프로그램을 훨씬 빠르게 이해할 수 있을 것 같아요. . 예시 . ## 요구 사항 가상으로 사용자가 로또를 구매하고 지난주 당첨 번호를 직접 입력하여 당첨이 얼마나 되는지 수익률이 몇인지 알 수 있는 프로그램입니다. - java로만 구현된 애플리케이션(jdk11버전) - 터미널에서 사용자가 구입금액, 지난주 당첨 번호를 입력하고 터미널에서 결과를 확인할 수 있다. - 로또는 1 ~ 45 중 랜덤으로 6개의 번호를 가진 로또를 발급한다. - 로또는 1장당 1000원이다. - 당첨기준은 실제 로또와 같다. ## 실행 결과 text 구입금액을 입력해 주세요.(1000원~20억원) 14000 . | ## 페어프로그래밍 컨벤션도 유지 . ## 페어 프로그래밍 컨벤션 - 10분 간격으로 역할을 바꾼다. - BDD 테스트 코드 작성 패턴으로 작성한다. - 테스트만 통과할 수 있을 정도로 TDD를 구현한다. - 커밋 단위를 README 기준으로 한다. . | . | . 네이밍 . 메서드 입력요구는 request (getMoney -&gt; requestMoney)?? 내부에서 print 로직을 포함하지 말 것 | print는 controller에서 뿌려주면 됨. | . | 상수는 재사용 뿐만 아니라 의미의 명확화의 관점도 포함된다. . 맞습니다. 깔끔하다면 계속 사용하셔도 됩니다! 다만 우리가 상수화를 할 때 단순히 재사용을 위해서 하는 것 뿐만아니라 의미를 알 수 없는 값에 이름을 부여해서 의미를 드러낸다라는 관점도 있다는 점을 알고 가시면 좋을 것 같아요! . | 사소하더라도 한 줄에는 . 1개 -&gt; stream은 한 줄씩 모두 띄워주는게 가독성이 좋은 것 같아요. 그 역할이 조금 더 뚜렷하게 보이는 것 같아서요. . public Lotto(List&lt;Integer&gt; numbers) { validateNumbers(numbers); this.numbers = numbers.stream().map(Number::new).collect(Collectors.toSet()); . 디미터의 법칙도 객체에게 메시지를 보내라!의 관점 . | 아래는 1줄에 . 1개이지만, 가독성을 위해 stream은 줄 띄우기 . map(Number::new).collect(Collectors.toSet()); . | . numbers.stream() // 스트림을 열고 .map(Number::new) // 가공하여 .collect(Collectors.toSet()); // 결과를 셋으로 만든다. . | Money가 VO가 아니라 검증이 추가되었다면 대명사 Money(X) -&gt; 로또에서만 사용되는 1_000단위의 금액 -&gt; LottoMoney로서 대명사 VO가 아니라 도메인임을 명시해줄 것 . 지금 Money는 로또를 구매하기 위한 금액이기 때문에 1000으로 나누어떨어져야한다는 제약사항이 있어요. 순수한 Money는 아니게 되는거죠. 그렇기때문에 개인적으로는 LottoMoney / PurchaseMoney 와 같이 이 금액은 구매를 위한 금액이고 제약사항이 있다라는 것을 명시할 수 있는 이름을 사용할 것 같아요. . | 특정 프로그램 패키지 안에 있더라도 클래스명에 명시 . 작은 프로그램이지만 앞으로 프로그램이 커질 때 각 클래스들의 패키지를 잘 안보게 되기도 하고, 코드 자체에서 드러나지 않기 때문에 놓치는 경우가 많더라구요. 이런 부분을 지양하고자 저는 후자를 선호합니다🙂 다만 네이밍이 길어지는 단점도 분명 존재하는 것 같습니다. . | 앞에 검증 등 포장되어있다면, 앞에 도메인명을 붙이자.! Number -&gt; LottoNumber | 포장되는 내부 인스턴스 변수를 클래스 그대로 따오지 말고 -&gt; value -&gt; getValue() . | 예외 던질때 메세지 피드백을 상세하게 어떤 값때문에 예외가 발생했는지 추가 | . | . 캐슁 . 캐슁 작업을 Lotto 생성자에서 해주다가 복잡해지니 정적 팩토리 메서드-&gt;클래스 LottoFactory로 뺐다. . 객체생성이 복잡한 경우 팩토리라는 키워드로 조금 더 공부해보시면 좋을 것 같아요. 맞습니다. 정적팩토리메소드를 통해 자동로또를 만들어낸다라는 의미를 잘 드러낼 수 있어요. 추후에 생성이 더 복잡해진다면 생성을 담당하는 LottoFactory와 같은 형태로 리팩토링하는 것도 방법인 것 같아요. . | 처음부터 미리 만들지말고, 생성할때마다 CACHE맵에서 검사후 없으면 반환 . private static final Map&lt;Integer, LottoNumber&gt; CACHE = new HashMap&lt;&gt;(); private final int number; private LottoNumber(int lottoNumber) { this.number = lottoNumber; } public static LottoNumber getInstance(int lottoNumber) { validateRange(lottoNumber); if (CACHE.containsKey(lottoNumber)) { return CACHE.get(lottoNumber); } LottoNumber newInstance = new LottoNumber(lottoNumber); CACHE.put(lottoNumber, newInstance); return newInstance; } private static void validateRange(int number) { if (isOutOfRange(number)) { throw new IllegalArgumentException(ERROR_MESSAGE_FOR_OUT_OF_RANGE_NUMBER); } } private static boolean isOutOfRange(int number) { return number &lt; MINIMUM_LOTTO_NUMBER || MAXIMUM_LOTTO_NUMBER &lt; number; } . | 캐슁은 맵을이용해라 IntStream -&gt; toMap( number -&gt; number, 그걸로 new 객체 생성자() ) . 이펙티브 자바, 아이템 28. 배열보다는 리스트를 사용하라를 한번 찾아보시는 것도 좋을 것 같네요 🙂 | . LOTTO_NUMBER_CACHE = IntStream.rangeClosed(MIN_LOTTO_NUMBER, MAX_LOTTO_NUMBER) .boxed() .collect(Collectors.toMap( number -&gt; number, LottoNumber::new) ); . 블로그 | . | . map . map 돌기: map.entrySet().stream().map( entry -&gt; entry.getKey(), entry.getValue() ) + getKey(enum)에 메서드 정의하여 추가로직 -&gt; sum() . public long getTotalProfit() { return result.entrySet() .stream() .mapToLong(entry -&gt; entry.getKey().multiply(entry.getValue())) .sum(); } . entry는 getKey()할 수 밖에 없으며, 하나의 맾핑된 key객체로서 .메서드( ) 로 메세지를 던진다. -&gt; .multiply( ) . 메서드를 어캐 정의했나 . public long multiply(int count) { return (long) price * count; } . public double getRateOfProfit(Money money) { long totalMoney = 0L; for (Map.Entry&lt;LottoRanking, Integer&gt; entry : result.entrySet()) { //요렇게도 사용할 수 있을 것 같네요🙂 public double getRateOfProfit(Money money) { long totalMoney = result.entrySet() .stream() .mapToLong(entry -&gt; entry.getKey().multiply(entry.getValue())) .sum(); return money.getRateOfProfit(totalMoney); } . | . | . | enumMap: HashMap보다 성능상에서 이점이 많은 것 같습니다. . Null값을 key로 가질 수 없다. | hashcode 충돌이 존재하지 않는다. | 단순 배열의 구조를 가진다. | Enum의 순서를 유지할 수 있다. | . 개인적으로 현재 EnumMap을 사용해서 위의 장점을 얻을 수 있다 라는 접근보단, 어떠한 코드를 구현하는데 있어서 조금 더 적절한 (그것을 위한 형태)가 있다면 사용해보는 것도 좋다라는 생각 . | findAny가 스트림이 직렬이면 findFirst와 동일하게 작동하는군요! . | (베) . 개인코드 -&gt; map초기화시 toMap() + Function.identity(), r-&gt;0이용 . private Map&lt;Rank, Integer&gt; emptyRankMap() { return Stream.of(Rank.values()) .collect(toMap(Function.identity(), r -&gt; 0)); } . | . | (리) . 비교 결과를 알아서 그룹별,갯수의 map에 담아주는 stream . private static Map&lt;Rank, LongSummaryStatistics&gt; getLottoResult(WinningLotto winningLotto, Lottos lottos) { Objects.requireNonNull(winningLotto, ERROR_MESSAGE_FOR_NULL_WINNING_LOTTO); Objects.requireNonNull(lottos, ERROR_MESSAGE_FOR_NULL_LOTTOS); return lottos.getLottos() .stream() .map(winningLotto::getRankByLotto) .collect(groupingBy(identity(), () -&gt; new EnumMap&lt;&gt;(Rank.class), summarizingLong(Rank::getPrize))); } . | map의 values()값만 sum by LongSummaryStatistics . private static long getTotalReturnByLottoResult(Map&lt;Rank, LongSummaryStatistics&gt; lottoResult) { return lottoResult.values() .stream() .mapToLong(LongSummaryStatistics::getSum) .sum(); } . | . | (후) . 누적합을 IntSream으로 변환해서 .sum() 하는게 &gt; reduce(0부터, 변환하면서 누적) 하는 것보다 깔끔하다. . IntStream 스트림을 사용하면 sum() 메서드 활용이 가능해서, 더 읽기좋을 것 같아요. 그리고 메서드체이닝(.)을 행 단위로 나눠주시면 더 읽기 좋습니다 👍 . //수정전 return rankResults.entrySet().stream().map(Entry::getValue).reduce(0, Integer::sum) * Lotto.LOTTO_PURCHASE_MONEY; //수정후 return rankResults.entrySet().stream() .mapToInt(Entry::getValue) .sum() * Lotto.LOTTO_PURCHASE_MONEY; . | . | . Factory . 개인적으로는 객체생성의 롤을 객체에게 전담하도록 하는 편이고, Lotto 와 같이 생성이 복잡한 일부분에 대해서만 팩토리를 사용하는 편이에요. 참고만 부탁드립니다 생성과 팩토리를 통한 생성 두가지가 모두 가능할 때, 이 코드를 유지보수하는 사람이 이 두가지를 적절하게 잘 이용하기 어렵다는 단점도 있을 것 같아요. 객체 생성에 대한 역할을 두 곳에서 관리하고 있기 때문에 | . | . | . test . Nested로 의미가 잘 드러나는 것 같아요🙂 . 여기서는 가독성이라는 측면이 더 중요한 것 같아요. 이 더 가독성이 좋다면 사용하시면 될 것 같습니다. | 똑같은 상태값 공유하는 것들만 다르게 setUp하는 용도로 쓰자. | . 저 개인적으로는 상태값을 공유하고 그 의미가 비슷한 것들은 @nested로 작성하고 이외에 독립적인 것들은 클래스내에 메소드로 작성하는 것 같아요🙂 - 페어와 팀원과 적절한 룰을 만들어가며 장단을 비교해가면 좋을 것 같습니다. . | . (베) . 테스트는 오히려 먼저 변수 선언 (or초기화)후 -&gt; 나중 할당하는 @beforeEach에서 초기화하기 위해 이용한 가변으로 선언 . //LottoesTest.java private static final Lotto[] LOTTOES = new Lotto[]{ Lotto.create(List.of(1,2,3,4,5,6)), Lotto.create(List.of(11,12,13,14,15,16)), Lotto.create(List.of(21,22,23,24,25,26)), Lotto.create(List.of(31,32,33,34,35,36)) }; 테스트 픽스쳐를 만들어주셨는데요. 지금은 큰 문제가 없지만 이 부분도 가변이 될 수 있어서요. 특정테스트에서 값이 변경되어 디버깅이 굉장히 어려워질 수 있습니다. 이 부분을 @BeforeEach로 빼보시는걸 추천해요🙂 . | . .copyOf() . (리) . 읽기전용을 의미하는 Collections.unmodifiableList()이라도, 원본이 바뀌면 따라 바뀐다. 할당받은 변수만 조작불가 -&gt; 원본과는 연결됨 . 생성자에서 검증에서 파라미터 원본값의 오염가능성 -&gt; 포장이 가진 내부 상태값은 연결고리를 끊고난 것을 주자. -&gt; this.value = List.copyOf() | . //수정 전 validateSize(lottoNumbers); validateDuplicate(lottoNumbers); this.lottoNumbers = Collections.unmodifiableList(lottoNumbers); //이 생성자를 사용하는 곳에서 생성자가 실행된 이후에 전달된 파라미터의 원본 값(지역변수이자 원본 값)에 list 를 조작한 뒤 디버깅을 해보시면 좋을 것 같아요 //수정 후 public Lotto(List&lt;LottoNumber&gt; lottoNumbers) { Objects.requireNonNull(lottoNumbers, ERROR_MESSAGE_FOR_NULL_LOTTO_NUMBERS); validateSize(lottoNumbers); validateDuplicate(lottoNumbers); this.lottoNumbers = List.copyOf(lottoNumbers); // 상태값에는 연결고리를 파라미터와 연결고리륵 } . unmodifiableList(anotherList) 로 선언한 참조변수, 즉 복사본 컬렉션에다가 요소를 추가거나 삭제하려고 할 경우, UnsupportedOperationException이 발생 . 그러나 원본 컬렉션에 요소를 추가 / 삭제할 경우, 복사본 컬렉션에서도 그대로 적용 . | 요약 . 원본 컬렉션과 주소값이 다르며 컬렉션 내부 요소들의 주소값은 동일하다. . | 원본 컬렉션에서 요소 추가, 삭제가 일어날 경우, 복사본 컬렉션에서도 적용된다. . | 복사본 컬렉션에서 요소 추가, 삭제를 시도할 경우 UOE 이 발생되며 실패한다. . | | . | List.copyOf(anotherList);를 통한 방어적 복사를 하려면 . 복사본 컬렉션에 대한 요소 추가 / 삭제 시도 시 UOE가 발생한다는 점은 unmodifiableList와 동일 | 그러나 원본 컬렉션에서 요소 추가 / 삭제 가 일어나도, 영향을 받지 않습니다 | 그럼에도 불구하고 copyOf()로 만들어낸 컬렉션이 완전한 불변이라고 볼 수는 없습니다. 왜냐하면 copyOf의 반환값으로 전달된 unmodifiable list에서 객체를 꺼내서, 그 객체 내부의 값을 변경할 경우, 아니면 외부에서 그 객체의 값을 변경할 경우에는 요소 까지 깊은 복사를 하지는 않았기 때문에 값이 변경됨. 원소들도 불변이여야지 완벽한 불변 | . | . | . new ArrayList&lt;&gt;(anotherList), new ArrayList&lt;&gt;() + addAll() 과 동일합니다. 컬렉션의 주소값은 달라지지만, 요소들의 주소값은 동일합니다. 따라서, 컬렉션 레벨의 요소 추가 / 삭제 는 공유되지 않지만, 요소 레벨의 요소 값 수정 등은 공유됩니다.new ArrayList&lt;&gt;(anotherList), new ArrayList&lt;&gt;() + addAll() 과 동일합니다. 컬렉션의 주소값은 달라지지만, 요소들의 주소값은 동일합니다. 따라서, 컬렉션 레벨의 요소 추가 / 삭제 는 공유되지 않지만, 요소 레벨의 요소 값 수정 등은 공유됩니다. . 공부용 코드 . package lotto; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; import org.junit.jupiter.api.Test; public class ListTest { @Test void modify_UOE() { String[] stringArray = {&quot;a&quot;, &quot;b&quot;}; // 배열 final List&lt;String&gt; stringList = Arrays.asList(stringArray); // 가변 스트링 final List&lt;String&gt; unmodifiableStringList = Collections.unmodifiableList(stringList); System.out.printf(&quot;unmodifiableStringList={}&quot;, unmodifiableStringList); // unmodifiableStringList.add(&quot;c&quot;); System.out.printf(&quot;unmodifiableStringList={}&quot;, unmodifiableStringList); } @Test void wrap_and_modify_original_and_get_unmodifiable() { String[] stringArray = {&quot;a&quot;, &quot;b&quot;}; // 배열 List&lt;String&gt; stringList = new ArrayList&lt;&gt;(Arrays.asList(stringArray)); // 가변 스트링 list //final List&lt;String&gt; unmodifiableStringList = Collections.unmodifiableList(stringList); //원본 List&lt;String&gt;을 포장해서 들고 있으면서, 반환만 Collections.unmodifiableList();시키면 UnmodifiableList unmodifiableList = new UnmodifiableList(stringList); List&lt;String&gt; returnedUnmodifiableList = unmodifiableList.getValue(); // a, b System.out.printf(&quot;returnedUnmodifiableList={ % s}%n&quot;, returnedUnmodifiableList.toString()); //add할때는 원본 list에 add -&gt; 이게 객체내부의 value에도 영향을 미칠까? stringList.add(&quot;c&quot;); // a, b, c -&gt; 원본을 고쳤는데, unmodifiableList만 못건들였지, 같이 수정됨. // -&gt; 쓰기불가지만, 컬렉션 주소를 공유 System.out.printf(&quot;returnedUnmodifiableList={ % s}%n&quot;, returnedUnmodifiableList.toString()); } @Test void wrap_and_modify_original_and_get_copyOf() { String[] stringArray = {&quot;a&quot;, &quot;b&quot;}; // 배열 List&lt;String&gt; stringList = new ArrayList&lt;&gt;(Arrays.asList(stringArray)); // 가변 스트링 list // 마찬가지로 원본을 들고 있으면서, 반환만 copyOf로 해주는 클래스 생성 final CopyOfList copyOfList = new CopyOfList(stringList); final List&lt;String&gt; returnedCopyOfList = copyOfList.getValue(); // a, b System.out.printf(&quot;returnedCopyOfList={ % s}%n&quot;, returnedCopyOfList.toString()); //add할때는 원본 list에 add -&gt; 이게 객체내부의 value에도 영향을 미칠까? stringList.add(&quot;c&quot;); // a, b -&gt; 원본을 고쳤는데도, 콜렉션주소가 공유되지 않아, returnedCopyOfList는 불변 System.out.printf(&quot;returnedCopyOfList={ % s}%n&quot;, returnedCopyOfList.toString()); } private class UnmodifiableList { private List&lt;String&gt; value; public UnmodifiableList(final List&lt;String&gt; value) { this.value = value; } public List&lt;String&gt; getValue() { return Collections.unmodifiableList(value); } } private class CopyOfList { private final List&lt;String&gt; value; public CopyOfList(final List&lt;String&gt; value) { this.value = value; } public List&lt;String&gt; getValue() { return List.copyOf(value); } } } . | . | . | . (후) . 페어 덕분에 copyOf에 대해 알게됐는데요, unmodifiable을 이용해서 반환하는 것만으로도 충분히 값 변환에 있어서 안정성을 보장할 수 있을 것 같은데 앨런은 Java 11에서 왜 Collections를 새로 생성해서 반환하는 copyOf를 만들었다고 생각하시나요? . copyOf도 unmodifiableList를 반환하지 않던가요? 😅 List.of()와 List.copyOf()에 어떤 차이가 있을까요? 둘다 불변을 보장하지만, 매개변수 받아주는 것 차이 - List.of 와 List.copyOf는 둘다 unmodifiableList를 반환하는 것은 같지만 전자는 리스트의 요소가되는 여러 매개변수를 받고 후자는 존재하는 리스트를 받아옵니다! copyOf를 사용하면 새로운 리스트를 만들어 unmodifiable로 반환 -&gt; 도메인에서 직접 unmodifiable을 사용하여 반환하는 것보다도 더 안전하게 리스트를 사용 코멘트 감사합니다! �업무에서 List.of()를 사용하고 있었는데, 조사해준덕분에 알게됐군요! copyOf를 활용 . | . for vs stream . 횟수가 적을 땐 for -&gt; 그 자체를 여러번 돌릴 땐 stream -&gt; 스레드 세이프라면 .parallel()도 선언해서..하면 더 빠르다. . | stream으로 전체 중 일부를 뽑는 랜덤을 구현 . 전체list -&gt; shuffle -&gt; stream + .limit()+ sorted() + 캐슁getInstance + tolist or .limit()대신 list상태에서 .subList() | . private static List&lt;LottoNumber&gt; getAutoLottoNumbers() { List&lt;Integer&gt; lottoNumbersForNewLotto = new ArrayList&lt;&gt;(lottoNumbers); Collections.shuffle(lottoNumbersForNewLotto); return lottoNumbersForNewLotto.stream() .limit(LOTTO_NUMBERS_SIZE) .sorted() .map(LottoNumber::getInstance) .collect(toList()); } . | .",
            "url": "blog.chojaeseong.com/java/feedback/review/%EB%A1%9C%EB%98%90/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/15/%ED%94%BC%EB%93%9C%EB%B0%B1)-1-2(%EB%A1%9C%EB%98%90)-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0.html",
            "relUrl": "/java/feedback/review/%EB%A1%9C%EB%98%90/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/15/%ED%94%BC%EB%93%9C%EB%B0%B1)-1-2(%EB%A1%9C%EB%98%90)-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0.html",
            "date": " • Mar 15, 2022"
        }
        
    
  
    
        ,"post32": {
            "title": "강의) 네오 3단계 피드백(블랙잭 상속)",
            "content": "스타버즈 커피전문점을 통한 상속 이해 . 요구사항 . Starbuzz 커피 전문점은 커피와 차를 판매한다. 커피와 차를 준비하는 과정은 각각 다음과 같다. . 커피(coffee) 물을 끓인다. | 필터를 활용해 커피를 내린다. | 컵에 붓는다. | 설탕과 우유를 추가한다. | . | 차(tea) 물을 끓인다. | 차 티백을 담근다. | 컵에 붓는다. | 레몬을 추가한다. | . | . | . 기본 클래스 2개 작성 . Coffee 클래스부터 작성한다 . 요구사항은 /* 로 시작하도록 옮겨놓는다. . . . | 테스트에서 각각의 메서드부터 작성한다. . my) 전체를 모아두는 메서드는… 각각 작성하고 통합호출시 묶어주는 것일 듯? | . . | 메서드들을 한눈에 볼 모든 메서드 호출 메서드 정의하기 . 같은 인스턴스메서드(객체 행위) 단위로서, 현재까지 만든 객체 메서드(행위들)을 모두 한번에 호출해주는 메서드도 Test에서 만든 뒤, 테스트에서의 코드를 잘라내서 내부로 가져가자 . . . | 같은 객체가 호출하던 메서드를 한꺼번에 호출할려고 가져가면, -&gt; 바깥에서 만든 객체로 호출 빨간줄 뜬다. 지워주자. 현재 class내부 = 현재 객체this가 호출하고 있는 중 . . | 모든 메서드들보다위에 위치하도록, 가장 위로 올려준다. . | 비슷한 클래스 Tea클래스도 복붙해서 작성해주자 . public class Coffee { void prepareRecipe() { boilWater(); brewCoffeeGrinds(); pourInCup(); addSugarAndMilk(); } public void boilWater() { System.out.println(&quot;물을 끓인다.&quot;); } public void brewCoffeeGrinds() { System.out.println(&quot;필터를 활용해 커피를 내린다.&quot;); } public void pourInCup() { System.out.println(&quot;컵에 붓는다.&quot;); } public void addSugarAndMilk() { System.out.println(&quot;설탕과 우유를 추가한다.&quot;); } } . public class Tea { void prepareRecipe() { boilWater(); steepTeaBag(); pourInCup(); addLemon(); } public void boilWater() { System.out.println(&quot;물을 끓인다.&quot;); } public void steepTeaBag() { System.out.println(&quot;티백을 담근다.&quot;); } public void pourInCup() { System.out.println(&quot;컵에 붓는다.&quot;); } public void addLemon() { System.out.println(&quot;레몬을 추가한다.&quot;); } } . 상속으로 중복코드제거 -&gt; 공통메서드를 부모클래스를 만들어 올려서 제거(super를 생략하고 쓰는 것) . . boilWater()와 pourInCup() 2개 메서드가 중복이다. | . 클래스 다이어그램을 통해 본 코드 중복(메서드 중복) . . 중복된 메서드만 빼내서 따로 클래스로 분리한다. | . . 01 중복메서드만을 메서드로 가지는 부모클래스 만들기 . 중복된 2 메서드를 + 각각의 클래스명을 보고 부모클래스를 만든다. . . | 중복된 메서드 2개를 복사해서 가져온다. . . package starbuzz; public class CaffeineBeverage { public void boilWater() { System.out.println(&quot;물을 끓인다.&quot;); } public void pourInCup() { System.out.println(&quot;컵에 붓는다.&quot;); } } . | 02 자식들은 상속한 뒤, 중복메서드 -&gt; 공통메서드로 올렸으니 자식에서 공메 정의부 제거 -&gt; 자식들은 자신만의 메서드만 가지고 있기 -&gt; 사용은 super.생략하고 자기것처럼 쓰기 . . 자식들이 만약 상속한 상태에서 부모가 가져간 공통메서드들을 제거해줘야한다. | 부모가 줄 공통메서드를 삭제해도 빨간줄이 뜨지 않는다. | . 03 부모한테 공통적으로 물려받아 쓰는것들에 대해서는 super.을 붙혀도 된다. . ctrl+ 클릭하면 부모로 타고 올라간다. . | 부모한테 물려받아 쓰는 것들은 super.를 앞에 달아서 부모클래스한테 물려받아 쓰고 있는 메서드라고 써도 된다. . . | . my) 추상클래스로 만든다면, 강제 각자구현용 추상메서드를 추가할 수도 있다. . 참고) 상속대신 주입하는 조합으로 중복제거 . cf) 조합을 적용하여 중복코드를 객체로 박기(정리용) . [공통(중복)메서드를 뽑은 클래스]를 뽑는후 [조합으로 중복제거] like 전략패턴 . 참고 01 공통/중복 메서드들을 잘라내기해서 뽑아낸 클래스를 따로 만든다(상속의 부모클래스) . 아래 메서드 중에 boilWater()과 pourInCup()은 다른 곳과도 중복이라 뽑아낼 준비한다. | . public class Coffee { public void prepareRecipe() { boilWater(); brewCoffeeGrinds(); pourInCup(); addSugarAndMilk(); } . public class CaffeineBeverage { public void boilWater() { System.out.println(&quot;물을 끓인다.&quot;); } public void pourInCup() { System.out.println(&quot;컵에 붓는다.&quot;); } } . 중복된 메서드들을 빨간줄 상태 | . 참고 02 중복제거하고 싶은 클래스(Coffee)를 복붙해서 클래스2(Coffee2)를 만들어 조합적용을 준비한다. . . . 참고 03 조합은, 객체 생성자로부터 외부에서 받은 전략객체같은 조합객체를 받아서 상태로 가지고 있는다 (생성자 -&gt; 상태 초기화) . 나는 CoffeeTest에서 Coffee2 생성자 자동생성을 위해 코드를 작성하고 있다. | 참고 04 조합객체.공통메서드() 들을 호출시켜 중복을 제거한다. . . public class Coffee2 { private final CaffeineBeverage caffeineBeverage; public Coffee2(final CaffeineBeverage caffeineBeverage) { this.caffeineBeverage = caffeineBeverage; } public void prepareRecipe() { caffeineBeverage.boilWater(); brewCoffeeGrinds(); caffeineBeverage.pourInCup(); addSugarAndMilk(); } public void brewCoffeeGrinds() { System.out.println(&quot;필터를 활용해 커피를 내린다.&quot;); } public void addSugarAndMilk() { System.out.println(&quot;설탕과 우유를 추가한다.&quot;); } } . my) 조합으로 중복제거란, 전략패턴 중 전략1개만 외부에서 받는 형태인 것 같다. . 추상화 . 04 공통(중복)메서드를 뽑아 extrends 일반상속으로 사용하고 있다면, 이것 부모클래스를 활용해 [나머지 개별메서들을 추상화]하는 데 활용 할 수 있다.(공통메서드 없어도 빈 공통 클래스로 뽑아만 놓는다면) -&gt; 추상화 후보들(추상메서드 후보들)을 추상화 -&gt; 뽑힌다면 추상클래스로 변경해야한다. . 공통(중복)메서드들은 100% 똑같아서 뽑아서 클래스를 만들고 -&gt; super 생략하고 니것처럼 갖다쓸 수 있게뽑은 클래스에서 정의해줬다. 공통메서드 빼기 -&gt; 상속하기 -&gt; 개별 메서드 추상화 살펴보기의 차례다 | . | 나머지 서로 다른 작업들은??? 이제 메서드 추상화 후보 -&gt; 부모클래스도 추상클래스 후보들일 확인해서 추상화 해야한다. | . | . . 중복이 아닌 메서드들을 추상화에 도전해봐야한다. | . CF) 추상클래스 되는 순간 -&gt; 객체생성X -&gt; Test코드는 에러가 난다 . 공통메서드 추출한 부모 클래스 -&gt; 객체 생성가능 . | 공통메서드 + 추상화 메서드 포함 부모클래스 -&gt; 객체 생성 불가능. 상속만 이용가능 . . | . 05 구현부는 다르지만 메서드이름만 추상화 시도 -&gt; 커피를내린다 + 티백을 담근다의 추상화 -&gt; abstract returnType 내린다() 로 추상화 in 상위클래스 . 2개 메서드를 추상화해서 추상메서드를 정의한다. . . public class CaffeineBeverage { abstract void brew(); public void boilWater() { System.out.println(&quot;물을 끓인다.&quot;); } public void pourInCup() { System.out.println(&quot;컵에 붓는다.&quot;); } } . | 06 추상메서드를 가지는 순간 -&gt; 추상클래스로 바꾼다. . 추상화한 astract 메서드를 명시한 순간부터 추상클래스로 바꿔줘야 에러가 사라진다. . . . | 나머지 메서드도 추상화해주자. . . . | . my) 추상클래스 -&gt; 공통메서드뽑은 일반부모에 + 구현부는 다르지만 메서드 이름만 추상화하여 -&gt; 자식은 extends -&gt; super생략한 체, 부모에서 정의한 공통메서드 갖다쓰기 + 추상메서드 개별구현은 override 강제하도록 하는 일부 구현강제된 부모클래스로 해석하자. . 07 추상화가 끝났다면, -&gt; 추상화전 메소드들 정의부가 아닌 사용(호출)처부터 추상화된 이름으로 변경하여 메소드 호출하도록 바꿔준다. . 추상화된 메서드들은 -&gt; 오버라이딩으로 다시 적용해야한다. 일단 둔다. | 추상화된 메서드들을의 사용처부터 이름을 바꿔준다. | . 추상화후보 메서드들이 주석처리 되서 회색상태였다. 추상화된 이름의 메서드로 호출해주자. | ​ . . 08 추상화된 메서드 정의부는 impl(오버라이딩을 impl로) -&gt; 내용 옮겨 주고 - 삭제의 과정을 가진다. . Generate -&gt; Override을 하면 너무 많은 메소드가 잡히니 implements method를 통해 추상메서드만 구현하여 오버라이딩해준다. | . 오버라이딩이 아니라 impl로 오버라이딩 . . | 기존 개별 구체메서드들의 내용을 옮겨준다 . . . | 기존 구체메서드들은 삭제한다. . . | 동일하게 다른 클래스(Tea)에서도 추메 호출부 이름바꿔주기 -&gt; 추메 정의부 impl로 내용옮겨주고 삭제하기 를 진행해준다. . public class Tea extends CaffeineBeverage{ void prepareRecipe() { boilWater(); brew(); pourInCup(); addCondiments(); } @Override void brew() { System.out.println(&quot;티백을 담근다.&quot;); } @Override void addCondiments() { System.out.println(&quot;레몬을 추가한다.&quot;); } } . public class Coffee extends CaffeineBeverage{ public void prepareRecipe() { boilWater(); brew(); pourInCup(); addCondiments(); } @Override void brew() { System.out.println(&quot;필터를 활용해 커피를 내린다.&quot;); } @Override void addCondiments() { System.out.println(&quot;설탕과 우유를 추가한다.&quot;); } } . | 09 추상화를 끝내고 -&gt; 추상화 호출부 이름변경(통일)로 인한 공통(중복)메서드가 추가로 생길 수 있다 -&gt; 다시 부모로 빼준다. . 추상화 IMPL 오버라이딩된 정의부는 서로 다르게 구현되므로 이름은 같지만 공통메서드로 볼수 없다 . | 추상화 사용처()는 이름이 자식들이 같아지므로, 공통메서드/중복메서드가 생길 수 있다 -&gt; 보이면 부모 클래스로 빼면 된다. . . . | 메서드 순서 맞춰주기(현재 추상메서드만 위에서 정의해놨을 듯..) . . | 10 extends -&gt; 정의도 안되어있는데 super생략한 체로 공통메서드를 실제 내부 or 외부에서 인스턴스가 사용 확인해보기 . 현재 Coffee클래스 . **extends로 상속하고 있다. ** super는 생략되어있지만 부모로 빼놨던 공통메서드를 내부에서 쓰고 있다 | . | . public class Coffee extends CaffeineBeverage{ @Override void brew() { System.out.println(&quot;필터를 활용해 커피를 내린다.&quot;); } @Override void addCondiments() { System.out.println(&quot;설탕과 우유를 추가한다.&quot;); } } . | **메인 메서드를 만들고 -&gt; 상속한 자식클래스 인스턴스를 만든 뒤 ** . Coffee 내부에는 정의되어있지 않지만, 부모에게 상속된 공통 메소드를 바로 호출할 수 있다. | . public class Application { public static void main(String[] args) { final Coffee coffee = new Coffee(); coffee.prepareRecipe(); // 정의 안된 메서드인데 extends 공통메서드라면 바로 사용 가능 } } . | 추상화부터 하는 방법도 있다. 정답은 없다. 처음부터 완벽하게 추상화 x -&gt; 공통처리부분이 발견될 시 처리하는게 좋다. . cf) 추상클래스 인스턴스화(=구체화) 안되는 이유: 구현부 없는 추상메서드 때문에 추상클래스가 됬으므로..ㅋ -&gt; 구현부정의와 같이 객체를 만들어줄 수도 있다. . 공통메서드를 추출한 부모클래스를 활용해서, 구현부는 다르지만 이름만 공통으로 추상화하였다 = 추상메서드 들고 있다 = 추상클래스가 부모다 &gt; 인스턴스화 안된다. . | 인스턴스화를 하려면 내부에 구현부 없이 이름만 추상화한 추상메서드를 인스턴스화 하면서, {}]중괄호 블럭로 자식클래스처럼 바로 클래스 구현하면 된다. . . | 중괄호{}로 클래스를 구현하는 것을 람다 와 동일하게 익명클래스라 부른다. . . 익명클래스를 자식클래스와 동일하게 작성하더라도, 별개의 익명클래스다 | . | . quiz) 추상클래스는 추메가 무조건 있어야할까? . 추메 없어도 된다. . | 추메 없으면 객체 생성해도될까? -&gt; 구현부없는 놈을 안가지고 있어도 객체생성은 안안된다. . 구현할 내용이 없어도 { } 중괄호 블럭 가진체로 만들어야한다. | . | . 추메를 안가지는데 추상클래스를 구현했다면 고민해봐야한다. . 추메 -&gt; 구현부는 다르지만 공메를 가진 부모클래스에서 구현부제외 이름만 추상화해놓은 것 추메가 없다? 그냥 부모가 가진 공통메서드만 super생략 갖다쓰는 일반 상속이면 된다. | | . | . 업캐스팅 vs 다운캐스팅 . 업캐스팅 = 다형성 = 추상체로 변수,파라미터,응답값 받기 . 변수/파라미터/응답Type은 추상체(up)로 받을 수 있다. 구상체들을 한번에 처리할 수 있다. . | List쓸 때 많이 쓰는 업캐스팅개념이다. . . public class Application { public static void main(String[] args) { //업캐스팅 final CaffeineBeverage caffeineBeverage = new Tea(); final List&lt;Tea&gt; list = new ArrayList&lt;&gt;(); } } . | . 다운캐스팅 = 추상체상태에서 -&gt; 구상체로 돌아가 구상체만의 메서드/상태 사용가능해진다. . 01 구상체 or 자식만의 메서드는 편하게 가질 수 있다. . Tea에 Tea만의 메서드(some_t())가 있다고 치자. . . | 02 문제는 추상체/부모형으로 업캐스팅 된 상태에서는, 개별구상체 본인이라도, 메서드를 호출이 안된다. . . 업캐스팅된 부모타입이라면, Type자체가 부모상태라 안된다. | . 03 추상체 상태의 구상체를 (다운캐스팅)하면, 자신만의 메서드를 사용할 수 있다. . . 변수를 캐스팅하려면 괄호가 2개가 필요하다. . final CaffeineBeverage beverage = new Tea(); // beverage.some_t(); //(Tea)beverage.some_t(); ((Tea) beverage).some_t(); . | . 04 문제는 엉뚱한 구상체를 다운캐스팅해도 호출()된다 == 컴파일 타임에 처리 못하는 에러 -&gt; 캐스팅에러가 무섭다. -&gt; 신중하게 써야한다. -&gt; 다운캐스팅은 instanceof + .class.cast()메서드와 함께 !! . new Coffee 인스턴스 -&gt; 추상체 -&gt; (Tea)로 다운캐스팅 해도 some_t()가 호출시 에러는 안난다 == 컴파일시 에러가 안난다. . . public class Application { public static void main(String[] args) { final CaffeineBeverage beverage = new Coffee(); ((Tea) beverage).some_t(); } } . | 하지만 돌려보면, 캐스팅 에러가 난다. . | 다운캐스팅후 자신만의 메서드호출 -&gt; 반드시 instanceof로 직접 확인하고 호출해줄 것 . public static void main(String[] args) { final CaffeineBeverage beverage = new Coffee(); if (beverage instanceof Tea) { ((Tea) beverage).some_t(); } } . | 괄호2개 캐스팅 말고 가독성을 위해 -&gt; 해당클래스.class.cast( )로 다운캐스팅해서 써도 된다. . if (beverage instanceof Tea) { Tea.class.cast(beverage).some_t(); } . | isinstanceof도 가독성을 위해 아래와 같이 수정할 수 있다. . if (Tea.class.isInstance(beverage)) { Tea.class.cast(beverage).some_t(); } . | .",
            "url": "blog.chojaeseong.com/java/%EC%83%81%EC%86%8D/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4/%EC%A1%B0%ED%95%A9/%EC%BA%90%EC%8A%A4%ED%8C%85/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/15/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EC%83%81%EC%86%8D,%EC%A1%B0%ED%95%A9,%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4,%EC%BA%90%EC%8A%A4%ED%8C%85.html",
            "relUrl": "/java/%EC%83%81%EC%86%8D/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4/%EC%A1%B0%ED%95%A9/%EC%BA%90%EC%8A%A4%ED%8C%85/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/15/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EC%83%81%EC%86%8D,%EC%A1%B0%ED%95%A9,%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4,%EC%BA%90%EC%8A%A4%ED%8C%85.html",
            "date": " • Mar 15, 2022"
        }
        
    
  
    
        ,"post33": {
            "title": "TDD 6 로또(캐슁,Factory,전략)",
            "content": "캐슁 . 19 싱글톤을 이용한 [단일객체 CACHE] 적용과 TDD . 싱글톤을 이용한 CACHE 생성 2가지 방법(정리용) . 싱글톤 생성 방법 . static final으로 클래스 CACHE변수; 선언 . 바로 옆에서 = 할당하며 초기화 or 길어서 static { 클래스변수 = } 블럭(final도 가능)에서 초기화 바로 초기화하든, static블럭에서 초기화하든 null이 아닌 상태의 캐쉬변수 | . | 이후 정팩메로만 생성된 CACHE객체 or 생성된 CACHE자료구조에서 1개만 get하여 제공 이후 기본생성자는 CACHE 최초 초기화하며 채울때만 사용됨 | . | . private static final Map&lt;Integer, LottoNumber&gt; LOTTO_NUMBER_CACHE; static { LOTTO_NUMBER_CACHE = IntStream.rangeClosed(LOTTO_NUMBER_MIN, LOTTO_NUMBER_MAX) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } private final int number; public LottoNumber(final int inputNumber) { this.number = inputNumber; } public static LottoNumber from(final String inputNumber) { final int number = Integer.parseInt(inputNumber); validateLottoNumberRange(number); return LOTTO_NUMBER_CACHE.get(number); } . | static으로 클래스 CACHE변수; 선언 (no final) . 이후 정팩메에 synchronized달아주고 . | 정펙매내부에서 초기화 한번도 안된 최초 if (CACHE == null) 상태의 캐쉬변수일 때만, 기본생성자로 CACHE변수 초기화 | 정펙매로만 생성된 CACHE객체 or 생성된 CACHE자료구조에서 1개만 get하여 제공 | . private static Map&lt;Integer, LottoNumber&gt; LOTTO_NUMBER_CACHE; private final int number; private LottoNumber(final int number) { checkNumberRightRange(number); this.number = number; } public synchronized static LottoNumber valueOf(final int number) { checkNumberRightRange(number); if (LOTTO_NUMBER_CACHE == null) { LOTTO_NUMBER_CACHE = IntStream.rangeClosed(MIN_LOTTO_NUMBER, MAX_LOTTO_NUMBER) .boxed() .collect(Collectors.toMap(lottoNumber -&gt; lottoNumber, LottoNumber::new)); } return LOTTO_NUMBER_CACHE.get(number); } . | | Test에서부터 빨간줄로 넘어가 -&gt; 캐쉬 적용하기 . 캐쉬로 받아먹으려면 싱글톤 받아주는 정펙매(getInstance())로만 가져와야한다. . 네이밍을 그렇게 했어도 기본 생성자에 넣어줄 파라미터도 받아야한다. | . | 싱글톤의 동시성 잇슈를 처리하기 위해 synchronized를 접근제한자 &lt;-&gt; static 사이에 넣어준다. . public synchronized static void getInstance(final int value) { } . | 앞으로 정펙매로만 제공되어야하므로 도메인 검증을 여기로 옮기자. . 기존 도메인테스트가 new 기본생성자()로 진행되어있으니, 그냥 두고 -&gt; 맨 나중에 도메인검증을 정팩메코드로 + 기본생성자는 private + 검증은 삭제하도록 수정하자.. | . | . public LottoNumber(final int value) { // 지금은 임시로 살려둔다. 테스트를 나중에 바꿀 때 private로 변경 + 검증삭제 validate(value); this.value = value; } public synchronized static void getInstance(final int value) { //2. 검증은 여기로 옮긴다. 왜냐면, 앞으로 CACHE정팩메로만 제공될 것이기 때문. // - 정적안에 들어가므로 검증메서드가 static으로 바뀐다. validate(value); } . | CACHE의 static변수 선언을 직접 안하고 빨간줄생성 하기 위해, . 빨간줄로 if ( == null )부터 static 초기화 를 작성해줬다. 기본생성자는 이제 여기 캐쉬생성에서만 이용되어야한다. 원래는 private으로 바꾸고, TEST다 처내야함. | . | . | static 메서드 내 자동 생성시 constant = static final이므로 그냥 field -&gt; static필드로 생성하자. | . . public class LottoNumber { private static final int MIN = 1; private static final int MAX = 45; // 자동 생성한 CACHE field (static) private static Map&lt;Integer, LottoNumber&gt; CACHE; private final int value; public synchronized static void getInstance(final int value) { validate(value); //3. 캐쉬로 제공될 static 변수; 만 선언하고 -&gt; if null일 때 = 최초에만 초기화 시켜준다. // - Map으로 만들거면 // - 중간에 .map( number -&gt; )없이 맨 나중에 toMap으로 만들면 된다. // - intStream은 Integer가 아니다. toMap에 들어가려면 .boxed() 먼저 해주고 들어가야한다. // - toMap의 2번쨰 인자는 method reference만 사용 가능하다. new LottoNumber(Number하니 안되더라) if (CACHE == null) { CACHE = IntStream.rangeClosed(MIN, MAX) //.map( number -&gt; ) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } } . | 정팩메에서 캐쉬객체 or 캐쉬 자료구조.get()한 것을 응답해준다. . public synchronized static LottoNumber getInstance(final int value) { validate(value); if (CACHE == null) { CACHE = IntStream.rangeClosed(MIN, MAX) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } // 제공은 이제 기본생성자가 아닌, CACHE에서 제공해준다. return CACHE.get(value); } . | 검증이 넘어간 캐쉬 정팩메로 생성 테스트로 마무리 . @Test void cache_create() { assertDoesNotThrow(() -&gt; LottoNumber.getInstance(6)); } . 갯수만큼 일급&lt;List&gt; 생성 -&gt; 메인로직이 도메인 생성이라 static 일급Factory 를 거치도록 기능 분리 . static Service는 재료를 받아 메인로직의 흐름을 호출 및 처리한다. **일급생성은 일급 생성자에서 하면 되지만, 일급List 생성 with Money만큼은 단순히 한번 더 포장하는 것보다 복잡하다. ** 도메인 생성 로직을 서비스가 아닌도메인Factory.메서드()를 거친 뒤 -&gt; 그 응답값(일급의 리스트)을 필요에 따라 포장하던지 해야한다. | . | 도메인 생성의 역할이므로 service로직이 아니라 도메인 로직쪽이라 서비스는 호출만 해준다. | . | 앞으로 생성의 방법이 여러갈래 (Manual/Auto)로 외부에서 주입될 가능성이 높아도 도메인Factory에서 외부 생성타입 주입을 받아주는 역할을 해준다. | . 20 Service에서 복잡한 도메인 생성( 갯수만큼 일급List 생성)을 호출한다면, service에서 호출해주는 정적Static한 도메인Facotry가 도메인로직으로서 생성을 담당한다. . Service에서 생성로직을 호출하되, 메서드는 Factory가 가져간다. 가장 정제된 원시Type을 인자로 받는다. . 사정상 여기선 정제된input으로 new LottoMonety(3000)의 포장도메인 대신 장제된 원시값인 3000(원)을 인자로 넣어준다. . **원래는 new LottoMoney(도메인)을 넣어줘야하는데, 도메인 클래스 포장은 나중에 하고 정제된 input을 가정하고 원시값으로 호출해서 점점 포장해나가므로 ** 가장 원시값을 [포장도메인VO 입력 -&gt; 도메인.getter를 내부에 호출하는] 대신 바로 쓸 수 있는 원시값을 파라미터로 일단 제공해서 생성한다. | . | . . @Test void issue_lotto_by_money() { LottoService.issueByMoney(3000); } . | . 실제 Serivce내 도메인 생성관련 모든 로직은 도메인내부or도메인Factory에 일임시킨다. . Service내에서 class부터 생성해야한다면 . class -&gt; classTest -&gt; classTest에서 메서드 빨간줄 생성 -&gt; 메서드생성 | . public static void issueByMoney(final int money) { // input으로 money -&gt; money에게 횟수로 치면 몇번이냐 물어볼 예정임. final int count = money / 1000; LottoFactory.issueByCount(count); } . | 메서드 생성이 [컨셉과 파라미터가 잡힌 경우]는 프로덕션 빨간줄로 생성하되 ClassTest 빨간줄까지 가서 메서드 생성 완료하기! . 메서드 생성을 프로덕션에서 해야할 경우, 컨셉과 파라미터가 잡힌 경우, Test에서 메서드 생성하기가 쉽지 않다. . 프로덕션에서 메서드의 컨셉과 파라미터가 잡힌 경우 -&gt; 프로덕션 빨간줄로 메서드 생성하되 ClassTest-&gt;해당 메서드호출까지 작성 완료한다. . . | 클래스 생성후 바로 ClassTest생성 -&gt; 생성 원하는 메서드 호출까지 완료한 뒤 로직 작성할 것 . . | . | . [갯수(raw숫자)만큼 반복로직]은 VO로 바뀔 것 대비 [틀을 잡아 while로 돌리기] . 차후 미래에 VO로 포장시 . public static void issueLottoByCount(final int count) { Count count = new Count(number); while (count.isNotFinished()) { count = count.decrease(); // 반복되는 단일로직 issueLotto } } . | 현재 . VO count를 0까지 허용하면서, 깍아내려가다가, 0일 때, 튕겨나가게 할 것이다. | 그전까진 내부에서 1개씩 깍으면서 반복하기 | . public static void issueLottoByCount(int count) { while (count != 0) { count-=1; // 반복되는 단일 로직 issueLotto } } . . | . 내부에서 정의될, [1개당 도메인 생성]로직도 도메인Factory내 메서드로 정의 . 프로덕션내 메서드 정의 해야한다면, 빨간줄 생성후 ClassTest에서 메서드 호출까지 완료해라고 했다. . . | 프로덕션빨간줄 생성이라면 -&gt; private이라도 public수정후 TestGenerate로 ClassTest 생성 -&gt; 메서드호출까지 완료 시키기 . 메서드의 접근제한자를 private -&gt; public으로 수정 . 나중에 다 public 메서드들 조사하면 될 듯 -&gt; 테스트에서만 사용시 삭제or Private화 시키면 될 듯 | . . | private -&gt; public 수정후에는 Test메서드로 자동생성 됨. . | 생성된 테메에서 메서드 호출까지 완료하자 . . . | 21 CACHE된 단일 객체는 -&gt; Static한 [도메인Factory]의 Static {} 블럭에서 미리 뽑아놓을 수 있다. . 재료가 되는 도메인은 의존/갖다써도/상수는 public으로 바꿔써도 된다. . . public class LottoFactory { static { //1. Factory는 재료도메인을 의존해서 사용해도 된다. // -&gt; 재료 도메인내 상수를 public으로 바꿔서 Facotry에서 같이 쓰자. //2. 캐쉬된 것들을 static 블록에 다 모아놓는다. (랜덤구현은 [메서드 호출시 shffle + subList] IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(it -&gt; LottoNumber.getInstance(it)) .collect(Collectors.toList()); } . suffle과 subList를 통한 랜덤구현을 위해 []미리CACHE된 재료만 다 static{}블럭]에서 준비한다. . 준비물들을 미리 뽑아놓고 -&gt; 상수 추출을 한다. . | split 선언 &lt;-&gt; 초기화시키면 알아서 static블럭에서 초기화시켜 미리 준비되도록 한다. . . public class LottoFactory { private static final List&lt;LottoNumber&gt; LOTTO_NUMBERS; static { LOTTO_NUMBERS = IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(it -&gt; LottoNumber.getInstance(it)) .collect(Collectors.toList()); } . | 21 정해진 갯수에서 일부 랜덤이다? -&gt; 정해진 갯수 셔플 + subList(or .limit)으로 랜덤을 구현 . CACHE(static 싱글톤)을 이용한 static {}블럭에 준비된 랜덤준비물들을 랜덤이 필요한곳에서 shuffle + subList or .limit으로 구현하기 . public static Lotto issueLotto() { //3. [랜덤한 6개 뽑기] 구현을 [미리 준비된 cache 들] -&gt; shuffle &amp;&amp; 일부뽑기로 구현한다. Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } . | random한 일급 테스트 -&gt; getter후 size + 제한된 범위(단일객체의 경계값) 검사 . @Test void issueLotto_count() { final Lotto lotto = LottoFactory.issueLotto(); assertThat(lotto.getValue().size()).isEqualTo(6); } @Test void issueLotto_range() { final Lotto lotto = LottoFactory.issueLotto(); final ListIterator&lt;LottoNumber&gt; lottoNumberIterator = lotto.getValue().listIterator(); while (lottoNumberIterator.hasNext()) { assertThat(lottoNumberIterator.next()) .isGreaterThanOrEqualTo(LottoNumber.getInstance(1)) .isLessThanOrEqualTo(LottoNumber.getInstance(45)); } } . 22 다시 [횟수만큼 반복되는 도메인생성] 메서드 처리 . 단일 생성의 테스트를 마쳤다. . public static void issueLottoByCount(int count) { while (count != 0) { count -= 1; LottoFactory.issueLotto(); } } . | . 2번 이상의 add라면, 지역변수 가변 new ArrayList에 add해서 반환 . count만큼 반복해서 로또 발급후 add해서 반환해야한다. . public static ArrayList&lt;Lotto&gt; issueLottoByCount(int count) { final ArrayList&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (count != 0) { count -= 1; lottos.add(LottoFactory.issueLotto()); } return lottos; } . | 테스트에서, 랜덤한 3개 로또 발급에 대해 갯수정도만 테스트한다. . 단일 생성 테스트보다 더 밑으로 테스트를 옮겨주자. | . @Test void issue_by_count() { LottoFactory.issueLottoByCount(3); } . @Test void issue_by_count() { final List&lt;Lotto&gt; lottos = LottoFactory.issueLottoByCount(3); assertThat(lottos.size()).isEqualTo(3); } . | . 23 다시 Service로 돌아와 응답값 만들고 -&gt; 메서드 퉁 테스트 . public static List&lt;Lotto&gt; issueByMoney(final int money) { // input으로 money -&gt; money에게 횟수로 치면 몇번이냐 물어볼 예정임. final int count = money / 1000; return LottoFactory.issueLottoByCount(count); } . @Test void issue_lotto_by_money() { final List&lt;Lotto&gt; lottos = LottoService.issueByMoney(3000); assertThat(lottos.size()).isEqualTo(3000 / 1000); } . 서비스의 메인로직 진행 중 추가 로직(비교&amp;검증)이 발생하는데, 도메인의 영역이라면? -&gt; 대상들을 포장에 포장이라도 새로운 도메인으로 . 24 Service메서드 [파라미터들의 검증로직에 의한 개별 포장] 끝났는데, 또 [추가 검증 로직]이 서비스에 늘날려고 한다? . 포장된 일급과 단일의 검증인데도 또 포장? . **당첨로또와 보너스볼 번호는 중복되면 안되며므로 추가 검증 로직이 필요하고, 항상 붙어다닌다 -&gt; 2개 상태값을 가진 포장체 ** Lotto인데 굳이 포장해야하나? -&gt; 추가 검증이 필요하므로 일급vs단일의 검증인데도 2개 인변가지는 도메인으로 새로 포장 해야한다. 안그러면 서비스 ( or 컨트롤러)에 로직이 늘어난다. | . | 포장하기 전, [ service 테매 복붙]하고 case반영한 테메이름 바꾸고 -&gt; 메서드 추가해주기 . 테메 복붙해서 case반영해서 이름 바꿔주기 . | 포장해서 만들어나간다. . | 포장 도메인 만들어놓고, 생성자만 처리해준다. . 일단 하나는 value + 하는 구체적인 이름으로 적었다. | . public class WinningLotto { private final Lotto value; private final LottoNumber bonusNumber; public WinningLotto(final Lotto value, final LottoNumber bonusNumber) { this.value = value; this.bonusNumber = bonusNumber; } } . | 새롭게 포장된 파라미터를 받는 (차후 새 기준이 될)메소드도 추가 -&gt; 가장 위로 올린다. . 메서드 이름은 같고… 파라미터만 다른게 쌓여나간다. . 이놈이 새로운 | . . | 새 기준이 될 메서드를 가장 위로 올려보자. . . | . 직전 기준 메소드의 내용을 복붙 -&gt; 포장된 파라미터에 맞추어 빨간줄을 없앤다. (주로 getter로 임시처리) . 직전의 파라미터명과 비교해서 맞춰준다. | . 포장전 객체앞에다가 새롭게 포장.getter()을 통해 에러를 없앨 수 있다. . . | 포장 + 포장파라미터메서드 생성 -&gt; 새 기준 메서드로 지정하기- &gt; 전 메소드는 전 파라미터 -&gt; 포장후 호출하도록 변경 . . . public class LottoService { public static Rank match(final Lotto userLotto, final WinningLotto winningLotto) { final int matchCount = userLotto.match(winningLotto.getValue()); final boolean matchBonus = userLotto.contains(winningLotto.getBonusNumber()); return Rank.of(matchCount, matchBonus); } public static Rank match(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { return match(userLotto, new WinningLotto(winningLotto, bonusNumber)); } . 포장에 원하던 [생성자에 검증 로직 추가]후 테스트하기 . public WinningLotto(final Lotto value, final LottoNumber bonusNumber) { if (value.contains(bonusNumber)) { throw new IllegalArgumentException(&quot;당첨 번호와 보너스볼은 중복될 수 없습니다.&quot;); } this.value = value; this.bonusNumber = bonusNumber; } . 서비스에서 | . 서비스로 퉁 치던 테스트를 [도메인Test] 생성시 [경계값Test]하기 . WinningLottoTest 만들어서 경계값 테스트하기 . @ParameterizedTest @CsvSource({&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;}) void duplicate(final int bonusNumber) { assertThatThrownBy(() -&gt; new WinningLotto( new Lotto(1, 2, 3, 4, 5, 6), new LottoNumber(bonusNumber))) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;중복&quot;); } @ParameterizedTest @CsvSource({&quot;7&quot;, &quot;8&quot;, &quot;45&quot;}) void valid(final int bonusNumber) { assertDoesNotThrow(() -&gt; new WinningLotto( new Lotto(1, 2, 3, 4, 5, 6), new LottoNumber(bonusNumber))); } . | 새 기준 메서드에 임시처리(포장.getValue) 부분 메세지로 보내기 (과정) . 기존 임시처리 . public static Rank match(final Lotto userLotto, final WinningLotto winningLotto) { final int matchCount = userLotto.match(winningLotto.getValue()); final boolean matchBonus = userLotto.contains(winningLotto.getBonusNumber()); return Rank.of(matchCount, matchBonus); } . | . getter()를 제거해서 빨간줄을 낸다. . . | 기존 사용처에 대해 바로 변경이 아니라 메서드 생성 -&gt; 내부 내용 복사를 통해 백업한 체로 진행한다. . 이 경우, 새로운 메서드를 정의해주고, 기존 메서드 바로 밑으로 가져와서 비교하며 처리한다. | . . . | 새로운 기준을 만들어 나가며, 완성대면 완전히 대체한다. . //public int match(final Lotto other) { // return (int) other.value.stream() // .filter(this::contains) // .count(); //} public int match(final WinningLotto winningLotto) { return (int) winningLotto.getValue().value.stream() .filter(this::contains) .count(); } . | 나머지도 . //public boolean contains(final LottoNumber number) { // return value.contains(number); //} public boolean contains(final WinningLotto winningLotto) { return value.contains(winningLotto.getBonusNumber()); } . | 새 기준 메서드로 바꿨음에도 [기존메서드]가 다른데서 사용중인지 보고 가서 처리한다. . . 못바꾸는 부분이 있다면 그대로 둔다. | . 단일 결과의 메인로직(도1 vs 도2)을 여러번 돌리며 [결과값을 모으는 자료구조]도 포장하는 로직 . match()를 내부에서 여러번 호출하여 발생하는 것들을 map에 모아서 controller 응답한다. . | 결과값 map에 대한 계산로직도 포함될 예정이므로 생성될 자료구조(map)을 생성자에서 생성후 -&gt; 변수 포장하도록 class로 뺀다. . | . 25 단일결과by메인로직(도메인1 vs 도메인2)을 바깥에서 여러번 호출해서 발생하는 결과값을 저장할 새로운 자료구조가 나온다. -&gt; [결과값 저장 로직]을 생성자로 넘겨 -&gt; [최종 결과값 자료구조를 시작 상태값]으로 가지면서 + 관련로직을 메서드로 가지는 도메인3(Result도메인) 만들기 . 단일결과 로직(도메인1 vs 도메인2)인 메인 메서드의 파라미터 포장까지 완료된 상태여야만 -&gt; 바깥에서 여러번 돌릴 때, 포장된 것을 받을 수 있음 . 내부 단일결과를 유발하는 메인로직 메서드의 파라미터가 이미 포장이 끝났다. -&gt; 바깥에서 개별 결과값을 모으는 메서드도 포장된 값을 받는다. . 단일 결과(Enum)을 응답하는 메서드는 파라미터를 포장된 것을 받는다. | 바깥에서 결과값들을 모을 메서드 -&gt; 포장된 것을 받아야 편하다. | . @Test void get_result() { //1. 메인로직(match)를 여러번 호출해서 결과값을 받을 Service.메서드 // -&gt; 메인로직에 필요한 파라미터(Lotto여러개 + WinningLotto)는 넘겨줘야한다. final List&lt;Lotto&gt; lottos = List.of( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1, 2, 3, 4, 5, 7), new Lotto(1, 2, 3, 4, 7, 8) ); //0. 내부 메인로직(도1vs도2)의 파라미터 포장까지 완료되었을 때, // -&gt; 바깥에서 복수의 포장을 받아, 여러번 돌려 -&gt; 결과값을 저장할 수 있다. LottoService.getResult(lottos, new WinningLotto( new Lotto(1, 2, 3, 4, 5, 7), new LottoNumber(6))); } . | . 일단은 Service.Method내부에서 [메인로직을 돌리기]를 정의를 하다가 -&gt; 필요에 의해 옮기고 포장하자. . 현재 Service.getResult( , )에서 자료를 받아서, 현재는 서비스에서 호출하고 있던 메인로직(도1vs도2 비교)를 호출도 한다. . public static void getResult(final List&lt;Lotto&gt; lottos, final WinningLotto winningLotto) { //2. 일단 service내부에 도메인 계산로직을 작성한다. final List&lt;Rank&gt; results = lottos.stream() // 3. Service를 통해 돌리다보니, 1:1 단일결과(메인로직)을 호출할 수 밖에 없는데 // -&gt; 돌리는 이것 역시 서비스에서 호출하는 메서드였다. // -&gt; 만약, 결과값 모으는 곳으로 간다면 바뀌어야할 것 같다. .map(lotto -&gt; match(lotto, winningLotto)) .collect(Collectors.toList()); } . | 26 [결과값을 모은 List를 카운팅하는 새로운 응답(자료구조)] 만들기 . 단일 결과값들을 돌아가며 호출결과값 List를 모은다. | . Enum List -&gt; EnumMap에 카운팅하기(정리용) . List&lt;객체&gt;의 갯수를 객체를 key로 하는 hashMap Map&lt;객체, Integer&gt; 에 세야한다. | . 빈 Map 선언 및 초기화 . 객체의 Count을 원한다면 **&lt;객체key, Integer&gt;로 Map을 선언한다. ** (cf) 원시적으로는 직접 0으로 초기화 한다.) . EnumMap이라면 ( )생성자에 안에 Enum클래스.class(클래스 자체)를 지정해준다. | . final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); . 참고) . (원시적) 모든 객체key들 stream화해서 돌면서 -&gt; forEach -&gt; map.put(객체key, 0)으로 초기화해준다. . private final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); { Arrays.stream(Rank.values()).forEach(rank -&gt; result.put(rank, 0)); } . | . | EnumMap는 넣고난 뒤, 자동정렬되어있지만 . 일반map넣고 난 뒤, key순으로 정렬되어야하면(순서가 중요하면) hashMap대신 -&gt; linkedHashMap을 사용한다. | . private final LinkedHashMap&lt;Rank, Integer&gt; value = new LinkedHashMap&lt;&gt;(); . | . | 일급vs단일 로직을 먼저 수행한 -&gt; 응답결과List를 카운팅하는 3가지 방법 . 이제 갯수를 셀 결과값List(Enum List or 객체 List)들을 돌면서 카운팅한다. . 결과List(객체List)를 먼저 계산 -&gt; 돌면서 -&gt; . 이미 0으로 초기화해놓고 넣어놨어야한다. | map.put( 객체Key, map.get( 객체key )의 value + 1 ) | . { Arrays.stream(Rank.values()).forEach(rank -&gt; result.put(rank, 0)); } . result.put(rankPrize, result.getOrDefault(rankPrize, 0) + 1); . | 결과List(객체List)를 먼저 계산 -&gt; 돌면서 -&gt; . 미리 0 초기화 없이 알아서 직전value(없으면 0부터) 누적해주는 -&gt; map.merge( 객체key, 누적해넣을값, Integer.sum()으로 기존value와 누적방법 Bifunction ) | . result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after)) . final List&lt;Rank&gt; results = lottos.stream() .map(lotto -&gt; match(lotto, winningLotto)) .collect(Collectors.toList()); final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); results .forEach(rank -&gt; result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after))); . 결과값을 찍어보니 merge로 카운팅이 1개씩 잘 된다. | . | | EnumMap은 아니지만, 일급vs단일 –stream–&gt; 단일vs단일 결과값(객체key)을 뽑아낼 로직 + 카운팅을 동시에 해주는 일급.stream().collect(Collectors.groupingBy( 객체key를 뽑아낼 로직 , summingInt( value -&gt; 1) ) . 결과값List를 뽑는 로직 조차 일급.stream -&gt; 단일vs단일로 객체Key뽑기로직이 내부에 포함됨 . 결과값List를 미리 뽑지 않는다. -&gt; Collectors.groupingBy( , )의 **첫번째 인자에 ** | . // (1)결과값 List를 미리 뽑는 과정 -&gt; 생략됨. //final List&lt;Rank&gt; results = lottos.stream() // .map(lotto -&gt; match(lotto, winningLotto)) // .collect(Collectors.toList()); // (2) map을 미리 선언해두기 -&gt; 생략됨 //final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); // (3) 결과값List를 돌면서 -&gt; merge로 1씩 카운팅 -&gt; 생략됨 //results.stream() // .forEach(rank -&gt; result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after))); // 일급을 돌면서 -&gt; groupingBy(단일vs단일의 [결과값 = 객체key]를 뽑는 로직 , 1씩 누적합하는 로직) return lottos.stream() .collect(Collectors.groupingBy( lotto -&gt; match(lotto, winningLotto), Collectors.summingInt(value -&gt; 1))); . | 27 결과값을 모은 List를 카운팅하는 새로운 응답(자료구조)을 포장하는데 그 생성 과정을 생성자에 넣어서 시작부터 상태값으로 가지자 . 현재 상황 . public static Map&lt;Rank, Integer&gt; getResult(final List&lt;Lotto&gt; lottos, final WinningLotto winningLotto) { return lottos.stream() .collect(Collectors.groupingBy( lotto -&gt; match(lotto, winningLotto), Collectors.summingInt(value -&gt; 1))); } . | . 응답값 포장하기 . returntype 빨간줄 수정 -&gt; 생성 | 결과산출 로직은 포장결과값 생성자로 가져가되, new 포장결과( ) 로 생성되도록 재료추출은 있어야함. . . 대박) 메서드추출로 new 포장( , ) 생성자 or 결과class 정펙매 생성자 호출과 동시에 재료 추출하기 . . . 밖으로 나가서 아무거나 타자치면 invalid해도 완성된다. . . | . 새로운 응답값 을 시작부터 상태 관리되도록 생성자에서 처리해주고 초기화하도록 잘라내서 가져가기 . 기존에 추출된 새로운 응답값 자료구조 추출 로직을 -&gt; 결과값 포장클래스의 생성자로 가져간다. . . | 가져와서 파라미터 부분 + 내용부분만 잘 가져다 생성자로 만든다. . . | 서비스 정의된 에서 단일vs단일 메인 결과값match 로직을 서비스에서 -&gt; 결과 도메인인 여기로 가져오자 . . . . | 이제 생성자에서 뽑아진 result를 상태값으로 가지기 . . . public class LottoResult { private final Map&lt;Rank, Integer&gt; value; public LottoResult(final List&lt;Lotto&gt; lottos, final WinningLotto winningLotto) { final Map&lt;Rank, Integer&gt; value = lottos.stream() .collect(Collectors.groupingBy( lotto -&gt; match(lotto, winningLotto), Collectors.summingInt(count -&gt; 1))); this.value = value; } public static Rank match(final Lotto userLotto, final WinningLotto winningLotto) { final int matchCount = userLotto.match(winningLotto); final boolean matchBonus = userLotto.contains(winningLotto); return Rank.of(matchCount, matchBonus); } . | . | 새 결과값 포장이 끝났으면, Serivce 메서드 테스트 다시 해보기 . @Test void get_result() { //1. 메인로직(match)를 여러번 호출해서 결과값을 받을 Service.메서드 // -&gt; 메인로직에 필요한 파라미터(Lotto여러개 + WinningLotto)는 넘겨줘야한다. final List&lt;Lotto&gt; lottos = List.of( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1, 2, 3, 4, 5, 7), new Lotto(1, 2, 3, 4, 7, 8), new Lotto(1, 2, 3, 4, 7, 8), new Lotto(1, 2, 3, 4, 7, 8) ); final LottoResult result = LottoService.getResult(lottos, new WinningLotto( new Lotto(1, 2, 3, 4, 5, 7), new LottoNumber(6))); System.out.println(result); System.out.println(); } . . 28 결과값 포장Result class의 자체 테스트 . [새로운 응답값 생성로직]이 담긴 [생성자 자체 테스트] with [view에서 쓰일 수도 있는? 삭제될? Count getter(객체key)개발] . 결과값 Map을 만들 재료 중 일부만 setup에 준비한다. 여러 재료라면 가변쉬운것을 테스트에서 -&gt; 많고 복잡한 것을 setup에 고정 . class LottoResultTest { List&lt;Lotto&gt; lottos; @BeforeEach void setUp() { //new LottoResult(lottos, winningLotto); //새로운 응답값 생성(결과값 포장 클래스 생성자)에 필요한 재료 먼저 선언 // -&gt; case별 변동이 쉬운 winningLotto는 놔두고, lottos를 미리 만들어놓자. lottos = List.of( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1, 2, 3, 4, 5, 7), new Lotto(1, 2, 3, 4, 7, 8), new Lotto(1, 2, 3, 7, 8, 9) ); } . | count Map이라면, 맘 편하게 .getCount( 객체key )를 맘편하게 만들자 . 뷰에서 쓸 일 있으면 쓰고, 없으면 삭제하면 된다. default를 0으로 해서 count인 value값을 가져오자. . public Integer getCountByRank(final Rank rank) { return value.getOrDefault(rank, 0); } . | . | 해당 key의 Count를 꺼내와서 정확한지 확인하기 . 할수 있다면, debug 활용해서 내부값 까보면서 같이하면 될 듯. | . @Test void create() { //given -&gt; 1등이 1개 있도록 가정인자를 만들어줌 final LottoResult lottoResult = new LottoResult(lottos, new WinningLotto( new Lotto(1, 2, 3, 4, 5, 6), new LottoNumber(7) )); // map이 세고 있던 객체key를 넣어주고 -&gt; Count를 반환하는 메서드 개발 //when final Integer actual = lottoResult.getCountByRank(Rank.RANK_1); //then assertThat(actual).isEqualTo(1); } } . | 29 새응답 결과값(map)에 계산 로직 더하기 . Service에서 controller로 반환되므로 자체 ResultTest에서 시작 . ServiceTest가 아니라 ResultTest 추가 로직 메서드 개발 시작 | countMap 처리 deafult : value.entrySet() .stream() .map() . CountMap을 돌 때, 기본적인 으로 작성해서 돌아보자 . public void getPrize() { value.entrySet() .stream() .map() } . | map( -&gt; ) 로직에서 getter등장으로 보내야한다면 -&gt; 옆에 값도 같이 보내자. enum.getter * count(it.getValue()) -&gt; enum.메세제( it.getValue() ) . map안에서 enum.getXXX() * count숫자 를 계산해야하는데, getter대신 메세지보낼 때, 같이 보내버리자. . . | 없던 Enum필드도 this.필드명을 바로써서 빨간줄로 바로 생성 . 아직 상금필드를 enum에 정의 안해뒀다. this.필드명을 기입해서 빨간줄로 생성해버리자. . . . . . | ​ ​ . it.getKey()의 enum으로 메세지 보내도록 작성완료 | 누적한다면, matToInt( ) .sum() 일까? map().reduce( )일까? . map()으로 반환받은 int(stream&lt;Int&gt;)는 .sum()이 안된다. . | matToInt()로 반환받은 IntStream만 .sum()의 누적함수 적용된다. . . | . reduce의 불편함과 초기값장점 . mapToType - sum()이 아닌 경우 -&gt; map의 returnType에 따라 reduce(누적)에 type에 맞는 합(누적할연산자)메서드를 직접 넣어준다. . . | 직접 메서드와 초기값을 지정해주지만, stream이 비었어도 에러가 안나고 defaul값이 나온다. . . | . mapToType -&gt; .sum()의 편리함과 불편성(?-&gt; 없다) -&gt; 편한 것 쓰면 될듯 . mapToInt를 써서, .sum()할 stream이 없을 때에도 0이 default로 전달된다. . . | . 30 countMap에 NONE객체 존재 + orElse(NONE)가 있어야하는 이유 -&gt; 전체 갯수도 셀 수 있다. . 당첨못함 : 14명 / 1등: 1명 / 2등: 2명 -&gt; 총 17명의 갯수.. 만약 당첨 못했다고 안셌으면.. ㅠ_ㅜ 전체 로또 갯수를 셀 수 없게 된다. | . | . NONE(여기선 OUT)객체는 존재해야하며, 다른 것이 해당 없을 때도 반환되어야한다. . public enum Rank { RANK_1(2000_000_000, ((matchCount, matchBonus) -&gt; matchCount == 6)), RANK_2(30_000_000, (matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; matchBonus), RANK_3(1_500_000, (matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; !matchBonus), RANK_4(50_000, (matchCount, matchBonus) -&gt; matchCount == 4), RANK_5(5_000, (matchCount, matchBonus) -&gt; matchCount == 3), OUT(0, (matchCount, matchBonus) -&gt; matchCount &lt; 3), // 1. ; //... public static Rank of(final int matchCount, final boolean matchBonus) { return Arrays.stream(values()) .filter(it -&gt; it.condition.test(matchCount, matchBonus)) .findAny() .orElse(OUT); // 2. } . | 로또 전체 갯수를, NONE객체 포함한 COUNTMAP을 통해 구할 수 있다. . values()에 모든 로직이 counting 포함되어있따. . . public long getPrize() { final long totalPrize = value.entrySet() .stream() .mapToLong(it -&gt; it.getKey().getPrize(it.getValue())) .sum(); // 전체 로또 구매수를 countMap의 NONE까지 같이 센다. // -&gt; enum처럼 map도 둘다 values().stream 자동완성으로 돌 수 있다. final int purchasePrice = value.values().stream() .mapToInt(it -&gt; it) .sum() * 1000; return totalPrize; } . | . | long / int라도 둘자 정수니 한쪽에 (double)만 씌우면 된다. . // long vs int 든, int vs int든 나누기가 들어가면 한쪽에 (double)을 씌우자. return totalPrize / (double) purchasePrice; . public double getPrize() { final long totalPrize = value.entrySet() .stream() .mapToLong(it -&gt; it.getKey().getPrize(it.getValue())) .sum(); final int purchasePrice = value.values().stream() .mapToInt(it -&gt; it) .sum() * 1000; return totalPrize / (double) purchasePrice; } . | 31 나눗셈(하나 double)의 Test return되는 것과 같이 구성해버리기 . 0.0을 넣어도 되긴 하지만 당첨금(long) 0L / (double) 구입금액(int) 4000 으로 똑같이 줘서 구성하면 된다. | . @Test void name() { // create 테스트에 쓰던 것 그대로 활용 final LottoResult lottoResult = new LottoResult(lottos, new WinningLotto( new Lotto(11, 12, 13, 14, 15, 16), new LottoNumber(7) )); final double prize = lottoResult.getPrize(); //숫자 비교도 return되는 타입이랑 동일하게 expected주기 // -&gt; totalPrize / (double) purchasePrice; assertThat(prize).isEqualTo(0L / (double) 4000); } . 단위가 정해져 있는 것의 포장( LottoMoney ) . (1) 단위보다 작은지 검사 -&gt; (2) % 단위로 나눈 나머지 !=0 검사 . private static void validate(final int value) { if (value &lt; DIVIDE_UNIT) { throw new LottoMoneyLessException(value); } if (value % DIVIDE_UNIT != 0) { throw new LottoMoneyDivideException(value); } } . 32 대상의 필요성 확인후 포장 시작 . 메서드 실행시 정제된 input으로 money가 왔다고 가정했다. -&gt; 근데 실제로 필요한 건 money / 단위로 산출되는 횟수가 필요하다. . @Test void issue_lotto_by_money() { // new Money(3000) 예약 final List&lt;Lotto&gt; lottos = LottoService.issueByMoney(3000); // money.메세지() 보내서 횟수를 반환받아 그만큼 반복할 예정 assertThat(lottos.size()).isEqualTo(3000 / 1000); } . count도 뽑아내야한다. count도 결국엔 포장해야할 듯. | . public class LottoService { public static List&lt;Lotto&gt; issueByMoney(final int money) { // input으로 money -&gt; money에게 횟수로 치면 몇번이냐 물어볼 예정임. final int count = money / 1000; return LottoFactory.issueLottoByCount(count); } . | . Test에서 포장 시작( 정정: Money -&gt; LottoMoney ) . Test에서 빨간줄로 시작하며 생성하기 . public class Money { private final int money; public Money(final int money) { this.money = money; } } . | 참고) 포장으로 파라미터 달라지는 메테(포장-&gt;자동생성-&gt;끌올-&gt; 내용복붙후 새기준) vs case늘릴려고 복사해서 만드는 테메+메서드2(테매 복-&gt;case반영-&gt;메서드2복 -&gt;메서드2수정-&gt;메서드2통과-&gt; 메서드1대체하여 삭제) 등..은 서로 다른 것 . 생성한 예비 새 기준메서드를 기존메서드 위로 위치를 올린 뒤, 내용 복붙 -&gt; 포장한 것으로 처리되도록 -&gt; 기존메서드는 포장용으로 변경 . 메서드 파라미터를 바꾸는게 아니라, 메서드2로 생성하고 새 기준 메서드가 되도록 포장 파라미터로 처리되도록 한다. . 생성한 예비 새 기준메서드를 기존메서드위로 위치를 이동 | . . . . | ​ . 새메서드의 내용을 포장된 것으로 바꿀 때, 기존값.getter()로 대체해도 되지만 -&gt; 바로 [기존값으로 연산] -&gt; 포장.메서드() -&gt; 포장 내부에서 [this.값으로 연산]하도록 처리해야한다. . 기존메서드의 내용을 복붙해온 뒤 -&gt; 포장파라미터에 맞게 수정해준다. 필요시 getter를 처리했었는데를 연산이 바로 보이는 곳에서는 .메서드()로 처리 해줘도 된다. . . . | ​ . ​ . 기존메서드는 내부에서 파라미터포장+ 새기준 호출만 -&gt; 기존내용은 다 삭제 - &gt; 회색으로 안쓰인다면 버려도 됨. . . 기존메서드가 테스트 등에서도 안쓰이니 삭제 | . 줄어드는 횟수Count VO의 포장(정리용) . 33 count(VO, hasNext패턴 가진 것) 포장 . 미리 원시값도 줄어들 때 hasNext패턴을 만들어두었다. . 내 패턴으로는 0을 허용하면서 더 큰 n부터 줄어들되 0이 아닐때까지, 즉, 1까지도는 것이다. | . public static List&lt;Lotto&gt; issueLottoByCount(int count) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (count != 0) { count -= 1; lottos.add(LottoFactory.issueLotto()); } return lottos; } . 메서드에서부터 파라미터로 전해지도록 Count 포장 (포장은 테매 인자에서부터~ ) . 이름은 도메인Count로 만들어야한다. 포장하는 순간, 대명사가 아니다. . . | . 포장하기 . public class LottoCount { private final int value; public LottoCount(final int value) { this.value = value; } } . | VO는 equals/hC부터 . . count VO는 0까지는 허용해주도록 검증을 만든다. (for while문에서 0까지 간 뒤 0에서 탈출시킴) . public LottoCount(final int value) { if (value &lt; 0) { throw new IllegalArgumentException(&quot;0보다 작을 수 없습니다.&quot;); } this.value = value; } . 새기준메서드 새로 만들어, 기존메서드 위로 위치이동후, 내용복붙후, 처리 . . . . . 값자리에는 포장.getter()를 -&gt; 연산이 할만하면 바로 메세지를 . . . . 값의 연산 -&gt; 포장 안으로 잘라들고가서 this.값으로 연산 . getter지우고 메세지보내기 만약, 지우고 빨간메서드가 남아있다면 그대로 정의해도 된다. | 여기선 연산!=0이 남아있으니, 그에 맞는 의미있는 메서드를 지어준다. 0=Finish가 != 아직 Not이냐 | 남은 연산을 잘라내서 -&gt; 메서드만들고 -&gt; 내부에서 this.값으로 잘라낸 연산 처리 | . | 값의 재할당 -&gt; VO에서는 연산만 들고 들어가면서 메서드를 만들고, 포장 = 는 그대로 둔다. -&gt; 내부에서는this.값으로 연산한 뒤 =에 대해 새VO로 응답하는 [메세지]로 작성한다. . -= 1을 포장 처리하려면 . -1 을 내부로 들고 들어가서 this.값 -1으로 연산 | =은 새 VO를 반환 | . . . | = 놓아두고, -1만 들고 들어가면서, 연산과 관련된 메서드명으로 메세지를 보낸다. . . . . . | 연산을 들고들어갔더라도 바깥에서는 포장변수 = 이 새 VO응답을 기다리고 있으므로 내부연산 결과를 포장해서 응답해준다. . . . final을 풀어 재할당 가능하게 해준다. | . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(LottoFactory.issueLotto()); } return lottos; } . 포장전 기존메서드가 사용중이면 찾아가서, 수정해준다. . . . count가 사용중인데, 일단 money.getCount()의 반환값도 원시count으로 바꿔준다. . public int getCount() { return this.money / 1000; } . . public LottoCount getCount() { return new LottoCount(this.money / 1000); } . public static List&lt;Lotto&gt; issueByMoney(final Money money) { final LottoCount count = money.getCount(); return LottoFactory.issueLottoByCount(count); } . | . 새 기준메서드 완성시, 포장검증을 메서드로 퉁치는 테스트(-1이하에서 에러) . . 자체 도메인Test생성후 Count VO 검사 . 0까지 허용하여 음수 생성자 에러 | . @Test void create() { assertAll( () -&gt; { assertDoesNotThrow(() -&gt; new LottoCount(1)); assertDoesNotThrow(() -&gt; new LottoCount(0)); assertThatThrownBy(() -&gt; new LottoCount(-1)); } ); } . 1개 뽑 + 감소된 것 뽑 -&gt; 감소된 로직후 동일한지 비교 | . @Test void decrease() { final LottoCount lottoCount = new LottoCount(1); final LottoCount expected = new LottoCount(0); // 감소된 것 미리 뽑기 final LottoCount actual = lottoCount.decrease(); assertThat(actual).isEqualTo(expected); } . 랜덤구현 -&gt; 전략패턴으로 수동 더하기(정리용) . 34 [랜덤 최소단위 메서드]를 전략메서드로 바꿔 [수동]도 가능하게 하기 . 전략부위가 만약, 메서드화 안되어있으면(ex&gt;조건식) 메서드화 (추출 등) . 메서드명을 랜덤+수동다 포함하는 일반화 + 목적어 뺌(전략인페+구현전략들에 명시됨)된 전략메서드로 바꿔주기 | . 랜덤 최소단위 메서드 정의부 -&gt; 호출()부 찾기 . 랜덤 메서드 정의부 찾기 . | 랜덤 메서드의 호출부 찾기 . | ##### 랜덤 메서드 호출부에서 랜덤 메서드명을 -&gt; 수동포함하는 일반화된 전략메서드명() + 목적어 제거으로 변경 -&gt; 전략인페를 상속한 new 랜덤전략구현체 객체(). 전략메서드() 인척 빨간줄 생성해주기 . 일반화된 메서드명 상태에서 -&gt; 빨간줄로 외부주입된 랜덤전략구현체 객체 + 전략메서드()호출해준다. . 기존상태( 메서드명을 랜덤+수동다 포함하는 일반화된 + 목적어빠진 전략메서드명으로 바꿔주기) . . 전략메서드에 목적어 넣지마라 | . . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(issue()); } return lottos; } public static Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } . | . | 외부주입된 new 랜덤전략객체에서 호출한 전략메서드()인척 해서 빨간줄로 생성하기 . . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(new RandomLottoIssuer().issue()); } return lottos; } . . | 전략메서드도 작성 . | 랜덤전략객체.전략메서드()로 &lt;- [ 기존 랜덤 메서드 ]에 있던 랜덤 로직 옮겨주기 . public class RandomLottoIssuer { static final List&lt;LottoNumber&gt; LOTTO_NUMBERS; static { LOTTO_NUMBERS = IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(LottoNumber::getInstance) .collect(Collectors.toList()); } public static Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } } . 외부주입 전략객체를 -&gt; 외부파라미터로 받기 위해서 -&gt; 실제 전략인페 정의해주기 . 앞에서 정의한 랜덤전략객체를 보고 전략인페를 생성한다. . RandomLottoIssuer -&gt; LottoIssuer -&gt; 앞으로 xxxxLottoIssuer 등 . | 전략인페명으로 패키지를 만들어서 다같이 넣어주면 좋다. . . | . | 전략메서드명은 다 통일이다. 목적어없이 동사만 . issue() . | 특정전략메서드의 반환타입을 참고해서 추상메서드를 정의해준다. . 랜덤전략의 메서드 반환타입 보고 . | 정의부 복붙해와서 반환타입 + 메서드명빼고 다 달리기 . . . public interface LottoIssuer { Lotto issue(); } . | . | . | ​ . new 외부전략객체() 생성하던 곳으로 돌아가서 -&gt; 변수/파라미터는 추상체로 외부주입 받아, 추상체.전략메서드()하도록 한다. . 기존: 외부주입없이 + 구상체로 사용 . . public class LottoFactory { public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(new RandomLottoIssuer().issue()); } return lottos; } } . | 호출부 중 전략객체만 선택해서 파라미터로 추출 . 전략메서드를 제외한 전략객체만 선택해서 추출하면 된다. . | 추상체 이름과, 파라미터 Type모두 추상체로 바꿔준다. . . public class LottoFactory { public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount, final LottoIssuer lottoIssuer) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(lottoIssuer.issue()); } return lottos; } } . | 처음에는 내부에서 특정 전략객체를 만들어썻찌만 -&gt; 파라미터 추출하면 알아서 외부에서 주입된다 . 그 장소가 service라도 괜찮다. spring에서는 알아서 service에서 외부주입 받는다. . . public class LottoService { public static List&lt;Lotto&gt; issueByMoney(final Money money) { final LottoCount count = money.getCount(); return LottoFactory.issueLottoByCount(count, new RandomLottoIssuer()); } . | . 이제 전략인페를 impl 수동 구현만 -&gt; TDD에서 수동메서드 완성해보자. . 수동 전략impl 구현체를 생성한다. . . | 관련 테스트(LottoFactoryTest)로 가서, 해당메서드를 완성해야한다. . test에서 외부전략객체생성 후 전략메서드()호출해도 아무도일도 안일어날 것이다. . . | . | 미리 작성된 RandomLottoIssuer를 띄워놓고(tabmover -&gt; ctrl+alt+shift+D)로 참고하면서 내용을 채워나가면 된다. . . | ​ . ​ . ​ . ​ . ​ . 대박) 전략메서드 준비물을 [메서드() 인자]가 아닌 -&gt; 각 전략별 [전략객체 생성자/정펙매]에서 받아 준비해두자 . 랜덤로직을 랜덤전략객체에 옮기고 나니 랜덤에 필요한 것들이 생성자나 변수에서 처리되고 있었다. . 각 전략별 전략메서드 실행시 필요한 준비물은 각 전략객체 생성자/정펙매에서 파라미터로 받자 | . . public class RandomLottoIssuer implements LottoIssuer { static final List&lt;LottoNumber&gt; LOTTO_NUMBERS; static { LOTTO_NUMBERS = IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(LottoNumber::getInstance) .collect(Collectors.toList()); } public Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } } . | . 수동로또준비물은 수동 입력된 번호 List일 것이다. . . @Test void manual_issue() { // 전략들의 준비물은 전략메서드()에서는 따로따로 못받는다. -&gt; 전략객체 만들때 미리 준비되어있어야한다. //1. 수동로또전략의 준비물은 [1,2,3, 수동입력]이 있어야 -&gt; issue()로 [1,2,3, 수동로또]를 발급할 수 있을 것이다. // -&gt; input은 나중에 처리하고, 정제된rawInput을 생성자에서 받아주자. //final Lotto lotto = new ManualLottoIssuer().issue(); final Lotto lotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); } . 일단 가변인자로 받도록 만들어놨으니… 저렇게 처리했음. | . | 전략객체 생성시부터 준비물 -&gt; 변수에 받아준비해두자 . public class ManualLottoIssuer implements LottoIssuer { private final Integer[] value; public ManualLottoIssuer(final Integer... value) { this.value = value; } @Override public Lotto issue() { throw new UnsupportedOperationException(&quot;ManualLottoIssuer#issue not implemented.&quot;); } } . | 전략메서드에서 준비물을 사용해서 처리해주자. . public class ManualLottoIssuer implements LottoIssuer { private final Integer[] value; public ManualLottoIssuer(final Integer... value) { this.value = value; } @Override public Lotto issue() { //throw new UnsupportedOperationException(&quot;ManualLottoIssuer#issue not implemented.&quot;); //2. 전략객체가 생성시 받아둔 준비물을 가지고 전략메서드로 반환하자. return new Lotto(value); } } . | 가장 기본적인 일급테스트인 size + contains만 테스트 해줬다. . @Test void manual_issue() { final Lotto manualLotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); assertThat(manualLotto.getValue().size()).isEqualTo(6); } . @Test void contains() { final Lotto manualLotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); assertThat(manualLotto.getValue()).containsExactly( new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6) ); } . | 초대박) 테스트용 람다 전략은 전략객체 대신이 아니라 내부 전략메서호출()될 응답까지를 미리 주는 것 -&gt; 테스트에서 내부랜덤결과(전략메서드 응답type)을 외부 객체주입시 넣어줄 수 있다 . 전략객체를 주입받는 메서드(전략메서드 호출()부를 감싸는 메서드)에 new 전략객체를 입력해서 . 내부에서 서로다른 전략메서드() 호출 -&gt; 전략마다 다른 응답값을 사용하는 것이 기본 패턴인데 | . . . | 람다전략은 new전략객체 대신 ` () -&gt; 전략메소드의 응답(Lotto)`까지 한번에 주입한다. . 예시1: 전략객체가 들어가던 boolean응답 전략메소드의 전략객체 주입 . js.move(new RandomMoveConditionStrategy()); js.printPosition(); . public void move() { if(isMovable()){ this.position++; } } . 전략객체 대신 람다 () -&gt; boolean응답까지 미리 지정해서 전략자리에 대입 | . jk.move( () -&gt; true); jk.printPosition(); . | | 로또에 적용해보면, 2번째 인자로 전략객체를 받아 -&gt; 그에 맞는 전략메서드()내부 호출하는 issueLottoByCount( , ) . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount, final LottoIssuer lottoIssuer) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(lottoIssuer.issue()); } return lottos; } . | 여기에 2번째 인자에 테스트용 람다전략으로서 전략메서드 응답값을 포함한 람다전략을 대입하자 . @Test void lambda() { final List&lt;Lotto&gt; lottos = LottoFactory.issueLottoByCount( new LottoCount(1), () -&gt; new Lotto(1, 2, 3, 4, 5, 7)); // 외부 전략객체가 들어와야하는데, 람다(내부전략메소드 호출후 응답갑까지 미리)를 대입 assertDoesNotThrow(() -&gt; lottos.get(0).contains(new LottoNumber(7))); } . | 요약: [전략객체 ]자리에 내부.전략메서드()호출 끝난 응답값까지 구현하여 전달하는 람다전략 . 횟수만큼 자동 로또 생성 -&gt; 횟수를 수동+자동 나누어서 로또 생성 . 35 수동 로또를 input이 왔다고 치고, 나눠서 수동 + 자동 생성하기 . 포장이 끝난 상태라면, [메서드 파라미터 추가]는 정제된 input보다는 [포장]된 것으로 추가해주자. . 자동로또 만들어 주는 메서드에 수동로또를 파라미터에 추가하자 . 이 때, 정제된 input인 List.of(1,2,3,4)가 아니라 포장 끝났으니 실제 포장된 new Lotto()를 넣어주자. | . @Test void issue_with_money_and_manual() { // final List&lt;Lotto&gt; lottos = LottoService.issueByMoney(new Money(3000)); //1. 돈만 받아서, 알아서 횟수만큼 자동로또 -&gt; 돈 과 수동로또input을 같이 받도록 변경 // -&gt; 파라미터 다른 메서드를 만들고 -&gt; 그 다음 이름변경하자. (기존 코드 돌아가야되니 복붙개념으로 가야됨) // -&gt; 수동이 여러개일 수 있다 -&gt; 만약 리스트라면, 6개숫자리스트의 리스트가 들어올 것이다. // -&gt; **서비스 메서드에는 controller에서 도메인으로 이미 포장으로 변수를 받아놓고 호출되었을 것이다. // --&gt; 포장작업은 이미 끝내놨으니, 파라미터를 포장으로 받아도 된다. // --&gt; 서비스 메서드(메인로직)에서 이미 포장끝났다면 rawInput보다는 포장된 것을 파라미터로 던지자! // LottoService.issueByMoney(new Money(3000), List.of(1,2,3,4,5,6)); final List&lt;Lotto&gt; totalLotto = LottoService.issueByMoney(new Money(3000), List.of(new Lotto(1, 2, 3, 4, 5, 6))); . | 파라미터 변경하지말고, 메서드를 새로 생성 -&gt; 기존메서드위로 가져와서 내용복붙후 처리 . //2. 기존메서드 위로 올린 뒤, 내용 복붙해와서 처리해보자. public static List&lt;Lotto&gt; issueByMoney(final Money money, final List&lt;Lotto&gt; lottos) { //3. 자동을 돌릴 갯수가 돈/1000이 아니라 수동로또수만큼 빼야한다. //final LottoCount count = money.getCount(); final LottoCount totalCount = money.getCount(); //4. VO 증감 메서드는 항상 응답받을 준비를 한다. final LottoCount autoCount = totalCount.decrease(lottos.size()); //5. 기존에는 자동로또가 전체로또였다. 이;번엔 수동로또 + 자동로또 합쳐서 건네애햐한다. // return LottoFactory.issueLottoByCount(count, new RandomLottoIssuer()); //6. 수동로또는 파라미터로 넘어올 것이다. 자동만 갯수만큼 -&gt; 수동은 input에 의해 controller에서 생산 final List&lt;Lotto&gt; totalLottos = Stream.concat( lottos.stream(), LottoFactory.issueLottoByCount(autoCount, new RandomLottoIssuer()).stream() ).collect(Collectors.toList()); return totalLottos; } . 새 기준 메더드 완성시, 기존메서드 사용처확인해서 삭제 -&gt; 메서드 이름 변경 . //포장된 로또 리스트를 받도록 수정했는데, // 받기전 기존메서드에 빈 list를 넣어서 돌아가는지 확인되면 //-&gt; 기존 메서드 삭제 final List&lt;Lotto&gt; lottos = LottoService.issueByMoney(new Money(3000), Collections.emptyList()); . //기존메서드 잘 삭제되면, 메서드 이름변경 public static List&lt;Lotto&gt; issueByMoneyAndManualLotto(final Money money, final List&lt;Lotto&gt; lottos) { final LottoCount totalCount = money.getCount(); final LottoCount autoCount = totalCount.decrease(lottos.size()); final List&lt;Lotto&gt; totalLottos = Stream.concat( lottos.stream(), LottoFactory.issueLottoByCount(autoCount, new RandomLottoIssuer()).stream() ).collect(Collectors.toList()); return totalLottos; } . 생성된 전체로또가 수동로또 포함하는지 테스트 하기 . @Test void issue_with_money_and_manual() { final List&lt;Lotto&gt; totalLotto = LottoService.issueByMoneyAndManualLotto(new Money(3000), List.of(new Lotto(1, 2, 3, 4, 5, 6))); assertThat(totalLotto.size()).isEqualTo(3); assertThat(totalLotto).contains(new Lotto(1, 2, 3, 4, 5, 6)); } .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%BA%90%EC%8A%81/factory/%EC%A0%84%EB%9E%B5/tdd/%EA%B0%95%EC%9D%98/2022/03/14/TDD-6-%EB%A1%9C%EB%98%90(%EC%BA%90%EC%8A%81,Factory,%EC%88%98%EB%8F%99%EC%B6%94%EA%B0%80%EB%A7%88%EB%AC%B4%EB%A6%AC).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%BA%90%EC%8A%81/factory/%EC%A0%84%EB%9E%B5/tdd/%EA%B0%95%EC%9D%98/2022/03/14/TDD-6-%EB%A1%9C%EB%98%90(%EC%BA%90%EC%8A%81,Factory,%EC%88%98%EB%8F%99%EC%B6%94%EA%B0%80%EB%A7%88%EB%AC%B4%EB%A6%AC).html",
            "date": " • Mar 14, 2022"
        }
        
    
  
    
        ,"post34": {
            "title": "전략패턴 2(자동로또->수동)",
            "content": "전략 패턴 적용하기 . [랜덤 최소단위 메서드]를 전략메서드로 바꿔 [수동]도 가능하게 하기 . 전략부위가 만약, 메서드화 안되어있으면(ex&gt;조건식) 메서드화 (추출 등) . 메서드명을 랜덤+수동다 포함하는 일반화 + 목적어 뺌(전략인페+구현전략들에 명시됨)된 전략메서드로 바꿔주기 | . 랜덤 최소단위 메서드 정의부 -&gt; 호출()부 찾기 . 랜덤 메서드 정의부 찾기 . | 랜덤 메서드의 호출부 찾기 . | ##### 랜덤 메서드 호출부에서 랜덤 메서드명을 -&gt; 수동포함하는 일반화된 전략메서드명() + 목적어 제거으로 변경 -&gt; 전략인페를 상속한 new 랜덤전략구현체 객체(). 전략메서드() 인척 빨간줄 생성해주기 . 일반화된 메서드명 상태에서 -&gt; 빨간줄로 외부주입된 랜덤전략구현체 객체 + 전략메서드()호출해준다. . 기존상태( 메서드명을 랜덤+수동다 포함하는 일반화된 + 목적어빠진 전략메서드명으로 바꿔주기) . . 전략메서드에 목적어 넣지마라 | . . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(issue()); } return lottos; } public static Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } . | . | 외부주입된 new 랜덤전략객체에서 호출한 전략메서드()인척 해서 빨간줄로 생성하기 . . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(new RandomLottoIssuer().issue()); } return lottos; } . . | 전략메서드도 작성 . | 랜덤전략객체.전략메서드()로 &lt;- [ 기존 랜덤 메서드 ]에 있던 랜덤 로직 옮겨주기 . public class RandomLottoIssuer { static final List&lt;LottoNumber&gt; LOTTO_NUMBERS; static { LOTTO_NUMBERS = IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(LottoNumber::getInstance) .collect(Collectors.toList()); } public static Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } } . 외부주입 전략객체를 -&gt; 외부파라미터로 받기 위해서 -&gt; 실제 전략인페 정의해주기 . 앞에서 정의한 랜덤전략객체를 보고 전략인페를 생성한다. . RandomLottoIssuer -&gt; LottoIssuer -&gt; 앞으로 xxxxLottoIssuer 등 . | 전략인페명으로 패키지를 만들어서 다같이 넣어주면 좋다. . . | . | 전략메서드명은 다 통일이다. 목적어없이 동사만 . issue() . | 특정전략메서드의 반환타입을 참고해서 추상메서드를 정의해준다. . 랜덤전략의 메서드 반환타입 보고 . | 정의부 복붙해와서 반환타입 + 메서드명빼고 다 달리기 . . . public interface LottoIssuer { Lotto issue(); } . | . | . | ​ . new 외부전략객체() 생성하던 곳으로 돌아가서 -&gt; 변수/파라미터는 추상체로 외부주입 받아, 추상체.전략메서드()하도록 한다. . 기존: 외부주입없이 + 구상체로 사용 . . public class LottoFactory { public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(new RandomLottoIssuer().issue()); } return lottos; } } . | 호출부 중 전략객체만 선택해서 파라미터로 추출 . 전략메서드를 제외한 전략객체만 선택해서 추출하면 된다. . | 추상체 이름과, 파라미터 Type모두 추상체로 바꿔준다. . . public class LottoFactory { public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount, final LottoIssuer lottoIssuer) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(lottoIssuer.issue()); } return lottos; } } . | 처음에는 내부에서 특정 전략객체를 만들어썻찌만 -&gt; 파라미터 추출하면 알아서 외부에서 주입된다 . 그 장소가 service라도 괜찮다. spring에서는 알아서 service에서 외부주입 받는다. . . public class LottoService { public static List&lt;Lotto&gt; issueByMoney(final Money money) { final LottoCount count = money.getCount(); return LottoFactory.issueLottoByCount(count, new RandomLottoIssuer()); } . | . 이제 전략인페를 impl 수동 구현만 -&gt; TDD에서 수동메서드 완성해보자. . 수동 전략impl 구현체를 생성한다. . . | 관련 테스트(LottoFactoryTest)로 가서, 해당메서드를 완성해야한다. . test에서 외부전략객체생성 후 전략메서드()호출해도 아무도일도 안일어날 것이다. . . | . | 미리 작성된 RandomLottoIssuer를 띄워놓고(tabmover -&gt; ctrl+alt+shift+D)로 참고하면서 내용을 채워나가면 된다. . . | ​ . ​ . ​ . ​ . ​ . 대박) 전략메서드 준비물을 [메서드() 인자]가 아닌 -&gt; 각 전략별 [전략객체 생성자/정펙매]에서 받아 준비해두자 . 랜덤로직을 랜덤전략객체에 옮기고 나니 랜덤에 필요한 것들이 생성자나 변수에서 처리되고 있었다. . 각 전략별 전략메서드 실행시 필요한 준비물은 각 전략객체 생성자/정펙매에서 파라미터로 받자 | . . public class RandomLottoIssuer implements LottoIssuer { static final List&lt;LottoNumber&gt; LOTTO_NUMBERS; static { LOTTO_NUMBERS = IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(LottoNumber::getInstance) .collect(Collectors.toList()); } public Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } } . | . 수동로또준비물은 수동 입력된 번호 List일 것이다. . . @Test void manual_issue() { // 전략들의 준비물은 전략메서드()에서는 따로따로 못받는다. -&gt; 전략객체 만들때 미리 준비되어있어야한다. //1. 수동로또전략의 준비물은 [1,2,3, 수동입력]이 있어야 -&gt; issue()로 [1,2,3, 수동로또]를 발급할 수 있을 것이다. // -&gt; input은 나중에 처리하고, 정제된rawInput을 생성자에서 받아주자. //final Lotto lotto = new ManualLottoIssuer().issue(); final Lotto lotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); } . 일단 가변인자로 받도록 만들어놨으니… 저렇게 처리했음. | . | 전략객체 생성시부터 준비물 -&gt; 변수에 받아준비해두자 . public class ManualLottoIssuer implements LottoIssuer { private final Integer[] value; public ManualLottoIssuer(final Integer... value) { this.value = value; } @Override public Lotto issue() { throw new UnsupportedOperationException(&quot;ManualLottoIssuer#issue not implemented.&quot;); } } . | 전략메서드에서 준비물을 사용해서 처리해주자. . public class ManualLottoIssuer implements LottoIssuer { private final Integer[] value; public ManualLottoIssuer(final Integer... value) { this.value = value; } @Override public Lotto issue() { //throw new UnsupportedOperationException(&quot;ManualLottoIssuer#issue not implemented.&quot;); //2. 전략객체가 생성시 받아둔 준비물을 가지고 전략메서드로 반환하자. return new Lotto(value); } } . | 가장 기본적인 일급테스트인 size + contains만 테스트 해줬다. . @Test void manual_issue() { final Lotto manualLotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); assertThat(manualLotto.getValue().size()).isEqualTo(6); } . @Test void contains() { final Lotto manualLotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); assertThat(manualLotto.getValue()).containsExactly( new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6) ); } . | 초대박) 테스트용 람다 전략은 전략객체 대신이 아니라 내부 전략메서호출()될 응답까지를 미리 주는 것 -&gt; 테스트에서 내부랜덤결과(전략메서드 응답type)을 외부 객체주입시 넣어줄 수 있다 . 전략객체를 주입받는 메서드(전략메서드 호출()부를 감싸는 메서드)에 new 전략객체를 입력해서 . 내부에서 서로다른 전략메서드() 호출 -&gt; 전략마다 다른 응답값을 사용하는 것이 기본 패턴인데 | . . . | 람다전략은 new전략객체 대신 ` () -&gt; 전략메소드의 응답(Lotto)`까지 한번에 주입한다. . 예시1: 전략객체가 들어가던 boolean응답 전략메소드의 전략객체 주입 . js.move(new RandomMoveConditionStrategy()); js.printPosition(); . public void move() { if(isMovable()){ this.position++; } } . 전략객체 대신 람다 () -&gt; boolean응답까지 미리 지정해서 전략자리에 대입 | . jk.move( () -&gt; true); jk.printPosition(); . | | 로또에 적용해보면, 2번째 인자로 전략객체를 받아 -&gt; 그에 맞는 전략메서드()내부 호출하는 issueLottoByCount( , ) . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount, final LottoIssuer lottoIssuer) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(lottoIssuer.issue()); } return lottos; } . | 여기에 2번째 인자에 테스트용 람다전략으로서 전략메서드 응답값을 포함한 람다전략을 대입하자 . @Test void lambda() { final List&lt;Lotto&gt; lottos = LottoFactory.issueLottoByCount( new LottoCount(1), () -&gt; new Lotto(1, 2, 3, 4, 5, 7)); // 외부 전략객체가 들어와야하는데, 람다(내부전략메소드 호출후 응답갑까지 미리)를 대입 assertDoesNotThrow(() -&gt; lottos.get(0).contains(new LottoNumber(7))); } . | 요약: [전략객체 ]자리에 내부.전략메서드()호출 끝난 응답값까지 구현하여 전달하는 람다전략 .",
            "url": "blog.chojaeseong.com/java/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/13/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B42-%EC%A0%81%EC%9A%A9(%EC%88%98%EB%8F%99%EB%A1%9C%EB%98%90).html",
            "relUrl": "/java/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/13/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B42-%EC%A0%81%EC%9A%A9(%EC%88%98%EB%8F%99%EB%A1%9C%EB%98%90).html",
            "date": " • Mar 13, 2022"
        }
        
    
  
    
        ,"post35": {
            "title": "01 임상연구 소개",
            "content": "&#51076;&#49345;&#50672;&#44396; . &#51076;&#49345;&#50672;&#44396;&#46976; . 임상연구: 사람의 질병을 이해, 예방, 치료하고 건강을 증진하기 위한 학문 사람의 질병에 대한 학문 | 사람이 아닌 동물실험 연구도 도움 될 수 있다. 실험실에서 세포, 분자단위 연구도 도움 될 수 있다. Labloratory Research와도 겹치게 된다. | . | 큰 인구집단에 적용한다고 하면, 예를들어, 특정 질병에 취약한 high risk 집단은 어떤 계층인가, 질병의 outcome을 향상시키기 위해서 어떤 의료시스템 변화를 implement해야할 것인가와 연결되어 있다. Population Research와도 겹치게 된다. | . | . | . &#51076;&#49345;&#50672;&#44396;&#51032; &#51333;&#47448; . 치료 | 예방 | 진단 | 스키리닝 | 삶의질 | 유전학 | (큰 인구집단) 역학 연구까지 종류가 다양하다 | &#44288;&#47144;&#48516;&#50556; . 기초과학(생물학, 화학, 유전학...) | 역학 | 통계학 | Psychometrics: 임상연구에서 쓰이는 각 변수들의 measurement들이 얼마나 신뢰도가 있느냐 관련 | Physiology of resarch( &#50672;&#44396; &#54644;&#48512;&#46020; ) . Designing Clinical Research 4판에 나오는 내용 | . . 알고 싶은 세계: truth in the universe . 그 중 알고 싶은 것 총 2가지 (0) research question | 어떤 집단에 대한 궁금증인가 (1) target population | 어떤 현상에 관심이 있나 (2) phenomena of interest | . | 알고 싶으니 연구계획을 세운다: study plan . 알고 싶은 target population의 전체를 연구하는 경우는 거의 없다 -&gt; 일부 의도된 샘플: intended sample | 관심 현상을 알기 위해선 변수를 관측: intended variables | . | 연구계획대로 되지 않은다: actual study . 의도한 샘플과 비슷할 수도 있거나 다를 수 있는, 실제 조사/관찰한 subject들 : actual subjects | 의도한 변수와 비슷할 수도 있거나 다를 수 있는, : actual measurements | . | . 실제로는 3가지 : 알고싶은 세계 -&gt; 의도한 연구 -&gt; (의도가)실제로 수행/관측된 것 3가지의 간극을 좁혀야한다. 각각은 얼마나 가까운가에 대한 것 : validity 알고싶은 세계 &lt;-&gt; 의도한 연구가 얼마나 가까운가 : External validity | 의도한 연구 &lt;-&gt; 실제 연구가 얼마나 가까운가 : internal validity | . | . | . &#51339;&#51008; &#51076;&#49345;&#50672;&#44396; . 좋은 연구는 이 2가지 validity가 최대화된 연구 -&gt; 어떻게 하면 맥시마이즈 할 수 있을까? | . &#50672;&#44396;&#44228;&#54925;&#49436; . 연구 구조가 적혀있는 설계도 | 연구비 심사나 IRB를 위해 작성하는 경우가 많다 | 그러나 근본적인 목적은 연구를 과학적/효율적으로 도와주는 도구가 된다. | . &#50672;&#44396;&#44228;&#54925;&#49436; &#44396;&#49457; . &#50672;&#44396;&#51656;&#47928;(Research question) . 연구를 통해 답하고자하는 질문 | 연구의 목적 연구 시작전 명시되어야하고, 구체적일 수록 좋다. | . | . 연구 해부도내에서는 truth in the universe에 해당하는 것 | 좋은 연구질문을 정하는 기준 FINER . Feasible(피져블): 실제 수행 가능한가? 실제 연구에 들어가는 비용과 시간을 감당할 수 있고,환자를 모집할 수 있는가 | 연구자의 능력/자원/경험치가 연구하기에 충분한가? 연구질문이 아무리 좋아도 피져블 하지 않으면 성공할 수가 없음. | . | . | Interesting: 연구자 본인에게 흥미로운 주제인가 더불어, 관련분야 연구자들의 흥미를 끌 만한 주제인가 | . | Novel(노블): 기준연구와 비교시 새로운점이 있나 기존연구와 다른점이 있는가 | 기존연구의 단점을 보완하는가 | 완전히 새로운 가설을 만들어 내는가 | . | Ethical(에띠컬): 윤리적인가 윤리적 연구 기본원칙에 충실한가 | IRB 규정을 준수하는가 | . | Relevant(렐러번트): 연구계획서에 significant에 해당하는 항목 . 얼마나 과학/환자 돌보는데 기여하는가 | 얼마나 새로운 지식을 창출하고, 미래연구를 촉진시키는 가 | . . . | | . &#50672;&#44396; &#48176;&#44221;&#44284; &#51473;&#50836;&#49457; . 이미 무엇이 알려져있는가 | 무엇이 안알려져있어서 이 연구질문이 중요한가 | 이 연구를 하면 어떤 종류의 지식을 | 이 연구가 어떤 prractical impact(실제 가이드라인, 보건정책에 영향)을 끼칠 것이가 | . &#50672;&#44396;&#46356;&#51088;&#51064; . 종류가 많고, 새로운 디자인이 개발되고 있어 정리될 순 없지만, 대략적으로 파악할 수 있는 그림이다. | . 크게 2가지 . Experimental(실험) : 내가 연구대상에 무엇인가를 가하거나 해서 -&gt; 연구대상을 따라가며 관찰 . 가하면서 연구대상을 따라가며 관찰하니 특성상 Prospective한 study일 수 밖에 없다. | intervention등을 가한 다음, 이후에 일을 관찰하니 Longitudinal study일 수 밖에 없다. | . | Observational(관찰): 가하지 않음 따라감 -&gt; prospective가 될 수도 retrospective가 될 수도 . prospective: 가하진 않지만 지금부터 따라가면서 살펴보는 Longitudinal: 지금부터 따라가면서 현재-&gt;미래 2시점 연결해관찰 = Cohort Study | . | retrospective: 가하진 않지만 지금부터 과거로 따라가면서 살펴보는 Longitudinal: 지금부터 과거로 따라가면서 현재-&gt;과거 2시점 연결해관찰 = Case-control study | . | cross-sectional: p/r관계없이, 시점을 2개이상 보지않고,딱 1시점만 보는 것 | . | | . 연구의 목적에 따라 좋은 디자인의 기준이 달라지지만 | 좋은 디자인: internal/external validity를 높이는 디자인 나쁜 디자인을 통계기법으로 극복해낼순 없다. -&gt; 처음부터 잘 골라서 연구설계해야한다. | . | . &#50672;&#44396;&#45824;&#49345;&#51088; . 알고 싶은 환자군 전체 Target population이 있고 | 그 전체를 알 수 없으니 일부를 뽑은 게 study sample(study subjects)이라 한다. 연구계획서는 study sample이 어떤 집단이 될 것인지 적어야한다. | 반드시 inclusion/exclusion criteria(크라이테리아)로 명시해줘야한다. | . | . inclusion criteria . 인구학적 특성: 성별/나이에 대한 것 | 임상적 특성: 내가 관심있는 질병에 따라 결정되어지는, 대상의 임상기준? | 지리학적 또는 행정적 특성: 내가 실제 연구 수행하는 장소와 시간 | 시간적 특성: 내가 실제 연구 수행하는 장소와 시간 | exclusion criteria . 연구대상자가 안되는 사람의 기준 | . . Follow Up 안될 가능성이 높은 사람은 제낀다. ex&gt; 알콜중독자, 이사갈 사람 | 양질 데이터 제공이 어려운 사람은 제낀다. ex&gt; 언어 문제, 지적장애인 | (drug study시) adverse effects를 겪을 가능성이 높은 사람은 제낀다 ex&gt; 암환자, 임산부 | 연구 해부도에서, 가운데 부분이 연구대상자 내가 알고 싶은 타켓파풀레이션 | 그 중 일부를 어떻게 뽑겠다 계획 | 실제 recruit되는 환자 간격을 줄여야한다. | . | . | . 예시 chd환자 전체(타겟 파퓰레이션)를 보고 싶지만 | 실제로는 recruit하게 되는(인텐디드 샘플) 내가 일하는 곳의 intended sample으로만 제한된다 타겟 파퓰레이션과 괴리가 생기게 된다. -&gt; 이 차이를 줄이기 위해, 모든병원 or 병원 갯수를 늘리는 식으로 노력하여 더 제네럴라이즈하게 시도할 수 있지만, 비용과 시간과 노력이 많이 들게 된다. | 즉 external validity를 맥시마이즈 하는 것이 중요하지만, 비용/시간/노력의 문제 때문에 적당한 타협점을 찾아야한다. | . | recruit하려고 했던 subjects들 중에 실제로 연구에 동의(액츄얼 스터디 샘플)해서 데이터를 제공한 환자들을 Actual Study sample이라고 한다. intended sample과 차이가 있을 수 있는데, 차이가 적을 수록 좋다 | 만약, recruite하려고 하는 사람들 중 매우 일부만 동의 등으로 차이가 커질 수록 internal validity가 해를 입게 된다. | . | . | . &#48320;&#49688; . outcome: 결과변수, 반응변수 관심 질병유무 /심각도/이벤트 유무/건강상태 | . | 설명변수: 독립변수 . outcome과 관련되는 여러가지 factor들 . . | . | &#53685;&#44228;&#51201; &#44256;&#47140;&#49324;&#54637; . 가설: 가장 중요한 것으로서, research question을 통계적으로 testable한 가설로 바꿔줘야한다. . 귀무가설과 대립과설이 무엇과 무엇인지 / 어떻게 검증할 것인지 나와야한다. | . | 통계분석 계획: 가설이 나오난 뒤에, 이 가설을 어떤 테스트로 검정할 것인지 정하는 것 . 가설 증명을 통한 r.q.에 답하기 위한 통계적 방법을 구체적으로 기술해야 됨. | . | 연구 대상자 수: 위에서 정해진 통계적 방법이, 가설을 증명하기 위해 필요한 샘플 사이즈 . 내가 보이려고 하기 위한 대립가설이 사실일 경우에, p밸류가 0.05보다 작게 나올 확률인 power가 80~90%로 확보되기 위해서 몇명의 환자를 조사해야하는지 | . | . &#51076;&#49345;&#50672;&#44396;&#51032; &#45800;&#44228; . &#45800;&#44228; . 딱 정해진 것은 없지만 3가지로 책에서 서술한다. | . . 디스크립티드 스터디: 관심있는 질병과 특성이 and/or 어떤 식의 분포로 나타나는지 기술하는 스터디 . 관심 질병= 미표기 or 관련 특성=한국 CHD환자의 일주일당 생선섭취량 | 이러한 현상이 있다. | . | 애널리틱 스터디: 관심 질병과 관련 특성의 상관관계/인과관계가 있는지 보는 연구 . 관심 질병= 심장발작여부와 - 관련 특성=한국 CHD환자의 일주일당 생선섭취량이 관련있는가? . | 상관 관계가 확인이 되면 (-&gt; 인과 관계가 먼저 완전히 확립되면 더 좋겠지만), 인과 관계를 확립을 확실히하기 위해 아래 다음단계인 클리니컬 트라이얼스로 넘어간다. . | . | 클리니컬 트라리얼스: 관심있는 intervention이 추가되어 그 효과를 확인하는 연구이다. . 특히, RCT를 하게되면 인과관계를 확실히 확인할 수 있다. | 한국 CHD환자 대상 - 인터벤션1:fish oil보충제 vs 플라시보 투약한 것에 비해 outcome이 좋은가?(심장발작 횟수가 줄어드는가?)를 진행한다. | . | 교수님 생각으로 전계되는 단계 | . 처음 내가 관심있는 현상에 대해서 디스크립션해야한다 | 그 다음에는 관심있는 특성과 관심있는 질병과의 어쏘시에션(상관관계)를 보게 된다. | 어쏘시에션을 확인한 상태에서 코잘리티(인과관계)를 보고 넘어가는 경우 vs 코잘리티를 못보고 넘어가는 경우가 있다 . 프리딕션 모델로 가는 경우 2가지 . 관심질병-관심인자(특성)과의 어쏘시에이션이 충분히 보였다 -&gt; 코잘리티를 굳이 보이지 않더라도, 상관관계 높은 인자를 이용한 예측모델을 만들 수 있다. association모델에서 바로 prediction모델로 갈 수 있다.! | . | 어쏘시에이션 -&gt; 여러 방법을 통해 코절하다고 결론이 나온 경우 -&gt; 프리딕션으로 넘어가기 | | 인터벤션 리서치로 넘어가는 경우 2가지 코잘리티를 확실하게 보이지 않더라도, 단지 상관관계만 보인 상태에서, 인과관계가 있을 것이라는 강한 믿음 or 근거를 가지고 intevention으로 넘어가기 | 어쏘시에이션 확인 후, 여러 통계기법 + 정황으로 코잘리티를 보인 상태에서, 인터벤션으로 넘어가기 | | | 인터벤션(주로 RCT로 함)의 효과가 확인되었다면, 같은 인터벤션에 대한 효과들을 모아 메타분석을 한다. 같은 인터벤션이지만, 다른 위치, 환자군 등을 모아봄 | . | 내가 연구하려는 주제가 있을 때, 어느 정도까지 연구되어있는지 임상연구의 단계를 찾아보고, 다음 단계에서 내가 해야할 것은 무엇인지를 확인하면 된다. 예를 들어, association이 밝혀지지 않은 주제 -&gt; 바로 RCT나 Prediction하도록 단계를 건너띄어선 안된다. | . | . &#49345;&#44288;&#44288;&#44228;&#50752; &#51064;&#44284;&#44288;&#44228; . &#49345;&#44288;&#44288;&#44228; vs &#51064;&#44284;&#44288;&#44228; &#50696;&#49884; . 어떤 자료 2개가 상관관계가 엄청 높았다 -&gt; 바로 인과로 가면 안된다. 우주기술에 투자할수록 -&gt; 자살률이 높다?? -&gt; 이렇게 결론 내리진 않는다. | 우연에 의한 것인지 확인? / 시간이라는 컨파운딩 팩터가 있어서 시간이 증가하면서 경제 발달 -&gt; 정부는 투자많이 / 인구늘어남 -&gt; 자살수 늘어남 | . | 컨파운더에 의한 상관관계로 결론 | . | . . 상관관계가 관측됨 이 상관관계가 진짜인가? /우연 or 잘못된 연구디자인 때문은 아닌가부터 의심한다 | . | 진짜 상관관계가 판단됨 a가 b를 일으키는 코잘리티인가? / [보이지 않지만, 실제 b를 일으키면서 &amp;&amp; 동시에 a에도 영향을 주고 있는 confounding factor]때문에 생겨난 서로간의 인과관계는 없지만 [보이는 상관관계]인지판단 해야한다 | . | &#49345;&#44288;&#44288;&#44228; &#48156;&#44204;&#49884;, &#53076;&#51096;vs&#52980;&#54028; &#50696;&#49884; . 연구했는데 커피 -&gt; 췌장암의 상관관계가 있는 것으로 관측되어었다(상관관계가 진짜이라고 가정) 커피섭취가 -&gt; 실제로 췌장암에 영향을 미치는 코절리티가 있는 경우 | 보이지 않는 컴파운딩 팩터 때문에, 인과없이, 보이기만 하는 상관관계인 경우 보이지 않는 흡연이라는 실제 췌장암의 증가원인 &amp;&amp; 커피 섭취의 증가원인인 컴파운딩 팩터가 있음 | 흡연하는 사람이 커피를 많이 마시는 경향도 있어서, a와 b 둘다 영향을 주기 때문에, 커피섭취가 -&gt; 췌장암에 영향을 주는 인과가 없더라도 해당 보이는 상관관계를 유발시킨다. 커피-&gt;췌장암 영향 있을 수도 없을 수도 있지만, 컨파운딩 때문에 이렇게 보이는 상관관계를 만드는게 아닌가 고민을 해봐야한다. | . | . | | . &#51064;&#44284;&#44288;&#44228; &#54032;&#45800; &#44032;&#51060;&#46300;&#46972;&#51064; . 인과관계 판단이 쉽지 않으므로, 담배-&gt;폐암 인과증명시 제시 된 것들이다. | 하지만, 칼같이 정해지는 것이 아니라 종합적으로 고려되어야한다. 시간이 지나면서 계속 수정되고 있다. | . 템포럴 릴레이션쉽: 선후관계가 명확해야한다. 원인이 선행해야한다. | . | 상관관계가 강해야한다. 약한 순간 인과관계이긴 어렵다 | . | 도스-리스폰스 릴레이션쉽: . 세부 섭취량(음식)/투약량(약)에 따라 outcome과 관련있어야한다 | 인과관계가 확실한 경우에도 나타나지 않는 경우도 있으니 100% 만족안해도 된다. ex&gt; 적은 양에는 효과X -&gt; 역치 넘으면 효과O 있는 경우, -&gt; 인과는 있는데 적은량에서는 dose가 무시됨 | . | . | 레플리케이션 오브 파인딩스: . 내 연구에서 상관관계-&gt;인과관계를 발견했어도, 바로 인과관계 있다고 말할 수 없다. 다른 연구/환자군/서브그룹에서도 일관된 상관관계가 나타날 때 -&gt; 인과관계 있다고 말할 수 있다. | . | 바이얼로직 플러져빌리티: 생물학적 그럴듯한 설명이 있어야한다. . | 컨시덜레이션 오브 얼터네이트 익플레내이션스: 다른 설명이 가능한지도 살펴봐야한다 . 인과관계가 아니라 사실은 다른 컨파운딩이 숨어있는 것은 아닐까? | 인과가 뒤바뀐 것은 아닐까? | . | 쎄세이션 오브 익스포져: 원인이 되는 exposure 중단시 -&gt; 결과도 중단 되어야한다. . 하지만, 도스-리스폰스 릴레이션쉽처럼, 인과관계일 때도 성립안하는 경우가 가끔 있다. 흡연이 -&gt; emphysema에 영향을 미치는 인과는 사실이나 | 흡연 중단 -&gt; emphysema 해결은 안된다. | . | . | 컨시스턴시 위드 아덜 날러지: 이 질병/환자군에 대해 알고 있는 다른 지식과 컨시스턴시 해야한다 . | 스페서피서티 오브 더 어소시에이션: . 원인이 일으키는 결과가 1개 여야한다. 다른 결과들도 일으키면 안된다. | 회색: 논의가 많이 되는 부분이다. ex&gt; 미국담배회사: 담배 -&gt; 폐암외 여러질병일으킴 -&gt; 스페서피서티 오브 더 어소시에이션를 만족하지 않으므로 인과관계 아니라고 주장함. | . | . | 다른 가이드라인이 많고, 절대적인 기준은 없다. | 우리 데이터가 가진 전체적인 패턴을, 다른 지식과 종합해서 인과관계인지 판별해해야한다. | . &#51221;&#47532;&#54616;&#44592; . 임상연구는 사람의 질병을 이해, 예방, 치료하고 건강을 증진하기 위한 학문이다. . 사람에 대한 학문이다. | . | 좋은 임상연구는 validity가 최대화된 연구이다. . Internal validity는 연구 내에서 일어난 일에 대해 올바른 결론을 내렸는가에 관한 것이고, | External validity는 연구 결과가 연구 밖 real world에 적용될 수 있는가에 관한 것이다. 두 validity를 최대한 연구가 좋은 연구이다 | . | . | 연구계획서는 연구의 구조가 적혀있는 설계도이다. 연구계획서는 . 연구질문(research question), | 연구 배경과 중요성, | 디자인, | 연구대상자, | 변수, | 통계적 고려사항으로 이루어진다. | . | 임상연구의 많은 부분은 상관관계를 확인하고 그로부터 인과관계에 대한 추론을 끌어내기 위한 노력이며, 경우에 따라 예측모델이나 중재연구(intervention study)의 단계로 이어진다. . | 상관관계로부터 인과관계를 성립시키기 위한 몇가지 기준이 있지만, 기계적으로 적용하여 인과관계가 있다고 결론내릴 수 있는 절대적인 기준은 없으며, 관측된 데이터의 전체적인 패턴을 종합적으로 고려하여 인과관계에 대한 결론을 내려야 한다. . | &#53300;&#51592;&#47784;&#51020; . . . .",
            "url": "blog.chojaeseong.com/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EC%9E%84%EC%83%81%EC%97%B0%EA%B5%AC/2022/03/13/01-%EC%9E%84%EC%83%81%EC%97%B0%EA%B5%AC-%EC%86%8C%EA%B0%9C(%EC%99%84).html",
            "relUrl": "/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EC%9E%84%EC%83%81%EC%97%B0%EA%B5%AC/2022/03/13/01-%EC%9E%84%EC%83%81%EC%97%B0%EA%B5%AC-%EC%86%8C%EA%B0%9C(%EC%99%84).html",
            "date": " • Mar 13, 2022"
        }
        
    
  
    
        ,"post36": {
            "title": "Count VO 포장 과정(로또)",
            "content": "Count VO 포장 . 줄어드는 횟수Count VO의 포장 . 미리 원시값도 줄어들 때 hasNext패턴을 만들어두었다. . 내 패턴으로는 0을 허용하면서 더 큰 n부터 줄어들되 0이 아닐때까지, 즉, 1까지도는 것이다. | . public static List&lt;Lotto&gt; issueLottoByCount(int count) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (count != 0) { count -= 1; lottos.add(LottoFactory.issueLotto()); } return lottos; } . 메서드에서부터 파라미터로 전해지도록 Count 포장 (포장은 테매 인자에서부터~ ) . 이름은 도메인Count로 만들어야한다. 포장하는 순간, 대명사가 아니다. . . | . 포장하기 . public class LottoCount { private final int value; public LottoCount(final int value) { this.value = value; } } . | VO는 equals/hC부터 . . count VO는 0까지는 허용해주도록 검증을 만든다. (for while문에서 0까지 간 뒤 0에서 탈출시킴) . public LottoCount(final int value) { if (value &lt; 0) { throw new IllegalArgumentException(&quot;0보다 작을 수 없습니다.&quot;); } this.value = value; } . 새기준메서드 새로 만들어, 기존메서드 위로 위치이동후, 내용복붙후, 처리 . . . . . 값자리에는 포장.getter()를 -&gt; 연산이 할만하면 바로 메세지를 . . . . 값의 연산 -&gt; 포장 안으로 잘라들고가서 this.값으로 연산 . getter지우고 메세지보내기 만약, 지우고 빨간메서드가 남아있다면 그대로 정의해도 된다. | 여기선 연산!=0이 남아있으니, 그에 맞는 의미있는 메서드를 지어준다. 0=Finish가 != 아직 Not이냐 | 남은 연산을 잘라내서 -&gt; 메서드만들고 -&gt; 내부에서 this.값으로 잘라낸 연산 처리 | . | 값의 재할당 -&gt; VO에서는 연산만 들고 들어가면서 메서드를 만들고, 포장 = 는 그대로 둔다. -&gt; 내부에서는this.값으로 연산한 뒤 =에 대해 새VO로 응답하는 [메세지]로 작성한다. . -= 1을 포장 처리하려면 . -1 을 내부로 들고 들어가서 this.값 -1으로 연산 | =은 새 VO를 반환 | . . . | = 놓아두고, -1만 들고 들어가면서, 연산과 관련된 메서드명으로 메세지를 보낸다. . . . . | 연산을 들고들어갔더라도 바깥에서는 포장변수 = 이 새 VO응답을 기다리고 있으므로 내부연산 결과를 포장해서 응답해준다. . . . final을 풀어 재할당 가능하게 해준다. | . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(LottoFactory.issueLotto()); } return lottos; } . 포장전 기존메서드가 사용중이면 찾아가서, 수정해준다. . . . count가 사용중인데, 일단 money.getCount()의 반환값도 원시count으로 바꿔준다. . public int getCount() { return this.money / 1000; } . . public LottoCount getCount() { return new LottoCount(this.money / 1000); } . public static List&lt;Lotto&gt; issueByMoney(final Money money) { final LottoCount count = money.getCount(); return LottoFactory.issueLottoByCount(count); } . | . 새 기준메서드 완성시, 포장검증을 메서드로 퉁치는 테스트(-1이하에서 에러) . . 자체 도메인Test생성후 Count VO 검사 . 0까지 허용하여 음수 생성자 에러 | . @Test void create() { assertAll( () -&gt; { assertDoesNotThrow(() -&gt; new LottoCount(1)); assertDoesNotThrow(() -&gt; new LottoCount(0)); assertThatThrownBy(() -&gt; new LottoCount(-1)); } ); } . 1개 뽑 + 감소된 것 뽑 -&gt; 감소된 로직후 동일한지 비교 | . @Test void decrease() { final LottoCount lottoCount = new LottoCount(1); final LottoCount expected = new LottoCount(0); // 감소된 것 미리 뽑기 final LottoCount actual = lottoCount.decrease(); assertThat(actual).isEqualTo(expected); } .",
            "url": "blog.chojaeseong.com/java/vo/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/12/Count-VO-%ED%8F%AC%EC%9E%A5.html",
            "relUrl": "/java/vo/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/12/Count-VO-%ED%8F%AC%EC%9E%A5.html",
            "date": " • Mar 12, 2022"
        }
        
    
  
    
        ,"post37": {
            "title": "00 데이터 클리닝 특강",
            "content": "강의 교재 사이트: https://rpubs.com/biostat81/DataPrep_CRM | 데이터셋 보유되어있음(data/특강/example_dataset.csv) | . &#46972;&#51060;&#48652;&#47084;&#47532; &#49444;&#52824; . install.packages(&#39;plyr&#39;) . package &#39;plyr&#39; successfully unpacked and MD5 sums checked The downloaded binary packages are in C: Users cho_desktop AppData Local Temp RtmpC2VGFd downloaded_packages . install.packages(&#39;dplyr&#39;) . also installing the dependencies &#39;ellipsis&#39;, &#39;fansi&#39;, &#39;pkgconfig&#39;, &#39;purrr&#39;, &#39;cli&#39;, &#39;utf8&#39;, &#39;generics&#39;, &#39;glue&#39;, &#39;lifecycle&#39;, &#39;magrittr&#39;, &#39;R6&#39;, &#39;rlang&#39;, &#39;tibble&#39;, &#39;tidyselect&#39;, &#39;vctrs&#39;, &#39;pillar&#39; . There are binary versions available but the source versions are later: binary source needs_compilation fansi 0.4.2 1.0.2 TRUE cli 2.5.0 3.2.0 TRUE utf8 1.2.1 1.2.2 TRUE generics 0.1.0 0.1.2 FALSE glue 1.4.2 1.6.2 TRUE lifecycle 1.0.0 1.0.1 FALSE magrittr 2.0.1 2.0.2 TRUE R6 2.5.0 2.5.1 FALSE rlang 0.4.11 1.0.2 TRUE tibble 3.1.1 3.1.6 TRUE tidyselect 1.1.1 1.1.2 TRUE pillar 1.6.0 1.7.0 FALSE dplyr 1.0.6 1.0.8 TRUE Binaries will be installed package &#39;ellipsis&#39; successfully unpacked and MD5 sums checked package &#39;fansi&#39; successfully unpacked and MD5 sums checked package &#39;pkgconfig&#39; successfully unpacked and MD5 sums checked package &#39;purrr&#39; successfully unpacked and MD5 sums checked package &#39;cli&#39; successfully unpacked and MD5 sums checked package &#39;utf8&#39; successfully unpacked and MD5 sums checked package &#39;glue&#39; successfully unpacked and MD5 sums checked package &#39;magrittr&#39; successfully unpacked and MD5 sums checked package &#39;rlang&#39; successfully unpacked and MD5 sums checked package &#39;tibble&#39; successfully unpacked and MD5 sums checked package &#39;tidyselect&#39; successfully unpacked and MD5 sums checked package &#39;vctrs&#39; successfully unpacked and MD5 sums checked package &#39;dplyr&#39; successfully unpacked and MD5 sums checked The downloaded binary packages are in C: Users cho_desktop AppData Local Temp RtmpC2VGFd downloaded_packages . installing the source packages &#39;generics&#39;, &#39;lifecycle&#39;, &#39;R6&#39;, &#39;pillar&#39; . install.packages(&#39;tableone&#39;) . also installing the dependencies &#39;bit&#39;, &#39;prettyunits&#39;, &#39;glue&#39;, &#39;bit64&#39;, &#39;withr&#39;, &#39;progress&#39;, &#39;cli&#39;, &#39;clipr&#39;, &#39;vroom&#39;, &#39;tzdb&#39;, &#39;DBI&#39;, &#39;gtools&#39;, &#39;forcats&#39;, &#39;hms&#39;, &#39;readr&#39;, &#39;cpp11&#39;, &#39;stringi&#39;, &#39;Matrix&#39;, &#39;survival&#39;, &#39;lattice&#39;, &#39;minqa&#39;, &#39;numDeriv&#39;, &#39;mitools&#39;, &#39;class&#39;, &#39;proxy&#39;, &#39;gdata&#39;, &#39;haven&#39;, &#39;stringr&#39;, &#39;tidyr&#39;, &#39;survey&#39;, &#39;MASS&#39;, &#39;e1071&#39;, &#39;zoo&#39;, &#39;gmodels&#39;, &#39;nlme&#39;, &#39;labelled&#39; . There are binary versions available but the source versions are later: binary source needs_compilation glue 1.4.2 1.6.2 TRUE withr 2.4.2 2.5.0 FALSE cli 2.5.0 3.2.0 TRUE clipr 0.7.1 0.8.0 FALSE vroom 1.4.0 1.5.7 TRUE tzdb 0.1.1 0.2.0 TRUE DBI 1.1.1 1.1.2 FALSE gtools 3.8.2 3.9.2 TRUE hms 1.0.0 1.1.1 FALSE readr 1.4.0 2.1.2 TRUE cpp11 0.2.7 0.4.2 FALSE stringi 1.6.1 1.7.6 TRUE Matrix 1.3-3 1.4-0 TRUE survival 3.2-11 3.3-1 TRUE lattice 0.20-44 0.20-45 TRUE class 7.3-19 7.3-20 TRUE proxy 0.4-25 0.4-26 TRUE haven 2.4.1 2.4.3 TRUE tidyr 1.1.3 1.2.0 TRUE survey 4.0 4.1-1 FALSE MASS 7.3-54 7.3-55 TRUE e1071 1.7-6 1.7-9 TRUE nlme 3.1-152 3.1-155 TRUE labelled 2.8.0 2.9.0 FALSE tableone 0.11.2 0.13.0 FALSE Binaries will be installed package &#39;bit&#39; successfully unpacked and MD5 sums checked package &#39;prettyunits&#39; successfully unpacked and MD5 sums checked package &#39;glue&#39; successfully unpacked and MD5 sums checked . Warning message: &#34;cannot remove prior installation of package &#39;glue&#39;&#34;Warning message in file.copy(savedcopy, lib, recursive = TRUE): &#34;C: Users cho_desktop anaconda3 Lib R library 00LOCK glue libs x64 glue.dll를 C: Users cho_desktop anaconda3 Lib R library glue libs x64 glue.dll로 복사하는데 문제가 발생했습니다: Permission denied&#34;Warning message: &#34;restored &#39;glue&#39;&#34; . package &#39;bit64&#39; successfully unpacked and MD5 sums checked package &#39;progress&#39; successfully unpacked and MD5 sums checked package &#39;cli&#39; successfully unpacked and MD5 sums checked package &#39;vroom&#39; successfully unpacked and MD5 sums checked package &#39;tzdb&#39; successfully unpacked and MD5 sums checked package &#39;gtools&#39; successfully unpacked and MD5 sums checked package &#39;forcats&#39; successfully unpacked and MD5 sums checked package &#39;readr&#39; successfully unpacked and MD5 sums checked package &#39;stringi&#39; successfully unpacked and MD5 sums checked package &#39;Matrix&#39; successfully unpacked and MD5 sums checked package &#39;survival&#39; successfully unpacked and MD5 sums checked package &#39;lattice&#39; successfully unpacked and MD5 sums checked package &#39;minqa&#39; successfully unpacked and MD5 sums checked package &#39;numDeriv&#39; successfully unpacked and MD5 sums checked package &#39;mitools&#39; successfully unpacked and MD5 sums checked package &#39;class&#39; successfully unpacked and MD5 sums checked package &#39;proxy&#39; successfully unpacked and MD5 sums checked package &#39;gdata&#39; successfully unpacked and MD5 sums checked package &#39;haven&#39; successfully unpacked and MD5 sums checked package &#39;stringr&#39; successfully unpacked and MD5 sums checked package &#39;tidyr&#39; successfully unpacked and MD5 sums checked package &#39;MASS&#39; successfully unpacked and MD5 sums checked package &#39;e1071&#39; successfully unpacked and MD5 sums checked package &#39;zoo&#39; successfully unpacked and MD5 sums checked package &#39;gmodels&#39; successfully unpacked and MD5 sums checked package &#39;nlme&#39; successfully unpacked and MD5 sums checked The downloaded binary packages are in C: Users cho_desktop AppData Local Temp RtmpC2VGFd downloaded_packages . installing the source packages &#39;withr&#39;, &#39;clipr&#39;, &#39;DBI&#39;, &#39;hms&#39;, &#39;cpp11&#39;, &#39;survey&#39;, &#39;labelled&#39;, &#39;tableone&#39; . library(plyr) library(dplyr) . Warning message: &#34;package &#39;plyr&#39; was built under R version 3.6.3&#34;Warning message: &#34;package &#39;dplyr&#39; was built under R version 3.6.3&#34; Attaching package: &#39;dplyr&#39; The following objects are masked from &#39;package:plyr&#39;: arrange, count, desc, failwith, id, mutate, rename, summarise, summarize The following objects are masked from &#39;package:stats&#39;: filter, lag The following objects are masked from &#39;package:base&#39;: intersect, setdiff, setequal, union . library(tableone) . Error in library(tableone): there is no package called &#39;tableone&#39; Traceback: 1. library(tableone) . &#44592;&#52488; &#53945;&#44053; . . aa &lt;- 1:5 # 벡터 bb &lt;- as.factor(aa) # 벡터 -&gt; factor cc &lt;- as.character(aa) # 벡터 -&gt; 케릭터 . bb # factor형 변수 # levels라는 한줄이 더 나온다. # 범주형변수 factor로 인식시켜줘야, 범주의 갯수와 종류를 print해준다. . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 4 | 5 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &#39;4&#39; | &#39;5&#39; | &lt;/ol&gt; cc # 문자형이라서 큰따옴표로 나온다 in R studio . &lt;ol class=list-inline&gt; &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &#39;4&#39; | &#39;5&#39; | &lt;/ol&gt; aa # numeric은 가감승제가 가능하다. . aa + 1 # 더하면 벡터 전체에 일괄 적용 된다. . &lt;ol class=list-inline&gt; 2 | 3 | 4 | 5 | 6 | &lt;/ol&gt; bb + 1 # 팩터형 변수에는 가감승제를 해줄 수 없다. . Warning message in Ops.factor(bb, 1): &#34;&#39;+&#39; not meaningful for factors&#34; . &lt;ol class=list-inline&gt; &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;/ol&gt; cc + 1 # 케릭터형 변수에는 가감승제를 할 수 없다. . Error in cc + 1: 이항연산자에 수치가 아닌 인수입니다 Traceback: . typeof(aa) . &#39;integer&#39; typeof(bb) # factor형은 내부에서 integer로 저장한다. . &#39;integer&#39; typeof(cc) . &#39;character&#39; . . dd &lt;- data.frame( aa, bb, cc) # 개별 벡터들을 넣어주면, 변수=&gt;칼럼이 된다. dd . aabbcc . 1 | 1 | 1 | . 2 | 2 | 2 | . 3 | 3 | 3 | . 4 | 4 | 4 | . 5 | 5 | 5 | . # data.frame은 type이 달라도 모아서 사용할 수 있다. . summary(dd) # aa: 연속형변수 -&gt; 기본? 통계가 잘 나온다 # bb: 각 범주에 갯수를 표시한 범주형 변수 -&gt; 도수분표표 # cc: 캐릭터변수 -&gt; 길이에다가 설명 # 데이터클리닝 최종목표 : summary에 넣었을 때 정상적으로 나와야함. . aa bb cc Min. :1 1:1 1:1 1st Qu.:2 2:1 2:1 Median :3 3:1 3:1 Mean :3 4:1 4:1 3rd Qu.:4 5:1 5:1 Max. :5 . . &#54056;&#53412;&#51648; &#49444;&#52824; &#48143; &#47196;&#46300; . dply r &#54056;&#53412;&#51648;&#51032; &#54028;&#51060;&#54532;&#46972;&#51064;&#47484; &#51060;&#50857;&#54620; &#45936;&#51060;&#53552;&#53364;&#47532;&#45789; . &#54028;&#51060;&#54532;&#46972;&#51064; &#49444;&#47749; . aa . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 4 | 5 | &lt;/ol&gt; log(aa) . &lt;ol class=list-inline&gt; 0 | 0.693147180559945 | 1.09861228866811 | 1.38629436111989 | 1.6094379124341 | &lt;/ol&gt; aa %&gt;% log() . &lt;ol class=list-inline&gt; 0 | 0.693147180559945 | 1.09861228866811 | 1.38629436111989 | 1.6094379124341 | &lt;/ol&gt; # 체이닝해서.. 여러가지 작업을 할 경우, 그 과정을 알 수 있다. round( sum( log(aa) ) ) . 5 # 왼쪽부터 읽는 것 &lt;-&gt; 호출 순서가 다른 것을 # 파이프라인으로 순서대로 읽고 실행되게 aa %&gt;% log() %&gt;% sum() %&gt;% round() . 5 &#51089;&#50629;&#50689;&#50669; &#51648;&#51221; &#46321; . &#45936;&#51060;&#53552;&#53364;&#47532;&#45789; . &#47196;&#46300; &#51204;, &#45936;&#51060;&#53552;&#47484; &#51069;&#44592;&#51204;&#50857;&#51004;&#47196; &#48708;&#45012;&#51452;&#44592; . . # 데이터를 객체에 저장 dat0 &lt;- read.csv(&#39;./data/특강//example_dataset.csv&#39;) # stringAsFactors = F) # R버전 4이하인 경우 수행해야함. . head(dat0) . idagesexRecur..1..Recur..0..Censored.OP_dateRecur_datelocal_6mCA19.9CEATNMCCIadc_decreaseadc_5_decreasevolume_changeapt_1_meanapt_1_95padc_1_meanadc_1_5p . 1 | 79 | 1 | 1 | 2014-07-07 | 2014-08-10 | 1 | 4490 | 8.7 | 5 | 1 | 8.83908844 | 1.8832245 | -2.357226849 | 5.167 | 2.840 | 89.37554932 | 53.85543 | . 2 | 54 | 0 | 0 | 2013-05-07 | 2018-07-07 | 1 | 37.8 | 2.5 | 4 | 1 | -2.473731995 | 6.4843369 | 140.736618 | 2.967 | 3.753 | 130.4454651 | 82.87475 | . 3 | 31 | 1 | 0 | 2016-05-06 | 2020-01-11 | 0 | 36.6 | 3.0 | 5 | 1 | 24.08946228 | 11.6069794 | 57.76787567 | 2.444 | 3.114 | 127.4504852 | 84.46223 | . 4 | 39 | 1 | 1 | 2015-11-25 | 2017-08-03 | 0 | 65 | 16.6 | 4 | 2 | 42.83881378 | 0.7782211 | 3.21591568 | 2.952 | 3.651 | 114.5146027 | 74.28822 | . 5 | 50 | 1 | 1 | 2015-02-09 | 2016-06-01 | 1 | 38.9 | 4.0 | 5 | 1 | 5.897392273 | 2.9760971 | -3.059473038 | 0.628 | 1.795 | 99.98454285 | 75.61291 | . 6 | 69 | 1 | 1 | 2015-06-22 | 2016-02-12 | 1 | 5.9 | 4.5 | 5 | 1 | na | 11.0519104 | 26.99385071 | 5.167 | 3.646 | 144.8905334 | 95.49654 | . view() &#48712; &#45936;&#51060;&#53552;&#44032; NA&#47196; &#51064;&#49885;&#46104;&#45716;&#51648; &#54869;&#51064;&#54616;&#44592; . view(dat0) # 엑셀 저장 실수로 빈 데이터가 NA로 차있다. -&gt; 50행까지만 읽자. . Error in view(dat0): 함수 &#34;view&#34;를 찾을 수 없습니다 Traceback: . # dat0 &lt;- read.csv(&#39;./data/특강//example_dataset.csv&#39;) # 빈 데이터는 제끼기 dat0 &lt;- read.csv(&#39;./data/특강//example_dataset.csv&#39;, nrow=50) . id&#44032; &#50976;&#45768;&#53356;&#54620;&#51648; (&#51473;&#48373;distinct.count) &#54869;&#51064; &#54616;&#44592; . head(dat0) . idagesexRecur..1..Recur..0..Censored.OP_dateRecur_datelocal_6mCA19.9CEATNMCCIadc_decreaseadc_5_decreasevolume_changeapt_1_meanapt_1_95padc_1_meanadc_1_5p . 1 | 79 | 1 | 1 | 2014-07-07 | 2014-08-10 | 1 | 4490 | 8.7 | 5 | 1 | 8.83908844 | 1.8832245 | -2.357226849 | 5.167 | 2.840 | 89.37554932 | 53.85543 | . 2 | 54 | 0 | 0 | 2013-05-07 | 2018-07-07 | 1 | 37.8 | 2.5 | 4 | 1 | -2.473731995 | 6.4843369 | 140.736618 | 2.967 | 3.753 | 130.4454651 | 82.87475 | . 3 | 31 | 1 | 0 | 2016-05-06 | 2020-01-11 | 0 | 36.6 | 3.0 | 5 | 1 | 24.08946228 | 11.6069794 | 57.76787567 | 2.444 | 3.114 | 127.4504852 | 84.46223 | . 4 | 39 | 1 | 1 | 2015-11-25 | 2017-08-03 | 0 | 65 | 16.6 | 4 | 2 | 42.83881378 | 0.7782211 | 3.21591568 | 2.952 | 3.651 | 114.5146027 | 74.28822 | . 5 | 50 | 1 | 1 | 2015-02-09 | 2016-06-01 | 1 | 38.9 | 4.0 | 5 | 1 | 5.897392273 | 2.9760971 | -3.059473038 | 0.628 | 1.795 | 99.98454285 | 75.61291 | . 6 | 69 | 1 | 1 | 2015-06-22 | 2016-02-12 | 1 | 5.9 | 4.5 | 5 | 1 | na | 11.0519104 | 26.99385071 | 5.167 | 3.646 | 144.8905334 | 95.49654 | . length(unique(dat0$id)) . 50 . &#47785;&#54364;&#51064; summary&#50640; &#45347;&#50612;&#48372;&#44592; . summary(dat0) . id age sex Recur..1..Recur..0..Censored. Min. : 1.00 Min. :25.00 Min. :0.00 Min. :0.00 1st Qu.:13.25 1st Qu.:49.25 1st Qu.:0.00 1st Qu.:0.00 Median :25.50 Median :58.50 Median :1.00 Median :0.00 Mean :25.50 Mean :56.44 Mean :0.66 Mean :0.44 3rd Qu.:37.75 3rd Qu.:65.75 3rd Qu.:1.00 3rd Qu.:1.00 Max. :50.00 Max. :79.00 Max. :1.00 Max. :1.00 OP_date Recur_date local_6m CA19.9 CEA 2011-12-29: 1 2018-07-07: 3 Min. :0.00 &lt;1.0 : 2 Min. : 0.630 2012-01-27: 1 2019-11-15: 2 1st Qu.:0.00 10.8 : 2 1st Qu.: 1.450 2012-03-13: 1 2019-11-19: 2 Median :0.00 5.9 : 2 Median : 2.500 2012-08-14: 1 2012-04-09: 1 Mean :0.46 10.7 : 1 Mean : 5.574 2012-09-20: 1 2012-08-29: 1 3rd Qu.:1.00 11.4 : 1 3rd Qu.: 4.150 2013-05-07: 1 2013-05-28: 1 Max. :1.00 12.1 : 1 Max. :115.900 (Other) :44 (Other) :40 (Other):41 TNM CCI adc_decrease adc_5_decrease Min. :1.00 Min. :0 42.83881378 : 9 Min. :-6.717 1st Qu.:3.00 1st Qu.:1 -2.473731995: 4 1st Qu.: 2.566 Median :4.00 Median :2 -1.790367126: 1 Median :11.329 Mean :3.56 Mean :2 . : 1 Mean :10.998 3rd Qu.:4.00 3rd Qu.:3 0.423 : 1 3rd Qu.:15.638 Max. :5.00 Max. :6 10.24687958 : 1 Max. :63.617 (Other) :33 volume_change apt_1_mean apt_1_95p adc_1_mean n/a : 2 Min. : 0.628 Min. :1.267 : 1 -12.57099533: 1 1st Qu.: 1.831 1st Qu.:2.517 100.3332748: 1 -14.51074219: 1 Median : 2.510 Median :3.034 100.7850723: 1 -2.133106232: 1 Mean : 3.129 Mean :3.065 101.1288986: 1 -2.357226849: 1 3rd Qu.: 3.100 3rd Qu.:3.650 106.94384 : 1 -20.45214844: 1 Max. :27.473 Max. :5.437 107.4796753: 1 (Other) :43 (Other) :44 adc_1_5p Min. : 53.86 1st Qu.: 75.78 Median : 85.10 Mean : 85.03 3rd Qu.: 92.43 Max. :116.59 . . # Recur -&gt; 변수명 짧게 # 날짜 -&gt; character로 인식함 #local_6m # ca19.9 -&gt; 케릭터로 인식됨. . &#48320;&#49688;&#47749; &#44596; &#44163;&#48512;&#53552; &#52376;&#47532; . dat0$Recur..1..Recur..0..Censored. . # 클리닝하명 dat1에 &lt;- . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) . &#45216;&#51676;&#54805;&#51004;&#47196; &#48148;&#45012;&#51452;&#44592; . dat0$OP_date . &lt;ol class=list-inline&gt; 2014-07-07 | 2013-05-07 | 2016-05-06 | 2015-11-25 | 2015-02-09 | 2015-06-22 | 2017-02-10 | 2012-09-20 | 2016-05-20 | 2017-05-19 | 2016-01-11 | 2015-11-24 | 2012-08-14 | 2016-07-13 | 2015-08-31 | 2015-12-16 | 2015-02-04 | 2015-07-23 | 2015-10-23 | 2011-12-29 | 2016-10-18 | 2012-01-27 | 2017-11-14 | 2017-07-27 | 2015-05-22 | 2015-02-26 | 2017-05-17 | 2016-03-14 | 2017-03-14 | 2016-09-20 | 2014-08-08 | 2016-10-12 | 2016-07-22 | 2016-01-26 | 2016-05-23 | 2017-06-29 | 2016-09-28 | 2017-09-05 | 2016-02-29 | 2013-12-20 | 2012-03-13 | 2015-09-10 | 2014-07-31 | 2015-01-27 | 2014-05-23 | 2017-08-21 | 2014-05-09 | 2015-07-21 | 2015-02-03 | 2015-09-07 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;2011-12-29&#39; | &#39;2012-01-27&#39; | &#39;2012-03-13&#39; | &#39;2012-08-14&#39; | &#39;2012-09-20&#39; | &#39;2013-05-07&#39; | &#39;2013-12-20&#39; | &#39;2014-05-09&#39; | &#39;2014-05-23&#39; | &#39;2014-07-07&#39; | &#39;2014-07-31&#39; | &#39;2014-08-08&#39; | &#39;2015-01-27&#39; | &#39;2015-02-03&#39; | &#39;2015-02-04&#39; | &#39;2015-02-09&#39; | &#39;2015-02-26&#39; | &#39;2015-05-22&#39; | &#39;2015-06-22&#39; | &#39;2015-07-21&#39; | &#39;2015-07-23&#39; | &#39;2015-08-31&#39; | &#39;2015-09-07&#39; | &#39;2015-09-10&#39; | &#39;2015-10-23&#39; | &#39;2015-11-24&#39; | &#39;2015-11-25&#39; | &#39;2015-12-16&#39; | &#39;2016-01-11&#39; | &#39;2016-01-26&#39; | &#39;2016-02-29&#39; | &#39;2016-03-14&#39; | &#39;2016-05-06&#39; | &#39;2016-05-20&#39; | &#39;2016-05-23&#39; | &#39;2016-07-13&#39; | &#39;2016-07-22&#39; | &#39;2016-09-20&#39; | &#39;2016-09-28&#39; | &#39;2016-10-12&#39; | &#39;2016-10-18&#39; | &#39;2017-02-10&#39; | &#39;2017-03-14&#39; | &#39;2017-05-17&#39; | &#39;2017-05-19&#39; | &#39;2017-06-29&#39; | &#39;2017-07-27&#39; | &#39;2017-08-21&#39; | &#39;2017-09-05&#39; | &#39;2017-11-14&#39; | &lt;/ol&gt; # 이것으로 확인한다. -&gt; 안되면 케릭터로 잘못 된 것임 dat0$OP_date + 1 . Warning message in Ops.factor(dat0$OP_date, 1): &#34;&#39;+&#39; not meaningful for factors&#34; . &lt;ol class=list-inline&gt; &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;/ol&gt; as.Date(dat0$OP_date, format = &quot;%Y-%m-%d&quot;) + 1 # 에러 안나면 성공임. . &lt;ol class=list-inline&gt; 2014-07-08 | 2013-05-08 | 2016-05-07 | 2015-11-26 | 2015-02-10 | 2015-06-23 | 2017-02-11 | 2012-09-21 | 2016-05-21 | 2017-05-20 | 2016-01-12 | 2015-11-25 | 2012-08-15 | 2016-07-14 | 2015-09-01 | 2015-12-17 | 2015-02-05 | 2015-07-24 | 2015-10-24 | 2011-12-30 | 2016-10-19 | 2012-01-28 | 2017-11-15 | 2017-07-28 | 2015-05-23 | 2015-02-27 | 2017-05-18 | 2016-03-15 | 2017-03-15 | 2016-09-21 | 2014-08-09 | 2016-10-13 | 2016-07-23 | 2016-01-27 | 2016-05-24 | 2017-06-30 | 2016-09-29 | 2017-09-06 | 2016-03-01 | 2013-12-21 | 2012-03-14 | 2015-09-11 | 2014-08-01 | 2015-01-28 | 2014-05-24 | 2017-08-22 | 2014-05-10 | 2015-07-22 | 2015-02-04 | 2015-09-08 | &lt;/ol&gt; &#54028;&#51060;&#54532;&#46972;&#51064;&#51004;&#47196; &#53364;&#47532;&#45789;&#44284;&#51221; &#52628;&#44032;&#54616;&#44592; . # mutate( = )덮어써주기 . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate(OP_date=as.Date(OP_date, format = &quot;%Y-%m-%d&quot;)) # + 1) . mutate() &#45824;&#49888; mutate_at( vars(&#44057;&#51008;&#51089;&#50629;&#54624;, &#52860;&#47084;&#46308;), list(~&#51201;&#50857;&#54632;&#49688;(.&#51004;&#47196; &#52860;&#47100;&#45824;&#52404;)) &#47196; &#50668;&#47084;&#52860;&#47100; &#54620;&#48264;&#50640; &#52376;&#47532;&#54616;&#44592; . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) . summary(dat1) . id age sex Recur Min. : 1.00 Min. :25.00 Min. :0.00 Min. :0.00 1st Qu.:13.25 1st Qu.:49.25 1st Qu.:0.00 1st Qu.:0.00 Median :25.50 Median :58.50 Median :1.00 Median :0.00 Mean :25.50 Mean :56.44 Mean :0.66 Mean :0.44 3rd Qu.:37.75 3rd Qu.:65.75 3rd Qu.:1.00 3rd Qu.:1.00 Max. :50.00 Max. :79.00 Max. :1.00 Max. :1.00 OP_date Recur_date local_6m CA19.9 Min. :2011-12-29 Min. :2012-04-09 Min. :0.00 &lt;1.0 : 2 1st Qu.:2015-01-28 1st Qu.:2016-06-25 1st Qu.:0.00 10.8 : 2 Median :2015-11-08 Median :2018-03-13 Median :0.00 5.9 : 2 Mean :2015-08-11 Mean :2017-09-21 Mean :0.46 10.7 : 1 3rd Qu.:2016-09-05 3rd Qu.:2019-10-12 3rd Qu.:1.00 11.4 : 1 Max. :2017-11-14 Max. :2020-01-11 Max. :1.00 12.1 : 1 (Other):41 CEA TNM CCI adc_decrease Min. : 0.630 Min. :1.00 Min. :0 42.83881378 : 9 1st Qu.: 1.450 1st Qu.:3.00 1st Qu.:1 -2.473731995: 4 Median : 2.500 Median :4.00 Median :2 -1.790367126: 1 Mean : 5.574 Mean :3.56 Mean :2 . : 1 3rd Qu.: 4.150 3rd Qu.:4.00 3rd Qu.:3 0.423 : 1 Max. :115.900 Max. :5.00 Max. :6 10.24687958 : 1 (Other) :33 adc_5_decrease volume_change apt_1_mean apt_1_95p Min. :-6.717 n/a : 2 Min. : 0.628 Min. :1.267 1st Qu.: 2.566 -12.57099533: 1 1st Qu.: 1.831 1st Qu.:2.517 Median :11.329 -14.51074219: 1 Median : 2.510 Median :3.034 Mean :10.998 -2.133106232: 1 Mean : 3.129 Mean :3.065 3rd Qu.:15.638 -2.357226849: 1 3rd Qu.: 3.100 3rd Qu.:3.650 Max. :63.617 -20.45214844: 1 Max. :27.473 Max. :5.437 (Other) :43 adc_1_mean adc_1_5p : 1 Min. : 53.86 100.3332748: 1 1st Qu.: 75.78 100.7850723: 1 Median : 85.10 101.1288986: 1 Mean : 85.03 106.94384 : 1 3rd Qu.: 92.43 107.4796753: 1 Max. :116.59 (Other) :44 . &#50672;&#49549;&#54805;&#51064;&#45936; character&#51064; &#50528;&#46308; . dat0$CA19.9 # 피검사 랩value # ~보다 작다(&lt;1)로 입력되는 경우가 많은데, 숫자가 아닌 . &lt;ol class=list-inline&gt; 4490 | 37.8 | 36.6 | 65 | 38.9 | 5.9 | 23.3 | 53.2 | 19.8 | 84.7 | 4860 | 50.2 | 15.9 | 18.9 | &lt;1.0 | 59.4 | 12.6 | 81.4 | 2500 | 6.6 | 71.1 | 4.3 | 68.7 | 11.4 | 10.8 | 10.8 | 5.9 | 3.3 | 14.4 | 47.9 | 25.6 | 134.1 | 10.7 | 472 | 160.6 | 23.2 | 20.4 | 3.4 | 55.3 | 9.2 | 5.1 | 12.1 | 2647 | 24.5 | 17.9 | 33.8 | 5.8 | 5.6 | &lt;1.0 | 99.3 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;&lt;1.0&#39; | &#39;10.7&#39; | &#39;10.8&#39; | &#39;11.4&#39; | &#39;12.1&#39; | &#39;12.6&#39; | &#39;134.1&#39; | &#39;14.4&#39; | &#39;15.9&#39; | &#39;160.6&#39; | &#39;17.9&#39; | &#39;18.9&#39; | &#39;19.8&#39; | &#39;20.4&#39; | &#39;23.2&#39; | &#39;23.3&#39; | &#39;24.5&#39; | &#39;25.6&#39; | &#39;2500&#39; | &#39;2647&#39; | &#39;3.3&#39; | &#39;3.4&#39; | &#39;33.8&#39; | &#39;36.6&#39; | &#39;37.8&#39; | &#39;38.9&#39; | &#39;4.3&#39; | &#39;4490&#39; | &#39;47.9&#39; | &#39;472&#39; | &#39;4860&#39; | &#39;5.1&#39; | &#39;5.6&#39; | &#39;5.8&#39; | &#39;5.9&#39; | &#39;50.2&#39; | &#39;53.2&#39; | &#39;55.3&#39; | &#39;59.4&#39; | &#39;6.6&#39; | &#39;65&#39; | &#39;68.7&#39; | &#39;71.1&#39; | &#39;81.4&#39; | &#39;84.7&#39; | &#39;9.2&#39; | &#39;99.3&#39; | &lt;/ol&gt; . replace&#47196; &#47928;&#51088;&#50676;&#49707;&#51088; -&gt; &#49707;&#51088;&#47196; &#48148;&#45012;&#51452;&#44592; . replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)#위치 #바꿀값 # 숫자로 바꿔졌찌만, 칼럼 전체가 케릭터(팩터)라 &quot;1&quot;로 들어갈 듯 # 칼럼 전체가 응답된다. . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . &lt;ol class=list-inline&gt; 4490 | 37.8 | 36.6 | 65 | 38.9 | 5.9 | 23.3 | 53.2 | 19.8 | 84.7 | 4860 | 50.2 | 15.9 | 18.9 | &lt;NA&gt; | 59.4 | 12.6 | 81.4 | 2500 | 6.6 | 71.1 | 4.3 | 68.7 | 11.4 | 10.8 | 10.8 | 5.9 | 3.3 | 14.4 | 47.9 | 25.6 | 134.1 | 10.7 | 472 | 160.6 | 23.2 | 20.4 | 3.4 | 55.3 | 9.2 | 5.1 | 12.1 | 2647 | 24.5 | 17.9 | 33.8 | 5.8 | 5.6 | &lt;NA&gt; | 99.3 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;&lt;1.0&#39; | &#39;10.7&#39; | &#39;10.8&#39; | &#39;11.4&#39; | &#39;12.1&#39; | &#39;12.6&#39; | &#39;134.1&#39; | &#39;14.4&#39; | &#39;15.9&#39; | &#39;160.6&#39; | &#39;17.9&#39; | &#39;18.9&#39; | &#39;19.8&#39; | &#39;20.4&#39; | &#39;23.2&#39; | &#39;23.3&#39; | &#39;24.5&#39; | &#39;25.6&#39; | &#39;2500&#39; | &#39;2647&#39; | &#39;3.3&#39; | &#39;3.4&#39; | &#39;33.8&#39; | &#39;36.6&#39; | &#39;37.8&#39; | &#39;38.9&#39; | &#39;4.3&#39; | &#39;4490&#39; | &#39;47.9&#39; | &#39;472&#39; | &#39;4860&#39; | &#39;5.1&#39; | &#39;5.6&#39; | &#39;5.8&#39; | &#39;5.9&#39; | &#39;50.2&#39; | &#39;53.2&#39; | &#39;55.3&#39; | &#39;59.4&#39; | &#39;6.6&#39; | &#39;65&#39; | &#39;68.7&#39; | &#39;71.1&#39; | &#39;81.4&#39; | &#39;84.7&#39; | &#39;9.2&#39; | &#39;99.3&#39; | &lt;/ol&gt; as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . &lt;ol class=list-inline&gt; 28 | 25 | 24 | 41 | 26 | 35 | 16 | 37 | 13 | 45 | 31 | 36 | 9 | 12 | &lt;NA&gt; | 39 | 6 | 44 | 19 | 40 | 43 | 27 | 42 | 4 | 3 | 3 | 35 | 21 | 8 | 29 | 18 | 7 | 2 | 30 | 10 | 15 | 14 | 22 | 38 | 46 | 32 | 5 | 20 | 17 | 11 | 23 | 34 | 33 | &lt;NA&gt; | 47 | &lt;/ol&gt; dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . summary(dat1) . id age sex Recur Min. : 1.00 Min. :25.00 Min. :0.00 Min. :0.00 1st Qu.:13.25 1st Qu.:49.25 1st Qu.:0.00 1st Qu.:0.00 Median :25.50 Median :58.50 Median :1.00 Median :0.00 Mean :25.50 Mean :56.44 Mean :0.66 Mean :0.44 3rd Qu.:37.75 3rd Qu.:65.75 3rd Qu.:1.00 3rd Qu.:1.00 Max. :50.00 Max. :79.00 Max. :1.00 Max. :1.00 OP_date Recur_date local_6m CA19.9 Min. :2011-12-29 Min. :2012-04-09 Min. :0.00 Min. : 2.00 1st Qu.:2015-01-28 1st Qu.:2016-06-25 1st Qu.:0.00 1st Qu.:12.75 Median :2015-11-08 Median :2018-03-13 Median :0.00 Median :24.50 Mean :2015-08-11 Mean :2017-09-21 Mean :0.46 Mean :24.27 3rd Qu.:2016-09-05 3rd Qu.:2019-10-12 3rd Qu.:1.00 3rd Qu.:35.25 Max. :2017-11-14 Max. :2020-01-11 Max. :1.00 Max. :47.00 NA&#39;s :2 CEA TNM CCI adc_decrease Min. : 0.630 Min. :1.00 Min. :0 42.83881378 : 9 1st Qu.: 1.450 1st Qu.:3.00 1st Qu.:1 -2.473731995: 4 Median : 2.500 Median :4.00 Median :2 -1.790367126: 1 Mean : 5.574 Mean :3.56 Mean :2 . : 1 3rd Qu.: 4.150 3rd Qu.:4.00 3rd Qu.:3 0.423 : 1 Max. :115.900 Max. :5.00 Max. :6 10.24687958 : 1 (Other) :33 adc_5_decrease volume_change apt_1_mean apt_1_95p Min. :-6.717 n/a : 2 Min. : 0.628 Min. :1.267 1st Qu.: 2.566 -12.57099533: 1 1st Qu.: 1.831 1st Qu.:2.517 Median :11.329 -14.51074219: 1 Median : 2.510 Median :3.034 Mean :10.998 -2.133106232: 1 Mean : 3.129 Mean :3.065 3rd Qu.:15.638 -2.357226849: 1 3rd Qu.: 3.100 3rd Qu.:3.650 Max. :63.617 -20.45214844: 1 Max. :27.473 Max. :5.437 (Other) :43 adc_1_mean adc_1_5p : 1 Min. : 53.86 100.3332748: 1 1st Qu.: 75.78 100.7850723: 1 Median : 85.10 101.1288986: 1 Mean : 85.03 106.94384 : 1 3rd Qu.: 92.43 107.4796753: 1 Max. :116.59 (Other) :44 . &#47928;&#51088;&#50676;&quot;.&quot;&#44284; &quot;na&quot;&#51060;&#44032; &#46308;&#50612;&#44032;&#51080;&#45716; &#49707;&#51088;&#54805; &#48320;&#49688; -&gt; &#44208;&#52769;(&#45824;&#47928;&#51088; &quot;NA&quot;)&#51004;&#47196; &#52376;&#47532;&#54644;&#48372;&#51088;. . dat0$adc_decrease . &lt;ol class=list-inline&gt; 8.83908844 | -2.473731995 | 24.08946228 | 42.83881378 | 5.897392273 | na | 12.79924774 | 42.83881378 | 10.24687958 | 16.47277069 | 3.877372742 | 17.01249695 | 4.098892212 | 42.83881378 | 30.9415741 | 11.229599 | 42.83881378 | 37.16684723 | 25.70823669 | -2.473731995 | 40.03754425 | 17.24663544 | 5.312309265 | 33.87471008 | 42.83881378 | 26.80117798 | 6.082252502 | 35.74214172 | 42.83881378 | 21.19241333 | 15.09790039 | 7.512702942 | 9.244918823 | 25.51950836 | 42.83881378 | . | 22.15099335 | 12.68886566 | 17.57089233 | 42.83881378 | 70.52548981 | 10.59333801 | -1.790367126 | 19.15110016 | -2.473731995 | 0.423 | 42.83881378 | 15.3989563 | -2.473731995 | 40.38618469 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;-1.790367126&#39; | &#39;-2.473731995&#39; | &#39;.&#39; | &#39;0.423&#39; | &#39;10.24687958&#39; | &#39;10.59333801&#39; | &#39;11.229599&#39; | &#39;12.68886566&#39; | &#39;12.79924774&#39; | &#39;15.09790039&#39; | &#39;15.3989563&#39; | &#39;16.47277069&#39; | &#39;17.01249695&#39; | &#39;17.24663544&#39; | &#39;17.57089233&#39; | &#39;19.15110016&#39; | &#39;21.19241333&#39; | &#39;22.15099335&#39; | &#39;24.08946228&#39; | &#39;25.51950836&#39; | &#39;25.70823669&#39; | &#39;26.80117798&#39; | &#39;3.877372742&#39; | &#39;30.9415741&#39; | &#39;33.87471008&#39; | &#39;35.74214172&#39; | &#39;37.16684723&#39; | &#39;4.098892212&#39; | &#39;40.03754425&#39; | &#39;40.38618469&#39; | &#39;42.83881378&#39; | &#39;5.312309265&#39; | &#39;5.897392273&#39; | &#39;6.082252502&#39; | &#39;7.512702942&#39; | &#39;70.52548981&#39; | &#39;8.83908844&#39; | &#39;9.244918823&#39; | &#39;na&#39; | &lt;/ol&gt; dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . summary(dat1) . id age sex Recur Min. : 1.00 Min. :25.00 Min. :0.00 Min. :0.00 1st Qu.:13.25 1st Qu.:49.25 1st Qu.:0.00 1st Qu.:0.00 Median :25.50 Median :58.50 Median :1.00 Median :0.00 Mean :25.50 Mean :56.44 Mean :0.66 Mean :0.44 3rd Qu.:37.75 3rd Qu.:65.75 3rd Qu.:1.00 3rd Qu.:1.00 Max. :50.00 Max. :79.00 Max. :1.00 Max. :1.00 OP_date Recur_date local_6m CA19.9 Min. :2011-12-29 Min. :2012-04-09 Min. :0.00 Min. : 2.00 1st Qu.:2015-01-28 1st Qu.:2016-06-25 1st Qu.:0.00 1st Qu.:12.75 Median :2015-11-08 Median :2018-03-13 Median :0.00 Median :24.50 Mean :2015-08-11 Mean :2017-09-21 Mean :0.46 Mean :24.27 3rd Qu.:2016-09-05 3rd Qu.:2019-10-12 3rd Qu.:1.00 3rd Qu.:35.25 Max. :2017-11-14 Max. :2020-01-11 Max. :1.00 Max. :47.00 NA&#39;s :2 CEA TNM CCI adc_decrease adc_5_decrease Min. : 0.630 Min. :1.00 Min. :0 Min. : 1.00 Min. :-6.717 1st Qu.: 1.450 1st Qu.:3.00 1st Qu.:1 1st Qu.:10.75 1st Qu.: 2.566 Median : 2.500 Median :4.00 Median :2 Median :22.50 Median :11.329 Mean : 5.574 Mean :3.56 Mean :2 Mean :20.67 Mean :10.998 3rd Qu.: 4.150 3rd Qu.:4.00 3rd Qu.:3 3rd Qu.:31.00 3rd Qu.:15.638 Max. :115.900 Max. :5.00 Max. :6 Max. :38.00 Max. :63.617 NA&#39;s :2 volume_change apt_1_mean apt_1_95p adc_1_mean n/a : 2 Min. : 0.628 Min. :1.267 : 1 -12.57099533: 1 1st Qu.: 1.831 1st Qu.:2.517 100.3332748: 1 -14.51074219: 1 Median : 2.510 Median :3.034 100.7850723: 1 -2.133106232: 1 Mean : 3.129 Mean :3.065 101.1288986: 1 -2.357226849: 1 3rd Qu.: 3.100 3rd Qu.:3.650 106.94384 : 1 -20.45214844: 1 Max. :27.473 Max. :5.437 107.4796753: 1 (Other) :43 (Other) :44 adc_1_5p Min. : 53.86 1st Qu.: 75.78 Median : 85.10 Mean : 85.03 3rd Qu.: 92.43 Max. :116.59 . &quot;n/a&quot; &#52376;&#47532; volume_change&#51032; &#47928;&#51228; . dat0$volume_change . &lt;ol class=list-inline&gt; -2.357226849 | 140.736618 | 57.76787567 | 3.21591568 | -3.059473038 | 26.99385071 | 15.75263786 | -14.51074219 | 35.89277363 | -23.29013634 | -24.1180644 | n/a | 14.30595779 | n/a | 61.12881088 | 80.11054611 | 29.39501953 | 80.77587891 | -42.23847198 | 68.45624542 | 64.41679382 | 116.6783257 | 8.413768768 | 14.72431612 | 7.143749237 | 1.901952744 | 33.4467752 | 118.6039994 | 119.1181564 | 3.223827362 | 80.79081726 | -28.04677582 | -6.659473419 | 39.32578278 | -2.133106232 | 71.6211853 | 88.36875153 | 23.59248352 | 4.665237427 | 21.60439301 | 51.39668274 | 40.27851391 | -12.57099533 | -5.537094116 | 91.3113327 | 24.23391724 | 12.77226639 | 34.60077667 | -20.45214844 | 125.2863274 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;-12.57099533&#39; | &#39;-14.51074219&#39; | &#39;-2.133106232&#39; | &#39;-2.357226849&#39; | &#39;-20.45214844&#39; | &#39;-23.29013634&#39; | &#39;-24.1180644&#39; | &#39;-28.04677582&#39; | &#39;-3.059473038&#39; | &#39;-42.23847198&#39; | &#39;-5.537094116&#39; | &#39;-6.659473419&#39; | &#39;1.901952744&#39; | &#39;116.6783257&#39; | &#39;118.6039994&#39; | &#39;119.1181564&#39; | &#39;12.77226639&#39; | &#39;125.2863274&#39; | &#39;14.30595779&#39; | &#39;14.72431612&#39; | &#39;140.736618&#39; | &#39;15.75263786&#39; | &#39;21.60439301&#39; | &#39;23.59248352&#39; | &#39;24.23391724&#39; | &#39;26.99385071&#39; | &#39;29.39501953&#39; | &#39;3.21591568&#39; | &#39;3.223827362&#39; | &#39;33.4467752&#39; | &#39;34.60077667&#39; | &#39;35.89277363&#39; | &#39;39.32578278&#39; | &#39;4.665237427&#39; | &#39;40.27851391&#39; | &#39;51.39668274&#39; | &#39;57.76787567&#39; | &#39;61.12881088&#39; | &#39;64.41679382&#39; | &#39;68.45624542&#39; | &#39;7.143749237&#39; | &#39;71.6211853&#39; | &#39;8.413768768&#39; | &#39;80.11054611&#39; | &#39;80.77587891&#39; | &#39;80.79081726&#39; | &#39;88.36875153&#39; | &#39;91.3113327&#39; | &#39;n/a&#39; | &lt;/ol&gt; dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), # 마지막엔 더블형변환해야하니 as.double부터 volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . &#48276;&#51452;&#54805;&#51064;&#45936;, &#50672;&#49549;&#54805;&#51004;&#47196; &#54364;&#44592;&#46104;&#50612;&#51080;&#45716; &#44057;&#51008;&#51089;&#50629;&#46308; -&gt; mutate_at&#51004;&#47196; &#52376;&#47532; . local_6m , sex? | . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), # 마지막엔 더블형변환해야하니 as.double부터 volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA))) %&gt;% mutate_at(vars(sex, Recur, local_6m, TNM, CCI), list(~as.factor(.))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . summary(dat1) . id age sex Recur OP_date Min. : 1.00 Min. :25.00 0:17 0:28 Min. :2011-12-29 1st Qu.:13.25 1st Qu.:49.25 1:33 1:22 1st Qu.:2015-01-28 Median :25.50 Median :58.50 Median :2015-11-08 Mean :25.50 Mean :56.44 Mean :2015-08-11 3rd Qu.:37.75 3rd Qu.:65.75 3rd Qu.:2016-09-05 Max. :50.00 Max. :79.00 Max. :2017-11-14 Recur_date local_6m CA19.9 CEA TNM CCI Min. :2012-04-09 0:27 Min. : 2.00 Min. : 0.630 1: 2 0: 3 1st Qu.:2016-06-25 1:23 1st Qu.:12.75 1st Qu.: 1.450 2: 5 1:16 Median :2018-03-13 Median :24.50 Median : 2.500 3:12 2:15 Mean :2017-09-21 Mean :24.27 Mean : 5.574 4:25 3:12 3rd Qu.:2019-10-12 3rd Qu.:35.25 3rd Qu.: 4.150 5: 6 4: 3 Max. :2020-01-11 Max. :47.00 Max. :115.900 6: 1 NA&#39;s :2 adc_decrease adc_5_decrease volume_change apt_1_mean Min. : 1.00 Min. :-6.717 Min. : 1.00 Min. : 0.628 1st Qu.:10.75 1st Qu.: 2.566 1st Qu.:12.75 1st Qu.: 1.831 Median :22.50 Median :11.329 Median :24.50 Median : 2.510 Mean :20.67 Mean :10.998 Mean :24.50 Mean : 3.129 3rd Qu.:31.00 3rd Qu.:15.638 3rd Qu.:36.25 3rd Qu.: 3.100 Max. :38.00 Max. :63.617 Max. :48.00 Max. :27.473 NA&#39;s :2 NA&#39;s :2 apt_1_95p adc_1_mean adc_1_5p Min. :1.267 : 1 Min. : 53.86 1st Qu.:2.517 100.3332748: 1 1st Qu.: 75.78 Median :3.034 100.7850723: 1 Median : 85.10 Mean :3.065 101.1288986: 1 Mean : 85.03 3rd Qu.:3.650 106.94384 : 1 3rd Qu.: 92.43 Max. :5.437 107.4796753: 1 Max. :116.59 (Other) :44 . &#53888;&#50612;&#45716; &#44050;&#46308;(LabValue&#46308;)&#51012; log&#48320;&#54872; . CA19.9 정상치는 거기서 거기인데, 이상인 경우 수천배로 팍 튀는 경우 -&gt; 데이터의 분포가 너무 길어져 원본으로는 다른변수와의 관계가 깨진다. | . hist&#47484; &#44536;&#47140;, &#44537;&#49548;&#49688;&#47564; &#50628;&#52397; &#53888;&#45716; &#44163;&#51012; &#54869;&#51064;&#54616;&#51088;. . hist(dat1$CA19.9) . &#12615;&#12615; . hist( log) . log.&#51012; &#48537;&#50668; &#49352;&#47196;&#50868; &#48320;&#49688;&#47196; &#52628;&#44032; . 0이 있으면 다른 값 or 1로 바꿔서 로그취해야함. | . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA)), # 여기(mutate)다 추가 log.CA19.9 = log(CA19.9), log.CEA=log(CEA) # 위에다 추가 ) %&gt;% mutate_at(vars(sex, Recur, local_6m, TNM, CCI), list(~as.factor(.))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . 36&#48516; &#48148;&#51060;&#45789; CA19 &#52628;&#44032; by ifelse -&gt; asfactor&#51089;&#50629;&#50640;&#46020; &#48320;&#49688; 1&#44060; &#52628;&#44032; . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA)), log.CA19.9 = log(CA19.9), log.CEA=log(CEA), CA19.9.group=ifelse(CA19.9&gt;37, 1, 0), # 칼럼 생성 ) %&gt;% mutate_at(vars(sex, Recur, local_6m, TNM, CCI, CA19.9 # factor화 추가 ), list(~as.factor(.))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . ply r &#51012; &#53685;&#54644; mapvalue (1,2&#47484; &#47926;&#50612; -&gt; TNM.b&#52860;&#47100;&#51004;&#47196;)&#50416;&#44592; . from 원래 카테고리 -&gt; to = 합칠거명 같은이름으로 순서대로 차례대로 카테고리 ) | 다시 범주형 만드는 곳에서 처리 | . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA)), log.CA19.9 = log(CA19.9), log.CEA=log(CEA), CA19.9.group=ifelse(CA19.9&gt;37, 1, 0), TNM.b = mapvalues(TNM, from=c(1,2,3,4,5), to=c(&quot;1or2&quot;, &quot;1or2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)), # 카테고리 합치기 ) %&gt;% mutate_at(vars(sex, Recur, local_6m, TNM, CCI, CA19.9, TNM.b # 추가 ), list(~as.factor(.))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA)), log.CA19.9 = log(CA19.9), log.CEA=log(CEA), CA19.9.group=ifelse(CA19.9&gt;37, 1, 0), TNM.b = mapvalues(TNM, from=c(1,2,3,4,5), to=c(&quot;1or2&quot;, &quot;1or2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)), CCI.b = mapvalues(CCI, from=c(0,1,2,3,4,6), to=c(&quot;0or1&quot;, &quot;0or1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;&gt;=4&quot;, &quot;&gt;=4&quot;)), ) %&gt;% mutate_at(vars(sex, Recur, local_6m, TNM, CCI, CA19.9, TNM.b # 추가 ), list(~as.factor(.))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . &#50668;&#44592;&#49436;&#48512;&#53552;&#45716; &#47803;&#46384;&#46972;&#44048; . # as.factor가 아닌 factor로 어떤 순서대로 카테고리를 하고싶은지 인식시켜준다 # 아래에서 as.factor부분에서 빼준다. . 45&#48516;&#48512;&#53552; &#47803;&#46384;&#46972;&#44048;.. . 48&#44620;&#51648; &#53364;&#47532;&#45789;&#51008; &#45149; . library(&quot;tableone&quot;) . tableone&#51004;&#47196; &#49789;&#44172; table&#47564;&#46308;&#44592; . var1&lt;-c(&quot;Recur&quot;, &quot;RFS&quot;, &quot;local_6m&quot;, &quot;age&quot;, &quot;sex&quot;, &quot;CA19.9&quot;, &quot;log.CA19.9&quot;, &quot;CA19.9.group&quot;, &quot;CEA&quot;, &quot;log.CEA&quot;, &quot;TNM&quot;, &quot;TNM.b&quot;, &quot;CCI&quot;, &quot;CCI.b&quot;, &quot;adc_decrease&quot;, &quot;adc_5_decrease&quot;, &quot;volume_change&quot;, &quot;apt_1_mean&quot;, &quot;apt_1_95p&quot;, &quot;adc_1_mean&quot;, &quot;adc_1_5p&quot;) . tobj&lt;-CreateTableOne(vars = var1, data=dat1) summary(tobj) . Warning message in ModuleReturnVarsExist(vars, data): &#34;The data frame does not have: RFS Dropped&#34; . ### Summary of continuous variables ### strata: Overall n miss p.miss mean sd median p25 p75 min max skew kurt age 50 0 0 56.4 12.6 58.5 49.2 66 25.0 79 -0.47 -0.3 log.CA19.9 50 2 4 2.9 0.8 3.2 2.5 4 0.7 4 -1.12 0.5 CA19.9.group 50 2 4 0.2 0.4 0.0 0.0 0 0.0 1 1.48 0.2 CEA 50 0 0 5.6 16.3 2.5 1.4 4 0.6 116 6.63 45.5 log.CEA 50 0 0 1.0 0.9 0.9 0.4 1 -0.5 5 1.81 5.8 adc_decrease 50 2 4 20.7 11.5 22.5 10.8 31 1.0 38 -0.31 -1.3 adc_5_decrease 50 0 0 11.0 12.2 11.3 2.6 16 -6.7 64 1.74 6.0 volume_change 50 2 4 24.5 14.0 24.5 12.8 36 1.0 48 0.00 -1.2 apt_1_mean 50 0 0 3.1 3.7 2.5 1.8 3 0.6 27 6.06 40.2 apt_1_95p 50 0 0 3.1 0.9 3.0 2.5 4 1.3 5 0.40 0.5 adc_1_5p 50 0 0 85.0 11.5 85.1 75.8 92 53.9 117 0.05 0.5 ======================================================================================= ### Summary of categorical variables ### strata: Overall var n miss p.miss level freq percent cum.percent Recur 50 0 0.0 0 28 56.0 56.0 1 22 44.0 100.0 local_6m 50 0 0.0 0 27 54.0 54.0 1 23 46.0 100.0 sex 50 0 0.0 0 17 34.0 34.0 1 33 66.0 100.0 CA19.9 50 2 4.0 2 1 2.1 2.1 3 2 4.2 6.2 4 1 2.1 8.3 5 1 2.1 10.4 6 1 2.1 12.5 7 1 2.1 14.6 8 1 2.1 16.7 9 1 2.1 18.8 10 1 2.1 20.8 11 1 2.1 22.9 12 1 2.1 25.0 13 1 2.1 27.1 14 1 2.1 29.2 15 1 2.1 31.2 16 1 2.1 33.3 17 1 2.1 35.4 18 1 2.1 37.5 19 1 2.1 39.6 20 1 2.1 41.7 21 1 2.1 43.8 22 1 2.1 45.8 23 1 2.1 47.9 24 1 2.1 50.0 25 1 2.1 52.1 26 1 2.1 54.2 27 1 2.1 56.2 28 1 2.1 58.3 29 1 2.1 60.4 30 1 2.1 62.5 31 1 2.1 64.6 32 1 2.1 66.7 33 1 2.1 68.8 34 1 2.1 70.8 35 2 4.2 75.0 36 1 2.1 77.1 37 1 2.1 79.2 38 1 2.1 81.2 39 1 2.1 83.3 40 1 2.1 85.4 41 1 2.1 87.5 42 1 2.1 89.6 43 1 2.1 91.7 44 1 2.1 93.8 45 1 2.1 95.8 46 1 2.1 97.9 47 1 2.1 100.0 TNM 50 0 0.0 1 2 4.0 4.0 2 5 10.0 14.0 3 12 24.0 38.0 4 25 50.0 88.0 5 6 12.0 100.0 TNM.b 50 0 0.0 1or2 7 14.0 14.0 3 12 24.0 38.0 4 25 50.0 88.0 5 6 12.0 100.0 CCI 50 0 0.0 0 3 6.0 6.0 1 16 32.0 38.0 2 15 30.0 68.0 3 12 24.0 92.0 4 3 6.0 98.0 6 1 2.0 100.0 CCI.b 50 0 0.0 &gt;=4 4 8.0 8.0 0or1 19 38.0 46.0 2 15 30.0 76.0 3 12 24.0 100.0 adc_1_mean 50 0 0.0 1 2.0 2.0 100.3332748 1 2.0 4.0 100.7850723 1 2.0 6.0 101.1288986 1 2.0 8.0 106.94384 1 2.0 10.0 107.4796753 1 2.0 12.0 108.1219025 1 2.0 14.0 108.4807739 1 2.0 16.0 109.8269577 1 2.0 18.0 110.6593323 1 2.0 20.0 112.250946 1 2.0 22.0 112.6311264 1 2.0 24.0 113.6343842 1 2.0 26.0 114.5146027 1 2.0 28.0 116.6255951 1 2.0 30.0 116.9603348 1 2.0 32.0 119.7995605 1 2.0 34.0 121.1716843 1 2.0 36.0 123.4509964 1 2.0 38.0 123.5778046 1 2.0 40.0 125.6047516 1 2.0 42.0 125.8717575 1 2.0 44.0 127.4504852 1 2.0 46.0 128.1634064 1 2.0 48.0 128.2574005 1 2.0 50.0 128.8485718 1 2.0 52.0 129.5490875 1 2.0 54.0 129.7754059 1 2.0 56.0 130.4454651 1 2.0 58.0 131.0157623 1 2.0 60.0 131.2865448 1 2.0 62.0 133.0798645 1 2.0 64.0 134.7369385 1 2.0 66.0 137.2429199 1 2.0 68.0 137.4812317 1 2.0 70.0 138.7712097 1 2.0 72.0 139.8694763 1 2.0 74.0 140.6768646 1 2.0 76.0 142.7576294 1 2.0 78.0 144.4676361 1 2.0 80.0 144.8905334 1 2.0 82.0 146.3157654 1 2.0 84.0 149.0292358 1 2.0 86.0 152.9427185 1 2.0 88.0 154.0635529 1 2.0 90.0 154.9950104 1 2.0 92.0 82.6672821 1 2.0 94.0 89.37554932 1 2.0 96.0 99.98454285 1 2.0 98.0 n/a 1 2.0 100.0 . . # 범주형 변수들의 요약통계량이 나온다. 갯수와 % . print(tobj) . Overall n 50 Recur = 1 (%) 22 (44.0) local_6m = 1 (%) 23 (46.0) age (mean (SD)) 56.44 (12.60) sex = 1 (%) 33 (66.0) CA19.9 (%) 2 1 ( 2.1) 3 2 ( 4.2) 4 1 ( 2.1) 5 1 ( 2.1) 6 1 ( 2.1) 7 1 ( 2.1) 8 1 ( 2.1) 9 1 ( 2.1) 10 1 ( 2.1) 11 1 ( 2.1) 12 1 ( 2.1) 13 1 ( 2.1) 14 1 ( 2.1) 15 1 ( 2.1) 16 1 ( 2.1) 17 1 ( 2.1) 18 1 ( 2.1) 19 1 ( 2.1) 20 1 ( 2.1) 21 1 ( 2.1) 22 1 ( 2.1) 23 1 ( 2.1) 24 1 ( 2.1) 25 1 ( 2.1) 26 1 ( 2.1) 27 1 ( 2.1) 28 1 ( 2.1) 29 1 ( 2.1) 30 1 ( 2.1) 31 1 ( 2.1) 32 1 ( 2.1) 33 1 ( 2.1) 34 1 ( 2.1) 35 2 ( 4.2) 36 1 ( 2.1) 37 1 ( 2.1) 38 1 ( 2.1) 39 1 ( 2.1) 40 1 ( 2.1) 41 1 ( 2.1) 42 1 ( 2.1) 43 1 ( 2.1) 44 1 ( 2.1) 45 1 ( 2.1) 46 1 ( 2.1) 47 1 ( 2.1) log.CA19.9 (mean (SD)) 2.95 (0.81) CA19.9.group (mean (SD)) 0.21 (0.41) CEA (mean (SD)) 5.57 (16.28) log.CEA (mean (SD)) 0.99 (0.89) TNM (%) 1 2 ( 4.0) 2 5 (10.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) TNM.b (%) 1or2 7 (14.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) CCI (%) 0 3 ( 6.0) 1 16 (32.0) 2 15 (30.0) 3 12 (24.0) 4 3 ( 6.0) 6 1 ( 2.0) CCI.b (%) &gt;=4 4 ( 8.0) 0or1 19 (38.0) 2 15 (30.0) 3 12 (24.0) adc_decrease (mean (SD)) 20.67 (11.49) adc_5_decrease (mean (SD)) 11.00 (12.19) volume_change (mean (SD)) 24.50 (14.00) apt_1_mean (mean (SD)) 3.13 (3.70) apt_1_95p (mean (SD)) 3.07 (0.88) adc_1_mean (%) 1 ( 2.0) 100.3332748 1 ( 2.0) 100.7850723 1 ( 2.0) 101.1288986 1 ( 2.0) 106.94384 1 ( 2.0) 107.4796753 1 ( 2.0) 108.1219025 1 ( 2.0) 108.4807739 1 ( 2.0) 109.8269577 1 ( 2.0) 110.6593323 1 ( 2.0) 112.250946 1 ( 2.0) 112.6311264 1 ( 2.0) 113.6343842 1 ( 2.0) 114.5146027 1 ( 2.0) 116.6255951 1 ( 2.0) 116.9603348 1 ( 2.0) 119.7995605 1 ( 2.0) 121.1716843 1 ( 2.0) 123.4509964 1 ( 2.0) 123.5778046 1 ( 2.0) 125.6047516 1 ( 2.0) 125.8717575 1 ( 2.0) 127.4504852 1 ( 2.0) 128.1634064 1 ( 2.0) 128.2574005 1 ( 2.0) 128.8485718 1 ( 2.0) 129.5490875 1 ( 2.0) 129.7754059 1 ( 2.0) 130.4454651 1 ( 2.0) 131.0157623 1 ( 2.0) 131.2865448 1 ( 2.0) 133.0798645 1 ( 2.0) 134.7369385 1 ( 2.0) 137.2429199 1 ( 2.0) 137.4812317 1 ( 2.0) 138.7712097 1 ( 2.0) 139.8694763 1 ( 2.0) 140.6768646 1 ( 2.0) 142.7576294 1 ( 2.0) 144.4676361 1 ( 2.0) 144.8905334 1 ( 2.0) 146.3157654 1 ( 2.0) 149.0292358 1 ( 2.0) 152.9427185 1 ( 2.0) 154.0635529 1 ( 2.0) 154.9950104 1 ( 2.0) 82.6672821 1 ( 2.0) 89.37554932 1 ( 2.0) 99.98454285 1 ( 2.0) n/a 1 ( 2.0) adc_1_5p (mean (SD)) 85.03 (11.48) . print(tobj, showAllLevels = T) . level Overall n 50 Recur (%) 0 28 (56.0) 1 22 (44.0) local_6m (%) 0 27 (54.0) 1 23 (46.0) age (mean (SD)) 56.44 (12.60) sex (%) 0 17 (34.0) 1 33 (66.0) CA19.9 (%) 2 1 ( 2.1) 3 2 ( 4.2) 4 1 ( 2.1) 5 1 ( 2.1) 6 1 ( 2.1) 7 1 ( 2.1) 8 1 ( 2.1) 9 1 ( 2.1) 10 1 ( 2.1) 11 1 ( 2.1) 12 1 ( 2.1) 13 1 ( 2.1) 14 1 ( 2.1) 15 1 ( 2.1) 16 1 ( 2.1) 17 1 ( 2.1) 18 1 ( 2.1) 19 1 ( 2.1) 20 1 ( 2.1) 21 1 ( 2.1) 22 1 ( 2.1) 23 1 ( 2.1) 24 1 ( 2.1) 25 1 ( 2.1) 26 1 ( 2.1) 27 1 ( 2.1) 28 1 ( 2.1) 29 1 ( 2.1) 30 1 ( 2.1) 31 1 ( 2.1) 32 1 ( 2.1) 33 1 ( 2.1) 34 1 ( 2.1) 35 2 ( 4.2) 36 1 ( 2.1) 37 1 ( 2.1) 38 1 ( 2.1) 39 1 ( 2.1) 40 1 ( 2.1) 41 1 ( 2.1) 42 1 ( 2.1) 43 1 ( 2.1) 44 1 ( 2.1) 45 1 ( 2.1) 46 1 ( 2.1) 47 1 ( 2.1) log.CA19.9 (mean (SD)) 2.95 (0.81) CA19.9.group (mean (SD)) 0.21 (0.41) CEA (mean (SD)) 5.57 (16.28) log.CEA (mean (SD)) 0.99 (0.89) TNM (%) 1 2 ( 4.0) 2 5 (10.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) TNM.b (%) 1or2 7 (14.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) CCI (%) 0 3 ( 6.0) 1 16 (32.0) 2 15 (30.0) 3 12 (24.0) 4 3 ( 6.0) 6 1 ( 2.0) CCI.b (%) &gt;=4 4 ( 8.0) 0or1 19 (38.0) 2 15 (30.0) 3 12 (24.0) adc_decrease (mean (SD)) 20.67 (11.49) adc_5_decrease (mean (SD)) 11.00 (12.19) volume_change (mean (SD)) 24.50 (14.00) apt_1_mean (mean (SD)) 3.13 (3.70) apt_1_95p (mean (SD)) 3.07 (0.88) adc_1_mean (%) 1 ( 2.0) 100.3332748 1 ( 2.0) 100.7850723 1 ( 2.0) 101.1288986 1 ( 2.0) 106.94384 1 ( 2.0) 107.4796753 1 ( 2.0) 108.1219025 1 ( 2.0) 108.4807739 1 ( 2.0) 109.8269577 1 ( 2.0) 110.6593323 1 ( 2.0) 112.250946 1 ( 2.0) 112.6311264 1 ( 2.0) 113.6343842 1 ( 2.0) 114.5146027 1 ( 2.0) 116.6255951 1 ( 2.0) 116.9603348 1 ( 2.0) 119.7995605 1 ( 2.0) 121.1716843 1 ( 2.0) 123.4509964 1 ( 2.0) 123.5778046 1 ( 2.0) 125.6047516 1 ( 2.0) 125.8717575 1 ( 2.0) 127.4504852 1 ( 2.0) 128.1634064 1 ( 2.0) 128.2574005 1 ( 2.0) 128.8485718 1 ( 2.0) 129.5490875 1 ( 2.0) 129.7754059 1 ( 2.0) 130.4454651 1 ( 2.0) 131.0157623 1 ( 2.0) 131.2865448 1 ( 2.0) 133.0798645 1 ( 2.0) 134.7369385 1 ( 2.0) 137.2429199 1 ( 2.0) 137.4812317 1 ( 2.0) 138.7712097 1 ( 2.0) 139.8694763 1 ( 2.0) 140.6768646 1 ( 2.0) 142.7576294 1 ( 2.0) 144.4676361 1 ( 2.0) 144.8905334 1 ( 2.0) 146.3157654 1 ( 2.0) 149.0292358 1 ( 2.0) 152.9427185 1 ( 2.0) 154.0635529 1 ( 2.0) 154.9950104 1 ( 2.0) 82.6672821 1 ( 2.0) 89.37554932 1 ( 2.0) 99.98454285 1 ( 2.0) n/a 1 ( 2.0) adc_1_5p (mean (SD)) 85.03 (11.48) . # 하지만 치우친 [기울어진 분포]의 연속형변수는 [ median, IQR ]를 뽑아야한다. print(tobj, showAllLevels = T, nonnormal = c(&quot;CA19.9&quot;, &quot;CEA&quot;)) . level Overall n 50 Recur (%) 0 28 (56.0) 1 22 (44.0) local_6m (%) 0 27 (54.0) 1 23 (46.0) age (mean (SD)) 56.44 (12.60) sex (%) 0 17 (34.0) 1 33 (66.0) CA19.9 (%) 2 1 ( 2.1) 3 2 ( 4.2) 4 1 ( 2.1) 5 1 ( 2.1) 6 1 ( 2.1) 7 1 ( 2.1) 8 1 ( 2.1) 9 1 ( 2.1) 10 1 ( 2.1) 11 1 ( 2.1) 12 1 ( 2.1) 13 1 ( 2.1) 14 1 ( 2.1) 15 1 ( 2.1) 16 1 ( 2.1) 17 1 ( 2.1) 18 1 ( 2.1) 19 1 ( 2.1) 20 1 ( 2.1) 21 1 ( 2.1) 22 1 ( 2.1) 23 1 ( 2.1) 24 1 ( 2.1) 25 1 ( 2.1) 26 1 ( 2.1) 27 1 ( 2.1) 28 1 ( 2.1) 29 1 ( 2.1) 30 1 ( 2.1) 31 1 ( 2.1) 32 1 ( 2.1) 33 1 ( 2.1) 34 1 ( 2.1) 35 2 ( 4.2) 36 1 ( 2.1) 37 1 ( 2.1) 38 1 ( 2.1) 39 1 ( 2.1) 40 1 ( 2.1) 41 1 ( 2.1) 42 1 ( 2.1) 43 1 ( 2.1) 44 1 ( 2.1) 45 1 ( 2.1) 46 1 ( 2.1) 47 1 ( 2.1) log.CA19.9 (mean (SD)) 2.95 (0.81) CA19.9.group (mean (SD)) 0.21 (0.41) CEA (median [IQR]) 2.50 [1.45, 4.15] log.CEA (mean (SD)) 0.99 (0.89) TNM (%) 1 2 ( 4.0) 2 5 (10.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) TNM.b (%) 1or2 7 (14.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) CCI (%) 0 3 ( 6.0) 1 16 (32.0) 2 15 (30.0) 3 12 (24.0) 4 3 ( 6.0) 6 1 ( 2.0) CCI.b (%) &gt;=4 4 ( 8.0) 0or1 19 (38.0) 2 15 (30.0) 3 12 (24.0) adc_decrease (mean (SD)) 20.67 (11.49) adc_5_decrease (mean (SD)) 11.00 (12.19) volume_change (mean (SD)) 24.50 (14.00) apt_1_mean (mean (SD)) 3.13 (3.70) apt_1_95p (mean (SD)) 3.07 (0.88) adc_1_mean (%) 1 ( 2.0) 100.3332748 1 ( 2.0) 100.7850723 1 ( 2.0) 101.1288986 1 ( 2.0) 106.94384 1 ( 2.0) 107.4796753 1 ( 2.0) 108.1219025 1 ( 2.0) 108.4807739 1 ( 2.0) 109.8269577 1 ( 2.0) 110.6593323 1 ( 2.0) 112.250946 1 ( 2.0) 112.6311264 1 ( 2.0) 113.6343842 1 ( 2.0) 114.5146027 1 ( 2.0) 116.6255951 1 ( 2.0) 116.9603348 1 ( 2.0) 119.7995605 1 ( 2.0) 121.1716843 1 ( 2.0) 123.4509964 1 ( 2.0) 123.5778046 1 ( 2.0) 125.6047516 1 ( 2.0) 125.8717575 1 ( 2.0) 127.4504852 1 ( 2.0) 128.1634064 1 ( 2.0) 128.2574005 1 ( 2.0) 128.8485718 1 ( 2.0) 129.5490875 1 ( 2.0) 129.7754059 1 ( 2.0) 130.4454651 1 ( 2.0) 131.0157623 1 ( 2.0) 131.2865448 1 ( 2.0) 133.0798645 1 ( 2.0) 134.7369385 1 ( 2.0) 137.2429199 1 ( 2.0) 137.4812317 1 ( 2.0) 138.7712097 1 ( 2.0) 139.8694763 1 ( 2.0) 140.6768646 1 ( 2.0) 142.7576294 1 ( 2.0) 144.4676361 1 ( 2.0) 144.8905334 1 ( 2.0) 146.3157654 1 ( 2.0) 149.0292358 1 ( 2.0) 152.9427185 1 ( 2.0) 154.0635529 1 ( 2.0) 154.9950104 1 ( 2.0) 82.6672821 1 ( 2.0) 89.37554932 1 ( 2.0) 99.98454285 1 ( 2.0) n/a 1 ( 2.0) adc_1_5p (mean (SD)) 85.03 (11.48) . ?CreateTableOne . # createtableone에서 strata에 그룹을 나눈 칼럼명 options(width = 300) tobj2&lt;-CreateTableOne(vars = var1, data=dat1, strata=&quot;CA19.9.group&quot;) print(tobj2) . Warning message in ModuleReturnVarsExist(vars, data): &#34;The data frame does not have: RFS Dropped&#34; . Stratified by CA19.9.group 0 1 p test n 38 10 Recur = 1 (%) 15 (39.5) 7 (70.0) 0.172 local_6m = 1 (%) 20 (52.6) 3 (30.0) 0.358 age (mean (SD)) 56.34 (12.56) 58.80 (13.62) 0.591 sex = 1 (%) 24 (63.2) 9 (90.0) 0.213 CA19.9 (%) 0.352 2 1 ( 2.6) 0 ( 0.0) 3 2 ( 5.3) 0 ( 0.0) 4 1 ( 2.6) 0 ( 0.0) 5 1 ( 2.6) 0 ( 0.0) 6 1 ( 2.6) 0 ( 0.0) 7 1 ( 2.6) 0 ( 0.0) 8 1 ( 2.6) 0 ( 0.0) 9 1 ( 2.6) 0 ( 0.0) 10 1 ( 2.6) 0 ( 0.0) 11 1 ( 2.6) 0 ( 0.0) 12 1 ( 2.6) 0 ( 0.0) 13 1 ( 2.6) 0 ( 0.0) 14 1 ( 2.6) 0 ( 0.0) 15 1 ( 2.6) 0 ( 0.0) 16 1 ( 2.6) 0 ( 0.0) 17 1 ( 2.6) 0 ( 0.0) 18 1 ( 2.6) 0 ( 0.0) 19 1 ( 2.6) 0 ( 0.0) 20 1 ( 2.6) 0 ( 0.0) 21 1 ( 2.6) 0 ( 0.0) 22 1 ( 2.6) 0 ( 0.0) 23 1 ( 2.6) 0 ( 0.0) 24 1 ( 2.6) 0 ( 0.0) 25 1 ( 2.6) 0 ( 0.0) 26 1 ( 2.6) 0 ( 0.0) 27 1 ( 2.6) 0 ( 0.0) 28 1 ( 2.6) 0 ( 0.0) 29 1 ( 2.6) 0 ( 0.0) 30 1 ( 2.6) 0 ( 0.0) 31 1 ( 2.6) 0 ( 0.0) 32 1 ( 2.6) 0 ( 0.0) 33 1 ( 2.6) 0 ( 0.0) 34 1 ( 2.6) 0 ( 0.0) 35 2 ( 5.3) 0 ( 0.0) 36 1 ( 2.6) 0 ( 0.0) 37 1 ( 2.6) 0 ( 0.0) 38 0 ( 0.0) 1 (10.0) 39 0 ( 0.0) 1 (10.0) 40 0 ( 0.0) 1 (10.0) 41 0 ( 0.0) 1 (10.0) 42 0 ( 0.0) 1 (10.0) 43 0 ( 0.0) 1 (10.0) 44 0 ( 0.0) 1 (10.0) 45 0 ( 0.0) 1 (10.0) 46 0 ( 0.0) 1 (10.0) 47 0 ( 0.0) 1 (10.0) log.CA19.9 (mean (SD)) 2.74 (0.79) 3.75 (0.07) &lt;0.001 CA19.9.group (mean (SD)) 0.00 (0.00) 1.00 (0.00) &lt;0.001 CEA (mean (SD)) 6.13 (18.55) 4.15 (4.59) 0.740 log.CEA (mean (SD)) 0.99 (0.90) 1.03 (0.93) 0.926 TNM (%) 0.308 1 1 ( 2.6) 1 (10.0) 2 3 ( 7.9) 1 (10.0) 3 11 (28.9) 1 (10.0) 4 17 (44.7) 7 (70.0) 5 6 (15.8) 0 ( 0.0) TNM.b (%) 0.231 1or2 4 (10.5) 2 (20.0) 3 11 (28.9) 1 (10.0) 4 17 (44.7) 7 (70.0) 5 6 (15.8) 0 ( 0.0) CCI (%) 0.304 0 1 ( 2.6) 2 (20.0) 1 13 (34.2) 2 (20.0) 2 10 (26.3) 4 (40.0) 3 10 (26.3) 2 (20.0) 4 3 ( 7.9) 0 ( 0.0) 6 1 ( 2.6) 0 ( 0.0) CCI.b (%) 0.635 &gt;=4 4 (10.5) 0 ( 0.0) 0or1 14 (36.8) 4 (40.0) 2 10 (26.3) 4 (40.0) 3 10 (26.3) 2 (20.0) adc_decrease (mean (SD)) 20.83 (11.55) 21.60 (11.41) 0.853 adc_5_decrease (mean (SD)) 11.24 (11.82) 10.80 (14.62) 0.922 volume_change (mean (SD)) 22.58 (13.56) 32.00 (13.00) 0.056 apt_1_mean (mean (SD)) 3.19 (4.20) 3.08 (1.23) 0.935 apt_1_95p (mean (SD)) 2.96 (0.75) 3.54 (1.25) 0.064 adc_1_mean (%) NaN 1 ( 2.6) 0 ( 0.0) 100.3332748 1 ( 2.6) 0 ( 0.0) 100.7850723 1 ( 2.6) 0 ( 0.0) 101.1288986 1 ( 2.6) 0 ( 0.0) 106.94384 0 ( 0.0) 1 (10.0) 107.4796753 1 ( 2.6) 0 ( 0.0) 108.1219025 0 ( 0.0) 1 (10.0) 108.4807739 1 ( 2.6) 0 ( 0.0) 109.8269577 0 ( 0.0) 0 ( 0.0) 110.6593323 1 ( 2.6) 0 ( 0.0) 112.250946 0 ( 0.0) 1 (10.0) 112.6311264 1 ( 2.6) 0 ( 0.0) 113.6343842 1 ( 2.6) 0 ( 0.0) 114.5146027 0 ( 0.0) 1 (10.0) 116.6255951 1 ( 2.6) 0 ( 0.0) 116.9603348 1 ( 2.6) 0 ( 0.0) 119.7995605 1 ( 2.6) 0 ( 0.0) 121.1716843 1 ( 2.6) 0 ( 0.0) 123.4509964 1 ( 2.6) 0 ( 0.0) 123.5778046 1 ( 2.6) 0 ( 0.0) 125.6047516 1 ( 2.6) 0 ( 0.0) 125.8717575 1 ( 2.6) 0 ( 0.0) 127.4504852 1 ( 2.6) 0 ( 0.0) 128.1634064 1 ( 2.6) 0 ( 0.0) 128.2574005 0 ( 0.0) 1 (10.0) 128.8485718 0 ( 0.0) 0 ( 0.0) 129.5490875 1 ( 2.6) 0 ( 0.0) 129.7754059 1 ( 2.6) 0 ( 0.0) 130.4454651 1 ( 2.6) 0 ( 0.0) 131.0157623 1 ( 2.6) 0 ( 0.0) 131.2865448 1 ( 2.6) 0 ( 0.0) 133.0798645 1 ( 2.6) 0 ( 0.0) 134.7369385 1 ( 2.6) 0 ( 0.0) 137.2429199 1 ( 2.6) 0 ( 0.0) 137.4812317 1 ( 2.6) 0 ( 0.0) 138.7712097 1 ( 2.6) 0 ( 0.0) 139.8694763 0 ( 0.0) 1 (10.0) 140.6768646 1 ( 2.6) 0 ( 0.0) 142.7576294 1 ( 2.6) 0 ( 0.0) 144.4676361 0 ( 0.0) 1 (10.0) 144.8905334 1 ( 2.6) 0 ( 0.0) 146.3157654 0 ( 0.0) 1 (10.0) 149.0292358 0 ( 0.0) 1 (10.0) 152.9427185 1 ( 2.6) 0 ( 0.0) 154.0635529 1 ( 2.6) 0 ( 0.0) 154.9950104 0 ( 0.0) 1 (10.0) 82.6672821 1 ( 2.6) 0 ( 0.0) 89.37554932 1 ( 2.6) 0 ( 0.0) 99.98454285 1 ( 2.6) 0 ( 0.0) n/a 1 ( 2.6) 0 ( 0.0) adc_1_5p (mean (SD)) 84.85 (11.42) 84.70 (12.29) 0.972 .",
            "url": "blog.chojaeseong.com/r/%EC%9D%98%EC%97%B0%EB%B0%A9/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/datacleaning/2022/03/12/00-%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%81%B4%EB%A6%AC%EB%8B%9D,-tableone-%ED%8A%B9%EA%B0%95-(22-03-05)(%EC%99%84).html",
            "relUrl": "/r/%EC%9D%98%EC%97%B0%EB%B0%A9/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/datacleaning/2022/03/12/00-%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%81%B4%EB%A6%AC%EB%8B%9D,-tableone-%ED%8A%B9%EA%B0%95-(22-03-05)(%EC%99%84).html",
            "date": " • Mar 12, 2022"
        }
        
    
  
    
        ,"post38": {
            "title": "EnumMap으로 카운팅(로또결과)",
            "content": "EnumMap . Enum List -&gt; EnumMap에 카운팅 . List&lt;객체&gt;의 갯수를 객체를 key로 하는 hashMap Map&lt;객체, Integer&gt; 에 세야한다. | . 빈 Map 선언 및 초기화 . 객체의 Count을 원한다면 **&lt;객체key, Integer&gt;로 Map을 선언한다. ** (cf) 원시적으로는 직접 0으로 초기화 한다.) . EnumMap이라면 ( )생성자에 안에 Enum클래스.class(클래스 자체)를 지정해준다. | . final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); . 참고) . (원시적) 모든 객체key들 stream화해서 돌면서 -&gt; forEach -&gt; map.put(객체key, 0)으로 초기화해준다. . private final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); { Arrays.stream(Rank.values()).forEach(rank -&gt; result.put(rank, 0)); } . | . | EnumMap는 넣고난 뒤, 자동정렬되어있지만 . 일반map넣고 난 뒤, key순으로 정렬되어야하면(순서가 중요하면) hashMap대신 -&gt; linkedHashMap을 사용한다. | . private final LinkedHashMap&lt;Rank, Integer&gt; value = new LinkedHashMap&lt;&gt;(); . | . | 일급vs단일 로직을 먼저 수행한 -&gt; 응답결과List를 카운팅하는 3가지 방법 . 이제 갯수를 셀 결과값List(Enum List or 객체 List)들을 돌면서 카운팅한다. . 결과List(객체List)를 먼저 계산 -&gt; 돌면서 -&gt; . 이미 0으로 초기화해놓고 넣어놨어야한다. | map.put( 객체Key, map.get( 객체key )의 value + 1 ) | . { Arrays.stream(Rank.values()).forEach(rank -&gt; result.put(rank, 0)); } . result.put(rankPrize, result.getOrDefault(rankPrize, 0) + 1); . | 결과List(객체List)를 먼저 계산 -&gt; 돌면서 -&gt; . 미리 0 초기화 없이 알아서 직전value(없으면 0부터) 누적해주는 -&gt; map.merge( 객체key, 누적해넣을값, Integer.sum()으로 기존value와 누적방법 Bifunction ) | . result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after)) . final List&lt;Rank&gt; results = lottos.stream() .map(lotto -&gt; match(lotto, winningLotto)) .collect(Collectors.toList()); final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); results .forEach(rank -&gt; result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after))); . 결과값을 찍어보니 merge로 카운팅이 1개씩 잘 된다. | . | | EnumMap은 아니지만, 일급vs단일 –stream–&gt; 단일vs단일 결과값(객체key)을 뽑아낼 로직 + 카운팅을 동시에 해주는 일급.stream().collect(Collectors.groupingBy( 객체key를 뽑아낼 로직 , summingInt( value -&gt; 1) ) . 결과값List를 뽑는 로직 조차 일급.stream -&gt; 단일vs단일로 객체Key뽑기로직이 내부에 포함됨 . 결과값List를 미리 뽑지 않는다. -&gt; Collectors.groupingBy( , )의 **첫번째 인자에 ** | . // (1)결과값 List를 미리 뽑는 과정 -&gt; 생략됨. //final List&lt;Rank&gt; results = lottos.stream() // .map(lotto -&gt; match(lotto, winningLotto)) // .collect(Collectors.toList()); // (2) map을 미리 선언해두기 -&gt; 생략됨 //final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); // (3) 결과값List를 돌면서 -&gt; merge로 1씩 카운팅 -&gt; 생략됨 //results.stream() // .forEach(rank -&gt; result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after))); // 일급을 돌면서 -&gt; groupingBy(단일vs단일의 [결과값 = 객체key]를 뽑는 로직 , 1씩 누적합하는 로직) return lottos.stream() .collect(Collectors.groupingBy( lotto -&gt; match(lotto, winningLotto), Collectors.summingInt(value -&gt; 1))); . | groupingBy의 가운데 인자에 EnumMap.class를 줄 수 있다. . final EnumMap&lt;GameResult, Integer&gt; dealerResult = gamblers.stream() .collect(Collectors.groupingBy( gambler -&gt; getResultPlayer(dealer, gamblerResult, gambler), () -&gt; new EnumMap&lt;&gt;(GameResult.class), // Map타입 가운데서 지정 Collectors.summingInt(count -&gt; 1) )); .",
            "url": "blog.chojaeseong.com/java/enummap/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/11/EnumMap.html",
            "relUrl": "/java/enummap/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/11/EnumMap.html",
            "date": " • Mar 11, 2022"
        }
        
    
  
    
        ,"post39": {
            "title": "01-Basics and R environment",
            "content": "강의주소:https://lms.knou.ac.kr/dks/user/home/initUSTHomeIndex_GRSC.do?stLeftMenuId=0 | 선배블로그: https://insb.tistory.com/9?category=967351 작년 김성수 교수 강의로 진행 | . | . &#44592;&#48376; . R &#49548;&#44060; . 무료 | 대화형 프로그램 언어 | 객체지향 시스템 데이터, 변수, 행렬 등은 모두 객체 | 생성은 = or &lt;-로 생성 | . | . . x = 2:10 x . &lt;ol class=list-inline&gt; 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | &lt;/ol&gt; y &lt;- 3*x + 5 y . &lt;ol class=list-inline&gt; 11 | 14 | 17 | 20 | 23 | 26 | 29 | 32 | 35 | &lt;/ol&gt; a &lt;- 3:9 b &lt;- 3*a + 5 plot(a, b) . plot(a, b, pch=18) . R&#51032; &#50669;&#49324; . . 1980년대 S 언어 탄생 by AT&amp;T Bell Lab(c언어 개발한 연구소)에서 통계언어 S를 구현함 . 1998 ACM S/W 상을 John Chambers가 탐 &quot;Forever altered how people analyze, visualize and manipulate data 사람들이 어떻게 데이터 분석, 시각화, 다루는지를 영원히 바꾼 언어다 | . | . | 오클란드 대학의 Ross and Robert 교수 2명이 S 축소버전인 R &amp; R을 만듦 . | 1995년 Martin Maechler(마틴 매흘러)가 R&amp;R(이하카, 젠틀만)을 설득하여, linux처럼 오픈소스(GPL)로 쓰게 한 것인 R source code 발표 . | 1997년 8월 R core team 결성. 2000년 02월 29일 R version 1.0.0 발표 . 12월 R version 3.2.3 | | . | R &#45796;&#50868;&#48155;&#44592; . . base버전으로 다운 받기 | . &#51089;&#50629;&#50689;&#50669; &#51648;&#51221; . . getwd() . &#39;C:/Users/cho_desktop/2022_RProjects/대학원/1-01 데이터분석방법론 1&#39; setwd(&quot;.&quot;) . setwd( choose.dir() ) . Error in setwd(choose.dir()): missing value is invalid Traceback: 1. setwd(choose.dir()) . R studio &#49548;&#44060; . rsutdio.com | . R Commander &#49548;&#44060; . 메뉴 방식으로 처리된 R 패키지/ John fox가 개발 | . . &#44368;&#51116; . First step . install.packages(&quot;ISwR&quot;) . package &#39;ISwR&#39; successfully unpacked and MD5 sums checked The downloaded binary packages are in C: Users cho_desktop AppData Local Temp Rtmpo5uUeT downloaded_packages . library(ISwR) . Warning message: &#34;package &#39;ISwR&#39; was built under R version 3.6.3&#34; . plot( rnorm(1000), pch = 19) . 1.1.3 &#48289;&#53552;&#50672;&#49328; . weight &lt;- c(60, 72, 57, 90, 95, 72) height &lt;- c(1.75, 1.80, 1.65, 1.90, 1.74, 1.91) bmi &lt;- weight/height^2 . bmi . &lt;ol class=list-inline&gt; 19.5918367346939 | 22.2222222222222 | 20.9366391184573 | 24.9307479224377 | 31.3779891663364 | 19.7363010882377 | &lt;/ol&gt; . # 벡터c의 갯수 -&gt; length( ) xbar &lt;- sum(weight) / length(weight) xbar . 74.3333333333333 mean(weight) . 74.3333333333333 sqrt(sum((weight-xbar)^2) / (length(weight) - 1)) . 15.4229266569827 sd(weight) . 15.4229266569827 1.1.4 standard procedures . bmi . &lt;ol class=list-inline&gt; 19.5918367346939 | 22.2222222222222 | 20.9366391184573 | 24.9307479224377 | 31.3779891663364 | 19.7363010882377 | &lt;/ol&gt; t.test(bmi, mu=22.5) # H0: mu=22.5 / H1: mu!=22.5 # t값 , 자유도, p값 . One Sample t-test data: bmi t = 0.34488, df = 5, p-value = 0.7442 alternative hypothesis: true mean is not equal to 22.5 95 percent confidence interval: 18.41734 27.84791 sample estimates: mean of x 23.13262 . 1.1.5 Graph . . # color=&quot;대or소문자&quot; 대신 col=2번호를 줘도 된다. like pch=숫자 plot(height, weight, pch=2, col=&quot;RED&quot;) . # c벡터객체 1개 만들고 hh &lt;- c(1.65, 1.70, 1.75, 1.80, 1.85, 1.90) # lines로 선 그리기 lines(hh, 22.5*hh^2, col=&quot;BLUE&quot;, lty=2) # lty = line type -&gt; 2번은 점점점 타입 . Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet Traceback: 1. lines(hh, 22.5 * hh^2, col = &#34;BLUE&#34;, lty = 2) 2. lines.default(hh, 22.5 * hh^2, col = &#34;BLUE&#34;, lty = 2) 3. plot.xy(xy.coords(x, y), type = type, ...) . plot(height, weight, pch=2, col=&quot;RED&quot;) hh &lt;- c(1.65, 1.70, 1.75, 1.80, 1.85, 1.90) lines(hh, 22.5*hh^2, col=&quot;BLUE&quot;, lty=2) . 1.2 R languange essentials . # - 작따-&gt;큰따로 변환되서 표기된다. # - 여기선 큰따-&gt; 작따로 표기되네..like python c(&quot;Huey&quot;, &quot;Dewey&quot;, &quot;Louie&quot;) . &lt;ol class=list-inline&gt; &#39;Huey&#39; | &#39;Dewey&#39; | &#39;Louie&#39; | &lt;/ol&gt; c(&#39;Huey&#39;, &#39;Dewey&#39;, &#39;Louie&#39;) . &lt;ol class=list-inline&gt; &#39;Huey&#39; | &#39;Dewey&#39; | &#39;Louie&#39; | &lt;/ol&gt; c(T, T, F, T) . &lt;ol class=list-inline&gt; TRUE | TRUE | FALSE | TRUE | &lt;/ol&gt; bmi . &lt;ol class=list-inline&gt; 19.5918367346939 | 22.2222222222222 | 20.9366391184573 | 24.9307479224377 | 31.3779891663364 | 19.7363010882377 | &lt;/ol&gt; # 벡터 + 조건식 -&gt; 마스크가 된다. bmi &gt; 25 . &lt;ol class=list-inline&gt; FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | &lt;/ol&gt; cat( c(&quot;Huey&quot;, &quot;Dewey&quot;, &quot;Louie&quot;) ) . Huey Dewey Louie . cat( c(&quot;Huey&quot;, &quot;Dewey&quot;, &quot;Louie&quot;, &quot; n&quot;) ) . Huey Dewey Louie . . cat(&quot;What is &quot;R &quot;? n&quot;) . What is &#34;R&#34;? . &#50696;&#51228; &#52280;&#44256;&#51088;&#47308; &#49324;&#51060;&#53944; . 예제 파일을 들고 있는 블로그: https://booolean.tistory.com/913?category=807312 | . 1.2.5 Missing Value . R에서는 결측치를 NA로 표시한다. | . . wd &lt;- read.table(&quot;./data//01/wd.txt&quot;, sep = &quot; t&quot;, header=T) # &quot;./따옴표경로&quot; , sep=&quot;구분자&quot; , header=T (첫줄이 타이틀) wd . M1M2M3M4M5Y . 0.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 0.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 0.606 | 0.1273 | 0.494 | 0.522 | 0.920 | 0.570 | . 0.437 | 0.1591 | 0.446 | 0.423 | 0.992 | 0.450 | . 0.547 | 0.1135 | 0.531 | 0.519 | 0.915 | 0.548 | . 0.444 | 0.1628 | 0.429 | 0.411 | 0.984 | 0.431 | . 0.489 | 0.1231 | 0.562 | 0.455 | 0.824 | 0.401 | . 0.536 | 0.1473 | 0.410 | 0.430 | 0.978 | 0.423 | . 0.413 | 0.1182 | 0.592 | 0.464 | 0.854 | 0.475 | . 0.685 | 0.1564 | 0.631 | 0.564 | 0.914 | 0.486 | . 0.664 | 0.1588 | 0.506 | 0.481 | 0.867 | 0.554 | . 0.703 | 0.1335 | 0.519 | 0.484 | 0.812 | 0.519 | . 0.653 | 0.1395 | 0.625 | 0.519 | 0.892 | 0.492 | . 0.586 | 0.1114 | 0.505 | 0.565 | 0.889 | 0.517 | . 0.534 | 0.1143 | 0.521 | 0.571 | 0.889 | 0.502 | . 0.523 | 0.1320 | 0.508 | 0.412 | 0.919 | 0.508 | . 0.580 | 0.1249 | 0.546 | 0.608 | 0.954 | 0.520 | . 0.448 | 0.1028 | 0.522 | 0.534 | 0.918 | 0.506 | . 0.417 | 0.1684 | 0.405 | 0.415 | 0.981 | 0.401 | . 0.528 | 0.1057 | 0.424 | 0.566 | 0.909 | 0.568 | . nwd = wd nwd . M1M2M3M4M5Y . 0.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 0.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 0.606 | 0.1273 | 0.494 | 0.522 | 0.920 | 0.570 | . 0.437 | 0.1591 | 0.446 | 0.423 | 0.992 | 0.450 | . 0.547 | 0.1135 | 0.531 | 0.519 | 0.915 | 0.548 | . 0.444 | 0.1628 | 0.429 | 0.411 | 0.984 | 0.431 | . 0.489 | 0.1231 | 0.562 | 0.455 | 0.824 | 0.401 | . 0.536 | 0.1473 | 0.410 | 0.430 | 0.978 | 0.423 | . 0.413 | 0.1182 | 0.592 | 0.464 | 0.854 | 0.475 | . 0.685 | 0.1564 | 0.631 | 0.564 | 0.914 | 0.486 | . 0.664 | 0.1588 | 0.506 | 0.481 | 0.867 | 0.554 | . 0.703 | 0.1335 | 0.519 | 0.484 | 0.812 | 0.519 | . 0.653 | 0.1395 | 0.625 | 0.519 | 0.892 | 0.492 | . 0.586 | 0.1114 | 0.505 | 0.565 | 0.889 | 0.517 | . 0.534 | 0.1143 | 0.521 | 0.571 | 0.889 | 0.502 | . 0.523 | 0.1320 | 0.508 | 0.412 | 0.919 | 0.508 | . 0.580 | 0.1249 | 0.546 | 0.608 | 0.954 | 0.520 | . 0.448 | 0.1028 | 0.522 | 0.534 | 0.918 | 0.506 | . 0.417 | 0.1684 | 0.405 | 0.415 | 0.981 | 0.401 | . 0.528 | 0.1057 | 0.424 | 0.566 | 0.909 | 0.568 | . nwd[ nwd &gt; 0.9 ] = 99 . head(nwd) . M1M2M3M4M5Y . 0.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 0.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 0.606 | 0.1273 | 0.494 | 0.522 | 99.000 | 0.570 | . 0.437 | 0.1591 | 0.446 | 0.423 | 99.000 | 0.450 | . 0.547 | 0.1135 | 0.531 | 0.519 | 99.000 | 0.548 | . 0.444 | 0.1628 | 0.429 | 0.411 | 99.000 | 0.431 | . nwd[nwd == 99] = NA head(nwd) . M1M2M3M4M5Y . 0.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 0.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 0.606 | 0.1273 | 0.494 | 0.522 | NA | 0.570 | . 0.437 | 0.1591 | 0.446 | 0.423 | NA | 0.450 | . 0.547 | 0.1135 | 0.531 | 0.519 | NA | 0.548 | . 0.444 | 0.1628 | 0.429 | 0.411 | NA | 0.431 | . # is.na()는 데이터객체 전체에 대한 boolean mask(logical character)를 만든다. -&gt; 행렬mask -&gt; 행 or 열별로 접근해줘야한다. is.na(nwd) . M1M2M3M4M5Y . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . rowSums( is.na(nwd) ) . &lt;ol class=list-inline&gt; 0 | 0 | 1 | 1 | 1 | 1 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | &lt;/ol&gt; colSums( is.na(nwd) ) . &lt;dl class=dl-horizontal&gt; M1 0 M2 0 M3 0 M4 0 M5 11 Y 0 &lt;/dl&gt; # -&gt; 행별로 제거하는 듯 싶다. # -&gt; na.omit()의 결과 &lt;기존 행번호&gt;가 같이 찍히니 확인하면 된다. na.omit(nwd) . M1M2M3M4M5Y . 10.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 20.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 70.489 | 0.1231 | 0.562 | 0.455 | 0.824 | 0.401 | . 90.413 | 0.1182 | 0.592 | 0.464 | 0.854 | 0.475 | . 110.664 | 0.1588 | 0.506 | 0.481 | 0.867 | 0.554 | . 120.703 | 0.1335 | 0.519 | 0.484 | 0.812 | 0.519 | . 130.653 | 0.1395 | 0.625 | 0.519 | 0.892 | 0.492 | . 140.586 | 0.1114 | 0.505 | 0.565 | 0.889 | 0.517 | . 150.534 | 0.1143 | 0.521 | 0.571 | 0.889 | 0.502 | . nwd . M1M2M3M4M5Y . 0.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 0.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 0.606 | 0.1273 | 0.494 | 0.522 | NA | 0.570 | . 0.437 | 0.1591 | 0.446 | 0.423 | NA | 0.450 | . 0.547 | 0.1135 | 0.531 | 0.519 | NA | 0.548 | . 0.444 | 0.1628 | 0.429 | 0.411 | NA | 0.431 | . 0.489 | 0.1231 | 0.562 | 0.455 | 0.824 | 0.401 | . 0.536 | 0.1473 | 0.410 | 0.430 | NA | 0.423 | . 0.413 | 0.1182 | 0.592 | 0.464 | 0.854 | 0.475 | . 0.685 | 0.1564 | 0.631 | 0.564 | NA | 0.486 | . 0.664 | 0.1588 | 0.506 | 0.481 | 0.867 | 0.554 | . 0.703 | 0.1335 | 0.519 | 0.484 | 0.812 | 0.519 | . 0.653 | 0.1395 | 0.625 | 0.519 | 0.892 | 0.492 | . 0.586 | 0.1114 | 0.505 | 0.565 | 0.889 | 0.517 | . 0.534 | 0.1143 | 0.521 | 0.571 | 0.889 | 0.502 | . 0.523 | 0.1320 | 0.508 | 0.412 | NA | 0.508 | . 0.580 | 0.1249 | 0.546 | 0.608 | NA | 0.520 | . 0.448 | 0.1028 | 0.522 | 0.534 | NA | 0.506 | . 0.417 | 0.1684 | 0.405 | 0.415 | NA | 0.401 | . 0.528 | 0.1057 | 0.424 | 0.566 | NA | 0.568 | . 1.2.6 Functions that create vectors . x &lt;- c(1,2,3) y &lt;- c(10, 20) c(x, y, 5) # 벡터객체와 값이 동등하게 1차원으로 연결된다. . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 10 | 20 | 5 | &lt;/ol&gt; # boolean + 숫자 -&gt; 숫자로 type 0/1로 바뀌어서 type통일 c(FALSE, 3) . &lt;ol class=list-inline&gt; 0 | 3 | &lt;/ol&gt; c(FALSE, &quot;abc&quot;) . &lt;ol class=list-inline&gt; &#39;FALSE&#39; | &#39;abc&#39; | &lt;/ol&gt; c(pi, &quot;abc&quot;) . &lt;ol class=list-inline&gt; &#39;3.14159265358979&#39; | &#39;abc&#39; | &lt;/ol&gt; seq(4, 9) . &lt;ol class=list-inline&gt; 4 | 5 | 6 | 7 | 8 | 9 | &lt;/ol&gt; oops &lt;- c(7, 9, 13) . rep(oops, 3) . &lt;ol class=list-inline&gt; 7 | 9 | 13 | 7 | 9 | 13 | 7 | 9 | 13 | &lt;/ol&gt; # - index순서대로 1번, 2번, 3번 반복복사 # - index별 반복회수도 벡터로 제공하면 된다. rep(oops, c(1,2,3)) . &lt;ol class=list-inline&gt; 7 | 9 | 9 | 13 | 13 | 13 | &lt;/ol&gt; rep(oops, 1:3) . &lt;ol class=list-inline&gt; 7 | 9 | 9 | 13 | 13 | 13 | &lt;/ol&gt; rep(1:2, c(10, 15)) . &lt;ol class=list-inline&gt; 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | &lt;/ol&gt; 1.2.7 Matrices and arrays . x &lt;- 1:12 x . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | &lt;/ol&gt; # 행렬이 된다. dim(x) = c(3, 4) x # 보이진 않지만, 1, 2, 3, 행 ,1 ,2 ,3 ,4 렬이 된다. . 1 | 4 | 7 | 10 | . 2 | 5 | 8 | 11 | . 3 | 6 | 9 | 12 | . # - 특히 byrow=를 T루로 주면, ncol없이 알아서 된다. matrix(1:12, nrow=3, byrow=T) . 1 | 2 | 3 | 4 | . 5 | 6 | 7 | 8 | . 9 | 10 | 11 | 12 | . LETTERS[1:3] . &lt;ol class=list-inline&gt; &#39;A&#39; | &#39;B&#39; | &#39;C&#39; | &lt;/ol&gt; rownames(x) &lt;- LETTERS[1:3] . x . A1 | 4 | 7 | 10 | . B2 | 5 | 8 | 11 | . C3 | 6 | 9 | 12 | . t(x) . ABC . 1 | 2 | 3 | . 4 | 5 | 6 | . 7 | 8 | 9 | . 10 | 11 | 12 | . # 1차원들을 -&gt; 눕혀서 행으로 더하는 rbind cbind(A = 1:4) . A . 1 | . 2 | . 3 | . 4 | . cbind(A = 1:4, B = 5:6, C = 9:12) . ABC . 1 | 5 | 9 | . 2 | 6 | 10 | . 3 | 5 | 11 | . 4 | 6 | 12 | . rbind(A=1:4,B=5:8,C=9:12) . A1 | 2 | 3 | 4 | . B5 | 6 | 7 | 8 | . C9 | 10 | 11 | 12 | . aa &lt;- cbind(A=1:4,B=5:8,C=9:12) aa . ABC . 1 | 5 | 9 | . 2 | 6 | 10 | . 3 | 7 | 11 | . 4 | 8 | 12 | . # - 좌or우 똑같은 크기의 상수를 붙이려면 상수로 bind하면 된다. cbind(1, aa) . ABC . 1 | 1 | 5 | 9 | . 1 | 2 | 6 | 10 | . 1 | 3 | 7 | 11 | . 1 | 4 | 8 | 12 | . factors(&#48276;&#51452;&#54805; &#51088;&#47308;) . 카테고리칼 변수는 인자로 만들어주는게 중요하다. 그 때 쓰는 것이 factor() | . pain &lt;- c(0, 3, 2, 2, 1) . # -&gt; levels=에는 [요인들과 동일한 값]으로 레벨을 정해서 매칭해놓는다. # -&gt; 연속적인 숫자벡터를 줬어도 &#39;0&#39;~&#39;3&#39;의 문자열로 정해진다. # -&gt; 매칭된 요인-레벨에 대해서, 레벨이름levels을 바꿔주면 요인들도 따라 바뀐다. fpain &lt;- factor(pain, levels = 0:3) fpain . &lt;ol class=list-inline&gt; 0 | 3 | 2 | 2 | 1 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;0&#39; | &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &lt;/ol&gt; # -&gt; 원본 값들이 레벨에 따른 해당 [라벨]로 바껴버린다. levels(fpain) &lt;- c(&quot;none&quot;, &quot;mild&quot;, &quot;medium&quot;, &quot;severe&quot;) fpain . &lt;ol class=list-inline&gt; none | severe | medium | medium | mild | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;none&#39; | &#39;mild&#39; | &#39;medium&#39; | &#39;severe&#39; | &lt;/ol&gt; &#49707;&#51088; -&gt; &#46972;&#48296; by&#50836;&#51064;&#45934; &#48148;&#44984;&#44592; . 변수 job, edu를 숫자 -&gt; 라벨(요인)으로 바꿔보자. . insurance = read.table(&quot;./data/01//insurance.txt&quot;, sep = &quot; t&quot;, header=T) . head(insurance) . idsexjobreligioneduamountsalary . 1 | m | 1 | 1 | 3 | 7.0 | 110 | . 2 | m | 2 | 1 | 4 | 12.0 | 135 | . 3 | f | 2 | 3 | 5 | 8.5 | 127 | . 4 | f | 3 | 3 | 5 | 5.0 | 150 | . 5 | m | 1 | 3 | 3 | 4.5 | 113 | . 6 | m | 2 | 1 | 2 | 3.5 | 95 | . insurance$job . &lt;ol class=list-inline&gt; 1 | 2 | 2 | 3 | 1 | 2 | 3 | 3 | 2 | 1 | 1 | 2 | 3 | 3 | -9 | 1 | 1 | 2 | 2 | 3 | 3 | 3 | &lt;/ol&gt; insurance = read.table(&quot;./data/01//insurance.txt&quot;, sep = &quot; t&quot;, header=T, na.strings = &quot;-9&quot;) . insurance$job . &lt;ol class=list-inline&gt; 1 | 2 | 2 | 3 | 1 | 2 | 3 | 3 | 2 | 1 | 1 | 2 | 3 | 3 | &lt;NA&gt; | 1 | 1 | 2 | 2 | 3 | 3 | 3 | &lt;/ol&gt; # (3) 덮어쓸 labels도 순서대로 동시에 준다. insurance$job &lt;- factor(insurance$job, levels = 1:3, labels = c(&quot;근로자&quot;, &quot;사무직&quot;, &quot;전문가&quot;) ) . insurance$job . &lt;ol class=list-inline&gt; 근로자 | 사무직 | 사무직 | 전문가 | 근로자 | 사무직 | 전문가 | 전문가 | 사무직 | 근로자 | 근로자 | 사무직 | 전문가 | 전문가 | &lt;NA&gt; | 근로자 | 근로자 | 사무직 | 사무직 | 전문가 | 전문가 | 전문가 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;근로자&#39; | &#39;사무직&#39; | &#39;전문가&#39; | &lt;/ol&gt; head(insurance) . idsexjobreligioneduamountsalary . 1 | m | 근로자 | 1 | 3 | 7.0 | 110 | . 2 | m | 사무직 | 1 | 4 | 12.0 | 135 | . 3 | f | 사무직 | 3 | 5 | 8.5 | 127 | . 4 | f | 전문가 | 3 | 5 | 5.0 | 150 | . 5 | m | 근로자 | 3 | 3 | 4.5 | 113 | . 6 | m | 사무직 | 1 | 2 | 3.5 | 95 | . insurance$edu2 &lt;- factor(insurance$edu, levels = 1:5, labels = c(&quot;무학&quot;, &quot;국졸&quot;, &quot;중졸&quot;, &quot;고졸&quot;, &quot;대졸&quot;) ) . insurance . idsexjobreligioneduamountsalaryedu2 . 1 | m | 근로자 | 1 | 3 | 7.0 | 110 | 중졸 | . 2 | m | 사무직 | 1 | 4 | 12.0 | 135 | 고졸 | . 3 | f | 사무직 | 3 | 5 | 8.5 | 127 | 대졸 | . 4 | f | 전문가 | 3 | 5 | 5.0 | 150 | 대졸 | . 5 | m | 근로자 | 3 | 3 | 4.5 | 113 | 중졸 | . 6 | m | 사무직 | 1 | 2 | 3.5 | 95 | 국졸 | . 7 | m | 전문가 | 2 | 4 | 4.0 | 102 | 고졸 | . 8 | f | 전문가 | 2 | 4 | 4.0 | 122 | 고졸 | . 9 | f | 사무직 | 3 | 4 | 4.5 | 140 | 고졸 | . 10 | m | 근로자 | 3 | 5 | 17.0 | 100 | 대졸 | . 11 | f | 근로자 | 1 | 3 | 22.0 | NA | 중졸 | . 12 | m | 사무직 | 1 | 2 | 5.5 | 106 | 국졸 | . 13 | m | 전문가 | 2 | 1 | 4.5 | 130 | 무학 | . 14 | m | 전문가 | 2 | 5 | 7.0 | 150 | 대졸 | . 15 | m | NA | 3 | 4 | 6.0 | 110 | 고졸 | . 16 | f | 근로자 | 3 | NA | 7.0 | 88 | NA | . 17 | m | 근로자 | 1 | 4 | 6.0 | 138 | 고졸 | . 18 | f | 사무직 | 1 | 5 | 5.0 | 110 | 대졸 | . 19 | m | 사무직 | 3 | 3 | 7.0 | 85 | 중졸 | . 20 | m | 전문가 | 3 | 4 | 9.5 | 110 | 고졸 | . 21 | m | 전문가 | 1 | 4 | 10.0 | 95 | 고졸 | . 22 | m | 전문가 | 2 | 3 | 12.0 | 88 | 중졸 | . 1.2.9 list . 객체들을 복합 오브젝트로 만들어준다. | . intake.pre &lt;- c(5260, 5470, 5640, 6180, 6390) intake.post &lt;- c(3910, 4220, 3885, 5160, 5645) . mylist &lt;- list(before=intake.pre, after=intake.post) mylist # df의 칼럼처럼 뽑아쓸 수 있게 모아준다. . $before &lt;ol class=list-inline&gt; 5260 | 5470 | 5640 | 6180 | 6390 | &lt;/ol&gt; $after &lt;ol class=list-inline&gt; 3910 | 4220 | 3885 | 5160 | 5645 | &lt;/ol&gt; mylist$before . &lt;ol class=list-inline&gt; 5260 | 5470 | 5640 | 6180 | 6390 | &lt;/ol&gt; dataframe . 복합 오브젝트 중에 행렬을 만든다. | text파일을 읽을 땐, 거의 df의 행렬로 만든다고 생각하면 된다. | . d &lt;- data.frame(intake.pre, intake.post) d . intake.preintake.post . 5260 | 3910 | . 5470 | 4220 | . 5640 | 3885 | . 6180 | 5160 | . 6390 | 5645 | . d$intake.pre . &lt;ol class=list-inline&gt; 5260 | 5470 | 5640 | 6180 | 6390 | &lt;/ol&gt; 1.2.11 indexing &#44592;&#45733; . 순서대로, 혹은 일부만 벡터/list/df의 특정index(또는 열)을 여러개 뽑아쓰는 기능 | . intake.pre[c(1,5)] . &lt;ol class=list-inline&gt; 5260 | 6390 | &lt;/ol&gt; intake.pre[- c(1,5)] . &lt;ol class=list-inline&gt; 5470 | 5640 | 6180 | &lt;/ol&gt; 1.2.12 Conditional selection . 인덱싱 처럼 대괄호를 쓰며, 인덱싱 명시 자리에 조건식을 넣는다. 데이터 순서를 (환자)id로 공유하는 list 데이터라면, 서로 다른 list &amp;&amp; 상관없어 보이는 데이터를 통해 만들기 가능한` boolean 벡터를 만들어서 대괄호에 넣는다. | . | . intake.post . &lt;ol class=list-inline&gt; 3910 | 4220 | 3885 | 5160 | 5645 | &lt;/ol&gt; intake.pre . &lt;ol class=list-inline&gt; 5260 | 5470 | 5640 | 6180 | 6390 | &lt;/ol&gt; # 1) [pre가 6000보다 컸]던 id의 환자들에 대해 # 2) post 수치는? intake.post[ intake.pre &gt; 6000 ] . &lt;ol class=list-inline&gt; 5160 | 5645 | &lt;/ol&gt; intake.post[ intake.pre &gt; 5500 &amp; intake.pre &lt;= 6200 ] . &lt;ol class=list-inline&gt; 3885 | 5160 | &lt;/ol&gt; # - 비운 행or렬 = 전체 d [ d$intake.pre &gt; 6000, ] . intake.preintake.post . 46180 | 5160 | . 56390 | 5645 | . 1.2.15 implicit loops . 내장된 반복을 가진 기능들 | . library(&quot;ISwR&quot;) . data(thuesen) . head(thuesen, 3) # 2개의 변수가 있는 데이터 투센 . blood.glucoseshort.velocity . 15.3 | 1.76 | . 10.8 | 1.34 | . 8.1 | 1.27 | . # - l을 붙이면, 각 변수들이 변수명을 가진 list()로 합쳐진다. like before=,after= lapply( thuesen, mean) . $blood.glucose 10.3 $short.velocity &lt;NA&gt; # - na.rm = T : 미싱밸류를.제거한 lapply( thuesen, mean, na.rm = T) . $blood.glucose 10.3 $short.velocity 1.32565217391304 # - 그냥 벡터형식으로 풀어진다. sapply(thuesen, mean, na.rm = T) . &lt;dl class=dl-horizontal&gt; blood.glucose 10.3 short.velocity 1.32565217391304 &lt;/dl&gt; # - 데이터를 바로 넣으면 안해준다. # - (데이터변수 , 그룹변수, 집계)순으로 지정해줘야한다. tapply(thuesen, mean, na.rm = T) . Error in unique.default(x, nmax = nmax): unique()는 오로지 벡터들에만 적용됩니다 Traceback: 1. tapply(thuesen, mean, na.rm = T) 2. lapply(INDEX, as.factor) 3. FUN(X[[i]], ...) 4. factor(x) 5. unique(x, nmax = nmax) 6. unique.default(x, nmax = nmax) . tapply(thuesen$blood.glucose, thuesen$short.velocity, mean, na.rm = T) . &lt;dl class=dl-horizontal&gt; 1.03 4.9 1.05 16.1 1.09 11.1 1.12 6.5 1.18 7.5 1.19 8.85 1.22 12.2 1.25 6.7 1.27 7.65 1.28 15.1 1.31 9.3 1.32 13.3 1.34 10.8 1.37 10.3 1.47 19.5 1.49 5.3 1.52 6.7 1.7 9.5 1.76 15.3 1.95 19 &lt;/dl&gt; data(energy) . energy . expendstature . 9.21 | obese | . 7.53 | lean | . 7.48 | lean | . 8.08 | lean | . 8.09 | lean | . 10.15 | lean | . 8.40 | lean | . 10.88 | lean | . 6.13 | lean | . 7.90 | lean | . 11.51 | obese | . 12.79 | obese | . 7.05 | lean | . 11.85 | obese | . 9.97 | obese | . 7.48 | lean | . 8.79 | obese | . 9.69 | obese | . 9.68 | obese | . 7.58 | lean | . 9.19 | obese | . 8.11 | lean | . tapply(energy$expend, energy$stature, mean, na.rm = T) . &lt;dl class=dl-horizontal&gt; lean 8.06615384615385 obese 10.2977777777778 &lt;/dl&gt; # - 1=row별 가로집계 / 2=col별 세로집계 m = matrix(rnorm(12), 4) # 2번째인자가 row수만 지정해주는 듯 m . 0.9182174 | -0.7425004 | 1.0621464 | . -1.0513366 | 0.8554100 | -0.2472357 | . -0.9116358 | -1.6340607 | -0.4725558 | . -0.1975745 | -0.1045159 | 1.0616053 | . # - 칼럼별 최소값 apply(m, 2, min) . &lt;ol class=list-inline&gt; -1.05133658709921 | -1.63406066310988 | -0.472555766861294 | &lt;/ol&gt; Sorting . 특정 변수에 대한 order객체를 만든 뒤 -&gt; boolean mask자리에 order mask를 인덱싱 자리에 넣어줘야한다. | . intake . prepost . 5260 | 3910 | . 5470 | 4220 | . 5640 | 3885 | . 6180 | 5160 | . 6390 | 5645 | . 6515 | 4680 | . 6805 | 5265 | . 7515 | 5975 | . 7515 | 6790 | . 8230 | 6900 | . 8770 | 7335 | . typeof(intake$post) . &#39;double&#39; o1 &lt;- order(intake$post) o1 . &lt;ol class=list-inline&gt; 3 | 1 | 2 | 6 | 4 | 7 | 5 | 8 | 9 | 10 | 11 | &lt;/ol&gt; typeof(o1) . &#39;integer&#39; intake$post . &lt;ol class=list-inline&gt; 3910 | 4220 | 3885 | 5160 | 5645 | 4680 | 5265 | 5975 | 6790 | 6900 | 7335 | &lt;/ol&gt; # -&gt; 해당칼럼에 대한 오름차순 order객체로 정렬 intake$post[o1] . &lt;ol class=list-inline&gt; 3885 | 3910 | 4220 | 4680 | 5160 | 5265 | 5645 | 5975 | 6790 | 6900 | 7335 | &lt;/ol&gt; intake$pre . &lt;ol class=list-inline&gt; 5260 | 5470 | 5640 | 6180 | 6390 | 6515 | 6805 | 7515 | 7515 | 8230 | 8770 | &lt;/ol&gt; intake$pre[o1] . &lt;ol class=list-inline&gt; 5640 | 5260 | 5470 | 6515 | 6180 | 6805 | 6390 | 7515 | 7515 | 8230 | 8770 | &lt;/ol&gt; R environment . Session management . ls(): 내 워크스페이스에 존재하는 모든 객체 | rm(): 데이터 객체 삭제 | . ls() . &lt;ol class=list-inline&gt; &#39;a&#39; | &#39;aa&#39; | &#39;b&#39; | &#39;bmi&#39; | &#39;d&#39; | &#39;energy&#39; | &#39;fpain&#39; | &#39;height&#39; | &#39;hh&#39; | &#39;insurance&#39; | &#39;intake.post&#39; | &#39;intake.pre&#39; | &#39;m&#39; | &#39;mylist&#39; | &#39;nwd&#39; | &#39;o1&#39; | &#39;oops&#39; | &#39;pain&#39; | &#39;thuesen&#39; | &#39;wd&#39; | &#39;weight&#39; | &#39;x&#39; | &#39;xbar&#39; | &#39;y&#39; | &lt;/ol&gt; rm(aa, b) # rm으로 데이터객체 삭제 -&gt; 콤마로 한번에 여러개 가능 . ls() . &lt;ol class=list-inline&gt; &#39;a&#39; | &#39;bmi&#39; | &#39;d&#39; | &#39;energy&#39; | &#39;fpain&#39; | &#39;height&#39; | &#39;hh&#39; | &#39;insurance&#39; | &#39;intake.post&#39; | &#39;intake.pre&#39; | &#39;m&#39; | &#39;mylist&#39; | &#39;nwd&#39; | &#39;o1&#39; | &#39;oops&#39; | &#39;pain&#39; | &#39;thuesen&#39; | &#39;wd&#39; | &#39;weight&#39; | &#39;x&#39; | &#39;xbar&#39; | &#39;y&#39; | &lt;/ol&gt; # df객체 속 변수를 바로 쓰는 방법은? # -&gt; session에 df자체를 attach해버리는 것 -&gt; 가진 칼럼들이 다 변수로 붙어진다? # --&gt; 함수들의 인자로 넣기 쉽게 하기 위함인듯? . head(thuesen, 3) . blood.glucoseshort.velocity . 15.3 | 1.76 | . 10.8 | 1.34 | . 8.1 | 1.27 | . attach(thuesen) . ls() . &lt;ol class=list-inline&gt; &#39;a&#39; | &#39;bmi&#39; | &#39;d&#39; | &#39;energy&#39; | &#39;fpain&#39; | &#39;height&#39; | &#39;hh&#39; | &#39;insurance&#39; | &#39;intake.post&#39; | &#39;intake.pre&#39; | &#39;m&#39; | &#39;mylist&#39; | &#39;nwd&#39; | &#39;o1&#39; | &#39;oops&#39; | &#39;pain&#39; | &#39;thuesen&#39; | &#39;wd&#39; | &#39;weight&#39; | &#39;x&#39; | &#39;xbar&#39; | &#39;y&#39; | &lt;/ol&gt; blood.glucose . &lt;ol class=list-inline&gt; 15.3 | 10.8 | 8.1 | 19.5 | 7.2 | 5.3 | 9.3 | 11.1 | 7.5 | 12.2 | 6.7 | 5.2 | 19 | 15.1 | 6.7 | 8.6 | 4.2 | 10.3 | 12.5 | 16.1 | 13.3 | 4.9 | 8.8 | 9.5 | &lt;/ol&gt; # - 인덱싱과 마찬가진데, 함수를 쓴다.?! thue2 &lt;- subset(thuesen, blood.glucose &lt; 7) thue2 . blood.glucoseshort.velocity . 65.3 | 1.49 | . 116.7 | 1.25 | . 125.2 | 1.19 | . 156.7 | 1.52 | . 174.2 | 1.12 | . 224.9 | 1.03 | . # - 로그값을 씌운 변수를 함수로 생성하여 반환 thue3 &lt;- transform(thuesen, log.gluc = log(blood.glucose)) head(thue3, 4) . blood.glucoseshort.velocitylog.gluc . 15.3 | 1.76 | 2.727853 | . 10.8 | 1.34 | 2.379546 | . 8.1 | 1.27 | 2.091864 | . 19.5 | 1.47 | 2.970414 | . # -&gt; 중괄호{}를 이용하여, 입력된 df내에서 변수생성/조작/중간변수 삭제가 가능하다. thue4 &lt;- within(thuesen, { log.gluc &lt;- log(blood.glucose) # + log씌운 칼럼 생성 m &lt;- mean(log.gluc) # 평균값 계산(중간변수) centered.log.gluc &lt;- log.gluc - m # 중간변수를 이용해 새로운 칼럼 추가 생성 rm(m) }) head(thue4) . blood.glucoseshort.velocitycentered.log.gluclog.gluc . 15.3 | 1.76 | 0.4818798 | 2.727853 | . 10.8 | 1.34 | 0.1335731 | 2.379546 | . 8.1 | 1.27 | -0.1541090 | 2.091864 | . 19.5 | 1.47 | 0.7244414 | 2.970414 | . 7.2 | 1.27 | -0.2718920 | 1.974081 | . 5.3 | 1.49 | -0.5782662 | 1.667707 | . The graphics system . 2.2.1 plot layout . x &lt;- runif(50,0,2) y &lt;- runif(50, 0,2) . plot( x, y, main=&quot;Main title&quot;, sub=&quot;subtitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;, ) . # -&gt; x, y좌표에 텍스트를 넣어준다. text(0.6, 0.6, &quot;text at (0.6, 0.6)&quot;) . Error in text.default(0.6, 0.6, &#34;text at (0.6, 0.6)&#34;): plot.new has not been called yet Traceback: 1. text(0.6, 0.6, &#34;text at (0.6, 0.6)&#34;) 2. text.default(0.6, 0.6, &#34;text at (0.6, 0.6)&#34;) . plot( x, y, main=&quot;Main title&quot;, sub=&quot;subtitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;, ) text(0.6, 0.6, &quot;text at (0.6, 0.6)&quot;) . abline(h=.6, v=.6, lty=2) . Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet Traceback: 1. abline(h = 0.6, v = 0.6, lty = 2) 2. int_abline(a = a, b = b, h = h, v = v, untf = untf, ...) . plot( x, y, main=&quot;Main title&quot;, sub=&quot;subtitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;, ) text(0.6, 0.6, &quot;text at (0.6, 0.6)&quot;) abline(h=.6, v=.6, lty=2) . # -&gt; -1부터 4숫자를, 각 side에 , 0.7크기로, -1~4의 위치에 적기 for (side in 1:4) mtext(-1:4, side=side, at=.7, line=-1:4) . Error in mtext(-1:4, side = side, at = 0.7, line = -1:4): plot.new has not been called yet Traceback: 1. mtext(-1:4, side = side, at = 0.7, line = -1:4) . plot( x, y, main=&quot;Main title&quot;, sub=&quot;subtitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;, ) text(0.6, 0.6, &quot;text at (0.6, 0.6)&quot;) abline(h=.6, v=.6, lty=2) for (side in 1:4) # -1부터 4숫자를, 각 side에 , 0.7크기로, -1~4의 위치에 적기 mtext(-1:4, side=side, at=.7, line=-1:4) . c(1:4) . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 4 | &lt;/ol&gt; 1:4 . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 4 | &lt;/ol&gt; mtext(paste(&quot;side&quot;, 1:4), side=c(1:4), line=-1, font=2) . Error in mtext(paste(&#34;side&#34;, 1:4), side = c(1:4), line = -1, font = 2): plot.new has not been called yet Traceback: 1. mtext(paste(&#34;side&#34;, 1:4), side = c(1:4), line = -1, font = 2) . plot( x, y, main=&quot;Main title&quot;, sub=&quot;subtitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;, ) text(0.6, 0.6, &quot;text at (0.6, 0.6)&quot;) abline(h=.6, v=.6, lty=2) for (side in 1:4) mtext(-1:4, side=side, at=.7, line=-1:4) mtext(paste(&quot;side&quot;, 1:4), side=c(1:4), line=-1, font=2) . 2.2.2 Building a plot from pieces . 각 축에 라벨 주기 | . plot(x, y) . # -&gt; 흰색으로 표시만 지우고 도화지만 그려놓는다는 의미 # 라벨도 &quot;&quot;로 다 지우고 # axes= F -&gt; 축도 그리지 말고 있어라. plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F ) . plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F) points(x, y) . # 2) axis(1) -&gt; 1번 축(x축)만 그려라 plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F) points(x, y) axis(1) . # 2) axis(1) -&gt; 1번 축(x축)만 그려라 # 3) axis(2, at= ) -&gt; 2번 축(좌 y축)에는 점을 직접 찍어준다. plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F) points(x, y) axis(1) axis(2, at=seq(0.2, 1.8, 0.2)) . # 2) axis(1) -&gt; 1번 축(x축)만 그려라 # 3) axis(2, at= ) -&gt; 2번 축(좌 y축)에는 점을 직접 찍어준다. # 4) box() -&gt; 4방향 축이 사각형으로 모두 그려진다. plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F) points(x, y) axis(1) axis(2, at=seq(0.2, 1.8, 0.2)) box() . # 2) axis(1) -&gt; 1번 축(x축)만 그려라 # 3) axis(2, at= ) -&gt; 2번 축(좌 y축)에는 점을 직접 찍어준다. # 4) box() -&gt; 4방향 축이 사각형으로 모두 그려진다. # 5) title() -&gt; main(위) sub(아래) xlab, ylab -&gt; 2개 축 라벨 plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F) points(x, y) axis(1) axis(2, at=seq(0.2, 1.8, 0.2)) box() title(main=&quot;Main title&quot;, sub = &quot;subttitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;) . 2.2.3 Using par . 그래프 그릴 때 유용한 par문 | . ?par . par(mfrow=c(2,2)) # 한 화면을 2x2 로 나눠서 그린다. . par(mfrow=c(1,1)) . 2.2.4 Combinin plots . 그래프를 합치는(겹쳐그리는) 방법: 2번째 그래프에 add=T옵션 주기 정규분포 변수 -&gt; rnorm(갯수) | 정규분포 함수 -&gt; dnorm(변수) | . | hist그램 그린 후 -&gt; 정규분포를 겹쳐그려서 -&gt; 정규분포를 따르는지 확인 | . # - 안주면 각각의 그림이 2개로 나눠서 각각 그려진다. x &lt;- rnorm(100) # 정규분포(r norm)를 따르는 놈 100개 hist(x, freq=F) # 히스토그램: freq=F 를 주면 빈도대신 비율(밀도)가 y축을 차지한다. curve(dnorm(x), add=T) # 정규분포 함수dnorm(x) 를 curve로 그리는데, 겹쳐서 그려라 add=T # my) 정규분포 변수 -&gt; rnorm(갯수) # my) 정규분포 함수 -&gt; dnorm(변수) . # 다시 그리고 -&gt; add=T로 2번째 그림 그리고 h &lt;- hist(x, plot=F) h . $breaks [1] -3 -2 -1 0 1 2 3 4 $counts [1] 4 9 39 28 17 2 1 $density [1] 0.04 0.09 0.39 0.28 0.17 0.02 0.01 $mids [1] -2.5 -1.5 -0.5 0.5 1.5 2.5 3.5 $xname [1] &#34;x&#34; $equidist [1] TRUE attr(,&#34;class&#34;) [1] &#34;histogram&#34; . h &lt;- hist(x, plot=F) # 기존 hist plot 객체에서 y축 정보만 가져와 -&gt; 조작후 객체로 만든다. ylim &lt;- range(0, h$density, dnorm(0)) # 조작된 ylim으로 새로운 hist를 그린다. hist(x, freq=F, ylim=ylim) curve(dnorm(x), add=T) . 2.3 R programming . 함수를 정의하고 -&gt; .r 파일로 저장후 -&gt; source() 문으로 로딩한 뒤 -&gt; 사용 | . # -&gt; 이후 파일로 저장하기 위해 스트링으로 바꿈 func_string &lt;- &quot;hist.with.normal &lt;- function(x) { hist &lt;- hist(x, plot=F) s &lt;- sd(x) m &lt;- mean(x) ylim &lt;- range(0, h$dentisy, dnorm(0, sd=s)) hist(x, freq=F, ylim=ylim) curve(dnorm(x, m, s), add=T) }&quot; . filename &lt;- &quot;./01_p44.r&quot; fileConn &lt;- file(filename) writeLines(func_string, fileConn) close(fileConn) . source(filename) . ls() . &lt;ol class=list-inline&gt; &#39;a&#39; | &#39;bmi&#39; | &#39;d&#39; | &#39;energy&#39; | &#39;fileConn&#39; | &#39;filename&#39; | &#39;fpain&#39; | &#39;func_string&#39; | &#39;h&#39; | &#39;height&#39; | &#39;hh&#39; | &#39;hist.with.normal&#39; | &#39;insurance&#39; | &#39;intake.post&#39; | &#39;intake.pre&#39; | &#39;m&#39; | &#39;mylist&#39; | &#39;nwd&#39; | &#39;o1&#39; | &#39;oops&#39; | &#39;pain&#39; | &#39;side&#39; | &#39;thue2&#39; | &#39;thue3&#39; | &#39;thue4&#39; | &#39;thuesen&#39; | &#39;wd&#39; | &#39;weight&#39; | &#39;x&#39; | &#39;xbar&#39; | &#39;y&#39; | &#39;ylim&#39; | &lt;/ol&gt; x &lt;- rnorm(100) hist.with.normal(x) . 2.3.1 Flow control . R의 반복문 중 3가지 while 문 -&gt; 반복될 조건문 | repeat 문 -&gt; 탈출할 조건문 -&gt; while의 반대 | for 문 -&gt; 뿌려줄 벡터 -&gt; 그걸로 그림그리기 | | . y &lt;- 12345 # 1. while (조건) 식 으로 구하는 root x &lt;- y/2 while (abs(x*x-y) &gt; 1e-10 ) x &lt;- (x + y/x)/2 x . 111.108055513541 x^2 . 12345 # 1. while (조건) 식 으로 구하는 root # 2. repeat { 식 if 탈출조건 break} repeat{ x &lt;- (x + y/x)/2 if (abs(x*x-y) &lt; 1e-10) break } x . 111.108055513541 x &lt;- seq(0, 1, 0.5) plot(x, x, ylab=&quot;y&quot;, type=&quot;l&quot;) for ( j in 2:8 ) lines(x, x^j) . 2.4 Data entry . 김성수 2015 강의교안 저장된페이지 | 01 2015자료 데이터시각화.pdf에 코드 검색됨 | . text file: read.table, read.csv | excel file : read.xlsx ( package: xlsx) | install.packages(&quot;xlsx“) library(xlsx) drug.data = read.xlsx(&quot;c:/Rfolder/data/drug.xlsx&quot;, 1) # 1은 default인데, sheet번호다. edit(drug.data) # R전용 데이터에디터에 가져와서 조작하고 싶을 때 . &#48320;&#49688;&#44049; &#48320;&#54872;(recode) Method1 : &#51064;&#45937;&#49905; . (범위별 매핑 -&gt; ) recode = 변수 값 변환이라고 한다. | . 새 변수를 만들고 (할당으로 복사) | 인덱싱을 이용해서 범위별로 값 변환 | &#48320;&#49688;&#44049; &#48320;&#54872;(recode) Method2 : car&#54056;&#53412;&#51648;&#51032; recode()&#54632;&#49688; . 새 변수 만들어놓는 것은 똑같고 | recode()함수를 이용하여 범위를 간단하게 표현할 수 있다. . &quot; lo:40=1; 40:60=2;60:hi=3 &quot; | . | 1,2,3 범주형 자료이면서 순서형 변수 순서를 ordered()를 이용해서 factor-라벨로 준다. . 라벨을 주면 그래프에서도 나온다. | . | &#44050; &#46972;&#48296;(Value labels): &#49707;&#51088; -&gt; &#46972;&#48296;&#47196; &#48148;&#44984;&#44592; . 명목형 변수 -&gt; 순서 없는 일반 범주factor()를 이용해서 바꾼다. | 순서형 변수 -&gt; 순서를 가진 범주ordered()를 이용해서 바꾼다. |",
            "url": "blog.chojaeseong.com/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EB%8D%B0%EB%B6%84%EB%B0%A91/2022/03/11/01-Basics-and-R-environment(%EC%99%84).html",
            "relUrl": "/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EB%8D%B0%EB%B6%84%EB%B0%A91/2022/03/11/01-Basics-and-R-environment(%EC%99%84).html",
            "date": " • Mar 11, 2022"
        }
        
    
  
    
        ,"post40": {
            "title": "싱글톤으로 캐싱(로또번호)",
            "content": "싱글톤과 캐싱 . 싱글톤을 이용한 [단일객체 CACHE] 적용과 TDD . 싱글톤을 이용한 CACHE 생성 2가지 방법(정리용) . static final으로 클래스 CACHE변수; 선언 . 바로 옆에서 = 할당하며 초기화 or 길어서 static { 클래스변수 = } 블럭(final도 가능)에서 초기화 바로 초기화하든, static블럭에서 초기화하든 null이 아닌 상태의 캐쉬변수 | . | 이후 정팩메로만 생성된 CACHE객체 or 생성된 CACHE자료구조에서 1개만 get하여 제공 이후 기본생성자는 CACHE 최초 초기화하며 채울때만 사용됨 | . | . private static final Map&lt;Integer, LottoNumber&gt; LOTTO_NUMBER_CACHE; static { LOTTO_NUMBER_CACHE = IntStream.rangeClosed(LOTTO_NUMBER_MIN, LOTTO_NUMBER_MAX) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } private final int number; public LottoNumber(final int inputNumber) { this.number = inputNumber; } public static LottoNumber from(final String inputNumber) { final int number = Integer.parseInt(inputNumber); validateLottoNumberRange(number); return LOTTO_NUMBER_CACHE.get(number); } . | static으로 클래스 CACHE변수; 선언 (no final) . 이후 정팩메에 synchronized달아주고 . | 정펙매내부에서 초기화 한번도 안된 최초 if (CACHE == null) 상태의 캐쉬변수일 때만, 기본생성자로 CACHE변수 초기화 | 정펙매로만 생성된 CACHE객체 or 생성된 CACHE자료구조에서 1개만 get하여 제공 | . private static Map&lt;Integer, LottoNumber&gt; LOTTO_NUMBER_CACHE; private final int number; private LottoNumber(final int number) { checkNumberRightRange(number); this.number = number; } public synchronized static LottoNumber valueOf(final int number) { checkNumberRightRange(number); if (LOTTO_NUMBER_CACHE == null) { LOTTO_NUMBER_CACHE = IntStream.rangeClosed(MIN_LOTTO_NUMBER, MAX_LOTTO_NUMBER) .boxed() .collect(Collectors.toMap(lottoNumber -&gt; lottoNumber, LottoNumber::new)); } return LOTTO_NUMBER_CACHE.get(number); } . | Test에서부터 빨간줄로 넘어가 -&gt; 캐쉬 적용하기 . 캐쉬로 받아먹으려면 싱글톤 받아주는 정펙매(getInstance())로만 가져와야한다. . 네이밍을 그렇게 했어도 기본 생성자에 넣어줄 파라미터도 받아야한다. | . | 싱글톤의 동시성 잇슈를 처리하기 위해 synchronized를 접근제한자 &lt;-&gt; static 사이에 넣어준다. . public synchronized static void getInstance(final int value) { } . | 앞으로 정펙매로만 제공되어야하므로 도메인 검증을 여기로 옮기자. . 기존 도메인테스트가 new 기본생성자()로 진행되어있으니, 그냥 두고 -&gt; 맨 나중에 도메인검증을 정팩메코드로 + 기본생성자는 private + 검증은 삭제하도록 수정하자.. | . | . public LottoNumber(final int value) { // 지금은 임시로 살려둔다. 테스트를 나중에 바꿀 때 private로 변경 + 검증삭제 validate(value); this.value = value; } public synchronized static void getInstance(final int value) { //2. 검증은 여기로 옮긴다. 왜냐면, 앞으로 CACHE정팩메로만 제공될 것이기 때문. // - 정적안에 들어가므로 검증메서드가 static으로 바뀐다. validate(value); } . | CACHE의 static변수 선언을 직접 안하고 빨간줄생성 하기 위해, . 빨간줄로 if ( == null )부터 static 초기화 를 작성해줬다. 기본생성자는 이제 여기 캐쉬생성에서만 이용되어야한다. 원래는 private으로 바꾸고, TEST다 처내야함. | . | . | static 메서드 내 자동 생성시 constant = static final이므로 그냥 field -&gt; static필드로 생성하자. | . . public class LottoNumber { private static final int MIN = 1; private static final int MAX = 45; // 자동 생성한 CACHE field (static) private static Map&lt;Integer, LottoNumber&gt; CACHE; private final int value; public synchronized static void getInstance(final int value) { validate(value); //3. 캐쉬로 제공될 static 변수; 만 선언하고 -&gt; if null일 때 = 최초에만 초기화 시켜준다. // - Map으로 만들거면 // - 중간에 .map( number -&gt; )없이 맨 나중에 toMap으로 만들면 된다. // - intStream은 Integer가 아니다. toMap에 들어가려면 .boxed() 먼저 해주고 들어가야한다. // - toMap의 2번쨰 인자는 method reference만 사용 가능하다. new LottoNumber(Number하니 안되더라) if (CACHE == null) { CACHE = IntStream.rangeClosed(MIN, MAX) //.map( number -&gt; ) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } } . | 정팩메에서 캐쉬객체 or 캐쉬 자료구조.get()한 것을 응답해준다. . public synchronized static LottoNumber getInstance(final int value) { validate(value); if (CACHE == null) { CACHE = IntStream.rangeClosed(MIN, MAX) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } // 제공은 이제 기본생성자가 아닌, CACHE에서 제공해준다. return CACHE.get(value); } . | 검증이 넘어간 캐쉬 정팩메로 생성 테스트로 마무리 . @Test void cache_create() { assertDoesNotThrow(() -&gt; LottoNumber.getInstance(6)); } .",
            "url": "blog.chojaeseong.com/java/%EC%8B%B1%EA%B8%80%ED%86%A4/%EC%BA%90%EC%8B%B1/cache/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/10/%EC%8B%B1%EA%B8%80%ED%86%A4%EA%B3%BC-%EC%BA%90%EC%89%AC(%EB%A1%9C%EB%98%90%EB%B2%88%ED%98%B8).html",
            "relUrl": "/java/%EC%8B%B1%EA%B8%80%ED%86%A4/%EC%BA%90%EC%8B%B1/cache/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/10/%EC%8B%B1%EA%B8%80%ED%86%A4%EA%B3%BC-%EC%BA%90%EC%89%AC(%EB%A1%9C%EB%98%90%EB%B2%88%ED%98%B8).html",
            "date": " • Mar 10, 2022"
        }
        
    
  
    
        ,"post41": {
            "title": "일급컬렉션관련 가,불변 List",
            "content": "01 Test코드 등 add/remove 허용 가변List는 new ArrayList&lt;&gt;()로 생성 . 테스트코드에서 .add()해야하는데 Arrays.asList(전체단위만 가변ex&gt;set, replace) 나 List.of(아예 조작 불가)로 초기화 하면 UOE 예외가 발생한다. . add 등 조작이 당장 필요한 List는 new ArraysList&lt;&gt;( );로 초기화할 것 | . @Test void 일급컬렉션_생성자가_파라미터로_list를_받는경우_방어적복사_테스트() { //1. 외부에서 일급컬렉션의 포장변수(List&lt;객체&gt;)로 넘겨줄 [add가능한 가변List]를 생성 // - List.of()는 add/remove 등을 제공하지 않으니 Arrays.List()로 생성했다가 UOE 뜸. 역시 불변 //List&lt;LottoNumber&gt; lottoNumbers = List.of(new LottoNumber(1), //List&lt;LottoNumber&gt; lottoNumbers = Arrays.asList(new LottoNumber(1), // -&gt; 테스트에 add 등 조작하는 가변List는 new ArraysList()&lt;&gt;;로 초기화해서 사용할 것 List&lt;LottoNumber&gt; lottoNumbers = new ArrayList&lt;&gt;(); lottoNumbers.addAll( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6) )); } . | . 02 input 가정인자(검증후 완료된 인자) 등 add/remove 불허 불변List(List.of()) . 참고 블로그 | TDD할 때, input으로 넘어온다고 가정한 인자로서 List를 받을 때 Arrays.asList(1,2,3)이 아니라 List.of(1,2,3)을 쓰더라 | . | . 결론 . List.of() , List.copyof( list )는 add/remove등 **조작시 ** UnsupportedOperationException발생시키는 불변List | 모든 가변 조작(add/remove, set/replace) 불허 | null도 불허 | . | 반면 Arrays.asList는 add/remove만 안되는 전체는 가변List를 제공 통채로 add하는 set, replace 가능) | null허용 + | . | 둘다 add안되니.. 테스트용 가변 객체리스트 생성시에도.. add하면서 테스트하면 안될 듯. | . returnType . List.of()는 10개까진 가변인자 없이 하나하나 받아서 -&gt; ImmutableCollections.ListN()을 반환한다. . add(), remove(), set(), replace()처럼 삽입, 삭제, 변경작업을 하게 될시 UnsupportedOperationException예외가 발생는 불변 자료구조 = 이름 그대로 Immutable한 Collection을 반환해준다. | . static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6) { return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6); } . java9부터 제공한다. . | 인자의 갯수( 0개 / 1~2개 / 3개이상N/ List )에 따라서 다른방식 메서드를 반환한다. . . . | . | 반면에 Arrays.asList()는 가변인자를 받으며 -&gt; new ArraysList&lt;&gt;()를 반환한다. . public static &lt;T&gt; List&lt;T&gt; asList(T... a) { return new ArrayList&lt;&gt;(a); } . 가변인자는 내부 배열로 관리됨 | 추상메서드 AbstractList&lt;E&gt;를 extends하지만, add+remove만 메서드 오버라이딩 하지 않는다. AbstractList의 add()와 remove() 메서드를 확인해본 결과 서브클래스에서 해당 메서드를 오버라이딩 하지 않았다면, UnsupportedOperationException예외가 발생된다. Arrays.asList()의 리턴되는 ArrayList는 삽입, 삭제로 이뤄지는 구조적인 변경을 허용하지 않고 내부 원소들의 값을 변경하는건 허용하는걸 알 수 있다. | . | set() setter메서드만 오버라이딩함. | . | . | . 03 일급컬렉션의 List&lt;객체&gt; 파라미터를 받는 생성자 or 컬렉션을 return하는 getter의 return문에서의 방어적 복사 -&gt; 불변List.copyOf( list ) or add 등 가변 new ArraysList&lt;&gt;( list ) . 만약, 생성자가 파라미터 List&lt;객체&gt;를 받으면, 외부 원본 list의 메모리주소가 들어오니 끊고 재생성해라. . list를 내부 포장할 때, 만약 생성자 파라미터로 내부 포장하는 변수와 동일한 형태의 List&lt;객체&gt;가 들어오면, 외부에서 온 List의 메모리주소로서, 끊고 재생성해줘야 오염이 안된다. list는 callByReference 로서 파라미터에 지역변수로 선언되어도 외부의 메모리주소를 가지고 있다. | this.value = 파라미터로 온 list는 메모리 주소만 대입하여 포장되어있지만, 외부 변화에 오염된다. | . @Test void 일급컬렉션_생성자가_파라미터로_list를_받는경우_방어적복사_테스트() { //1. add될 가변 &amp;&amp; 방어적복사로인한 메모리주소 끊음(재발급)안하면 일급컬렉션 내부 변수도 오염시키는 // -&gt; &lt;외부 원본 List&gt; List&lt;LottoNumber&gt; lottoNumbers = new ArrayList&lt;&gt;(); lottoNumbers.addAll( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6) )); //2. 일급은 외부list를 생성자로 넘겨받아 --방어적복사없이 --&gt; this.value에 넣은 상태다. final Lotto lotto = new Lotto(lottoNumbers); //3. 일급컬렉션말고, 원본에 1개를 더한다. lottoNumbers.add(new LottoNumber(7)); //4. getter로 내부 상태값의 길이를 가져와보자. 6개여야하는데... 7개가 되어있을 것이다. final int size = lotto.getSize(); //5. 7하니까 통과 ... -&gt; 외부list를 add했는데 -&gt; 일급컬렉 포장변수가 가변으로 변해버렸다. assertThat(size).isEqualTo(7); } . | 파라미터로 오는 외부List의 메모리주소를 끊는 방법 2가지 불변 일급 : List.copyOf( otherList ) | 가변 일급: new ArraysList&lt;&gt;( ohterList )로 반환받아서 this.value에 넣어주자. | public Lotto(final List&lt;LottoNumber&gt; value) { if (value.size() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개여야 합니다.&quot;); } if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 중복해서 입력할 수 없습니다.&quot;); } //this.value = value; // 불변하는 일급컬렉션으로 -&gt; 1번째 방어적 복사 적용 this.value = List.copyOf(value); } . // 외부 add에도 6개라고 에러났다. org.opentest4j.AssertionFailedError: expected: 7 but was: 6 Expected :7 Actual :6 &lt;Click to see difference&gt; . | . 참고) 포장(VO or 일급컬렉션) 변수명: value, 상수 MIN/MAX . 값의 포장은 앵간하면 value를 인스턴스 변수(상태값)으로 쓴다. 그래야 getter시 LottoNumber.getValue() 형태로 잘 빠진다. | 만약, LottoNumber.getLottoNumber()가 될 수 도.. | . | 상수도 마찬가지로 도메인Class.이 앞에 붙는다고 생각하고 도메인내에서 편하게 짓자 LottoNumber.LOTTO_NUMBER_MIN이 될 수도.. | LottoNumber.MIN으로 MIN, MAX 편하게 쓰자. | . | . public class LottoNumber { private static final int MIN = 1; private static final int MAX = 45; private final int value; //LottoNumber.getValue()가 맞다.(o) -&gt; LottoNumber.getLottoNumber() (X) public LottoNumber(final int value) { validate(value); this.value = value; } //LottoNumber.MIN 이 맞다.(o) -&gt; LottoNumber.LOTTO_NUMBER_MIN (X) //Integer.MAX_VALUE (o) private void validate(final int value) { if (value &lt; MIN || value &gt; MAX) { throw new IllegalArgumentException(&quot;로또 번호의 범위가 아닙니다.&quot;); } . 일급이 중복 허용 안한다면 단일List가 대신 단일Set으로 정의해도 된다. . List&lt;단일&gt;의 value를 Set&lt;단일&gt;로 바꾼다. . | 테스트에서 생성도 Set.of( 단일1, 단일2 )형식으로 사용한다. . . | Set에 들어가므로 해쉬코드로 비교하는 자료구조용 단일객체는 equals/hashCode 오버라이딩이 되어있어야한다. . VO뿐만 아니라 단일값 포장객체는 그냥 다 오버라이딩 해주자. | . |",
            "url": "blog.chojaeseong.com/java/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%EB%B0%A9%EC%96%B4%EC%A0%81%EB%B3%B5%EC%82%AC/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/08/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98%EA%B4%80%EB%A0%A8-List-%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/java/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%EB%B0%A9%EC%96%B4%EC%A0%81%EB%B3%B5%EC%82%AC/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/08/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98%EA%B4%80%EB%A0%A8-List-%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Mar 8, 2022"
        }
        
    
  
    
        ,"post42": {
            "title": "TDD 5 로또(Method부터 시작)",
            "content": "메서드의 파라미터(값-&gt;일급) 및 응답값(제한된 종류의 분기 응답) 포장시 TDD . 메서드의 파라미터(값-&gt;일급) 및 응답값 포장시 TDD [메서드 내부 포장후 -&gt;새 기준메서드 호출] 및 [Client 배려 by 메서드 파라미터 포장 완성된 후 client일급생성 내부(List.of)부터 가변인자 생성자 추가] . 01 메변1) 검증 등 필요에 의한 값 포장시, [메서드복붙]후 [파라미터 수정] -&gt; 에러해결 -&gt; client 인자 변경 . 기존 테스트들이 인자를 안바꿔도 유지되도록 전체 복사후 인자만 바꾼 새 기준 메서드를 만들고 에러 해결후 포장 객체로 메서드 호출 변경 . 기존 테스트는 유지한 체 값List를 받다가 . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { . | 새 테스트에서 검증 등 필요에 의해 값을 1개 포장 . final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, new LottoNumber(100)) . | 포장 Class, ClassTest생성 . public class LottoNumber { private final int value; public LottoNumber(final int value) { this.value = value; } } . class LottoNumberTest { } . | 객체비교를 위해, equals,hC 오버라이딩 . | 메서드 복붙 -&gt; 파라미터 정의 변경 . public static int start(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { . | 검증 요구 새 테스트에 한해, 복붙한 새 메서드 인자를 포장시키도도록 노가다 . @Test void over() { assertThatThrownBy(() -&gt; LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(100)), List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(7)), new LottoNumber(6) )).isInstanceOf(IllegalArgumentException.class); } . | 검증, 필요에 의한 포장 테스트 -&gt; thr 나야 통과하는 테스트 . 포장 생성자에 검증을 안 넣어준 상태므로 테스트를 통과못한다. | 원래 포장 객체 생성자 1개로만 테스트를 해야하는데, 여기서는 메서드 전체 호출로 퉁친다. | . | 02 도메인 속 검증 등 포장에 의해 thr나는 메서드() 테스트 작성 . 생성자 쪽에서 validate해준다. . public LottoNumber(final int value) { validate(value); this.value = value; } private void validate(final int value) { if (value &lt; 1 || value &gt; 45) { throw new IllegalArgumentException(&quot;로또 번호의 범위가 아닙니다.&quot;); } } . | 테스트해서 thr나게 된다. . @Test void over() { assertThatThrownBy(() -&gt; LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(100)), List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(7)), new LottoNumber(6) )).isInstanceOf(IllegalArgumentException.class); } . | 03 (필요에 의해 포장이 발생된) 메서드 테스트를 넘어서서 도메인 전용Test에서 경계값들 테스트 . class LottoNumberTest { @ParameterizedTest @ValueSource(ints = {0, 46, -1, 100}) void range(final int value) { assertThatThrownBy(() -&gt; new LottoNumber(value)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;범위&quot;); } } . 04 메변2) [기존 rawInput메서드]는 [파라미터만 유지]한체 내부에서 포장 -&gt; 새 기준 메서드 호출 하는 [포장후 호출메서드]로 변경 . rawInput을 받는 곳의 파라미터명에 raw를 달아 -&gt; 원래 네이밍은 포장후 변수로 받아줄 준비를 한다 . public static int match(final List&lt;Integer&gt; rawUserLotto, final List&lt;Integer&gt; rawWinningLotto, final int rawBonusNumber) { . | 내용물에 대해선 포장된 것으로 처리되는 메서드가 남아있으니, rawInput은 받아서 stream().map(포장생성자).collect()의 List&lt;포장&gt;만해서 그쪽으로 넘겨주기만 한다. . public static int match(final List&lt;Integer&gt; rawUserLotto, final List&lt;Integer&gt; rawWinningLotto, final int rawBonusNumber) { final List&lt;LottoNumber&gt; userLotto = rawUserLotto.stream() .map(LottoNumber::new) .collect(Collectors.toList()); final List&lt;LottoNumber&gt; winningLotto = rawWinningLotto.stream() .map(LottoNumber::new) .collect(Collectors.toList()); return match(userLotto, winningLotto, new LottoNumber(rawBonusNumber)); } . | 요약: 값을 단일객체 포장한다면, 메서드복붙후 포장인자 -&gt; 에러처리 -&gt; rawInput메서드는 내부포장용으로 변경 . 05 메변3) 객체간 검증(갯수, 중복) 등 필요에 의해 List.of앞에 [new 일급()]으로 포장 . [메서드 수정]은 포장후 기준호출해주는 메서드가 아니라 포장인자를 받는 기준 메서드로 . 기준메서드에 List.of( 단일, 객체, 들) -&gt; 갯수 초과 유발(필요에 의한 검증) . rawInput을 받아 포장후 기준메서드 호출해주기도 하지만, 제깍적인 수정을 위해서 포장된 인자를 직접 받아서 내부에서 바로 처리하는 메서드를 수정해줘야한다. . 하나하나 다 쏴줘야, 메서드는 그렇게 오는지 알 수 있다(노가다) | . @Test void lotto7() { assertThatThrownBy(() -&gt; LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6), new LottoNumber(7)), // 갯수 초과 . 갯수를 초과해서 넣었다. 에러가 나야 통과인데, 현재는 에러가 안날 것이다. 포장해야한다. | . | 파라미터의 갯수 검증은, 받는 메서드 내부에서도 해줘도 될 것 같지만.. [검증은 다 쏴서 포장한 도메인 생성자에서] . 관련 로직도 아닌데, if가 계속 쌓이게 될 것이다. 메서드 내 파라미터를 받아 검증하는 것을 지양하자. | 검증이 필요하면, 포장 -&gt; 도메인 분리 -&gt; 도메인 생성자에서 | . | . 복수개 검증을 위해 List.of( ) 앞에 new 일급() 생성자를 씌워서 포장 시작 . 객체List인 List.of()를 new일급() 생성자를 씌워 일급객체를 만든다. . @Test void lotto7() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(2), . | 일급객체도 상태가 1개 라면, value로 네이밍 -&gt; 나중에 .getValue()로 getter를 쓸 생각 . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final List&lt;LottoNumber&gt; value) { this.value = value; } } . | 검증의 순서는 중복검사보다는 갯수가 있다면 갯수가 먼저다 . public Lotto(final List&lt;LottoNumber&gt; value) { // 중복검사(distinct.count != )보다 갯수검사(size != )가 선행되어야 한다. // (1) 일단 6개가 들어오고 -&gt; 거기서 중복검사 해야한다. // (2) 7개가 들어왔는데 -&gt; 중복검사 해봤자 의미 없다. if (value.size() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개여야 합니다.&quot;); } if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 중복해서 입력할 수 없습니다.&quot;); } this.value = value; } . | 또다시 기존 메서드 유지되도록 전체복사후 인자만 바꾼(list-&gt;포장) 새 기준메서드만들고 -&gt; 에러해결(.getValue()) -&gt; client 호출 변경 . 복붙후 파라미터 변경 . public static int start(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { . | **내용물들은 일단 list에 난 빨간줄을 .getValue()를 붙여서 해결한다. ** . 나중에 도메인 로직으로 들어갈 후보들이다. . 도메인에 넣으면 getter없이 바로 value를 쓰게 된다. | . . | 앞에 getter를 붙이면 빨간줄이 사라진다. . . | . List.of(단일, 객체, 들)을 모두 new일급() 다싼 뒤 -&gt; List&lt;단일&gt;메서드의 파라미터 . | 06 새 기준(일급) 메서드 에러 제거(getValue()) 후, 도메인(일급)에 [필요에 의한 검증(갯수)]시 에러나도록 도메인 검증 작성 -&gt; 메서드 테스트로 퉁치기(일급자체 테스트는 client배려로 test도 배려되면) . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), new Lotto(List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6))), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class) } . 아직!) 일급자체Test List.of() 제거된 가변인자 등의 client 배려(내려가며 생성자 추가) 끝나고 일급 도메인 테스트 하자! . 07 새 기준 메서드(일급이 파라미터, 수정 등 적용 대상) 완성 -&gt; 기존 메서드의 내부에서 포장해서 새기준을 호출하도록 변경 . 변경 전: 파라미터는 포장 전인데, 모든 로직이 다 있는 상태 . | 변경 후: 일급을 파라미터로 받는 이후 수정 등이 적용될new 기준 메서드을 내부에서 호출하도록, 파라미터만 유지해서 기존 테스트코드들 유지 . public static Rank match(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { // 이제 로직은 새 기준메서드에 양보됨. // 새 기준 메서드(포장객체)를 내부에서 호출만 해줌. return match(new Lotto(userLotto), new Lotto(winningLotto), bonusNumber); } . | . 08 client배려1) 메서드 이전 [단일... 가변인자 일급 생성자를 추가]하는데, client List.of ()입력 제거 -&gt; List&lt;단일&gt; to 단일... 파라미터 -&gt; 내부에서 list포장후 기본생성자 호출 . 현재 client 호출 . LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), . | . 일급의 기본 생성자는 그대로 단일List + 검증로직을 보유하고 있는다. . 기존 일급 기본 생성자: 단일List + 검증 로직이 모여있다. 계속 유지되어서 호출되어야한다. . public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . | . client배려 1번은 호출시 clinet가List을 제거하고 -&gt; 파라미터에 가변인자를 받도록 한 뒤 -&gt; 내부에서는 가변인자(배열)을 List로 포장해서 this()로 호출하도록 일급 생성자 추가 . . 추가된 일급의 가변인자 생성자 . public class Lotto { private final List&lt;LottoNumber&gt; value; //단일객체를 가변인자로 받도록 생성자 추가 public Lotto(final LottoNumber... value) { this(Arrays.stream(value).collect(Collectors.toList())); } public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . | . 요약: 기본생성자(단일객체List + 검증) 외에 가변인자(단일객체...) 생성자를 만들어 client의 List.of()호출부터 제거하자. . 가변인자로 내부에서 List화 -&gt; client List.of()가 제거된 모습 . LottoService.start( new Lotto(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), . | . 09 client배려 2) 단일... 가변인자 일급생성자 직후 바로 값... 가변인자 일급생성자를 추가한다. . new 일급( List.of( 단일, 객체) ) new 일급( 단일, 객체 ) : by 단일... 가변인자 + stream List포장 후 this기본생성자 호출 new 일급( 값1, 값2 ) by 값.. 가변인자(int라면 Integer…) + stream map단일객체생성 -&gt; List포장후 this기본생성자 호출 | . | . | 단일… 가변인자 -&gt; 단일객체stream -&gt; 단일객체List가운데 단일객체stream을 값... 가변-&gt; 값 stream + map으로 만들수 있으니 값… 가변 생성자도 추가 . public class Lotto { private final List&lt;LottoNumber&gt; value; //2. new Lotto( 원시값, 가변으로) -&gt; List.Of() + new단일()생성자 제거 public Lotto(final Integer... value) { this(Arrays.stream(value).map(LottoNumber::new).collect(Collectors.toList())); } //1. new Lotto( 단일객체, 가변으로) -&gt; List.Of제거 public Lotto(final LottoNumber... value) { this(Arrays.stream(value).collect(Collectors.toList())); } public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . | . . stream에서 mapToObj가 뜨는 이유는 integer가 아닌 int -&gt; 객체로 가기 때문 -&gt; 애초에 파라미터로 들어오는 원시값들을 int… 대신 Integer...로 box된 타입으로 받을 수 있다. . . 이제 원시값으로 일급을 만들 수 있게 된다. . . 요약: 값... 가변-&gt; 값 stream + map으로 단일... -&gt; 단일객체stream을 만들수 있으니 값.. 가변인자 생성자 추가해서 clinet의 단일...가변입력도 값... 입력으로 대체하자 . 메서드 테스트로 퉁 | . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1,2,3,4,5,6), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class); } . 요약2: 메서드 파라미터 포장이 끝난 직후부터, client배려1 List.of 제거 by 단일... -&gt; client 배려2 new단일() 제거 by 값... . 10 일급자체(경계값)Test는 client배려1,2가 끝난 뒤 -&gt; new 일급 ( 값 가변인자) 로 하면 편하다 . 개수(count) 검사 -&gt; 중복(duplicate) 검사 순으로 . @Test void count_valid() { assertDoesNotThrow(() -&gt; new Lotto(1, 2, 3, 4, 5, 6)); } @Test void count_under() { assertThatThrownBy(() -&gt; new Lotto(1, 2, 3, 4, 5)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } @Test void count_over() { assertThatThrownBy(() -&gt; new Lotto(1, 2, 3, 4, 5, 6, 7)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } @Test void duplicate() { assertThatThrownBy(() -&gt; new Lotto(1, 1, 3, 4, 5, 6)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } . 11 메서드 내부 일급.getValue()는 메서드화하여 도메인내부 로직으로 옮겨갈 후보들 . 일급.메서드( 객체 )로 메세지를 던질 때, 일급을 좌항(메서드 호출하는 놈) 우항에는 내부 찢어질 일급 or 단일(파라미터)을 배치하여 value.list메서드()를 사용하며, 재활용 가능성을 생각하자. . 일급.getter vs 일급 or 일급.getter vs 단일 로직이면 메서드화해서 도메인 로직으로 옮겨가는데, 일급vs일급부터 처리한다. . 일급.메서드( 찢일 or 단일) -&gt; value(일급내부 list).입장에서 넘어온or넘어와돌고있는 단일을 List(value)의 메서드로 컨트롤할 수 있다. | . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { //일급내부list. list메서드 ( 단일 ) if (value.contains(lottoNumber)) { matchCount += 1; } } return matchCount; } . | 일급.getter() vs단일이 외부에 존재했다면 메서드화 하면 . value. list메서드( 단일 )로 내부정의 되므로 일급vs일급 중 value.list메서드( 돌고있는 단일)로 메서드가 재활용 될 가능성이 있으니 잘 확인해서 대체해주면 된다. | . public boolean contains(final LottoNumber number) { return value.contains(number); } . | . 일급.list메서드( 단일 )의 메서드가 추가된다면, -&gt; 내부 상태(value)를 사용하는 내부 정의 메서드인 객체없이 호출되는 메서드가 value.list메서드( 단일 )을 대체한다. . value.contains( lottoNumber ) -&gt; contains(lottoNumber) . 객체없이 호출되는 메서드가 있다면 내부에서 정의된, 내부 상태(value)를 이용하는 메서드로 생각하자. (this.)value가 쓰이는 메서드구나 | . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { //if (value.contains(lottoNumber)) { // 객체없이 호출된다? 내부상태가 쓰이는 내부 정의 메서드구나~! if (contains(lottoNumber)) { matchCount += 1; } } return matchCount; } . | . 응답값 포장 . 12 응답값도 포장할 수 있다. 만약, 제한된 종류 + if분기마다 달라지는 응답값라면 ENUM응답 포장후 응답에 필요한 input들로 정펙매 를 호출한 뒤 내부로 분기 옮겨 응답한다. 이후 if분기를 처리해줄 &lt; input-&gt;필드들 - 응답값&gt;을 매핑한다. . int를 포장한 뒤 -&gt; 관련된 if분기 로직을 포장한 도메인으로 넘기면, 메서드 if문이 사라진다., | . . 제한된 종류의 응답 값포장은 Enum을 활용한다. 메서드 응답을 빨간줄로 바꿔 생성하자. . 만약, 제한되지 않았다면? class Rank로, 현재는 제한된 종류의 값 응답이므로 Enum으로 매핑해서 if를 대신하게 해보자. . . | 연속된 상수라면, Enum명_ 순서를 활용하면 된다. . 1,2,3,4,5등 -&gt; 등을 Enum으로 만들고 등_1,2,3,4,5; 로 선언해보자. | . package lotto; public enum Rank { RANK_1, RANK_2, RANK_3, RANK_4, RANK_5; } . | . 13 응답에 대한 분기로직을 어떻게 응답class/응답Enum으로 넘길까? . . 메서드 응답부에서 원하는 포장된 응답값인 Enum객체을 뽑아 응답해주는 return Enum.정펙매of (,)완성하기 . 결과적으로 정펙매인 Enum.from() or Enum.of( , , )로 Enum객체를 응답해야한다. . 원하는 Enum객체가 응답될 수 있도록 필요한 인자들을 생각해서 받아들인다. | 실제로 입력값이 될 것들을 가지고 있는 사용부인 메서드 응답부에서 부터 시작 | . | . 응답부에서 Enum.정팩메로 해당하는 포장응답값을 return해 줄 예정이다. . 필요한 input들이 뭐가 있는지 살펴본다. | 메서드호출의 결과값이 있다면, input이 명확하도록 따로 변수로 뽑아주자. | . . 정팩메로는 Enum이라는 포장된 응답값을 가져올 것이기 때문에 return과 같이 작성한다. | . . | 값 응답 로직을 -&gt; 포장응답값 정펙매로 잘라내서 처리하기 . 이제 값 응답로직을 그대로 잘라붙혀넣기 한다. . 이동후 | . . | 14 정팩메 내부로 옮긴 분기에 대해, 응답[값]들을 [Enum객체]로 수정해주기 -&gt; 없는 값(0, None)에 대해서도 OUT,NONE객체 만들어서 응답해주기 . 아직 바꾸기 전 응답로직 . if (matchCount == 6) { return 1; } if (matchCount == 5 &amp;&amp; matchBonus) { return 2; } if (matchCount == 5) { return 3; } if (matchCount == 4) { return 4; } if (matchCount == 3) { return 5; } return 0; . | 수정 + NONE객체 추가후 . package lotto; public enum Rank { RANK_1, RANK_2, RANK_3, RANK_4, RANK_5, OUT; public static Rank of(final int matchCount, final boolean matchBonus) { if (matchCount == 6) { return RANK_1; } if (matchCount == 5 &amp;&amp; matchBonus) { return RANK_2; } if (matchCount == 5) { return RANK_3; } if (matchCount == 4) { return RANK_4; } if (matchCount == 3) { return RANK_5; } return OUT; } } . public static Rank match(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { final int matchCount = userLotto.match(winningLotto); final boolean matchBonus = userLotto.contains(bonusNumber); return Rank.of(matchCount, matchBonus); } . | . 15 메서드 [포장된 응답] 테스트 작성하기 . 여러분기므로 1case에 대한 -&gt; 1예상값 마다 테매를 작성해야한다. . @Test void match_1() { //given, when final Rank rank = LottoService.match( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1, 2, 3, 4, 5, 6), new LottoNumber(7) ); //then assertThat(rank).isEqualTo(Rank.RANK_1); } . 16 if분기를 enum정팩매 내부 values().stream+filter( 정펙매input vs 매핑값과 비교 조건식)으로 제거하기 . 정팩메 input으로 들어올 데이터들 中 1개를 골라 (매핑 예정인) Enum객체의 필드로 넣어준다. . 정펙매로 여러 데이터가 들어와 사용가 들어오지만 of( matchCount, matchBonus) . . 매핑에 사용될 쉬운 변수 1개만 선택하여, 정펙매 내부 values().stream.filter 분기에서 비교할 것이다. Enum객체가 필드로 가지고 있으면 되며, 그 필드 기준으로 매핑값도 차후 배정된다. | . | . 쉽게 Enum의 필드에 넣기 위해서는 일단 ENUM(1) 객체 옆에 빨간줄로 원시형 예제작성해준다. . . | 생성자를 생성해주면서 input과 똑같이 네이밍후 빨간줄 this.필드명 = 필드; 초기화를 이용해서 필드를 생성한다. . . . . | 나머지 객체도 데이터를 넣어준다. . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0); private final int matchCount; Rank(final int matchCount) { this.matchCount = matchCount; } public static Rank of(final int matchCount, final boolean matchBonus) { if (matchCount == 6) { return RANK_1; } . | Enum정팩메 내 [제한된종류의 모든 if분기]를 values().stream + filter with input vs 매핑field로 분기 없애기 . 특수한 경우, 정팩매에서 ENUM매핑값 뽑기도 전에, early return해준다. . 특수한 경우로서 2등과 3등을 먼저 필드는 안됬지만 사용해야하는 변수 matchBonus로 홀로 true인 2등을 early return한다. . public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } . | . Enum내에서 values()는 Enum객체배열을 응답하며 거기에 배열.stream자동완성 사용하여 EnumStream 만들어 객체전체를 돌리기 . . . . 제한된 종류의 if분기를 values().stream (for) + filter(it -&gt; input vs 매핑field 비교) 대체하기 . public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); . 기존 if분기들 이제 삭제 | . enum sense: 각 enum객체끝은 마지막도 콤마(,) 그 다음라인(;) + .findAny()후 .orElse( NONE객체 ) . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0), ; . return Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); . 17 Bi(비.아이.) Predicate&lt; , &gt;로 input된 2개 값을 다 사용하는 1개의 람다식필드 &amp;&amp; filter속 예비 조건식(.test(a,b)로 실행)을 만들어 -&gt; [enum의 1 필드 매핑]에 사용되는 Type을 함수형인터페이스로 사용하여 -&gt; 정펙매 내부 들어오는 2개값 모두 사용하는 enum 만들기 . BiPredicate Type은 1개 함수를 가진 인터페이스 = 함수형 인터페이스 중 2개 인자를 받아 실행대기 중인 조건식을 제공해주고 -&gt; .test( a, b)를 통해 외부인자를 받아서 조건식을 실행한다. .test(a, b)에 정팩메로 들어온 input2개를 넣어주면 된다. | . | . 아직 BiPredicate 적용안한 기존 코드 (상금도 매핑 안된 상태) . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0), ; private final int matchCount; Rank(final int matchCount) { this.matchCount = matchCount; } public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } return Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); } } . Enum필드에 2인자 람다식인 BiPredicate를 넣어서 생성하기 . 이번엔 Enum()객체안에 input 중 1개 6,5,4.. 대신에 input 2필드 다 써서 1개 람다식을 만들어 예제로 넣어주자. 이왕이면 다중커서로 한번에 다 입력해주자. | . | 아쉽게도 BiPredicate는 직접 필드입력 -&gt; private final 필드 변수 생성 -&gt; 생산자 자동완성로 가야한다. (원래는 예제 -&gt; 생산자 -&gt; 빨간줄 this.필드 생성) . 원래 객체( 원시값 등 쉬운 Type)을 빨간줄 필드로 넣으면, 생성자에 파라미터 공짜 -&gt; this.로 필드 공짜 생성 | . BiPredicate 작성 . 받은 인자 2개는 if분기에 쓰였던 input값 2개다. -&gt; 원래 Enum의 매핑 쉬운 상수 응답값 6, 5, 4...와 비교해야한다. | . public enum Rank { RANK_1(((matchCount, matchBonus) -&gt; matchCount == 6)), RANK_2((matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; matchBonus), RANK_3((matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; !matchBonus), RANK_4((matchCount, matchBonus) -&gt; matchCount == 4), RANK_5((matchCount, matchBonus) -&gt; matchCount == 3), OUT((matchCount, matchBonus) -&gt; matchCount &lt; 3), ; . | 필드 직접 입력 private final . 제네릭 타입은 들어올 인자들의 Type(정팩메로 들어올 Type)을 Boxing한 타입 + 네이밍은 condition으로 실행될 조건식임을 인지시킴 | . private final BiPredicate&lt;Integer, Boolean&gt; condition; . . | 생성자 자동완성 . | values().stream + filter분기에서 .test( , )로 정펙매 인자를 받아 조건식 실행 . public static Rank of(final int matchCount, final boolean matchBonus) { return Arrays.stream(values()) .filter(it -&gt; it.condition.test(matchCount, matchBonus)) .findAny() .orElse(OUT); } . 18 응답값의 포장(리팩토링)이 다 끝났으면, 자체 도메인Test(Enum은 정펙매 테스트) . @Test void rank_1() { final Rank rank = Rank.of(6, false); assertThat(rank).isEqualTo(Rank.RANK_1); } @Test void rank_2() { final Rank rank = Rank.of(5, true); assertThat(rank).isEqualTo(Rank.RANK_2); } @ParameterizedTest @CsvSource({&quot;5,false,RANK_3&quot;, &quot;4, false, RANK_4&quot;, &quot;3, false, RANK_5&quot;}) void rank_3_5(final int matchCount, final boolean matchBonus, final Rank expected) { final Rank rank = Rank.of(matchCount, matchBonus); assertThat(rank).isEqualTo(expected); } .",
            "url": "blog.chojaeseong.com/java/enum/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/07/TDD-5-%EB%A1%9C%EB%98%90(Service.method%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91).html",
            "relUrl": "/java/enum/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/07/TDD-5-%EB%A1%9C%EB%98%90(Service.method%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91).html",
            "date": " • Mar 7, 2022"
        }
        
    
  
    
        ,"post43": {
            "title": "강의) 네오 2단계 로또 피드백",
            "content": "세팅 . 패키지 생성 (각종 설정 후) . 프로젝트 생성 했다면 . main&gt;java와 | test&gt;java 밑에 패키지 생성(lotto)부터 해주기 | . | 시작점 고르기 (game, service) . 시작점 찾기 로또번호부터 구현할 수 있느냐? | 로또부터? | 정제된 rawInput을 받은 Game, Service부터 구현해서 객체/도메인도출을 천천히 처음부터 객체 도출은 어려울 수 있다. | . | . | Service method TDD . run()테메에서 static한 Service.start()메서드로 메인흐름 시작하기 . LottoServiceTest를 만들고 . | 테스트 메소드명도 편하게 run() . | Service클래스의 static메소드명도 run() start()로 만들면서 시작한다. . . | 요구사항에 따른 [정제 rawInput]을 Controller내 service가 가정 인자로 사용하여 -&gt; Service 흐름 시작하기 . 테스트해야하므로 메인흐름을 가진 메서드는 controller로 응답까지 해줘야한다. . service는 상태를 안가지므로 객체 - 예상객체 비교X, 응답값 - 예상값으로 비교해야한다. | . public class LottoServiceTest { @Test void run() { //사용자의 로또번호 //당첨번호 // 보너스번호 // -&gt; 당첨 등수 응답 LottoService.start(); } } . 로직에 필요한 인자(정제된 input)를 가상으로 넣어주기 | . LottoService.start( List.of(1, 2, 3, 4, 5, 6), List.of(1, 2, 3, 4, 5, 6), 7 ); . 로직결과로 응답까지 해줘야 테스트가 된다. | . | . 가정인자에 따른 1 case만 1응답하도록 짠 뒤 테스트 . 가정인자( 6개 일치) = 1case를 넣어줬으니 -&gt; 1응답을 반환하도록 일단 1 case만 짠다. . 테스트할 메서드는 처음에는 무조건 응답되도록 void를 수정한다. 어떤 형으로 응답할지를 생각해서 정의시 기입한다. . . | 3개이상의 긴 인자는 콤마 다음부터 내려서 이쁘게 정리해주자. . public class LottoService { public static int start(final List&lt;Integer&gt; integers, final List&lt;Integer&gt; integers1, final int i) { } } . public class LottoService { public static int start(final List&lt;Integer&gt; integers, final List&lt;Integer&gt; integers1, final int i) { } } . | 메서드 파라미터 이름을 바꿔준다. . | 아직 도메인을 몰라서 클래스로 분리 못하겠다면, 메인 로직을 rawInput 가지고 짠다. . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { } } . | 1case에 대한 1응답을 해주는 로직을 완성한다. . if가 포함된 1응답이라면, return 0; 같은 default 응답도 넣어준다. | . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { // 몇개 일치하는지 돌면서 누적시켜야한다 // - 돌아가야하는 놈을 우측 파라미터+for문에 // - 전체를 가지고 contains 확인해야하는 놈을 좌변에 int matchCount = 0; for (Integer lotto : userLotto) { if (winningLotto. contains(lotto)) { matchCount += 1; } } // 일단 가정 인자에 따른 1 case통과 코드만 짠다. // 나중에는 matchCount 갯수에 따라 싹다 분기해서 응답해야한다.(리팩 대상) if (matchCount == 6) { return 1; } return 0; // 1case 응답인데, if를 포함해서 응답했다. -&gt; 1외 default return 0;도 해주자. } . | 1응답이 나오는지 test한다. . public class LottoServiceTest { @Test void run() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, 6), List.of(1, 2, 3, 4, 5, 6), 7 ); assertThat(rank).isEqualTo(1); } } . | [테메] 복붙후 2case에 맞게 가정인자+예상값 바꾼 테스트 메서드 만들기 . 복붙 전, 각 case로 테메명 바꿔주고 난 뒤 복붙하기 . 현재 run()으로 되어있는 테스트메서드명을 case를 반영해서 바꿔주고 난 뒤 복붙 . 복붙하는 이유: 기존 테스트가 계속 돌아가도록 하기 위함. | . @Test //void run() { void rank1() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, 6), List.of(1, 2, 3, 4, 5, 6), 7 ); assertThat(rank).isEqualTo(1); } . | . 복붙후 가정인자+예상값을 2case에 맡게 수정 . 1등 반환case 1개 이후에는 -&gt; 복붙후 가정인자를 바꾼 case변경을 하면서 새로 짜야한다. . 테스트메서드 명을 case에 맡게 복사해준다. | 가정인자 및 예상값을 -&gt; 2case에 맞게 수정해준다. | @Test void rank2() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, 6), List.of(1, 2, 3, 4, 5, 7), // 2등에 맞게 가정인자 수정 6 // 2등에 맞게 가정인자 수정 ); assertThat(rank).isEqualTo(2); // 2등에 맞게 예상값 수정 } . | [메서드 복붙]후 2case 예상값을 응답하도록 메서드2를 수정 . 메서드2로 복붙한다. . 단축키 shift + alt + → 및 ↓를 활용해서 복사하고 | 단축니 shift + alt + F로 정렬해서 | . public static int start2(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { . | 메서드2가 case2예상값을 만들도록 짠다. . public static int start2(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { int matchCount = 0; for (Integer lotto : userLotto) { if (winningLotto.contains(lotto)) { matchCount += 1; } } if (matchCount == 6) { return 1; } if (matchCount == 5 &amp;&amp; userLotto.contains(bonusNumber)) { return 2; } return 0; } . | 테메2가 메서드2를 사용하도록 수정한 뒤 테스트한다. . @Test void rank2() { final int rank = LottoService.start2( . | [기존 테메]도 [메서드2]로 돌아가는지 확인한다. . @Test void rank1() { final int rank = LottoService.start2( . [메서드2]를 [메서드]로 완전히 대체한다. . 기존 메서드 회색 비활성화된 메서드를 안전삭제(alt+del)한다. | 메서드2 -&gt; 메서드(F2 2번)로 이름을 바꿔서 완전히 대체한다. | [2case이후 테메]는 복붙후 한번에 처리해보자. . [다case]테메명 + @ParaemeterizedTest를 통해 가정인자+ 예상값들을 변경시키며, 그에 맞는 응답을 하도록 [메서드 원본]을 수정해서 통과되도록 만들자. . 가정인자가 2개, 예상값 1개, 총 3개 인자가 case에 따라 바뀐다. . List.of() | bonusNumber . | expected | @CsvSource 혹은 @MethodSource를 통해 여러 파라미터를 받아야한다. . @ParameterizedTest @MethodSource(&quot;provideWinningLottoAndExpected&quot;) void rank3_to_5(){ . public static Stream&lt;Arguments&gt; provideWinningLottoAndExpected() { return Stream.of( Arguments.of(List.of(1, 2, 3, 4, 5, 7), 8, 3), // 3등 Arguments.of(List.of(1, 2, 3, 4, 7, 8), 9, 4) , // 4등 Arguments.of(List.of(1, 2, 3, 7, 8, 9), 10, 5) // 5등 ); } . @ParameterizedTest @MethodSource(&quot;provideWinningLottoAndExpected&quot;) void rank3_to_5(final List&lt;Integer&gt; winningLotto, final int bonusNumber, final int expected) { // 파라미터 추가 + 가정인자/예상값 다 변경 -&gt; 테스트시 에러나야 정상 final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, 6), winningLotto, bonusNumber ); assertThat(rank).isEqualTo(expected); } . | 바뀐 가정인자 + 예상값에 대응하도록 원본 메서드를 1,2case에 비추어 수정 . if (matchCount == 6) { return 1; } if (matchCount == 5 &amp;&amp; userLotto.contains(bonusNumber)) { return 2; } if (matchCount == 5) { return 3; } if (matchCount == 4) { return 4; } if (matchCount == 3) { return 5; } . | service 메서드 완성후 회고 . 여기까지 통과시키고 난 뒤, 가정인자로 들어오는 놈들에 대해 도메인 지식이 쌓였을 것이다. 가정인자로 들어오는 List에 대해 개별Integer는 개별 객체 LottoNumber라는 객체로도메인 분리할 수 있겠다. | LottoNumber List 6개를 모아서 Lotto라는 객체로 도메인 분리모아볼 수 있겠다. | . | . 구현된 Service method의 가정인자 리팩토링 . 도메인 지식을 높이기 위해서, 가정하고 넣어주는 인자가 rawInput인체로 빨리 돌아가기만 하는 코드를 짠 상태다. . | 유지보수, 계속 봐야하는 코드라면 리팩토링해야한다. . | . 입력인자 예외처리에 의한 도메인 추출 인지 . 테스트코드가 가정인자+예상값의 변화 없이 개별 도메인 생성자 호출자체에서 문제이기 때문에, 개별도메인으로 가서 테스트 된다. | . [입력인자] [가장 작은 단위]의 숫자(로또번호)가 범위를 벗어나는 경우 . 기존 rank1~5 테스트라도 복붙해서 메서드명을 over로 바꿔고 범위를 벗어나는 경우에 대한 가정인자 + 예상값이 아니라 user입력인자를 바꿔서 만들어주자. . 사용자 입력에 대한 예외에 대한 테스트의 경우, service메서드의 가정인자 변화가 문제가 아니라 입력인자에 실수가 반영된 것이기 때문에 객체로 도메인 분리해서 도메인 검증해야한다. | . @Test void over() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, 100), // 사용자 입력인자만 예외인자로 변화 -&gt; 100 입력 List.of(1, 2, 3, 4, 5, 7), // 가정인자 변화X 6 ); assertThat(rank).isEqualTo(2); // 예상값 변화X } . | [입력인자] 가장 작은 단위가 상호작용한 [일급]에서 중복 문제 . 테메 복붙후 이름변경duplicate . | 입력인자에서 중복이 되도록 입력 . 예외 테스트 는 가정인자 + 예상값의 변화가 없는 상태임. | . @Test void duplicate() { final int rank = LottoService.start( List.of(1,1,1,1,1,1), // 사용자 입력인자만 예외인자로 변화 -&gt; 1이 list내 중복 됨. List.of(1, 2, 3, 4, 5, 7), // 가정인자 변화X 6 ); assertThat(rank).isEqualTo(2); // 예상값 변화X } . | Service.메서드() 사용시 발견된 값들의 예외처리 -&gt; 개별 도메인에서 테스트하면서 처리되어야함. . 도메인을 풍부하게 -&gt; 도메인으로 추출 분리후 도메인 내에서 검증 . | 서비스메서드 사용하면서, 그 service(메인로직) 흐름내에서 if로 하지말자. 자기 도메인내에서 if없이 개별로 처리되어야한다. . 잘못된 예(service에서 인자로 넘어온 도메인들의 예외처리) | . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { if (userLotto.get() &gt; 45) { throw new IllegalArgumentException(&quot;범위 초과&quot;); } . | . 메서드인자 리팩토링1) 최소단위 값 검증 때문에 포장하도록 Service.메서드() 수정 . Service.메서드() [최소단위 값] 1개만 new 생성자()로 싸서, Class와 ClassTest를 정의 . Service.메서드() 로직을 사용하던 곳에서 예외발생 상황을 가정했던 곳에서 new 생성자()를 씌워서 Class -&gt; ClassTest까지 만들어보자. . @Test void over() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, new LottoNumber(100)), // 검증이 필요한 곳 -&gt; class로 도메인분리 -&gt; 생성자부터 씌워서 만들어나가기 . | 값을 1개만 포장하는 경우, 변수명을 value로 잡아서 getValue()등 이름을 어색하지 않게 하자. . 생성자로 클래스 생성후, 상태값 직접 지정해줘야한다. | . package lotto; public class LottoNumber { public LottoNumber(final int value) { } } . public class LottoNumber { private final int value; public LottoNumber(final int value) { this.value = value; } } . | classTest도 바로 만들기 . class LottoNumberTest { } . | Service.method()의 [포장]된 [입력인자]버전의 메소드를 만들기 위해 메소드1복붙 . 기존테스트를 통과하는 메소드2의 개발이 아니라 인자가 달라지는 동일명의 메소드를 개발하는 것이므로 메소드명 동일하게 복붙한다. . 기존 포장안한 테스트가 그대로 통과한 상태를 유지할 수 있다. | 포장이 실패할시 바로 돌아갈 수 있다. | 메소드2로 지어도 상관없을 것 같긴하다. | . . | . 메소드 파라미터 정의를 원시형 -&gt; 포장형으로 바꿔주기 . 메소드의 파라미터 정의부를 원시형을 모두 포장 형으로 바꿔준다. . int, Integer -&gt; LottoNumber | . public static int start(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { . | 내부도 다 타입을 바꿔준다. . 에러가 안나는 듯 하지만, 포장class에서도 기본 제공되는 contains()는 비교/포함여부 되려면 equals/hashCode가 오버라이딩 되어있어야 에러가 안난다. | 최소단위 포장은 equals/hashCode생각 | . public class LottoService { public static int start(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { int matchCount = 0; for (LottoNumber lotto : userLotto) { if (winningLotto.contains(lotto)) { matchCount += 1; } } . | 포장용 Service메소드에서 사용되는 값들 모두 포장해서 전달해주기 . 현재 생성을 위해 1개만 포장된 상태다. 수동으로 다 포장해줘야한다. . @Test void over() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, new LottoNumber(100)), // 사용자 입력인자만 예외인자로 변화 -&gt; 100입니다. List.of(1, 2, 3, 4, 5, 7), // 가정인자 변화X 6 ); assertThat(rank).isEqualTo(2); // 예상값 변화X } . 포장 후 | . @Test void over() { final int rank = LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5),new LottoNumber(100)), List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5),new LottoNumber(7)), new LottoNumber(6) ); assertThat(rank).isEqualTo(2); // 예상값 변화X } . | Exception 나는 것을 의도하여 포장했다면 에러가 나야한다 assertThat -&gt; assertThatThrownBy()의 테스트 코드 바꾸기 . 응답 vs 예상값비교 구조에서 () -&gt; exception발생구조로 테스트메서드를 바꿔주자. . @Test void over() { assertThatThrownBy(() -&gt; LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(100)), List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(7)), new LottoNumber(6) )).isInstanceOf(IllegalArgumentException.class); } . | 포장한 도메인 생성자에 예외처리 검증 넣어주기 . 예외 발생 안했다 -&gt; 예외발생시키는 검증을 도메인에 넣어준다. . public LottoNumber(final int value) { validate(value); this.value = value; } private void validate(final int value) { if (value &lt; 1 || value &gt; 45) { throw new IllegalArgumentException(&quot;로또 번호의 범위가 아닙니다.&quot;); } } . | [Service.method()에서의 검증]이 끝났으면 [단일 도메인에서 본격 검증]하러 classTest로 직접가서 [경계값 테스트]하기 . 시간 관계상 Service.method()에서 통채로 테스트하지만, 포장ClassTest에서 직접 경계값 주위로 테스트해야한다. | . class LottoNumberTest { @ParameterizedTest @ValueSource(ints = {0, 46, -1, 100}) void range(final int value) { assertThatThrownBy(() -&gt; new LottoNumber(value)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;범위&quot;); } } . 예외 발생을 위한 포장 회고 . Service.메서드()에서 테스트했지만, LottoNumber로는 더이상 over되는 번호는 오지않겠구나. 심리적 안정감을 얻었다. | . | . 포장 입력인자 메소드 사용시 애로사항 . Service.메서드() 사용시 모든 원시값을 new 포장( )으로 일일히 감싸줘야한다. . LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(100)), List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(7)), new LottoNumber(6) )); . | 포장된 입력인자가 아니라 -원시값 입력인자를 그대로 사용하되, 메소드 내부에서 한꺼번에 포장객체로 변환시키자 . | . [정제된 rawInput을 받던 테매들이 사용하던 service.method()] 내부 개조로 한번에 포장해서 포장인자 메서드 호출해주기 . 기존에 작성된[ 정제된 rawInput을 받던 메소드]의 내용물은 삭제 . 기존 테스트를 위해 정제된 원시값을 받던 메소드 . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { int matchCount = 0; for (Integer lotto : userLotto) { if (winningLotto.contains(lotto)) { matchCount += 1; } } . | . 원시값 인자 네이밍 -&gt; 내부stream으로 한번에 포장 -&gt; return 포장 인자 메서드() 호출 . **기존 내용물은 삭제(포장된 것으로 처리되도록 통일해야됨) ** . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { } . | **원시값 인자 +raw네이밍 붙이기 ** . 각 원시인자 기존 네이밍 -&gt; 포장인자로 갈 때 기존 네이밍으로 받아줘야 -&gt; ``포장메서드 호출시 기존 네이밍으로 가기 때문에 **원시 인자 네이밍 앞에 raw`를 붙혀준다** | . public static int start(final List&lt;Integer&gt; rawUserLotto, final List&lt;Integer&gt; rawWinningLotto, final int rawBonusNumber) { } . return 포장된 인자를 받는 새 메소드()호출 응답은 그대로 나가야하므로 return 유지 | . | . public static int start(final List&lt;Integer&gt; rawUserLotto, final List&lt;Integer&gt; rawWinningLotto, final int rawBonusNumber) { final List&lt;LottoNumber&gt; userLotto = rawUserLotto.stream() .map(LottoNumber::new) .collect(Collectors.toList()); final List&lt;LottoNumber&gt; winningLotto = rawWinningLotto.stream() .map(LottoNumber::new) .collect(Collectors.toList()); return start(userLotto, winningLotto, new LottoNumber(rawBonusNumber)); } . | . 의의: Service를 사용하는 client를 편안하게 해줘야한다.(내부로 가기전에 포장해서 호출해주는 놈이 있다면) = client는 원시값도 입력받아 도메인은 모르게 해주는게 낫다 . client쪽, view쪽, 중요하지 않은쪽, 잘변하는 쪽은 도메인, 포장값 사용없이 원시값으로만 service.메서드()를 호출하고, 내부에서 포장 좋다. 포장을 서비스내에서 한번 거쳐서 하는 방법을 여기선 안내해줬다. | 원래 중요하지 않은쪽이 -&gt; 중요한 것을 생성/사용/리턴하는 방향은 허용된다. | . | 생각이 다를 수 있다. 외부에서 무조건 감싸서 로직에 보내줘야한다라고 생각할 수도 있다. | but 사용하는 client입장에서는.. 내부포장으로 편안한게 좋다 | . | my) controller에서 도메인 사용해도 되지만 내부 포장만 해주는 로직이 따로 존재한다면, 원시값을 넘겨도 될 듯? | . | . 메서드 인자 리팩토링2) 최소단위 [묶음]의 예외 처리 -&gt; 일급 포장하여 검증 . 초과된 [포장 최소단위의 갯수 문제] -&gt; [포장인자 메소드]를 가진 [테매]를 복붙하여 Exception 발생시키기 . 현상황에서 포장인자를 받던 메소드를 복붙하여 포장객체의 갯수 문제를 발생시켜보자. . 아무래도.. 최소단위객체의 범위문제에서 작성된 메소드를 복붙해서 고쳐야함… | . @Test void lotto7() { assertThatThrownBy(() -&gt; LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6), new LottoNumber(7)), // 갯수 초과 List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6)), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class); } . | 갯수를 초과했음에도 불구하고 아직 묶음에 대한 검증이 안되기 때문에 예외발생이 안된다. . . | 앞에서도 그렇고, 예외처리를 Service.method() 내부에서 if로 편하게 해주고 싶은데, 여기서 하면 모든 인자들에 대한 예외처리가 if로 한곳에 쌓일 것이다. . **각 검증은 도메인 추출된 class를 만들어서 그곳에서 한다. ** | . public static int start(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { // 여기서 갯수처리를 해주고 싶으나.. if (userLotto.size() != 6) { throw new 예외 } // 2번째 인자도 예외처리를 로직실행 메서드 내부에서 인자를 받아서 처리하고 싶으나.. if (winningLotto.size() != 6) { throw new 예외 } // 인자들마다 모든 검증들이 if로 여기(사용메서드)에 쌓여갈 것이다. 따른 검증 역시 여기서 해야한다. . | . [객체의 갯수or중복 등 복수 검증]을 위한 List&lt;도메인&gt;을 포장하는 일급포장의 시작 . 복수검증 문제가 발생하는 곳에가서 new 일급()부터 시작 . Service.method()에서 원시값 List -&gt; 단일객체 List가 인자로 들어가는 곳에서 **new 일급( ) ** -&gt; Class -&gt; ClassTest까지 생성해준다. . @Test void lotto7() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(2), . | 생성자로 들어오는 이름도value로 네이밍하여 생성자에서 초기화 . ClassName. 가 PREFIX인 것 및 .getValue() 생각하기 | . public class Lotto { public Lotto(final List&lt;LottoNumber&gt; lottoNumbers) { } } . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final List&lt;LottoNumber&gt; value) { this.value = value; } } . | 나머지도 List -&gt; 일급으로 들어가도록 service.method수정 . . | 들어오는 포장인자(List&lt;단일&gt;) 메서드 복붙 백업후 -&gt; 일급인자로 받도록 method 파라미터 정의부 개조 . 기존 List&lt;단일&gt;으로 들어오던 메서드 전체를 복붙한다. 기존 테스트 유지?를 위해, 일급으로 바꾸기전 List도 들어올 수 있도록 백업해둔다. ![image-20220305003021893](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220305003021893.png) | . | 기존 List&lt;단일&gt;으로 들어오던 메서드의 파라미터 정의부만 정의해준 일급들어오도록 수정한다. . public class LottoService { public static int start(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { . 수정후 | . public static int start(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { . | 내부 빨간줄 수정 ( 단일List -&gt; 일급으로 인한 -&gt; 기본적으로 앞에 .getValue()의 getter가 요구됨.) . 일단 getter로 다 처리해놓자. 리팩토링 요구됨. 객체 메세지 던져서 통신. . | 상태값을 value로 네이밍해줬어도, .getValue()의 빨간줄을 리팩토링으로 생성 후 return this.value;까지 직접 입력해줘야된다. . . | 앞에 getter를 붙이면 빨간줄이 사라진다. . . | . | 일급용 메서드가 완성되었으면 | [일급 인자를 받는 Service.method()]가 완성되었으면, [일급이라는 도메인 내부 생성자에 단일List간 복수검증]을 넣어준다. . 일급 도메인인 Lotto의 생성자에서 상태값 초기화 전에 검증을 넣어준다. . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final List&lt;LottoNumber&gt; value) { this.value = value; } . 도메인 검증 추가 | . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . | 도메인 생성자에 넣어준 검증(중복) 을, Service.method()의 인자검증으로 통채로 . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), new Lotto(List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6))), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class) } . | 포장(단일)에 포장(일급) 후 client가 너무 불편? -&gt; Client를 배려해줘라. . 일급 생성자가 받는 new일급(List&lt;단일&gt;)의 인자를 -&gt; 단일... 가변인자로 받고 내부에서 List.Of대신 모아주는 포장용 생성자 추가 . 현재 일급까지 포장해야하는 Service메서드 테매 . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), new Lotto(List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6))), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class) } . 인자 1개만 떼서 보기 | . new Lotto(List.of(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), . | [Client] 일급 생성자에 들어가는 List.of() 혹은 Set.of() 제거해주는 -&gt; [메서드내부] 가변인자(알아서 배열) -&gt; this + Arrays.stream().collect(Collectors.toList or toSet ())) ) . client에서 List.of(단일,객체)나 Set.of(단일, 객체)대신 단일객체를 콤마로 나열만 해서 넘겨주면, 알아서 List or Set으로 내부에서 모아주는 . 내부에서 포장해준 뒤, 포장 인자용 메서드를 다시 한번 호출해주는 메서드 파라미터 -&gt; 인자만 복사해서 껍데기 메서드 생성 -&gt; 내부에서 포장후 호출 다시 포장인자메서드를 재호출 | 일급 생성자 -&gt; List.Of, Set.of를 제거하여 생성자를 추가 생성 -&gt; 가변인자를 받도록 정의 -&gt; 배열을 stream collect로 List나 set으로 포장만해서 this( , )로 미리 정의해둔 &amp;&amp; 뒤에 존재하는 포장인자용 생성자 호출 | . | . . . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final LottoNumber... value) { this(Arrays.stream(value).collect(Collectors.toList())); } public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . 이제 new Lotto() 일급의 생성자에서 2가지 다 받을 수 있게 된다. List.of( , ,, ) 대신 -&gt;그냥 , , ,의 가변인자를 넣어줘도 알아서 List로 포장하게 된다. | . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1)), new Lotto(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6)), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class); } . | 가변인자(List.of제거) + 단일객체생성자 제거의 일급 내부에 2번의 포장 생성자도 추가해서 client를 편하게 해주자. . new 일급( ) 생성자에 client에서 List.Of() 제거하고 가변인자만 받도록 내부에서 포장해주는 생성자를 추가해줬었다. . //1. new Lotto( 단일객체, 가변으로) -&gt; List.Of제거 public Lotto(final LottoNumber... value) { this(Arrays.stream(value).collect(Collectors.toList())); } . | 이번에는 client 단일객체 생성자 제거하고 단일객체 생성에 필요한 raw원시값을 가변인자로만 받도록 수정해보자. . stream에서 mapToObj가 뜨는 이유는 integer가 아닌 int -&gt; 객체로 가기 때문 -&gt; 애초에 파라미터로 들어오는 원시값들을 int… 대신 Integer...로 box된 타입으로 받을 수 있다. | . public class Lotto { private final List&lt;LottoNumber&gt; value; //2. new Lotto( 원시값, 가변으로) -&gt; List.Of() + new단일()생성자 제거 public Lotto(final Integer... value) { this(Arrays.stream(value).map(LottoNumber::new).collect(Collectors.toList())); } //1. new Lotto( 단일객체, 가변으로) -&gt; List.Of제거 public Lotto(final LottoNumber... value) { this(Arrays.stream(value).collect(Collectors.toList())); } public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . | 이제 단계별로 생성자를 만들어서, 기존 테스트의 인자들이 모두 돌아가게 만들었다. . 이제 원시값으로 일급을 만들 수 있게 된다. | . . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1,2,3,4,5,6), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class); } . | client입장에서 코드를 사용하게 엄청 편해진다. | . my) 메서드의 [인자만 포장후 호출용 메서드] or 일급 등의 생성자를 [인자만 다르게 정의하고 내부는 포장해서] client를 편하게 만들어줬다. . 가변인자 사용시 주의해야한다. . 가변인자는 배열을 내부적으로 만들어서 사용하기 때문에, 메모리 잇슈가 있을 수 있다. . | 그래서 .of()메서드들은 11개부터 가변인자를 사용하고 10개까지는 인자를 하드코딩으로 받는다. . | . | . 일급 테스트는 Service.Method()에서 완성된 [가변인자생성자] 시리즈가 완성된 후에 해주자. . [Service.method()에서의 단일/일급 퉁치는 검증] + [일급의 포장용 가변인자 생성자] 끝났으면 [단일 도메인Test]에서 본격 [경계값 테스트]하기 . Lotto라는 일급도메인 테스트를 만든다. . . | Service.method()에서 퉁치며 만들던 갯수/중복 테스트를 case별로 테매명에 반영하면서 만들어본다. . 가변인자는 parameter로 내려보내질 못하네 | 갯수먼저 검사 -&gt; 중복 검사 중복부터하면? distinct.count() != 6에서 list의 size검사도 같이 일어나 중복에 걸리게 된다. | . | . @Test void count_valid() { assertDoesNotThrow(() -&gt; new Lotto(1, 2, 3, 4, 5, 6)); } @Test void count_under() { assertThatThrownBy(() -&gt; new Lotto(1, 2, 3, 4, 5)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } @Test void count_over() { assertThatThrownBy(() -&gt; new Lotto(1, 2, 3, 4, 5, 6, 7)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } @Test void duplicate() { assertThatThrownBy(() -&gt; new Lotto(1, 1, 3, 4, 5, 6)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } . | Service.메서드의 이름 수정 . start -&gt; match | . 일급으로 바꿨더니, 서비스 메서드 내부에 도메인 로직이? -&gt; 메서드 분리로 역할 분리 . getter가 있으면 도메인내부로직임을 의심한다. | . 일급vs일급 or 일급vs단일의 로직(도메인 로직-특히 getter써놓은부분)이 Service.method()내부에 있는지 확인한다. getter가 있으면 의심해본다. . Lotto와 Lotto를 비교하는 로직이 보인다. 같은 도메인끼리의 비교를 서비스내에서 할 필요가 없다. 같은 놈끼리는 더더욱 메세지를 보내서 getter의 존재없이 비교되도록 + 도메인을 풍부하게 해준다. . 비교로직을 도메인으로 넣고, matchCount만 받아오자. | . public class LottoService { public static int start(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { int matchCount = 0; for (LottoNumber lotto : userLotto.getValue()) { if (winningLotto.getValue().contains(lotto)) { matchCount += 1; } } . | matchCount는 서비스가 가지고 있어야하는데, 비교해서 누적하는 부분만 도메인 로직이다. . | 서비스내 도메인 로직을 도메인 내부 메서드로 옮긴다. . getter로 꺼내서 억지로 하던 것이, 파라미터로 서로를 비교해도 바로 상태값을 갖다 쓸 수 있다. 일단 옮길 도메인내 메서드부터 만든다. . 서비스에서 갖다쓸 예정이니 서비스에서 빨간줄로 만들어도 될듯? | . . 같은 것끼리의 비교는 other로 파라미터를 네이밍해주자 파라미터 other(일급)이 other.value(같은도메인 getter)로 list가 되면서 찢어진다. | . | . . 돌면서 누적하는 것은 초기화 후 누적하는 폼의 가변변수를 쓸 수 밖에 없다? | . . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lotto : other.value) { if (value.contains(lotto)) { matchCount += 1; } } return matchCount; } . | 포장과정에서 빠르게 처리하여 생긴 포장.getter.메서드()가 서비스메서드내 보인다면, 도메인로직으로 (내부 value.메서드()가 되도록)넘겨준다. . . 서비스메서드내 포장(도메인).getter가 보인다. . 넘겨줄 수 없을까? | getter()를 지워 getValue().메서드를 포장.메서드()로 빨간줄을 생성하여 대체한다. | . . . 파라미터(매개변수) 이름으로 bonusNumbe는 너무 구체적이다. 팀원입장에서 시그니쳐보고 쓸건데, 좀더 추상적이면서, 넓게… 메서드 입장에서는 구체적인 bonus라는 것을 모른다. LottoNumber 역시 클래스랑 완전 동일해서.. value를 일급이 이미썼으니 -&gt; number로 네이밍 해준다. | . . 바깥에서 포장.getValue().contains로 사용됬던 것을 -&gt; 포장.contains메서드 -&gt; 도메인 내부에서 getter없이 value.contains로 사용하도록 만든다. | . . | 서비스로직에 geValue()를 달고 있는 것ㅇ 도메인 로직으로 옮겨가며되면, 포장(도메인).getValue()가 비활성화 되며 -&gt; alt+del로 안전삭제 해준다. . | 일급과 단일의 메서드가 정의됬다면 -&gt; 일급vs일급에서도 사용될 가능성이 있다. . 서비스 로직에 있던 일급.contains(단일)의 메서드가 정의되었다면 . 일급vs단일은 일급내에서 파라미터/우항이 찢어지는 일급vs일급 비교메서드에서 쓰일 가능성이 높다. | . . 정의했으면, 찾아서 대체해준다. | . | 객체없이 호출되는 메서드 -&gt; 순수묶음 or [내부 포장된 변수](현재는 일급을 get한 단일List)가 쓰이는 내부 메서드 . contains( xxx) | (현재 도메인의 포장하는 변수)가 생략된체로 cotains()하고 있구나 생각 | . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { //value:[일급] lotto:찢어진 일급이 돌고 있는 [단일] // [일급 내부] 메서드 contains는 // [일급의 getter(단일List)된 value가 내부에서 쓰이는] 메서드로서, // 들어오는 단일에 대해 [현재 일급의 단일List]가 &lt;파라미터 단일&gt;을 포함하는지 // my) 객체없는 메서드 -&gt; 순수묶음 or [내부 포장된 변수](현재는 일급을 get한 단일List)가 쓰이는 내부 메서드 // if (value.contains(lotto)) { // 객체없이 호출된다? 내부상태가 쓰이는 내부 정의 메서드구나~! if (contains(lottoNumber)) { matchCount += 1; } } return matchCount; } public boolean contains(final LottoNumber number) { return value.contains(number); } . | . 응답값도 포장할 수 있다. 만약, 제한된 종류 + if분기마다 달라지는 응답값라면 ENUM응답 포장후 응답에 필요한 input들로 정펙매 를 호출한 뒤 내부로 분기 옮겨 응답한다. 이후 if분기를 처리해줄 &lt; input-&gt;필드들 - 응답값&gt;을 매핑한다. . int를 포장한 뒤 -&gt; 관련된 if분기 로직을 포장한 도메인으로 넘기면, 메서드 if문이 사라진다., | . . 제한된 종류의 응답 값포장은 Enum을 활용한다. 메서드 응답을 빨간줄로 바꿔 생성하자. . 만약, 제한되지 않았다면? class Rank로, 현재는 제한된 종류의 값 응답이므로 Enum으로 매핑해서 if를 대신하게 해보자. . . | 연속된 상수라면, Enum명_ 순서를 활용하면 된다. . 1,2,3,4,5등 -&gt; 등을 Enum으로 만들고 등_1,2,3,4,5; 로 선언해보자. | . package lotto; public enum Rank { RANK_1, RANK_2, RANK_3, RANK_4, RANK_5; } . | . 응답에 대한 분기로직을 어떻게 응답class/응답Enum으로 넘길까? . . 메서드 응답부에서 원하는 포장된 응답값인 Enum객체을 뽑아 응답해주는 return Enum.정펙매of (,)완성하기 . 결과적으로 정펙매인 Enum.from() or Enum.of( , , )로 Enum객체를 응답해야한다. . 원하는 Enum객체가 응답될 수 있도록 필요한 인자들을 생각해서 받아들인다. | 실제로 입력값이 될 것들을 가지고 있는 사용부인 메서드 응답부에서 부터 시작 | . | . 응답부에서 Enum.정팩메로 해당하는 포장응답값을 return해 줄 예정이다. . 필요한 input들이 뭐가 있는지 살펴본다. | 메서드호출의 결과값이 있다면, input이 명확하도록 따로 변수로 뽑아주자. | . . 정팩메로는 Enum이라는 포장된 응답값을 가져올 것이기 때문에 return과 같이 작성한다. | . . | 값 응답 로직을 -&gt; 포장응답값 정펙매로 잘라내서 처리하기 . 이제 값 응답로직을 그대로 잘라붙혀넣기 한다. . 이동후 | . . | 정팩메 내부로 옮긴 분기에 대해, 응답[값]들을 [Enum객체]로 수정해주기 -&gt; 없는 값(0, None)에 대해서도 OUT,NONE객체 만들어서 응답해주기 . 아직 바꾸기 전 응답로직 . if (matchCount == 6) { return 1; } if (matchCount == 5 &amp;&amp; matchBonus) { return 2; } if (matchCount == 5) { return 3; } if (matchCount == 4) { return 4; } if (matchCount == 3) { return 5; } return 0; . | 수정 + NONE객체 추가후 . package lotto; public enum Rank { RANK_1, RANK_2, RANK_3, RANK_4, RANK_5, OUT; public static Rank of(final int matchCount, final boolean matchBonus) { if (matchCount == 6) { return RANK_1; } if (matchCount == 5 &amp;&amp; matchBonus) { return RANK_2; } if (matchCount == 5) { return RANK_3; } if (matchCount == 4) { return RANK_4; } if (matchCount == 3) { return RANK_5; } return OUT; } } . public static Rank match(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { final int matchCount = userLotto.match(winningLotto); final boolean matchBonus = userLotto.contains(bonusNumber); return Rank.of(matchCount, matchBonus); } . | . 메서드 [포장된 응답] 테스트 작성하기 . 여러분기므로 1case에 대한 -&gt; 1예상값 마다 테매를 작성해야한다. . @Test void match_1() { //given, when final Rank rank = LottoService.match( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1, 2, 3, 4, 5, 6), new LottoNumber(7) ); //then assertThat(rank).isEqualTo(Rank.RANK_1); } . if분기를 enum 매핑으로 제거하기 . 정팩메 input으로 들어올 데이터들 中 1개를 골라 (매핑 예정인) Enum객체의 필드로 넣어준다. . 정펙매로 여러 데이터가 들어와 사용가 들어오지만 of( matchCount, matchBonus) . . 매핑에 사용될 쉬운 변수 1개만 선택하여, 정펙매 내부 values().stream.filter 분기에서 비교할 것이다. Enum객체가 필드로 가지고 있으면 되며, 그 필드 기준으로 매핑값도 차후 배정된다. | . | . 쉽게 Enum의 필드에 넣기 위해서는 일단 ENUM(1) 객체 옆에 빨간줄로 원시형 예제작성해준다. . . | 생성자를 생성해주면서 input과 똑같이 네이밍후 빨간줄 this.필드명 = 필드; 초기화를 이용해서 필드를 생성한다. . . . . | 나머지 객체도 데이터를 넣어준다. . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0); private final int matchCount; Rank(final int matchCount) { this.matchCount = matchCount; } public static Rank of(final int matchCount, final boolean matchBonus) { if (matchCount == 6) { return RANK_1; } . | Enum정팩메 내 [제한된종류의 모든 if분기]를 values().stream + filter with input vs 매핑field로 분기 없애기 . 특수한 경우, 정팩매에서 ENUM매핑값 뽑기도 전에, early return해준다. . 특수한 경우로서 2등과 3등을 먼저 필드는 안됬지만 사용해야하는 변수 matchBonus로 홀로 true인 2등을 early return한다. . public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } . | . Enum내에서 values()는 Enum객체배열을 응답하며 거기에 배열.stream자동완성 사용하여 EnumStream 만들어 객체전체를 돌리기 . . . . 제한된 종류의 if분기를 values().stream (for) + filter(it -&gt; input vs 매핑field 비교) 대체하기 . public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); . 기존 if분기들 이제 삭제 | . enum sense: 각 enum객체끝은 마지막도 콤마(,) 그 다음라인(;) + .findAny()후 .orElse( NONE객체 ) . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0), ; . return Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); . Bi(비.아이.) Predicate&lt; , &gt;로 input된 2개 값을 다 사용하는 1개의 람다식필드 &amp;&amp; filter속 예비 조건식(.test(a,b)로 실행)을 만들어 -&gt; [enum의 1 필드 매핑]에 사용되는 Type을 함수형인터페이스로 사용하여 -&gt; 정펙매 내부 들어오는 2개값 모두 사용하는 enum 만들기 . BiPredicate Type은 1개 함수를 가진 인터페이스 = 함수형 인터페이스 중 2개 인자를 받아 실행대기 중인 조건식을 제공해주고 -&gt; .test( a, b)를 통해 외부인자를 받아서 조건식을 실행한다. .test(a, b)에 정팩메로 들어온 input2개를 넣어주면 된다. | . | . 아직 BiPredicate 적용안한 기존 코드 (상금도 매핑 안된 상태) . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0), ; private final int matchCount; Rank(final int matchCount) { this.matchCount = matchCount; } public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } return Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); } } . Enum필드에 2인자 람다식인 BiPredicate를 넣어서 생성하기 . 이번엔 Enum()객체안에 input 중 1개 6,5,4.. 대신에 input 2필드 다 써서 1개 람다식을 만들어 예제로 넣어주자. 이왕이면 다중커서로 한번에 다 입력해주자. | . | 아쉽게도 BiPredicate는 직접 필드입력 -&gt; private final 필드 변수 생성 -&gt; 생산자 자동완성로 가야한다. (원래는 예제 -&gt; 생산자 -&gt; 빨간줄 this.필드 생성) . 원래 객체( 원시값 등 쉬운 Type)을 빨간줄 필드로 넣으면, 생성자에 파라미터 공짜 -&gt; this.로 필드 공짜 생성 | . BiPredicate 작성 . 받은 인자 2개는 if분기에 쓰였던 input값 2개다. -&gt; 원래 Enum의 매핑 쉬운 상수 응답값 6, 5, 4...와 비교해야한다. | . public enum Rank { RANK_1(((matchCount, matchBonus) -&gt; matchCount == 6)), RANK_2((matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; matchBonus), RANK_3((matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; !matchBonus), RANK_4((matchCount, matchBonus) -&gt; matchCount == 4), RANK_5((matchCount, matchBonus) -&gt; matchCount == 3), OUT((matchCount, matchBonus) -&gt; matchCount &lt; 3), ; . | 필드 직접 입력 private final . 제네릭 타입은 들어올 인자들의 Type(정팩메로 들어올 Type)을 Boxing한 타입 + 네이밍은 condition으로 실행될 조건식임을 인지시킴 | . private final BiPredicate&lt;Integer, Boolean&gt; condition; . . | 생성자 자동완성 . | values().stream + filter분기에서 .test( , )로 정펙매 인자를 받아 조건식 실행 . public static Rank of(final int matchCount, final boolean matchBonus) { return Arrays.stream(values()) .filter(it -&gt; it.condition.test(matchCount, matchBonus)) .findAny() .orElse(OUT); } . 응답값의 포장(리팩토링)이 다 끝났으면, 자체 도메인Test(Enum은 정펙매 테스트) . @Test void rank_1() { final Rank rank = Rank.of(6, false); assertThat(rank).isEqualTo(Rank.RANK_1); } @Test void rank_2() { final Rank rank = Rank.of(5, true); assertThat(rank).isEqualTo(Rank.RANK_2); } @ParameterizedTest @CsvSource({&quot;5,false,RANK_3&quot;, &quot;4, false, RANK_4&quot;, &quot;3, false, RANK_5&quot;}) void rank_3_5(final int matchCount, final boolean matchBonus, final Rank expected) { final Rank rank = Rank.of(matchCount, matchBonus); assertThat(rank).isEqualTo(expected); } . 리팩토링(가변변수 0에 조건만족시 갯수 누적) . 직전까지의합 0가변변수에 조건 만족시 add 1 -&gt; stream + filter + count . 변경 전: 0이라는 int 가변변수를 먼저 선언해놓고 -&gt; 돌면서 조건만족시 -&gt; 가변변수에 += 1;하는 행위 | . // 일급 Lotto public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { if (contains(lottoNumber)) { matchCount += 1; } } return matchCount; } . stream의 filter + count로 원하는 조건의 갯수를 누적된 상태로 바로 뽑을 수 있다. | . // 미리 가변 변수 int = 0;을 선언하지말고 조건만족시를 다 count()로 갯수만 반환받는다. // - long이 기본 타입이라.. 캐스팅 해야한다. public int match(final Lotto other) { // 우항, 파라미터를 찢는 놈이라고 했으니, other.value.stream()으로 찢었다. return (int) other.value.stream() .filter(it -&gt; contains(it)) .count(); } . stream없이 for+if 에서 if를 메서드분리 -&gt; 누적변수없이도 응답 가능=갯수니까 return 1 or 0; . 변경 전 . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { if (value.contains(lottoNumber)) { matchCount += 1; } } return matchCount; } . | . for문 내부 if는 메서드 추출로 통채로 빼기 -&gt; if가 바깥쪽 가변변수 조작한다면? return = 메서드추출()로 받아진다. . . 원래 if 내부에서 바깥의 가변변수를 건들였으니 if가 있던 자리 -&gt; 바깥 가변변수 = 메서드추출()로 return받도록 짜여졌다. . 메서드추출했는데 변수에 리턴받는다? -&gt; 내부에서 바깥의 가변변수를 건들였던 것을 뱉어준 것 | . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { matchCount = getMatchCount(matchCount, lottoNumber); } return matchCount; } private int getMatchCount(int matchCount, final LottoNumber lottoNumber) { if (value.contains(lottoNumber)) { matchCount += 1; } return matchCount; } . | . 메서드추출로 튀어나온 (내부에서 사용되던 바깥선언의) 가변변수는 무조건 가변 = 메서드()형태다 . 원래 if문 내부에서 가변변수++, 가변변수+=1를 해줬었는데… 추출된 것은 무조건 변수 = 메서드()형태인 이유는 . 추출된 메서드의 파라미터로 가변변수가 들어간다. . for (LottoNumber lottoNumber : other.value) { matchCount = getMatchCount(matchCount, lottoNumber); } . | 가변변수가 파라미터에서 선언되는 이름만 똑같은 지역변수가 되는데, 이름은 같아도 바깥 가변변수와는 전혀 다른 것이다. . . | . | . 갯수 증가의 가변++/가변+=1 은 메서드추출시 파라미터(=지역변수)로 안가도 return 1 or 0만 해주면 되므로 [추출메서드에서 파라미터 삭제] -&gt; 이후 가변 = 이 아닌 가변 += 으로 바꿔주면 된다. . 파라미터=지역변수를 없애고, 지역변수++자리를 return 1로 아니면 return 0;으로 대체하자. . private int getMatchCount(int matchCount, final LottoNumber lottoNumber) { if (value.contains(lottoNumber)) { matchCount++; } return matchCount; } . // 지역변수 지우고, 걸리면 갯수증가용 1 , 안걸리면 0 을 반환 private int getMatchCount(final LottoNumber lottoNumber) { if (value.contains(lottoNumber)) { //matchCount++; return 1; } return 0; } . | 메서드 추출 기능 자체의 문제가 가변+= 메서드리턴()이 안되서 -&gt; 가변을 파라미터로 받은 뒤, 지역변수++, 지역변수+= 후 return되는 문제였다. . 가변 = 메서드 추출()부분을 가변 += 메서드 추출()-1or0리턴;으로 바꿔주자. | . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { //matchCount = getMatchCount(matchCount, lottoNumber); //matchCount = getMatchCount(lottoNumber); matchCount += getMatchCount(lottoNumber); } return matchCount; } . | .",
            "url": "blog.chojaeseong.com/java/%EB%A1%9C%EB%98%90/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/06/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-2%EB%8B%A8%EA%B3%84-%EB%A1%9C%EB%98%90-%ED%94%BC%EB%93%9C%EB%B0%B1.html",
            "relUrl": "/java/%EB%A1%9C%EB%98%90/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/06/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-2%EB%8B%A8%EA%B3%84-%EB%A1%9C%EB%98%90-%ED%94%BC%EB%93%9C%EB%B0%B1.html",
            "date": " • Mar 6, 2022"
        }
        
    
  
    
        ,"post44": {
            "title": "강의) 네오 2단계 List + 제네릭",
            "content": "리스트 . 테스트부터 만든다. . test&gt;java에서 class를 앞에 패키지.를 붙혀 만들면 패키지 + class를 동시에 만들 수 있다. list.ListTest | . | . public class ListTest { @Test void name() { new ArrayList&lt;&gt;(); } } . | ArrayList vs LinkedList . ArrayList . arrayList는 내부에 단순 배열을 가지고 있다. 배열을 사용하기 좋게 감싼 일급컬렉션 . transient Object[] elementData; // non-private to simplify nested class access . 배열을 그냥 쓰면, 배열크기가 고정되어있지만, 일급으로 만들어서 크기를 유동적으로 증가 감소, 복사해서 대체해주기 등을 한다. | . private Object[] grow(int minCapacity) { return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); } . | LinkedList . 배열이 아니라 시작과 끝노드를 가지고 있으며 연결되어있다. . transient Node&lt;E&gt; first; /** * Pointer to last node. */ transient Node&lt;E&gt; last; . | 연결되어있으므로 배열 공간에 미리할당할 필요없이 하나씩 node를 추가하면 된다. . | 저장 -&gt; 접근 방식 . . 배열의 arrayList: 인덱스로 한번에 접근가능하다. 인덱스로 한번에 중간원소 접근가능 -&gt; 빠르다. 메모리 공간을 미리 할당해야하므로, 메모리 딸리는 상황에서는 데이터 추가시 느릴 수 있다. | . | 중간원소 삭제시 인덱스를 한칸식 다 땡겨줘야하므로 시간이 오래 걸린다. | 중복처리 방식 리스트 안에 리스트를 넣는방식 이용 | 크기가 커지면 리스트 안에 트리를 넣는 방식 이용 | 사이즈에 맞게 다르게 사용되어서.. api를 사용하는게 좋다. | . | . | 노드의 LinkedList: 통해서 가야하는 줄줄이 노드. 타고가야하는 줄줄이 노드는 중간원소 접근 -&gt; 느리다. | 중간원소 삭제시 편하게 삭제 | . | 하드디스크의 물리적으로 순차적인 접근 . 옛날 하드디스크 = 물리적으로 순차적으로 메모리 배열 -&gt; arraylist와 마찬가지 방식 -&gt; 유리했었음 요즘은 linkedList가 메모리 파편화된 node들의 집합이어도 별 상관없어졌다. | . | . 제네릭 . list처럼 다양한type을 관리하는 경우, 특정type으로 고정시킬 수 있다. 제네릭이 멀까? 컴파일 타임(핵심)에 처리가 되서, 그 때 버그를 잡아낼 수 있다. | 클래스를 변수로 만들기? | . | . | . 제네릭은 컴파일 타임에 처리된다. . 1을 arrayList에 넣고 출력하는 코드를 작성하고 실행시켜 컴파일 . @Test void name() { final ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); integers.add(1); System.out.println(integers); } . | out(build)부터 시작되는 컴파일코드로 가서 shift2번 &gt; show bytecode를 쳐서 내부적으로 실행된 코드를 확인해보자. . . // access flags 0x0 name()V @Lorg/junit/jupiter/api/Test;() L0 LINENUMBER 9 L0 NEW java/util/ArrayList DUP // ArrayList 생성할 때, 제네릭정보는 없다. INVOKESPECIAL java/util/ArrayList.&lt;init&gt; ()V ASTORE 1 L1 LINENUMBER 10 L1 ALOAD 1 ICONST_1 INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer; // integer가 들어갈 때, Object로 들어간다. -&gt; 컴파일 될 때 알아서 Type으로 떨어진다. 컴파일 타임까지만 Type실수하지않게 도와주는 것. 런타임 때는 안도와준다. INVOKEVIRTUAL java/util/ArrayList.add (Ljava/lang/Object;)Z POP L2 LINENUMBER 12 L2 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 1 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)V L3 LINENUMBER 13 L3 RETURN L4 LOCALVARIABLE this Lgeneric/GenericTest; L0 L4 0 LOCALVARIABLE integers Ljava/util/ArrayList; L1 L4 1 // signature Ljava/util/ArrayList&lt;Ljava/lang/Integer;&gt;; // declaration: integers extends java.util.ArrayList&lt;java.lang.Integer&gt; MAXSTACK = 2 MAXLOCALS = 2 . | 결과적으로 외부에서 타입을 지정할 수 있게하는 기술이다. . 생성시에는 타입없이 내부에서 생성 | 외부인 변수에 할당시 타입지정 | . ArrayList&lt;Integer&gt; integers = new ArrayList(); . 외부에서 타입을 맘대로(나 인티져 넣을거야, 나 스트링 넣을 거야~)지정해서 편하게 사용한다. | . final ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); final ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;(); . | 장점 . (사용시 특정타입으로 제한하여) 타입안정성을 얻을 수 있다. | 캐스팅해서 사용하던 것을 자동으로 처리되도록 됨. | my) [여러 타입가능한 자료구조]사용시 get하면 object로 내려와 (1) 타입확인 (2) 다운캐스팅 해서 사용했어야 했는데 사라지게 된다. . jdk 5부터 추가되었다. | 다른type, 다른형을 막아주기 때문에 특별한 이유가 없으면 여러타입가능 자료구조는 무조건 generic을 사용해라 | . @Test void name() { final List integersNoGeneric = new ArrayList(); integersNoGeneric.add(1); // 여러타입 가능한 것에 대해 제네릭으로 타입을 안정해준다면, // 1. &lt;받아올 때&gt; Object형으로 내려온다. -&gt; &lt;받아 사용하는 쪽에서&gt; 다운캐스팅 해야 쓸 수 있다. final Object o = integersNoGeneric.get(0); // -&gt; [넣은 것과 동일한 형으로 직접 다운 캐스팅]해야줘야 다시 해당 type으로 사용할 수 있다. final Integer integer = (Integer) integersNoGeneric.get(0); // 2. 다른 Type을 넣어버릴 수 도 있어서 type불안정하다. integersNoGeneric.add(&quot;1&quot;); // -&gt; &lt;사용하는 쪽, 타입까지 직접확인해줘야&gt;해서 -&gt; 사용할 때 [넣은 것과 동일한지 type확인도 미리] 다운캐스팅전에 해줬어야했다. final Object o1 = integersNoGeneric.get(0); if (o1 instanceof Integer) { final Integer o11 = (Integer) o1; } } . Type과 제네릭은 영역 좁히는게 반대다? . ArrayList는 구현체 List가 인터페이스(추상체) . type을 받아줄 변수는 인터페이스(추상체)로 받아야, 메서드들이 분기를 대신하는 구상체(전략객체)를 받을 수 있는 추상체(인터페이스) 파라미터로 정의되어있음을 인지해야한다. | . my) Type의 경우) 정의하는 변수와 파라미터는 전체 분기들을 내포되도록 추상체로 받고, 사용하는 할당과 메소드호출 인자에는 분기가 결정된 구상체를 넣어주자. . 파라미터를 분기결정된 구상체로 받는다면? . 다른 구상체들을 못받는다. | . void 파라미터를_분기결정된_구상체로_넣는경우(ArrayList&lt;Integer&gt; value) { System.out.println(value); } . // 1. default로 변수추출시 ArrayList 풀로 형이 정해지는데 final ArrayList&lt;Integer&gt; integersArrayList = new ArrayList&lt;&gt;(); // 2. vs 정의하는 변수와 파라미터는 전체분기들을 내포하는 추상체로 받아라 -&gt; 할당과 메소드호출인자에는 분기결정한 구상체를 넣어주자. final List&lt;Integer&gt; integersList = new ArrayList&lt;&gt;(); //3. 정의하는 메소드파라미터를 분기결정된 구상체 -&gt; 해당 구상체밖에 못들어온다. 파라미터를_분기결정된_구상체로_넣는경우(integersArrayList); // 에러안남. 파라미터를_분기결정된_구상체로_넣는경우(integersList); // 에러남 (구상체 정의 -&gt; 추상체를 넣음) } . | 파라미터를 분기내포하는 추상체(인터페이스)로 받는다면? . 파라미터를 추상체로 받는다? -&gt; 분기들을 내포하여 구상체들을 다 받을 수 있는 상황 | 인터페이스로 분리해서 내가 어떤이점을 얻고 있지? 잘활용하고 있나 고민할 것 전략패턴에서는, 파라미터를 전략인터페이스로 정의후 | 호출시점에 전략객체.전략메서드() 호출시켜서 실시간성 부여 | 사용하는 메인에서 메서드호출시 new 구상체를 던져 분기를 정해줌 | . | . void 파라미터를_분기내포하는_추상체로_넣는경우(List&lt;Integer&gt; value) { System.out.println(value); } . 파라미터를_분기내포하는_추상체로_넣는경우(integersArrayList); // 에러안남. 파라미터를_분기내포하는_추상체로_넣는경우(integersList); // 이것도 에러 안남. //메소드 호출시, 여러분기들의 구상체를 다 받을 수 있다. . | 선언시, 변수 생략된T &lt;&gt; 형 + 파라미터, 클래스 &lt;T&gt;형의 제네릭에서의 추상체 &lt;—&gt; 호출시구상체 &lt;특정형&gt; 을 지정해서 사용한다. . my) intellij의 생성자 파라미터를 T로 지정하여 Generic을 생성한 선T -&gt; 호구지 (선언시 T형 -&gt; 호출시 구상형을 지정해서 사용) . 호출부에서 T형을 집어넣을 수 없으니 -&gt; 일단 아무형이나 넣어서 생성자에 넣고 내부에서 T로 바꿔서 정의한다. | T형으로 파라미터를 받아도, T는 빨간줄이다. 빨간줄 [Create type T paramter] 를 통해 class 전체를 선택해서 클래스자체도 Class&lt;T&gt;형으로 지정해준다. 필드가 아닌, 파라미터 속 T에 대해서만 해당 T형 파라미터 자동생성이 활성화된다. | . | . 제네릭 추상체 &lt;T&gt;형으로 box클래스 정의하기 . 외부에서 생성자를 통해 빨간줄로 생성할 땐, 아무형이나 집어넣고 -&gt; 내부에서 T형으로 정의후 -&gt; Create T type parameter를 통해 class에도 &lt;T&gt;로 선언되도록 해야한다. (선T호구지) | . 제네릭 추상체 &lt;T&gt;형 클래스 만들기 . class Box&lt;T&gt; { private final T value; // 1. T형 변수을 감싸는 클래스 box를 만든다. T형이란 미정이므로 -&gt; 2. 클래스 정의시 &lt;T&gt; 제네릭을 달아줘야한다. //3. T형변수를 변수를 생성자를 통해 초기화하고 public Box(final T value) { this.value = value; } //4. T형 변수를 getter로 응답한다. public T getValue() { return value; } } . | my) 제네릭은 Type과 반대로, 변수 및 생성자에서는 제네릭 구상체 인 &lt;특정형&gt; 변수에 , 할당(사용)시 생략된T형&lt;&gt;을 넣어줘, 변수와 생성자에서 좁힌다. . 제네릭 추상체 생략된T형 &lt;&gt;변수, 제네릭 구상체 &lt;특정형&gt; 변수 각각 생성자 대입해보기 . 변수가 제네릭 구상체이라면, 할당도 해당하는 형밖에 못넣는다. | . @Test void name2() { final Box&lt;String&gt; stringBox = new Box&lt;&gt;(&quot;&quot;); //final Box&lt;String&gt; stringBox = new Box&lt;&gt;(1); // 제네릭은 변수와 생성자에서 좁힌다. 할당시 제네릭추상체-생략된T&lt;&gt;형으로 넓게준다. } . | 할당(사용)시 생략된T형&lt;&gt;을 넣지만, 좁히는 변수와생성자 자리에 들어간&lt;특정형&gt; 변수가 추상체인 인터페이스라면, 넓히는 할당 자리에 &lt;특정형 인터페이스의 구상체형들&gt; 들도 할당가능하다 . 넓은 할당자리에 특정형을 집어넣으면 해당 클래스만 사용가능해진다. . 무엇이든 다 들어갈 수 있는 제네릭 추상체 Box&lt;T&gt;에 대해서 제네릭 구상체 Box&lt;특정형&gt;을 지정해줬지만, 그 특정형이 구상체들을 가진다면 우변에서 구상체들의 할당이 가능하다 . // 8.제네릭에서는 생략된T형인 Box&lt;&gt;에 비해 Box&lt;특정형&gt;은 제네릭구상체다. -&gt; 할당이 &lt;특정형&gt;의 자체 및 그 구상체들만 가능해진다. // -&gt; Animal이 제네릭 특정형으로 들어가 그 제네릭 구상체가 되었더라도, 그것의 구상체들인 Dog, Cat은 할당될 수 있다. new Box&lt;Animal&gt;(); final Box&lt;Animal&gt; animalBox = new Box&lt;Animal&gt;(); . | 좌항 좁히는 변수가 &lt;특정형&gt;의 제네릭구상체라면 -&gt; 마찬가지 좁히는 생성자에 들어갈 변수도 특정형으로 처리되어야함. 할당(사용, 특정분기)은 생략된T형(제네릭추상체)의 기본생성자 호출 불가 . 변수만 좁히고, 할당은 안좁혔을 때 -&gt; 기본 생성자에 인자가 들어간다면 넓은 할당형에 쓰던 것이 생성자로 들어갈 예정이니 에러가난다 -&gt; 인자를 안받는 생성자를 만들어줘서 생략된T형의 인자가 못들어가게 막아주자. . List(추상) = ArrayList(구상)는 내가 특정분기를 우항에서 할당하여 사용하는 것이다. . 하지만 현 상황에서는 제네릭 구상체인 Box&lt;Animal&gt; (구상) = new Box &lt;&gt; () (추상:생략된T형)을 넣는 것은 정반대로 주는 것 | **좌변 변수정의에서 구상체 특정형으로 제한되어있다면, 뭔짓을 한들 생략된 T형 = 제네릭추상체 사용시, 생성자에 건네주는 것으로 class내부 T형 변수를 초기화해줄 수 없기 때문이다. ** | . // 9. 좁히는 변수만 좁히고, 할당은 안좁혔을 때 -&gt; 기본 생성자에 인자가 들어간다면 넓은 할당형에 쓰던 것이 생성자로 들어갈 예정이니 에러가난다 final Box&lt;Animal&gt; animalBox = new Box&lt;&gt;(); // 생성자쪽에서 에러 // -&gt; 인자를 안받는 생성자를 만들어줘서 생략된T형의 인자가 못들어가게 막아주자. // -&gt; default생성자(파라미터T가 안되니, 파라미터를 아예 안받고, 내부 T형은 null로 초기화시켜주는)를 추가해주자. public Box() { this(null); } . final Box&lt;Animal&gt; animalBox = new Box&lt;&gt;(); . 마치 제네릭 구상체 변수에 제네릭추상체 할당이 가능해 보이지만, 생성자가 파라미터를 외부에서 아예 안받고 내부적으로 자체 처리해서 제네릭추상체를 감당하고 있기 때문에 그렇게 보이기만 할 뿐이다. 특수처리되어서 에러는 사라졌으나 사용은 불가하다.?! | . | . | . 할당시 제네릭구상체&lt;특정형&gt;을 지정해주면, 내부의 모든 것이 T-&gt;특정형으로 바뀐다. 할당은 변수보다 넓어야하니 변수는 더 좁은 특정형or특정형의 구상체들로 받아줘야할 것이다. . // 11. 이미 좁힌 제네릭변수가 있을 때, 할당은 생략된T형 &lt;&gt;으로 넓게 줄 수 있다. (넓은 형으로 들어갈 생성자만 잘 처리되면) final Box&lt;Animal&gt; animalBox2 = new Box&lt;&gt;(); // 12. 할당에서 특정형을 제네릭구상체로 지정해주면, 내부의 모든 로직이 해당 classType으로 바껴서 // 12-1. 동일형으로 좁힌 변수에는 잘들어간다. final Box&lt;Animal&gt; animalBox3 = new Box&lt;Animal&gt;(); // 12-2. 만약 넓은 할당쪽이 더 좁아졌다면? (좁힌 변수보다 더 좁은) Type과 다르게 안들어가진다. -&gt; 변수와 생성자가 더 좁아야한다. final Box&lt;Animal&gt; animalBox4 = new Box&lt;Dog&gt;(); // 에러 . 좁았던, 제네릭 변수정의 - 생성자 인자의 관계에선, Type처럼 변수-추상체라면, 생성자인자-구상체의 관계를 가진다. . //13. 할당시 생략된T형&lt;&gt; -&gt; 변수-생성자 인자 관계에서는, Type처럼 변수 추상체 - 생성자=메서드호출 구상체가 가능하다. //13-1. 할당시 생략된 T&lt;&gt;으로 내부가 T로 구성된 데이터에, 좁은 생성자 인자를 넣어줄 때, 추상체에 구상체가 들어가므로 괜춘하다. final Box&lt;Animal&gt; animalBox4 = new Box&lt;&gt;(new Dog()); //13-2. 할당이 넓은 상태라면, 변수-추상체 생성자-구상체로서 동일한 것도 생성자로 넣을 수 있다. final Box&lt;Dog&gt; animalBox5 = new Box&lt;&gt;(new Dog()); . 실사용 와일드카드 . 실사용은 좁은 변수제네릭에 와일드카드를 지정해주고 넓은 할당은 생략된T형이 기본인 상태에서, 넣어줄 생성자에 변수의 좁은제네릭에 들어있는 구상체or상속or와일드카드 범위의 객체를 넣어 사용해줘야한다. . //14. 넓은 제네릭할당에 대해 new Box&lt;&gt;(); //14-1. 좁은 변수의 제네릭에 와일드카드(upper bound) 적용주자. final Box&lt;? extends Animal&gt; extendsAnimalBox = new Box&lt;&gt;(); //14-1-1. 실사용은 변수에 대해 생성자에 넣어줄 놈은 더 구상체로 넣어주면 된다. final Box&lt;? extends Animal&gt; extendsAnimalBox2 = new Box&lt;&gt;(new Animal(){}); final Box&lt;? extends Animal&gt; extendsAnimalBox3 = new Box&lt;&gt;(new Dog()); . 상속자 자리에 와일드카드변수(제네릭추상체) 구현체를 상속한 것들도 넣어줄 수 있다. . //15. [Animal의 구현체인 Dog]를 상속한 것들도 제네릭 상속자 자리에 넣어줄 수 있다. // -&gt; 술을 먹어서 개가 된 돌범(상속) 정의 class Dolbum extends Dog { } . //15-2. 제네릭 변수-상속자의 관계는 구상체 자식들 하위단계를 다 넣어줄 수 있다. final Box&lt;? extends Animal&gt; extendsAnimalBox4 = new Box&lt;&gt;(new Dolbum()); . 넓은 할당쪽 제네릭은 사실, 생성자에 들어갈 객체의 범위가 default다. . 할당쪽 제네릭은 와일드카드 사용불가 | 특정형 사용시, 생성자도 그걸로 | 생성자를 넣어줄 시, 그거랑 동일한 것이 default | . 와일드카드에 대해, 상속자들어갈놈 -&gt; 할당제네릭의 default가 안정해줄 경우, 어떤 Type으로 잡힐까? . 제일 defaultType은 제일 상단이 나온다. Type입장에서는 열려있는 최고 부모를 변수type으로 받아줘야한다. | . | . //16. 와일드카드에 대해, 상속자들어갈놈 -&gt; 할당제네릭의 default가 안정해줄 경우, 어떤 Type으로 잡힐까? final Box&lt;? extends Animal&gt; extendsAnimalBox5 = new Box&lt;&gt;(); //16-1. upperbound를 가진 extends 와일드카드의 경우, 제일 상단인 Animal이 나오고 final Animal value = extendsAnimalBox5.getValue(); final Box&lt;? super Animal&gt; superAnimalBox5 = new Box&lt;&gt;(); //16-2. lowerbound를 가진 super의 경우, 제일 하단인 Animal이 나올 것 같지만, // -&gt; 역시 제일 상단인 Object가 나온다. // --&gt; 와일드카드의 default는 제일 위아래쪽 상관없이 상단 bound ~ Object까지 나오게 된다. final Object value2 = superAnimalBox5.getValue(); . 제네릭의 클변 메파 정의/ 좁 변수(와) + 메파 제한자(와X) -&gt; 생성자/ 넓 할당 . Type은 정의하는 변수, 메서드 파라미터에는 추상체를 / 사용하는 할당, 메소드호출에는 구상체를 넣어서 분기처리를 밖으로 제거해줄 수 있다. | . 제네릭은 정의(class 속 변수, method 파라미터)는 T(E)로 / 변수(와일드카드)와 method 파라미터는 &lt;T&gt; (&lt;E&gt;) 좁게 + 생성자(좁힌 것의 구현체&amp;자식들) + / 할당은 넓게(default로 두면 알아서 생성자에 사용되는 구현체에 맞게) . 메소드 파라미터는 제네릭E로 정의해주지만 (클래스 변수 타입 T형처럼) /히는 작업이 접근제한자와 응답사이에 좁은 꺽쇠&lt;E&gt;로 정의 (좁은 변수Type처럼) . //1. T는 클래스의 변수 정의하느라 썼으니 // -&gt; 파라미터는 E로 받지만, 제한자 쪽에다가 꺽쇠붙인 &lt;E&gt;로 좁혀준다. // -&gt; &lt;E&gt;는 별다르게 좁혀주지 않는 default 어느타입이든 가능임. public &lt;E&gt; void some(E e) { } . //2. 제네릭은 변수에 좁게 정의하고, 그 와일드카드에 해당 범위의 객체를 생성자에 넣어주니, 변수까지 정의해서 객체를 생성한다. new Box&lt;&gt;(); final Box&lt;? super Animal&gt; superAnimalBox6 = new Box&lt;&gt;(); final Object value1 = superAnimalBox.getValue(); // 와일드카드에 구상체 객체를 않넣어주면, T형의 인스턴스변수를 Object로 잡아 반환한다. final Box&lt;?&gt; value6 = superAnimalBox; //객체는 ? 와일드카드에 그냥 넣어줄 수 있다? value6.some(&quot;&quot;); // E는 기본적으로 Object부터 시작하여 -&gt; 메서드호출시 어떤Type이든지 호출 가능해진다. value6.some(1); // E는 기본적으로 Object부터 다 받을 수 있다. . 좁은 변수처럼, 메소드 파라미터는 제한자 쪽에서 좁힌 Type &lt;E&gt;에 와일드카드 or 직접 꺽쇠에 제한을 걸수 있다. . 잘보면 응답Type void보다 앞쪽에서, 파라미터에 대한 와일드카드 제한을 거는 것이다. | . //3. 메서드의 파라미터의 좁힘 제한은 응답Type앞쪽에서 꺽쇠&lt;E&gt;제네릭으로 걸 수 있다. public &lt;E extends String&gt; void some(E e) { } //4. value6.some(&quot;&quot;); // string 이하로 제한건 E에는.. string 및 string상속한 것만 들어간다. value6.some(1); // 에러 . 참고) E는 와일드카드 범위내에서 사용된 Type이 추론끝나면 컴파일 타임에서 해당Type으로 대체되어 사라진다. . 참고) 정의를 해주는 class옆 꺽쇠 + method파라미터용 앞쪽 꺽쇠에서는 와일드카드 사용이 안된다. 변수 제네릭에서만 와일드카드 가능 . // 와일드카드 사용 좁힘시 에러 public &lt;? extends String&gt; void some(E e) { } // 와일드카드 사용시 에러 class Box2&lt;? extends Animal&gt; { } . 추가 메서드 파라미터 E를 좁힐 땐, 와일드카드가 아닌 꺾쇠&lt;E extends &gt;로 좁히며, super불가 + 와이드카드 불가다.. . 메서드에서 class와 동일한 타입추론 변수를 사용해도 된다. but… . public &lt;T&gt; void some(T t) { } . 메서드 파라미터의 변수는 지역변수라 … class쪽과 다르다. . //2. class내부에서 동일한 타입추론 변수T를 사용한 메서드는.. 파라미터로 T가 추론된 Dog형만 사용가능할까? // -&gt; class정의시에서는 T로 똑같은게 사용된 것 같지만, 메서드 파라미터의 변수 -&gt; 지역변수 -&gt; class 제네릭 타입변수 T랑은 별개다. // -&gt; 타입추론한 Dog와 별개로, 제한안걸린 T로서 모든 타입이 다들어간다. dogBox.some(new Object()); dogBox.some(1); dogBox.some(&quot;1&quot;); . E로 바꿔도 똑같이 지역변수로 적용되므로… 개별적 처리가 된다. | 되도록이면 이름 중복 안되게 하는게 좋다. | . P-E C-S(제네릭와일드카드 사용처) . 생성관련된 메소드의 파라미터에 대해서는 extends 상속한 것들만 들어올 수 있게 ArrayList의 생성자 파라미터 정의시 | ArrayList의 add메서드들의 파라미터 정의시 | . | 소비하는 곳에서는 super를 써서 제네릭을 정의해라 | . ArrayList를 타고 들어가서 ? extends가 어디서 사용되는지 검색 해보자. . 생성자 파라미터에서 E의 상속한 자식들(extends)만 들어오도록 제한을 걸어준다. . . | add의 파라미터할때도 ? extends를 사용한다. . . | . ? super는 소비되는 곳에서 사용된다. . super는 어떤 값이든 들어와도 되며, 소비되는 곳에 사용된다. . 소비만 되므로, 실제 어떤 타입인지 중요하지 않다. | . . | action은 람다 학습시 필요하다. . 람다로 넘겨줄 때, Consumer, Predicate 사용시 많이 이용된다. | . public void forEachRemaining(Consumer&lt;? super E&gt; action) { . | .",
            "url": "blog.chojaeseong.com/java/list/%EC%A0%9C%EB%84%A4%EB%A6%AD/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/05/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-2%EB%8B%A8%EA%B3%84-list%EC%99%80-%EC%A0%9C%EB%84%A4%EB%A6%AD.html",
            "relUrl": "/java/list/%EC%A0%9C%EB%84%A4%EB%A6%AD/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/05/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-2%EB%8B%A8%EA%B3%84-list%EC%99%80-%EC%A0%9C%EB%84%A4%EB%A6%AD.html",
            "date": " • Mar 5, 2022"
        }
        
    
  
    
        ,"post45": {
            "title": "제이) 중간피드백 Service와 Controller",
            "content": "Service . 일반 코드로 작성하는 안티 패턴 싱글톤이 아닌 스프링에서는 전용 싱글톤으로 유지되어야한다. | 상태(인스턴스 변수)를 가지면 안된다. 스프링의 service는 유저별 객체생성하면 감당이 안되므로 싱글톤으로 관리 되는데, 수많은 유저가 -&gt; 1개 싱글톤의 상태를 오염시킬 것이 뻔하기 때문이다. | controller -&gt; 재료들을 service 메소드 파라미터로 받아서 지역 변수로 처리되어야한다. | . | 원래 service를 사용한다면? Controller -&gt; inputDto -&gt; 도메인을 return하는 toDomain -&gt; service는 domain을 받는다. 상태로 유지는 X -&gt; 레포지토리 dto를 service에 넘기는 것을 지양해야한다 dto -&gt; toDomain -&gt; service controller는 클라이언트 레이어쪽 &lt;—&gt; service는 도메인이 포함된 레이어 쪽 | . | 레포지토리는 지엽적인 구상체들이 다 올 수 있는 Interface로 쌓여있다. | 도메인 생성에 필요한 데이터를 가져다 주는 것이 레포지토리 인터페이스 | 도메인은 레포지토리에게 질의만(findByName, findById) | . | . | input -&gt; 도메인으로 받은 controller에서 service.흐름로직( 도메인1, 도메인2)로 service로 흐름을 가져가되, input/output 흐름이 잘 잡히도록 짜면 된다. . | 검증이 controller에 있어도 되긴 되지만, 최대한 controller에서의 로직은 걷어내서 Factory or 도메인 로직에 넣어준다. 도메인을 풍부하게 해주자 . | 서비스에서 전략객체 바로 생성사용 가능? spring -&gt; bean에서 언제든지 사용가능하게 관리해줄 것이므로 **주입없이 바로 사용해도 ** | . | Controller와 의존성 . 의존성 개념에 따르면 중요하지 않은 = 잘 변하는= view와 맞닿은 controller가 중요한 도메인을 생성-&gt;사용해도 된다. . 중요한 것 의존=생성/(인자로)사용/리턴 (X)&gt; 중요하지 않은 것(쉽게 변하는것) (X) - domain내부에서 dto를 return하는 toDto() 하면 안된다. - domain내부에서 view(String)과 관련된 메소드를 작성하면 안된다. 중요하지 않은 것 의존=생성/(인자로)사용/리턴(O)&gt; 중요한 것 - controller에서 도메인을 (인자로)생성후 사용해도 된다. - dto에서 도메인을 from인자로 사용해도 된다. - dto에서 도메인을 return하는 toDomain()해도 된다. . | controller에서 도메인을 생성/인자로사용해도 되며 -&gt; service에는 도메인or값으로 넘겨준다. . | Service to Controller . Controller는 중요하지 않은 것으로서 중요한 도메인을 받아 써도 된다. 프로젝트가 커지면 Dto로 반환해준다. jpa를 쓰게 되면, 영속성 관리 때문에, 도메인을 view단으로 보내면 안된다. | . | view에서는 도메인에 있는 정보를 짤라 일부만 써야하는데, 필드를 날릴 순 없으니 민감/불필요한 필드가 짤려진 dto로 보낸다. | 도메인의 정보가 다쓰인다면 도메인객체를 그대로 넘겨도 된다. view에 map을 넘겨줘도 된다. 알아서 변환되서 내려간다. | map을 각 key필드 + value필드로 쪼갠 뒤 -&gt; dto클래스를 만들어서 -&gt; 객체dto를 넘겨도 된다. | . | . | Method시 들어갈 때 필요한 것들 -&gt; 뭐가 나오는지 명확하게 . 나중에는 returnType -&gt; 메서드명 -&gt; 파라미터의 시그니쳐만 보고 메서드를 갖다쓰기 때문에, 잘 정의되어 있어야한다. . 안 좋은 예 -&gt; 잘못 메서드 추출한 예 . lottoService.calculateResult(inputView.getBonusNumber()); . 보너스를 넣으면 -&gt; 당첨 결과가 나온다? -&gt; (X) 결과는 산 로또 + 당첨번호 + 보너스가 들어가서 -&gt; 당첨결과가 나와야한다. | . | . final Money totalMoney = getMoney(); final List&lt;Lotto&gt; issuedManualLotto = buyManualLotto(totalMoney); final Result result = issueLotto(totalMoney, issuedManualLotto); . | . xxxxFactory . **xxxxFactory 는 판매원이자 xxxxMachine** Lotto를 용지로만 본다면, 복잡한 생성과정은 판매원/Machine인 Factory에게 | . | 생성로직이 복잡하고 중요하기 때문에 클래스로 분리한 것 . 간단하면 따로 Factory로 분리할 필요가 없다. | . . | .",
            "url": "blog.chojaeseong.com/java/%ED%94%BC%EB%93%9C%EB%B0%B1/mvc/dto/service/controller/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/04/%ED%94%BC%EB%93%9C%EB%B0%B1_2-1(%EB%A1%9C%EB%98%90-%EC%A4%91%EA%B0%84)_%EC%A0%9C%EC%9D%B4_service%EC%99%80-controller.html",
            "relUrl": "/java/%ED%94%BC%EB%93%9C%EB%B0%B1/mvc/dto/service/controller/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/04/%ED%94%BC%EB%93%9C%EB%B0%B1_2-1(%EB%A1%9C%EB%98%90-%EC%A4%91%EA%B0%84)_%EC%A0%9C%EC%9D%B4_service%EC%99%80-controller.html",
            "date": " • Mar 4, 2022"
        }
        
    
  
    
        ,"post46": {
            "title": "TDD 4 자경(controller~view~검증)",
            "content": "ControllerTest for 컨트롤러와 service 형태 결정 . (test)Controller는 InputView를 파라미터로 받는다. . Controller -&gt; ControllerTest에서 컨트롤러 생성 | . controller = new Controller(new InputView()); . (prod)Controller 생성자 내부 new Service( inputXX ) 초기화 . 01 모든 입력을 한번에 다 -&gt; new Service( InputView.getInputDto() ) . 개별 try/catch는 안될 것이다. 처음부터 재입력받는 로직이 필요하다면, 여기를 함수화하고 재귀 걸어주면 될듯 | . | . public Controller(final InputView inputView) { //1-1. 서비스 생성시 inputView에서 한꺼번에 inputDto로 받는 경우 racingService = new RacingService(inputView.getInputDto()); . 01-1 inputDto.of( 개별getInput() , 개별getInput()) 형태로 return . 개별input에서는 출력문 | 기본 scanner input받아서, 공통 NullOrEmpty + 숫자면포맷 | split(,-1)+trim or parseInt의 정제된 형으로 변환 | 원시값 return | | . public class InputView { private static Scanner SCANNER = new Scanner(System.in); //1-3. getINputDto내부에서 사용될 개별 getXXX는 getInput()스캐너에 의존한다. private String getInput() { return SCANNER.nextLine(); } //1-2. 모든 input들을 InputDto.of에 넣어서 InputDto로 반환해주는 작업. // -&gt; dto는 일단 of(모든 속성들을 원시값으로) 받아서 -&gt; new dto( 원시값, 들로 생성)해야한다. public InputDto getInputDto() { return InputDto.of(getNames(), getRound()); } //1-4. 개별 getInput들은 출력 + 공통input검증(nullOrEmpty/format)이 생성된다. // 개별 getInput들은 4단계가 있다고 했다 (1)출력 (2) nullOrEmypy 검증 (3) format검증후convert or split+trim 변환 (4) return public List&lt;String&gt; getNames() { System.out.println(&quot;이름을 입력해주세요&quot;); final String input = getInput(); Validators.checkNullOrEmpty(input); return Arrays.stream(input.split(&quot;,&quot;, -1)) .map(String::trim) .collect(Collectors.toList()); } public int getRound() { System.out.println(&quot;몇 회 진행하겠습니까?&quot;); final String input = getInput(); Validators.checkNullOrEmpty(input); Validators.checkValidFormat(input); return Integer.parseInt(input); } } . 01-2 InputDto는 of 정펙매 -&gt; 생성자 -&gt; 원시값필드 -&gt; getter순으로 정의 . public class InputDto { private final List&lt;String&gt; names; private final int round; public InputDto(final List&lt;String&gt; names, final int round) { this.names = names; this.round = round; } //1-5. of에서 개별input다 받았으면, 그걸로 new생성자 -&gt; 필드 -&gt; getter까지 다 만든다. public static InputDto of(final List&lt;String&gt; names, final int round) { return new InputDto(names, round); } public List&lt;String&gt; getNames() { return names; } public int getRound() { return round; } } . 02 순차적이라면 new Service( 첫input ) -&gt; 메서드파라미터 ( 담input ) . setter금지령으로 인해 -&gt; 메인로직에 필요한 데이터는 생성자에서 객체 생성시 받아 -&gt; 인변에 넣어줘야한다. Controller는 service를 관리하고 있으며, 생성시service 초기화해줘야한다. 그 service 초기화시 받을 input -&gt; 좀있다가 받을 input이 따로 있는 경우 | . | . | . 02-1 첫 입력만 일단 생성자에서 개별input()으로 받는다. . public Controller(final InputView inputView) { // 첫 입력만 일단 생성자에서 개별input()으로 받는다. racingService = new RacingService(inputView.getNames()); . 02-2 개별input() in InputView 정의 . public List&lt;String&gt; getNames() { System.out.println(&quot;이름을 입력해주세요&quot;); final String input = getInput(); Validators.checkNullOrEmpty(input); return Arrays.stream(input.split(&quot;,&quot;, -1)) .map(String::trim) .collect(Collectors.toList()); } . 02-3 그에 따라 Service의 생성자 정의 . public RacingService(final List&lt;String&gt; carNames) { this.cars = new Cars(carNames); } . 원래 service 생성자는.. 일급 및 VO 개발시, 다 받아주는 것으로 정했었다. 여기에 추가해준다. . public RacingService(final List&lt;String&gt; carNames, final int round) { this.cars = new Cars(carNames); this.round = new Round(round); } . | . 03 inputView 콘솔입력(공통검증)부터의 테스트 -&gt; new Controller + InputStream(null불가) . new Controller( new InputView )를 던지면 . Controller생성자에서 inputView.콘솔input() 이 호출된다. | 여러개 개별input()이 포함되어있다면, 그만큼 SequenceInputStream을 던져야한다. | . // 1. 콘솔의 개별input()호출 -&gt; 공통 검증 public Controller(final InputView inputView) { racingService = new RacingService(inputView.getNames()); // 2.정제된 input으로 -&gt; 도메인생성 -&gt; 내부에서 도메인 검증 public RacingService(final List&lt;String&gt; carNames, final int round) { this.cars = new Cars(carNames); . | **테스트는 inpustream에 null은 넣지못하므로 &quot;&quot;빈칸만 테스트한다. ** . 전체 다 맞는 것 + 개별input 갯수만큼 sequence를 만들어줘야하므로 끝나면 가장 마지막에 테스트할 예정으로 바꾼다. | . | . @Test void controller_input_test() { final String argument = &quot;&quot;; final InputStream input = new ByteArrayInputStream((argument + &quot; n&quot;).getBytes()); System.setIn(input); assertThatThrownBy(() -&gt; new Controller(new InputView())) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;빈칸&quot;); } . 재귀추가시 fail 뜨게 되므로 valid한 input을 다시 넣어두자. . @Test void input_null_or_empty_test() { final String argument1 = &quot;&quot;; // 틀 final String argument2 = &quot;재성, 재경&quot;; // 맞아서 재귀 통과 final InputStream input1 = new ByteArrayInputStream((argument1 + &quot; n&quot;).getBytes()); final InputStream input2 = new ByteArrayInputStream((argument2 + &quot; n&quot;).getBytes()); final SequenceInputStream sequenceInputStream = new SequenceInputStream(input1, input2); System.setIn(sequenceInputStream); assertThatThrownBy(() -&gt; new Controller(new InputView())).isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;빈칸&quot;); } . 04 null를 직접하고 싶다면 바로 메서드 유틸Validators.checkNullorEmtpy 자체를 테스트하자. . @Test void input_null_or_empty_in_validator() { assertThatThrownBy(() -&gt; Validators.checkNullOrEmpty(null)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;빈칸&quot;); } . ServiceTest again for 넘어온 정제된input으로 도메인 검증 . 도메인 검증은 controller 생성자에서 inpuView.개별input()에서 건너오는 정제된 input을 받아 관리 도메인으로 넣어주는 Service 생성자에서 한다 . //controller racingService = new RacingService(inputView.getNames()); //service public RacingService(final List&lt;String&gt; carNames) { this.cars = new Cars(carNames); } . | . new Service() -&gt; service.메서드()에서 받아주는 input 순서대로 도메인 검증하기 . new Service( inputView.개별input() )을 호출하면서 내부 ` this.cars = new Cars(carNames);` 도메인 생성자 호출되므로, | inputView.개별input() 자리에 원하는 인자로 테스트한다. | . | . 01 inputView.개별input() 자리에 valid 테스트 데이터 입력 . ServiceTest에서 inputView.개별input()을 받는 곳을 호출하되, 값만 임의로 넣어서 테스트한다. . @Test void valid_domain1_input_check() { //new RacingService(inputView.getNames()) //this.cars = new Cars(carNames); //given final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); //when,then assertDoesNotThrow(() -&gt; new RacingService(names)); } . | . 02 invalid한 테스트 작성하면서, 예외발생토록 도메인 검증 작성 . **invalid한 경우부터는 도메인 검증을 만들고, 예외를 발생시켜야한다. ** . | 도메인 만의 검증을 추가한다. . 복수/일급이라면 복수에 대한 것만 추가한다. | validate( 정제input ) -&gt; 모든 검증 나열하고 나중에, 메서드 추출하기 | . public Cars(final List&lt;String&gt; names) { // 2-5-2. 개별 도메인 검증 메서드 생성 validate(names); this.cars = names.stream() .map(name -&gt; new Car(name)) .collect(Collectors.toList()); } private void validate(final List&lt;String&gt; names) { long distinctCountOfNames = names.stream().distinct().count(); if (distinctCountOfNames != names.size()) { //2-5-3. thr 이후 해당 에외클래스() 생성 -&gt; 필요 예외 상속후 생성자만 메세지 파라미터 없이 정의 -&gt; 내부에서 super(&quot;message&quot;) throw new IllegalArgumentException(&quot;중복값을 입력할 수 없습니다.&quot;); //throw new DuplicateNameException(); } } . | . 03 커스텀 예외클래스 만들기 . thrw new 다음에 발생시킬 에러에 예외 클래스를 명시하고 . 상속할 기존 예외클래스를 extends한 뒤 | 부모예외클래스에서 필요했던 파라미터를 생성자로 받든지 or 내부에서 제공할 것으로, 파라미터 없는 생성자를 정의해주고 | 부모 생성자를 그대로 빌려 super() 내부에서 부모가 필요했던 상수를 생성자 내부에서 정의해주자. | . public class NameDuplicatedException extends IllegalArgumentException { public NameDuplicatedException() { super(&quot;이름이 중복될 수 없습니다.&quot;); } } . | . 04 invalid 테스트 . valid: 올바른_도메인이_들어올_경우를_확인한다 | invalid: 도메인이_중복된_경우_예외를_발생시킨다 | . @Test void invalid_domain2_input_exception_check() { //given final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재성&quot;); //when,then assertThatThrownBy(() -&gt; new RacingService(names)) .isInstanceOf(NameDuplicatedException.class) .hasMessageContaining(&quot;중복&quot;); } . 05 개별input~서비스객체 생성 -&gt; 재귀메서드화 in Controller생성자 . 에러시 재입력 받게 하기 위함. . public Controller(final InputView inputView) { //racingService = new RacingService(inputView.getNames()); getNames(inputView); } private void getNames(final InputView inputView) { try { racingService = new RacingService(inputView.getNames()); } catch (Exception e) { System.out.println(&quot;[ERROR] &quot; + e.getMessage()); getNames(inputView); } } . | . 재귀달린이후 테스트: 틀-&gt;맞으로 구성된 SequenceInputStream . 재귀 달린 순간부터 SequenceInputStream아니어서, 1번 틀리면 ControllerTest 안끝남. . @Test void input_null_or_empty_test() { // final String argument = &quot;&quot;; // final InputStream input = new ByteArrayInputStream((argument + &quot; n&quot;).getBytes()); // // System.setIn(input); final String argument1 = &quot;&quot;; // 틀 final String argument2 = &quot;재성, 재경&quot;; // 맞아서 재귀 통과 final InputStream input1 = new ByteArrayInputStream((argument1 + &quot; n&quot;).getBytes()); final InputStream input2 = new ByteArrayInputStream((argument2 + &quot; n&quot;).getBytes()); final SequenceInputStream sequenceInputStream = new SequenceInputStream(input1, input2); System.setIn(sequenceInputStream); assertThatThrownBy(() -&gt; new Controller(new InputView())).isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;빈칸&quot;); } . | 문제는.. 추가되는 재귀input -&gt; 기존꺼 계속 Sequnece 이어져야함 -&gt; 재귀는 가장 나중에 달던가 [TDD는 하지말자.] . | . 06 메서드 파라미터로 들어오는 개별input과 이미 생성[되었을] service객체 . 이미 controller생성자 위쪽에서, 서비스 생성과 동시에 받아주는 input으로 service객체를 생성한 상태이므로, valid한 앞쪽 개별input을 미리 만들어주고, service객체를 만들어서 테스트해줘야할 듯 싶다. . 먼저 개발된 valid_domain1_input으로 service객체를 먼저 만들면서 메서드 + domain2_input을 넣어주도록 한다. . | 그래야 메서드(initDomain2()) 개발이 된다. . | . @Test void valid_domain2_input_check() { //given final List&lt;String&gt; validNames = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); final int round = 4; //when,then assertDoesNotThrow(() -&gt; new RacingService(validNames).initiateRound(round)) } . | service의 생성자에서 못받은 개별input을, service관리 인변에 넣어주자. . public void initiateRound(final int round) { this.round = new Round(round); } . | 07 invalid case -&gt; 도메인 검증 추가 작업 반복 . @Test void invalid_domain2_input_range_exception() { //given final List&lt;String&gt; validNames = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); final int round = -1; //when,then assertThatThrownBy(() -&gt; new RacingService(validNames).initiateRound(round)) .isInstanceOf(RoundRangeException.class) .hasMessageContaining(&quot;0회 이상&quot;); } . 08 개별input 재귀화 -&gt; TDD는 하지말것 . getRound(inputView); private void getRound(final InputView inputView) { try { racingService.initRound(inputView.getRound()); } catch (Exception e) { System.out.println(&quot;[ERROR] &quot; + e.getMessage()); getRound(inputView); } } . ControllerTest (재귀 올 개발 후 ) . 01 재귀작성 완료후 [개별input ALL 맞-&gt;맞 ]으로 컨트롤러 생성자 테스트 . 재귀가 추가됨에 따라, controller생성시 추가 &amp;&amp; 맞는 것으로 맞춰줘야하는 input이 늘어나기 때문에, controller생성으로 인한 input테스트는 가장 나중에 해야할 것 같다. . 개별input개수만큼 SequenceInputStream으로 들어가게 해준다. | . @Test void controller_input_test() { final String argument1 = &quot;재성, 재경&quot;; // 틀 final String argument2 = &quot;5&quot;; // 맞아서 재귀 통과 final InputStream input1 = new ByteArrayInputStream((argument1 + &quot; n&quot;).getBytes()); final InputStream input2 = new ByteArrayInputStream((argument2 + &quot; n&quot;).getBytes()); SequenceInputStream sequenceInputStream = new SequenceInputStream(input1, input2); System.setIn(sequenceInputStream); assertDoesNotThrow(() -&gt; new Controller(new InputView())); } . | . 02 컨트롤러 생성자withInput 전체를 셋업 올리고 -&gt; Controller.run (new OuputView()) 개발 . Controller controller; @BeforeEach void setUp() { final String argument1 = &quot;재성, 재경&quot;; // 틀 final String argument2 = &quot;5&quot;; // 맞아서 재귀 통과 final InputStream input1 = new ByteArrayInputStream((argument1 + &quot; n&quot;).getBytes()); final InputStream input2 = new ByteArrayInputStream((argument2 + &quot; n&quot;).getBytes()); SequenceInputStream sequenceInputStream = new SequenceInputStream(input1, input2); System.setIn(sequenceInputStream); controller = new Controller(new InputView()); } @Test void controller_run() { controller.run(new OutputView); } . public class OutputView { } . //controller public void run(final OutputView outputView) { //outputView의 기본 프린터 기능 쓰면서 //메인로직 //메인로직이후 service에게서 결과받은 것 -&gt; ouputView가 인자로 받아서 처리 } . 03 controller.run()내부에 service로직 + OuputView처리 . public void run(final OutputView outputView) { outputView.printStartMessage(); while (racingService.isContinuable()) { racingService.race(new RandomNumberGenerator()); racingService.decreaseRound(); } outputView.printRoundResult(racingService.getCurrentCars()); outputView.printWinner(racingService.getWinners()); } . 04 OutputView 결과받아 출력 작성 with OutputView Test . setup . OutputStream output; @BeforeEach void setUp() { output = new ByteArrayOutputStream(); System.setOut(new PrintStream(output)); // output.toString() -&gt; actual 로서 print된 스트링을 받아올 수 있게 된다 } . output에 들어갈 결과(dto or dtoList)를 만들어서 output에 뿌려주기 . @Test void name() { //(1)outputView.printRoundResult(racingService.getCurrentCars()); // racingService.getCurrentCars() -&gt; List&lt;CarDto&gt; 만들어주기 //controller.run()에 사용되던 dto결과들을 단일dto.of() -&gt; dto list -&gt; dtos 까지 직접 만들어준다. final CarDto 재성 = CarDto.of(&quot;재성&quot;, 1); final CarDto 재경 = CarDto.of(&quot;재경&quot;, 2); final List&lt;CarDto&gt; cars = Arrays.asList(재성, 재경); //(2) outputView객체 만들어서 print뿌려주기( output에 박히게 됨 ) new OutputView().printRoundResult(cars); //(3) print뿌려진 output.toString()과 예상string을 비교하기 // -&gt; sout는 System.lineSeparator()로 줄바꿈한다. // -&gt; 내부string은 n로 작성되면 -&gt; n 잡으면 된다. assertThat(output.toString()).isEqualTo(&quot;재성 : - n재경 : -- n&quot; + System.lineSeparator()); } . @Test void name2() { final CarDto 재성 = CarDto.of(&quot;재성&quot;, 1); final CarDto 재경 = CarDto.of(&quot;재경&quot;, 0); final List&lt;CarDto&gt; cars = Arrays.asList(재성, 재경); final CarsDto carsDto = new CarsDto(cars); new OutputView().printRoundResult(cars); assertThat(output.toString()).isEqualTo(&quot;재성 : - n재경 : n&quot; + System.lineSeparator()); } . @Test void name3() { //outputView.printWinner(racingService.getWinners()); // racingService.getWinners() -&gt; CarsDto 만들어주기 final CarDto 재성 = CarDto.of(&quot;재성&quot;, 2); final List&lt;CarDto&gt; cars = Arrays.asList(재성); final CarsDto carsDto = new CarsDto(cars); new OutputView().printWinner(carsDto); assertThat(output.toString()).isEqualTo(&quot;재성&quot; + System.lineSeparator()); } . @Test void name4() { //outputView.printWinner(racingService.getWinners()); // racingService.getWinners() -&gt; CarsDto 만들어주기 final CarDto 재성 = CarDto.of(&quot;재성&quot;, 2); final CarDto 재경 = CarDto.of(&quot;재경&quot;, 2); final List&lt;CarDto&gt; cars = Arrays.asList(재성, 재경); final CarsDto carsDto = new CarsDto(cars); new OutputView().printWinner(carsDto); assertThat(output.toString()).isEqualTo(&quot;재성, 재경&quot; + System.lineSeparator()); } . Application으로 controller.run(new OutputView()) 실행 . import controller.Controller; import view.InputView; import view.OutputView; public class application { public static void main(final String[] args) { final Controller controller = new Controller(new InputView()); controller.run(new OutputView()); } } .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/28/TDD-4-controller~inputview~%EB%8F%84%EB%A9%94%EC%9D%B8%EA%B2%80%EC%A6%9D.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/28/TDD-4-controller~inputview~%EB%8F%84%EB%A9%94%EC%9D%B8%EA%B2%80%EC%A6%9D.html",
            "date": " • Feb 28, 2022"
        }
        
    
  
    
        ,"post47": {
            "title": "TDD 3 자경(단일Dto~Service)",
            "content": "Controller와 Service . Controller는 도메인Service 의존하며, 생성자에서 같이 초기화된다. . controller의 생성자에서 inputView와 outputView와 함께, 생성된 or 생성한 service객체를 받아준다. . public GameController(GameService gameService, InputView inputView, OutputView outputView) { //controller가 알고 있던 빈 service객체에 this.gameService = gameService; // 외부에서 받음 this.inputView = inputView; this.outputView = outputView; } . | 컨트롤러 생성시 inputView객체를 받고 . 받은 inputView를 생성자에서 이용하여 inputView.getDto() 등의 데이터를 인자로 받아 Service를 생성한다. | 한번에 input을 받을 수 있을 경우, input에서 getDto로 Service로 다 가져온다. | outputView는 controller 작동시 인자로 받아서 사용된다. | . public GameController(InputView inputView) { //controller가 알고 있던 빈 service객체에 //외부에서 받은 InputView를 이용하여 service를 생성하여 초기화 racingGame = new RacingGame(inputView.getInitDto()); } public void run(OutputView outputView) { playGame(outputView); endGame(outputView); } public static void main(String[] args) { GameController controller = new GameController(new InputView()); controller.run(new OutputView()); } . | 컨트롤러 생성시 컨트롤러 생성자에서 service도 데이터없이 먼저 생성한다. . service가 필요한 데이터는 메서드의 인자로 받아서 service에 set한다. | . public RacingController() { racingService = new RacingService(); } // 한꺼번에 input을 dto로 받는게 아니라면, 개별로 -&gt; 메서드를 통해 input을 따로 입력받는다. racingController.generateRacingCars(carNameInput()); public static void main(String[] args) { RacingController racingController = new RacingController(); racingController.generateRacingCars(carNameInput()); int round = roundInput(); RacingCarOutput.printRoundResultMessage(); race(racingController, round); racingController.checkWinners(); } . | Controller[생성]시 inputView 받 -&gt; Service는 input데이터 받는 안받든 초기화하여 생성. + [작동]시 결과가져 줄OuputView를 받아 전달 . inputView에서 재입력 or 나눠서 받아야하는 경우가 아니라면 new Service( inputView.getInitDto() ) 생성시 받아 생성 | 먼저 서비스부터 생성되고 이후 순서대로 데이터를 set해야하는 경우, 먼저 서비스를 생성 new Service() 이후, 메서드 사용하면서 초기화 | . 객체 -&gt; Service까지 TDD . 단일 객체 TDD . 참고: TDD2 자동차경주 블로그 / DTO 단계별 적용 + 테스트 . 인자 없는 생성자 new Car() + 응답하는 메서드 + 값으로 비교부터 시작해서, 블로그 글을 보고 완성한다. | when 객체 와 생성자로 만든 예상객체를 비교한다. | . @Test void car_move_1step() { final Car car = new Car(&quot;재성&quot;, 0); car.move(4); assertThat(car).isEqualTo(new Car(&quot;재성&quot;, 1)); } @Test void car_move_2step() { final Car car = new Car(&quot;재성&quot;, 0); car.move(4); car.move(4); assertThat(car).isEqualTo(new Car(&quot;재성&quot;, 2)); } @Test void car_move_stop() { final Car car = new Car(&quot;재성&quot;, 0); car.move(3); assertThat(car).isEqualTo(new Car(&quot;재성&quot;, 0)); } . | . 필요시 도메인 검증 테스트 . 단일 Dto TDD . 완성된 단일 객체 -&gt; 꽁꽁 싸멘 일급컬렉션으로 가기 전에, List&lt;단일Dto&gt;가 있어야 일급컬렉션 결과조회 by toDto()로 가능할 것 같다. | . 단일객체의 모든 인스턴스 변수(필드)을 원시값으로 받는 Dto.of( , )로 받도록 정팩매부터 설계하고, getter로 뽑는 확인만 해주자. . final CarDto 재성 = CarDto.of(&quot;재성&quot;, 1); // Car의 모든 필드을 원시값으로 받아 만든다. assertThat(재성.getName()).isEqualTo(&quot;재성&quot;); . private final String name; private final int position; public CarDto(final String name, final int position) { this.name = name; this.position = position; } public static CarDto of(final String name, final int position) { return new CarDto(name, position); } public String getName() { return name; } public int getPosition() { return position; } @Override public boolean equals(final Object object) { . | 일급 TDD . 단일객체들 생성 -&gt; list에 넣기 -&gt; 일급 or 서비스에 넣기 -&gt; 단일객체 조정 -&gt; 그대로 반영 | . 정제가상 재료로 셋업 . input으로 들어오는 List&lt;String&gt;으로 split 정제되어 들어온다고 가정하고 setUp에 세팅한다. . Cars cars; @BeforeEach void setUp() { final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); cars = new Cars(names); } . | 필요시 도메인 검증 테스트 . input에서부터 정제된 데이터(split, convert)가 들어왔을 때, 검증하자. | . 기능 결과 확인용 toDto() 부터 . 일급은 쌓여져있어서 확인이 힘들다. -&gt; toDto()로 List&lt;단일Dto&gt;로 가져와서 확인한다. . 개발1: .getCurrentCars()로서 List&lt;단일Dto&gt;를 가져온다. | . @Test void toDto() { //3-3. 일급의 기능개발 전, 확인이 될 수 있게 현재 객체들을 Dto List로 가져오는 기능 // -&gt; 내부에서 dto가 단일객체를 이용하도록 짤 것 final List&lt;CarDto&gt; currentCars = cars.getCurrentCars(); // assertThat(currentCars.get(0)).isEqualTo(CarDto.of(&quot;재성&quot;, 0)); // List의 검사는 contains, containsOnly로도 검사할 수있따. assertThat(currentCars).contains(CarDto.of(&quot;재경&quot;, 0)); } . | . 일급.toDto()를 통한 메서드 기능 테스트 . 각종 확인 방법 . 일급.toDto() contains ( 예상객체 by Dto.of) | 일급.toDto() containsOnly ( 예상객체1, 2 by Dto.of) isEqualTo ( Arrays.asList(예상객체1, 2 by Dto.of)) | . | 일급.toDto() .get( index) isEqualTo ( **예상객체 by Dto.of **) | 일급.메서드() -&gt; 객체 isEqualTo ( **예상객체 by Dto.of **) | 단일Dto.from( 객체 1개 ) 개발 .getter() isEqualTo ( 값 ) | . @Test void race_move_1step() { cars.race(5); assertThat(cars.getCurrentCars()).contains(CarDto.of(&quot;재성&quot;, 1)); } @Test void race_move_0step() { cars.race(3); assertThat(cars.getCurrentCars()).contains(CarDto.of(&quot;재성&quot;, 0)); } @Test void get_max_position_cars() { cars.race(4); final Car maxPositionCar = cars.getMaxPosition(); assertThat(CarDto.from(maxPositionCar).getPosition()).isEqualTo(1); } . | . 단일Dto.from( 응답객체 ) 개발 -&gt; (객체비교불가상황)응답 값 1개만 getter 추출 -&gt; 값 비교 테스트 . 현재 maxPosition인 Car객체 (List)를 뽑기 위해 중간, Car객체 1개 추출 로직을 테스트해야한다. . actual에서 단일객체 1개마 뽑히는 상황 -&gt; 단일객체1 to 단일Dto로 바로 가도록 단일Dto.from() 정펙매를 만들어줘야 -&gt; 값을 추출할 수 있다. | 필드 1개만 알고 있는 상황을 확인해야하므로, max인 값을 가진 Car를 뽑아내기 때문에, 임의로 CarDto.of( , , )로 만들 수 없는 상황 | . @Test void get_max_position_car() { cars.race(4); final Car maxPositionCar = cars.getMaxPosition(); // 이름은 모름, position만 1인 것을 아는 상황. -&gt; 값으로 비교해야함 -&gt; Dto에서 뽑아내야함. } . public static CarDto from(final Car car) { return new CarDto(car.getName(), car.getPosition()); } . @Test void get_max_position_car() { cars.race(4); final Car maxPositionCar = cars.getMaxPosition(); //my) &lt;일부 속성(이름제외된 숫자속성)만 변화되어, 객체==만든 예상객체&gt;의 비교가 불가능할 경우, // 실제 객체를 -&gt; dto변형 후 값을 뽑아내 -&gt; 값 대 값으로 확인할 수 도 있다. assertThat(CarDto.from(maxPositionCar).getPosition()).isEqualTo(1); } . | . 일급의 응답(List&lt;객체&gt;)는 -&gt; 한방에 DtoList or 복수Dto로 한방에 . 일급이 사용되는 serivce에게는 DtoList or 복수 Dto로 응답해야한다. . 어차피 응답은 객체List로 오니 -&gt; 복수Dto.from( List&lt;객체&gt;)로 한방에 돌리자. | 내부에서 이미 개발된 stream 단일객체 + 단일Dto.from( 단일객체) -&gt; list로만 만들어주면 된다. | 대신 dto용 getter에 이름을… get()로 단순화시키자. | . @Test void get_max_position_cars() { cars.getWinners(); } . //일급 응답이 객체리스트? -&gt; 한방에 복수Dto.from만들기 public List&lt;Car&gt; getWinners() { final Car maxPositionCar = getMaxPosition(); return this.cars.stream() .filter(car -&gt; car.isSamePosition(maxPositionCar)) .collect(Collectors.toList()); } . // 이미 단일Dto.from이 개발된 상황이라면, // 객체리스트 -&gt; 복수Dto 한방에 개발한다. return CarsDto.from(this.cars.stream() .filter(car -&gt; car.isSamePosition(maxPositionCar)) .collect(Collectors.toList())); . public static List&lt;CarDto&gt; from(final List&lt;Car&gt; cars) { // 단일Dto List로 일단 만든 뒤 -&gt; 생성자 호출 예정 return cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList()); } . return CarsDto.from(this.cars.stream() .filter(car -&gt; car.isSamePosition(maxPositionCar)) .collect(Collectors.toList())); . private final List&lt;CarDto&gt; carsDto; public CarsDto(final List&lt;CarDto&gt; carsDto) { this.carsDto = carsDto; } public static CarsDto from(final List&lt;Car&gt; cars) { return new CarsDto(cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList())); } //public List&lt;CarDto&gt; getCarsDto() { public List&lt;CarDto&gt; get() { return carsDto; } . dtoList .get() -&gt; Dto List -&gt; 1개 뽑아서 값 비교..(현재 이름모르고 1개 값만 아는 상태) | . @Test void get_max_position_cars() { cars.race(4); cars.race(4); cars.race(4); final CarsDto winnerCars = cars.getWinners(); //복수Dto.get() -&gt; List &lt;단일Dto&gt; assertThat(winnerCars.get().get(0).getPosition()).isEqualTo(3); } . | . Service 객체 TDD . inputView로부터 오는 도메인의 재료를 컨트롤러 내부에서 생성될 때, 생성자로 될 때 받을지 | 객체생성 후, generate로 | | input재료들 -&gt; 받아서 생성자를 통한 일급 or List단일로의 변환 생성도 서비스 안에서 이루어진다. 필요재료라 인스턴스 변수로 관리해야한다. | . | . 재료없이 service객체 셋업 (원래 미리 생성 in 컨트롤러) . 컨트롤러에서 사용한다고 생각하자. . | 일단 컨트롤러 생성자에서부터 미리 서비스를 미리 생성시킬 예정이다. . 재료가 한번에 오면 initDto -&gt; service미리 생성시킬 시 받아주면 되는데 . @BeforeEach void setup() { racingGame = new RacingGame(InitDto.of(&quot;juri,hunch&quot;, &quot;5&quot;)); } . | 그게 아니라면, service.generate일급()처럼, 원재료를 일급/List객체로 변환하는 작업도 service가 담당한다. . public RacingController() { racingService = new RacingService(); } . | . | 셋업에 서비스 미리 생성 . RacingService racingService; @BeforeEach void setUp() { racingService = new RacingService(); } . | . input재료들을 받는 service 생성자도 만들어, 셋업에서 관리변수 채워놓기. . input을 나중에 받더라도.. 미리 만들어져있어야하구나. 그래야 꺼내는 기능만을 확인할 수 있다. . | service안에 관리 변수에 뭐가 들어있어야… 확인이 된input원재료 -&gt; 관리 변수 (Cars cars)를 통채로 받아주는 놈을 임시로 만들자. . 검증은 각 도메인 내에서 할 것임. 변환생성해주는 서비스에서 하지말자. | . @BeforeEach void setUp() { final List&lt;String&gt; carNames = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;, &quot;아라&quot;); racingService = new RacingService(carNames); } . private Cars cars; public RacingService(final List&lt;String&gt; carNames) { this.cars = new Cars(carNames); } . | . 기능 결과 확인용 일급.toDto() 호출 함수부터 . 서비스는 내부에 인스턴스변수로 일급 (or 객체List)를 관리한다. . 일급이나 객체List를 확인하는 방법은 toDto로 미리 정의해놓았다. | 이것을 부르는 메서드(getCurrent일급())를 먼저 TDD한다. 이름만 get일급()이지, toDto한 List&lt;Dto&gt;를 가져온다. | . | . @Test void get_current_cars() { racingService.getCurrentCars(); } . public class RacingService { public void getCurrentCars() { this.cars.getCurrentCars(); } } . public class RacingService { private Cars cars; public List&lt;CarDto&gt; getCurrentCars() { return this.cars.getCurrentCars(); } } . java @Test void get_current_cars() { final List currentCars = racingService.getCurrentCars(); . assertThat(currentCars).contains(CarDto.of(&quot;재성&quot;, 0)); } . | . 미리 안넣어놓고, 차후 setter역할의 service.generate()로 input재료 -&gt; 해당도메인 객체(일급) 변환 생성 TDD . 서비스는 해당도메인의 기능을 모아둔 것이다. 일단 해당도메인으로 변환시킨다. . 서비스.해당도메인생성( input재료) -&gt; 내부 관리 인스턴스 변수(일급orList)에 set되는 것을 확인해야한다. | 그것을 빼쓰라고 만든게 일급.toDto()있으니, 서비스에서 일급DTO내놔 메서드를 호출해서 컨트롤러에 제공해준다. | . @Test void generate_cars() { //given: input에서 오는 원재료 final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); //when racingService.generateCars(names); } . public class RacingService { public void generateCars(final List&lt;String&gt; names) { this.cars = new Cars(names); } } . public class RacingService { private Cars cars; public void generateCars(final List&lt;String&gt; names) { this.cars = new Cars(names); } } . @Test void generate_cars() { //given: input에서 정제된 원재료 final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); racingService.generateCars(names); //when //then assertThat(racingService.getCurrentCars()).contains(CarDto.of(&quot;재성&quot;, 0)); } . | . 필요시 전략객체 service에서 생성하여, 메서드의 파라미터로 넣어주기 . 들어간 Service 변수(인스턴스 변수, 필요 변수)확인 테스트 . 관리(인스턴스) 변수 중 VO는 getDto없이 asssertThat().extracting으로 내부 인변 바로 뽑아 확인하기 . input정제 VO 원시값까지 받아주는 service 생성자 추가 생성 . @Test void get_round() { racingService = new RacingService(carNames, 5); } . VO 객체 개발 . //서비스 생성자 추가 public RacingService(final List&lt;String&gt; carNames, final int round) { this.cars = new Cars(carNames); this.round = new Round(round); } //VO 개발 public class Round { private final int round; public Round(final int round) { this.round = round; } @Override public boolean equals(final Object object) { . VO를 받아서 생성하는 service를 초기화 후, extracting으로 객체 뽑아서 1:1비교 . 기존 서비스는 노인자 -&gt; names(stringList-&gt;일급) -&gt; names 포함한 VO까지 받아서 처리 | . @Test void get_round() { racingService = new RacingService(carNames, 5); //when, then assertThat(racingService).extracting(&quot;round&quot;).isEqualTo(new Round(5)); } . 메인로직 TDD . 메인로직 실행 . 일급.메서드()를 실행시키는 단순로직 . 응답 값이 없는 실행 메서드다? 사용객체와 예상객체로 비교 | 랜덤값이 포함되어있으면, 그만큼 빼줘야한다… 하지만, 그냥 빼면… 일괄 적용되므로, 인터페이스로 빼고 -&gt; 필요한 곳에서 전략메서드 호출()하도록 뺀다. 테스트에선 전략객체 대신 최종 결과값만 넣어주면 됨. (여기선 생략) | . | . @Test void race() { racingService = new RacingService(carNames, 5); racingService.race(); racingService.race(); assertThat(racingService.getCurrentCars().get(0).getPosition()).isEqualTo(2); } . 전략 인페 + 전략메소드 정의 | 전략을 구현한 랜덤인페 + 메소드 정의 | 전략메소드 호출시점에만, 메소드 호출하여 랜덤 시행 + 그외에는 전략객체만 파라미터로 수정 | 테스트에선 람다식으로 인자 없이 랜덤한 return값을 직접 지정 () -&gt; return을 준다. | | . 메인로직 실행 횟수(VO)의 iterator TDD . service가 만들어질 때나, 만들어진 이후 가지고 set되어야할 VO는 service내부 관리 변수 확인 테스트에서 처음 등장했다. . @Test void get_round() { racingService = new RacingService(carNames, 5); assertThat(racingService).extracting(&quot;round&quot;).isEqualTo(new Round(5)); } . | 컨트롤러에서 service.메인로직()을 service.hasNext(VO)만큼 돌려야한다. . | . 01 service. isContinuable() -&gt; Vo.isNotFinish() -&gt; true/false를 테스트한다. . hasNext패턴의 while()문에 들어갈 조건부이다. . @Test void vo_is_continuable() { racingService = new RacingService(carNames, 5); final boolean isContinuable = racingService.isContinuable(); assertThat(isContinuable).isTrue(); } @Test void vo_is_not_continuable() { racingService = new RacingService(carNames, 0); final boolean isContinuable = racingService.isContinuable(); assertThat(isContinuable).isFalse(); } . //Service public boolean isContinuable() { return this.round.isNotFinish(); } //Round public boolean isNotFinish() { return this.round &gt; 0; } . | . 02 service.play메인로직() 내부에서 -&gt; 메인객체.메인로직() 와 동시에 돌아갈 + VO감소로직 VO.getNext(); 처리 . VO감소 -&gt; 감소된 VO반환하여 service관리 VO를 덮어쓰기 . 이 과정이 while문 true 내부 메인로직 돌아갈 때 같이 돌아가야한다. | . @Test void vo_can_decrease() { racingService = new RacingService(carNames, 4); //프로덕션코드에서는, 반복될 메인로직 실행부 메서드와 같이, race실행시 round감소를 같이시켜줘야한다. //racingService.play(); racingService.playWIthRoundDecrease(); } . //Service public void playWIthRoundDecrease() { //1. 메인(일급)객체.race() //2. decrease된 vo를 받아와야함 *값만 변화(round.decrease())하면 안됨 round = round.getNext(); } . //Round public Round getNext() { // 여기서는 0보다 커야한다는 검증이 있으면 0으로 갈때 에러가 나니 조심! // 검증은 hasNext패턴을 가지는 VO는 무조건 검증을 정팩메에 주자~ return new Round(this.round - 1); } . @Test void vo_can_decrease() { racingService = new RacingService(carNames, 4); //프로덕션코드에서는, 반복될 메인로직 실행부 메서드와 같이, race실행시 round감소를 같이시켜줘야한다. //racingService.play(); racingService.playWIthRoundDecrease(); //내부의 round값이 변화되기 때문에 -&gt; 응답 값이 아닌 사용객체 vs 예쌍객체로 비교해야한다. assertThat(racingService).extracting(&quot;round&quot;).isEqualTo(new Round(3)); } . | . 랜덤응답의 범위 TDD(단위테스트) . 랜덤을 생성하는 메서드를 학습하는 단위테스트 범위내로 들어오나? -&gt; isBetween(a, b) -&gt; a&lt; = &lt;= b의 검사 | . | . 값 1개의 랜덤: @RepeatedTest() + .isBetween . //사용할 객체 만들고 RandomNumberGenerator randomNumberGenerator; @BeforeEach void setUp() { randomNumberGenerator = new RandomNumberGenerator(); } //응답값의 범위 확인을 여러번 @RepeatedTest(100) void range_test() { assertThat(randomNumberGenerator.generate()).isBetween(0, 9); } . List의 랜덤: iterator의 hasNext패턴 -&gt; 객체비교 . @Test void Random_숫자범위_검사() { // 원래는 랜덤으로 차있는 list -&gt; iterator final ListIterator&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 44, 45).listIterator(); // 랜덤값들을 돌면서 검사 while (numbers.hasNext()) { assertThat(numbers.next()) .isGreaterThanOrEqualTo(1) .isLessThanOrEqualTo(45); } } .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/26/TDD-3-%EB%8B%A8%EC%9D%BCDto-~-Service.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/26/TDD-3-%EB%8B%A8%EC%9D%BCDto-~-Service.html",
            "date": " • Feb 26, 2022"
        }
        
    
  
    
        ,"post48": {
            "title": "TDD 2 자동차경주(객체Dto)",
            "content": "실패하는 코드를 짜는 이유? 통과하는 코드를 짜려고 하면, case단위가 아니라 다 짜야해서 너무 커진다. | case 만드는 것이 목적 -&gt; 실패 case부터 만든다. | . | 테스트코드도 복잡도를 낮춘다. | . 기능 요구사항 복붙후 정리 . 복붙 . 각 자동차에 이름을 부여할 수 있다. 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다. 자동차 이름은 쉼표(,)를 기준으로 구분한다. 자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한명 이상일 수 있다. . 제목(##) + 앞에 체크박스 만들기 . ## 요구사항 - [ ] 각 자동차에 이름을 부여할 수 있다. - [ ] 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다. - [ ] 자동차 이름은 쉼표(,)를 기준으로 구분한다. - [ ] 자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한명 이상일 수 있다. . 각 요구사항들을 테스트코드 DisplayName으로 작성하기도 한다. | . 키워드 뽑기 . ## 요구사항 - [ ] 각 자동차에 이름을 부여할 수 있다. - [ ] 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다. - [ ] 자동차 이름은 쉼표(,)를 기준으로 구분한다. - [ ] 자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한명 이상일 수 있다. - 자동차 - 이름 - 자동차 이름은 쉼표(,)를 기준 - 전진 - 게임 - 우승 - 우승자는 한명 이상 . 키워드 관계 재배치 . 객체인지 vs 메서드인지 vs 세부 요구사항인지 | 객체 중에 이름만 다르게 뽑을지 -&gt; 뽑는 것은 관리자 객체에서 우승한 자동차 -&gt; 자동차 중 뽑은 것 -&gt; 자동차 경주(관리자) | . | . - 자동차 - 전진: 자동차가 하는 것이니 객체가 아닌 메서드 - 우승한 자동차: 따른 객체인지 vs 자동차 중 뽑아서 이름만 다르게? - 우승자는 한명 이상: 세부 요구사항 - 이름 - 이름은 쉼표(,)를 기준: 세부 요구사항 - 자동차 게임: 자동차에서 우승한 자동차 뽑는 것은 이상하니, 게임이 관리하면서 뽑도록 - 우승한 자동차: 따른 객체인지 vs 자동차 중 뽑아서 이름만 다르게? - 우승자는 한명 이상: 세부 요구사항 . 시작점 고르기 . 자동차 게임 -&gt; 관리자부터 하기엔 잘 모름 | 자동차 -&gt; 핵심이자 간단한 단위 객체 진짜 잘 모르겠으면 이름부터 해도 된다. | . | . 출력, View에 대한 요구사항은 무시하고 객체 설계부터 시작 . UI, view를 맨나중에 붙이면, 객체다운 객체가 완성됨. | . TDD 시작 . 정의 없는 default생성자 사용 / 응답 하는 메서드부터 . TDD 시작점을 new Car();의 생성자에서 부터 시작하는 경우가 많다. . 보통은 Car car = new Car();의 생성자로 TDD를 시작한다. 여기서 시작해서 테스트 코드로 변하게 된다. | . | . @Test void 생성자_검사() { //방법1. 생성시 예외발생안함. assertDoesNotThrow(() -&gt; new Car(재성)); //방법2. 생성한 것이 null이 아님. final Car car = new Car(&quot;재성&quot;); assertThat(car).isNotNull(); } . | 여기서는 객체 생성자와 동시에 상수 먼저 응답하는 기능 메서드를 주 테스트로 시작한다 . 움직였을 때, 1칸 움직였다고 -&gt; 상수 1을 응답할거라 가정하고 작성한다. | . //1. 객체+Test로 테스트 class 작성 public class CarTest { @Test //2. (생성자 따로 검사하는게 아닌) 객체의 기능으로 메서드 명 먼저 작성 void move() { //3. 없어도 객체 생성자 호출 final Car car = new Car(); //4. 객체 기능을 호출하되, 테스트에 용이하도록 &lt;호출시 응답 결과값&gt;이 있을 거라 예상 -&gt; assertThat( actual )에 바로 값 넣어주기 //car.move() //5. 기대하는(나와야하는) 응답 값을 .isEqualTo( expected )에 넣어주기 assertThat(car.move()).isEqualTo(1); } } . | 컴파일 에러들을 잡는다. . 예상하는 응답값을 상수로 바로 나오도록 먼저 작성한다. | . public class Car { public int move() { return 1; } } . | 테스트를 돌려서, 상수 1로 응답하는지 확인한다. . | . case 추가(누적 -&gt; 응답 expected 변경 2) . 복붙으로 다른 Test case(메서드 맨끝_네임 수정)를 작성하며 안돌아가는 코드 구현 . 1칸 움직여서 1 반환하는 case도 있지만, 2번 움직이는 or 안 움직이는 케이스도 있음. . 메서드를 복붙해서 case를 나눈다 | . @Test void move_go() { final Car car = new Car(); assertThat(car.move()).isEqualTo(1); } @Test void move_go2() { final Car car = new Car(); //1. car.move(); //2. assertThat(car.move()).isEqualTo(2); // 2를 응답해줘야함. } . | . 기존 작성된 메서드를 메서드2로 복붙한 뒤 구현 . 기존 코드는 돌아가도록 하는 상태(move() 그대로 두기)에서 move() -&gt; move2()로 복붙한 뒤, 직전꺼도 포함해서 다 돌아가도록 구현 . package domain; public class Car { public int move() { return 1; } public int move2() { return 1; } } . 누적되려면, 저장할 변수가 필요해서 필드(인변)를 선언하여 거기다가 가지고 있도록 한다.. | . public int move2() { return position++; } . public class Car { private int position; public int move() { return 1; } public int move2() { return ++position; } } . | . 복붙 수정 메서드2를 사용해서 통과시켜본다. . 복붙new Test method 에서 복붙 method2()를 사용해서 통과시킨다. . @Test void move_go2() { final Car car = new Car(); //1. car.move2(); //2. assertThat(car.move2()).isEqualTo(2); } . | . 기존case도 수정 메서드2로 변경해보고 -&gt; 기존메서드()는 회색띄운 뒤 삭제 . 처음 테스트도 .move2()를 사용하게 한 뒤 테스트 . | 테스트 통과하면 기존 move()는 사용안되서 회색 떠있음 -&gt; alt + del로 안전삭제 . @Test void move_go() { final Car car = new Car(); assertThat(car.move2()).isEqualTo(1); } @Test void move_go2() { final Car car = new Car(); //1. car.move2(); //2. assertThat(car.move2()).isEqualTo(2); } . | . 최종 수정메서드2 -&gt; 매서드로 이름 변경 . .move2()가 -&gt; .move()를 대체하는 순간 . @Test void move_go() { final Car car = new Car(); assertThat(car.move()).isEqualTo(2); } @Test void move_go2() { final Car car = new Car(); //1. car.move(); //2. assertThat(car.move()).isEqualTo(2); } } . | . case 추가(조건 따라 stop -&gt; expected는 stop일때 나와야하는 값으로 미리 넣어두기 0) . 복붙 Test case 추가 ( 설계전 해당 case expected입력해서 error) . move_stop케이스 추가 -&gt; expected 0을 응답하도록 작성하기 . @Test void move_stop() { final Car car = new Car(); //1. 1번움직였는데 &gt; 0을 응답해야하는 경우도 처리 assertThat(car.move()).isEqualTo(0); } . | . 메서드2()로 복사해서 다시 처리 . 해당 조건일 때만 움직이게 해준다. . public int move2() { if (ThreadLocalRandom.current().nextInt(10) &gt;= 4) { position += 1; } return position; } } . | . 내부 랜덤 포함 메서드는 테스트 실행시마다 결과가 다르다. . 특정 테스트 바깥에 커서를 두고 전체 테스트 실행 랜덤이 껴있는 경우 돌릴 때 마다 다르게 결과 | . | . 랜덤은 가능한 구조로 바꿔주기 . 랜덤부분만 파라미터화시켜 밖으로 빼준다. . 기존 . public int move() { if (ThreadLocalRandom.current().nextInt(10) &gt;= 4) { position += 1; } return position; } . | 파라미터화시켜 밖으로 빼기 . 자동으로 사용중이던 부분(랜덤)이 –&gt;메소드 사용처로 이동된다. | . public int move(final int number) { if (number &gt;= 4) { position += 1; } return position; } . assertThat(car.move(ThreadLocalRandom.current().nextInt(10))).isEqualTo(0); . | . 사용처의 랜덤생성을 특정 상수로 바꾼다. . 랜덤은 프로덕션 코드에서만 사용되므로 추출되어 사용처로 옮겨간 랜덤부분을 테스트에서는 상수로 변경한다. . @Test void move_go2() { final Car car = new Car(); car.move(5); assertThat(car.move(5)).isEqualTo(2); } @Test void move_stop() { final Car car = new Car(); assertThat(car.move(3)).isEqualTo(0); } } . | . 랜덤 뿐만 아니라 랜덤포함조건자체를 객체의 역할로 . 객체가 테스트를 위한 랜덤부분 외부 파라미터로 추출 뿐만 아니라 . | if 조건에 따른 다른 역할을 하는 객체로 취급하고 싶다면 if조건 자체를 인터페이스로 추출할 수 있다. . 전략패턴은 대체가능한 다른전략을 넣는 부분을 인터페이스 -&gt; 전략메서드로 추출해놓는다. | . 바뀔 수 있는 부분을 잡아서 상태에 맞게 메소드로 추출해놓는다. . | 인터페이스 XXXXStrategy + 이름만 가진 추상메서드를 만든다. . | 특정Strategy의 이름을 정해서 impl구상클래스를 추출메소드를 복붙해서 구현한다. . | 특정전략의 메소드가 사용된 곳마다 —&gt; 다른전략을 허용하는 추상화된 인터페이스 객체를 인자로 받은 뒤 -&gt; 추상체.추출메소드()호출로 수정한다. . | 이제 에러난 부분을 타고가면서, *내부 매개변수 정의에 사용된 추상 인자를 호출하는 외부 인자 자리에 new 특정전략()를 넣워준다. . | 테스트에서 다른전략으로 조건부의 상수인 람다함수로 () -&gt; true를 대입하여 움직임을 확인한다. . | | . 확인을 위한 응답 값(조회)이 실제 필요한지 의심해봐야한다 . 내부 position만 바뀌면 되는데, 테스트를 위해 응답하고 있지는 않은지 의심하자. | . 응답하는 것도 1가지 일(조회)다. 위치변경(테스트할 기능) + 조회 2가지 일을 하는 move() . 포지션을 조회하고 싶다면 또다시 car.move()를 호출해서 확인해야하나? 변하면서 조회되므로 이상하다. . public int move(final int number) { if (number &gt;= 4) { position += 1; } return position; } . | 조회는.. 응답 말고도 다른 방법이 있다. 값으로 만드는 객체로 비교 . | . 조회 메서드가 아니라면, 테스트 끝난 후, 응답 값 제거리팩토링 . 메서드2() 복붙 생성하여, 응답이 제거된 메서드2 생성 . public int move(final int number) { if (number &gt;= 4) { position += 1; } return position; } public void move2(final int number) { if (number &gt;= 4) { position += 1; } } . | Test에서는 assertThat()에 응답 값을 넣어줘야하는데? . assertThat(car.move(3)).isEqualTo(0); . | . 응답 값 대신 [해당객체]를 / expected 예상값 대신 예상값으로 생성한 + equals옵라된 [예상객체]를 . 예상값으로 예상객체를 만들어줄 생성자를 추가한다. . | 기존에는 default 생성자로서, 인자 없이 만들었다. Select None으로 기존 것도 사용가능하게 빈 default 생성자를 따로 정의해주자. . . public Car() { } . | 생성된 객체로 비교하기 위해, equals, hashCode를 옵라이딩 . | 응답 없는 메소드2로 치환 후, 객체.메서드2호출 - assertThat(객체). (예상객체) 로 비교 . 이제 전부 응답없는 메소드2로 치환 -&gt; actual 응답 자리에서 빼주기 . @Test void move_go() { final Car car = new Car(); car.move2(4); // 1.actual에는 실제응답 대신, 객체를 assertThat(car).isEqualTo(new Car(1)); // 2. 예상값으로 만든 예상객체 } . | 기존 assertThat( 응답값 ) .isEqualsTo ( 예상값) . assertThat(car.move(4)).isEqualTo(0); . | assertThat( 사용객체 ) .isEqualsTo ( 예상객체) . ar.move2(4); assertThat(car).isEqualTo(new Car(1)); . | . 생성자도… 테스트를 위한 생성자인지 고민 -&gt; 그렇다면 .getPosition() 대신 .position()으로 마무리? . get이라는 네이밍을 빼서 내부에 position이 있는지 모르게 하는게 핵심 | . 외부추출랜덤은 상위 객체 테스트를 막는다 . 자동차.move()의 내부 랜덤 추출 -&gt; 자동차.move(랜덤사용) -&gt; 자동차.move(랜덤사용)을 호출하는 자동차경주가 내부 랜덤을 포함하게 됨. | . 상위 객체(관리자) Test -&gt; List&lt; 테스트끝난객체&gt; 를 받도록 생성 -&gt; 돌면서 시켜야함. . 단일 테스트가 끝난 단일객체에 대해서 일급 컬렉션 생성 전 LIst&lt;단일&gt;을 사용 == 세팅by생성자( List&lt;단일객체&gt; )하는 상위객체, 관리자객체를 Test서부터 만든다. . 필요한 것은 set을 생성자에서 받는다. | 다 못받으면, 필요기능의 메서드 파라미터로 | . @Test void name() { final List&lt;Car&gt; cars = Arrays.asList(new Car(), new Car()); final RacingGame racingGame = new RacingGame(cars); } . public class RacingGame { public RacingGame(final List&lt;Car&gt; cars) { } } . public class RacingGame { private final List&lt;Car&gt; cars; public RacingGame(final List&lt;Car&gt; cars) { this.cars = cars; } } . | 관리자=상위객체에서 메서드() -&gt; list를 돌며 단일객체 메서드 시키기 . public class RacingGame { private final List&lt;Car&gt; cars; public RacingGame(final List&lt;Car&gt; cars) { this.cars = cars; } public void start() { cars.forEach( car -&gt; car.move(ThreadLocalRandom.current().nextInt(10))); } } . | Car만 테스트는 가능하고, 그 상위객체인 RacingGame은 테스트가 불가능한 상태다. . 원한다면 다시 랜덤부분을 파라미터로 추출하면 된다. | 어디까지 테스트가능 구조로 할지는 자기가 선택하는 것 | 상위객체도 테스트 가능한 구조로 만들고 싶다면, 파라미터화시켜 외부로 빼면 된다. | . | 가장 끝단의 객체를 찾고, 테스트 불가 부분을 밖으로 뺀다. . . 한단계 더 올리면, RacingGame도 테스트가 가능해진다. . . | 랜덤, 특정 날짜에만 작동 등이 테스트하기 힘든 코드다. . 외부로 분리해서 주입한다. | . | . .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/24/TDD-2-%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/24/TDD-2-%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Feb 24, 2022"
        }
        
    
  
    
        ,"post49": {
            "title": "피드백) 1-1(자동차경주) 코드리뷰",
            "content": "자경 미션 피드백 . PR 1차 피드백 | PR 2차 피드백 리뷰어: 코니 | . | . 네이밍 . if절에 들어가는 메서드명은 is~, has~로 시작하자. | VO의 새객체 반환 메서드네이밍을 toNextRound()로 잡았다. to는 괜찮을까? toString, toDto 같이 형 변환시에만 사용하자.. 또 바꿔야겟넹.. getNextRound() | . | Util이라는 추상적인 이름 대신 Validator처럼 구체적인 이름으로 클래스 잡기 . | 조건문 전체가 아니라, 일부 값 비교에서도 네이밍을 변수로 추출하는게 좋다 . private static void checkDuplicated(List&lt;String&gt; carNames) { if (carNames.stream().distinct().count() != carNames.size()) { long distinctCountOfCarNames = carNames.stream().distinct().count(); if (distinctCountOfCarNames != carNames.size()) { . | 추출할 때, 메서드의 인자는 구체적으로X 좀더 추상적으로 정의해주기 | . 체크 . 메소드 사용 순서대로 배치후 commit -&gt; 커밋전 체크리스트화 structure(alt+7) | . | 불필요 공백 제거후 coimmit | 테스트 코드 돌리고 commit @parameterizedTest &lt;-&gt; @Test | . | intellij 상수, 변수추출을 private으로 최초 1번 옮겨주기 | 유틸이라도 해당 class에서만 사용된다면, private 으로 변경해줘야한다. . | static 유틸 클래스는 private생성자로 객체생성없음을 명시해주기 | 상수 &lt;-&gt; 멤버변수 개행 1줄 넣어주기 . | 전략메서드에는 인페/클래스명에 있는 목적어(number)를 repeat할 필요없다. 동사(generate)만 | . 검증 . 실수로 기입된 내부공백(Blank) 검사는 문자열숫자의 format검사가 있다면 안해도 된다. . | 부정조건문 없애자 . | . 생성자 . static 유틸 클래스는 private생성자로 객체생성없음을 명시해주기 . | 접근제한자 기본은 private으로 바꿔주기 . | 도메인은 input이외에 자체 검증 -&gt; input에서는 공통검증 / 도메인 자체검증 생성자 . | 생성자 로직 private 기본 생성자 | public from( 원본 List&lt; Car&gt;) + Cars검증로직(중복 등) | public fromNames or fromInput(List&lt; String &gt;) + Cars검증로직(중복 등) | . | 테스트에서 단일-&gt; 단일List 만든 뒤, 단일 조정 by메서드 -&gt; 단일List에 반영 -&gt; 반영된 단일List로 일급컬렉션 생성 | 불변을 위해 포인터의 포인터 사용을 막아야하는데, 테스트에서는 포포를 사용할 수 있게 inputString List가 아닌 단일객체List로부터 만드는 생성자(정펙매) 추가 | . | . 기본 . split은 2번재 인자를 줘야, ,, 를 안씹고 간다. -&gt; split( , -1) . String[] split = &quot;,,&quot;.split(&quot;,&quot;); // count 0 String[] split1 = &quot;,,a&quot;.split(&quot;,&quot;); // 3 String[] split2 = &quot;,a,&quot;.split(&quot;,&quot;); // 2 String[] split3 = &quot;a,,&quot;.split(&quot;,&quot;); // 1 . | split후 trim까지 해서 반환해야 a, a를 다른 것으로 인식한다. -&gt; split(,-1).map(String::trim) . return Arrays.stream(value.split(delimiter, -1)) .map(String::trim) .collect(Collectors.toList()); . | convert나 split관련 기본api가 충분하면, 유틸 메서드로 따로 빼지말고 그냥 사용하자. 지식만 늘어난다. . | 조건문의 전략객체(Functional interface)에는 () -&gt; 람다식으로 테스트한다. . | . VO, DTO . Dto는 controller에 일단 넣어준다. . | ROUND는 hasNext패턴으로 줄어가는데, 생성자 검증은 1이상 &lt;-&gt; 1씩 줄여가니 0까지는 감. 생성자에서 검증하되, 새객체 반환은 검증없는 private 기본생성자이용 | . | DTO는 VO나, 포장객체 없이 only 원시값들로 필드가 구성 -&gt; Dto사용을 위한 원본 getter에서는 VO-&gt;value까지 최종반환시킨 getter . | VO를 가진 단일객체의 compareTo에 원시값 비교 x -&gt; VO로 비교 -&gt; VO도 비교가능하게 . | 정펙매 생성자 중간에 VO가 등장할 경우, getter()를 써도 된다. . | VO는 검증/불변을 위해 래핑한 것이므로, 도입했다고 굳이 정펙매를 외부에 오픈안해도 된다 . private Cars getCars() { try { return Cars.fromNames(InputView.getCarNames()); //Cars.fromNames(Names.fromInput(InputView.getCarNames())); . 같은 context에서 사용될 일이 없는, 객체 생성 가운데 활용되는 객체들은 구현을 드러내지 않는 것이 좋을 것 같습니다! | . | . 테스트 . DTO의 테스트는 view처럼 자주 바뀌는 DTO에 대해 테스트를 생각해본다. . | DisplayName은 너무하다 싶을정도로 자세히 쓴다. . class NameTest { //@DisplayName(&quot;이름이 1자 미만, 5자 초과일 경우&quot;) //@DisplayName(&quot;자동차 이름이 1자 미만, 5자 초과하여 유효하지 않은 경우&quot;) @DisplayName(&quot;자동차 이름이 1자 미만, 5자 초과하여 유효하지 않은 경우 예외가 발생한다&quot;) . 이정도로 결과까지 명확하게 서술하면 더 좋습니다. | . | @ValueSource의 빈 문자열과 @EmptySource가 같은 값을 제공하지 않나요? . @EmptySource @ValueSource(strings = {&quot;&quot;, &quot;Wishoon&quot;, &quot;123456&quot;}) . | .",
            "url": "blog.chojaeseong.com/java/feedback/review/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/23/%ED%94%BC%EB%93%9C%EB%B0%B1)-1-1(%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC)-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0.html",
            "relUrl": "/java/feedback/review/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/23/%ED%94%BC%EB%93%9C%EB%B0%B1)-1-1(%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC)-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0.html",
            "date": " • Feb 23, 2022"
        }
        
    
  
    
        ,"post50": {
            "title": "강의) 네오 1단계 자경 피드백",
            "content": "final 키워드로 값의 변경을 막아라 . 값은 final로 재할당금지 -&gt; 재사용 금지 . . main 메소드 template 인 psvm의 인자에도 final을 붙혀준다. . . | 메서드 내부에서 코드 중간에서 가변 변수를 수정할 때, 위에 재할당 등의 수정이 되었었나 확인해야한다. final로 재할당(재사용)이 불가능한 불변 값사용하다가, 변수의 재사용이 필요할 경우 새 변수를 만들어서 쓰자. | . | 모든 지역변수, 인자에 final을 붙이자. . . | . final 객체의 내부 속성변화 메서드 -&gt; 변한 속성으로 만든 새 객체로 응답 . 객체의 경우는 final로는 완벽한 불변을 못만든다. . final 값와 달리 final 객체는 메소드 등에 의해 내부가 변할 수 있다.(포인터의 포인터에서 껍데기 포인터1) | . | 객체를 불변으로 만든 법상태변화를 일으키는 기능들은 새로운 객체를 반환하도록 정의하자. . 상태변화 시켰던 메서드의 void returnType에 해당 객체를 응답(return)하도록 수정 . public void move() { this.position++; } public Car move() { this.position++; } . | 변화된 상태로 new생성자()로 호출하여 -&gt; 새로운 객체를 반환시킨다. . public Car move() { return new Car(this.position + 1); } public Car(final int position) { this.position = position; } . | | . 객체, 컬렉션(껍데기포인터1)등은 응답시 copy해서 응답하라 . my) 포인터1의 포인터2에 의해 변경될 수 있으니, 껍데기 포인터1 자체를 copy해서 응답해라 . 컨밴션 중 하나가 된다. . final을 붙이는 것은 컨벤션이며 팀 안에서는 따르는게 좋을 수 도 있다. 내 생각에 타당하지 않으면 얘기를 꺼내서 바꿀 수 있다. | . | 컨벤션이라면, 비효율적이라도 그대로 가는 경우가 많다. 디자인 패턴 역시, 효율적이거나 좋은 코드라서 뿐만 아니라, 커뮤니케이션을 줄이는 컨밴션이기 때문에 좋기도 하다. | . | . 참고 글 . 후디 블로그 | . 객체를 객체스럽게 사용해라 . 아래와 같이 getter와 setter만 있는 객체를 구현하지 않는다. | setPosition()같은 setter 대신 move()의 역할로 분리해야한다. | getter()는 안쓰는게 좋은데, setter()는 100% 확정적으로 안쓰는게 좋다. setter() == 생성자 == pushed 로 외부에서 주입은 X | 특히 불변객체의 경우는 속성 변화 -&gt; 새 객체로 응답해야하니, setter란 개념이 없다. | . | view에서 사용하는 getter()는 필수적이다. view에서 getter()안쓰기 위해 toString() 쓰는 것은… 좀 아니다. | getter()쓰지마라라는 말은 도메인에서 getter() 쓰는 대신, 객체에 메세지를 던지면서 협력하라는 뜻이다. | 객체를 직접 사용하지말고, View에서는 dto로 값만 꺼내써라 | . | Q. view에서 cars.get(0).getPosition()은 가능한가요? . my) 디미터법칙 위반이다 -&gt; 책임을 2번째 놈에게 위임해야됌 . | index 0 은 무엇을 말하는지 모른다. . | 가져오려는 이유가 무엇인지 부터 물어보고 싶다. . 우승자를 구하려는 이유라면 메세지를 던지는 식으로 바꿔보자. cars.getWinners() | . | . | .get + .get이 이어지는 경우가 있는데 의심을 해봐야한다. . 점 1개로 줄이도록 해보자. . cars.getFirst().getPosition(); cars.getFirstPosition(); . | 첫번째 포지션 -&gt; 의미가 애매하다 -&gt; 위너로 바꾸자. . cars.getWinners(); . | . | . | . 객체.getXXX()대신 new XXX( 객체 )를 던지는 클래스로 만드는 방법도 . **getter()대신 객체를 생성자로 던져 class를 만들어볼까? ** . new Winner(cars); . | . 객체를 던졌어도, 객체.setter() 등의 주입 대신 역할위임을 하자. . public class Racing { ... public int run(Car car) { int num = random.nextInt(11); int position = car.getPosition(); if (num &gt;= 4) { position++; } car.setPosition(position); return position; } } . car.setPosition(position);대신에 car 내부로 역할이 위임되어서 내부에서 했으면 좋겠다. | . 인변의 접근제한자는 private으로 고정 -&gt; 객체상태에 대한 접근은 제한 . getter()도 지금 허용할까말깐데.. 인변에 접근은 절대 안시킨다. | . . 그렇다면 public, protected는 왜 있는 걸까? 과거에는 의도가 있어서 만들었는데, 요즘에는 필요없다고 느껴졌을 수 가 있음. | 과거에는 왜 여러 접근제한자를 만들었을까? | public으로 열여있으면, getter/setter 동시허용이나 마찬가지다. 어디서든 접근하면 -&gt; 불안해야 한다. | 이 역할만 하면 좋겠다. | 변수를 public으로 열어두면, 변했는지 안했는지 직접 보고 확인해야하는 비용이 든다. | 변수를 public으로 열어두지말고, method를 열어주어 캡슐화된 속성변화를 만들어내자. | . | . | . (내부)랜덤요소는 단위 테스트하기 힘들다. . 내부에 random은 테스트하기 힘들다. . . | . 밖에서 받아오는 메서드로 변경한다. . 테스트하기 힘든 내부 랜덤은 일단 밖에서 주어지는 파라미터로 변경 한다. . 파라미터 추출 단축키 ctrl+shit+P | . public void move() { if (getRandomNo() &gt;= 4) { this.position++; } } car.move(); . public void move(final int number) { if (number &gt;= 4) { this.position++; } } car.move(car.getRandomNo()); // 자동으로 메서드의 인자도 바뀐다. . | 문제점: 밖에서 받아오는 랜덤이 . 단일객체.move( 밖 ) | 일급컬렉션.move( 밖 ) cars.forEach( car -&gt; car.move( 밖 ) ) -&gt; .. | . | 일급컬렉을 사용하는 클래스에서도 ( 밖 ) | 어디 밖까지 빼서 받아올지가 끝이 없다 -&gt; 적절한 경계를 잡아준다. | . | 질문: . car.move ( 밖 )도 테스트 했는데, cars.move ( 밖 ) 도 테스트해야할까? 마음의 평화가 중요함. 자기가 생각해 봐야함. | . | 리뷰어에게는 설계가 담근 readme의 링크와 같이 보낸다. | . | 받아오는 인자를 전략메소드를 가진 인터페이스로 변경하여 -&gt; 랜덤외에 구상 전략객체들도 입력가능하게 만든다. . public interface MovableStrategy { boolean isMove(); } . 인변 수는 최소화한다. . 최대 2개 정도로… . | 기존 인변으로 만들어낼 수 있는 것은, 변수로 선언하지 않는다. . public class RacingGame { private List&lt;Car&gt; cars; private List&lt;String&gt; winners; . | my) 인변으로 둔다 -&gt; 바깥에서(or default값으로) 받아와 알고있고, 의존해야하는 것 . 그게 아니라면, 시간이 좀 걸리더라도, 기존 인변들도 만든다. | 관리포인트를 늘리면 좋은가? 그냥 그때그때 실시간으로 만드는게 좋은 것 같다. | 현대에는 메모리/컴퓨팅 비용성능 «&lt; 인력의 유지보수성 | DB를 이용하는 시점에서 변수 -&gt; 성능을 위한 캐싱을 하기도 한다. | . | . ### setter는 사용을 자제해라 -&gt; 생성자에서 초기화 후 더이상 변경안한다. . 인스턴스 변수는 생성자 초기화 후에 불변을 유지하기 위해 setter는 사용을 자제한다. | setter의 문제점은? 역할을 하지 못하게 된다. | 어디서든 변경되어 -&gt; 내 의도와 다르게 동작한다. | 유지보수성이 떨어진다. | . | . 비즈니스 로직과 UI 로직의 분리 . View관련 코드는 도메인에 넣지말라는 소리 . 90%는 도메인에 View관련 코드를 넣었었다. . public class Car { private int position; ... private void print(int position) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; position; i++) { sb.append(&quot;-&quot;); } System.out.println(sb.toString()); } } . | . | 리뷰를 받으면서 점점 분리한다. . | 왜 분리할까? 그냥 출력하도록 도메인에서 메서드 만들면 되는거 아닌가? . getter쓰지말라고 해서 -&gt; 객체.역할부여()로 출력역할 만들었더니 | 역할부여는 도메인 &amp;&amp; getter없이 하는게 맞지만, 변경이 자주 일어나는 view로직을 예외다. | . | View관련 로직 . 출력관련 역할부여(책임)를 도메인에서 안시킨다. 아예 정의하지말고 도메인은 객체만 넘겨라. . 출력 책임은 객체가 가지게 하지마라 | &lt;변경 빈번&gt; UI변경 -&gt; &lt;변경없어야할 소중한, 중요도가 높은&gt; 도메인에 여파를 일으키면 큰일이 나기 때문 | . | dto로 getter로 값만 꺼내쓰게 할 것이다 . | . | . Collection 활용 로직 처리 . Car 목록에서 최종 우승자를 구하는 로직이다. 이 코드를 Collection 기능을 사용해 어떻게 리팩터링할 것인가? . public class ResultView { private Cars cars = null; private String getTopRankedCar(List&lt;Car&gt; carList) { String topCarString = &quot;&quot;; cars = new Cars(carList); int maxPosition = getMaxPosition(carList); for (int i = 0; i &lt; carList.size(); i++) { if (cars.getPosition(i) == maxPosition) { topCarString += cars.getCarName(i) + &quot;, &quot;; } } return topCarString.substring(0, topCarString.length() - 2); } private int getMaxPosition(List&lt;Car&gt; carList) { int maxPosition = 0; cars = new Cars(carList); for (int i = 0; i &lt; carList.size(); i++) { if (maxPosition &lt; cars.getPosition(i)) { maxPosition = cars.getPosition(i); } } return maxPosition; } } . | . 기본 api를 이용해서 다짜지 말자 . Collection을 활용해 로직을 구현할 때 직접 구현하려 하지 말고 먼저 Collection API를 통해 해결할 수 있는 방법이 있는지 찾는다. 방법을 찾았는데 해결 방법을 찾지 못하는 경우만 직접 구현한다. . . 경계값을 테스트한다. . 다 하는게 아니라 경계값만 테스트 . 모든 테스트 X | . @Test public void 랜덤숫자가_4이상일때만_움직인다() { Car car = new Car(); assertFalse(car.shouldMove(0)); assertFalse(car.shouldMove(1)); assertFalse(car.shouldMove(2)); assertFalse(car.shouldMove(3)); assertTrue(car.shouldMove(4)); assertTrue(car.shouldMove(5)); assertTrue(car.shouldMove(6)); assertTrue(car.shouldMove(7)); assertTrue(car.shouldMove(8)); assertTrue(car.shouldMove(9)); } . | . 테스트 픽스처 생성 . 테스트를 반복적으로 수행할 수 있게 도와주고 매번 동일한 결과를 얻을 수 있게 도와주는 ‘기반이 되는 상태나 환경’을 의미한다. 여러 테스트에서 공용으로 사용할 수 있는 테스트 픽스처는 테스트의 인스턴스 변수 혹은 별도의 클래스에 모아 본다. . 중복제거를 위해 하면 된다. | junit의 @beforEach를 사용하면 된다. 테스트 픽스쳐의 일종이다. | . public class RacingGameTest { private final String[] testNames = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}; private final int testPosition = 5; private final String resultSamePositionString = &quot;, b&quot;; private final String resultWinnersString = &quot;a, b&quot;; RacingGame racingGame; private final Car firstWinner = new Car(testPosition, &quot;a&quot;); private Car secondWinner; private final List&lt;Car&gt; cars = new ArrayList&lt;Car&gt;(); ... } . | . 과정 실습 . 추후 미션이 진행 되면, 복잡해지고 객체가 많아질 경우, 코드를 분리해야됨. . @Test void move() { final Car car = new Car(&quot;재성&quot;); } . | 비슷한 환경의 테스트를 복사해서 case를 나눈다고 가정하자. . @Test void move_go() { final Car car = new Car(&quot;재성&quot;); } @Test void move_stop() { final Car car = new Car(&quot;재성&quot;); } . | 객체의 생성이 반복된다면, Generate &gt; Setup method를 선택해서 @BeforeEach를 생성하자. . @BeforeEach void setUp() { } @Test void move_go() { final Car car = new Car(&quot;재성&quot;); } @Test void move_stop() { final Car car = new Car(&quot;재성&quot;); } . | 공통되는 객체생성코드를 beforeEach로 뺀다 . @BeforeEach void setUp() { final Car car = new Car(&quot;재성&quot;); } @Test void move_go() { } @Test void move_stop() { } . | ctrl+.(show context action)을 눌러서 split declation and assignment를 통해 . 변수 선언은 변수재활용을 위해 클래스변수로 클래스변수에 넣고 매번 초기화한다 -&gt; 변수 재활용한다 -&gt; 변수 재할당한다 -&gt; final은 안된다. | . | 할당만 beforeEach에서 매 테스트마다 새로운 것으로 분리한다. | . @BeforeEach void setUp() { final Car car; car = new Car(&quot;재성&quot;); } . class ApplicationTest { //final Car car; // 매 테스트마다의 재활용 = 재할당 Car car; @BeforeEach void setUp() { car = new Car(&quot;재성&quot;); } . | 픽스쳐가 많아지면, 공통이 맞는지 확인한다. . | . 특정상태를 만들어주기 위한 반복코드 -&gt; 생성자로 상태 바로 만들기 . 과도하게 반복해서 만든다? . public class RacingGameResultTest { @Test public void check_ranking_if_correct() { List&lt;Car&gt; cars = new ArrayList&lt;&gt;(); Car car1 = new Car(&quot;pobi&quot;); Car car2 = new Car(&quot;crong&quot;); Car car3 = new Car(&quot;honux&quot;); car1.move(); car1.move(); car2.move(); car2.move(); car2.move(); car3.move(); cars.add(car1); cars.add(car2); cars.add(car3); ... } } . 단순반복의 경우, 반복문+메서드 호출로 해결할 수도 있지만, 그렇지 않은 경우가 많다. | 상태를 만들기 위해 복잡한 과정이 많은 경우, 상태를 바로 만들어주는 생성자를 만들 수 있다. 여기선, move()테스트가 아니라 우승자를 찾는게 목적이기 때문에, 목적 달성을 위해, 다른 것은 바로 상태를 만드는 생성자를 만들수 도 있음. | 현재는 move()호출방식에 따라 테스트가 의존하여, 변하면 테스트코드가 깨질 수 도 있다. | 테스트를 위해 생성자를 만들지만, 그게 진짜 테스트만을 위한 코드인지 생각해봐야한다. | . | . public Car(final String name, final int position) { this.name = name; this.position = position; } List&lt;Car&gt; cars = new ArrayList&lt;&gt;(); // Car car1 = new Car(&quot;pobi&quot;); // Car car2 = new Car(&quot;crong&quot;); // Car car3 = new Car(&quot;honux&quot;); Car car1 = new Car(&quot;pobi&quot;, 2); Car car2 = new Car(&quot;crong&quot;, 3); Car car3 = new Car(&quot;honux&quot;, 1); // car1.move(); // car1.move(); // car2.move(); // car2.move(); // car2.move(); // car3.move(); cars.add(car1); cars.add(car2); cars.add(car3); . 이 코드가 프로덕션 코드에서 사용되지 않더라도, 객체관점+객체역할에서 봤을 때, 테스트를 위한 기능이 아닐 수 있다. 객체 관점에서 자연스러우면 괜찮다. | position default값을 지정해주는 관점에서 괜찮다. | . | 테스트만을 위한 메서드추가는 문제가 더 큰데, 생성자는 객체를 만드는 방법일 뿐이므로 생성자는 많아도 괜찮다. 충분히 납득이 가능하다. | . | . | 생성자는 여러개 만들면, 인자 많은 것을 주생성자로 취급하고 인자 적은 생성자 -&gt; 위쪽에 위치하고 default값을 this에 넣어주는 부생성자 . // 부 생성자는 주 생성자(name, position)보다 더 앞에 위치하며, 뒤쪽의 주 생성자를 this( , )로 사용한다. public Car(final String name) { this(name, 0); } public Car(final String name, final int position) { this.name = name; this.position = position; } . | 생성자가 너무 많아지거나, 같은 시그니쳐 or 이름을 주고 싶을 때 -&gt; 정팩메로 분리 고려 . | . getter없이 구현 가능? . setter/getter 메서드를 사용하지 말라는 것은 핵심 비지니스 로직을 구현하는 도메인 객체를 의미한다. 도메인 Layer -&gt; View Layer, View Layer -&gt; 도메인 Layer로 데이터를 전달할 때 사용하는 DTO(data transfer object)의 경우 setter/getter를 허용한다. . | 아예 없이 toString으로 구현하는 분들도 있지만, 도메인 Layer에서 사용하는 getter를 만들지마라 == 비즈니스 로직를 위한 getter를 이용하지마라 . 도메인 대신 DTO 구현시 getter/setter는 허용한다. . | DTO라도 setter는 생성자에서 초기화하는 것으로 대신한다. | view에서는 열어야한다. | . | 접근제한자는 최소한으로 열고 시작한다. . | getter로 받아와서 하지말고, 역할을 부여해서 시키는 것 -&gt; 그래야 협력한다. . | . 객체안에서 toDTO를 만들지마라 . 내부에서 toDto()를 만든다? 모델에서 DTO를 알면 왜 안좋을까? | DTO는 뷰에 종속적인 객체 -&gt; view처럼 변경이 많다 -&gt; 도메인에 영향을 줌 | 객체 안에서 DTO를 생성하지마라 | 객체는 밥줄이라 아껴야하고, DTO는 막쓴다. | . | . 테스트를 위한 코드는 구현코드에 분리 . 테스트용 편의 메서드를 구현 코드에서 구현하지마라 | . 생성자로 주입하는 건 괜찮고, setter는 안좋냐? . 똑같은 내부 코드(행위)보다는 역할이나 시점을 봐야한다. | setter가 하나라도 존재하면 내부 상태변화 기능.move()을 따로 가지는 객체지만, 객체를 믿을 수 없게 된다. 기능으로 내부 변하는 것도 좀 그런데… 언제든지 변화시키는 믿을 수 없는 객체가 된다. | . | .",
            "url": "blog.chojaeseong.com/java/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/23/%EA%B0%95%EC%9D%98_%EB%A0%88%EB%B2%A81_1%EB%8B%A8%EA%B3%84_%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_%EB%84%A4%EC%98%A4_%EA%B0%95%EC%9D%98(%EC%99%84).html",
            "relUrl": "/java/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/23/%EA%B0%95%EC%9D%98_%EB%A0%88%EB%B2%A81_1%EB%8B%A8%EA%B3%84_%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_%EB%84%A4%EC%98%A4_%EA%B0%95%EC%9D%98(%EC%99%84).html",
            "date": " • Feb 23, 2022"
        }
        
    
  
    
        ,"post51": {
            "title": "Console 입력-검증-생성자 정리",
            "content": "콘솔 프로그램 입력/검증/생성자 . 자동차경주 1,2차 피드백(1단계 미션)후 콘솔입력 -&gt; 검증 -&gt; 개별 모델 생성자 구조를 생각해보았다. . | 아직 Dto - domain 의존은 해결되지 않은 상황 . 나중에 참고할 것: DTO를 의존 하는 domain 문제 PR | . | . InputView . 재활용 SCANNER . 스캐너를 사용하는 public static getInput() . private static final Scanner SCANNER = new Scanner(System.in); public static String getInput() { return SCANNER.nextLine(); } . | 4단계 InputView.getXXX() . 개별 모델input들을 의미하는 getXXX()는 4단계로 구성됨. . public static List&lt;String&gt; getCarNames() { OutputView.printRequestInstruction(REQUEST_CARS_NAME); List&lt;String&gt; carsName = Arrays.stream(getInput().split(SPLIT_DELIMITER, -1)) .map(String::trim) .collect(Collectors.toList()); Validator.validateCarNames(carsName); return carsName; } public static String getRound() { OutputView.printRequestInstruction(REQUEST_ROUND_VALUE); String inputRound = InputView.getInput(); Validator.validateInputNumber(inputRound); return inputRound; } . OuputView.print( 안내메세지 ) . | 스캐너를 사용해서 받은, 복수형이면 split(,-1) by Arrays.stream( ).map().collect() / 단수형이면 그냥 . List&lt;String&gt; or String | . | 복수형이면 실제이름XXXX를 붙이고 / 단수형이면 Input(String) or InputNumber(StringNumber)를 붙인 . Input루트의 공통검증: Validator.validate~ -&gt; 재료는 List&lt;String&gt; 아니면 String(Number)로 무조건 String타입을 검증대상으로 보게 정했다. . 복수형이면 check복수형(개별Empty, 중복) -&gt; for validateInput or validateInputNumber의 단수 공통검증 . private Validator() { // 유틸클래스는 따로 객체생성안한다는 private생성자로 표시 } public static void validateCarNames(List&lt;String&gt; carNames) { checkCarNamesEmpty(carNames); checkDuplicated(carNames); for (String carName : carNames) { validateInput(carName); } } . | 단수형이면 String이냐 StringNumber냐에 따라서 다르게 . String: NullOrEmpty + IncludeBlank | StringNumber: NullOrEmpty + Format(넣으면 IncludeBlank안넣어도 된다) | private static void validateInput(String carName) { checkNullOrEmpty(carName); checkIncludeBlank(carName); } public static void validateInputNumber(String inputRound) { checkNullOrEmpty(inputRound); checkValidFormat(inputRound); } . | | | return List&lt;String&gt; or String(2번) . | | Controller . try/catch . 입력받을 때, 입력 예외발생시 다시 입력받기 받으려면 **getXXXX()가 ** . 검증을 포함하는 부분시켜서 | 재귀호출하는 하도록 메서드화되어 있고 그부분을 try/catch로 쌓여있여있어야하는데, | . | getXXX() + 받아서 모델의 (정펙매)생성자 호출하는 과정까지 try/catch로 감싸면, 도메인 자체검증도 try/catch의 재귀에 걸려 도메인 자체검증 예외발생시에도 재입력받을 수 있게 된다. . 객체 생성로직( 자체 검증 -&gt; 객체 생성)까지 포함시켰으니, 해당 메서드는 try성공시 객체를 returnType으로 | . private Cars getCars() { try { return Cars.fromInput(InputView.getCarNames()); } catch (IllegalArgumentException e) { OutputView.printErrorMessage(e); return getCars(); } } private Round getRound() { try { return Round.fromInput(Integer.parseInt(InputView.getRound())); } catch (IllegalArgumentException e) { OutputView.printErrorMessage(e); return getRound(); } } . RacingGame racingGame = RacingGame.createRacingGame( getCars(), getRound(), new RandomNumberGeneratePolicy() ); . | . Controller getXXX(): InputView.getXXX() 응답 String -&gt; convert+생성자객체생성+try/catch . 대신, 중간에 필요한 객체의 생성자까진 노출할 필요는 없다. . public class RacingGameController { public void startRacing() { RacingGame racingGame = RacingGame.createRacingGame( getCars(), // InputView의 getXXX()는 무조건 String -&gt; 중간 객체(Name)도 다 노출... private Cars getCars() { try { return Cars.fromNames(Names.fromInput(InputView.getCarNames())); . 지금은 Cars를 만들기 위해 Names의 존재를 알아야 하는 상황인데요, 사실 Names는 Cars 안에서만 사용되고 있죠. 그렇다면 Names의 존재가 바깥에 노출될 필요가 있을까요? 구현을 드러내고 있는 건 아닐까요? 원시값 포장한 것은 굳이 생성자를 안드러내도 된다. | . | . private Cars getCars() { try { return Cars.fromInput(InputView.getCarNames()); public static Cars fromInput(List&lt;String&gt; InputNames) { Names names = Names.fromInput(InputNames); return new Cars(names.getNames( . | . 생성자 . 01 private 기본생성자 . 복수( List&lt;단일&gt;) ex&gt; Cars . private Cars(List&lt;Car&gt; cars) { this.cars = cars; } . 단일객체 (포장객체들, Name+Position ) ex&gt; Car . private Car(Name name) { this.name = name; this.position = Position.from(DEFAULT_POSITION_VALUE); } . 일급컬렉션 (List&lt;원시&gt;) ex&gt; Names . private Names(List&lt;Name&gt; names) { this.names = names; } . StringNumber (int ) ex&gt; Round . private Round(int roundNum) { this.roundNum = roundNum; } . String (String ) ex&gt; Name . private Name(String name) { this.name = name; } . 복수Dto (List&lt;CarDto&gt;) ex&gt; CarsDto . private CarsDto(final List&lt;CarDto&gt; carsDto) { this.carsDto = carsDto; } . 단일Dto (원시값들) ex&gt; CarDto . public CarDto(String name, int position) { this.name = name; this.position = position; } . 02 .fromInput ( only String or List&lt;String&gt; ) . inputView에서 기본검증을 거치고 난 뒤, 자체 검증만 필요한 친구들 만약, stream.map 단일객체생성자 등장시 -&gt; 단일객체로 검증이 옮겨짐 | . | . 복수( List&lt;단일&gt;) ex&gt; Cars . public static Cars fromInput(List&lt;String&gt; InputNames) { Names names = Names.fromInput(InputNames); return new Cars(names.getNames().stream() .map(Car::fromName) .collect(Collectors.toList())); } . 단일객체 (포장객체들, Name+Position ) ex&gt; Car . // . 일급컬렉션 (List&lt;원시&gt;) ex&gt; Names . 자체검증하는 대신, stream상에서 단일객체에서 검증이 옮겨짐. | . public static Names fromInput(List&lt;String&gt; names) { return new Names(names.stream() .map(Name::from) .collect(Collectors.toList())); } . StringNumber (int ) ex&gt; Round . public static Round fromInput(int inputRound) { validateRound(inputRound); return new Round(inputRound); } . String (String ) ex&gt; Name . // . 복수Dto (List&lt;CarDto&gt;) ex&gt; CarsDto . // . 단일Dto (원시값들) ex&gt; CarDto . // . 03 .from( 원본재료 ) . 복수 . input없이 프로덕션내부 or 테스트에서 사용된다. -&gt; 유틸화된 공통검증 + 자체 검증 만일, 원본재료가 포장된 객체라면, 자체검증은 포장객에게 갈 수 있다. | . | . public static Cars from(List&lt;Car&gt; cars) { return new Cars(cars); } . VO 는 .from(원본 1개만) . 정팩메 1개 -&gt; input이지만 .from + 유일 자체 검증 생성자 | . public static Position from(int position) { validatePosition(position); return new Position(position); } . 복수( List&lt;단일&gt;) ex&gt; Cars . test코드에서 Car -&gt; Cars로 바로 생성하기 위해 | . public static Cars from(List&lt;Car&gt; cars) { return new Cars(cars); } . 단일객체 (포장객체들, Name+Position ) ex&gt; Car . 일급컬렉션, 복수 쪽에서는 stream을 통해 원본 List -&gt; 단일객체 List -&gt; 일급으로순으로 가기도 한다. | . public static Car fromName(Name name) { return new Car(name); } . 일급컬렉션 (List&lt;원시&gt;) ex&gt; Names . test코드용 | . public static Names from(List&lt;Name&gt; names) { validateNames(names); return new Names(names); } . StringNumber (int ) ex&gt; Round . test를 안하고, controller에서 마지막에 convert시킬거라을 input원본 받을일이 없음. | . // . String (String ) ex&gt; Name . 복수, 일급컬렉션의 Names에서 stream으로 만들어지는 과정 | 테스트용 | . public static Name from(String name) { checkValidLengthOfName(name); return new Name(name); } . 복수Dto (List&lt;CarDto&gt;) ex&gt; CarsDto . 일급컬렉션 내부에서 toDto()호출시 ** List&lt;단일&gt; **유일 필드-&gt; List&lt;단일Dto&gt; 변환후 기본생성자로 복수Dto로 만들어줌 -&gt; from일급컬렉 | 공통적인 기본 private List&lt;단일Dto&gt;를 호출해줄 public -&gt; .from | public static CarsDto fromCars(final List&lt;Car&gt; cars) { //todo: 5. cars -&gt; carsdto의 정펙메( List&lt;Car&gt; ) -&gt; List&lt;CarDto&gt; -&gt; 일급 생성자 // carsDto의 생성자는 car list(cars)를 받아서 -&gt; cardto list -&gt; 일급 dto를 만드는 곳 final List&lt;CarDto&gt; carDtos = cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList()); return new CarsDto(carDtos); } public static CarsDto from(final List&lt;CarDto&gt; carsDto) { return new CarsDto(carsDto); } . 단일Dto (원시값들) ex&gt; CarDto . 복수or일급컬렉션에서 stream에서 Car -&gt; CarDto시 사용될 .from원본( 1:1원본) | OuputView 테스트에서 원시값 필드들로 생성하는단일Dto -&gt; 복수Dto | public CarDto(String name, int position) { this.name = name; this.position = position; } .",
            "url": "blog.chojaeseong.com/java/console/input/validation/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/22/%EC%BD%98%EC%86%94%EC%9E%85%EB%A0%A5_%EA%B2%80%EC%A6%9D_%EC%83%9D%EC%84%B1%EC%9E%90(%EC%99%84).html",
            "relUrl": "/java/console/input/validation/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/22/%EC%BD%98%EC%86%94%EC%9E%85%EB%A0%A5_%EA%B2%80%EC%A6%9D_%EC%83%9D%EC%84%B1%EC%9E%90(%EC%99%84).html",
            "date": " • Feb 22, 2022"
        }
        
    
  
    
        ,"post52": {
            "title": "DTO 단계별 적용(자동차경주)",
            "content": "단일DTO . 참고 DTO 쓴 PR | . 01 Controller의 OutputView.print( )에 List&lt;단일Dto&gt; 반환해주기 . OutputView.printResultEveryRound(racingGame.getCurrentCars()); . 관리자객체에서도 List&lt; 단일객체 &gt;나오는 일급에 들어가지 않았으므로 그대로 여기서 return될 타입이 List&lt; 단일Dto &gt;를 예상하자 | . public List&lt;CarDto&gt; getCurrentCars() { return this.cars.getCurrentCars(); } . 02 일급 속 List&lt;단일객체&gt;를 stream.map으로 List&lt;단일Dto&gt;로 변환 . public List&lt;CarDto&gt; getCurrentCars() { return this.cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList()); } . 03 Dto 변환 정펙메는 from(단일객체) -&gt; 모든 속성들 원시값까지 나눠서 get . 이 때, Car는 VO Name, Position이라도, Dto의 속성 및 getter()는 순수 원시값만 가지고 뱉어낸다. 예를 들어, car.getName()은 Name(VO) return이 아니라 this.name.getName()의 원시값을 return해야 CarDto가 생성자에서 개별속성들을 원시값으로 받아먹을 수 있다. | . | . public class CarDto { private final String name; private final int position; public CarDto(String name, int positiion) { this.name = name; this.position = positiion; } public static CarDto from(Car car) { return new CarDto(car.getName(), car.getPosition()); } public String getName() { return this.name; } public int getPosition() { return this.position; } } . 04 OutputView는 List&lt;단일Dto&gt;를 받아서 getter들로 출력 로직 작성 . public static void printResultEveryRound(List&lt;CarDto&gt; currentCars) { for (CarDto currentCar : currentCars) { System.out.println(currentCar.getName() + &quot; : &quot; + collectDash(currentCar.getPosition())); } System.out.println(); } . 일급Dto . 01 일급.toDto()를 통한 List&lt;단일Dto&gt;자리를 일급Dto로 교체 . 단일Dto는 List -&gt; steram -&gt; map 가운데만 등장했으나 | 일급Dto는 this.일급.toDto()의 책임이 주어진다. | . public CarsDto getCurrentCars() { //return this.cars.getCurrentCars(); return this.cars.toDto(); . 02 일급Dto 정펙매 공식 재료는 일급 내부에 있는 List&lt;단일객체&gt; (No List&lt;단일Dto&gt;) . 단일Dto는 Car가 모르고, 내부에서 이용안한다. Cars내부에서 List&lt;CarDto&gt; 만들 때 map에서 사용된다. | 일급Dto는 Cars가 알고 이용하여, 내부에서 변환환다. | 일급내부의 단일객체 List만 건네주면, 내부에서 단일Dto -&gt; 일급Dto 한번에 변환후 생성 다해준다. List&lt;단일Car&gt; —정팩메List&lt;단일Dto&gt;—&gt; CarsDto | . | . // todo: 4. Cars의 toDto()함수는 &lt;&lt;Cars내부지만 CarsDto를 알고, 의존하여&gt;&gt; [CarsDto의 정팩메]를 호출 Cars -&gt; CarsDto로 변환한다. // my) Cars는 CarsDto와 그 정팩메를 알고 있다! public CarsDto toDto() { return CarsDto.fromCars(cars); // from List&lt;단일객체CarDto&gt; vs from다른것 Cars } . 일급Dto 정펙매의 재료가 List&lt;단일Dto&gt;가 아니라 List&lt;단일객체&gt;만 있으면, 내부에서 단일Dto List -&gt; 일급Dto까지 간다. | . public static CarsDto fromCars(final List&lt;Car&gt; cars) { // 필요재료가 List&lt;단일Dto&gt;가 아니라 List&lt;단일객체&gt;만 있으면, 내부에서 단일Dto List -&gt; 일급Dto까지 간다. final List&lt;CarDto&gt; carDtos = cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList()); return new CarsDto(carDtos); } . 03 일급Dto의 getter 네이밍은 get()으로 줄여주자. . 안줄이면. XXXsDto.getXXXsDto() -&gt; get으로 네이밍 줄여주기 | 단일Dto는 개별속성 getter()가 목적이라 Dto.get속성() | . public List&lt;CarDto&gt; get() { return carsDto; } . 04 OutputView내부 List&lt;단일Dto&gt; 사용 -&gt; 일급Dto.get() . //public static void printRacingRecord(List&lt;CarDto&gt; cars) { // for (CarDto car : cars) { public static void printRacingRecord(CarsDto carsDto) { for (CarDto car : carsDto.get()) { . DTO테스트 . 01 Dto를 사용하는 OutputView의 Test로 테스트한다. . ByteArrayOutputStream 변수 + setOut에 설정하기 차후 print명령을 내놓고 -&gt; output.toString()에서 확인하기 | . | . private final ByteArrayOutputStream output = new ByteArrayOutputStream(); @BeforeEach public void setUp_streams() { System.setOut(new PrintStream(output)); } . 02 [원시속성들]로 단일Dto 만드는 깡통 [정펙매of ] 정의 . 메서드로만 변환되는 deafult값의 position필드도 다 받도록 한다. (Dto는 깡통) | 1개 이상의 속성들을 받아야하므로 .of()의 정펙매로 개발한다. | . public static CarDto of(final String name, final int position) { return new CarDto(name, position); } . 03 프로덕션에 없던, 일급Dto의 정펙매from ( List&lt;단일Dto&gt;) 정의 . 프로덕션에서는 일급내부 List&lt;단일&gt; —일급Dto정펙매–&gt; (List&lt;단일Dto변환 -&gt;) 일급Dto 테스트에선 단일Dto 출발 -&gt; List&lt;단일Dto&gt;를 받아 일급Dto 생성해줄 정펙매 필요함. | . | . public static CarsDto from(final List&lt;CarDto&gt; carsDto) { return new CarsDto(carsDto); } . 04 output.toString()은 변수로 못받는다. 바로 확인 . //given final CarsDto carsDto = CarsDto.from(Arrays.asList(CarDto.of(&quot;재성&quot;, 1), CarDto.of(&quot;재경&quot;, 1))); //when: output.toString을 이후 actual변수에 따로 못받음. OutputView.printRacingRecord(carsDto); //then assertThat(output.toString()).contains(&quot;재성 : -&quot; + System.lineSeparator() + &quot;재경 : -&quot;); . final CarsDto carsDto = CarsDto.from(Arrays.asList(CarDto.of(&quot;재성&quot;, 1), CarDto.of(&quot;재2&quot;, 1))); // 우승자가 2명인 상황이라 가정해야됨. &gt; Winner들만 모인 CarsDto를 넘겨받는다. OutputView.printRacingResult(carsDto); assertThat(outputStream.toString()).contains(&quot;재성, 재2가 최종 우승했습니다&quot;); .",
            "url": "blog.chojaeseong.com/java/dto/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/22/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_DTO_%EB%8B%A8%EA%B3%84%EB%B3%84-%EC%A0%81%EC%9A%A9(%EC%99%84).html",
            "relUrl": "/java/dto/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/22/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_DTO_%EB%8B%A8%EA%B3%84%EB%B3%84-%EC%A0%81%EC%9A%A9(%EC%99%84).html",
            "date": " • Feb 22, 2022"
        }
        
    
  
    
        ,"post53": {
            "title": "동일성vs동등성(equals, hashCode)",
            "content": "동일(ㅣ)성 = (I)dentity = 메모ㄹ(ㅣ)주소 . 반대로 동등성 = equality = 정해준 값이 같은지 . | equals는 equality가 아닌메모리 주소(identity) 비교가 default라서 오버라이딩 해야한다. . == = 메모리 주소로 비교 = default equals . public boolean equals(Object obj) { return (this == obj); } . | = = 값으로 비교 = 오버라이딩 equals . | . | . 세팅 . public class Car { private final String name; private int position; // 부 생성자는 주 생성자(name, position)보다 더 앞에 위치하며, 뒤쪽의 주 생성자를 this( , )로 사용한다. public Car(final String name) { this(name, 0); } public Car(final String name, final int position) { this.name = name; this.position = position; } } . 오버라이딩 전 default equals -&gt; 메모리비교 . @Test void before_overriding_equals_test() { //1. 오버라이딩 전 deafult equals : 같은 메모리 주소만 true final Car 재성 = new Car(&quot;차&quot;); final Car 석영 = new Car(&quot;차&quot;); assertThat(재성).isEqualTo(석영); //Expected :domain.Car@29647f75 //Actual :domain.Car@355ce81c // -&gt; 서로 다른 객체(메모리주소)를 가져서 deafult equals로는 같다고 할 수 없음. } . 오버라이딩후 equals -&gt; 지정한 값으로 비교 . final Car 재성 = new Car(&quot;차&quot;); final Car 석영 = new Car(&quot;차&quot;); assertThat(재성).isEqualTo(석영); // true . hashCode도 같이 오버라이딩 하는 이유? . hashCode메서드는 실제 메모리 주소 -&gt; 정수값으로 반환해주는 함수이다. 자료구조 등에 사용될 때, 이 hashCode기준으로 같냐/틀리냐를 판단한다. | . | 값 같으면 -&gt; 같은 객체를 만족시켜주기 위해서는 같다의 기준을 바꿔줬었다. 같다의 기준을 메모리 주소 비교 -&gt; 값 비교로 equals 오버라이딩으로 바꿔줘야했지만, | . | 이번엔 자료구조 등이 받아서 읽을해쉬코드 기준을 객체의 메모리주소정수 반환이 아닌 -&gt; 객체(Car)가 가진 값(name)의 메모리 주소 정수 반환로 바꿔준다. cf) 값의 메모리주소 -&gt; 같은 문자열이면 다 같다 | . | . 자료구조들도 같은 객체로 인식 . 쉽게 말해서, 반환되는 hashCode도 값 기준으로 바꿔서, 값 같다 -&gt; 객체의 해쉬코드 같다를 만들어버린다. . 그렇지 않으면, equals는 True로 나올지 몰라도, 자료구조는 다른 객체로 인식하는 상태가 된다. | . @Test void before_overriding_hashcode_test() { final Car 재성 = new Car(&quot;차&quot;); final Car 석영 = new Car(&quot;차&quot;); final HashSet&lt;Car&gt; set = new HashSet&lt;&gt;(); set.add(재성); set.add(석영); assertThat(set.size()).isEqualTo(1); //Expected :1 //Actual :2 // hashCode를 객체기준-&gt;값기준으로 정의해주지 않으면, 자료구조들은 다른 객체로 인식한다. } . hashCode오버라이딩 후 | . @Test void after_overriding_hashcode_test() { //2. final Car 재성 = new Car(&quot;차&quot;); final Car 석영 = new Car(&quot;차&quot;); final HashSet&lt;Car&gt; set = new HashSet&lt;&gt;(); set.add(재성); set.add(석영); assertThat(set.size()).isEqualTo(1); // true } .",
            "url": "blog.chojaeseong.com/java/equals/hashcode/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/%EB%8F%99%EC%9D%BC%EC%84%B1%EA%B3%BC-%EB%8F%99%EB%93%B1%EC%84%B1(%EC%99%84).html",
            "relUrl": "/java/equals/hashcode/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/%EB%8F%99%EC%9D%BC%EC%84%B1%EA%B3%BC-%EB%8F%99%EB%93%B1%EC%84%B1(%EC%99%84).html",
            "date": " • Feb 21, 2022"
        }
        
    
  
    
        ,"post54": {
            "title": "java final 세팅과 사용법",
            "content": "final 키워드로 값의 변경을 막아라 . final 세팅 in IDE, 지역 변수, 메소드 파라미터 . 지역변수, 파라미터 모두 final로 생성되도록 하자 설정 &gt; Editor &gt; Code style &gt; java &gt; Code generation &gt; Make ~ final 체크박스 2개 | . | main 메소드 template 인 psvm의 인자에도 final을 붙혀준다. . 설정 &gt; live template or psvm 검색 &gt; final 붙여주기 | . . | . final 값 -&gt; 재할당을 막아 불변 . 메서드 내부에서 코드 중간에서 가변 변수를 수정할 때, 위에 재할당 등의 수정이 되었었나 확인해야한다. final로 재할당(재사용)이 불가능한 불변 값사용하다가, 변수의 재사용이 필요할 경우 새 변수를 만들어서 쓰자. | . | 모든 지역변수, 인자에 final을 붙이자. . . | final로 값을 초기화(선언후 할당)하는 방법은 2가지다 . //1. final변수 선언과 동시에 &amp;&amp; 할당 -&gt; final은 재할당 불가 -&gt; 변수재사용시 새객체 반환할 것 final int i = 2; i = 4; // java: cannot assign a value to final variable i //2. final변수 먼저 선언 -&gt; 이후 할당 // 생성자 등에서 값을 외부에서 받아와 추가 로직(convert or default 대입 등 특수 case(if) 존재)이후 초기화 final int number; number = 5; . | . final 객체 -&gt; 메서드로 내부 변화 가능 -&gt; 메서드를 항상 새 객체로 응답 . 객체의 경우는 final로는 완벽한 불변을 못만든다. . final 값와 달리 final 객체는 메소드 등에 의해 내부가 변할 수 있다.(포인터의 포인터에서 껍데기 포인터1) | . | 객체를 불변으로 만든 법상태변화를 일으키는 기능들은 새로운 객체를 반환하도록 정의하자. . 상태변화 시켰던 메서드의 void returnType에 해당 객체를 응답(return)하도록 수정 . // 내부변화되는 final 객체 public void move() { this.position++; } // 1. 일단 응답을 동일 객체로 만들어주기 public Car move() { this.position++; } . | 변화된 상태로 new생성자()로 호출하여 -&gt; 새로운 객체를 반환시킨다. . //2. 응답 객체를, 변화된 값으로 새로 만들어서 응답 -&gt; 내부 값은 변화 없다. public Car move() { return new Car(this.position + 1); } //3. 생성자를 통해 응답할 객체를 만들어준다. 내부 값의 변화는 없게 한다. public Car(final int position) { this.position = position; } . | | . final 메서드, 클래스 -&gt; 자식이 못 쓰게 . package domain; final public class FinalParent { final void finalMethod() { final String asdfasdf = &quot;asdfasdf&quot;; } } . package domain; //2. final 클래스는 자식이 상속이 안된다. // java: cannot inherit from final domain.FinalParent public class FinalChild extends FinalParent { //1. final 메소드는 자식이 오버라이딩 못된다. -&gt; 코어 부분에서 변경을 원치 않는 메소드를 명시할 때 사용 //java: cannot find symbol, symbol: class FinalParent @Override protected void finalize() throws Throwable { super.finalize(); } } . final 컬렉션(내부 변경api를 제공하는 껍데기포인터1) 등은 응답시 copy(unmodifiable) 해서 응답하라 . my) 포인터1의 포인터2에 의해 변경될 수 있으니, 껍데기 포인터1 자체를 copy해서 응답해라 | 컬렉션을 반환할 때, 메모리주소가 공유되니, 어디서든 같은 컬렉션이 변경되는 위험이 있다. copy해서 전혀 다른 메모리의 컬렉션으로 응답하자. | . | . List&lt;String&gt; names = List.of(); // unmodifiableList names.add(&quot;텍스트&quot;) // 예외발생 . - 내가 만든 일급컬렉션이라면 불변(내부 변화 기능 제공 않함)이 되겠지만, **일반 컬렉션이라면, 반환시 메모리주소가 공유된다. -&gt; `unmodifiableList`로 copy된 메모리를 반환시켜 테스트 등 변화가 발생하게 하자.** . 컨밴션 중 하나가 된다. . final을 붙이는 것은 컨벤션이며 팀 안에서는 따르는게 좋을 수 도 있다. 내 생각에 타당하지 않으면 얘기를 꺼내서 바꿀 수 있다. | . | 컨벤션이라면, 비효율적이라도 그대로 가는 경우가 많다. 디자인 패턴 역시, 효율적이거나 좋은 코드라서 뿐만 아니라 커뮤니케이션을 줄이는 컨밴션이기 때문에 좋기도 하다. | . | . 참고 글 . 후디 블로그 | .",
            "url": "blog.chojaeseong.com/java/final/%EB%8B%A8%EC%B6%95%ED%82%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/final_%EC%84%B8%ED%8C%85%EA%B3%BC_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/java/final/%EB%8B%A8%EC%B6%95%ED%82%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/final_%EC%84%B8%ED%8C%85%EA%B3%BC_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Feb 21, 2022"
        }
        
    
  
    
        ,"post55": {
            "title": "comparable vs comparator",
            "content": "참고 블로그1 | 참고 블로그2 | . 세팅 . public class Car { private final String name; private int position; public Car(final String name, final int position) { this.name = name; this.position = position; } public String getName() { return name; } public int getPosition() { return position; } } . 기준없이 정렬 . 기준없이 문자열 리스트 정렬 . 문자열은 값이므로 알아서 기준 없이 알아서 정렬된다. . @DisplayName(&quot;정렬기준 없이 문자열 리스트 정렬&quot;) @Test void noStandard_stringList_sort() { final List&lt;String&gt; strings = Arrays.asList(&quot;acd&quot;, &quot;abc&quot;, &quot;dca&quot;); // Collections.sort() 와 .reverse() Collections.sort(strings); System.out.println(strings); // [abc, acd, dca] Collections.reverse(strings); System.out.println(strings); // [dca, acd, abc] } . | String은 이미 내부에서 Comparable을 구현 -&gt; compareTo 오버라이딩 하여 정렬기준을 제시하고 있기 때문 . public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { //... public int compareTo(String anotherString) { byte v1[] = value; byte v2[] = anotherString.value; if (coder() == anotherString.coder()) { return isLatin1() ? StringLatin1.compareTo(v1, v2) : StringUTF16.compareTo(v1, v2); } return isLatin1() ? StringLatin1.compareToUTF16(v1, v2) : StringUTF16.compareToLatin1(v1, v2); } . | . 기준없이 객체 리스트 정렬 . 객체를 넣은 List는 아예 정렬 대상이 안되고 컴파일 에러가 난다. . | 반드시 먼저 정렬기준을 정해줘야한다. . @DisplayName(&quot;정렬기준 없이 객체 리스트 정렬&quot;) @Test void noStandard_carList_sort() { final List&lt;Car&gt; cars = Arrays.asList( new Car(&quot;재성&quot;, 1), new Car(&quot;재경&quot;, 2), new Car(&quot;아라&quot;, 3) ); //2. // no suitable method found for sort(java.util.List&lt;domain.Car&gt;) // method java.util.Collections.&lt;T&gt;sort(java.util.List&lt;T&gt;,java.util.Comparator&lt;? super T&gt;) is not applicable Collections.sort(cars); System.out.println(cars); Collections.reverse(cars); System.out.println(cars); } } . | . 객체에 정렬 기준 주기 . 01 sort()에 안넣어줘도 되는 수동 기준 Comparable . 수동적인 내부 기준인 만큼, 까봐야알고, 수정할려면 다 도메인 내부를 다 바꿔야한다. | . 자기자신 Type의 Comparable을 구현한다. . public class Car implements Comparable&lt;Car&gt; { . | 비교할 원시값Type에 맞게 compareTo를 재정의한다. . int면 Integer.compare( this.xxxx , other.xxxx ) | string이면, 내부 자기가 구현한 this.compareTo(other)를 사용 | . @Override public int compareTo(final Car otherCar) { return this.name.compareTo(otherCar.name); } . | .sort()만 해서 오름/내림차순 확인해보기 . @DisplayName(&quot;comparable -&gt; name 기준으로 객체 리스트 정렬&quot;) @Test void noStandard_carList_sort() { final List&lt;Car&gt; cars = Arrays.asList( new Car(&quot;재성&quot;, 1), new Car(&quot;재경&quot;, 2), new Car(&quot;아라&quot;, 3) ); //3. Collections.sort(cars); System.out.println(cars); // [아라 3, 재경 2, 재성 1] Collections.reverse(cars); System.out.println(cars); // [아라 3, 재경 2, 재성 1] } . | compareTo . 참고 블로그 | . 숫자형 비교 . 기준 값과 비교대상이 동일한 값일 경우 0 . | 기준 값이 비교대상 보다 작은 경우 -1 . | 기준 값이 비교대상 보다 큰 경우 1 . Integer x = 3; Integer y = 4; Double z = 1.0; System.out.println( x.compareTo(y) ); // -1 System.out.println( x.compareTo(3) ); // 0 System.out.println( x.compareTo(2) ); // 1 System.out.println( z.compareTo(2.7) ); // -1 . | . | 숫자형 중 Int의 비교 . compareTo() 대신 Integer.compare(, ) 사용 . int x = 4; int y = 5; Integer.compare(x,y); . | . | 문자열 -&gt; String클래스가 이미 오버라이딩 해놓은 compareTo()이용 . (첫글자 같으면서) 비교대상이 기준에 포함되면 -&gt; 길이의 차이를 return한다. . | (첫글자가 다르면서) 비교대상이 기준에 포함되면 -&gt; 서로 다른 문자열이 시작되는 위치(첫위치)에서 아스키코드 값 차이 . | 포함이 안되는 문자열끼리 비교는 그냥 첫글자의 아스키코드 차이 . String str = &quot;abcd&quot;; // 1) 비교대상에 문자열이 포함되어있을 경우 System.out.println( str.compareTo(&quot;abcd&quot;) ); // 0 (같은 경우는 숫자나 문자나 0을 리턴) System.out.println( str.compareTo(&quot;ab&quot;) ); // 2 System.out.println( str.compareTo(&quot;a&quot;) ); // 3 System.out.println( str.compareTo(&quot;c&quot;) ); // -2 System.out.println( &quot;&quot;.compareTo(str) ); // -4 // 2) 비교대상과 전혀 다른 문자열인 경우 System.out.println( str.compareTo(&quot;zefd&quot;) ); // -25 System.out.println( str.compareTo(&quot;zEFd&quot;) ); // -25 System.out.println( str.compareTo(&quot;ABCD&quot;) ); // 32 . | . | in stream: .집계( ::compareTo) 기준으로 바로 사용 가능 . .집계( 기준이 되어줄 메서드 )로 집계기준으로 바로 사용할 수 있다. | . list.stream() .max(Car::compareTo) .collect(Collectors ... ); . 단점: 정렬기준 변화시 모두 수정 + 까봐야 앎 + 네이밍 . 다른 개발자들이 implements Comparable&lt;Car&gt; 만 보고도어떤 기준으로 정렬될지 모른다. -&gt; 지식으로서 compareTo를 다 까봐야한다. | 그리고 이 기준이 바뀌지 않을 거라 장담할 수 없다. 구현부 compareTo를 하나하나 수정해줘야한다. | 네이밍 수정을 못함. compareTo보다 더 직관적인 네이밍 필요 | . 02 .sort( , ) 2번째 인자에 넣어주는 능동적 기준 Comparator . list.sort()의 첫번째 인자 혹은 Arrays.sort(, )나 Collections.sort(, )의 두번째 파라미터로 comparator를 받는 메소드가 오버로딩 되어있다. 따라서 수동적 기준인 natural ordering 으로 정렬하기 원할 경우, compareTo만 정의해서 기준으로 넣어주면 되고 | 정렬 기준을 동적으로 할당하고 싶을 경우, .sort( , )1~2번째 파라미터로 Comparator를 정의해서 전달하자. | . | . comparator 직접 구현 for 네이밍 . new Comparator롤 작성한 뒤-&gt; &lt;Car&gt;의 클래스만 입력해주고 -&gt; implements메소드 -&gt; compare만 선택한다. . new Comparator&lt;Car&gt;() . | **getter()도.. 들어가서.. 불러와서.. 비교시킨다. ** . 문자열이면, compareTo() String클래스꺼 | 인트면, Integer.compare() | . java new Comparator() { @Override public int compare(final Car o1, final Car o2) { return o1.getName().compareTo(o2.getName()); } }; . | 변수로 받아서 정렬기준 객체의 네이밍을 완성한다. . final Comparator&lt;Car&gt; carNameComparator = new Comparator&lt;&gt;() { @Override public int compare(final Car o1, final Car o2) { return o1.getName().compareTo(o2.getName()); } }; final Comparator&lt;Car&gt; carPositionComparator = new Comparator&lt;&gt;() { @Override public int compare(final Car o1, final Car o2) { return Integer.compare(o1.getPosition(), o2.getPosition()); } }; . | .sort( , )의 2번째 인자에 능동적으로 기준을 넣어준다. . Collections.sort(cars, carNameComparator); System.out.println(cars); // [아라 3, 재경 2, 재성 1] Collections.sort(cars, carPositionComparator); System.out.println(cars); // [재성 1, 재경 2, 아라 3] . | Comparator.api + getter() for 가장편함. . 따로 impl하거나 new 구현할 필요 없이, sort()의 2번째 인자에 바로 넣어준다. | Comparator.comparing() .reversed()를 붙혀 역순 지정가능 | . Collections.sort(cars, Comparator.comparing(Car::getName)); System.out.println(cars); // [아라 3, 재경 2, 재성 1] Collections.sort(cars, Comparator.comparing(Car::getName) .reversed()); System.out.println(cars); // [재성 1, 재경 2, 아라 3] Collections.sort(cars, Comparator.comparing(Car::getPosition)); System.out.println(cars); // [재성 1, 재경 2, 아라 3] Collections.sort(cars, Comparator.comparing(Car::getPosition) .reversed()); System.out.println(cars); // [아라 3, 재경 2, 재성 1] . Comparator.api + getter() in stream . max ( Comparator.comparingInt ( 클래스::getter )) . 정리 . Comparable 보다는 Comparator를 사용하여 정렬 기준만큼은 도메인에서 제외시켜 외부에 위치시켜 변경에 유연하게 만든다. | 외부에서는 comparable -&gt; compareTo -&gt; .sort() 수동적 내부 기준으로 정렬시 밖에서 보면 무엇을 기준으로 정렬되는지 모른다. . | Comparator 는 도메인 클래스에 변경을 가하지 않고도 변경에 유연해진다. | 정렬 기준을 코드 자체로 나타내기 때문에 협업에도 더 좋은 것 같다. | . | .",
            "url": "blog.chojaeseong.com/java/comparable/comparator/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/comparable_vs_comparator(%EC%99%84).html",
            "relUrl": "/java/comparable/comparator/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/comparable_vs_comparator(%EC%99%84).html",
            "date": " • Feb 21, 2022"
        }
        
    
  
    
        ,"post56": {
            "title": "git강의(upstream, git객체)",
            "content": "준의 git 강의 . upstream . . 기본적으로 최초push에서는 local -&gt; origin의 연결에 local에 대한 상대적 상류(upstream) 를 -u로 명시해줘야한다. . | -u는 --set-upstream으로 상대적인 상류를 표기한 것이다. . | . | 일반적으로 origin에 대한 origin이 upstream이라고 별칭한다. 미션repo(upstream) -&gt; fork repo(origin) -&gt; clone repo(local) | . | 최초 명시해준 것처럼 upstream은 downstream에 대해 상대적인 것이다. | . | 깃허브 초기 메세지 박스를 보면 -u가 있는데 상대적 상-하 관계를 설정하는 upstream설정을 요약한 단어다 . 없으면 push가 안된다. | 내 local의 remote인 origin이라는 원천이라는 upstream으로 사용한다 보통은 원천(origin)보다 위쪽(stream)은 없다. | 하지만, fork로 가운데origin이 생기면서, 원본 repo를별칭stream을 사용하게 된다. | 우테코의 경우, 미션repo를 fork해해서 origin보다 더 상위단계가 생기므로 upstream | . | . . 여러개의 downstream이 존재함을 안보이더라도 생각해야한다. git clone시((origin &lt;-&gt; local)에는 origin을 알고 있기 때문에 자동으로 stream관계가 설정되어 push할 때 -u를 통한 upstream 설정은 안해도 된다. | . | . | . –help명령어와 git 객체 . 퀴즈1 . O . git help메세지들을 잘 보자. . .git안에 깃 저장소를 초기화 했습니다. | ls -al 숨긴 파일, 폴더 보면 .git이 깃 저장소(로컬 저장소)가 보인다. | . . tree .git/으로 로컬저장소의 구조를 보면 | . | 명령어 도움말은 명령어 + --help를 뒤에 달면된다. . | . | 퀴즈2 . blob은 파일으로 생각하자. . | 답은 5번 . branch는 commit객체에 대한 참조만 가지고 있다. | . . | commit . 커밋 = 작업 디렉토리 스냅샷 = 세이브 포인트 | 돌아가기 위한 포인트.. commit + push만 하지말자 | 돌아가기 위한 정보를 어떻게 담고 있을까 | . . | add시 생성객체, commit시 생성객체를 나누었다. . . add하면, git이 a.txt를 관리대상으로 인식한다. 아까는 없었던, index와 object가 추가 된다. | . | . . commit하면, tree(파일관련), commit(tree를 담고 있는)객체까지 만들어서 2개가 더 만들어진다. | . . | 퀴즈3 . . git은 변경사항만 저장한다? 흔한 오해 -&gt; 파일을 통채로 저장한다! | 엄청 뒤로 갈 때, 변경사항만으로 추적? -&gt; 연산 엄청 많아진다. 그냥 속도측면을 중요시해서 통채로 저장 = 객체로 관리 | 원본 파일마다 tree객체를 가지고 있다. 통채로 저장해놓고, 그것들을 관리하기 위한 커밋이 가진다. 마지막 commit상태의 blob을 본다. | 변경사항을 저장하는게 아니라서.. | . | . | . | . | .",
            "url": "blog.chojaeseong.com/git/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/17/%EC%A4%80)-upstream%EA%B3%BC-git%EA%B0%9D%EC%B2%B4-%EA%B0%95%EC%9D%98(%EC%99%84).html",
            "relUrl": "/git/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/17/%EC%A4%80)-upstream%EA%B3%BC-git%EA%B0%9D%EC%B2%B4-%EA%B0%95%EC%9D%98(%EC%99%84).html",
            "date": " • Feb 17, 2022"
        }
        
    
  
    
        ,"post57": {
            "title": "그림판으로 보는 git협업 미션",
            "content": "git-mission . https://github.com/woowacourse/retrospective/discussions/4 . 미션repo 관리자와 fork하는 페어1과 페어2가 있다. 관리자(upstream) - 페어1,2(origin) - 각 로컬(local) 형태로 구성할 예정 | . | . 관리자는 github에서 repo(git-mission)를 파고, readme.MD를 작성한다. . README.md # 백엔드팀 . . | pair1, pair2가 각각 관리자의 repo( 예정upstream) -&gt; fork(origin) -&gt; clone(local)한 뒤 . main만 있던 repo안에 작업용 각자의 {github_id}로 . | 미션repo(관리자repo)는 main만 일단 유지한다고 가정하며, . | 작업자들은 main fork -&gt; main clone -&gt; local main외 local {본인github_id}를 파서 작업하자. . git checkout -b is2js&lt;github_id&gt; . git branch -a . . 우테코와 같이 특수한 경우(관리자 repo가 main이외에 개별 br를 다 가지고 있는 경우) 작업자들은 학습사이트를 통해 생성된 main + 수많은 {본인github_id} fork -&gt; --single-branch하여 {본인github_id} clone ** -&gt; local {본인github_id} 외에 **step1 을 파서 작업한다. | . | . | . | pair1부터 readme.md를 수정 -&gt; pair2는 대기(파일 수정해도 됨) . 파일수정 . | add + commit . | (clone해왔지만, br바꿨기 때문에) push with origin과의 upstream 최초 설정 . git push --set-upstream origin is2js&lt;github_id&gt; . . | . | pair1은 [fork repo]의 main외 작업br{github_id} -&gt; [원본repo] main에 PR을 날릴 수 있다. . 보통 fork -&gt; clone -&gt; 작업br 파기 -&gt;(origin입장에서 new br인)작업br push -&gt; fork 작업br to 원본 main br로 PR in github | . | 관리자의 merge in github . | pair2가 conflict를 내기 위해 관리자 최신main from pair1 or pair1 최신을 가져오지 않고 . pair1이 작업끝내기 전에 같은 파일에 작업시작 | . . | pair2의 무지성 PR -&gt; conflict를 github가 알려준다. . 공통 작업자가 있다면, 같은 파일 수정 가능성이 있다면, PR전에 pair나 upstream의 pull부터 해야함. | github에서 PR을 만드려고 하면 conflict를 알려준다. | . | **pair2는 최신소스가 업데이트된 원본repo를 받아오기 위해 local &lt;-&gt; 원본repo upstream으로 등록하고, 받아와야한다. ** . pair1을 pair로 등록하고 받아와도 될 것 같은데, 중심은 원본repo에서 받아온다. . | 중간 다리인 fork는 주고/받을 때 별 영향이 없다. local과 원본repo가 연결되어야 최신소스를 받으니, upstream라는 별칭으로 원격저장소를 추가하여 연결한다. . . git remote -v # fork -&gt; clone으로 형성된 origin = fork레포만 연결되어있다. git remote add upstream&lt;원본레포 별칭&gt; &lt;원본레포 URL&gt; git remote -v git fetch upstream # fetch는 커밋내역만 가져오는데 [원격저장소별칭]만으로 가져올 수 있다. # 가져올 br이 있는지 확인한다. git branch -a git merge upstream/main # 가져올 [원격저장소별칭/br] 형태로 merge를 요청한다. . | . | 가져와서 conflict를 (vscode 등에서) 해결하고, 다시 fork(origin)으로 push -&gt; github에서 PR을 날리면 된다. . git push origin is2js{github_id} . . | 우테코의 코드리뷰는 더 복잡하다. . 원본repo의 관리자 -&gt; 리뷰어들이 merge를 담당한다 . | fork전, 우테코 학습사이트를 통해 원본repo에 main외 내 {github_id}로 하면서 PR의 최종merge가 각자의 {github_id}로 되도록 먼저 생성한다. . | fork하면, main + 모든 리뷰이들의 {github_id}들이 있다. -&gt; 내 {gihub_id}의 br만 로컬로 clone해와야한다. . git clone -b is2js&lt;내github_id&gt; --single-branch https://github.com/is2js/java- racingcar.git&lt;url&gt; . | clone후, 내입장에서의 main branch인 {github_id}에서 작업용=리뷰어br인 step1부터 파서 시작한다. . | 만약, 페어가 있다면 한 곳의 step1을 선택한 다음, 작업이 끝나면 찢어진 뒤 . pair라는 별칭으로 git remote add pair &lt;URL&gt;을 하고 | fetch -&gt; merge하여 작업된 pair의 코드를 가져온 뒤, 작업을 시작한다. | . | . . |",
            "url": "blog.chojaeseong.com/git/%ED%98%91%EC%97%85/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/17/git_%EA%B7%B8%EB%A6%BC%ED%8C%90%EC%9C%BC%EB%A1%9C_%EB%B3%B4%EB%8A%94_%ED%98%91%EC%97%85%EB%AF%B8%EC%85%98(%EC%99%84).html",
            "relUrl": "/git/%ED%98%91%EC%97%85/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/17/git_%EA%B7%B8%EB%A6%BC%ED%8C%90%EC%9C%BC%EB%A1%9C_%EB%B3%B4%EB%8A%94_%ED%98%91%EC%97%85%EB%AF%B8%EC%85%98(%EC%99%84).html",
            "date": " • Feb 17, 2022"
        }
        
    
  
    
        ,"post58": {
            "title": "코드리뷰 방법 2단계(step1 PR merge이후)",
            "content": "그 전 1단계 마무리 . local의 step1 브랜치에서 local commit만 한다. | 각종 검토후 push한 뒤, 최초PR을 날린다. (local step1 —&gt;) forkrepo step1 -&gt; 원본repo is2js | . | 최초PR이후, local commit만하다가, 2번쨰 push부터는 피드백 반영된다. | 리뷰어는 PR을 merge . **리뷰어는 ** . Push하여 피드백 반영된 fork-step1 —&gt; 원본-is2js의 PR을 merge시키는 권한이 있다. . 피드백 최종반영 fork step1 to 원본 is2js PR후 N번 피드백push . | 리뷰어의 PR을 merge . . | . | . | . 1단계완성br {github_id} -&gt; local 반영 . 참고문서: 코드리뷰 3단계 | . local 먼저 {github_id} checkout . . local branch를 일단 is2js{github_id}로 넘어온다. . . git checkout is2js&lt;github_id&gt; . | . 원본repo와 동기화 . 원본repo를 별칭upstream으로 remote add . . 현재 local에 달린 git remote 확인하기 . origin: fork레포 | (B라면, pair: A의 repo) | . git remote -v . 결과 . origin https://github.com/is2js/java-racingcar.git (fetch) origin https://github.com/is2js/java-racingcar.git (push) pair https://github.com/Wishoon/java-racingcar.git (fetch) pair https://github.com/Wishoon/java-racingcar.git (push) . | . | 원본(미션)repo를 upstream이라는 별칭으로 원격저장소 등록해주기 . git remote add upstream&lt;별칭&gt; https://github.com/woowacourse/java-racingcar.git&lt;원본(미션)repo&gt; . git remote add upstream https://github.com/woowacourse/java-racingcar.git . 결과 . git remote add upstream https://github.com/woowacourse/java-racingcar.git git remote -v origin https://github.com/is2js/java-racingcar.git (fetch) origin https://github.com/is2js/java-racingcar.git (push) pair https://github.com/Wishoon/java-racingcar.git (fetch) pair https://github.com/Wishoon/java-racingcar.git (push) upstream https://github.com/woowacourse/java-racingcar.git (fetch) upstream https://github.com/woowacourse/java-racingcar.git (push) . | . | . fetch로 원본repo상 merge된 내 br {github_id} -&gt; {remotes/별칭/내br}으로 가져오기 . . fetch로 원본repo상에 리뷰어에 의해 merge된 is2js를 -&gt; local is2js로 가져오기 . git fetch upstream&lt;별칭&gt; is2js&lt;가져올br명&gt; . 결과 . git fetch upstream is2js remote: Enumerating objects: 1, done. remote: Counting objects: 100% (1/1), done. remote: Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (1/1), 2.22 KiB | 759.00 KiB/s, done. From https://github.com/woowacourse/java-racingcar * branch is2js -&gt; FETCH_HEAD * [new branch] is2js -&gt; upstream/is2js . | . | git branch -a를 확인해보면 remotes/별칭/{merge된 내br=github_id}로 생성되었다. . git branch -a . 결과 . . | . | . rebase(1줄 이어붙merge)로 {fetch한 원격br}을 -&gt; {로컬br}과 동기화 . . 원격br -&gt; 로컬br에 끊어진 이후부터 &lt;merge와 달리 1줄&gt;로 이어붙이는 작업인 것 같다. . git rebase upstream/is2js . 결과: fetch한 remotes/upstream/is2js랑 local의 is2js랑 완전히 동일해졌다. . . | 참고로 rebase는 커밋 n개 합치기용(-i) or merge를 깨끗하게( . merge와 비교 장점: 커밋해쉬 유지 및 흐름 유지되어 돌아갈 수 있음 | 단점: merge라는 불필요커밋을 생성함. | . | rebase 장점: 주는놈위에 받는놈위주로 정리가 됨. 깨끗한 커밋 히스토리가 됨. | . | . | . | . 2단계 br 생성하기 . step2 br 생성과 동시에 checkout . 최신화(fetch -&gt; rebase)된 is2js{github_id}에서 받아와 생성되도록 한다. . git checkout -b step2 . | . 이후 step2에 작업후 add/commit/push-&gt;PR-&gt;push반복-&gt;merge . 나는 step1에 작업하던 것이 남아서 step2에서 merge받았다. . . | . step1 삭제 . 1단계 br은 이제 삭제한다. . git branch -d step1 . | .",
            "url": "blog.chojaeseong.com/git/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%ED%98%91%EC%97%85/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/16/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-2%EB%8B%A8%EA%B3%84(%EC%99%84).html",
            "relUrl": "/git/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%ED%98%91%EC%97%85/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/16/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-2%EB%8B%A8%EA%B3%84(%EC%99%84).html",
            "date": " • Feb 16, 2022"
        }
        
    
  
    
        ,"post59": {
            "title": "생성자와 일급컬렉션(사용이유, 테스트)",
            "content": "생성자 규칙 . 나만의 규칙 . 생성 루트가 여러개 ex&gt; List&lt;String&gt; or List&lt;Car&gt;인 일급컬렉션 private 필요속성(만) 받는 기본생성자 | public fromStrings( List&lt; String &gt; ) inputView에서 검증을 하고 오므로 검증없이 -&gt; List&lt;객체&gt;로 변환 -&gt; 생성자 | . | public from객체(List&lt; 객체 &gt;) test등에서 단일객체 -&gt; List add되어 들어오는데, 복수 검증(중복)을 추가후 -&gt; 생성자 | . | | VO, 단일객체라도 숫자형이라면 -&gt; inputView에서 형변환후, 해당형으로 검증되도록 inputView에서 따로 검증안한다면, public 생성자에서 검증까지 다 처리하면 될 듯함. inputView에서는 VO는 형변환하고나서 -&gt; 검증하자. | . | inputView 검증해야하는 상황이라면? -&gt; 형변환후 int만 검증 public 기본생성자(원본 타입) with 노검증(for inputView거친 뒤 controller or 숫자VO 연산) | public fromNumber(원본타입) with 검증(for 테스트 or int직접생성) | | | . 일급컬렉션 생성자와 사용이유 . 생성자 2+1개 . fromXXXX: InputView에서 검증된 List&lt; String &gt;를 받는 public 정적팩토리메서드 . InputView.getXXX() 에서 검증 후 들어오는 ** -&gt; **List&lt; String &gt;으로 들어올 것이기 때문에 .fromStrings( )형식으로 작성한다. . String List -&gt; 단일객체 List로 변환되어 -&gt; 기본 생성자를 부른다. | . public static Cars fromNames(List&lt;String&gt; values) { //input에서 검증하고 와서, 변환만 List&lt;Car&gt; cars = values.stream() .map(value -&gt; Car.from(value)) .collect(Collectors.toList()); return new Cars(cars); } . | . from: 테스트 등에서 List&lt; 단일객체 &gt;를 받는 public 정적팩토리메서드 . 기본생성자는 private하게 유지하기 위해, 테스트용 public 기본 생성자 from ( List&lt; 단일객체 &gt;로 생각하자. . 따로 개별 검증은 필요 없고(단일객체 생성시 이미 검증) -&gt; 중복검사 등만 필요 | . public static Cars from(List&lt;Car&gt; cars) { //중복 검증 등 return new Cars(cars); } . | . 기본생성자: private + List&lt; 단일객체 &gt; . inputView 검증-&gt; fromStrings . | test -&gt; from -&gt; 복수검증 . | 기본생성자는 일단 검증 없이 생성만 하는 역할을 하게 한다. . private Cars(List&lt;Car&gt; cars) { this.cars = cars; } . | . 쓰는 이유 4가지 . 참고 블로그 | . 01 검증 통과해야만 생성 가능한 자료구조(비지니스 종속 자료구조) . 흩어져있는 검증 기능들을 외울 수 없다. 신입사원이 와도 바로 작동하도록 하는 객체를 만들어야한다. . | 해당, util등에서 처리할게 아니라 검증 만족시 생성가능한 자료구조를 만들어 신입사원도 쓸 수 있게 해야한다. . public static Cars from(List&lt;Car&gt; cars) { Validator.validateCarsName(getCarNames(cars)); return new Cars(cars); } . | . 02 setter/add 등이 없는 불변구조 . List는 add, map은 put 등의 메서드를 제공하는데 . 일급컬렉션으로 감싸서 생성자와 getter류 기능만 제공하도록하고 setter 등을 제공하지 않음녀 불변구조가 된다. . | 자료구조에 final을 붙혀도 해당 context에서 재할당만 불가 -&gt; add, put 등은 가능함. . cf) 일급컬렉션에 변수는 1개이며, final이 붙어서 최초생성이후 변경할 수 없게 한다. | . private final List&lt;Car&gt; cars; . | . | . 03 상태(변수)와 행위(기능)을 자료구조와 함께 한 class에 다 모으기(냉무) . 05 이름을 가지는 자료구조가 됨.(냉무) . 일급컬렉션 테스트 . 단일객체 -&gt; 일급컬렉션 순서대로 생성 . 단일객체 -&gt; 일급컬렉션 순서대로 생성하도록 전역변수 -&gt; @BeforeEach에서 List&lt; Car &gt;를 받으면서 중복 등 다수검증하는 from으로 생성한다. | 단일 객체생성은 여기서는 다루지 않지만, 검증이 들어간 로직으로 해야할 듯. | . | . //1. 일급컬렉 Test: @BeforeEach에서 단일객체 개별생성 후(그래야 개별조작 가능 -&gt; 반영) List에 담아놓기 Car 코니; Car 재성; Cars cars; @BeforeEach void setUp() { 코니 = new Car(&quot;코니&quot;); 재성 = new Car(&quot;재성&quot;); cars = Cars.from(Arrays.asList(코니, 재성)); } . given자리에 단일객체 조작을! when에서는 일급컬렉 기능을! . given자리에 일급컬렉션과 공유된 개별 객체들을 조작후 -&gt; 테스트한다. . @Test void getMaxposition_method_test() { //given -&gt; 단일객체를 조작 코니.move(() -&gt; true); 재성.move(() -&gt; false); //when Car actualMaxPositionCar = getMaxPositionCar2(); //then assertThat(actualMaxPositionCar).isEqualTo(코니); } // private하며 메서드 내부의 메서드 -&gt; 복사하고, 인자를 바꿔주자. private Car getMaxPositionCar2() { Car maxPositionCar = Arrays.asList(코니, 재성).stream() .max(Car::compareTo) .orElseThrow(() -&gt; new IllegalArgumentException()); return maxPositionCar; } . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%ED%85%8C%EC%8A%A4%ED%8A%B8/%EC%83%9D%EC%84%B1%EC%9E%90/2022/02/15/%EC%83%9D%EC%84%B1%EC%9E%90_%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98_%EC%82%AC%EC%9A%A9%EC%9D%B4%EC%9C%A0_%ED%85%8C%EC%8A%A4%ED%8A%B8(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%ED%85%8C%EC%8A%A4%ED%8A%B8/%EC%83%9D%EC%84%B1%EC%9E%90/2022/02/15/%EC%83%9D%EC%84%B1%EC%9E%90_%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98_%EC%82%AC%EC%9A%A9%EC%9D%B4%EC%9C%A0_%ED%85%8C%EC%8A%A4%ED%8A%B8(%EC%99%84).html",
            "date": " • Feb 15, 2022"
        }
        
    
  
    
        ,"post60": {
            "title": "commit.template과 message양식",
            "content": "commit.template 활용하기 . template(.gitmessage.txt) 생성 . 이미 지정된 commit.template의 터미널에서 확인 . 없으면 원하는 경로에서 .gitmessage.txt를 생성하면 됨. | . git config --global commit.template . C: Users cho_desktop .gitmessage.txt에 지정 해놨었다. . cf) 적용 코드 . git config --global commit.template C: Users cho_desktop .gitmessage.txt . | . | . | 해당 경로(윈도우의 경우, 풀 경로)로 가서 커밋.템플릿을 생성/수정한다. . .gitmessage.txt . #commit전: inspect code.../F8/함수 순서/public test만/depth/필요개행/불필요개행/매직넘버/Test #fix | feat | build | chore | ci | docs | style | refactor | perf | test: ##### Subject 50 characters ## don&#39;t finish with . ##-&gt;| ######## 본문은 한 줄에 최대 72 글자까지만 입력 ########################### -&gt; | # 제목에서 한줄 띄고, 여러줄운 &quot;- 내용1 - 내용2&quot; , &quot;무엇을&quot; &quot;왜&quot; 기술 &gt;&gt; &quot;어떻게&quot; 72자 제한 ################################ # 꼬릿말은 아래에 작성: ex) #이슈 번호 # COMMIT END # &lt;타입&gt; 리스트 # feat : 기능 (새로운 기능) # fix : 버그 (버그 수정) # refactor: 리팩토링 # style : 스타일 (코드 형식, 세미콜론 추가: 비즈니스 로직에 변경 없음) # docs : 문서 (문서 추가, 수정, 삭제) # test : 테스트 (테스트 코드 추가, 수정, 삭제: 비즈니스 로직에 변경 없음) # chore : 기타 변경사항 (빌드 스크립트 수정 등) # # 제목 첫 글자 -&gt; 대문자 # 제목 명령문 # 제목 끝에 마침표(.) 금지 # 제목과 본문을 한 줄 띄워 분리하기 # 본문은 &quot;어떻게&quot; 보다 &quot;무엇을&quot;, &quot;왜&quot;를 설명한다. # 본문에 여러줄의 메시지를 작성할 땐 &quot;-&quot;로 구분 # . | . | . 생성 템플릿 적용하기 . global 설정 . 명령어를 통해 지정 . git config --global commit.template C: Users cho_desktop .gitmessage.txt . | .gitconfig의 [commit]블럭안에 template을 직접 수정 . [commit] template = C: Users cho_desktop .gitmessage.txt . | repository별 설정 . ~/.gitconfig를 사용하는 대신 해당 repository안에 있는 .git/config에 위에서 설명한 [commit]블락을 추가 . [commit] template = C: Users cho_desktop .gitmessage.txt . | .",
            "url": "blog.chojaeseong.com/git/%ED%98%91%EC%97%85/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/2022/02/15/commit.template%EA%B3%BC-%EC%96%91%EC%8B%9D-%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/git/%ED%98%91%EC%97%85/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/2022/02/15/commit.template%EA%B3%BC-%EC%96%91%EC%8B%9D-%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Feb 15, 2022"
        }
        
    
  
    
        ,"post61": {
            "title": "intellij 협업 세팅",
            "content": "인텔리제이 세팅 . buildType &amp; assertj라이브러리 . build Type: gradle -&gt; intellij . gradle검색후 build and run intellij로 바꿔주기 빌드 속도 및 TestName표기 | . | new projects에서 세팅 안됨 | . build.gradle 라이브러리에 assertj 추가 및 refresh . build.gradle의 dependency에 assertj 라이브러리 넣어주고 refresh 하기 . // Assertions testImplementation &#39;org.assertj:assertj-core:3.22.0&#39; testImplementation &#39;org.junit.jupiter:junit-jupiter-params:5.4.2&#39; // lombok compileOnly &#39;org.projectlombok:lombok&#39; annotationProcessor &#39;org.projectlombok:lombok&#39; . | Ctrl+Shift+O 또는 우측상단에 떠있을 코끼리버튼을 클릭해줘야 반영이 된다. . 단축키는 keymap에서 덮어써줘야 작동됨. | . | . assert문 live template에 추가해놓기 . as+all assertAll( () -&gt; assertThat().isEqualTo(), () -&gt; assertThat().hasSize() ); . | as+that Assertions.assertThat($ACTUAL$).isEqualTo($EXPECTED$); . | as+notthr Assertions.assertDoesNotThrow(() -&gt; $WHEN$) . | as+thr Assertions.assertThatThrownBy(() -&gt; $WHEN$) .isInstanceOf($EXCEPTION$.class) .hasMessage(&quot;$MESSAGE$&quot;); . | . gradle 정상 test . . shift 2번 or f1 -&gt; gradle task선택 gradle clean 수행 | gradle test 수행 | | 루틴 설정(1회성으로 보임) . ends with a line break . Editor &gt; General &gt; on Save 탭 &gt; ends with a line break에서 해당 박스를 체크한다. | . ​ . Code style(우테코) . 우테코javastyleXML, naverConventionXML 다운로드 프로젝트폴더 최상단에 넣어준다. | . | Editor &gt; code style &gt; Scheme &gt; 톱니바퀴 &gt; Import Scheme &gt; Intellij IDEA XML intellij-java-wooteco-style.xml 선택해주기 | . | SQL warning 워닝 제거 . 참고 사이트 | . Warning 검출 끄기 DAO 등의 sql 작성문으로 가서 ctrl + . &gt; Uninject language or reference 를 선택한다. | . | 프로젝트 SQL dialect 설정하기 for 자동완성 by 해당SQL로 인식후 문법 자동완성 Settings - Languages &amp; Frameworks - SQL Dialects or shift 2번(F1) &gt; sql dialects 선택 | Global 말고 Project SQL dialect를 테스트용 H2로 선택 | | schema.sql에서 H2를 DataSource로 지정하여 session에서 테이블들 생성 for String sql속 table 및 칼럼 인식후 자동완성 의존성에 h2추가 확인하기 runtimeOnly &#39;com.h2database:h2&#39; . | application.yml에서 h2 인메모리(mem) url(url: jbdc:h2:mem:maindb)으로 지정 / username 등 설정 확인 후 `펼쳐놓기 . | scheme.sql파일에서 configure data source 클릭 or shift 2번(F1)에서 data source검색하여 Data source... 선택 . Data source from url에 application.yml의 url을 복붙해서 설정도 가능하다고 한다. | . | h2를 추가하고, 기본 remote로 지정된 option을 내장형(In-memory)로 변경하고, username(sa), database(maindb) 등 입력해준다. . | schema.sql로 와서 실행버튼 &gt; 생성한 data source DB설정 &gt; schema.sql 선택후 실행시켜 data source에 session으로 메모리 테이블 실제 생성시켜준다. . | 이제 dao등에서 table을 인식하여 칼럼까지 자동완성할 수 있다. . | 연결이 끊기면 schema.sql -&gt; ctrl+shift+F10(run) -&gt; target data source 설정해서 연결해주면 된다. | | 1회성 설정 . New Project setup . File &gt; New Projects Setup &gt; Settings for New projects&gt; . . | . Save Actions (개행+imort최적화) . Plugins &gt; market &gt; save actions를 검색해서 설치한다. . import최적화(삭제) + 리포맷팅 자동 . | . file Encoding . 3가지 전부 UTF-8확인 | . tab (4space) . **Editor &gt; Code style &gt; java &gt; tabs and indents &gt; ** [ ] Use tab character 체크해제 | Continuation indent 8-&gt;4 | . | OS마다 tab의 크기가 다르므로 space를 사용하게 tab사용 체크해제하는 것 | . File and Code Templates &gt; method body template . 베루스 추천 . | settings &gt; File and Code Templates &gt; code 탭에서 . implemented + new Overriden Method Body부분에 | . ##if ( $RETURN_TYPE != &quot;void&quot; )return $DEFAULT_RETURN_VALUE;#end throw new UnsupportedOperationException(&quot;${SIMPLE_CLASS_NAME}#${METHOD_NAME} not implemented.&quot;); throw new UnsupportedOperationException(&quot;${SIMPLE_CLASS_NAME}#${METHOD_NAME} not write.&quot;); . ## 오버라이딩은 그냥 쓴다. 부모의 것 상속 받을 때인데, super() 등 메서드 그대로 호출시켜줘야함. ##throw new UnsupportedOperationException(&quot;${SIMPLE_CLASS_NAME}#${METHOD_NAME} not override.&quot;); . Auto Import . | Editor &gt; general &gt; auto import 검색 후 . Always -&gt; Ask로 변경(복붙후 library 선택) | Add unambiguous import on the fly 체크 . | Optimize imports on the fly (for current project) 체크 . . | . | . parameter name hints . Editor &gt; general &gt; code completoin 검색 후 &gt; Parameter Info 탭 &gt; [x] show parameter name hints on completion 체크 | . usages 표기 . preferences - editor - inlay hints - java - code vision usages 2가지체크 | . | . go to test . keymap &gt; go to test 검색 후 단축키 지정 : ctrl+shift+ T -&gt; 나머지 remove 테스트 없으면 생성, 있으면 이동 시켜주게 된다. | . | . lombok 라이브러리 이후 @anno적용 안될 때 . lombok 라이브러리를 추가한 후 Settings &gt; Build &gt; Compiler &gt; Annotation Processors 에서 [x] Enable annotation processing 을 체크해야 롬복을 사용할 수 있다.(안될 경우) | . | . final 및 private . method의 파라미터 앞에 final . Editor &gt; Code style &gt; java &gt; Code generation &gt; [x] make ~ final 체크박스 2개 | . 변수 추출시 final (최초 1회) . 추출할 때, ctrl + alt + v를 **2번 눌러서, ** Declare final체크 | . | . (private) 상수를 private로 추출(최초 1회) . 추출할 때, ctrl + alt + c를 **2번 눌러서, ** public -&gt; private로 옮겨놓기 | . | . Test Method 템플릿에 @DisplayName(“”) 추가해주기 . 세팅 &gt; file and code templates 검색 &gt; Code탭 &gt; JUnit Test Method에 아래 코드 추가 . @org.junit.jupiter.api.DisplayName(&quot;&quot;) . . | 파라미터 힌트 항상 보이게 하기 . settings &gt; Parameter hint검색 &gt; Editor &gt; Inlay Hints &gt; Java &gt; Parameter hints &gt; Paramters with names ~ 체크 | . | . keymap 추출하고 사용하기 . F1(search everywhere)에서 export settings를 검색한다 . | Select None을 한번 누르고 keymaps(schemes)만 선택 한 뒤, 저장경로에서 settings.zip에 날짜기입까지 해주고 OK로 export한다. . 사용시에는 반대로 F1 &gt; import settings를 검색한 뒤, zip을 선택만 해주면 된다. . | 까보면, plugins까지 다 포함되어있다. . | . . | Font . editor &gt; font &gt; jetbrain Mono -&gt; fira code + ligature 허용 | . 한글 워닝 제거 . Editor &gt; inspections &gt; non-ascii검색 &gt; 체크해제 | . . 페어 컨벤션(링크) . 구글 스프레트 시트 링크로 매번 업데이트 된 것 활용하기 | . .editorConfig for windows에서도 LF로 저장 . 다양한 에디터들에게 공통적인 코드컨벤션을 적용시킨다. 적용시 windows에서도 LF로 저장되게 한다. | . | 루트에서 NEW &gt; EditorConfig 검색후 생성한다. . | 아래 내용을 복붙한다. . # top-most EditorConfig file root = true [*] # [encoding-utf8] charset = utf-8 # [newline-lf] end_of_line = lf # [newline-eof] insert_final_newline = true [*.bat] end_of_line = crlf [*.java] # [indentation-tab] indent_style = tab # [4-spaces-tab] indent_size = 4 tab_width = 4 # [no-trailing-spaces] trim_trailing_whitespace = true [line-length-120] max_line_length = 120 . | . checkstyle . 일단 LF로 push하기 위한 git 전역설정이 되어있어야한다. . 윈도우에서는 git commit시 CRLF로 새줄을 저장하지만, 위 설정을 통해 push시에는 LF로 올라가게 한다. . Git은 커밋할 때 자동으로 CRLF를 LF로 변환해주고 | windows로 clone하면 다시 LF가 CRLF가 됨 | . git config --global core.autocrlf true . | . | 없다면 플러그인 Plugins 에서 CheckStyle-IDEA검색 후부터 설치한다. . CheckStyle-IDEA 설치 | 프로젝트 최상단에 naver-checkstyle-rules.xml를 위치시키고 | Tools &gt; Checkstyle에서 버전을 8.24 이상으로, | Scan Scope를 All sources(including tests)로 맞추고 - 테스트 한글함수를 위해서 tests 포함안해도 될 듯? | +를 눌러, 위에서 편집해준 naver-checkstyle-rule를 추가해준다. | naver-checkstyle-rule을 선택해준다. | . | . | 네이버핵데이 컨벤션 및 CheckStyle 적용하기 . 요약 . Settings &gt; Editor &gt; Code style &gt; Java &gt; Scheme &gt; 톱니바퀴 &gt; import Scheme &gt; (ideaProject폴더에 다운받아놓은 )InteliJ ~ .xml 파일 찾아 적용 cf) code style&gt; java에서 use tab character를 풀어야 4스페이스가 된다. Tab 사용하도록 체크하자. | | 파일을 저장 할 때마다 포멧터 자동 적용설정 by Save Actions plugin을 활용하면 파일을 저장하는 순간 포멧터를 자동 적용할 수 있다. File &gt; Settings ( Ctrl + Alt + S ) &gt; Plugins 메뉴로 이동 | Marketplace 탭에서 ‘Save Actions’ 로 검색 | Save Actions&#39; plugin의 상세 설명 화면에서 [Install]` 버튼 클릭 | IntelliJ를 재시작 | File &gt; Settings &gt; Other Settions &gt; Save Actions 메뉴로 이동 | 아래 항목을 체크 Activate save actions on save | Optimize imoprts | Refomat file | . | | 플러그인 CheckStyle-IDEA 플러그인을 검색 후 설치 Tools &gt; CheckStyle에서 Checkstyle version을 8.24 이상, Scan Scope를 All sources (including tests) 로 설정 | Configuration file에 다운받고 수정한 XML 파일(ideaProject폴더에 다운받아놓은 naver~checkstyle rule.xml)을 추가 | 하단에 checkstyle 창(단축키 직접지정 alt+shift+k)로 코드짜고 확인하기 | | | . . . intellij용 xml파일 다운로드 | 설치가이드 https://naver.github.io/hackday-conventions-java/#intellij-formatter | 나는 지금 플러그인 : google-java-format&gt; android 버전을쓰고있는데.. 취소시킴 | . | checkStyle적용하기 . CheckStyle은 Java 코드를 작성 할 때 규칙(이 경우 코딩 컨벤션)들을 선언해두고 이를 어길 시 에러 또는 경고를 뿜어내어 개발자로 하여금 컨벤션을 강제로 지킬 수 있도록 도와주는 코딩 컨벤션 검사 도구다. 네이버 핵데이 Java 코딩 컨벤션을 적용할 시 다음을 제외한 나머지들에 대한 컨벤션을 검사할 수 있다. . 한국어 발음대로의 표기 금지 | 클래스 이름에 명사 사용 | 인터페이스 이름에 명사/형용사 사용 | 메서드 이름은 동사/전치사로 시작 | 테스트 클래스는 ‘Test’로 끝남 | 대괄호 뒤에 공백 삽입 | 주석문 기호 전후의 공백 삽입 | . | 적용방법 . Naver CheckStyle Rules XML 파일을 다운받는다. 나는 프로젝트 최상단($rootDir)에 이를 추가했다. . 내문서 &gt; IdeaProjects폴더에 저장함. | . | 우선 나는 다른 규칙을 덮어쓸 생각이 없어서 여기를 참고하여 XML 파일에서 다음을 삭제했다. 이를 삭제하지 않으면 다음 단계에서 suppressionFile 변수에 파일을 할당해야한다. . &lt;module name=&quot;SuppressionFilter&quot;&gt; ​&lt;property name=&quot;file&quot; value=&quot;${suppressionFile}&quot;/&gt; ​&lt;property name=&quot;optional&quot; value=&quot;false&quot;/&gt; &lt;/module&gt; . | . | ide에 적용하기 . File &gt; Settings &gt; Plugins 메뉴에서 CheckStyle-IDEA 플러그인을 검색 후 설치한다. | Tools &gt; CheckStyle에서 Checkstyle version을 8.24 이상, Scan Scope를 All sources (including tests) 로 설정한 후 Configuration file에 다운받고 수정한 XML 파일을 추가하자 | 이제 우리가 설정한 코딩 컨벤션을 어기는 코드를 작성하면 다음과 같이 경고 표시가 나타난다. | | . | .",
            "url": "blog.chojaeseong.com/intellij/%EC%9A%B0%ED%85%8C%EC%BD%94/%ED%98%91%EC%97%85/2022/02/13/intellij_%ED%98%91%EC%97%85%EC%84%B8%ED%8C%85(%EC%99%84).html",
            "relUrl": "/intellij/%EC%9A%B0%ED%85%8C%EC%BD%94/%ED%98%91%EC%97%85/2022/02/13/intellij_%ED%98%91%EC%97%85%EC%84%B8%ED%8C%85(%EC%99%84).html",
            "date": " • Feb 13, 2022"
        }
        
    
  
    
        ,"post62": {
            "title": "intellij plugin, shortcut(keymap)",
            "content": "인텔리제이 플러그인 및 단축키 . 의존성 확인하는 법 . 우측의 gradle 탭 선택 타자 쳐서 바로 하위 패키지 검색 바로 안됨 | . | 상단 버튼 중 Analyze dependencies..선택 여기서 검색하면 나온다. | . | 플러그인 . vscode keymap검색 install . keymap탭 가서 VSCode로 바꾸기 | . | key Promoter X 설치 vscode keymap 바꾼것도 보여준다. | | Rainbow Brackets . | .ignore : 우클릭으로 ignore파일을 만들어주는데, . 우클릭 &gt; new &gt; ignore file &gt; .gitignore파일 &gt; 선택하면 됨. | 자동완성도 해줌. | . | cobalt2 theme . | translation . Plugin &gt; MarketPlace &gt; Translation검색 . | Tools 내부에 있음. 기본적인 세팅은 구글번역 . | 단축키 일부 재정의 . 공부용 영-&gt;한 번역기: ctrl+shift+ Y 아무것도 없는 곳에 두고 누르면 code with me 단축키 | . | 코딩작명용 한-&gt;영 즉시번역 : ctrl+shift+X Translate and Replace: 설정창에 묻혀서 단축키 재정의 (ctrl+shift+x)-&gt; 다른것 remove) | . | . | | sonalint shift2번 후 plugin 검색 or 설정에서 plugin -&gt; market을 선택한 뒤 sonalint검색 | 설치후 아래 탭에서 sonalint null체킹 등 기능 이용하기 | | Codota . 검색후 설치한 뒤, 자동완성시 % 보여주고 + snippet 검색 가능 . . . | . | prgoress bar검색후 마리오로 설치 . . | TabMover 설치후 . 파일 띄우기: ctrl+alt+shift+ D | 복사후 이미 떠있는 반대창에 종속시키키: ctrl+ 이후 ctrl+alt+shift + Up | . | atom material icons검색하여 설치 . | . | UnitVisualizer (1.7.1) : class의 package이동시 classTest파일도 같이 package이동 . project속 파일도 왼쪽아래 살짝 표시된다. . . | . | 단축키(vscode keymap기준) . shift 2번 : 전체 검색(유지) vscode F1 | . | keymap 들어가서 move To opposite group검색후 ctrl+shift+ 오른화살표지정하기 ctrl + 이후 넘기기..왼쪽넘기기 기능 자체는 없나보다. | alt+shift+0으로 세로로 넘기기 가능 | . | alt+shift+F : reformat code -&gt; 한파일내 패키지 or 폴더 선택후 alft+shift+F | . | keymap 들어가서 back검색후 ctrl+u지정하기 | ctrl + .으로 메인메소드 내용을 extract method 호돌스에서 봄. | 메소드 분리 및 패키지명 작성하고 폴더이동시키기 | . | 신세계) alt+insert로 생성자를 만듬 | **신세계) 메서드사용을 위한 객체 만들 때(인스턴스화) 할 때, ** new 클래스명(); 기입후 ctrl+.으로 local변수 자동(선택후)생성하자. | 객체.메서드();기입후 ctrl+.으로 메서드결과값 받는 변수 자동(선택후)생성 | . | keymap -&gt; extend line selection -&gt; ctrl+L을 추가해서 사용하기 라인 선택하기 shift+alt+아래화살표로 복사할때,, 라인 선택해서해야.. 꼬임없을 듯 | . | . | shift+ alt+ F10: 실행할 class파일 선택해서 실행 ctrl+alt+F10은 바로 실행. | . | shift + alt + x: 현재 파일들 다 close | shift + alt + a : 긴글 주석? . | alt + ~ : git관련 명령어들 목록나옴 . | ctrl+F11 or ctrl+shift+{key}로 북마크 지정 -&gt; ctrl+해당번호로 이동 | keymap -&gt; show bookmaks검색후 -&gt; CTRL+SHIFT + F11 으로 지정함 | . | ctrl+f3 : 같은단어 이동가능한 검색한 상태로 만들기 == ctrl+f f3 : 같은 단어 다음으로 이동 | shift+f3 : 같은단어 이전 단어로 이동 | . | shift+F5 : 실행중인 작업 종료 ctrl+F5 : 실행 | shift+ alt + f10 : main함수 골라서 실행 | . | alt+7: 현재파일 Structure(메소드 등) 한눈에 보기 유틸메서드로 빼기, 상수 옮기기 : f6으로 편하게 | . | 리팩토링 alt+ctrl+c : 값을 상수로 등록해버리기 | alt+ctrl+m : 코드를 메서드화 시키기 2번 눌르면 창으로 하는 듯 | . | alt+ctrl+v: new 클래스()까지 입력후 참조변수 바로 생성 | alt+ctrl+p: 클래스내 변수/메서드 사용을 -&gt; 작성중인 메서드의 파라미터로 빼고 싶을 때 ex&gt; 테스트를 위해 내부랜덤요소를 파라미터로 받도록 설게 | . | . | 축약어 iter | fori 추가 | itar | ifn | inn | . | F8: 오류바로 찾아가기 | ctrl+f -&gt; F3 or shift + F3 : 검색항목 순서대로 찾아가기 . | alt + del : 메소드 등 안전하게 지우기 . | keymap -&gt; refresh gradle dependen~검색 후 -&gt; shift+ c+a + G로 추가해서 사용 gradle에 추가한 라이브러리 재갱신시킬 때!! | . | keymap -&gt; checkstyle -&gt; alt+shift+k로 지정함 naver checkstyle 적용해보기 위함임. | . | F3 -&gt; 함수단위로 건너띄기 검색후 F3 : 다음 검색결과로 넘어가기 shift는 이전으로 넘어가짐. | . | . | ctrl+Tab : 직전창 왔다갔다하기 shift 안눌러도됨. | 메인로직(controller) 옆에서, readme &lt;-&gt; 세부작업중 파일싱글톤관리자, 서브화면 왓따갔다 하면 좋음 | . | ctrl+shift+alt+ I 후 -&gt; unused desc 검색후 -&gt; test파일 제외 체크 -&gt; 사용하지 않는 험수들 손수 제거하기 safe delete하니까..ㅠㅠ 설정 꼬였음. . | File -&gt; invalidate cache 캐쉬삭제 &amp; restart 해서 처리.. . | . | 라이브 템플릿 추가하기 싱글톤용 -&gt; sgt으로 생성 외부에서 메인로직관리싱글톤Class.getInstance()로 작성후 | 클래스 생성 후 sgt으로 채워주기 | . | 검증하며 무한호출하는 재귀 getInput InputView.getInput()작성후 getMany or getOne | . | 랩핑클래스용 | 이넘용 | . | keymap에서 Toggle case검색후 vscode의 대문자(U), 소문자(L)에 해당하는 것 2개를 다 추가해주기 . ctrl+alt+U , ctrl+alt+L | . . | try/catch등 한방에 씌우기: ctrl+alt+t . | ctrl+alt+O : library 적용안될 때 refresh시키는 단축키 덮어주기 default 단축키로 지정되어있지만, 겹치는게 많아서 잘 적용이 안되더라. 다른거 remove하면서 덮어준다. | . | ctrl+F2 : 동일단어 한번에 전체 선택 . | ctrl+space x 2 : 기존 navigate error 역할인 F8이 너무 멀어서 추가함 keymap -&gt; navigate error검색후 add ctrl+space + second stroke ctrl+space 추가 -&gt; 기존 F8 leave | . | alt+2: 북마크창 ctrl+shift+숫자 지정후 -&gt; 바로 alt+2 띄우는 버릇 들이기 | . | 플러그인 translation설치후 ctrl+shift+x : 변수 번역하기 . | 플러그인 tabMover설치후 TabMover 파일 띄우기: ctrl+alt+shift+ D | 이미 창이 나뉜 상태에서 커서를 좌우왔다갔다 : ctrl+alt+shift + [ or ] | 가운데 창 복사 후 떠있는 반대창에 종속시키키: ctrl+ 이후 ctrl+alt+shift + PageUp | **파일을 좌우 왔다갔다: ctrl+alt+shift + PageUP/PageDOWN으로 ** 일반 화살표 &lt;-/ -&gt;는 탭의순서를 바꾸는 역할만한다. | . | . | . | alt+F12 : 구현부 즉시보기 . | ctrl+R2번 : 최근파일 -&gt; 최근파일 중 수정된 것만 보기 . | POSTFIX completion .if .while | . | .stream | .reqnonull | .sout .souf : 조심 블로그에 { % 찍히면 안됨 | .soutv | . | .try | .format | . | keymap &gt; go to test 검색 후 단축키 지정 : ctrl+shift+ T -&gt; 나머지 leave 테스트 없으면 생성, 있으면 이동 시켜주게 된다. | . | 중복코드 등 확인 analyze: shift2번 -&gt; inspect code...검색 &gt; ok누르면 찾아준다. . | ctrl+alt+F: 필드(인변, 클변)로 추출 (new HashMap등 제네릭 작성후 뽑을 때 유리할 듯) | 생성자에서 초기화해주는 필드 작성시? | . | ctrl+F6: 시그니처(파라미터 추가/삭제/위치변경을 스마트하게) . 대박) 추상클래스 등 부모에서 상태값 선언전에 generate로 대충 생성후 -&gt; change signature로 proteced( or public)으로 생성자 리팩토링하여 수정하면 -&gt; extends 자식들에게 super()로 내부에서 직접 갖다호출할 수 있게 정의까지 해준다. . . | . | . | 메서드 이동: keymap &gt; move statement검색후 &gt; 키맵 지정해주기 remove해도 됨. . . Move staetment Down : alt +shift + PgUp . | Move staetment Up: alt +shift + PgUp . 주의) 코드가 아니라 구현부괄호에서 작동한다. . 코드라인이 이었다면 ctrl+shit+ 를 통해 구현부 시작 괄호로 이동하해서 입력(alt+shift+PgUp/Dn)한다 . | 아래 code line에서는 작동안함 . | . | 참고) 메서드 내부 코드를 옮긴다면 alt+up/down보다 더 유용하게 code line도 이동시킬 수 있다. . | . | . | 상속/추상화 관련 작업후 다이어그램 보기: . 프로덕션의 패키지 폴더를 클릭한 상태로 ctrl+alt+shift + U . | 최근에는 ctrl+shift+ ;를 1~2번 눌러 BreadCrumb로 진입한 다음, 거기서 c+a+s+ U2번 정도 갈겨서 띄운다 . | 모드 . 기본 추상화/상속구조도 볼 때: edge create mode + field &amp; method는 기본적으로 켜두자 . . | . ​ . | 생성자 열어두기 여부를 통해 생성 경로를 포함한 추상화/상속 관계도를 볼 때 . field + 생성자 + show dependency껏다키기 -&gt; route edge는 선택 기본 필드+메서드+크레이이션 모드 | 생성자만 | 필드 + 생성자 | 필드 + 생성자 + show dependency | 필드 + 생성자 + show dependency 꺼서 보기 생성자 표기정리 좌물쇠 열림: public -&gt; 외부에서 생성 가능 | 빨간색 좌물쇠 잠김: private | 노란색 자물쇠 잠김: protected -&gt; 중간카테고리 추상클래스의 상태+생성자+getter물려줄 때, 생성자도 super()로 물려줘서 물려준 상태값을 초기화 | 회색 점 : default -&gt; 몰아놓은 package내에서만 생성가능 | . | * : final | 초록 빈 육면체 : 추클 | 파란 꽉찬 육면체 : 클래스 | . | . | . | 자동 업데이트 안되며, 껐다가 새로 다이어그램 띄워야한다. . returnType이 메서드 우측에 표기되나, null/throw처럼 확실하지 않으면 ?가 붙는다. | . . | . | ctrl+H: 찾아서(ctrl+f) 바꾸기 . ctrl + shift + h : 전체에서 찾아 바꾸기 -&gt; 쓸일 많이 없을 듯? | . | ctrl + F12 : 추상메서드의 개별 구현메서드 구현 선언부 다 표기해서 골라가기 . 보통 F12누르면.. 추상체의 추메로밖에 안가서 불편 | . . | 이름 리팩토링 with Test까지: 해당 파일 클래스명 클릭 -&gt; F2 -&gt; alt + a -&gt; tab2번 enter로 Okay *rename Test까지 뜰 때, Test도 같이 바꾸도록 Select All의 alt + A로 선택후 okay클릭 or 탭2번 | . | ctrl+alt+v : 변수추출을 우항-&gt; 좌항 변수 자동완성뿐만 아니라 긴 파라미터 위에다가 변수로 추출할 때 쓰자. . . | git history보기 : alt + ~ &gt; show history . | 코드창 빼고 다 닫기: shift + ESC . | breadCrumb 열기 : ctrl+shit+ ; . 같은 프러덕션 내 or 같은 테스트내 이동, 이걸로 움직이고 생성/삭제해도 괜찮을 듯; cf) 프 &lt;-&gt; 테 간의 이동 : go to test로 이동 ctrl+alt+T | . | . | 블럭지정을 포함한 F1 + tab or F1 + tabtabtab : 클래스명 or 메서드명 검색 . 특정단어 블럭지정 -&gt; 그 단어로 class명/method명 검색 by F1후 tab F1만 누르면 전체검색 | tab한번해서 class검색 | tab 총 3번해서 Symbols로 가면 변수 or 메서드 검색 | . | . | 오른쪽에 새창 띄우고, 왼쪽으로 커서 넘기는 새로운 방법 . 새로 오른쪽에 복제로 띄우기 ctrl + . 왼쪽으로 커서 넘어와서 (tabmover 플러그인의 c+a+s+[ ) 후 . | 왼쪽창을 Open in Opposite Group을 ctrl+alt+left로 재정의 한다음 복제후 왼쪽으로 커서 왼쪽으로 넘어오는 용도로 쓴다. . . 끄기 or ctrl+PgUp orctrl+PgDn으로 다른창으로 넘어가기 | . | | 요약 . ctlr+ 복제 -&gt; ctrl+alt+Left로 (왼쪽창을 여는 fake로)왼쪽창으로 커서 넘기기 이후론 왼쪽창 끄거나 다른창으로 넘어가기 | . | . | | 다른 window에서 editor로 넘어올 땐 Escape(ESC) . | 파라미터 힌트 완성 띄우기: ctrl+ alt+ space 파라미터 힌트 with names랑은 다른 것 | 좀 이상함. | . | related problem이 뜬 경우 . 클릭안하면 ctrl+.로 안먹는다. . | 대박Show related problembs): ctrl+space2번 or F8로 가면 노란색워닝(+전구)에서 ctrl+. . | 만약 2개 이상의 에러인 경우, alt+3의 Find창에 뜨는데 끄려면 확인후 ctrl+shift+F4 . 대박) 확인시 shift+enter로 2번째창에 띄우기 | . . | . | 대박2) 파일 아이콘 을 shift + Enter열기 : 우측에 복사해서 띄움… . | 현재 창제외 모두 종료: alt+ (X)닫기클릭 **alt + ctrl+w로 단축키 지정해주기 ** **keymap &gt; close ohter 검색후 &gt; ** Close Ohter Tabs: alt + ctrl+w | Reopen closed Tabs: shift + ctrl+w | . | . | . | 최근파일ctrl+r 2번해서 을 열어놓고 검색 + shift + endter로 우측창에 띄우기까지 하기 최근파일에서 특정 파일 검색으로 편하게 띄우기 | 특정파일의 Test등 옆에서 봐야할 파일을 shift+ Enter로 우측창에 띄우기 사실 테스트는 ctrl+ 복사 -&gt; 우측 창을 ctrl+shift+T의 go to test로 이동하는게 더 쉽다. | . | 특정파일 중에 README와 Test 등 단일로 빠르게 찾아 띄우기 기능이 좋다. readme | test | . | . | 테스트 with Coverage : alt+shift+ F10or F9(debug) -&gt;all Test -&gt; ` → Coverage 선택해서 Test돌리기` . . | ctrl+shift+ [+]: keymap &gt; expend all 검색후 &gt; 보이는 것 다 지정해줌 . 프로젝트 창에서 켜지말 것. 다 열림 | . . | 추클/인터페이스의 usage(바로 아래) vs impl(아래 최하의 구현체까지) 확인방법 . Shift + F12: usage로서, 추클인 경우, 적은 수의 extends로 사용한 자식들만 확인할 수 있다. . 중카/추클의 부모클래스에서 usage로 확인하면, extends한 같은 레벨의 자식들을 볼 수 있다. . | 같은레벨의 자식들이 뭐가 있는지 확인할 수 있다. . . | . | Ctrl + F12 : impl로서, impl한 추클의 extends자식들까지 -&gt; 중카-추클로 연결된 자식들포함 하위 구현체들 모두 . . | . | 사용처 아래 Find창에 띄우기 : Alt+F7 F12만으로 부족한 모든 사용처를 read/write별로 알려준다. | alt+3에 해당하는 Find창에 띄워진다. 참고 단축키 alt+3: find창 띄우기 | ctrl+shift+ [+] : 창 전체 expand하기 (Expand all 지정해준 것) | ctrl+shift+ F4 : 아래창 1개 끄기 | . | . | . | 메서드 파라미터 선언부에서 파라미터 순서변경: ctrl+alt+shift+화살표 만약, 일반적인 커서에서 ctrl+alt+shift+화살표 : 창이동 by TabMover | 메서드 파라미터 선언부에서 ctrl+alt+shift+화살표 : 파라미터 위치(순서)변경 | . | ParameterInfo : Ctrl+Shift+ Space 단순 파라미터 Type정보를 바로 알 수 있다! | . | 대박) 직전test Return : keymap &gt; rerun &gt; rerun 중 3번째 것 매핑 ctrl + shift+ alt+ R . | **생성자내에서 파라미터에서 ctrl+. ** 필드 추출 및 생성자 초기화 선택 가능 | 파라미터에서 ctrl+. -&gt; Replace constructor factory method : 정펙매로 빼는 것 가능 말만 replace지, 기본생성자는 private변경후 pulic 정적팩토리메서드 자동생성해준다. | . | | rerun : 단축키 ctrl +shift+ alt + R로 지정해주기 test 실패시 수정후 바로 테스트 재실행 | application 재실행 | . | shift+esc : 아래정보창 끄기 | delegate : 다른 클래스로 추출 for 조합 keymap &gt; delegate검색 &gt; [Refactor] Extract delegate &gt; ctrl+alt + D로 | 나는 무의식 중에 shift2번 + delegate로 사용함 | . | null가능성이 없는데 @Nullable 애노테이션 때문에 warning 뜨면 -&gt; suppress for method로 명시해주기 . | 메서드 생성시 cr~을 검색하면 바로 시킬 수 있다. . | ctrl+shift+k : 잘라내기(shift+ del)가 아닌 한 줄 삭제 잘라내기로 한 줄 삭제를 사용할 경우, 들고 있던 복사한 내용이 사라진다. | . | ctrl+shift+F9 : recompile for HTML 실시간 수정html이 웹에 반영된다. | java는 하더라도 서버를 재시작해야 웹에 반영되므로 아직까진 모르겠음. | . | ctrl + alt + N : 인라인 리팩터링 변수 인라인 -&gt; 변수에 커서를 데고 인라인 리팩토링하면, 변수로 뽑아 놓은 우항의 값들 -&gt; 변수는 사라지고 값이 각 변수자리에 직접 들어간다 변수 추출의 반대 | . | 메서드 인라인 -&gt; 메서드에 커서를 데고 인라인 리팩토링하면, 메서드 내부 return되던 로직들이 -&gt; 메서드는 사라지고 내부로직이 직접 들어간다 메서드 추출의 반대 메서드로 따로 존재하던 로직 | 메서드가 사라지고, 메서드 내부 로직이 들어온다. | . | 메서드 내부 로직이 바로 꺼내져 와서 context의 문제도 생기므로 잘 안쓸 듯. | . | | ctlr+shift+ DEL in html tag : 내부 태그는 놔두고, 해당 중간 태그 or 바깥 태그 등 일부 태그만 벗겨내서 지운다. java 등에선 사용 안됨. | . | class에 커서 데고 + F6 : inner class [바깥으로] 이동 [추출] python은 기본적으로 같은 .py내부에 inner class를 만든다. -&gt; 다 만들고 나서 class에 커서 데고 추출한다. | java에서도 public static 메서드만 추출했었는데, inner class도 추출된다. 말이 class추출이지 새로운 파일을 만든다. | . | . | alt + [ctlr + w] : 현재창 빼고 다 끄기 ( = alt + 파일닫기) shift + alt + x: 열린창 다 끄기 | cf) shift + alt + a : java + html 여러줄 한번에 주석(pycharm에선 안됨) | . | shift + ctrl + U : Run탭으로 가기 ctrl + u의 직전커서로 이동으로 하다가, 앞으로 갈려고 발견함 | vscode에서는 출력으로 간다. | f4 : run이 테스트일 때, 해당 테스트로 jump | . | cf) intellij default toString(String concat(+)) and equals and hashCode(java.util.Objects.equals and hashCode (java 7+)) 성능좋다고 builder로 바꿨다가. toString을 통한 java객체비교에 메모리 주소가 붙어서 안될 수 도 잇음. 컨벤션의 문제도 다시 String concat(+)로 돌림 | . | equals and hashCode도 intellij default가 있어서 봐꿨는데 다시 기본 java.util.Objects.equals and hashCode (java 7+)로 바꿈 intellj default는 기본이 아님 | . | . | ctrl+O(열기) -&gt; ctrl+2 : 프로젝트 열기 -&gt; 현재 프로젝트 폴더에 진입 . | 단축키로 윈도우폴더 열어 새로운 폴더 -&gt; 윈도우터미널(wt -d .) 열기 ctrl+shift+E(Tool Window-project) -&gt; ctrl+home(root folder) | ctrl+k+R: (루트폴더 상태)탐색기로 열기 -&gt; win+2(작업표시줄-파일탐색기) ctrl+k 누른 뒤, ctrl 떼고 R 눌러야함. | 탐색기로 열어도 바로 안뜸 -&gt; 작업표시줄 탐색기 단축키(win + 숫자로 눌러서 띄우기 | . | alt+2 : 새로운 폴더 폴더 생성 alt+1: 선택한 폴더 속성 | . | ctrl +L(주소표시줄) -&gt; wt -d . wt . 만 하면 에러 뜬다. 조심. | . | | shift + ENTER : Project(Tool window) or ctrl+shift+; or commit(alt+0) 상태에서 주위 파일 측면 창으로 열기 만약 아무파일도 안열린 상태면 F4로 jump to Source하면된다. | . | ctrl + alt + shift + C : 패키지부터~파일까지 경로 복사 alt + shift + C: 컴퓨터에서부터 경로 복사 | commit창에서 파일클릭시 비교창이 뜨는데 shift + enter로 우측체 파일을 띄울 수 있다 만약 아무파일도 안열린 상태면 F4로 jump to Source 하면된다. | . | . | commit에 대한 파일 경로 복사해서 괄호안에 넣기 정리 commit창(alt+0)으로 열고 | 해당 파일에서 F4를 통해 source파일로 가서 ctrl+alt+shift+ C를 통해 경로 복사 | 다시 commit창(alt+0)으로 와서 tab을 눌러 commit message창으로 간 뒤 | ctrl+v로 붙여놓고 앞에 세부경로 + 뒤에 확장자 및 라인을 제거(ctrl+shift+방향키4번) test파일이면, 앞에 test()로 커밋하기(test라는 경로는 안나옴) | . | ctrl+enter로 commit | | alt+ -&gt; (show검색) show history : 파일 자체의 commit 히스토리 확인 . | Database(Tool window) : keymap &gt; database 검색후 Tool Windows &gt; database의 단축키 지정 alt+D . | ctrl+shift+B: 기존 코드 수정후, 빨간줄 전파를 전체에서 찾아준다. ctrl+shift+F9: 현재코드만 리빌드 -&gt; html 수정후 바로 반영시킬 때 사용 | my ctrl + shift + B : 자바 코드 수정 후 전체파일에서 오류 찾기 Test 전체 실행 : 자바 코드 수정 후 전체파일에서 로직 오류 찾기 | . | ctrl + shift + F9 : html 코드 수정후 현재파일 업데이트 | . | . | ``ctrl + shift + up/down : 원격 데스크톱에서 멀티 커서(Clone Caret)` 단축키인 ctrl + alt + up/down 중 ctrol+alt가 먹통이어서, 원격용 멀티커서를 지정함 . | shift + F5 : 디버깅 멈추기 cf) 디버깅은 현재 테스트에 대한 디버깅이 없음… F5 or alt+shift+F5로 디버깅 지정해서 실행해야함. | run의 경우 run ant target으로 현재 커서에 위치한 테스트가 바로 실행되는데, debug ant target 은 없다. | . | test 전체 돌릴 때, ctrl+shift+;활용해서 src까지 가서 ctlr+shift+F10으로 전체 테스트 돌리기 현재 테스트파일내 전체 메서드 실행도 ctrl + shift + ; -&gt; F10으로 빠르게 돌릴 수 있다. | . | ctrl + shift + U : markdown 링크 거는 단축키 -&gt; keymap에서 Create link로 ctrl + K 추가함. vscode에서도 keyBinding을 Ctrl+K로 변경했지만, 이게 상용 단축키인가보다. | . | ctrl + alt + Q : javadoc을 renderView 봄 html 코드가 있을 경우, 예쁘게 나옴 | . | ctlr + alt + Y: refresh from disk 중복되어있다면, keymap -&gt; from disk 검색해서 이것만 살리게 한다. | . | 이미 생성된 인터페이스 구현을 쉽게하는 방법: 인터페이스 명칭에서 ctrl+.을 하면 implement interface가 뜬다. 기본 class로 구현하니 abstract(or final)를 붙여준다. | cf) 반대로 구현을 취소하는 것도 바로 가능함. | 추가로 추상클래스 구현도 추상클래스 명칭에서 ctrl+.을 활용한다. | . | class 필드 추가 순서 pf 필드를 선언 | ctrl + .으로 add construct parameter를 이용해서 없으면 생성/있으면 추가 이 방법을 써야 기존 생성자들이 있으면 자동으로 signature 변경 창을 띄우고 + 사용(호출)중인 생성자에 빨간색 추가인자를 끼워놓아 컴파일 에러로 수정하러 갈 수 있다. | 생성자 추가후 build project(ctrl+shift+B)를 활용하면, 인자 추가된 호출부들을 처리하러 갈 수 있음. | . | | README.md에서 원하는 폴더로 링크걸어주기 각자 by Repository root에서의 경로를 합해서 링크를 원하는 원하는 폴더 우클릭 &gt; Copy Path/Reference.. &gt; Path from REPOSITORY root 선택 | 현재 README.md의 위치가 root가 아니라면, root로 가는 경로 만들기 by ../ | README.md 경로(root) + 원하는 폴더(copy path) 주소 합하기 | | ctrl+shift+; -&gt; ctrl+shift+F10 해당 테스트 코드 전체 바로 돌리는 단축키 조합 | . | 이미 사용중인 메서드 삭제시 usage 확인 후 -&gt; alt+F7로 사용중인 곳 미리 띄워놓기 . | show explorer(Ctrl+K, R)시 오작동 켜지는 keyboard shortcut PDF 단축키(Ctrl+K, Ctrl+R)제거후 show explorer에 추가 배정하기 | .",
            "url": "blog.chojaeseong.com/intellij/%EC%9A%B0%ED%85%8C%EC%BD%94/%EB%8B%A8%EC%B6%95%ED%82%A4/%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8/plugin/keymap/shortcut/2022/02/13/intellij_%EB%8B%A8%EC%B6%95%ED%82%A4(%EC%99%84).html",
            "relUrl": "/intellij/%EC%9A%B0%ED%85%8C%EC%BD%94/%EB%8B%A8%EC%B6%95%ED%82%A4/%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8/plugin/keymap/shortcut/2022/02/13/intellij_%EB%8B%A8%EC%B6%95%ED%82%A4(%EC%99%84).html",
            "date": " • Feb 13, 2022"
        }
        
    
  
    
        ,"post63": {
            "title": "fastpages change index.html",
            "content": "참고블로그 및 깃허브 이분은 옛날 버전인 것 같으며, index.md로 paginationd이 작동한다. | 그러나 내 버전의 _config.yml은 md파일을 html파일로 수정하라고 명시하고 있다. | . | . index.md를 posts pagination을 제공 안함. . index.md를 사용하면, 아래 posts의 pagination이 안된다고 _config.yml에 명시되어있었다. 그래서 index.md로 빌드는 되니, 빌드후 html소스를 복붙해서 index.html로 옮기는 방식으로 꾸미려고 한다. | . | index.html을 삭제한 상태에서 main으로 빌드 되어 표기는 되더라. | . index.html -&gt; index_backup.html로 빼놓기 . root에 index.html이 존재하면, index.md이 반영이 안되어 백업해놓는다. | . index.md 생성 후 내용 채워 push . 나름의 시행착오 끝에 완성한 index.md(생성해야함.) | . layout: home search_exclude: true ![](/images/logo_github.png &quot;로고&quot;){: style=&quot;float: right; margin-left: 20px&quot; width=&quot;180&quot;} ## I&#39;m... 평범한 한의사 `돌아온범생`의 우아한 엔지니어 도전기를 기록합니다.&lt;br/&gt; &lt;br/&gt; 조재성 Jaeseong Cho | &lt;br/&gt; Doctor of Korean Medicine, Currently studying SW engineering and biostatistics&lt;br/&gt; [more...](/about) ## Posts . markdown에서 이미지를 float시키는 방법 참고해보자. . !()[]{: style=&quot;float: right; margin-left: 20px&quot; width=&quot;180&quot;} . | . . . 블로그 -&gt; 소스보기 -&gt; html코드로 복붙 . &lt;main class=&quot;page-content&quot; aria-label=&quot;Content&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;home&quot;&gt;&lt;p&gt;&lt;img src=&quot;/images/logo_github.png&quot; alt=&quot;&quot; title=&quot;로고&quot; style=&quot;float: right; margin-left: 25px&quot; width=&quot;200&quot; /&gt;&lt;/p&gt; &lt;h2 id=&quot;iam&quot;&gt;I’m…&lt;/h2&gt; &lt;p&gt;평범한 한의사 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;돌아온범생&lt;/code&gt;의 우아한 엔지니어 도전기를 기록합니다.&lt;br /&gt; &lt;br /&gt; 조재성 Jaeseong Cho | &lt;br /&gt; Doctor of Korean Medicine, Currently studying SW engineering and biostatistics&lt;br /&gt; &lt;a href=&quot;/about&quot;&gt;more…&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;posts&quot;&gt;Posts&lt;/h3&gt; . . index.html 부활시키기 + md는 삭제 . . . layout: home search_exclude: true image: images/logo_github.png &lt;main class=&quot;page-content&quot; aria-label=&quot;Content&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;home&quot;&gt;&lt;p&gt;&lt;img src=&quot;/images/logo_github.png&quot; alt=&quot;&quot; title=&quot;로고&quot; style=&quot;float: right; margin-left: 25px&quot; width=&quot;200&quot; /&gt;&lt;/p&gt; &lt;h2 id=&quot;iam&quot;&gt;I’m…&lt;/h2&gt; &lt;p&gt;평범한 한의사 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;돌아온범생&lt;/code&gt;의 우아한 엔지니어 도전기를 기록합니다.&lt;br /&gt; &lt;br /&gt; 조재성 Jaeseong Cho | &lt;br /&gt; Doctor of Korean Medicine, Currently studying SW engineering and biostatistics&lt;br /&gt; &lt;a href=&quot;/about&quot;&gt;more…&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;posts&quot;&gt;Posts&lt;/h2&gt; .",
            "url": "blog.chojaeseong.com/fastpages/2022/02/13/fastpages_%EB%A9%94%EC%9D%B8%ED%99%94%EB%A9%B4%EB%B0%94%EA%BE%B8%EA%B8%B0.html",
            "relUrl": "/fastpages/2022/02/13/fastpages_%EB%A9%94%EC%9D%B8%ED%99%94%EB%A9%B4%EB%B0%94%EA%BE%B8%EA%B8%B0.html",
            "date": " • Feb 13, 2022"
        }
        
    
  
    
        ,"post64": {
            "title": "생소한 윈도우 로고 단축키 모음",
            "content": "활용 . ctr + shift + win + {Num} : 작업표시줄에 올려진 프로그램을 관리자 권한으로 실행 . | win + m -&gt; win + shift + m : 현재창 최소화 -&gt; (작업) -&gt; 최소화 한 것 복구 . | win + ↓ : 현재 창 최소화 | win + shift + ↑: 세로 방향으로만 윈도우에 붙여 최대화 | win + shift + ↓ : 윈도우에 붙은 상태에서 붙기 전 모습 작은 창으로 복구 . | win + shift + ←, →: 윈도우 붙는 단위가 아닌 모니터별 창 이동시키기 | . 설정 관련 . win + a : 윈도우 액션 설정 창(블루투스, 핫스팍 관련) . | win + i : 윈도우 설정 창 win + u : 접근성 설정 창 | . | win + k : 연결 장치 검색 . | win + s : 작업표시줄 검색창 | . 부가 기능 . win + alt + d : 달력(다이어리) 열기 | .",
            "url": "blog.chojaeseong.com/windows/shortcut/2022/02/12/windows_unfamiliar_command.html",
            "relUrl": "/windows/shortcut/2022/02/12/windows_unfamiliar_command.html",
            "date": " • Feb 12, 2022"
        }
        
    
  
    
        ,"post65": {
            "title": "powershell_vs_bashshell명령어",
            "content": "개요 . 출저 : 유튜브-드림코딩 . | 참고 : 티스토리 리눅스 명령어모음 블로그 . | 나는 Windows Terminal을 다운 받은 뒤, powershell vs wsl에서 실습하였다. . window의 powershell은 alias를 제공하여 unix shell과 비슷한 명령어를 사용할 수 있다. . . | . | 아직 많은 개발자들이 window를 사용함 . . | . powershell 최신버전 설치 . 링크 : https://docs.microsoft.com/ko-kr/powershell/scripting/install/installing-powershell-core-on-windows?view=powershell-7.1 | . 기본 명령어 . man, clear . manual의 약자다. 잘 모를 때 참고하는 명령어 . man man . | Get-Help 명령어를 링크 해놓은 것이다. . | 청소해주는 명령어 . | . man clear clear . 파일 탐색 . pwd(경로 확인) . Print Woring Directory의 약자 | . explorer.exe .(경로상 탐색기열기) . mac에서는 open .을 사용한다. . | explorer가 아니라 explorer.exe .연다. . | . ls [하위폴더] (경로상 파일목록) . list의 약자 . | powershell에서는 mode까지 같이 나오는 반면, . powershell은 ls만 가능하다. ls -l등의 format활용은 X. 처음부터 다 보여준다. . | wsl/mac에서는 파일명만 나온다. . ls -al, ls -atl 등을 활용하면 mode까지 같이 출력된다. | . | . . | . ls . format for WSL2 . ls -l : long의 약자 . . | ls -a : all의 약자 . ui상에서는 보여주지 않는 숨겨진 폴더, 파일을 보여준다. | . . | ls -al : all(숨겨진) + long(mode까지) . . | . format for Powershell . powershell의 ls는 기본적으로 long모드로 보여주는 듯 했다. . | ls -name : 이름만 보고 싶을 때 . mac, wsl의 ls기본과 똑같다. | . | ls -force : 숨겨진 폴더, 파일을 보고 싶을 때 . . | . 폴더이동 . cd [./../-/~] . change directory의 약자 . . : 현재 경로. cd .는 제자리 이동. . | .. : 상위 경로 . | ~ : **현재설정된 사용자의 최상위 폴더 = home 디렉토리 ** . powershell에서도 cd ~를 하면, C: Users 사용자 | wsl에서 cd ~를 하면, root계정 : /root | 특정사용자 : /Users/사용자 | . | . . | - : 직전경로 . powershell은 cd -가 안된다. -&gt; 7.14버전으로 업데이트 해보는 중. . 7버전으로 업데이트하면 된다… . . | 대신, 직전경로 1번만 사용가능하며, 이후 C: 로 이동된다.. . | . | . | . | . 파일, 디렉토리 찾기 . find [경로] -type [f/d] -name “*.*” for shell . 입력한 경로부터 시작하여 하위까지 해당 파일or폴더를 찾는다. . 예시 . 나같은 경우 -type file , -type directory해도 안되길래, f, d로 약어로 넣으니 됬다. | permission denied나니까, 관리자 모드로 접속하자. | . find . -type d -name &quot;*flask*&quot; . find . -type f -name &quot;*.csv&quot; . | . | . 윈도우 폴더 탐색 (파워쉘 아닌 WindowTerminal) . - 윈도우 캡처 임시파일 저장 장소를 찾으려고 했었다. - /ad : directory 검색 - /s : 하위 폴더까지 검색 shell dir &quot;*폴더명*&quot; /ad /s . 파일 탐색 get-childitem for powershell . powershell에서는 사실상 안된다고 보면 된다. get-childitem -File -Filter &quot;*.txt&quot; -Recurse | . | . 프로그램 설치/설정 위치 . which for shell . 프로그램의 실행경로를 확인한다. . which node which code . | . gcm for powershell . get-command의 약자인 gcd를 이용한다. . | 경로는 창을 키워야 보임 . gcm node gcm code . | . 파일 생성 및 관리 . touch [파일명] (파일생성) . 존재하지 않으면, 파일 생성 | . man touch touch new_file1.txt . 이후 new_file1.txt를 열어 파일 | . new-item [파일명] for powershell . touch의 생성은 powershell에 없다. 하지만 cat, echo는 존재함. | . new-item new_file4.txt cat new_file4.txt . cat [파일] [파일2] (파일내용확인) . touch와 달리, powershell에도 사용가능함(alias존재) . | touch로 생성한 파일의 내용을 빠르게 확인 . 여러 파일을 동시에 쓰면, 붙혀서 string으로 확인됨. | . | . touch new_file2.txt cat new_file2.txt second line# cat new_file1.txt new_file2.txt first line 텍스트 추가second line# . echo “문자열” &gt;(») [파일] (&gt;파일생성+컨텐츠입력/ » 컨텐츠 추가) . 기본사용은 작성한 문자열을 터미널에 출력한다. (터미널에 에코~) 거의 사용안한다. | powershell에서도 사용가능하다. | &gt; [파일명]을 통해 파일생성+해당문자열을 컨텐츠로 넣어줌(덮어쓰기) | . echo &quot;third line&quot; &gt; new_file3.txt cat new_file3.txt third line . echo &quot;third line&quot; &gt; new_file3.txt cat new_file3.txt third line . &gt;&gt; [파일명] : 파일생성+덮어쓰기가 아니라 기존파일에 컨텐츠 append개념이다. | . echo &quot;third line--&quot; &gt;&gt; new_file3.txt cat new_file3.txt third line third line-- . 디렉토리 생성 . mkdir -p [폴더/하위폴더/하하위폴더] . make directory의 약자, 폴더 = 경로를 생성하는 명령어 | powershell 공용 | . mkdir dir1 ls -al . -p 옵션을 주면서 하위폴더들을 /로 연결하여 줄줄이 생성할 수 있다. | . mkdir -p dir2/subdir1/subdir2 ls dir2 subdir1 ls dir2/subdir1 subdir2 . 파일관리 cp/mv/rm . 3가지 다 powershell에서 사용가능 | . cp [파일] [원하는 경로/]or[새파일명] . copy의 약자 | . mv [파일] [원하는 경로/]or[새파일명] (파일이동/이름변경) . 이름바꾸는 것도 mv로 하는구나. . mv new_file2.txt file2.txt ll . | . rm [삭제파일명] / rm -r [디렉토리명] . -r 이라는 recursive옵션을 주면 디렉토리삭제+하위경로도 삭제 2가지 역할을 해주게 된다. 파일삭제는 rm 파일명 | 디렉토리삭제는 rm -r 디렉토리명 | . | . rm new_file4.txt rm -r dir3 . rm [디렉토리] 후 선택 / rm [디렉토리] -Recurse . 이부분 만 shell과 다름. | 그냥 rm하면 경고창(wsl)없이 선택화면이 나온다. 디렉토리를 선택하면됨. | 디렉토리 빠르게 삭제는 -r 옵션을 중간에 주는게 아니라 마지막에 -Recurse powershell에서도 마지막에 -r 줘도 삭제되는 듯 싶다. | . | . Grep (select-string) . Global regular expression print 의약자. . | 파일에서 검색 or *를 활용한 프로젝트 전체폴더에서 검색 . | . grep “검색문자열” [파일명] . grep &quot;line&quot; *.txt file2.txt:second line new_file1.txt:first line new_file3.txt:third line new_file3.txt:third line-- . grep -n : 라인정보 같이출력 . 찾은 것이 몇번째 라인에 있는지까지도 같이 출력 | . grep -n &quot;line&quot; *.txt file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . grep -ni : 대소문자상관없이 검색후 라인정보출력 . -i : intensive 옵션을 주면 대소문자 상관없이 검색하라는 말이다. | . grep -ni &quot;LINE&quot; *.txt file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . grep -nir “문자열” . : 프로젝트최상경로에서 하위끝까지 전체를 검색 . grep -nir &quot;LINE&quot; . ./file2.txt:1:second line ./new_file1.txt:1:first line ./new_file3.txt:1:third line ./new_file3.txt:2:third line-- . select-string [파일명] -pattern “검색문자열” . default로 대소문자상관없이 + 라인정보도 같이 출력된다. . select-string *.txt -pattern &quot;LINE&quot; file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . | . select-string [*, */*] -pattern “검색문자열” . -ni는 자동이고, -r 옵션은 없어서 직접 *와 ,를 연결한 경로를 지정(경로패턴)해줘야 전체 프로젝트 검색이 된다. | . select-string *, */* -pattern &quot;LINE&quot; file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . 대소문자를 구분하고 싶다면, 맨 뒤에 -CaseSensitive옵션을 주면 된다. | . 환경변수 설정 . 모바일, 웹 개발시 환경변수를 설정함 | 내 컴퓨터에서 특정한 키워드가 어떤 일을 하거나 경로를 저장할 수 있게 만드는 것. | . env . 지정한 환경변수 목록을 본다. 사용시에는 앞에 $를 붙인다. . env . | . ls env: . powershell에서 보는 환경변수목록. 사용시에는 $env:를 앞에 붙인다. . ls env: . | . export [대문자_변수명]=”경로or문자열” (환경변수 설정) . 대문자를 사용하고 사이에는 _를 이용하여 구분한다. . mkdir dir1 env # 모든 환경 변수 확인 export MY_DIR=&quot;dir1&quot; . | . $env:[환경변수명] = “경로or문자열” for powershell . $env:MY_DIR = &quot;dir1&quot; . cd $환경변수명 (환경변수 사용) . 환경변수를 터미널 등에서 사용할 수 있다. . cd $MY_DIR pwd . | . cd $env:[환경변수명] for powershell . unset 환경변수명 (환경변수 삭제) . unset MY_DIR env . $env:[환경변수명] = “” . powershell에서 환경변수 삭제는 빈 문자열을 넣어서 없애준다. . $env:MY_DIR = &quot;&quot; ls env: . | .",
            "url": "blog.chojaeseong.com/shell/powershell/windowsterminal/terminal/windows/command/2022/02/12/powershell_and_bashshell.html",
            "relUrl": "/shell/powershell/windowsterminal/terminal/windows/command/2022/02/12/powershell_and_bashshell.html",
            "date": " • Feb 12, 2022"
        }
        
    
  
    
        ,"post66": {
            "title": "전략,팩토리,싱글톤,hasNext,isEmpty",
            "content": "전략패턴 for 대체를 [테스트에서 상수]로 . 전략패턴은 전략을 사용자가 선택해서 상황에 맞는 행동을 하게 할때 주로 사용 필요시 다른 환율적용한 계산 반영 | 해쉬값 생성시 알고리즘을 다르게 적용 | 다른 적용 전략으로서 [랜덤값 포함 조건문] -&gt; [()- &gt; true] 테스트에 적용 여기서는 랜덤값을 -&gt; 테스트용 상수로 적용하기 위해서, 랜덤값 포함 조건문에 전략패턴을 건다 | . | 예시 코드 블로그(노션) | . | . 바뀔 수 있는 부분을 잡아서 상태에 맞게 메소드로 추출해놓는다. . 해당메소드는 인터페이스 impl 구상클래스로 갈 것이다. . public void move() { if( Util.generateRandomNumber() &gt;= 4 ){ this.position++; } } . public void move() { if(isMovable()){ this.position++; } } private boolean isMovable() { return Util.generateRandomNumber() &gt;= 4; } . | . | 인터페이스 XXXXStrategy + 이름만 가진 추상메서드를 만든다. . 랜덤한 조건문이 -&gt; 테스트용으로 대체될 예정이라면 -&gt; boolean등 반환형 + 추출한 메서드를 추상메서드로 이름만 정의한다 | . public interface MoveConditionStrategy { boolean isMovable(); } . | 특정Strategy의 이름을 정해서 impl구상클래스를 추출메소드를 복붙해서 구현한다. . public class RandomMoveConditionStrategy implements MoveConditionStrategy{ @Override public boolean isMovable() { return false; } } . public class RandomMoveConditionStrategy implements MoveConditionStrategy{ @Override public boolean isMovable() { return Util.generateRandomNumber() &gt;= 4; } } . | 특정전략의 메소드가 사용된 곳마다 —&gt; 다른전략을 허용하는 추상화된 인터페이스 객체를 인자로 받은 뒤 -&gt; 추상체.추출메소드()호출로 수정한다. . public void move() { if(isMovable()){ this.position++; } } . public void move(MoveConditionStrategy moveConditionStrategy) { if(moveConditionStrategy.isMovable()){ this.position++; } } . | 이제 에러난 부분을 타고가면서, 내부 매개변수 정의에 사용된 추상 인자를 호출하는 외부 인자 자리에 new 특정전략()를 넣워준다. . 여기서는 매 car마다 랜덤 전략이 각각 적용되어야하는 부분 -&gt; 특정전략을 인자로 넣어준다. | . public void move() { this.cars.forEach(car -&gt; car.move()); } . public void move() { this.cars.forEach(car -&gt; car.move(new RandomMoveConditionStrategy())); } . | 테스트에서 다른전략으로 조건부의 상수인 람다함수로 () -&gt; true를 대입하여 움직임을 확인한다. . 랜덤이 섞인 기능은 테스트하기 힘들다 -&gt; 전략자리로 바꿔서 항상 같은 값인 상수를 들어가게해서 다른 기능을 테스트한다. | . @Test void 자동차_움직임() { Car js = Car.of(&quot;js&quot;); // +1 움직임의 조건부를 &lt;다른전략 사용가능한 전략패턴&gt;으로 정의했으니 -&gt; 특정전략을 넘겨 결정한다. RandomMoveConditionStrategy randomMoveConditionStrategy = new RandomMoveConditionStrategy(); js.move(randomMoveConditionStrategy); js.move(randomMoveConditionStrategy); js.move(randomMoveConditionStrategy); js.printPosition(); // 전략자리-랜덤조건부 대신&gt; [다른전략으로서 람다함수 상수로서 true]로 줘버릴 수 있다. // -&gt; 테스트용으로 항상 움직임을 확인할 수 있다. Car jk = Car.of(&quot;jk&quot;); jk.move( () -&gt; true); jk.move( () -&gt; true); jk.move( () -&gt; true); jk.printPosition(); } js의 위치: 0 jk의 위치: 3 . | 정적 팩토리 메소드 네이밍 컨벤션 . from: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메소드 ex) Date d = Date.from(instant); | Of: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메소드 ex) Set faceCards = EnumSet.of(JACK, QUEEN, KING); | valueOf: from과 of의 더 자세한 버전 ex) BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);; | instance 혹은 getInstance: 매게변수를 받는다면 매게변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다. ex) StackWalker luke = StackWalker,getInstance(options); | create 혹은 newInstance: instance 혹은 getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장한다. . | 참고: 생성자내부에서만 this.필드 = 할당이 가능함. 팩토리 메서드는 변환or검증만 | . 싱글톤 패턴(관리자Machine, InputView스캐너) . //1. class내부에 default생성자로 static finale 객체를 미리 생성해놓는다 -&gt; for getInstance시 반환할 수 있게 미리 생성 private static final $CLASS_NAME$ $VALUE_NAME$ = new $CLASS_NAME$(); //2. 차후 입력시, 싱글톤이 받아서 [관리하는 데이터]를 쌓아둔다. //private Cars cars; //3. 싱글톤 private생성자는 미리 생성해야해서 매개변수 없이 default생성자로 만든다. private $CLASS_NAME$() { } //4. 관리자로서 [관리 데이터]를 매 구동시 초기화 할 수 있게 한다. public void init() { // this.cars = new ArrayList&lt;&gt;(); } //5. 싱글톤은 언제든지 부르면 나갈 수 있게 public static getInstance()메소드르 ㄹ정의한다. public static $CLASS_NAME$ getInstance() { return $VALUE_NAME$; } . //1. class 내부에 default? 생성자로 미리 static final 객체 생성 private static final Scanner scanner = new Scanner(System.in); //2. 싱글톤scanner(getInstance) + .nextLine() &gt; getInput()으로 싱글톤 + 메서드까지 사용 public static String getInput() { return scanner.nextLine(); } . 값객체.hasNext()패턴 . if 남은수 0보다 큰지 물어본다 0보다 크면 1빠진 값객체로 재할당받고 | true를 return해서 바깥 반복문이 계속 돌아가게 한다. | . | 남은수가 0보다 같거나 작으면 false를 return해서 바깥 반복문에 진입을 막는다. | . | public boolean hasNextGame() { if (this.gameCount.moreThanZero()){ this.gameCount = this.gameCount.next(); return true; } return false; } //... public boolean hasNextGame() { return count &gt; 0; } public Count next() { return new Count(this.count - 1); } . isEmpty &lt; isBlank . isEmpy: &quot;&quot;의 빈값 | isBlank: &quot;&quot;를 포함하여 &quot; &quot;까지 다 True되는 넓은 범위 | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/11/%EC%A0%84%EB%9E%B5,-%ED%8C%A9%ED%86%A0%EB%A6%AC,-%EC%8B%B1%EA%B8%80%ED%86%A4,-hasNext,isEmpty.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/11/%EC%A0%84%EB%9E%B5,-%ED%8C%A9%ED%86%A0%EB%A6%AC,-%EC%8B%B1%EA%B8%80%ED%86%A4,-hasNext,isEmpty.html",
            "date": " • Feb 11, 2022"
        }
        
    
  
    
        ,"post67": {
            "title": "TDD 1 문자열계산기",
            "content": "TDD . red -&gt; green -&gt; refactoring . 실패하는 코드(red)부터 짠다. . 테스트코드부터 짠다. | 프로덕션 코드를 생성하지 않은 체로 작성하면서 생성한다. | given(data), when(actual), then(assert문)의 순서로 짠다. | 최초 에러를 내기 위해 throw new IllegalStateException();를 활용한다. | | green을 만들 때는, 모든case 통과 풀 구현이 아니라, (현재까지의 테스트를 모두 만족시키는) 최소한의 최소한의 수정만 한다. . 예를 들어 expected 1을 만족시키는 코드를 짤 때 . return Integer.parseInt(&quot;1&quot;);이 아닌 return 1;으로 짜야한다. | . | 임의의 1개 case가 아닌 다양한 expected를 만족시켜야할 경우, assert문을 여러개 짜지말고, @Test메서드를 늘려서 2번째부터는 일반화시키는 풀구현을 하자. . @Test void splitAndSum_숫자하나() { final int actual = StringCalculator.splitAndSum(&quot;1&quot;); assertThat(actual).isEqualTo(1); //assertThat(actual).isEqualTo(2); } // assert문 추가가 아니라 테스트를 추가한다. @Test void splitAndSum_숫자하나_2() { final int actual = StringCalculator.splitAndSum(&quot;2&quot;); assertThat(actual).isEqualTo(2); //에러를 고치려면 어쩔 수 없이 2번째부터는 일반화된 풀 구현 } . | . | refactoring은 . 메서드 추출 시, 새롭게 추출된 메서드의 관점에서 인자를 수정할 수 도 있다. . 대상: indent를 늘리는 반복문을 포함한 부분 or 다른 일을 하는 곳 . 참고: method refactoring | . | 인자에 final을 달아서 엄청 긴 코드의 끝에서도 안심하고 사용할 수 있게 해보자. 요즘 언어들은 불변을 default로 한다고 한다. . | 매개변수의 이름도 바뀌어야한다 splitValues -&gt; values . //private static int sum(String[] splitValues) { private static int sum(String[] values) { int result = 0; for (String value : values) { result += Integer.parseInt(value); } return result; . | . | . | 복잡한 요구사항 -&gt; 쪼갠 학습테스트 활용 . 예를 들어, 문자열을 커스텀 문자열로 split -&gt; sum 을 구해야하는데, 일단 split부터 되도록 학습테스트를 작성한다. . 요구사항 . @Test void splitAndSum_custom_구분자() { final int actual = StringCalculator.splitAndSum(&quot;//; n1;2;3&quot;); assertThat(actual).isEqualTo(6); } . | 단계별 학습테스트 추가 1 . 쪼갰을 때 나와야하는 값을 expected로 생각하고 테스트하면 된다. | . @Test void split() { // given final String text = &quot;//; n1;2;3&quot;; // split해보고 -&gt; **내 기준에서 나와야하는 값(**이게 나와야한다**)을 &lt;expected&gt;자리에 넣고 테스트해본다.** // when String[] splitValues = text.split(&quot; n&quot;); assertThat(splitValues[0]).isEqualTo(&quot;//;&quot;); // 앞부분에서 나와야하는 값이 통과했다면, -&gt; 뒷부분도 테스트 코드를 추가해서 돌려본다. assertThat(splitValues[1]).isEqualTo(&quot;1;2;3&quot;); } . | 단계별 학습테스트 추가2 . 잘 쪼개졌어도, 구분자가 기존 코드와는 다른 경우이므로, if 검사 후 -&gt; ealry return 로직을 추가해야하는 상황이다. 특정 경우를 잘 골라내는지 boolean이 expected로 되는 학습테스트를 추가하자. | . | . @Test void startsWith() { //given // data -&gt; &quot;//&quot;로 시작하는지를 확인하는 학습테스트를 만든다. final String text = &quot;//; n1;2;3&quot;; //when // actual -&gt; 슬래쉬 2개로 시작하는 커스텀이냐? boolean isCustom = text.startsWith(&quot;//&quot;); //then // expected -&gt; 나와야하는 값 = true assertThat(isCustom).isTrue(); } . | 학습테스트 통과한 코드를 —&gt; 프로덕션 코드에 반영하자 . | . | . 일부분 수정(private함수or 코드) TDD -&gt; 영향받지 않게 복붙메서드 활용 . [private ] 특정함수 수정 TDD -&gt; Test에 [특정함수]만 복붙 . 요구사항: 음수 -&gt; 예외발생시키세요. -&gt; split한 리팩토링으로 splitAndSum 중 private sum()함수만 TDD해야한다. . Test클래스로 private함수를 복붙해온다. . 복붙을 한 순간, 기존 코드에 영향주지 않는 코드가 된다. | XXX.sum() -&gt; XXXTest.sum()으로 사용해서 테스트할 예정이다. | . | 전체 메서드(splitAndSum)중 일부분(sum())만 가져왔으므로 테스트 호출 메소드도 달라질 것이다. . 기존 전체메서드 테스트 가정 (나중에 완성될 테스트) . @Test void splitAndSum_negative() { assertThatThrownBy(() -&gt; StringCalculator.splitAndSum(&quot;-1,2,3&quot;)) .isInstanceOf(RuntimeException.class); } . | 일부분(전체에 비해 인자 달라짐) 메서드 테스트 ( Test로 복사해온 private함수라 XXXXTest.sum() ) . void sum_negative() { // sum(&quot;-1,2,3&quot;); // sum(&quot;-1,2,3&quot;.split()) // StringCalculatorTest.sum(&quot;-1,2,3&quot;.split(&quot;,&quot;)); assertThatThrownBy(() -&gt; StringCalculatorTest.sum(&quot;-1,2,3&quot;.split(&quot;,&quot;))) .isInstanceOf(RuntimeException.class); } . | Test코드로 복붙해온 일부분 메서드( 이놈을 수정해서 구현후 반영할 예정 ) . private static int sum(String[] values) throws RuntimeException { int result = 0; for (String value : values) { result += Integer.parseInt(value); } return result; } . | . | 예외처리 로직을 중간에 추가 by 변수 추출 . 좌항 = 우항 으로 우항이 할당되기 전 &lt;if 예외처리&gt;로직 추가를 위해서 변수 추출(Ctrl+Alt+V)을 활용한다. . result += Integer.parseInt(value); //우항이 넘어가기 전에 받아준다. int number = Integer.parseInt(value); result += number; int number = Integer.parseInt(value); // 우항이 넘어가기전에 받아 예외처리를 해준다. if (number &lt; 0) { throw new RuntimeException(); } result += number; . | . | 테스트통과시 복붙한 sum()메서드를 -&gt; 원본에 반영 + 원본 테스트함수 돌려보기 . 끝난 코드는 날리는게 맞다. | . | | . [public ] 특정[코드] TDD -&gt; 바로 밑에 [코드포함 222메서드 함수] 복붙 . 예를 들어, 어느정도 완성된 public splitAndSum() 메서드에서 text==null이외에 text.isEmpty() 검사를 추가하고 싶다. 하지만, 이미 다른 코드들과 섞여있는 일부분의 코드이므로 다른 코드에 영향주지 않게 테스트하려고 한다. . 코드를 포함한 메서드 복사 붙혀넣기를 통해 기존 코드 영향 받지 않는 메소드2를 새롭게 생성해서 테스트한다. . // 기존 메소드 public static int splitAndSum(final String text) { if (text == null) { return 0; } return sum(split(text)); } // if 조건에 .isEmpty()를 추가할 예정인데 -&gt; sum(split(text)))가 섞여있으므로 // 코드 수정시 영향이 갈 수 있다. // -&gt; 포함 메서드를 통째로 복붙한 메서드2로 테스트한다. // 대신 테스트할 메서드2 public static int splitAndSum2(final String text) { if (text == null || text.isEmpty()) { return 0; } return sum(split(text)); } . | 메서드2로 테스트하는 테스트메서드를 생성한다. . 기존 null테스트에서 인자 + expected(나와야할 값) + 복붙한 메서드2()로 이름 바꾸기 | . //splitAndSum2 를 테스트 @Test void splitAndSum_emtpy() { final int actual = StringCalculator.splitAndSum2(&quot;&quot;); assertThat(actual).isEqualTo(0); } . | 테스트가 완료되면 수정된 일부 코드만 기존함수에 반영하고, 222메서드랑 테스트는 날린다. . if (text == null || text.isEmpty()) . | . | . 그외 . assertThat()을 여러게 사용하지마라 -&gt; 테스트를 그만큼 만들다보면 일반화 혹온 @ParameterizedTest활용 | . | 테스트메서드는 영어로 대충 짓고 -&gt; @DisplayName()으로 한글을 제대로 적어주자. | private함수를 Test에 복붙해서 테스트하는 것외에 접근제어자를 지워 default로 만들어서 테스트할 수 도 있다. | 메서드명은 snake_Case를 써도 된다. | . 상수화 네이밍 . 검증시 if ~ thr로직 -&gt; checkXXXX . | index들 -&gt; CASE_CASE2_INDEX / 구분자 -&gt; CASE_CASE2_DELIMITER . if (text.startsWith(&quot;//&quot;)){ String[] splitValues = text.split(&quot; n&quot;); String delimiter = splitValues[0].substring(2); String customText = splitValues[1]; return customText.split(delimiter); } if (text.startsWith(CUSTOM_PREFIX)){ String[] splitValues = text.split(CUSTOM_DELIMITER); String delimiter = splitValues[CUSTOM_DELIMITER_INDEX].substring(CUSTOM_PREFIX.length()); String customText = splitValues[CUSTOM_TEXT_INDEX]; return customText.split(delimiter); } . | 특정문자열 다음에 나오는 문자열 추출 -&gt; substring( 특정문자열.length() ) . 예를 들어, “//;”에서 ;를 추출하고 싶다면? | ”//;”.substring( “//”.length()) text.substring( CUSTOM_DELIMITER_PREFIX.length() ) | . | . | assert문을 여러개하지말고, 테스트를 추가하다보면, 일반화할 수 밖에 없다. . | . 강타입 vs 약타입 . 강타입 : 자료형이 맞지 않을 시에 에러 발생, 암묵적 변환을 지원하지 않음 | 약타입 : 자료형이 맞지 않을 시에 암묵적으로 타입을 변환하는 언어 | . 정적타입 vs 동적타입 . 정적타입 언어 : 정적타입 언어는 컴파일 시에 변수의 타입이 결정되는 언어를 의미한다. | 동적타입 언어 : 동적타입 언어는 런타임 시 자료형이 결정되는 언어를 의미한다. | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/11/TDD-%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%84%EC%82%B0%EA%B8%B0_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/11/TDD-%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%84%EC%82%B0%EA%B8%B0_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Feb 11, 2022"
        }
        
    
  
    
        ,"post68": {
            "title": "DTO와 VO를 비교",
            "content": "DTO vs VO . 참고 사이트 테크톡1 | 테크톡2(인비) | 포모 블로그 | . | . 혼용 사례 . 특정 책 1판에 의해서 사람들이 잘못 인지하게 됨. 지금은 데이터 전달은 TO + Data -&gt; DTO로만 사용 | VO = 값 표현용 | . | . DTO(Data Transfer Object) . DTO는 프로세스 간에 데이터를 전달하는 객체 | 주로 비동기 처리를 해야할 때 사용 | 로직을 갖고 있지 않은 순수한 데이터 전달객체라 setter(보내는쪽)/getter(받는쪽)로만 구성되는데, DB에서 값을 받아오므로 setter가 없이. 생성자에서 값할당한 이후 끝. . | 정확히는 계층간 데이터 전달 객체 Controller(웹)와 Service(서비스)사이에 데이터 전달용으로 사용된다. | . | . 예시를 통한 DTO 학습(CrewDto) . . service layer에서 데이터를 보낼 때 (받는 쪽에서 사용하라고 정의만) . createXXX()메서드를 통해 DTO생성 + Dto에 정의한 setter()로 데이터 박아로 데이터전달`을 수행한다. | . | controllerlayer(웹 레이어)에서 데이터를 받을 땐 . **service에 정의해둔 createXXX()메서드를 통해 -&gt; ** 데이터박힌 DTO 생성 | DTO.getter로 데이터들 받기 | . | . | setter를 제거하고 생성자로만 데이터를 받아 생성된 불변의 DTO주도록 수정 . setter를 삭제한다 -&gt; VO처럼 불변객체가 됨 -&gt; 데이터 전달과정 시 불변성 보장 -&gt; 안정적 | . . | . Entity와 분리 . . View는 요구사항에 의해 자주 변경되는 부분이다. entity기준으로 테이블 생성/ 스키마변경하는 class -&gt; 요청/응닶값 전달 클래스로 사용하지 말 것 view변경시마다 entity도 매번 변경해야함. | 관련된 수많은 비지니스 로직(class)들이 영향을 끼치게 됨. | . | view변경에 따라 -&gt; 다른 class에 영향을 끼치지 않는 DTO class를 요청/응답값에 사용 join한 결과값 조회 -&gt; entity로는 다 표현X | . | . | . 예시(로또, Car 정의) . 예시 - 로또 . | 예시 - Car . class CarDTO { private String name; private int position; } . 생성이후 OutputView로 가공된 DTO 객체를 보내줄 수 있습니다. | . | . 특징 . 데이터 접근 메서드만 가진다. | 정렬과 직렬화 메서드는 가질 수 있다. | 데이터 캡슐화 -&gt; 유연하게 대응된다. 데이터 요청수 감소 효과 | . | VO(Value Object) . 값 객체 | VO의 핵심은 equals()와 hashcode()를 오버라이딩하하여 내부에 선언된 속성(필드)의 모든 값들이 같으면 &gt; 똑같은 객체라고 판단하게 한다 | 원시 값을 감싼다 -&gt; validation이 가장 큰 역할 중 하나 my) 식별자로 접근해야 데이터 변화에 대응한다 | . | . 예시를 통한 VO 학습(Money) . 고유번호 = 내부 값이 같으면 -&gt; 같은 객체 . | Money class . . VO는 값 자체 표현 = DTO처럼 불변 객체 DTO처럼, setter성격의 메소드 X 생성자로서만 초기화 | VO는 DTO와 달리 getter이외에 로직을 포함 ex&gt; getHalfValue | . | . | 일반적인 객체 -&gt; equals비교와 hashCode비교가 불일치로 나온다. . . | 완전한 VO를 위하여 . hashCode()의 return값 비교 -&gt; 같으면 equals()로 한번더 비교 . | 완전한 VO == 객체를 속성값으로만 비교하게 하기 위해 -&gt; 2개 메소드 오버라이딩 . 속성값인 value로만 비교할 수 있게 된다. | . . | . | . 예시(Car) . Car - 움직임이 있다면( 내부 속성이 변함) -&gt; new 새로운 객체로 반환하여 -&gt; 원래 자기가 가지던 값은 변하지 않고 -&gt; 변한 것은 다른 값 객체로 취급 . 내부속성 변화가 없다면 (움직이지않았다면) -&gt; 자기자신 반환 return this; | . public Car move(int randomNum) { if (randomNum &gt;= MOVE_POINT) { return new Car(this.name, position+1) } return this; } . | . 특징 . 값 자체로 의미를 가진다. . | 변하지 않는 값을 가진다 . 불변 보장(변하면 새객체)해서 안전성과 생산성 | . | 객체 비교시 ID를 사용하지 않음 . | 같은 객체로는 속성들의 값을 비교한다. . | DTO와 VO공통점과 차이점 . DTO: 레이어간 데이터 전달을 위함 객체 동등비교시, 속성값 같다고 같은 객체 아니다. | setter를 넣어준다면 가변, 보통 불변 | getter/setter외 로직X | . | VO: 값 자체 표현 객체 동등비교시, 속성값 같으면 같은 객체 by 오버라이딩 | setter없이 생성자로 초기화하는 불변 | getter/setter외 로직을 가질 수 있다. | . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/11/DTO-vs-VO(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/11/DTO-vs-VO(%EC%99%84).html",
            "date": " • Feb 11, 2022"
        }
        
    
  
    
        ,"post69": {
            "title": "method refactoring",
            "content": "메소드관련 리팩토링 . . . 01 메서드 추출로 [for indent] 제거 . . indent는 메서드 분리로 해결한다. . . | . 02 early return으로 [else] 제거 . else 제거 by early return . . | . . 03 메서드 분리 -&gt; [일을 1가지씩 순차적으로] . 1가지 일만하도록 메서드 분리 convert(문자열[]-&gt; 숫자[] ) + 누적합sum | . | . . . 보기 좋음 »&gt; 약간의 성능저하 | . 04 로컬변수 제거 -&gt; [ line 줄이기] . . . 05 compose method 패턴 -&gt; [조건문 보기 좋게] . 조건문에 적용: https://wooyaggo.tistory.com/34 | 심화: https://mygumi.tistory.com/343 | . . 조건문을 의도를 가진 메서드로 바꾼다 -&gt; 파라미터의 type이나 조건이 바뀔 때 사용된 조건문을 일괄해서 바꿀 수 있다. | . . 읽기좋게 레벨 맞추기 . . | 비교 . . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/10/method_refactoring(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/10/method_refactoring(%EC%99%84).html",
            "date": " • Feb 10, 2022"
        }
        
    
  
    
        ,"post70": {
            "title": "assertj 및 @annotation 모음",
            "content": "학습 테스트 with Junit5 . 학습테스트: 모듈 사용법 읽히기 -&gt; 다른사람이 만든 코드(api)를 검증 = 학습 테스트 | 단위테스트: 내가 짠 코드를 검증하기 위해 만드는 테스트 단위테스트부터 모든 코드를 설계하는 -&gt; TDD | . | . StringTest . dependency . build.gradle에 assertj추가 -&gt; depenecies run or 우측에 gradle &gt; Reload All Gradle Project . testImplementation &#39;org.assertj:assertj-core:3.22.0&#39; . assertThat()메서드 사용안될 시 . import static org.assertj.core.api.Assertions.*; . | . | assertThat . given(data) -&gt; when(actual값) -&gt; then(expected넣어서 비교) 나눠서 코드를 짠다. . 배열 Test: .contains( ) or .containsExactly() + 콤마로 개별원소 입력 | . @Test void 숫자2개_분리() { //given String data = &quot;1,2&quot;; //when String[] actual = data.split(&quot;,&quot;); //then // assertThat(actual).contains(&quot;1&quot;, &quot;2&quot;); assertThat(actual).containsExactly(&quot;1&quot;, &quot;2&quot;); } @Test void 숫자1개_분리() { //given String data = &quot;1&quot;; //when String[] actual = data.split(&quot;,&quot;); //then // assertThat(actual).contains(&quot;1&quot;, &quot;2&quot;); assertThat(actual).containsExactly(&quot;1&quot;); } @Test void 괄호제거() { String data = &quot;(1,2)&quot;; String actual = data.substring(1, 4); assertThat(actual).isEqualTo(&quot;1,2&quot;); } . | assertThatThrownBy . 지정한 에러가 나타나야 통과 . 에러 내는 테스트는 assertThatThrownBy( () -&gt; {} ).isinstanceof();에다가 예외이름.class를 인자로 줘서 해당 예외일때 통과된다. . **필요하다면, 해당에러 + 에러메세지까지 확인하기 위해 .hasMessageContaining( &quot;메세지&quot; );까지 체이닝한다. ** | . //원하는 에러을 안줬더니... 테스트 통과 못한다. @Test @DisplayName(&quot;문자열 인덱스 에러 테스트1&quot;) void 문자열_인덱스_테스트() { assertThatThrownBy(() -&gt; { &quot;abc&quot;.charAt(4); }).isInstanceOf(IllegalArgumentException.class); } // java.lang.AssertionError: // Expecting actual throwable to be an instance of: // java.lang.IllegalArgumentException // but was: // java.lang.StringIndexOutOfBoundsException: String index out of range: 4 @Test @DisplayName(&quot;문자열 인덱스 에러 테스트2&quot;) void 문자열_인덱스_테스트2() { assertThatThrownBy(() -&gt; { &quot;abc&quot;.charAt(4); }).isInstanceOf(StringIndexOutOfBoundsException.class); } . | assertThatThrownBy + hasMessageContaining . 해당 에러 + 해당 메세지까지 내어야 통과 . 도메인 생성자에 포함된 로직에서 메세지까지 같이 검사하자 | . @DisplayName(&quot;로또 번호가 유효하지 않는 경우 예외를 발생시킨다.&quot;) @ParameterizedTest @ValueSource(strings = {&quot;0&quot;, &quot;46&quot;, &quot;-1&quot;}) void input_lottoNumber_invalid(final String number) { assertThatThrownBy(() -&gt; new LottoNumber(number)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;로또 번호가 유효한 범위&quot;); } . | . 자동차경주 . assertDoesNotThrow . assertThatThrownBy와 달리 에러가 안나야 통과 . @ParameterizedTest @ValueSource(strings = {&quot;o&quot;, &quot;brown&quot;}) @DisplayName(&quot;1이상 5이하의 자동차 이름의 길이 확인&quot;) public void car_name_length_of_positive_name(String name) { assertDoesNotThrow(() -&gt; new Car(name)); } . | . assertThat().isNotNull(); . inputView에서 하는 null or Empty검사시 할 것 같다. | . final Car car = new Car(&quot;재성&quot;); assertThat(car).isNotNull(); . assertThat( service ).extracting(“내부 인스턴스 변수”) . service 내부에 존재하는 일급or객체List를 toDto로 가져오는 반면, VO나 단일 값 변수는 직접 가져와 객체-예상객체 / 값-예상값으로 비교할 수 있다. | . @Test void get_round() { racingService = new RacingService(carNames, 5); //when, then assertThat(racingService).extracting(&quot;round&quot;).isEqualTo(new Round(5)); } . 범위검사 . 값 1개: 랜던뽑기를 여러번 @RepeatedTest(100) + assertThat().isBetween(a,b) 랜덤응답의 범위 검사 . //사용할 객체 만들고 RandomNumberGenerator randomNumberGenerator; @BeforeEach void setUp() { randomNumberGenerator = new RandomNumberGenerator(); } //응답값의 범위 확인을 여러번 @RepeatedTest(100) void range_test() { assertThat(randomNumberGenerator.generate()).isBetween(0, 9); } . 랜덤값 List 원소들 : 매번범위 검사 : listIterator()를 만든 뒤, while( .hasNext() )동안 next()하면서, 체이닝으로 .크거나같(최소값 객체) .작거나같(최대값 객체) . @Test void Random_숫자범위_검사() { // 원래는 랜덤으로 차있는 list -&gt; iterator final ListIterator&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 44, 45).listIterator(); // 랜덤값들을 돌면서 검사 while (numbers.hasNext()) { assertThat(numbers.next()) .isGreaterThanOrEqualTo(1) .isLessThanOrEqualTo(20); } } . SetTest . @BeforeEach . 매번 초기화해야하는 변수는 Test안에서의 class &lt;빈&gt; 변수 + @BeforeEach로 정의한 setUp메소드에서 초기화 + 데이터삽입해준다. . public class SetTest { // [빈 변수] -&gt; 매 TEST마다 초기화+데이터 삽입을 반복해준다. private HashSet&lt;Integer&gt; numbers; @BeforeEach void setUp() { numbers = new HashSet&lt;&gt;(); numbers.add(1); numbers.add(1); numbers.add(2); numbers.add(3); } @Test void 사이즈_확인() { //given, when int size = numbers.size(); //then assertThat(size).isEqualTo(3); } } . | @ParameterizeedTest . @ValueSource . @ParameterizedTest로 중복해서 테스트할 필요없이, given으로 들어갈 메소드인자 or given + expected로 들어갈 메소드 인자들을 지정해서 여러 케이스를 테스트한다. . @ValueSource(ints = {1,2,3,4}) . 한가지 값만 뿌려줄 때 | . @ParameterizedTest @ValueSource(ints = {1,2,3,4}) public void set_contains(int number) { assertThat(numbers.contains(number)).isTrue(); } . | . @CsvSource . @CsvSource(value = {“1:true”, “2:true”, “3:true”, “4:false”}, delimiter = ‘:’) . 여러가지 값 -&gt; 여러개의 인자로 뿌려 줄 때 | delimiter 옵션을 안쓰려면, 그냥 ,콤마로 데이터들을 구분해주면 된다. @CsvSource({“1:,rue”, “2,true”, “3,true”, “4,false”}) | . | . @ParameterizedTest @CsvSource(value = {&quot;1:true&quot;, &quot;2:true&quot;, &quot;3:true&quot;, &quot;4:false&quot;}, delimiter = &#39;:&#39;) void set_contains2(int number, boolean expected) { assertEquals(numbers.contains(number), expected); } . | . @NullAndEmptySource . 테스트 메서드의 인자에다가 @어노테이션으로는 null을 넘길 수 없다. . @NullAndEmptySource를 달아주면, 인자에 1,2번째로 null과 emtpy가 전달된다. | 추가로 @ValueSouce를 주면 3번째 인자로 넘어간다. &quot;이 름&quot;를 주게 되면 blank까지 테스트가 된다. | . | . @ParameterizedTest @NullAndEmptySource @ValueSource(strings = {&quot;이 름&quot;}) void nullAndEmpty_or_blank(String name) { System.out.println(name); assertThatThrownBy(() -&gt; new Car(name)) .isInstanceOf(IllegalArgumentException.class); } . | . 그외 Assertj 메소드 모음 . isEqualTo(obj) obj 와 같다 . isNotEqualTo(obj) | obj 와 다르다 | . isEqualToIgnoringCase(str) | str 와 같다 (대소문자 무시) | . contains(str) | str 를 포함한다 | . containsIgnoringCase(str) | str 를 포함한다 (대소문자 무시) | . doesNotContain(str) | str 를 포함하지 않는다 | . startsWith(str) | str 로 시작한다 | . doesNotStartWith(str) | str 로 시작하지 않는다 | . endsWith(str) | str 로 끝난다 | . doesNotEndWith(str) | str 로 끝나지 않는다 | . matches(regex) | regex 정규식과 같다 | . doesNotMatch(regex) | regex 정규식과 같지 않다 | . isLowerCase(str) | str 은 소문자로 이루어져 있다 | . isUpperCase(str) | str 은 대문자로 이루어져 있다 | . isZero(n) | n 은 0 이다 | . isNotZero(n) | n 은 0 이 아니다 | . isOne(n) | n 은 1 이다 | . isPositive(n) | n 은 양수 이다 | . isNegative(n) | n 은 음수 이다 | . isNotPositive(n) | n 은 양수 또는 0 이다 | . isBetween(start, end) | start 와 end 사이의 값 이다 | . isStrictlyBetween(start, end) | start 와 end 사이의 값이 아니다 | . isCloseTo(n, within 또는 offset) | 주어진 within 또는 offset 에 가까운 값이다. | . isNotCloseTo(n, byLessThan 또는 offset) | 주어진 within 또는 offset 에 가까운 값이 아니다 | . isCloseTo(n, withinPercentage) | 주어진 백분율 내에서 주어진 숫자에 가깝다 | . isNotCloseTo(n, withinPercentage) | 주어진 백분율 내에서 주어진 숫자에 가깝지 않다 | . isTrue() | 참이다 | . isFalse() | 거짓이다 | . isNull() | null 값 이다 | . isNotNull() | null 값 아니다 | . isBlank() | 빈 값 이다 (공백 미포함) | . isNotBlank() | 빈 값 아니다 (공백 미포함) | . isEmpty() | 빈 값 이다 (공백 포함) | . isNotEmpty() | 빈 값 아니다 (공백 미포함) | . isNullOrEmpty() | null 값 이거나 빈 값 이다 (공백 포함) | . isLessThan(str) | str 보다 낮은 문자열 이다 (Ascii 코드) | . isIn(…obj) | 여러개의 obj 중 1개와 같다 | . isNotIn(…obj) | 여러개의 obj 와 모두 다르다 | . filteredOn(…) | list 필터 | . extracting(…) | list 프로퍼티 값 | . assertj string 예제 . assertThat(&quot;Hello, world! Nice to meet you.&quot;) // 주어진 &quot;Hello, world! Nice to meet you.&quot;라는 문자열은 .isNotEmpty() // 비어있지 않고 .contains(&quot;Nice&quot;) // &quot;Nice&quot;를 포함하고 .contains(&quot;world&quot;) // &quot;world&quot;도 포함하고 .doesNotContain(&quot;ZZZ&quot;) // &quot;ZZZ&quot;는 포함하지 않으며 .startsWith(&quot;Hell&quot;) // &quot;Hell&quot;로 시작하고 .endsWith(&quot;u.&quot;) // &quot;u.&quot;로 끝나며 .isEqualTo(&quot;Hello, world! Nice to meet you.&quot;); // &quot;Hello, world! Nice to meet you.&quot;과 일치합니다. . assertj number 예제 . assertThat(3.14d) // 주어진 3.14라는 숫자는 .isPositive() // 양수이고 .isGreaterThan(3) // 3보다 크며 .isLessThan(4) // 4보다 작습니다 .isEqualTo(3, offset(1d)) // 오프셋 1 기준으로 3과 같고 .isEqualTo(3.1, offset(0.1d)) // 오프셋 0.1 기준으로 3.1과 같으며 .isEqualTo(3.14); // 오프셋 없이는 3.14와 같습니다 .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%ED%85%8C%EC%8A%A4%ED%8A%B8/assertj/tdd/2022/02/10/assertj-%EB%B0%8F-annotation-%EB%AA%A8%EC%9D%8C.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%ED%85%8C%EC%8A%A4%ED%8A%B8/assertj/tdd/2022/02/10/assertj-%EB%B0%8F-annotation-%EB%AA%A8%EC%9D%8C.html",
            "date": " • Feb 10, 2022"
        }
        
    
  
    
        ,"post71": {
            "title": "코드리뷰 방법 1단계 및 피드백",
            "content": "개별 셋팅 . 관리자 짝 매칭 실시 . 관리자 매칭 실시 . | 피매칭자은 확인함. . | . 원본레포에 각 github_id br 생성 . lecture클릭후 미션시작 클릭시 -&gt; 자동으로 내 github_id로 —&gt; 미션repo에 브랜치생성 | 미션시작으로 내 브랜치를 생성하면, 리뷰어도 자동 배정된다. ) 동시성 잇슈가 있을 땐, 관리자가 리뷰어를 재배정한다. | . | 저장소로 와서 내 github_id로 생성된 branch가 정상 생성되었는지 미션repo에 branch 검색해서 확인한다 . . | 원본레포 각 fork . 강의홈페이지를 통해 branch가 생성되었으나 팀원X push권한 X -&gt; fork를 먼저 한다. 문서를 보면서 스텝바이스텝으로 한다. | 여기선 1단계까지만 한다. 코드리뷰 요청 1단계: 미션 진행 후 github에 올리는 단계 | 코드리뷰 요청 2단계: 코드리뷰 요청을 보내고, 피드백을 받은 후 피드백 반영 및 merge하는 단계 | 코드리뷰 요청 3단계: 다음 단계 미션을 위해 준비하는 단계 | . | 이렇게 권한은 없지만 [강의홈페이지를 통한 원본repo에 이름만 내 github_id branch]가 생성된 상태로 -&gt; fork한다. fork가 내 계정으로 잘되어있어야한다 | . | fork를 해도 기존 원본repo의 모든 branch들이 다 fork되어있다. 기본 main으로 되어있다. | . | github_id single-branch만 clone . fork는 모든 branch그대로 보유 —&gt; clone을 통해서 로컬로 가져올 때는 --single-branch만 가져오는 것이 가능하다. . 현업에서는 10개이내 branch이므로 git clone -b [branch명] --single-branch [fork한 레포명]가 필요가 없다 . | 내 이름의 branch가 main브랜치다. | . git clone -b {본인_아이디} --single-branch https://github.com/{본인_아이디}/{저장소 아이디} ex) git clone -b javajigi --single-branch https://github.com/javajigi/java-baseball.git . git clone -b is2js --single-branch https://github.com/is2js/java-racingcar.git intellij 터미널에서 작업하면 된다. | . | . PS C: Users cho_desktop IdeaProjects missions&gt; git clone -b is2js --single-branch https://github.com/is2js/java- racingcar.git . | ​ - . intellij에서 clone한 폴더를 open한다 내 이름의 싱글브랜치만 가져와지는지 확인한다. | . | step1 br(작업 br) 생성 . git checkout -b step1으로 첫번째 리뷰용 브랜치를 만든다. . –single-branch clone 한 입장에서 , 내 id_branch -&gt; main브랜치 | 작업할 branch -&gt; step1 -&gt; ... . | cf) **git alias는 집착해서 알아야한다.-&gt; ** . gco main = git command . | gba = git branch -a . # windows git alias git config --global alias.co checkout git config --global alias.ci commit git config --global alias.st status git config --global alias.br branch git config --global alias.hist &quot;log --pretty=format:&#39;%h %ad | %s%d [%an]&#39; --graph --date=short&quot; git config --global alias.type &#39;cat-file -t&#39; git config --global alias.dump &#39;cat-file -p&#39; # shell git alias alias gs=&#39;git status &#39; alias ga=&#39;git add &#39; alias gb=&#39;git branch &#39; alias gc=&#39;git commit&#39; alias gd=&#39;git diff&#39; alias gco=&#39;git checkout &#39; alias gk=&#39;gitk --all&amp;&#39; alias gx=&#39;gitx --all&#39; alias got=&#39;git &#39; alias get=&#39;git &#39; . | . | . . | 협업 시작 (A와 B) . 일단 github_id가 local에의 user.name과 동일한지 확인한다. . git config user.name . | . . 작업레포(local, A) 정하기 . 페어와 CodeWithMe등으로 작업할 local 레포 정하기 . 나의 경우, 네트워크 잇슈로 화면공유 + B를 colaborator 등록하여 B가 local에 step1만 --single-branch clone후 서로 push &amp;&amp; pull 해서 작성함. . git clone -b step1 --single-branch [git주소] [폴더명 or .] . | . | 작업을 완료한 뒤 push까지 끝낸다. . | . A fork레포(remote 2) —fetch/merge–&gt; B local레포 . 협업해서 push된 [A 원격레포-step1]를 2번째 remote repo로 등록한다. . 1번째는 fork한 나(B)의 원격레포 . | 2번째는 fork한 A의 원격레포 . git remote add pair&lt;원격레포별칭&gt; &lt;Repo URL for pairs fork&gt; git remote -v . origin: 원격 저장소를 가리키는 일반적인 별칭 | pair: 내가 정한 추가 원격 레포의 별칭 | . | . | A 원격레포(remote pair)의 step1(협업했던br)의 내용만 fetch해온다. . A pair repo -&gt; B local repo 우리는 pull을 해버렸다. pull할때마다 merge로 표기되니 조심. | . | git fetch : 다른 사람의 branch의 내용을 가져와 확인한 뒤 (나중에) merge 하고 싶을때 fetch를 사용 | 아직 merge는 하지 않았기 때문에 인텔리제이에 가져온 코드들이 보이진 않을 것이다. | . git fetch pair step1 . 안되면 git fetch pair/step1 | . | fetch로 내역들을 확인했으면 merge한다. . git merge pair/step1 . fetch는 띄워쓰기 / merge는 fetch된 것을 /로 연결 | . | A fork레포(remote2) -&gt; B fork레포(remote1) . 정보를 줄 pair(remote2)의 협업br(step1)로 HEAD 이동시켜놓기 . git checkout pair&lt;원격레포별칭&gt;/step1&lt;협업br&gt; . | 정보를 받을 origin(remote1)의 협업br(step1)으로 push하기 . A pair repo -&gt; B remote repo remote —&gt; remote로 commit내역을 넘기나보다. | fetch -&gt; merge로 local에 가져왔다면, 원격에서 원격으로 한번더 가져오나보다. | . | . git push --force origin step1 . | 사실… B local -&gt; B fork로 가는게 맞다? . 동기 크루 중 1분의 블로그 git remote add pair url | git fetch pair step1 | git merge pair step1 | git push origin step1 | . | . 코드리뷰 요청 . 페어 끊기 . 우테코 홈피 -&gt; 나의팀 -&gt; 피드백을 누르면 페어가 끊어진다. 페어가 끊어져야 리뷰요청이 활성화된다?! | . | forkRepo -&gt; 원본Repo PR (리뷰요청) . 내 fork 원격레포 의 step1 br로 이동한 뒤, 원본(미션)repo로 PR를 누른다. PR을 통한 코드리뷰는 fork레포- 작업br(step1)에서 PR을 걸어 -&gt; 원본레포의 나와관련된 br(is2js)에 요청하는 것 | fork레포의 관련br(is2js)가 아닌 것에 주의하자. | . | PR 받는 곳 원본레포: base repository - is2js(관련 br) | PR 보내는 곳 fork레포: head repository - step1(작업br) branch를 잘 선택해야한다. | . | . | PR메세지까지 다 작성해서 제출한다. | 홈피-&gt;slack에 리뷰요청 알림 . 우측 상단에 리뷰요청 . | slack으로 메세지 전달 . . | slack-&gt;피드백 알림 -&gt; 로컬수정 -&gt; PUSH로 피드백반영 -&gt; 홈피 리뷰요청2 . 슬랙으로 피드백 반영해달라고 알림이 온다 날렸던 PR에 그대로 코드리뷰가 반영되어있다. | . | local에서 step1 br로 수정한다. | local step1 -&gt; remote step1 PUSH 하는 순간 피드백 반영되므로 조심하자. 추가 PR은 필요 없다. | . | push로 피드백 반영이 끝났으면 우테코 학습 홈피 -&gt; 우측상단 리뷰요청 -&gt; 리뷰요청 -&gt; slack메세지 | 리뷰어가 피드백을 보고 merge해줄 것이다. 그럼 다음 단계로 진행하면 된다. |",
            "url": "blog.chojaeseong.com/git/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%ED%98%91%EC%97%85/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/09/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-1%EB%8B%A8%EA%B3%84-%EB%B0%8F-%ED%94%BC%EB%93%9C%EB%B0%B1(%EC%99%84).html",
            "relUrl": "/git/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%ED%98%91%EC%97%85/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/09/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-1%EB%8B%A8%EA%B3%84-%EB%B0%8F-%ED%94%BC%EB%93%9C%EB%B0%B1(%EC%99%84).html",
            "date": " • Feb 9, 2022"
        }
        
    
  
    
        ,"post72": {
            "title": "fastpages font & tag page change",
            "content": "font 바꾸기 . 참고: 한국 블로그 | . _includes폴더 &gt; head.html파일에서 웹 폰트 link태그 추가해주기 . &lt;!-- 폰트추가를 위한 link태그 삽입 --&gt; &lt;!-- 폰트1: 기본 spoqa 웹폰트 --&gt; &lt;!-- css에서 * {} 다 뒤집어씀. --&gt; &lt;link href=&#39;//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSansNeo.css&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&gt; &lt;!-- 폰트2: 블로그 제목들 sunflower 웹폰트 --&gt; &lt;!-- 쥬피터 등 포스트 내부 글자 h1, h2 제목은 sunflower체 도입 --&gt; &lt;link href=&quot;//fonts.googleapis.com/css?family=Sunflower:300,500,700&quot; rel=&quot;stylesheet&quot;&gt; . | 해당 폰트를 사용하기 위해 assets폴더 &gt; css폴더 &gt; styles.css를 수정한다 나의 경우, scss수정시 잘 안됬다. 모든 것을 여기서 설정해줬다. | font-family 검색해서 모두 font-family: &#39;Spoqa Han Sans Neo&#39;, normal;로 바꿔주기 | 전역으로 다 먹이기 + 제목들은 다른 글자체로 먹이기 /* 제목들은 먹히는데, 제목만쓰질 않으니.. */ /* test-&gt; 전체를 font-familty 덮어쓰기 */ *{ font-family:&#39;Spoqa Han Sans Neo&#39;, normal!important; } /* font2 제목 글자는 선플라워 */ h1, h2, h3, h4, h5, h6, tag-name { font-family:&quot;Sunflower&quot;, normal!important; color: #152447; } . | . | a태그 리셋시켜서 색 적용되게 하기 /** Links */ /** 폰트 색 (링크 색) -&gt; 이것만 바꾼다고 변경안됨.. */ /* 모든 a태그 프로퍼티들을 리셋 */ a { all: unset; } /* a태그의 가상클래스도 같이 리셋 */ a:link { text-decoration: none; color: #152447; } a:visited { text-decoration: none; color: #152447; } /* 누른상태 */ a:active { text-decoration: none; color: #152447; } /* 갖다덴 상태 */ a:hover { text-decoration: none; color: #152447; } a { color: #152447; text-decoration: none; } a:visited { color: #152447; } a:hover { color: #313266; text-decoration: underline; } . | 마크다운 강조색을 빨간색 글자로 변경 pre, code { font-family: &#39;Spoqa Han Sans Neo&#39;, &quot;Menlo&quot;, &quot;Inconsolata&quot;, &quot;Consolas&quot;, &quot;Roboto Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; font-size: 0.9375em; border: 1px solid #f9f2f4; border-radius: 3px; background-color: #f9f2f4; color:#E53A40;} . | tags.html 수정하기 . 예전 블로그의 css를 가져와 적용할 준비를 한다. style.css /** 예전 블로그에서 쓰던 tag모음 + 각 개별tag적용 css */ .entry-meta { font-size: 12px; font-size: 0.75rem; text-transform: uppercase; color: #152447; } .entry-meta a { color: #152447; } .entry-meta .vcard:before { content: &quot; by &quot;; } .entry-meta .tag { display: inline-block; margin: 4px; color: #fff; border-radius: 3px; background-color: rgba(162, 162, 162, 0.8); } /*my) 상단 태그들 모음 tag1 shap(#) */ .entry-meta .tag span { float: left; padding: 6px 6px; color: #152447; font-family: inherit; /* background-color: #ffffff; */ } /*my) 상단 태그들의 tag2 name(태그명) 색*/ .entry-meta .tag .tag-name { color: #ffffff; background-color: #152447; border-radius: 0 3px 3px 0; /*3px 이상 오그리면, 하이퍼링크랑 막 난리남.*/ } .entry-meta .tag:hover { background-color: rgba(136, 136, 136, 0.8); } .entry-meta .entry-reading-time { float: right; } .inline-list { list-style: none; margin-left: 0; padding-left: 0; } .inline-list li { list-style-type: none; display: inline; } /* 추가) 각 제목들도 tag 작은모양처럼*/ .eachtag { color: #ffffff; background-color: #152447; border-radius: 0 3px 3px 0; } . | tags.html코드를 수정한다. ul태그에 entry-meta inline-list 속성을 추가한다 | 그외 tag, tag-name, eachtag 등의 속성을 이용해서 꾸민다. | . &lt;ul class=&quot;entry-meta inline-list&quot;&gt; &lt;/ul&gt; . |",
            "url": "blog.chojaeseong.com/fastpages/2022/02/09/fastpages-font-&-tags-page-change.html",
            "relUrl": "/fastpages/2022/02/09/fastpages-font-&-tags-page-change.html",
            "date": " • Feb 9, 2022"
        }
        
    
  
    
        ,"post73": {
            "title": "fastpages post preview setting",
            "content": "fast pages 메인에서 preview image 보이게 하기 . 참고: 이미지를 표기하는 fastpages | . _config.yml에서 show_image: false -&gt; true로 변경 . | 미리캔버스를 검색해서 템플릿으로 생성할 이미지 만들기 참고 블로그 | 생성 목록 algo.png | blog.png | config.png | data.png | default.png | git.png | java.png | python.png | sql.png | wootech.png | . | . | 최상단 images폴더 &gt; posts폴더에 이미지들 넣어두기 . | post마다 image: &quot;images/posts/blog.png&quot;형식으로 preview 이미지 설정하기 메인 위쪽은 index.html | 메인 아래쪽 포스트 담당은 home.html이다 | . _config.yml에서 show.image: true일 경우 post_list.html(글만) -&gt; post_list_image_card.html로 바뀌어서 보인다. | . | . |",
            "url": "blog.chojaeseong.com/fastpages/2022/02/08/fastpages-post-preview-setting.html",
            "relUrl": "/fastpages/2022/02/08/fastpages-post-preview-setting.html",
            "date": " • Feb 8, 2022"
        }
        
    
  
    
        ,"post74": {
            "title": "TDD 기본 싸이클 작성",
            "content": "TDD 싸이클 . TDD 구현 싸이클 fail떨어지는 test코드 생성 case별로 메서드_이름을 표기하여 작성한다. | . | main(프로덕션)코드 작성 후 pass 2번째부터는 개별 pass -&gt; 전체pass 순으로 확인 | . | refactoring(rename부터 시작) | | . | . test에서 package &gt; XXXTest class를 먼저 만든다. . . generate(alt+insert)기능으로 @test로 생성 . | 메서드_명은 한글명으로 해도 되고, 단위테스트가 의미하는 바만 잘 나타내면된다. 여기선 여러 경우 중 1가지(구분자 없는) 경우로 시작을 한다. . | . . | 클래스명 + 메소드명을 먼저 사용하여 할당을 반환형 actual변수로 받은 뒤 given(값 -&gt; 변수 선언 등) -&gt; when(actual까지 로직) -&gt; then( asesertThat(actual).isEqualTo(expected)) . // given String data = &quot;(1,2)&quot;; // when String result = data.substring(1, data.length()-1); // then assertThat(result).isEqualTo(&quot;1,2&quot;); . | . | assertThat( actual ).isEqualTo( )에서 인자에 예상값(우리가 원하는 값)을 넣는다. . | SC 없는 클래스를 만들 되, 미리 main쪽에 package를 만들어 놓은 상태에서 -&gt; 생성경로를 main으로 바꿔준다. . test &gt; package &gt; XXXTest class | 내부 XXX클래스.메서드() —&gt; main &gt; package &gt; XXX class로 생성 | test에만 존재하는 package를 선택하면, main에 못만드니 미리 만들어놔야한다. | . | **클래스 생성 직후 바로 돌아와(Back기능 ctrl+u) method도 만들어준다 ** . 이 때, actual(1)을 반환하지 않는 불완전한 메소드를 수정없이 test실행부터해서 Error를 낸다 . . | . | test코드(SCTest)가 pass하도록 프로덕션코드(main코드, SC)를 수정한다. . . | pass한 프로덕션 메소드를 refactoring한다. . 파라미터 이름 바꾸는 것도 F2 = refactoring | @test 막 사용했던 class이름(XXX) 바꾸는 것도 F2 = refactoring 이 때, test class이름 XXXTest도 바꾸자고 권유한다. | . | . | 더이상 refactoring할게 없다면 -&gt; 새로운 단위테스트를 클래스.메소드()부터 만들어서 나아간다. . 직전에 만든 테코랑 비슷하다면, 복붙해서 시작한다. . | 테케는 가능한 가장 작은 단위를 만드는 경우며, 케이스 -&gt; if 상황별 새로운 메소드로 나누고 -&gt; 상황에 맞게 인자 변경 -&gt; expected . 구분자 없음 -&gt; “1” -&gt; 1 | 컴마 구분자 -&gt; “1,2” -&gt; 3 | . . | . | 다음 테케도 프로덕션 코드 수정없이 일단 돌려서 fail을 떨어뜨린 뒤-&gt; 에러보고 참고하여 찾아가서 수정 . | 해당 테케실행 -&gt; 전체 테케도 실행해서 전체 통과하는지 확인을 한다. . | pass후엔 refactoring하기 . for문으로 들어가는 indent -&gt; 메소드 추출 refactoring . return문까지 잡아서 추출해보기(alt+ctrl+m -&gt; 안되면 ctrl+.) . . | . | . | input/output이 명확한 쉬운 TDD였다. . 자동차 경주를 하려면, 너무 힘들 것 | 단위테스트만 만들어서 해볼 것 | fail하는 test생성 -&gt; 프로덕션수정으로 pass -&gt; refactoring | . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/08/TDD%EC%8B%B8%EC%9D%B4%ED%81%B4(%EB%8D%A7%EC%85%88%EA%B3%84%EC%82%B0%EA%B8%B0)(%EC%99%842).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/08/TDD%EC%8B%B8%EC%9D%B4%ED%81%B4(%EB%8D%A7%EC%85%88%EA%B3%84%EC%82%B0%EA%B8%B0)(%EC%99%842).html",
            "date": " • Feb 8, 2022"
        }
        
    
  
    
        ,"post75": {
            "title": "resources 속 파일 읽기",
            "content": "외부파일 읽기 . 01 src&gt;main&gt;resources 안에 파일을 넣는다. . . 02 카테고리(분기)가 있는 경우, enum에 외부문자열로서 파일경로 매핑 . 파일경로는 “src/main/resources/ ~ “로서 src부터 시작한다 . . public enum Course { BACKEND(&quot;백엔드&quot;, &quot;src/main/resources/backend-crew.md&quot;), FRONTEND(&quot;프론트엔드&quot;, &quot;src/main/resources/frontend-crew.md&quot;); private String name; private final String resourcePath; Course(String name, final String resourcePath) { this.name = name; this.resourcePath = resourcePath; } . 03 new File(경로) -&gt; new Scanner( file ) -&gt; if .hasNextLine() -&gt; .nextLine() . 한줄 씩 읽어서 -&gt; 가변 List&lt;String&gt;에 한줄씩 add하는 것이 특징 . utils &gt; FileReaderUtil . public class FileReaderUtil { public static List&lt;String&gt; read(final String pathname) { final File file = new File(pathname); final List&lt;String&gt; crews = new ArrayList&lt;&gt;(); try { final Scanner scanner = new Scanner(file); while (scanner.hasNextLine()) { crews.add(scanner.nextLine()); } } catch (FileNotFoundException e) { System.out.println(&quot;[ERROR] &quot; + e.getMessage()); } return crews; } } . public Crews generateShuffledCrews(final Course course) { final List&lt;String&gt; crewNames = FileReaderUtil.read(course.getResourcePath()); final List&lt;String&gt; shuffledCrew = Randoms.shuffle(crewNames); return Crews.from(course, shuffledCrew); } . | .",
            "url": "blog.chojaeseong.com/java/resources/pair-matching/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/07/resources-%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%9D%BD%EA%B8%B0.html",
            "relUrl": "/java/resources/pair-matching/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/07/resources-%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%9D%BD%EA%B8%B0.html",
            "date": " • Feb 7, 2022"
        }
        
    
  
    
        ,"post76": {
            "title": "우테코 프리코스 3주간 요구사항들",
            "content": "요구사항 체크리스트 모음 . 1주차 . 자바의 버전이 8버전인가 | 자바 코드 컨벤션을 지키는가 | Randoms의 pickNumberInRange()를 사용했는가 (3주차) pickNumberInList()를 사용했는가 | . | Console의 readLine()을 사용했는가 | 3항 연산자를 쓰지 않는가 | indent depth가 2이하인가 | 하나의 함수가 한 가지 일만 하도록 하였는가 | (추가) 하드코딩 하진 않았는가 | (추가) style check 및 convention 적용 하였는가 | gradlew.bat clean test의 모든 테스트가 통과하는가 | 과제 제출시 우테코 플랫폼에서도 제출하였는가 | . 2주차(피드백 및 과제에서 추가) . 함수(또는 메소드)의 길이가 15라인을 넘어가지 않도록 구현한다. | else 예약어를 쓰지 않는다 . | 기능 목록을 업데이트하고 재검토 한다 | Class 구현순서( 상수-&gt;멤버 변수-&gt;생성자-&gt;메서드) 지키기 | . 3주차 . 기능 목록에 예외상황도 기록한다. | 일급컬랙션 및 단일변수도 포장한다. | 변수를 줄이려고 노력한다. | . 주차별 미션 수행 키포인트 정리 . 1주차 과제 수행시 키포인트 . 개발 시작전에 요구사항 충분히 파악하기 | 기본 프로젝트 구조 및 뼈대 코드 작성하고 시작하기 | 라이브러리 확인 및 컨벤션 포맷터 적용, 버전 확인 등 기본적인 협업환경 확인하기 | Application에 개발하지 않고 각 class에서 개발하여 구동하기 | scanner 등 input, outview은 static으로 작성해서 재활용하기 | 문자열type의 숫자입력시 검증 여러가지 해보기(길이-&gt; 포맷-&gt; 범위-&gt; 중복여부 등 기타) | else 안쓰고, 반복문안에 if는 method로 빼서 method내에서 하여 indent줄이기 | 무한반복시 조건변수를 결과로 업데이트 하면 됬으나, 재시작 등 추가분기가 필요한 경우, status변수 추가 도입하기 | 상수도 반복되니 따로 class로 빼기 | 중복확인은 list길이로 하는 데, stream으로 편하게 하기 list 중복확인 : list.stream().distinct().count() | 입력받은 문자열배열 -&gt; 정수 list변환 : Arrays.stream(). mapToint(Integer::parseInt).boxed().collect(Collectors.toList()); | . | . 2주차 과제 수행시 키포인트 . Live template을 활용함. 1주차와 반복되는 input코드 등을 미리 작성해둠. | . | fork한 repo를 clone후에 branch부터 바꾸자! 실수로 main브랜치에 commit and push하여 새로 작성하는 경우가 발생했었음. | . | 일급컬렉션 사용하여 객체List에 대한 검증 및 관련 로직을 모음. 쪼개어지는 Input을 받을 때 ex&gt; Names -&gt; Name 미리 names에서 검증을 다 해버리는 전략을 세움 | 쪼개어놓고 내부에서 검증할 시, 다시 입력받으러 가기가 쉽지가 않음. | . | 조건절에서 getter쓰지말고, 객체.부등호를메서드화() 시켜 메세지보낼 것. 비교시 필요한 값은 메서드의 파라미터로 | 입력 받은 int 변수를 포장한 래핑클래스를 만들고 countdown 메서드 구현해보기 | 학습했던 stream위주로 코드 짜보기 max( Comparator)를 쓰더라도 1번에 max값을 충족시키는 여러개의 객체를 구하기는 쉽지 않음. | mapToInt( ) 집계값 구한 뒤 -&gt; 일치하는 객체 List(우승자들) 구하는 방식 | 간단한 출력문은 toString()오버라이딩 해서 쉽게 출력되도록 이용 하기 | | 상수들 및 에러 메세지들의 리팩토링 IDE를 이용하면 정말 간단하게 해결할 수 있음을 깨닫게 됨. | . | . 3주차 과제 수행시 키포인트 . 객체의 각 필드에도 wrapping class를 적용함 원시변수 및 if문의 최소화 -&gt; 래핑변수 및 stream의 활용 | . | 정규식 패턴검사에 stream을 활용함 | List대신 Map 자료구조 래핑하여 DB처럼 사용함 상품 정보등은 List를 포장한 일급컬렉션으로 만들어놓고 정보조회시 사용함 | . | 싱글톤 객체를 활용하여 전체 로직을 운영함 controller 반복문의 조건변수도 싱글톤객체에 메세지를 보내니 상태에 따른 값을 얻어와서 구현하기 수월했음 | . | 자판기 작동 로직에 대해 고민하여 기능 구현 목록을 작성함 | .",
            "url": "blog.chojaeseong.com/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/2021/12/15/%EC%9A%B0%ED%85%8C%EC%BD%94%EA%B0%80_%EB%82%98%ED%95%9C%ED%85%8C_%EC%A4%80_%EC%84%A0%EB%AC%BC.html",
            "relUrl": "/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/2021/12/15/%EC%9A%B0%ED%85%8C%EC%BD%94%EA%B0%80_%EB%82%98%ED%95%9C%ED%85%8C_%EC%A4%80_%EC%84%A0%EB%AC%BC.html",
            "date": " • Dec 15, 2021"
        }
        
    
  
    
        ,"post77": {
            "title": "intelliJ 세팅(vscode keymap + 협업 세팅)",
            "content": "vscode keymap 관련 플러그인 설치 . 설정 &gt; Plugin &gt; vscode kemap검색 후 설치 | key Promoter X 설치 (해당 기능의 단축키를 우측하단에 띄워줌) | | . vscode keymap 기준 단축키 정리 . shift 2번 : 전체 검색(유지) vscode F1 | . | keymap 들어가서 move to opposite group검색후 ctrl+shift+ 오른화살표지정하기 ctrl + 이후 넘기기..왼쪽넘기기 기능 자체는 없나보다. | alt+shift+0으로 세로로 넘기기 가능 | . | alt+shift+F : reformat code -&gt; 한파일내 패키지 or 폴더 선택후 alft+shift+F | . | keymap 들어가서 back검색후 ctrl+u지정하기 . | ctrl + .으로 메인메소드 내용을 extract method 메소드 분리 및 패키지명 작성하고 폴더이동시키기 | . | 신세계) alt+insert로 생성자, getter 등 오버라이딩 . | **신세계) 메서드사용을 위한 객체 만들 때(인스턴스화) 할 때, ** new 클래스명(); 기입후 ctrl+.으로 local변수 자동(선택후)생성하자. | 객체.메서드();기입후 ctrl+.으로 메서드결과값 받는 변수 자동(선택후)생성 | . | keymap -&gt; extend line selection -&gt; ctrl+L을 추가해서 사용하기 라인 선택하기 shift+alt+아래화살표로 복사할때,, 라인 선택해서해야.. 꼬임없을 듯 | . | . | shift+ alt+ F10: 실행할 class파일 선택해서 실행 ctrl+alt+F10은 바로 실행. | . | shift + alt + x: 현재 파일들 다 close . | shift + alt + a : 긴글 주석? . | alt + ~ : git관련 명령어들 목록나옴 . | ctrl+F11 or ctrl+shift+{key}로 북마크 지정 -&gt; ctrl+해당번호로 이동 | keymap -&gt; show bookmaks검색후 -&gt; CTRL+SHIFT + F11 으로 지정함 | . | ctrl+f3 : 같은단어 이동가능한 검색한 상태로 만들기 == ctrl+f f3 : 같은 단어 다음으로 이동 | shift+f3 : 같은단어 이전 단어로 이동 | . | shift+F5 : 실행중인 작업 종료 ctrl+F5 : 실행 | shift+ alt + f10 : main함수 골라서 실행 | . | alt+7: 현재파일 Structure(메소드 등) 한눈에 보기 유틸메서드로 빼기, 상수 옮기기 : f6으로 편하게 | . | 리팩토링 alt+ctrl+c : 값을 상수로 등록해버리기 | alt+ctrl+m : 코드를 메서드화 시키기 2번 눌르면 창으로 하는 듯 | . | alt+ctrl+v: new 클래스()까지 입력후 참조변수 바로 생성 | . | 축약어 iter | fori 추가 | itar | ifn | inn | . | F8: 오류바로 찾아가기 | ctrl+f -&gt; F3 or shift + F3 : 검색항목 순서대로 찾아가기 | . 프리코스를 위한 java8 협업 세팅 요약본 . clone후 branch부터 생성후 바꾸기 . git checkout -b is2js . git CRLF -&gt; LF로 바꾸기 설정하기 . git config --global core.autocrlf true . utf 8 설정 . utf8, lf설정 되어있나 확인하기 . editor &gt; File Encodings &gt; 체크 3가지 모두 utf-8 shift 2번연속 클릭 (search everywhere) . vm검색 Edit Custom VM option 클릭 맨 마지막 줄에 -Dfile.encoding=UTF-8 추가 | . | . | . | . | . | build.gradle 설정 추가 . compileJava.options.encoding = &#39;UTF-8&#39; // UTF-8 설정 compileTestJava.options.encoding = &#39;UTF-8&#39; . | . code style 3가지 / Checkstyle / saveActions . code style에서 . scheme지정 | n으로 선택해주기 | detect하도록도 체크함.. | java탭으로 내려가서 &gt; scheme 지정확인 checkstyle에 안걸리게 됨. | . | | Tools &gt; CheckStyle . 8.24이상 버전 (default) . | scope를 All sources(테스트포함, 나는 테스ㅡㅌ제외)로 변경 . | 파일 선택(일부코드 삭제하여 수정한)하여 추가 -&gt; +로 추가 . . | 해당 스타일체크후 alt +shift + k혹은 하단 체크스타일에서 추가한 naver style선택하여두기 . | | 다 풀고 **맽밑 Other settings &gt; Save Actions &gt; 3가지 체크 ** . . | . java8로 통일하기 . 설정&gt; Build&gt; Build Tools &gt; Gradle &gt; intelliJ IDEA + Gradle JVM 1.8로 바꾸기 exception 및 디버깅용으로 gradle 변경하는 것 | . | 설정&gt; Build&gt; Build Tools &gt; Compiler &gt; Java Compiler &gt; javac의 1.8 바꾸기 | 프로젝트구조(c +s + a + s) &gt;Project &gt; Project SDK 및 language level 1.8, 8 선택 | 프로젝트구조(c +s + a + s) &gt; Modules &gt; 랭귀지레벨에서 8버전 맞나 확인하기 | 프로젝트구조(c +s + a + s) &gt; SDKs에서 1.8버전 확인하기 | window intellij에서 gradle clean, test 해보기 . . shift 2번 or f1 -&gt; gradle task선택 gradle clean 수행 | gradle test 수행 코드 다짜고나서 | | |",
            "url": "blog.chojaeseong.com/java/configuration/2021/12/14/java_intellij_keymap.html",
            "relUrl": "/java/configuration/2021/12/14/java_intellij_keymap.html",
            "date": " • Dec 14, 2021"
        }
        
    
  
    
        ,"post78": {
            "title": "코딩테스트용 라이브러리 정리",
            "content": "참고 벨로그 | justkode | . | . 표준라이브러리 6가지 . 내장함수 . sum, min, max, eval, sorted(key=, reverse=) . result = eval(&quot;(3 + 5) * 7&quot;) print(result) . | . itertools . 반복되는 형태의 데이터를 처리하는 기능을 제공, 순열과 조합 라이브러리르 제공 . permutations(r개의 데이터를 뽑아 나열하는 모든 경우(순열)) . | combinations(r개의 데이터를 뽑아 순서를 고려하지 않고 나열하는 모든 경우(조합)) . | products(r개의 데이터를 뽑아 일렬로 나열하는 모든 경우(순열)를 계산한다. 다만 원소를 중복하여 뽑는다.) . from itertools import product data = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] # 데이터 준비 result = list(product(data, repeat=2)) # 2개를 뽑는 모든 순열 구하기(중복 허용) print(result) # [(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;C&#39;)] . | . heapq . 힙을 활용한 우선순위 큐 기능을 구현할 때 사용되며, O(NlogN)에 오름차순 정렬을 제공한다. PriorityQueue 라이브러리가 따로 있지만, heapq가 더 빠르게 동작한다. . PriorityQueue를 리스트나 힙으로 구현할 수 있지만 리스트는 삽입 O(1) 삭제 O(N) 의 복잡도를 가지지만, | 힙은 삽입 O(logN) 삭제 O(logN) 의 복잡도를 가진다. 그래서 우선순위 큐는 보통 힙으로 구현하고, 시간복잡도도 힙으로 구현한 시간복잡도를 사용한다. | . | . | heapq.heappush() : 원소 삽입 | heapq.heappop() : 원소 꺼내기 | heapq.heapify() | . import heapq def heapsort(iterable): h = [] result = [] # 모든 원소를 차례대로 힙에 삽입 for value in iterable: heapq.heappush(h, value) # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기 for i in range(len(h)): result.append(heapq.heappop(h)) return result result = heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) print(result) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . 히피파이를 이용한 힙정렬 기존에 있는 list 객체로 힙 정렬 만들기 | . | . import heapq h = [3, 9, 1, 4, 2] heapq.heapify(h) # 파라미터로 list 객체를 받는다. for _ in range(6): print(-heapq.heappop(h)) # 작은 값부터 출력된다. . bisect . 이진 탐색을 쉽게 구현할 수 있도록 bisect 라이브러리를 제공함. ‘정렬된 배열’에서 특정한 원소를 찾아야 할 때 매우 효과적이다. O(logN)에 정렬된 배열에 맞는 위치를 찾아준다. | ‘정렬된 리스트’에서 특정 범위에 속하는 원소의 개수를 구하는데 효과적이다. bisect_left(a, x) : 정렬된 순서를 유지하면서 리스트 a에서 데이터 x를 삽입할 가장 왼쪽 인덱스를 찾는 메서드 | bisect_right(a, x) : 정렬된 순서를 유지하면서 리스트 a에서 데이터 x를 삽입할 가장 오른쪽 인덱스를 찾는 메서드 | . | bisect 모듈은 이미 정렬되어 있는 list의 정렬 상태를 유지하기 위해 사용되는 모듈입니다. 이를 이용해서, 기존에 있는 list의 정렬 상태를 유지 할 수 있고, 이를 응용해서 Binary Search 또한 구현할 수 있습니다. | . from bisect import bisect_left, bisect_right a = [1, 2, 4, 4, 8] x = 4 print(bisect_left(a, x)) # 2 print(bisect_right(a, x)) # 4 . 정렬된 리스트’에서 특정 범위(시작과 끝)에 속하는 원소의 개수를 구하는데 효과적이다. . left는 같아도 젤 왼쪽 index(포함), right는 같아도 젤 오른쪽index(미포함, 들어가야하는 자리)를 반환하므로 시작과 끝 index를 알 수 있다. | . from bisect import bisect_left, bisect_right # 값이 [left_value, right_value]인 데이터의 개수를 반환하는 함수 def count_by_range(a, left_value, right_value): right_index = bisect_right(a, right_value) left_index = bissect_left(a, left_value) return right_index - left_index # 리스트 선언 a = [1, 2, 3, 3, 3, 3, 4, 4, 8, 9] # 값이 4인 데이터 개수 출력 print(count_by_range(a, 4, 4)) # 2 # 값이 [-1, 3] 범위에 있는 데이터 개수 출력 print(count_by_range(a, -1, 3)) # 6 . lgN으로 정렬까지 해주는 bisect.insort( )도 있다. . | bisect 모듈은 이미 정렬되어 있는 list의 정렬 상태를 유지하기 위해 사용되는 모듈입니다. 이를 이용해서, 기존에 있는 list의 정렬 상태를 유지 할 수 있고, 이를 응용해서 Binary Search 또한 구현할 수 있습니다. . | . # 1. 삽입 되어야 하는 index 찾기 import bisect arr = [1, 2, 3, 3, 4, 5] print(bisect.bisect_left(arr, 6)) # 6이 들어가야 하는 Index인 6을 반환 print(bisect.bisect_right(arr, 6)) # arr에 6이 없기 때문에 위와 똑같은 값을 반환한다. print(bisect.bisect_left(arr, 3)) # 중복 되는 값 제일 왼쪽, 2를 반환한다. print(bisect.bisect_right(arr, 3)) # 중복 되는 값 제일 오른쪽 + 1, 4를 반환한다. bisect.insort_left(arr, 3) # 중복 되는 값 왼쪽에 삽입 bisect.insort_right(arr, 3) # 중복 되는 값 오른쪽에 삽입 print(arr) . #2. Binary Search 구현 from bisect import bisect_left arr = [1, 2, 3, 3, 4, 5] def bs(arr, x): i = bisect_left(arr, x) # 들어가야 하는 &#39;제일 왼쪽&#39; index 반환 if i != len(arr) and arr[i] == x: # 들어가야 하는 index가 return i # 마지막 index + 1 이라면, arr에 x가 없는 것 else: # arr[i] == x가 아니라면, arr에 x가 없는 것 return -1 a = [1, 2, 4, 4, 8] x = 4 res = bs(a, x) if res == -1: print(x, &quot;는 없습니다!&quot;) else: print(&quot;첫번째&quot;, x, &quot;가 등장한 위치는&quot;, res) . collections . 덱(deque), 카운터(Counter) 등의 유용한 자료구조를 포함하고 있는 라이브러리 . deque . 파이썬에서는 일반적으로 deque를 활용해 큐를 구현한다. | Queue 라이브러리 있지만 일반적인 큐 자료구조를 구현하는 라이브러리는 아니다. | 리스트와 다르게 인덱싱, 슬라이싱 등의 기능은 사용할 수 없다. | 데이터의 시작이나 끝부분에 데이터를 삽입하는데 효과적이다. | . . | Counter 등장 횟수를 세는 기능을 제공한다. iterable 객체가 주어졌을 때, 해당 객체 내부 원소가 몇 번 등장했는지 알려준다. . | . math . 수학적 기능을 제공하는 라이브러리 . 자주 사용되는 수학적인 기능을 포함하고 있는 라이브러리 팩토리얼, 제곱근, 최대공약수(GCD) 등을 계산해주는 기능을 포함 . 종류 math.factorial() : 팩토리얼 | math.sqrt() : 제곱근 | math.gcd() : 최대공약수 | math.pi : 파이 | math.e : 자연상수 | . | . import math print(math.factorial(5)) # 120 print(math.sqrt(7)) # 2.6457513110645907 print(math.gcd(21, 14)) # 7 print(math.pi) # 3.141592653589793 print(math.e) # 2.718281828459045 . . 그외 . map, split, sorted . 주의점 . input말고 . 뭐 어느정도로 더 빠르고 느리냐는, 코딩 테스트 문제푸는 수준에서 다룰만한 내용이 아니므로 넘어가도록 하고, 직관적으로만 느꼈던 것은, input() 으로 코드를 제출할 시, 시간초과가 뜨지만, sys.stdin.readline() 으로 제출할 시 정답이 뜨더라는 것이다. 이와 비슷한 이슈는 이미 이전부터 있었다. | . 한편, 나는 입출력을 지금까지 이런 방식으로 했다. . a = [int(x) for x in input().split()] # a = [1, 2, 3, 4 ,5] . 하지만, 이 방법보다 다음 방법이 더 권장된다. (위와 같은 이유로) . import sys a = list(map(int, sys.stdin.readline().split()))# a = [1, 2, 3, 4, 5] . 재귀풀기 . 이전에 문제풀다가 말한 적이 있는데, 특히 자주접하는 DFS, BFS 문제의 경우 그렇다. . 파이썬의 재귀 허용 깊이의 기본치가 c 보다 약한건지, c 로 짠 DFS, BFS의 경우 문제 없이 돌아가지만, 파이썬으로 돌리면 런타임 오류가 뜨는 경우가 있다. 그래서 다음과 같이 재귀 허용 깊이를 수동으로 늘려주는 코드를, 코드 상단에 적어줘야 한다. . import sys sys.setrecursionlimit(10**8) # 10^8 까지 늘림. . | . Pypy . PyPy 가 뭔지 찾아보니, 쉽게말해 파이썬 보다 몇 배 더 빠른 개선된 파이썬이라고 생각하면 된다. . 좀 더 자세히 말하면, Python3 는 내부적으로는 C로 짜여져있는데 (이 이유 때문에 Python2 보다 빠르다.), 이를 C가 아니라 Python으로 다시 짠 것이다. 당연히 느릴 것 같은데, 의외로 빠르단다. 자세한 내용은 나무위키 참고. . 때문에, 일반적으로 Python3 보다 PyPy로 제출해서 내는게 더 안전한 듯 하다. (빠르다는 의미에서) . 한편, PyPy에서는 sys.setrecursionlimit(10**8) 이 안먹는다. 즉 임의로 재귀 호출 깊이를 설정할 수 없다는 것에 주의해야 한다. . 파이썬으로 문제푸는 게 편한점도 많지만 아직 어색하고, 이런 자잘한 리스크가 많은 듯 하다. 이후 또 뭔가 발견하면 남겨놔야겠다. . | .",
            "url": "blog.chojaeseong.com/algorithm/2021/10/22/python_%EB%AA%A8%EB%93%88%EC%A0%95%EB%A6%AC.html",
            "relUrl": "/algorithm/2021/10/22/python_%EB%AA%A8%EB%93%88%EC%A0%95%EB%A6%AC.html",
            "date": " • Oct 22, 2021"
        }
        
    
  
    
        ,"post79": {
            "title": "협업2)오픈소스PR + 팀원PR + issue로 PR",
            "content": "여러가지 Pull Request 날려보기 . Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . 노팀원 fork PR(팀원-PR받기만/ 타인(나)-Fork후 수정용브랜치로 push하여 타인의 PR) . 앞에서 PR = 팀원1(주인):수정용브랜치 -&gt; 팀원2:collaborator이며 리뷰만 PR(주인-수정용브랜치 / 팀원-리뷰만) 실습 로컬 : git_seminar | 원격 : CS100_Git in is3js . 협동자: is3js | . | . | . | 소샬코딩의 PR . 오픈소스 레포(is3js) : py . 주인 혹은 collaborator임. | . | 기여하고 싶은사람(is2js, 나): py(fork) . 팀원이 아닌 이상 일단 fork한다 | 팀원이 아니더라도 clone후 로컬에서 topic branch를 따서 작업한다. | fork레포(내꺼)에 commit, push한다 | 팀원이 아니지만, fork레포 - topic branch의 변동사항을 push로 PR한다. | . . | . | . 팀원아니더라도 fork-clone-topic따서 작업한 뒤 -&gt; (merge하지않고) commit, push . 나는 오픈소스의 collaborator가 아니므로 오픈소스(py)를 fork한다. . | 작업을 하려면 일단 clone부터해서 local에 가지고 온다. . ❯ git clone https://github.com/is2js/py.git .❯ code . . git 설정을 한번 확인해준다. . ❯ git config --list . remote.origin.url=https://github.com/is2js/py.gitremote.origin.fetch=+refs/heads/*:refs/remotes/origin/*branch.main.remote=originbranch.main.merge=refs/heads/main . | . | fork를 해온 상태는 main브랜치이다. 새로운 topic 브랜치 work를 따서 작업 -&gt; commit -&gt; work를 push까지해보자. . 브랜치 클릭 -&gt; +새 분기 만들기 &gt; work . | main에 merge하는게 아니라 topic branch를 commit -&gt; push해야 팀원아닌데도 PR을 날릴 준비를 할 수 있다. . 명령어로 할 거면 . git push origin [topic branch명] . | . | . | fork한 내 레포라도 topic branch가 merge없이 push되었으면 PR로 인식된다. . 내 개인소스 수정: merge –no-ff -&gt; main commit -&gt; push PR : no merge -&gt; topic commit -&gt; topic push | . | 원본레포인 is3js/py는 미동도 없고, fork한 내 레포 is2js/py에만 PR이 들어온다. | . | topic push로 만든 Fork레포 PR클릭시 원본레포(baserepo) PR을 유도: 전제-main(master)는 변화없이 topicbr만 변화! cf) Fork레포(headrepo)로 merge도 가능함. . 일단 기본적으로 fork한 내 레포(head repo) : is2js/py에서 | 원본 레포(base repo) : is3js/py로 PR를 보내는 것을 기본적으로 수행하려 한다. | fork레포에서 PR버튼 눌렀는데, 이미 원본레포(is3js/py)로 이동되어있다. | . | . . base repo를 수정하면, fork-main &lt;- fork-topic 도 가능한가보다. . | Create pull request해보자. . 원본레포에다가 날리는 것이다. | 원본레포에서 보면 PR이 불들어와있다. | . . | fork레포는 PR에 아무 표시도 안된다. . | 원본레포 팀원은, 팀원X-Fork-topic-PR 날린 것을 commit을 직접 확인하여 request chagnge하거나 approve해준다. . PR 확인후 해당 topic branch의 커밋까지 찾아들어간다. . . | 코멘트를 날릴 땐, +드래그해서 많이 날릴 수 있음. . | 최종적으로는 우측 상단의 review changes &gt; approve까지 해야하지 merge된다. . . | 최종승인하면 원본의 기본branch인 main으로 알아서 merge된다. . | 팀원이 아니더라도 PR(merge)후 delete branch가 원칙: 로컬에서 로컬+fork 2개다 해줌. . 로컬에서 내 fork레포 및 내 로컬레포의 topic branch를 삭제해준다. . main으로 바꾸고, 삭제 | . ❯ git branch -a❯ git checkout main❯ git branch -d work . | . 로컬topic 삭제 -&gt; remote(fork레포)도 자동삭제 반영시키기: git remote update –prune . 로컬에 topic branch가 삭제된 상태에서 git remote update --prune을 사용하여 로컬에 맞춰서 branch삭제 시킨다. . | ❯ git remote update --prune . | 안되서 나는 git push origin :remote_br . git push origin :work . | 참고) origin과 upstream . 레퍼런스: https://pers0n4.io/github-remote-repository-and-upstream/ | . Upstream &amp; Downstream . GitHub에서 repo를 생성하고 나면 다들 origin이라는 용어를 보셨을 겁니다. clone했을 때는 origin이 자동으로 등록돼있고, init했을 때는 git remote add origin ...으로 origin을 직접 등록하라고 안내하죠. 여기서 말하는 origin이 깃허브에 존재하는 repository 즉, remote를 뜻하는 단어입니다. 다만 remote에 origin이라는 이름을 붙인 것뿐이랍니다. . upstream과 downstream은 상대적인 개념이라 origin과 local을 기준으로 생각하면 origin이 upstream, local이 downstream이 됩니다. 그 이유는 push와 pull을 기준으로 생각했을 때 origin으로부터 local로 흐르는 관계가 형성되기 때문입니다. . local에서 origin으로 push한다 | origin에서 local로 pull한다 | . 만약 CLI로 push를 해보셨다면 git push -u origin main3이라는 명령어를 입력했을 텐데, 여기서 -u 옵션이 --set-upstream 옵션의 줄임으로 upstream을 설정한다는 뜻입니다. upstream을 한 번 설정하고 나면 다음부터는 git push 또는 git pull이라고 명령어만 입력해도 자동으로 origin의 main 브랜치로부터 push와 pull을 진행하는 이유가 upstream 옵션을 통해 해당 브랜치에서 upstream과 downstream 관계가 설정됐기 때문이죠. . Fork . GitHub에서 오픈소스 프로젝트에 기여한다거나, 협업을 진행할 때 fork를 이용하게 됩니다. fork는 다른 사람의 repository를 내 소유의 repository로 복사하는 일이죠. 따라서 원래 소유자의 remote repository와 내가 fork한 remote repository 사이에도 upstream과 downstream이라는 관계가 형성된답니다. 그래서 보통 원래 소유자의 remote를 말할 때 upstream, 내가 포크한 remote를 말할 때 origin이라는 용어를 사용하곤 합니다. . 노팀원이지만 [원본repo(오픈소스)] -&gt; fork레포 및 local레포를 최신형으로 유지 by local에서 upstream으로 등록하여 upstream(원본레포) -&gt; origin(fork레포), upstream -&gt; local 통로뚫고 가져오기: git remote add upstream [url] -&gt; git fetch upstream -&gt;[fork레포 ]merge버튼 + [local]git merge upstream/main . 상황 . 갑자기 오픈소스 author가 원본repo -&gt; main을 변경했다면? . 나한테(fork레포, local레포)의 main도 수정된 내용이 들어와야한다. | . . | 기존 local repo에서 -&gt; fork repo를 origin 이라 별칭했음 . local repo에서 -&gt; 원본repo를 upstream으로 별칭 등록 및 원본repo - fork repo를 연결 | . | git fetch: origin to local . git fetch upstream: 원본repo(upstream) to fork repo(origin)으로 업데이트 내용 받아오기 | git merge upstream/main으로 원본repo(upstream) to local repo(local)로 업데이트 내용 받아오기 | . | . | my) 원본repo를 노팀원이 upstream으로 local에서 등록하면 . upstream -&gt; fork | upstream -&gt; local 업데이트가 가능하다. | . | . | 관련 명령어 . . | 참고) upstream 삭제 . 참고 블로그 . git remote -v git remote rm upstream git remote -v . | . | . local에서 원본repo를 upstream으로 등록한다. . ❯ git remote add upstream https://github.com/is3js/py.git . . | git fetch upstream명령어로 upstream의 최신정보를 origin이 받을 수 있도록 업데이트해온다.(아직 받진 X) . ❯ git fetch upstream remote: Enumerating objects: 8, done. remote: Counting objects: 100% (8/8), done. remote: Compressing objects: 100% (3/3), done. remote: Total 5 (delta 2), reused 4 (delta 2), pack-reused 0 Unpacking objects: 100% (5/5), done. From https://github.com/is3js/py * [new branch] main -&gt; upstream/main . origin(fork repo)에 가보면, Fetch해왔다고 뜬다. | . | fork repo에 들어가 git fetch upstream정보를 이용해 최종 merge시킨다. by Fetch upsteam&gt; Fetch and merge 버튼 . | local에서는 git merge upstream/main명령어를 이용해 upstream정보를 가져온다. . 왠지 origin을 pull해서 업데이트 해도될것같긴한데… 따로 upstream -&gt; local로 받는다? | . ❯ git merge upstream/main Updating 476f70b..f7dd8e8 Fast-forward .gitignore | 11 ++++++++++- rb.py | 3 +++ 2 files changed, 13 insertions(+), 1 deletion(-) . 참고) 만약 merge가 conflict나면 . git merge upstream/master --allow-unrelated-histories . | . | 앞으로 계속 . ❯ git fetch upstream # fork repo가서 merge 버튼 # local에서 merge ❯ git merge upstream/main . | 팀작업1: 내부팀원 (not 오픈소스) 초대 및 작업하기 . 내부 소스( not 오픈소스)라고 가정한다. | 관련 명령어 | . 팀리더(is3js)가 팀원(is2js)초대 : github-settings-manage acess-add people(invite collaborator) . 초대받은 사람은 등록 email로만 초대를 받음. push권한이 있다고 한다. = 글쓰기 기능이 있다. | . | . 팀원은 초대되었다면,fork(-&gt; clone -&gt; topic -&gt; PR)할 필요가 없이 clone(-&gt;push)or(-&gt;topic-&gt; review=팀원PR)만 한다. 팀원이라면 바로 local-&gt;팀repo에 바로 push가 가능 . 팀원은 초대되었다면,fork(-&gt; clone -&gt; topic -&gt; PR)할 필요가 없이 clone(-&gt;topic-&gt;push or review=팀원PR) . ❯ mkdir team_py❯ cd team_py❯ git clone https://github.com/is3js/py.git . . | 해당 폴더로 이동후 수정하고 commit -&gt; push까지해보자. . 원래는 topic -&gt; | . code .# main에서 바로 # 파일수정# add commit -&gt;push . | 팀원이라면, 팀repo에 바로 push가 된다. . | 팀작업2: 내부팀원의 clone (local)에서 topic push로 PR권유 -&gt; topic push한 사람만 PR요청 가능 -&gt; 타 팀원review받기 (review안받을거면 main push했음) . . topic push한 작업팀원만, 자신에게 PR권유를 확인 및 요청할 수 있다. . 팀원은 fork필요없이 local clone후 main push해도 되지만, review를 받기 위해 topic push로 PR한다 . user-login topic branch 생성 . git checkout -b user-login . | login.py 생성 후 작업 . | add, commit, (topic branch) push . | | **팀원repo에 들어가도 ** . topic branch를 보낸 사람이 아니면.. PR권유가 안뜬다. . is3js(타팀원) . PR권유는 topic br push한 사람 자신에게만 보인다. | . . branch로는 보여도, PR은 타팀원이 결정안함. | . . | is2js( topic br push한 작업 팀원) . . | . | . | topic br push를 pull request한다. . 메세지에 코드리뷰 부탁한다고 남기자. | . | 타팀원은 PR 불-&gt; commit 메세지-&gt; commit 클릭 -&gt; 코드 리뷰 . author가 아니더라도 모든 팀원들이 확인할 수 있게 ** **PR에 불이 들어와있다. . | Merge를 누르기 전에 메세지에 달려있는 커밋까지 직접들어가서 코드를 살펴보자. . . | code line에서 +를 드래그해서 코드 리뷰를 해준다. . | 거절을 의미하는 코드 리뷰를 해주자. 코드리뷰한 것 바로 밑에 Reply도 달 수 있으니 확인하면된다. | 코드 리뷰를 데면 우측에 Finish your review(1)가 뜬다. 클릭해서 리뷰를 끝내자. | . | 코드 리뷰를 달면, 자동으로 작업 팀원에게 email도 보내준다. | (topic push -&gt;PR했던) 작업 팀원은 확인해서 1) Reply + 2) local에서 추가작업 -&gt; 3) topic br PUSH -&gt; 4) 자동 PR timeline에 추가 . . 거절성 코드리뷰에 대해 대답을 해주고 . | PR 날렸던 topic br로 다시 돌아와서 . 추가 작업을 함. . ❯ git checkout user-login . | . | 다시 한번 topic br push하면, 추가 PR을 안날려도 자동으로 PR 타임라인에 추가된다. . | 타팀원의 2번째 review부터는 [작업팀원의 추가push]가 자동으로 PR timelien에 추가된다. . 타팀원 화면에서는 작업팀원의 추가작업한 커밋 위에 View changes가 떠있다. . 작업팀원이 커밋할 때 . . | 타팀원(리뷰팀원)화면 . | . | 승인은 LGTM(looks good to me) . 코드 리뷰를 다시 한번 남기고 | finish your review에서 approve를 선택해주면 끝난다. 이 때 멘트는 LGMT를 많이 쓴다. | approval이 떴다면, 작업팀원이 merge PR해도 된다. 아무나 팀원이면 다된다. merge후에는 delete (topic) branch -&gt; local code 최신화(git pull) -&gt; local의 topic branch는 직접 삭제() . approve 확인되면 | 작업한 팀원이라도 merge시킬 수 있다. . | 작업이 끝난 topic branch를 삭제하라고 뜬다. 삭제한다. . | 로컬의 main 코드를 최신화하기 위해 main branch로 와서 git pull로 코드 최신화한다. . ❯ git checkout main . | 로컬의 topic branch도 직접 삭제한다. . ❯ git branch -d user-login Deleted branch user-login (was b7bde3a). . | cf) 혹시 delete branch 안해서 서버에 남아있다면? . local branch 수동 삭제 . | remote 동기화로 삭제 . git remote update --prune . | 팀작업3: issue(개선기록) 와 PR(팀원1(주인)-수정용브랜치push PR / 팀원2-리뷰만) 실습 . 로컬 : git_seminar . | 원격 : CS100_Git in is2js . 협동자: is3js | . | . 로컬 readme생성후 -&gt; 원격 빈레포에 push로 시작. 1번째 가이드: …or create a new repository on the command line(init, readme push) . 로컬에서, 빈 레포 생성시 주어지는 가이드1 번째인 …or create a new repository on the command line를 따라치기 . echo &quot;# CS100_Git&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;first commit&quot; git branch -M main git remote add origin https://github.com/is2js/CS100_Git.git git push -u origin main . 아직 git init안한 상태에서 readme.md를 먼저 만들고,, 시작하네 | . | . | 원격레포에 issue생성: issue는 TODO list 역할이나 논의사항 정리용 . 원격레포의 issue 탭 &gt; new issue 클릭 . readme.md 파일을 좀 더 구체적으로 작성해주라고 issue 생성하기 | . | issue 오른쪽 사이드바에 보이는 Assignees를 클릭하여, issue해결자 10명 중 1명으로 나를 등록한다. . . | issue 해결 전에, collaborator 추가 (상대방은 메일로만 초대받음) . settings &gt; manage access &gt; add people . is2js(tingstyle1@gmail.com, 현재) -&gt; (시크릿창) is3js 계정 추가 . . is3js(is2js@naver.com)계정은 깃허브알림 없이 메일로만 초대장이 옴 | . | . | . 로컬에서 생성 후 파일 수정하기: git checkout -b [생성후전환될 브랜치] . 로컬(is2js)에서 feature/readMe 라는 파일 수정용 브랜치를 생성하자 . ❯ git checkout -b feature/readMeSwitched to a new branch &#39;feature/readMe&#39;&gt;glg # git log(HEAD -&gt; feature/readMe, origin/main, main) . branch 변경 후 git log를 확인하니 HEAD가 브랜치를 잘 따라오고 있다. | . | 파일 수정후에는 add전 gitt diff로 어느부분 수정되어있는지 확인 . ❯ git diffdiff --git a/README.md b/README.mdindex 1743ce5..a6cac92 100644 a/README.md+++ b/README.md@@ -1 +1,3 @@ # CS100_Git++This is CS100 No newline at end of file . | add - status - commit 단계를 거친다. . ❯ git add README.md❯ git status . | (PR날릴 브랜치는)순수 git commit후 메세지 작성되는 부분에 [- issue #번호] 삽입하여, 해당issue에 커밋 걸어주기 . git commit만 입력하기 . &gt; git commit . | commit 메세지 작성 에디터에서 - issue #1의 관련된 issue 번호를 기입해주기 . ADD more description in README- issue #1 . . | 나중에 저렇게 삽입한 커밋속 issue #1지정 부분은 PR속에서 issue를 연결해준다. . **즉, issue에 대한 하여 PR(팀원검토)시에는 `#번호`를 커밋메세지에 넣어두자.** . . | . | 원격레포에 없는 지만, push해주면 &lt;알아서생성+PR권유&gt; . 로컬에서 원격레포로 수정용 브랜치를 push . ❯ git push origin feature/readMeCounting objects: 3, done.Writing objects: 100% (3/3), 289 bytes | 289.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)remote: remote: Create a pull request for &#39;feature/readMe&#39; on GitHub by visiting:remote: https://github.com/is2js/CS100_Git/pull/new/feature/readMeremote: To https://github.com/is2js/CS100_Git.git * [new branch] feature/readMe -&gt; feature/readMe . | github에 가보면, . 새로운 브랜치 생성 확인: 로컬에서 수정용브랜치를 push해서 자동으로 생성한 것 . . | 현재는 main우주만 보여주고 있음. 수정한 평행우주는 브랜치를 선택해서 들어가야 보임 . | . | 혼자는merge지만, PR은 를 팀원(collaborator)들에게 확인요청이니 메세지 한번더! . 혼자 작업했다면, . 로컬에서 수정용브랜치 -&gt; main브랜치 merge하면 끝 | . | 여러명 작업시 merge대신 . 로컬에서 수정용 브랜치생성후 파일 수정 . | 원격레포에 push하여 수정용브랜치 생성 . | 합치기전에 PR과정을 전시하여 팀원들에게 확인받기 . | . | . Compare &amp; pull request 클릭 . . | PR은 팀원확인요청이다. 로컬 커밋메세지가 default로 적혀있는데, 커밋메세지에 PR메세지로서 추가로 적어준다. . . | 아래와 같이 커밋메세지 따로에, PR메세지가 덮어서 보인다. . | PR을 검수할 팀원에게 review요청하기(수정용브랜치를 merge해도될지) . PR메세지 우측에 Reviewers가 있다. 여길 선택해서, PR review를 요청하자. | . is3js(팀원)계정을 시크릿창으로 들어가보자. . 레포 &gt; Pull request &gt; 해당PR까지 클릭하고 가야지 Review요청한 것이 보인다. (호버해도 보이긴하네) . . | | . | 리뷰요청받은 뒤 Add your review는 lineByline으로 피드백 주는 것 . add your review 클릭 . | 플러스버튼으로 피드백을 주면되는데 드래그로 여러라인에 대한 피드백을 줄 수 도 있다. . | 리뷰요청시 피드백(라인별코멘트)과 별개로, 칼을 뽑아야함: Approve(merge) or Request changes(다시push해) . 코멘트를 다 남겼으면, 우측 상단에 Finish you review로 칼을 뽑아야한다. . 이 경우 수정이 좀 더 필요하다고 하여 승인거절한다.내용없이 Reqeust changes 클릭 | . | 내가 남긴 코멘트의 위치 및 승인거절=변화요구의 메세지를 확인한다. . | [로컬] review내용인 1) 라인별코멘트에 [대한 대답reply] &amp; 2) 변화요구에 대한 [에서 수정후 다시 push] . 라인별 코멘트에 대한 대답 . | 리뷰어에 의한 Changes requested는 feature/readMe에 푸싱함으로써 커밋을 추가하라고 뜬다. . reviewer에 의한 request changes는 &lt;수정용 브랜치로 추가 커밋하면 다시 검토&gt;를 말하는 것이다. | . 다시 로컬 해당 브랜치로 와서 . | 요구대로 새롭게 작성후 push까지 해준다. . # 파일 수정# add전 git gtatusgit status#git add 파일명git add README.mdgit commitgit loggit push origin feature/readMe . | | PR은 의 단위라서 아직 merge안됬다면, 해당브랜치는 이어지며 가서 확인한다. . git push origin feature/readMe를 통해 push했으면, 아직 해당 PR상황에서 커밋이 추가된다. . main에서는 추가 PR 안내가 없음. 수정용 브랜치에서는 평행우주의 내용은 변화되었음. | . | reviewer에 의해 request changes는 &lt;수정용브랜치로 추가 커밋하면 다시 검토&gt;를 말하는 것이다. 즉, 검토하고 있던 PR상황으로 다시 직접들어가보면, 추가 push를 확인할 수 있게 됨. | . | . . | **의 추가push후**에는 되면 **또다시 review 요청해야한다.** . . | 또다시 PR(수정용브랜치 merge검토)에 대한 review요청을 받음. -&gt; LGTM approve해주기 . 역시 해당 PR까지 클릭해서 들어와야 보인다. . add your review . 라인별 코멘트 -&gt; 생략 | LGTM(Loos Good To me)와 함께 Approve | . . | . | . review가 approve해야 드디어 merge가 뜬다. 동시에 . . . 우측의 Delete branch를 눌러 수정용브랜치를 삭제해주자. . | PR탭은 Merged로 해결됨. . | [issue탭]에서도 Merged가 뜸. -&gt; [PR-&gt;merged]의 해결된 issue를 닫기 . . issue작성 후 . 수정용브랜치 생성 | PR를 위해 커밋 커밋시 issue번호를 #번호형태로 커밋메세지 속에 남기면 issue탭에서도 표기가 된다. | . | . | 수정용브랜치 push -&gt; PR 생성 -&gt; review -&gt; merged로 해결되었으면 issue도 닫아야한다. . 메세지로 닫는다 알리기 . . | Close issue를 눌러서 해당 issue를 닫는다. . | | [로컬]에서 default [main]브랜치로 옮겨와, PR-&gt;merged된 프로젝트 정보를 git pull로 내려받아서, 로컬에서도 통합 및 브랜치삭제가 반영되도록 한다. . 삭제당한 feature/readme&lt;수정용브랜치&gt;가 아닌 default main브랜치로 옮겨와서 git pull받는다. | ❯ git checkout main ❯ git fetch ❯ git pull # git pull origin main 으로 정확하게 표시하면 upstream설정이 안뜬다. # 그러나 한번만 업스트림하면 되므로 그냥 해준다. ❯ git branch --set-upstream-to=origin/main main Branch &#39;main&#39; set up to track remote branch &#39;main&#39; from &#39;origin&#39;. ❯ git fetch ❯ git pull Updating 99ce761..1ed16b7 Fast-forward README.md | 4 ++++ 1 file changed, 4 insertions(+) .",
            "url": "blog.chojaeseong.com/git/2021/10/17/%EA%B9%834_PR%ED%8C%80%EC%9E%91%EC%97%85_1%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4_2%ED%8C%80%EC%9E%91%EC%97%85_3%EC%9E%87%EC%8A%88%EC%99%80%EB%A6%AC%EB%B7%B0%EC%9A%A9PR.html",
            "relUrl": "/git/2021/10/17/%EA%B9%834_PR%ED%8C%80%EC%9E%91%EC%97%85_1%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4_2%ED%8C%80%EC%9E%91%EC%97%85_3%EC%9E%87%EC%8A%88%EC%99%80%EB%A6%AC%EB%B7%B0%EC%9A%A9PR.html",
            "date": " • Oct 17, 2021"
        }
        
    
  
    
        ,"post80": {
            "title": "SKTacademy 코테 TIP과 자료구조",
            "content": "reference SKTacademy | | . 알고리즘 푸는 이유 . 구현: 생각하는 내용을 코드로 옮긴다. 연습안하면 안된다. 500문제 이상 풀어야함. 반복해야 언제 어떤 변수를 선언하고 언제 전처리 해야하는지 알 수 있게 된다. 빨라지고 나만의 코딩스타일이 생긴다. | 효율성: 계속 구현하다보면, 효율성을 챙기면서, 자주 사용하는 함수로 최적화 | 다른 사람들의 코드를 보면서, 효율적인 코드 작성 | . | 절차적 사고: 절차적인 사고에 익숙해짐. 언제 어떤 과정을 하고, 다음은 어떻게 해야하는지 | 적재적소한 알고리즘을 선택할 수 있게 된다. 그럴려면 자료구조, 알고리즘을 따로 공부해야한다. | . | . | 디버깅: 한번만에 맞는 경우는 거의 없다. 예외케이스 탐색을 많이 해야한다. 최저, 최대, 최악 경우를 넣어보면서 한다. | 코드(에러)를 읽는 능력 | . | . | 재미: 적은시간으로 연습 가능 | 프로젝트와 다르게 짧은 주기로 성취감 | . | 문제보고 감잡기 . 1초당 가능한 복잡도 간 미리 계산하기 . python으로 . 백만번(10^6) 반복문or덧셈곱셈 등… -&gt; 1초 안에 다 풀린다. | 천만번(10^7) -&gt; 1초 안에 대부분 풀린다. python으로 1초안에 천만~5천만(10^7 ~ 5* 10^7)까지 연산 가능하다 생각하자. | . | 1억(10^8) -&gt; 불가능 -&gt; 알고리즘 바꿔야함. | . | 다시 문제보기 . 시간제한부터 보기 . 1초 -&gt; 10&amp;7 안에 풀어야한다. | . | 입력 보고, 반복문 횟수 갸늠하기 . n = 10억 = 10^9 -&gt; 단순 반복문 O(N)으로 는 불가능하다. | 입력을 보고 O(N)이상 불가 -&gt; 루트(n) or lgN or O(1)으로 해야한다. | . | . | . | PS팁 . 입력과 초기화 . python의 input은 3가지 종류를 받는다. . 숫자1개 . python에서는 항상 string으로 들어온형변환부터 해준다. | . . | 문자열 . 일반 문장 | 쪼개면서, [i]번째 인덱싱도 하고 싶다 -&gt; list() immutable한 string 대신 list로 변환시켜줘야한다. | . | 다시 붙일려면 ”“.join사용 | . . | 숫자 배열 . map을 써서 형변환한다. | . . | . | **list(배열)의 초기화는 comprehension으로 ** . . | . | 에러메세지 확인하기 RE: 런타임에러 -&gt; zerodivision or indexError | TLE: 시간초과 -&gt; 잘짰는데 무한루프가 있거나, 알고리즘이 안 좋거나 | . | 추상화와 기능분리 . 맨 처음 반복문에 돌아가면서 기능을 해줄 or 테케마다 처리해줄 input()받기부터 시작하는 함수를 짜자. 대충 로직을 슈도코드 짜듯이 짜면서 반복문 - 체크 - 결과값 저장 등의 로직을 짠다. . | 코딩하는 2가지 방법 . 현재가 main함수라고 가정하고 while 문에서 다 돌리기 | process함수를 따로 만들어놓고, 테케를 process함수에서 받아 main에서 돌림 | . | 처음에는 다 while문에 넣고 돌린다. . | 하지만, main함수는 최소화 해서 가벼워야한다. 내용들은 다 함수로 보낸다. . 반복문을 돌되, 각 TestCase마다 따로 처리되도록 함수로, TC별 처리되도록 하는 함수를 만들어서 돌린다. | . . 일단 위에 스샷기준으로는.. 테케별 처리도되록 함수에서 input을 받고 -&gt; 리하고 -&gt; return 하고-&gt; main에서 for문 print(함수return값) | . | . | 예를 들어, 삼성기출-사다리조작문제를 보자. (풀이는 안함) . 삼성쪽은 문제가 되게 길다. 그림 위 수치 위주로 빠르게 한번 보자. . 일단 수치(숫자)를 먼저보고 &quot;아~ 사다리가 5줄, 6줄 되는 구나 &quot; . | 사다리를 중간에 넣을 수 있구나 . | 사다리를 진행해나가는 과정이 있구나 . . | . | 입력 양식(예제 입력)보기 . 첫줄의 숫자와, 나머지 아래 숫자가 같으니까 아 대충 아래쪽이 사다리를 의미하겠구나 | . | 문제를 자세히 읽기 시작하는데 출력 요구사항을 먼저 본다 . | 문제가 복잡해보인다. . **이 때, main함수를 간단하게 만들기 위해, 반복문 어떻게 돌릴지 판단 -&gt; 그안에서 사용될 기능 분리하여 일단 슈도코드로 함수들을 작성해 기능분리 시켜준다. ** . | 사다리를 최대3개까지 놓는데, . i에 놓을지 . j에 놓을지 . k에 놓을지 선택할 수 있게 3중for문을 만들어 탐색가능하게 함. . | 3개에 따라 가능한지 확인하는 check(i,j,k) 함수를 사용하고 슈도코드로 위에다 작성해둔다. . | 가능할 때, 그 i번째 사다리가 i로 내려오는지 체크해주는 함수result()도 슈도코드로 작성해둔다. . | . . | . | | . | 코드를 줄여 가독성을 높이는 조건문, 반복문, 함수 by python indent를 줄이기 . 반복문 eX&gt; N by N by N 3중 포문 . 똑같이 N**3 만큼 횟수는 동일하게 돌아가는데, 한번에 for num in range(N**3)으로 돌리면서 . i = num을 N^2으로 나눈 몫 = num // (N*N) | j = num을 N으로 나눈 몫을, 다시 N으로 나눈 나머지 = num//N % N | k = num을 N으로 나눈 나머지 = num % N | . | **내가 만든 2중 포문을 indent 1개로 ** . i = num을 N으로 나눈 몫 N*N을 통해, ` 0~N-1을 첫번째 구간으로해서 N개` 존재하는데, 0~N-1구간: 행을 0으로 간주해요 | N~2N-1 : 행을 1로 간주해요 | … | ~N^2-1 N개의 구간이 있어요 | . | . | j = num을 N으로 나눈 나머지 구간별로 0~N-1의 열을 담당해요. | . | . for num in range(N**2): i, j = num//N, num%N print(f&quot;({i},{j})&quot; , end = &quot; &quot;) . | 진법, 진수를 활용하면 더 쉬워진다고 한다. . | . | main 반복문 속 조건문을 if True:시 process()가 아니라 if not False시: continue로 아래 process() 건너띄기를 통해 indent를 챙길 수 있다. . . process()함수 위에다가 if not 조건문 :continue를 활용해서 탈락시 건너띄기하면, 반복문내 indent를 줄일 수 있다. | . | 함수안에 if : return 다음에는 else가 필요없다. . **if return / return도 return 삼항연산자로 줄일 수 있다. ** 가장 선호. flag도 이런식으로 할 수 있다. | . | . . | | 변수명은 snake_case로, 함수명은 cameCase로, Pascal은 시작부터 대문자인 Camel . | 적용해보기 주사위네개 . 나는 Counter를 활용했지만.. | . # 기존 내코드 N = int(input()) from collections import Counter max_money = float(&#39;-inf&#39;) # 같은 눈이 4개가 나오면 50,000원+(같은 눈)×5,000원의 상금을 받게 된다. # 같은 눈이 3개만 나오면 10,000원+(3개가 나온 눈)×1,000원의 상금을 받게 된다. # 같은 눈이 2개씩 두 쌍이 나오는 경우에는 2,000원+(2개가 나온 눈)×500원+(또 다른 2개가 나온 눈)×500원의 상금을 받게 된다. # 같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)×100원의 상금을 받게 된다. # 모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)×100원의 상금을 받게 된다. def calc_money(data): max_cnt = max(data.values()) val_lst = [ x[0] for x in data.items() if x[1]==max_cnt] if max_cnt == 4: return 50000 + (val_lst[0]*5000) elif max_cnt == 3: # val_lst = [ x[0] for x in data.items() if x[1]==max_cnt] return 10000 + (val_lst[0]*1000) elif max_cnt == 2: # val_lst = [ x[0] for x in data.items() if x[1]==max_cnt] if len(val_lst) == 2: return 2000+(val_lst[0]*500) + (val_lst[1]*500) else: return 1000 + (val_lst[0]*100) else: return max(data.keys())*100 for _ in range(N): data = list(map(int, input().split())) data = Counter(data) money = calc_money(data) max_money = max(max_money, money) print(max_money) . 수학을 이용하면서 . 기능분리 by 함수 | 입력과 초기화 by 튜플, 컴프리헨션 | 반복문, 조건문 줄이기 by 한번에돌기+ if reutrn후에는 no else noelif + 삼항연산자 | . . | . | 수학 . 반복문을 . range(min(a,b))로 길이를 줄이거나 | range(min(a,b),,-1)로 거꾸로 시작하거나 | range(,,n)으로 간격을 주는 것을 생각하자. | . | 유호제법은 코드로 외우자. . math.gcd써도될듯.. | . # a&gt;b def gcd(a,b): # 1) b가 a의 약수면.. 그냥 b가 최대 공약수 # 2) 그게 아니라면, 재귀로서 gcd(b, a%b)로 재귀로 빨리 구하자. return b if a%b==0 else:gcd(b, a%b) . | 소수판별과 에라토스테네스의 체 . 소수판별 isPrime은 . 이론상 소수=1과 자기자신만을 약수로 가짐 = 2~n-1까지 약수없음, 약수 나오면 탈락인데 . 약수와 배수의 관계에서 약수는 항상 짝을 이루어 존재하니 2~루트(n)까지만 검사한다. | . . | . | 에라토스테네스의 체 . 범위가 주어진다 1~n까지 중 소스의 갯수는? 1은 소수가 아니여서 지움 | 2부터 isPrime으로 소수판별 소수로 판별되면 -&gt; 소수의 배수들을 싹다 지움(어떤수의 배수는.. 소수가 아님 무조건 x2, x3들이 약수가 되니까 | . | . | . . 뭔가를 지울 때는 chk, ck배열에다가 index - T/F를 hashing하여 활용한다. 이미 범위가 정해져있으면 거의 이렇게 사용한다. count 정렬 | 에라토스 테네스의 체 | DFS BFS? | . | . . 그외 자세히 주석으로 달음 . def era(N): # 체크는 hasing용으로서, n index를 쓸 거기때문에 0부터 시작했더라도 range(N+1)까지 돌려준다. ck = [ False for _ in range(N+1) ] p = [] # 1은 소수가 아니므로 제끼고 2부터 체크한다. # 소수의 배수들을 True를 채워놓고, 다음에 올 때 건너뛰게 한다. # 과거에서 판단한 소수의 배수들에 안걸렸으면, 아직 False로 남아있는, 소수는 바로 append해 줘도 된다. # -&gt; 맨처음 2만, 최초이기 때문에 과거에서 True로 소수탈락시킨 경험이 없다. for i in range(2, N+1): # 아직 False인 것만 체크한다. # 아래에서, 미래원소들 중에 소수라고 판별내어놨으면 건너뛴다. # -&gt; check를 활용해서 건너뛰는 [ck 미래 -&gt; continue 로직]이다. if ck[i] == True: continue # False = 2의 배수부터 시작해서, 소수탈락(True)에 안걸렸다면, 소수라고 판단한다. p.append(i) # 현재 i는 소수라는 뜻인데, 소수-&gt; 소수의 배수를 True(소수탈락)로 지워야한다. # * i배수 조작-&gt; i배수는 range(시작수, 끝수, i)를 통해 +i씩 움직인다. # 이 때, i+i or i*2부터 +i씩 i*3, i*4를 지워나가는게 아니라 # * &lt; ixi &gt;부터 시작해서 i의 배수를 지워나간다 range(i*i, N+1, i) # -&gt; 왜냐하면, 이미 과거에서 지워났기 때문인데 # -&gt; 예를 들어, 6은.. 이미 2에서 지워놨음. 3에서 지울 필요X. # -&gt; 3은 뭐부터 지워나가야할까? -&gt; 앞에서 안나왔을, 3의배수로서만 존재하는, # -&gt; 3만을 약수로 가지는 = 9부터 지워나가면 된다. # -&gt; 2*i부터 지눠나가도 괜찮다. # for j in range(i*2, N+1, i): for j in range(i*i, N+1, i): ck[j] = True # 이제 리얼소수는 p 배열에, 체크여부는 ck(소수탈락시True?)로 반환한다. return ck, p print(era(10)) # ([False, False, False, False, True, False, True, False, True, True, True], [2, 3, 5, 7]) . | . | . | 하노이 = 분할정복 by 재귀 . n번째 자체처리를 잘 넣어주자. | 재귀가 꼭 return해줄 필요는 없다. return안한다면 꼭 + 등의 연산으로 연결해줄 필요가 없다. 갯수: return f(n-1) * 2 +1 | 출력: f(n-1) + print(n자체) + f(n-1) f(n-1)내부에서도 print가 호출됨. | . | BUT 재귀함수의 base case if는 반드시 return으로 종료시켜줘야한다!! | . | 변하는 것들을 인자로 잘 넣어주자. 숫자 명칭이 고정이라면, 합이 일정한 것도 이용하자. | . # 1-&gt;3def hanoi(st, ed, n): if n==1: return print(st,ed) # 1-&gt;2 n-1 # st-&gt;mid hanoi(st, 6-(st+ed), n-1) # 1-&gt;3 print(st, ed) # 2-&gt;3 n-1 # mid -&gt;ed hanoi(6-(st+ed), ed, n-1) . | 정렬 . 선택정렬(i+1~n-1와 비교 최소값 찾으면 swap, 매번 맨왼쪽 최소값 확정), 버블정렬( 매번 인접한수 비교후 크면 오른쪽으로 swap, 매번 맨오른쪽 최대값 확정)은 n, n-1, .. 1번 모두 탐색해야해서 시복 O( n(n+1)/2) = O(N^2)으로 너무 느리다. . | 퀵 소트 . 재귀로 구현. 1)p정하고 2) 작, 큰그룹나눠서 3)p자리 확정의 과정을 작은그룹에서 1번, 큰그룹에서 1번 다시 시행한다. . def quick_sort(array): # 리스트가 하나 이하의 원소만을 담고 있다면 종료 if len(array) &lt;= 1: return array pivot = array[0] # 피벗은 첫 번째 원소 tail = array[1:] # 피벗을 제외한 리스트 left_side = [x for x in tail if x &lt;= pivot] # 분할된 왼쪽 부분 right_side = [x for x in tail if x &gt; pivot] # 분할된 오른쪽 부분 return quick_sort(left_side) + [pivot] + quick_sort(right_side) . | . | 머지 소트 . 재귀시, divide후 conquer과정에 투포인터 개념으로 merge를 해야한다. . | 1)절반으로 나누고, 2) 각각을 투포인터개념으로 합친다. . # 합병정렬에서는 conquer과정이 복잡하다. # [divide] 는 그냥 반씩 쪼개면 되지만, # [conquer]된(정렬된 list2개) 것들을 [combine](2개 list 합하여 정렬)시 복잡하기 때문에 이 부분을 merge함수로 뺀다. def merge(list1, list2): merged_list = [] i = 0 j = 0 while i &lt; len(list1) and j &lt; len(list2): if list1[i] &lt; list2[j]: merged_list.append(list1[i]) i+=1 else: merged_list.append(list2[j]) j+=1 if i == len(list1): merged_list += list2[j:] elif j == len(list2): merged_list += list1[i:] return merged_list def merge_sort(my_list): # base case if len(my_list) &lt; 2: return my_list # divide and conquer left_half = my_list[:len(my_list)//2] right_half = my_list[len(my_list)//2:] # 부분문제는 원래함수(부분)을 한 상태가.. 정복된 상태다 조심! return merge(merge_sort(left_half), merge_sort(right_half)) print(merge_sort([12, 13, 11, 14, 10])) . 2개의 배열을 merge할 때, 4개짜리 배열을 미리 대기시켜놓고, 투포인터로 넣어줘야한다. | 즉, 메모리할당이 많아진다. | 머지 소트는 정렬 문제에서 메모리가 넉넉할 때 쓴다. | 퀵 소트는, 최악(역순정렬&amp;p를 맨첫값)의 경우 NN이 될 수도 있다. | . | python sort(), sorted()는 퀵소트, 머지소트보다 더 최적화된 정렬을 쓰니. 그냥 이걸 쓰자. . | . | 라딕스 소트(radix sort) = 카운팅정렬 -&gt; 이범정(10^6~10^7 이하)일 때 . **이미 최소~최대값의 범위가 정해져있을 때 **, 그 범위를 index로 hashing시킨 배열을 미리 만들어놓고 . | 카운팅한다. . | 카운팅수만큼 연속해서 나열� . | | 자료구조 . 쓰는이유: 효율성. 쓰는 의미가 있음. 사용처가 정해져있다. 메모리를 효율적으로 쓴다. ex&gt; stack: undo 마지막에 했던 작업을 되돌리기 위해. 직전꺼를 되돌리기 | . | 추상적: 코드가 정해져있지 않음. 개념이므로 라이브러리가 아니더라도 어느 언어라도 구현가능해야한다. | 재사용성: 계속 쓰기 위해 라이브러리를 제공함 python은 collections에 많음. | . | . | stack 접시닦고 다시 가져가는 것에 비유 많이함. undo | 넣고push 위에서부터 빼는pop 2가지가 핵심 | 배열과 다른점은, 맨 마지막이 빠져나가는 점 : LIFO | python에서는 따로 library없고 배열[]로 바로 사용한다. | 예제 : 괄호 -&gt; 여는괄호만 넣어서 쌓으며, 닫괄시.. 직전에 넣은 여괄 부터 꺼내 짝이 맞나 확인해야한다. | . | queue와 deque 왜쓸까? 배열이랑 달라보이지만, 불필요 메모리를 줄인다.메모리를 효율적으로사용하기 위해 배열로도 구현가능(pop한 앞부분으로 index를 한칸씩 당긴다.?) | 이미 pop한 것들을 붙잡을 이유가 없어서 그럴필요가 없음. | . | server에서 여러 queue를 써서, 여유로운 queue에 task를 넣어주는 형식(task분할) | python에서는 deque = stack + queue라서 queue문제는 deque | 예제: 요세푸스 돌면서 제거된 사람을 빼야하는 경우 -&gt; deque의 queue로 popleft + append를 rotate로 해결 | . | . | . 그래프와 Tree의 저장방법 . 그래프의 특이한 형태로서, 나가는 간선(outdegree)만 있으면 Tree . Tree도 2가지 저장방법이 있다. . 자식마다 부모는 only 1개씩, 자식배열에 저장 cycle없이 root node제외하고 다 부모가 1개씩 존재 | 밑에서부터 부모를 찾아 올라갈 수 있다. 4의 부모 2 -&gt; 2의부모 1 -&gt; 1의 부모 0 == root | . | . | 부모마다 여러개자식을, 자식list로 2차원배열에 저장 인접리스트 저장시, 아래로 내려가면서 순환을 돌기 좋다. 1의 자식2 -&gt; 2는 아래로 4,5,6을 볼 수 있으니 4번 부터 본다. -&gt; 4번은 비어서 leaf node로 끝났따 -&gt; 5번 보고 6번보고 하자. | . | . | . | Tree의 부모저장배열 -&gt; LCA찾기 예시가 촌수문제다. . 조상들 모을 default 0의 N+1개짜리 부모저장배열 생성 입력정보를 배열에 저장함. 부모 없으면 0 | . | 2개 node의 공통조상찾는다? 각각의 (조상, 촌수) 튜플이 담길 list를 선언 | 한번 타고올라갈때마다 거리를 더해줄 각각의 촌수변수 선언 | . | 각 node마다 부모가 없을 때까지 찾아가야한다. default 0이며, 안쓰는 p[0]에 0이 들어가있어 무한루프의 가능성이 있으니, 부모가 0되는 순간 빠져나와서, 아직 처리안된상태로 나와, 마지막에 한번더 처리해준다. | 나부터 시작, 거리0으로서 튜플로(조상,거리)를 모아준다. | 재귀적으로 한번 찾아갈때마다 B = p[B] 로서, 나를 부모로 업데이트해준다. 그러면 나의 부모의 부모를 찾아가도록 된다. | . | . N = int(input()) A, B = map(int, input().split()) # 1. 촌수는 Tree형태 그래프인데, 문제에서 부모(1개만) 저장하는 방식을 택했으니 # -&gt; 1차원 배열에 다가 받아준다. # -&gt; 자신의 부모를 모두 0으로 초기화 해놓는다. (1부터 시작하는 node -&gt; 0은 부모가 없다는 것을 표현함.) # cf) 자식들y는 여러개일 수 있어서 index에 놓고, 각 자식들에 대한 부모는 1명밖이다 -&gt; value로서 1개 p = [0 for _ in range(N+1)] # 2. 관계수를 for문에서 바로 받아, 각 관계 -&gt; 부모배열을 채운다. for _ in range(int(input())): x, y = map(int, input().split()) # * 3.우리는 1차원 배열에 [부모만!] 저장한다. # 1 2 중에 1이 부모니까 index 2에다가 1를 저장한다. # cf) 자식들y는 여러개일 수 있어서 index에 놓고, 각 자식들에 대한 부모는 1명밖이다 -&gt; value로서 1개 p[y] = x # 3. A와 B의 공통 조상을 찾기전에, # * A의 조상들을 모두 모은다, B의 조상들을 모은다 -&gt; 교집합? # ** 참고로, A조상을 모을 때는, A자신을 포함해서 A자신 정보, 촌수거리0 부터 시작해서 -&gt; 재귀적으로 (부모, 부모까지거리(+=1)의 정보를 호출해서 담는다. Aa, Ba =[], [] # Aa: A의 조상a, Ba : B의 조상a # * A의 조상들(부모, 부모의 부모.. ) 모으는 과정에서, A와의 촌수도 같이 튜플로 저장하기 위해 Ad, Bd = 0, 0 # 1) 자신x&lt;-부모p[x]로 업데이트하여, 부모의 부모도 다음번에 찾아가게함 # 2) 자신&lt;-부모 업데이트할 때, 거리도 +1 업데이트해서, 촌수도 올라가게 함. # 3) p[x] &gt; 0를 while if조건절에 놓아서, p[x]==0 부모가없는 지점까지 올라간다. while p[A]&gt;0: # 3-1) 제일처음에 들어가면, 나와의거리Ad=0인.. 나 자신을 0촌 조상으로 튜플로 넣어준다. (나, 나와의거리) Aa.append( (A, Ad)) # 3-2) 재귀적으로 내가 부모가 되도록 업데이트해서, # while p[updated A]부모의부모가 있다면 -&gt; (나 updated A=부모, 전보단 늘어난 거리updated Ad +1) # 을 조상으로서 재귀적으로 모아준다. Ad+=1 A = p[A] # 내가 내 부모가 된다. for 다음단계를 위한 업데이트 # * 부모가 없는 p[A]=0의 root node도 넣어줘야한다... root node가 공통조상이 될 확류은 높다. # - 현재 p[A]==0상태이며, 첫 0이라서.. 루트노드로 업데이트된 것 일 것이다.. 마지막에 한번만 넣어주자. Aa.append((A, Ad)) # 4. B도 마찬가지다. while p[B]&gt;0: Ba.append( (B, Bd)) Bd+=1 B = p[B] Ba.append((B, Bd)) # print(p) # * 5. 2개배열을, &lt;2중 포문&gt;으로 1:1매칭 해보면서, 튜플 (조상, 촌수) 중 조상이 같을 때를 찾늗나. # -&gt; 조상이 같은 순간에서 촌수를 더해버리면 된다. for i in Aa: for j in Ba: # 여기는 Aa, Ba 조상들의 1:1매칭 공간 if i[0] == j[0]: print(i[1]+j[1]) # 등장하면, 제일 빠른 것을 만난 순간 바로 프로그램을 종료하면 된다. exit() else: print(-1) . | . | 나가는 간선외 들어오는 간선(indegree)까지 있으면 Graph . 그래프는 2가지 저장방법이 있음 . 인접행렬 : 행: 출발점 -&gt; 열: 도착점을 나타내는 N by N행렬 . 인접행렬도 3가지가 있음. 노방향 | 방향 | 방향+가중치 | . | . | 인접 리스트 : 튜플로 갈수 있는 (가중치, 노드) list를 인접한 list에 저정함. . 1의 indegree는? 0 (들어오는게 없다) . | 1의 outdgree는? 3 (3개가 나간다.) . in, outdegree가 중요한 이유는 indegree가 0인 지점이 시작점 일 될 수도, 한붓그리기 는 짝수여야한다. 등의 규칙이 있음 | . . | . | 이렇게 그래프를 저장하면, 최단거리나 가중치를 고려한 최소비용 등을 계산할 수 있게 된다 . | . | . | . 규칙적용된 tree인 이진트리로 heap/bst . 이진트리: Tree구조 자체가 graph만큼 어려워서 규칙을 정했는데 Tree의 rootnode가 1부터가 시작 | 자식은 최대2개로 하여-&gt;왼쪽자식node == 부모node의 2배가 너넘버링된다. 나node//2 는 부모node | . | | heap: NlgN으로 정렬을 유지하면서 데이터 pop/push가 가능하다. 그림 출저 | . | bst: python에서는 set, dict의 key를 원소-&gt; hash값 -&gt; hash값들을 bst 구조로 만들어 내부에서 사용되어 중복안되고 bst로 검색해서 빠르다? | . 그래프, 일반Tree, 점, 격자판 다 탐색하는 DFS와 BFS . DFS 전수조사시 사용되하는데, 1-&gt;0 마지막 탐색지점에서 빽할 때, 직전 node가 필요한데, 직전node를 stack 선언후 쌓아두는게 아니라, 재귀를 이용해서 stack을 자동 사용한다. 재귀함수=함수=stack메모리에서 관리되어 stack처럼 쓰임 | . | . | BFS 시작좌표(시작점, root node)에서 시작하여 level별 = 최단거리별 기록하기 위해 queue(deque)을 사용한다. 목표좌표가 나타나는 최단거리(level)을 구하거나 | 해당 level이 끝났을 때 최단거리의 수? | . | level별로 좌-&gt;우순으로 검색한다. | queue에 시작좌표를 넣어놓고 빼고 -&gt; (목표좌푠지확인) -&gt; 자식들 탐색 -&gt; 검사 -&gt; 넣기전 자체처리 -&gt; queue에 넣기 -&gt; (level별 시행시 L+=1) | . | . | . | 2개의 사용차이 찾는 범위가 국한되어서 n번안에 찾아지는 것이 확신을 할 수 있을 경우 -&gt; BFS 숨바꼭질2 | . | 모든 범위를 찾아봐야 하는 경우(매 탐색마다 1-&gt;0 바뀌는 끝을 찍어야하는 경우?) -&gt; DFS 단지번호 붙이기 | . | | . 앞으로 공부하는 방법 . 많이풀기 삼성은 DFS, BFS 30문제정도 | 카카오는 Trie를 포함해서 30문제정도 | | 암기하기 이해로는 X 많이 쓰면서 암기하는 과정이 필요하다. | 자기만의 템플릿이 있어야 한다. | | 주기적 체크하기 대회? | 안내서 노션 | |",
            "url": "blog.chojaeseong.com/algorithm/2021/10/17/sktacademy_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_python_%EB%AC%B8%EB%B2%95TIP.html",
            "relUrl": "/algorithm/2021/10/17/sktacademy_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_python_%EB%AC%B8%EB%B2%95TIP.html",
            "date": " • Oct 17, 2021"
        }
        
    
  
    
        ,"post81": {
            "title": "협업1) 나혼자 투컴으로 협업",
            "content": "나혼자 투컴협업(local to remote to local2) . Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . local to remote . 이미 로컬에서 관리하던 프로젝트를 github로 . local에서 작업시작 . 폴더 생성: . /home/is2js/workspace/git-github . | git init . | 계정입력(이미 global로 했으면 안해도됨) . | 파일 생성 . cat | mouse | . | 커밋 . ❯ git add -A ❯ git commit -m &quot;FIRST COMMIT&quot; . | . | 혹시나 연결된 원격레포가 있는지 확인 . git remote 아무것도 안뜨면 없는 것 | . | . | 깃헙 레포 생성(git-github) for 로컬을 원격으로 . readmd 등 생성하지 말아야함! 이미 local에서 git으로 관리하고 있던 프로젝트를 올리는 것이므로 아무것도 없어야함. | 아무것도 코드가 없을 때 나타나는 화면이 나와야함 | 구성 : https://github.com/is2js/git-github.git githuburl + /유저명/레포명.git | . | . | . | git status로 현재까지의 상황이 다 커밋되어있는지 확인한다. . ❯ git status On branch master nothing to commit, working tree clean . 빠진게 있으면 전부 add -A해서 commit | . | 로컬내용을 빈 원격레포에: git remote 등록 git push 내용옮기기 . 원격레포에 코드가 없을 경우 뜨는 페이지에서 …or push an existing repository from the command line 란을 복사버튼을 눌러서 . 현존하는 로컬 깃관리 레포를, 원격레포에 push하도록 복사한 내용을 cli에 붙혀넣기 해준다. . 현재는 코드가 main브랜치를 만들고, main 브랜치로 push하도록 변경되어있다. . | 복붙후 내 로컬도 main브랜치로 바껴있다. . | 아예 master브랜치 -&gt; main브랜치로 브랜치이름변경하는 명령어 인가보다. . git branch -M main . With a -m or -M option, will be renamed to | . &gt; git branch * main (END) . | . &gt; git remote add origin https://github.com/is2js/git-github.git git branch -M main git push -u origin main Counting objects: 4, done. Delta compression using up to 12 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (4/4), 273 bytes | 273.00 KiB/s, done. Total 4 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-github.git * [new branch] main -&gt; main Branch &#39;main&#39; set up to track remote branch &#39;main&#39; from &#39;origin&#39;. . | 이 때, 명령어를 뜯어보면 . git remote add origin https://github.com/is2js/git-github.git . git remote add [원격레포의 별칭, default origin] [레포 url]로서 원격레포url의 원격레포를 별칭(origin)으로 등록 | . | git branch -M main . 브랜치명을 main으로 변경 | . | git push -u origin main . git push -u [등록된 원격레포별칭, default origin] [올릴 원격레포의 branch] | . | 이후 나오는 메세지 중 현재 main브랜치가 , 원격레포인 origin의 원격 브랜치main을 추적한다.고 메세지가 뜬다. . Branch &#39;main&#39; set up to track remote branch &#39;main&#39; from &#39;origin&#39;. . | . | git remote명령어로 실제로 연결이 잘되었는지 확인 . ❯ git remote origin . | . | 빈 원격레포에, 관리되던 로컬 프로젝트 내용이 올라갔다면, 레포의 기본페이지가 바뀐다. . 커밋내용은 로컬에서 커밋한 기록들이 다 뜬다. | . | 소스트리에서 해보기 . 소스트리로 해당 레포 열기 | 저장소탭 &gt; 원격 설정 클릭 현재 나는 이미 터미널로 연결된 상태라, 원격 저정소 경로에 하나가 추가 되어있다. | . | 추가 클릭 원격 이름: 원격url의 원격레포에 대한 별칭, default origin | URL/경로: 원격레포의 url 복붙 | 호스트 종류: github | 사용자명: github id 입력 | . | 원격 탭에서 원격레포의 별칭(주로 origin)으로 확인하기 . | push버튼 클릭 로컬 / 원격(리모트) 브랜치를 각각 선택해주고 push해주자. | . | 파일추가(수정) 후 commit까지 한 뒤 push: git push [원격레포별칭] [그 레포의 브랜치] . dog파일 추가 . | git add - A, git commit -m , git push [원격레포별칭, 주로origin] [그 레포의 브랜치] . ❯ git add -A ❯ git commit -m &quot;ADD dog&quot; [main 15a73f6] ADD dog 1 file changed, 1 insertion(+) create mode 100644 dog ❯ git push origin main Counting objects: 3, done. Delta compression using up to 12 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 302 bytes | 302.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-github.git d33f3a8..15a73f6 main -&gt; main . | 올릴필요가 없거나(코드로 자동생성) 올려선 안되는 파일(DB계정 등)처리: .gitignore . 올릴 필요가 없는 파일 : 코드로 자동 빌드되는 파일들 그 때 그 때 실행해서 만들면 되므로 올릴 필요가 없다. 안드로이드나 스프링 등에서 처음부터 골격이 세팅된 체 시작하는 프로젝트들을 생성하면 .gitignore가 미리 만들어져있다!! | . | . | .gitignore에 등록하면 add + commit의 대상으로 안봄. 버전관리 안됨. | . | . 프로젝트폴더 최상위 공간안에 .gitignore파일 생성 . 숨김파일로 지정되니 참고해야함 | . | gitignore에 넣을 파일 secret-animal을 만들고, git status로 상황을 확인하자. . Untracked files(add해야할 목록)로서 아직 add안된 파일 2개를 알려준다. . Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) .gitignore secret-animal . | . | 이 상태에서 secret-animal 파일을 .gitignore에 적으면, git status상 add해야하는 파일에서 제외된다. . 아하~ 아예 add할 파일로조차 보지도 않음. | 내 프로젝트에 있어도 add + commit을 안하므로 push도 관리도 안됨. | . Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) .gitignore . | remote to com1,2 . 원격repo를 현재폴더에다가 가져오기: git clone [url] . . 1개 컴으로 연습하려면, 폴더 2개를 만들어서 해보면 된다. . . 일단 폴더 2개를 만든다 computer-1 | computer-2 | . | 참고) clone시 해당목적지 폴더로이동 &gt; git clone [url] [.] | 소스트리는 해당 목적지폴더 선택만 | . | . | . 컴퓨터1의 폴더를 vscode로 연 다음, 터미널도 켠다. . 윈도우탐색기 &gt; wt -d . &gt; code . &gt; ctrl + ~ + wsl로 repoen? 윈도우 통해서 들어가면.. vscode wsl원격버전이 안켜진다. | . | wt &gt; wsl &gt; 해당폴더로 이동 &gt; code . | . | 기존 작업하던 원격레포(git-github)의 url를 복사한 뒤, vscode 폴더 터미널에다가 git clone한다. . #git clone [url] [.] git clone https://github.com/is2js/git-github.git . . 만약, clone시 [.] 현재폴더 옵션을 안주면, 그 내부에 폴더를 새롭게 만들어버림 . 새로운 컴퓨터의 로컬폴더 컴퓨터-1에다가 원격repogit-github의 내용을 가져왔다. | . | . | 연결된 나의 원격repo가 아니라 아무 원격repo를 클론해오더라도 git log로 모든 작업내역을 볼 수 있다. . git log . | 이제 소스트리로 컴퓨터-2 로컬폴더로 clone해보자. . + (new) tab &gt; Clone &gt; . 소스경로/URL : 원격레포url | 목적지 경로: computer-2폴더 지정 git clone 시에는 [원격레포url] [.] 현재폴더로의 옵션을 붙혀줘야하지만, 소스트리에서는 안해주고 폴더만 선택해주면, 그 폴더로 다 clone | . | . . | 이제 컴퓨터-2도 vscode로 열자. . | . | 새로올린(뒤쳐진) 커밋 내역 자동 확인: git fetch + git status . 컴1작업 -&gt; 원격레포에 push -&gt; 컴-2에서 일일히 작업내역을 확인하지 않고, git fetch로 뒤쳐진 내역이 있는지 확인 컴퓨터1 | 컴퓨터2 | . | . 컴1에서 dog name을 수정하고, add, commit호 원격레포에 push까지 해보자. . local의 global계정이 내 계정이라서 그런가 바로 push된다. . ❯ git add -A ❯ git commit -m &quot;EDIT dog&quot; [main 1eaa722] EDIT dog 1 file changed, 1 insertion(+), 1 deletion(-) ❯ git push origin main . . | . | 이제 컴2에서 일일히 github에 새로 올라운 커밋내역을 확인하기 힘드니 git fetch로 뒤쳐진==새로올라온 커밋의 갯수를 확인한다. . ❯ git fetch ❯ git status On branch main Your branch is behind &#39;origin/main&#39; by 1 commit, and can be fast-forwarded. (use &quot;git pull&quot; to update your local branch) nothing to commit, working tree clean . 원격레포/main 브랜치에비해, 내 브랜치가 1개 커밋 뒤쳐져있다고 나온다. | . | 뒤쳐진 내용 받아오기: git pull [원격별칭] [브랜치명] . 컴2에서 뒤쳐진 1개의 커밋을 받아온다. . &gt; git pull origin main From https://github.com/is2js/git-github * branch main -&gt; FETCH_HEAD Updating 15a73f6..1eaa722 Fast-forward dog | 2 +- 1 file changed, 1 insertion(+), 1 deletion(- . . | 소스트리에서도 git pull을 하기위해 . 컴2에서 dog 이름 수정 . | 소스트리 컴2에서 커밋과 동시에 push . . | 소스트리에서 컴1 폴더를 add . | 컴1폴더에서 패치버튼 선택 &gt; 모든 원격저장소에서 가져오기 선택 . . | main 브랜치에 당겨올 것들이 있다고 메세지가 뜸 . | pull버튼으로 받아오기 . | . | 일단 작업전에 메세지 안떠도 pull부터 누르고 시작하자 . 나혼자 투컴협업 branch, conflict . 브랜치를 이용해서 투컴협업 . 브랜치 전환, 없으면 생성해서 : git checkout -b [브랜치명] . branch기본 생성 : git branch [이름] | 전환 : git checkout [이름] | . | 브랜치 생성과 동시에 전환 git checkout -b [이름] checkout은 커밋id, 브랜치, tag 다되므로.. -b옵션을 주면 브랜치전환인데, 없으면 생성까지 | . | . | . 컴1에서 my-idea 브랜치 생성 . git checkout -b my-idea . . git branch . | my-idea이라는 평행우주에서 파일을 수정하고 add commit까지 한 뒤 push할 준비를 해자. . mouse 삭제 . | dinosaur 추가 . ❯ git add -A ❯ git commit -m &quot;ADD dino&quot; [my-idea e43a292] ADD dino 2 files changed, 1 insertion(+), 1 deletion(-) create mode 100644 dinosaur delete mode 100644 mouse . | . | 새로운 브랜치(평행우주)를 push: git push [origin] [새로운 origin의 브랜치명] . my-idea 브랜치를 -&gt; origin의 특정브랜치로 생성해서 push할 수 있다. 하지만 보통은 원격레포에 로컬과 같은 브랜치명으로 생성해서 올린다. | . | . 컴1의 my-idea브랜치와 동일한 이름으로 원격레포의 브랜치를 생성해서 push까지 해보자. . ❯ git push origin my-idea Counting objects: 3, done. Delta compression using up to 12 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 304 bytes | 304.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) remote: remote: Create a pull request for &#39;my-idea&#39; on GitHub by visiting: remote: https://github.com/is2js/git-github/pull/new/my-idea remote: To https://github.com/is2js/git-github.git * [new branch] my-idea -&gt; my-idea . **new branch로서 [로컬my-idea] -&gt; [원격my-idea]으로 push했다고 나온다. ** 즉, 로컬의 평행우주를 push한다고 해서 1:1대응 되는 것이 아니라 원격의 원하는 이름의 평행우주를 만들어서 push하는 구나. | . | . | 원격레포에서 새로운 브랜치(평행우주)가 생성되었고, push도 되었으니 PR를 고려해보라고 메세지가 뜬다. . . my) PR는 push된 임의의, 새로운 평행우주를 기본branch로 합치겠습니까? 정도이다. | 브랜치를 바꿔서 들어가보면, **새로운 평행우주가 로컬-컴1의 my-idea그대로 ** 펼쳐진다. | . | 원격레포의 새로운브랜치를 받는 방법은 [브랜치 생성&amp;전환명령어] 응용: git fetch -&gt; git branch -a -&gt; git checkout -b [생성할 로컬 브랜치(결국엔 뒤에 기입한 원격브랜치를 받아올 브랜치)] [origin(별칭)/pull해올 원격 브랜치명] . git checkout -b [생성할브랜치(결국엔 뒤에 기입한 원격브랜치를 받아올 로컬 브랜치)] [origin(별칭)/pull해올 원격브랜치명] 브랜치 생성&amp;전환 명령어로 원격레포브랜치를 pull까지 해버린다. | git checkout -b : 생성과 동시에 전환 | [생성할 로컬 브랜치(결국엔 뒤에 기입한 원격브랜치를 받아올 로컬 브랜치)] : 아직 원격이 새 평행우주(branch)가 없는 로컬에서, 받아줄 브랜치(평행우주)를 지정한다. | [origin/pull해올 원격브랜치명] : 원격레포 속 받고 싶은 평행우주 | . | 컴2에서 원격레포의 새로운브랜치(평행우주)를 받아보자. 굳이 main에 합쳐진 것이 아니어도 받아서 사용해도 된다. | . | . 컴2에서 로컬용 git branch에 -a옵션까지 더해서 원격 브랜치도 확인한다 . git branch -a * main remotes/origin/HEAD -&gt; origin/main remotes/origin/main . 원격branch는 github의 소식을 업데이트를 해줘야한다 | . git fetch git branch -a * main remotes/origin/HEAD -&gt; origin/main remotes/origin/main remotes/origin/my-idea . 원격레포의 (HEAD, default 작업장소)가 보는 곳은 아니지만 밑에 새로운 평행우주가 추가되었음 | . | 원격레포의 새로운 평행우주(my-idea)를 컴2의 my-dea로 받아와 보자. . 브랜치 생성&amp;전환명령어로 원격레포브랜치를 pull까지 해버린다. | . #git checkout -b [로컬브랜치명] [origin/원격브랜치명] ❯ git checkout -b my-idea origin/my-idea Branch &#39;my-idea&#39; set up to track remote branch &#39;my-idea&#39; from &#39;origin&#39;. Switched to a new branch &#39;my-idea&#39; . git branch로 확인해보자. . main * my-idea . | . | 소스트리로 컴2:new브랜치생성 to 원격 to 컴1으로 넘겨보기 . 이번엔 소스트리로 컴-2에서 브랜치를 생성후 원격레포에 생성과 동시에 PUSH . 브랜치 탭 &gt; 새 브랜치 : my-another-idea . | cat이름을 nyang으로 변경 . | 커밋과 동시에 origin푸쉬 by 소스트리 . . 만약 소스트리가 아니라면? . ❯ git add -A ❯ git commit -m &quot;EDIT cat name&quot; ❯ git push origin my-another-idea . push origin은 없으면 해당 브랜치 생성해서 push한다. | . | . | 깃허브에서 branch 생성 확인 . . | . | 컴-1의 소스트리에서 컴2-new브랜치(my-anther-idea)받아보기 . **컴1의 소스트리 &gt; 원격 탭 클릭 &gt; 원격의 새 브랜치 더블클릭 &gt; 새 브랜치로 체크아웃 ** . . | **원격 브랜치의 체크아웃만으로 로컬의 새브랜치를 생성 및 가져온다. ** . 따로 pull의 과정이 없는 것이 cli 든 소스트리든 마찬가지다 | . | . | my) 새 브랜치는 pull이 아닌 [checkout -b]만으로 로컬에 새 브랜치를 생성 및 내용을 가져온다. . 로컬 컴1-main에 브랜치들 merge(자동커밋)후 push -&gt; 컴2에서 fetch로 확인후 받아오기 . 컴1에서 브랜치병합후 원격레포에 push해보자. | . main(master)로 이동(받는놈) . | 주는놈인 my-another-idea 우클릭 &gt; 병합하기 . 현재 브랜치로 (주는놈) 병합 | . | push할 커밋수 확인해보기 . 병합전: main옆에 1은 push할 커밋수다. . . | 병합(자동커밋!)후: main2로 push할 커밋 1개 늘어남. . | . | 병합된 내역(커밋)까지 컴1 -&gt; 원격 레포에 소스트리로 push . push버튼 &gt; 병합된 내역 push | . | 이제 컴2의 소스트리에서 fetch로 원격상황 받아오기 . main브랜치에 pull받을 것들이 있다고 업데이트된다. . . | main으로 이동후 pull받아오기 . | . | ### . 충돌해결로 협업 . 한쪽에서 파일1을 수정해서 push했는데 . 다른쪽에서 파일1을 pull받지 않은 상태로 수정후 로컬커밋한 상태 . . | 다른쪽에서 pull받아야하는데, 같은파일이 수정된체 커밋된 상태면, conflict . . | . | . 직접 충돌내보기 . 컴1에서 dog파일 수정, 커밋, push . 한쪽 수정(bark: wang wang)이 push한 상태 . ❯ git add -A ❯ git commit -m &quot;EDIT dog bark wang&quot; ❯ git push . | . | 컴2에서 pull 받지도 않은 체 dog파일 수정후 커밋 . 다른 쪽이 pull안한체로 수정후 커밋한 상태 . ❯ git add -A ❯ git commit -m &quot;EDIT dog bark warl&quot; . ❯ git push To https://github.com/is2js/git-github.git ! [rejected] main -&gt; main (fetch first) error: failed to push some refs to &#39;https://github.com/is2js/git-github.git&#39; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., &#39;git pull ...&#39;) before pushing again. hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details. . pull할게 있으면 push가 안된다. | . | . | push가 안되면 . 원격에 누가 새 작업을 올렸구나. pull부터 받자라고 생각 . ❯ git pull . | . | pull받았는데 conflict나면 . 저쪽에서 같은 파일 수정했구나 ㅠㅠ라고 생각 . | git status로 더 자세한 상황을 보자. . ❯ git status #... both modified: dog #...저쪽과 나 모두 dog파일을 수정했네.. . | vscode에서 처리하기 . HEAD : 내가 작성한 부분 . | ===아래부분 : 저쪽이 작성한 부분 . . | . | . | conflict 후에는 git commit 을 -m 없이 커밋하여, 충돌 메세지를 그대로 저장하도록 한다. . git add -A git commit . git push해서 수정본을 원격레포로 보낸다. | . git push . | 브랜치삭제, 원격브랜치삭제: git branch -d vs git push -d [origin] [원격브랜치] . git branch 목록보기 . git branch -a . | 로컬 삭제 &amp; 원격 삭제 . 로컬 : git branch -d [브랜치명] | 원격 : git push -d origin [브랜치명] | . ❯ git branch -d my-idea Deleted branch my-idea (was e43a292). ❯ git push -d origin my-idea To https://github.com/is2js/git-github.git - [deleted] my-idea . | 소스트리로 충돌만들고 해결해보기 . 충돌일으키기 : pull받기 전, 같은 파일 수정후 로컬 커밋 push하면 충돌 발생 | 소스트리는 커밋과 동시에 push하므로 커밋당시에 발생 | . | 서로 다른브랜치(평행우주)라도 같은파일 수정상태면 conflict남 | . pull받기전에, 저쪽에서 수정한 파일을, 나도 수정한 뒤 소스트리로 커밋&amp;push를 눌러본다. 커밋은 성공했다고 따로 메세지 뜸. | . | push시 에러 -&gt; pull받자 -&gt; conflict뜨면? -&gt; 같은파일수정했네 pull을 했더니 소스트리에서 conflict를 알려준다. | . | **파일상태 탭으로 가보면, ** 충돌파일은 아직 add되지 않은 unstaged된 파일로서 존재 | 충돌파일 클릭시 충돌내용이 vscode처럼 나옴 | 충돌 커밋메세지는 자동 작성되어있음 cli라면 git commit만 하란 소리 | . | . | 직접 에디터(vscode)로 가서 수정해줘야한다. | 다시 소스트리로 와서 add후 커밋&amp;push | my) push에러 -&gt; pull받자 -&gt; conflict -&gt; 같은파일 수정했네. .",
            "url": "blog.chojaeseong.com/git/2021/10/16/%EA%B9%833_%EB%82%98%ED%98%BC%EC%9E%90%ED%88%AC%EC%BB%B4%ED%98%91%EC%97%85_branch_conflict.html",
            "relUrl": "/git/2021/10/16/%EA%B9%833_%EB%82%98%ED%98%BC%EC%9E%90%ED%88%AC%EC%BB%B4%ED%98%91%EC%97%85_branch_conflict.html",
            "date": " • Oct 16, 2021"
        }
        
    
  
    
        ,"post82": {
            "title": "심화) vscode로 git 심화 학습",
            "content": "Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . 깃 기본 with vscode . extension 2개 설치 . git extension pack | git extension pack 검색후 설치 | gitlens와 gitignore가 동시에 설치되어진다. | 왼쪽메뉴에 소스제어 를 클릭하면, gitlens가 통합되서 나온다. | 설정 &gt; git enable이 활성화 되어있는지 확인한다. . | gitlens layout 수정 . gitlens를 왼쪽메뉴에 따로 보이게 되었는데, 설명서를 읽으니 gitlens.setViewsLayout 검색 &gt; default로 클릭해야 source control탭에서 통합해서 볼 수 있다. | . | _git history는 팔레트에서 git log를 검색해서 사용 | . markdown all in one | markdown all in one검색 후 설치 . gitignore (팔레트커맨드) . add전에 설치된 gitignore를 사용하기 위해서ctrl+shift+p(모든 명령어, 팔레트)에서 gitignore를 검색하여, add ignore를 클릭 이후 python 을 검색해서 선택 -&gt; 파이썬을 제외시키는게 아니라 python관련 불필요 파일들이 등록이 된다. | create .gitignore가 생성되었다고 뜬다. | . | 소스제어에서, gitignore도 뜨는데, [파일열기]버튼이 따로 있다. . | python프로젝트를 선택하더라도 .vscode/폴더를 맨끝에 추가해준다. . .vscode로 달아도 되지만, 폴더라서 마지막에 슬래쉬도 넣어준다. | . . | . add remote(팔레트커맨드) . 빈repo를 생성 . readme파일만 체크해서 생성( 첨부터 push안되게 충돌내기 위함. ) | . | &gt; add remote 후 repo 선택 . 주의 [remote name]: origin으로 기본적으로 설정한다!!! . | 참고) add remote를 2개 했다면? git remote + remove [remote name] . | . | git config --list로 연결된 원격레포의 주소 확인하기 . | add, commit, and push in commits . U 파일들에서, +버튼을 눌러 add시키면, staging된 변경사항으로 이동한다. . | commit은 상단의 [소스제어]에서 체크버튼으로 staging된 변경사항을 한번에 다 commit시킨다. . | [commits] 탭 push를 클릭했다. . 해당 repo에서 push내역을 확인 | . . | . pull(명령어) 및 이질적인 프로젝트 병합 허용(–allow-unrelated-histories) . git pull origin main . 현재 remote가 빈 레포가 아니므로, push가 바로 안됨 . readme.md가 있기 때문에 pull당겨와서 충돌해결하고 해야함. . fatal: refusing to merge unrelated histories . | 이건 뭔짓을 하더라도 안됨. 따로 설정하면서 pull을 해줘야한다. . | . | . git pull origin main --allow-unrelated-histories . push . 갑자기 commits탭에서 사라져서.. 그냥 . vscode 작업표시줄을 클릭하여 push . | F1(팔레트)열고 git push검색해서 push . 해도 됨 . | . . | . [개념] branch (실무 많이) . main은 항상 deploy상태로 유지 | topic branch = 수정용 브랜치 = push해서 PR하는 브랜치 push를 자주해서 날라가는 것을 방지하자. | 검토후 merged(PR)후에 바로 삭제하는 브랜치 | . | develop branch는 삭제안한다. | main브랜치는 항상 최신으로 유지하므로 각 기능별 브랜치는 main에서 딴다. | [실습] branch(명령어) . . from-br없이 브랜치를 따면, 현재 브랜치에서 따는 것이므로 git branch명령어를 확인하고 따자. git branch new-br from-br | git branch git branch new-br | . | . | -로 직전브랜치를 checkout할 수 있다. . | checkout -b [new-br] [from-br]로 생성하면서 동시에 브랜치를 변경하게 되므로 가장 자주 쓴다. . git branch testbr main git branch * main testbr git checkout testbr Switched to branch &#39;testbr&#39; git branch main * testbr git checkout - Switched to branch &#39;main&#39; Your branch is up to date with &#39;origin/main&#39;. git branch * main testbr git checkout -b work main Switched to a new branch &#39;work&#39; git branch main testbr * work . | . git merge 와 fastforwad . 그림 출저 | . . merge commit은 서로 다른 상태의 브랜치를 병합해서 새로운 commit을 만드는 경우이고 . fast forward는 동일 내용이 포함되는 브랜치일 경우 브랜치 이동만으로 병합해서 따로 commit을 생성하지 않는 경우입니다. . | . topic branch(작업용브랜치) main에 merge후 삭제: git merge –no-ff / git branch -d . 현재 브런치 목록 . main testbr * work remotes/origin/main . | . work를 토픽브랜치라 가정하고 파일 work.py생성 후 커밋 . | main으로 돌아오면 당연히 파일이 없음. . | main에서 merge했다는 커밋을 남기면서(--no-ff) work브랜치를 받아오자. . 파일의 변화가 차이밖에 없는 경우. HEAD만 이동시키는 merge는 커밋이 발생안하고 앞으로 이동만 -&gt; fast forward가 발생하는데, 여기서는 직접 merge 메세지도 남긴다. | . ❯ git merge --no-ff work . | merge의 log확인을 git history라는 익스텐션으로 해보자. . 나는 git graph라는 익스텐션도 보인다. . . git history . | git graph . . | git log –oneline –graph 의 명령어 . . | . | . | merge확인후 topic branch삭제 . ❯ git branch -d work Deleted branch work (was cbf2765). . | git 탭에서 브랜치 변경후 개별커밋들 확인 . . 해당브랜치 화살표누르면 switch (checkout 됨) . | 왼쪽 화살표를 누르면, 각 브랜치마다 커밋 목록이 보인다. . 브랜치 생성이전 main브랜치 커밋이 그대로 보이는 듯함. | . . | testbr에서만 파일 생성후 커밋해보자. . testbr이 위로 올라왔다. branch 생성이후부터 달라진 커밋 차이가 난다. | . | . | [중요] topic branch에서 [다른topic이 merge된 main] 의 파일 1개만 받아오고 싶다면: git checkout -p . testbr에서 main속 work.py를 가져오고 싶다면 . git checkout -p [가져올브랜치명] [가져올파일명]을 이용한다. wsl2에서 안되서 windows 상태에서 하니깐 됬음. | . | . | . ​ 1. git checkout -p main work + y 로 main브랜치의 work.py를 가지고 온다. . ❯ git checkout -p main work.py diff --git b/work.py a/work.py new file mode 100644 index 0000000..e69de29 (1/1) Apply addition to index and worktree [y,n,q,a,d,?]? y . 현재 상태를 보면 add까진 된체 로 온다. add전후 살펴보는 git status로 봐도, 이미 Add는 되어있다. | . | work.py에 내용을 조금 넣어주고 commit하자. | 직전 commit의 메시지 변경: git commit –amend . git commit --amend를 치면, 직전 commit에 대한 메세지 수정사항이 editor 로 열린다. | git commit --amend . 메세지를 저장하면 자동으로 반영되어진다. . | 참고 . 마지막 커밋A에 일부만 빠졌다? 3을 빼고 1,2만 add 및 커밋한 상태 | 3을 git add한 뒤 git commit --amend | . | 그냥 커밋메세지만 변경 git commit --amend -m &quot;메세지&quot; | . | . | HEAD포함 n번째[에] commit 합치기or삭제 등 commit history 조절: git rebase -i HEAD~[숫자] -&gt; fixup or squash . HEAD~ = HEAD~1 HEAD포함 HEAD1개 전 ~1 = HEAD^ : 헤드의 부모, 헤드의 1개전 | . | . | rebase는 명령어로 하는게 더 빠르고 쉽다. | . . commit 1개당 1개의 의미를 가져야하나, 의미가 없는 커밋들을 하나로 합칠 때 , git rebase -i HEAD~ + [합칠 커밋갯수] 이후에 fixup: (귀찮아서) HEAD포함 n번째커밋에 커밋합치면서 n번째 커밋명으로 커밋합침 | squash: (새로운커밋명을 위해) HEAD포함 n번째커밋에 커밋합치면서 + 새로운 커밋명으로 합침 | 그외 reword(= amend), drop 등: 사용안한다. | . | . 커밋을 1111,222,3333333,4444,55555 5개를 새로 만들자 . | git rebase -i HEAD~[head포함 합칠 커밋갯수 &amp; head에서 뒤로 2칸 간 곳에서 합쳐짐.]을 커맨드로 입력한다. . ❯ git rebase -i HEAD~2 . . 여기서 커밋메시지 같은 git-rebase-todo 메세지에서 pick대신 fixup을 적어서 뭉개자. 최근커밋인 5555(HEAD)를 fixup으로 뭉개서 저장시키면 된다. | . | . 따로 뭔가 뜨지 않으면 .git &gt; rebase-merge &gt; git-rebase-todo를 클릭한다. . | 도착지(HEAD포함 n번째 커밋)는 선택지가 없다. . 최근 것이며 뭉개지는 HEAD는 선택지가 있다. . 여기서 fixup을 선택하면, 귀찮게 새로운 커밋메세지를 작성안하고 n번째 커밋명을 이용하게 된다. . . | start rebase를 해서 커밋을 합친다. . | . | . | 이제 444 -&gt;333으로 . git rebase -i . . 최근 것(아래 것)을 pick to squash로 변경해보자. . 과거커밋으로 합치는데 커밋메세지는 새로작성한다는 것이다. . . | 맨 위에 커밋메세지를 적으면 적용된다. . | . | 이미해버린 commit 취소는 직전HEAD로 돌아가면서 취소: git reset –hard HEAD~ . reset은 해당커밋까지가면서 자연스럽게 삭제한다. | . head의 부모로 가면서, head는 삭제 . ❯ git reset --hard HEAD~HEAD is now at 3460720 Merge branch &#39;testbr&#39; of https://github.com/is2js/git-ssac into testbr . . | add(staging) 취소는 아직commit안됬으므로 commit전 HEAD로 돌아가면서 취소: - or git reset HEAD . git extension으로 는 그냥 -버튼을 누르면 add가 취소됨 . | 명령어로는 git reset HEAD로서 . --hard없이 code를 살린체 최근HEAD로 돌아가면 -&gt; add취소가 자동으로 | . . git reset HEAD # HEAD 대문자여야함. . . | . 깃 심화1 with vscode . ### . git tag는 release의 의미를 가지므로 main에서 딴다. tag 혼자 = 커밋의 합 = 강의 n화 | 협업 = topic -&gt; main에서 merge후에 main에서 배포버전으로서 tag를 딴다. | . | . | . merge는 항상 명령어로 –no-ff를 붙여 커밋을 남기자 . --no-ff를 붙이면 fastfoward = 커밋없이 head위치만 바꾸는 것을 안하고 항상 merge커밋을 남긴다. conflict나면, Accept incoming후 git commit만 입력해주면 메세지 완성되어있음. | . | . main브랜치로 넘어가기 . | 명령어로 merge하기 . ❯ git merge --no-ff testbr Merge made by the &#39;recursive&#39; strategy. hello.py | 3 +++ testbr.py | 0 work.py | 1 + 3 files changed, 4 insertions(+) create mode 100644 testbr.py . | merge후 topic branch는 삭제: git branch -d . merge가 되었다면, topic 브랜치 삭제하기!! . git branch -d testbr Deleted branch testbr (was 74296bb). . 만약, fully merge가 안되었다고 뜨면? 대문자 -D로 강제 삭제해준다. . git branch -D testbr . | . | tag 확인 및 생성 in main브랜치:git tag [v0.0.1] . tag는 release될 main브랜치에서 작성한다. | tag는 release단위 = 배포단위로 생성한다. | tag는 소스코드를 push를 해놓은 상태에서 -&gt; tag를 local에서 따고 -&gt;tag를 push한다. | . ❯ git tag ❯ git tag v0.0.1 ❯ git tag v0.0.1 (END) . tag는 commit과 별개로 따로 push: git push origin [tag(=버전)] . git push origin [태그명=버전명] . ❯ git push origin v0.0.1 Total 0 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-ssac.git * [new tag] v0.0.1 -&gt; v0.0.1 . | git repo에, tag가 생긴 것을 우측사이드에서 확인가능 . | code수정 후 commit-&gt;push 끝난 뒤, 따로 tag 따고 -&gt; push . 파일(코드) 수정 . | local git commit . | local -&gt; origin(원격레포)로 push . ❯ git add -A ❯ git commit -m &quot;askldjflkasd&quot; ❯ git push . | commit의 push가 끝난 뒤, tag를 딴다. . ❯ git tag v0.0.2 ❯ git push origin v0.0.2 Total 0 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-ssac.git * [new tag] v0.0.2 -&gt; v0.0.2 . | tag는 과감하게 돌아가기: git reset –hard [태그] . git reset --hard [commit_hash]를 하면 해당 커밋까지 돌아가면서 자연스럽게 그 이후의 내용들은 삭제되었다. 하지만, 태그의 경우, code + commit은 돌아가나 tag는 삭제안되고 남아있다. | . | . ❯ git reset --hard v0.0.1 HEAD is now at bd4c018 Merge branch &#39;testbr&#39; into main ❯ git tag v0.0.1 v0.0.2 . 되돌아가도 tag는 남아있으니 직접 삭제해줘야한다. | . reset tag이후에도 local+remote tag 따로 삭제: git tag -d 태그 / git push origin -d 태그 . 로컬 tag를 삭제한다. . git tag -d v0.0.2 Deleted tag &#39;v0.0.2&#39; (was 476f70b) . | 원격에 남아있는 tag도 삭제한다. . git push origin -d v0.0.2 To https://github.com/is3js/py.git - [deleted] v0.0.2 . | 깃 심화2 with 개념위주 . 실수로 다른브랜치에 커밋or코드의존성때문에 다른사람 커밋이 필요할 때: git cherry-pick 으로 특정커밋만 똑! 가져올 때 . . 코드의존성 . 다른사람 커밋 위에서 일해야하는 경우 ex&gt; 다른사람이 버그고침 -&gt; 나는 그위에서 일을 해야할 때 | . | . | master branch의 cccccccc커밋만 -&gt; my branch로 . 커밋해쉬 앞 7글자 . git cherry-pick ccccccc . . | . | . git reset 총정리(add취소, commit취소) . ADD취소 2가지 . 옵션을 안주면 mixed | . . | 커밋취소 3가지 . HEAD뒤에 눈웃음 한개 ^ --soft : commit만 취소 + add + 내용물 그대로 | (mixed) : commt취소 + add취소 + 내용물만 그대로(unstaged) | --hard : commit취소 + add취소 + 내용물취소 | . | . . | . HEAD와 ^, ~숫자 . HEAD: 로컬 workingDir의 현재 작업중인 커밋 switch하면 작업폴더, 작업하는곳도 바뀌니 head도 바뀐다. | add만 했다면? 커밋이 아직 아니므로 HEAD가 보고 있진 않다. | . | HEAD^: 현재작업중 커밋의 부모커밋 ^^ : 부모의부모 | ~3 : ^^^쓰지말고, 3단계 전 커밋 | . | . 다시git reset HEAD 살펴보기with 돌아가서 자연스럽게 취소 . add 취소 . 커밋이 아니므로, HEAD는 아직 안보고 있다. . | 그래서 git reset HEAD를 하게 되면, HEAD커밋을 삭제하는게 아니라 git reset [여기] = [여기]로 돌아가겠다 = 해당커밋이후로 add는 커밋은 필요없다. 자연스럽게 add를 취소 . . | . | 커밋취소 . git reset HEAD^ 현재의 부모커밋으로 가고 싶다. . | 를 통해서 현재커밋을 취소 . . | . | 작업중에 다른작업요청시 commit도 reset도 애매한 임시저장: git stash . 로그인 브랜치에서 작업중인데, 갑자기 로그아웃 브랜치를 수정해달라고함. . 브랜치를 정리해야지만 브랜치변경이 가능함. 커밋한다음 reset을 해도되긴하겠지만,,, | . | 커밋하기엔 미완성, 작업물을 날릴순 없다. 임시저장으로 정리 | . | 현재 어느정도는 add된 상태 . unstage된 = add되지 않는 파일도 있음. . . | add, unstage 다 합쳐서 사진을 스태시! 하고 찍는다. . git stash . . 커밋이후의 상황들 전체가 stash 바구니에 담기게 됨. . . | . | 바구니에 담기면 사라진다. . | . | git stash pop을 통해 stash바구니에서 꺼내면 다시 적용된다. . . stack처럼 pop으로 나온다. | . | git stash, git stash pop 이외에 git stash list도 있다. . | . 마지막 커밋 변경(내용추가, 메세지변경): git commit –amend . . 마지막 커밋A에 일부만 빠졌다? 3을 빼고 1,2만 add 및 커밋한 상태 | 3을 git add한 뒤 git commit --amend | . | 그냥 커밋메세지만 변경 git commit --amend -m &quot;메세지&quot; | . | . merge말고 1줄로 합치는데, 상대주는놈branch 위에 올려서 합칠 때:git rebase . 내 브랜치들을 주는놈branch 위에서 적용시키고 싶을 때 . 최근브랜치가 내꺼가 되면서, 내가 주는놈 위에 적용됨. | . . . | 주의할점으로, 주는놈위에 쌓아올려질 때, 그대로 가는게 아니라 커밋해쉬가 달라짐 . | . merge vs rebase . . merge와 비교 장점: 커밋해쉬 유지 및 흐름 유지되어 돌아갈 수 있음 | 단점: merge라는 불필요커밋을 생성함. | . | rebase 장점: 주는놈위에 받는놈위주로 정리가 됨. 깨끗한 커밋 히스토리가 됨. | . | . 커밋 합침, 삭제 등 커밋 히스토리 조절: git rebase -i . . pull받은이후 rebase로 커밋해쉬가 바뀌었다면? 어쩔수 없이 git push –force . . remote branch2개를 잘 받아왔다. . | 이후 git rebase(주는놈위에 쌓아서 합침)로 내 커밋해쉬가 바뀌었다면? . . 이 상태에서 git push하면 reject된다. | . | 어쩔수 없이 git push --force로 덮어씌워야함. . | 협업중엔 조심해야한다. . 남자가 rebase후 푸쉬포스로 덮어씌워진다면,, . . | 같은 브랜치 협업중에는 미리 말안하는 이상 rebase 및 push force를 하면 안될듯 . | . | . alias . git push까지 . status diff add cache? commit log | . | git폴더에 . . | 내 환경설정에 . | 참고 . 히데쿠마 설정 . ## alias # git alias gst=&#39;git status&#39; alias gc=&#39;git commit&#39; alias gm=&#39;git merge&#39; alias gr=&#39;git reset&#39; alias ga=&#39;git add&#39; alias gaa=&#39;git add --all&#39; alias gloga=&#39;git log --oneline --decorate --color --graph --all&#39; alias glog=&#39;git log --oneline --decorate --color --graph&#39; alias gco=&#39;git checkout&#39; alias gb=&#39;git branch&#39; alias gcb=&#39;git branch | fzf -m | xargs git checkout&#39; alias gmb=&#39;git branch | fzf -m | xargs git merge&#39; alias gdb=&#39;git branch | fzf -m | xargs git branch -D&#39; alias gp=&#39;git push&#39; alias gf=&#39;git fetch&#39; alias gl=&#39;git pull&#39; alias gd=&#39;git diff&#39; alias ghf=&#39;git ls-files -v | grep &quot;^h&quot; | cut -c3-&#39; # dkr alias dkr=&#39;docker&#39; alias dkrp=&#39;docker-compose&#39; # for docker #sudo mount --bind /mnt/c /c sudo mount --bind /mnt/d /d export DOCKER_HOST=tcp://0.0.0.0:2375 # basic alias dotfiles=&#39;cd ~/dotfiles&#39; alias ll=&#39;ls -al&#39; alias l=&#39;clear &amp;&amp; ls -al&#39; #alias cdd=&#39;cd /d/&#39; alias ws=&#39;cd /d/workspace&#39; #alias solup=&#39;cd /d/workspace/solup&#39; alias echost=&#39;cd /d/workspace/solup/echost&#39; alias 12r=&#39;cd /d/workspace/solup/12r&#39; alias private=&#39;cd /d/workspace/private&#39; alias ..=&#39;cd ..&#39; alias ..2=&#39;.. &amp;&amp; ..&#39; alias ..3=&#39;..2 &amp;&amp; ..&#39; # some more ls aliases #alias ll=&#39;ls -alF&#39; alias la=&#39;ls -A&#39; #alias l=&#39;ls -CF&#39; # Add an &quot;alert&quot; alias for long running commands. Use like so: # sleep 10; alert alias alert=&#39;notify-send --urgency=low -i &quot;$([ $? = 0 ] &amp;&amp; echo terminal || echo error)&quot; &quot;$(history|tail -n1|sed -e &#39; &#39;&#39;s/^ s*[0-9] + s*//;s/[;&amp;|] s*alert$//&#39; &#39;&#39;)&quot;&#39; # for python alias python=&#39;python3&#39; alias pip=&#39;pip3&#39; export WORKON_HOME=~/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=&#39;/usr/bin/python3&#39; # Usage of python3 source ~/.local/bin/virtualenvwrapper.sh # for pyenv export PYENV_ROOT=&quot;$HOME/.pyenv&quot; export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot; export PYTHON_CONFIGURE_OPTS=&quot;--enable-shared&quot; export PYENV_VIRTUALENV_DISABLE_PROMPT=1 if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then eval &quot;$(pyenv init -)&quot; eval &quot;$(pyenv virtualenv-init -)&quot; fi . | . | .",
            "url": "blog.chojaeseong.com/git/2021/10/15/%EA%B9%832_%EA%B9%83%EA%B8%B0%EB%B3%B8(vscode)_%EA%B9%83%EC%8B%AC%ED%99%941(vscode)_%EA%B9%83%EC%8B%AC%ED%99%942(%EA%B0%9C%EB%85%90).html",
            "relUrl": "/git/2021/10/15/%EA%B9%832_%EA%B9%83%EA%B8%B0%EB%B3%B8(vscode)_%EA%B9%83%EC%8B%AC%ED%99%941(vscode)_%EA%B9%83%EC%8B%AC%ED%99%942(%EA%B0%9C%EB%85%90).html",
            "date": " • Oct 15, 2021"
        }
        
    
  
    
        ,"post83": {
            "title": "기본) commit&tag/revert&reset/branch",
            "content": "타인repo를 clone후 commit, tag 코드 옮겨다니기 . 실습레포: /home/is2js/workspace/git-test | Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . commit_hash or tag로 점프: git checkout [hash or tag] . 환경변수를 파악하고 code . . | vscode로 리조지토리 초기화 . | vscode push 버튼으로 올리기 . . | git fetch는 해두는 게 좋다 . 내 repo에 누가 작업을 추가했는지 파악만 해주는 것 | . | 강의별로 commit을 한다면? . 커밋별로 tag를 추가로 만들어준다. . | 예를 들어 . 5화 작업 . 5화 커밋 git tag 5 | . | . | 6화 작업 . 6화 커밋 git tag 6 | . | . | push by vscode push버튼 . . | . | . | git checkout [git_id]으로 5화 이전의 4화로 점프띄어보자. . 4화 부분의 git id 복사 . | 해당 폴더의 vscode 터미널에서 git checkout [git_id] . git checkout fefc0cacbf262ae0794e64a632afa2da095b622a . 이때 brunch자체가 [git_id]로 변하면서 과거로 돌아간다 | . | 현재로 돌아오려면, 기존 branch(master)로 checkout한다 . git checkout master . | . | git checkout [tag명]으로 점프띄어보자 . 각 커밋마다 커밋후 쉬운 이름표인 tag를 만들어준다. . 아까 5화 작업 끝나고, git tag 5 . 5화 끝난후의 소스를 보고 싶을 땐 이렇게 이동한다 . #git checkout [tag명] git checkout 5 . . | . | . | 다 참조가 끝났다면, 다시 최근소스의 branch로 오면된다. . git checkout master . | . | tag는 대신 따로 push를 해줘야한다. . 커밋들을 push한거로는 tag까지 push가 안됨. | . git push --tags . 버튼으로는 잘 안보이고 팔레트 &gt; push 검색 &gt; git push tags를 선택해준다. . | 참고) . 맨첨 커밋에는 0.0.0의 tag를 만들어주고 . | 그 이후로는 1.0.0부터 쭉 만들면된다. . . | . | . | . 내 repo 돌아가기, 되돌리기 . 기본 세팅 . /home/is2js/workspace/git-practice | . 소스트리 설치 . vscode에서는 설정(ctrl+,)에서 exclude 검색후 .git을 삭제하여 보이게 하기 | . | 디렉토리에서 vscode열기 . vscode 터미널 열여서 git설정 저장하기 . git config --global user.name &quot;is2js&quot; git config --global user.name &quot;tingstyle1@gmail.com&quot; . | . | .git폴더를 삭제후 소스트리에서 해보기 . create를 통해 해당폴더를 선택해서 만들어준다. 이미 폴더가 있는데 이 내부에 .git생성할까 물어보면 OK | . | . | 2개의 파일을 만들고 이 상태를 저장하기 . cat | mouse | . | git status(gst)를 통해 아직 untracked 파일들 확인 후 add . git add -A . git status . | 메세지(-m)와 함께 묻기(commit 해주기) git commit -m &quot;First commit&quot; . | 묻은 것을 소스트리에서 확인해보기 . 터미널에서 히스토리 확인하기 git log --oneline . | 소스트리는 git status없이 묻을 파일을 자동으로 알려준다. . vscode도 extensiont쪽에 알려줌? | dog라는 파일을 만들고 소스트리에서 확인해서 add + 커밋까지해보자. | . | . | 파일 삭제 + 변경 + 생성을 한꺼번에 한 뒤 git status로 보자. 삭제+변경과 생성을 따로따로 알려주며 다 알려주긴 한다. | 소스트리도 아이콘으로 알려준다. | . | git log로 이때까지 묻은 캡슐들을 한꺼번에 볼 수 있음. 소스트리에서는 History탭에서 보면 된다. . . | 과감한 돌아가기: git reset [commit_hash] –hard . . 돌아갈때는 과감한방법과 신중한방법이 있다. . 과감한방법(--hard) : 복원이후시점은 완전히 지우겠다. . git log상의 commit_id 앞6글자만 복사후 . | git reset [commit_id] --hard . . | . | 다시 한번 cat삭제 + dog이름변경 + 펭귄추가를 해주고 commit한뒤 소스트리로 reset –hard해보자. . 이 커밋까지 현재브린치를 초기화 | Hard(버림) 선택 | . | . | 신중한방법(--soft): 시점만 돌아가고 + 그 이후는 커밋되지 않은 상태로 파일은 유지 . | . (반대동작으로 취소시켜, 돌아갈 미래를 남긴체) 되돌리기 : git revert . **[reset으로 돌아갈 수 있는 미래]를 남겨두기 위해, [반대동작으로 취소시켜] 되돌리기 ** . | 다시 3번째 커밋까지 만들어준다. | 이번에는 돌아갈시점 6자리 for reset이 아닌 취소할 시점 6자리 for revert를 git log에서 찾는다. 취소할 커밋을 revert(취소)했다는 커밋이 그대로 이어서 남는다. 소스트리를 통해 확인하면, 정확히 취소할 커밋이, 커밋시 수행한 동작을 정확히 반대로 수행하여 취소함. | 취소할커밋이 커밋기록으로 남아있으니, reset --hard(이 커밋까지 현재브런치를 초기화)을 통한 해당 커밋으로 과감하게 돌아갈 수도 있다. | . | . | **즉, [reset으로 돌아갈 수 있는 미래]를 남겨두는 [반대동작으로 취소시켜] 되돌리기 ** | . 가장 최근 것을 revert로 취소시켜보자. . git log . 제일 최근시점을 취소시키기 위해, 최근 커밋(현재커밋) 6글자 복붙 | . | git revert [취소시점6자리] + :wq . 커밋메세지 작성화면으로 들어온다. | 여기선 :wq로 나와야 해당 revert 커밋메세지가 전달된다. | . | 3번째 커밋이 취소된 것을 파일이 reset처럼 과거상태로 돌아감을 보면 알 수 있다. . | git log를 확인해보니, 돌아간시점이후로 가 삭제된 것(reset –hard, 과감한 돌아가기)가 아니라 새 커밋이 형성되었다. . 소스트리에서 보아도 3번째 커밋을 상쇄시키는 커밋이 추가로 발생함 | . . 자세히 보면, 소스트리를 통해 확인하면, 정확히 취소할 커밋이, 커밋시 수행한 동작을 정확히 반대로 수행하여 취소함 3번째 커밋(취소할 커밋) 때 한 동작들 | 4번째 커밋인 3번째 커밋을 취소함(revert)를 할때의 동작들 | . | . | revert를 통해 취소할커밋도 reset-hard와 다르게 기록으로 남아있으니 reset을 통해 취소하기 전의 3번째 커밋상태로 과감하게 돌아갈 수도 있다. . . | 소스트리를 통한 revert는 커밋 되돌리기다. . 역시.. (반대동작으로 취소시켜) 되돌리기 = revert . 커밋 되돌리기 == 반대동작을 통해 해당 커밋을 취소시킴 . . | . | . | 내repo branch(평행우주) 만들기 for 기존플젝에 새로운 도전 . 회사 프로젝트를 내가 함부로 수정할 수 없으니 현재 프로젝트에서 다른 시도를 해보고 싶을 때, branch를 만들어 평행우주로 넘어간다. | . | . 평행우주로 이동도:git checkout [브랜] or 더블클릭 in 소스트리 . 브랜치 생성 . 브랜치 : 현 시점에서 2개의 미래로 분기를 시작하겠다. 현 시점과 동일한 상태 그대로 가져가면서 분기함. | . | . #git branch [만들 브랜치명] git branch my-idea . . 확인은 git branch만 . . | . | 브랜치 이동도 git checkout . 과거로 점프갔다오기 : git checkout [commit_id or tag] . 과거로 돌아가기 : git reset –hard or git revert [commit_id] | . | 과거가 아닌 현재-&gt;다른평행우주(branch)로 이동도 git checkout + 브랜치명 . #git checktout [브랜치명]git checktout my-idea . . branch변경해도, 내 파일상태에는 변함이 없음. 현재 상태를 그대로 가지고 평행우주를 만들어서 | . | . | 데이터 변경 후 커밋하기 in my-idea브랜치 . mouse 삭제, dinosaur 추가 . 용이름 둘리 | . | 현 branch에서 커밋하기 . git add -Agit commit -m &quot;Add dino&quot; . . | . | 상사가 부를 땐, 원래 우주로 돌아간다. . 원래 브랜치는 master였다. . 이동 전 . | 이동 후 (파일이 원래대로 돌아옴) . git checkout master . . | . | git을 처음 배울때는 파일이 잘못될까바 불안해서 사용안할 수도 있는데, 앞으로 계속 사용해보자~ . | . | 소스트리에서 다시 해보자. 더블클릭으로도 우주를 왔다갔다 하며 확인할 수 있다. . 브랜치 부분에 my-idea가 추가됨. 여기서 각 브랜치를 더블클릭할 때마다, vscode의 파일도 같이 바뀌더라. | . | 브랜치에서 새 브랜치 따기 . my-idea로 checkout된 상태에서, 상단의 브랜치탭에서 새로 생성해보자. . 이 때, 새 브랜치로 체크아웃을 체크해주면, 자동으로 새 브랜치로 넘어가진 상태가 된다. | . . my-idea에서 파생된 브랜치라 그 상태를 그대로 가져갔다. | . | 브랜치의 브랜치 상태에서, 데이터를 변경후 커밋까지 . cat 이름을 변경:tom to nyang | . . | 연결된 3개의 평행우주에서 상황맞이 . 상사가 master의 내용을 바꾸길 원함. . . 요구 대로 바꿔고, commit한다. . git add -Agit commit -m &quot;EDIT dog name&quot; . . | . | 평행우주에서, 타 브랜치의 base가 되는 branch(여기선 maser)가 한발(commit) 나서게 되면, 분기된 branch가 나눠서 그려진다. . . | 다른 우주(의지를 이은 가장 바깥가지 브랜치)에서 변화 가져오기: [ 받을놈branch이동후] git merge [줄놈branch] . 현재 메인프로젝트 master의 변경내용과는 서로다른 평행우주끼리 다른파일 수정이라면, 브랜치의 브랜치라도 편하게 master로 merge되는 것을 권유할 수 있다. . 아래 내용을 상사에게 권해본다. . my-idea에서 mouse삭제 후 dino 추가했고 | my-idea - my-another-idea에서 cat이름을 변경했는데 이것들을 메인프로젝트에 적용해도될까요? Okay 승인 | . | . . | 2개의 평행우주에서 일어난 일을 master브랜치로 가져야가한다. . 이 때, 브랜치1의 브랜치2는 생성부터 브랜치1의 변화를 그대로 가져와서 생성되므로 브랜치2만 반영시키면 된다. . . | . | . | merge를 위해서는 . 먼저 받는놈 브랜치(master)로 이동(checkout)한 상태여야한다. . git merge [줄놈 브랜치명] | . git checkout mastergit merge my-another-idea . . | 변화를 보니 master의 상사지시 + 평행우주에서 한 것들이 모두 반영되어있다. . master에서의 dog name to 바꾼 것도 반영되어이있지만 | my-another-idea에서의 쥐삭제+용추가 한 것도 동시에 반영된 상태다. | . | . | 확인은 . 소스트리 | vscode git graph가 아니라면 | git log --graph --all --decorate로 확인하란다 git log --graph --oneline정도면 충분할듯? | . | . | reset –hard로 merge전으로 돌아간 후, 소스트리로 merge하기 . 소스트리로 실습하기 위해 merge전으로 돌아가보자. | . merge 직전의 받는놈 브랜치의 가장 마지막 커밋 == merge전 커밋으로 . git reset –hard . | 소스트리: 이 커밋까지 현재 브랜치를 초기화 . . | . | 소스트리로 merge하려면 더 간단한데 받는놈의 branch를 더블클릭해서 이동 | 주는놈 branch를 우클릭 &gt; 현재 브랜치(받는놈 더블클릭 상태)로 my-another-idea(주는놈, 우클리상태) 병합 | . | 나중에는.. 수많은 폴더와 파일을 다뤄야하기 때문에, 기존프로젝트에 새 도전을 하려면 반드시 git branch써야함. | . | 아름답지 않은 merge + conflict후에는 메세지없이 git commit . 원래 merge가 성공하면 git이 자동 add + commit까지 한다. | . bark-wang브랜치 생성후, dog 파일 수정 -&gt; commit . ❯ git branch bark-wang❯ git checkout bark-wangSwitched to branch &#39;bark-wang&#39;❯ git add -A❯ git commit -m &quot;EDIT dog file&quot; . . | 이제 받는놈인 master로 돌아와서 같은 dog파일 수정하자. . ❯ git checkout masterSwitched to branch &#39;master&#39;❯ git add -A❯ git commit -m &quot;EDIT dog file bar warlwarl&quot; . master가 한발짝 나가는 순간부터 분기가 갈라져 보인다. | . | 현재, master 와 bark-wang이 서로 같은 파일을 수정한 상태다. . 아까의 merge는 서로 다른파일이 수정된 상태라 merge가 쉽게 되었다. . | 한번 merge해보자 . ❯ git checkout masterAlready on &#39;master&#39;❯ git merge bark-wangAuto-merging dogCONFLICT (content): Merge conflict in dogAutomatic merge failed; fix conflicts and then commit the result. . . | . | merge시 conflict가 뜨는데 같은 파일을 여러 평행우주에서 수정했기 때문이다. conflic가 없었을 때의 merge는? merge를 자동으로 커밋까지 해주는 커밋메세지 확인이 떴었다. | . | terminal에 안내문이 뜬다 | 소스트리에서는 그래프가 회색으로 연결안되어있으면서 &quot;커밋하지 않은 변경사항&quot;의 상태로 뜬다. | vscode에서는 conflict된 부분을 나눠서 알려준다. | | conflict는 vscode에서 택1해서 지울건 지운 뒤, add후 git commit을 -m 없는 상태로 커밋을 날리면 자동으로 merge 메세지가 뜬다. . accept incoming ~ in vscode | . git add -Agit commit . . conflic후 commit은 메세지없이 git commit만 날리며 알아서 merge 메세지가 미리 작성되어있다. . . | . | 앞으로 다른 브랜치끼리는 같은파일을 수정안하도록 작업하면 merge가 편안해진다. | 다른우주도 1줄로 만들어 통합: git rebase(재배치) . 프로젝트의 성격에 따라 필요한 것을 선택해서 사용하면 된다. . . | 지금은 git log상 2갈래 정도만 나오지만 . 실제로는 엄청나게 많은 줄기가 생기게 된다. . . | . | 딱 1줄로 통합되도록 merge하는 방법이 git rebase다 . 소스트리상으로는 master(받는놈)에서 주는놈(bark-warl) 우클릭 &gt; 재배치(rebase)를 클릭한다. . . | 같은 파일을 건들인 상황이니 똑같이 conflict해결후 add+commit한다. . | 재배치가 끝나면 분기가1 줄로 나타난다. . 브랜치라도 합쳐지는 모양이 아니다. | . . | . | . 다 쓴 브랜치 삭제: git branch -D . rebase는 1줄로 받는놈(masetr)에 통합되어버린다. . 그럼 작업한 branch(주는놈)은 더이상 필요 없을 것이다. . | 대문자로 -D옵션을 준다 | 소스트리는 우클릭으로 바로 할 수 있다. | . ❯ git branch -D bark-wang Deleted branch bark-wang (was 5fefbe0). . ​ . | merge를 통해 분기가 합쳐졌던 branch들도 git branch -D로 삭제하였더니 . 분기 표기는 남아있는데, branch만 사라졌다. | . . | .",
            "url": "blog.chojaeseong.com/git/2021/10/14/%EA%B9%831_%EC%BB%A4%EB%B0%8B%ED%83%9C%EA%B7%B8%EC%9D%B4%EB%8F%99_%EB%8F%8C%EC%95%84%EA%B0%80%EA%B8%B0%EB%90%98%EB%8F%8C%EB%A6%AC%EA%B8%B0_%EB%B8%8C%EB%9E%9C%EC%B9%98.html",
            "relUrl": "/git/2021/10/14/%EA%B9%831_%EC%BB%A4%EB%B0%8B%ED%83%9C%EA%B7%B8%EC%9D%B4%EB%8F%99_%EB%8F%8C%EC%95%84%EA%B0%80%EA%B8%B0%EB%90%98%EB%8F%8C%EB%A6%AC%EA%B8%B0_%EB%B8%8C%EB%9E%9C%EC%B9%98.html",
            "date": " • Oct 14, 2021"
        }
        
    
  
    
        ,"post84": {
            "title": "terminal -> choco -> wsl, pyenv",
            "content": "chocolately로 초기 설치 . 관리자권한 powershell . 초코랫리 겟스타트 -&gt; 인스톨 코드 복붙 | 경고떠도됨. 관리자권한으로 다시 껐다 키기 | . | find pakage에서 terminal 검색후 설치 . choco install microsoft-windows-terminal . | python 3 검색후 3.9 설치 . choco install python3 . | vscode 설치 . choco install vscode . | git 설치 . choco install git . git config –global user.name “2js” . git config –global user.email “1@gmail” . | wsl2 설치 -&gt; 재부팅후 한번 더 실행 (-y -f ??) . choco install wsl2 -y -f . 참고사이트 . | 참고) 정식 가이드로 설치시 해주는 다운로드전 설정 . dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart # WSL 활성화 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart # VM platform 활성화 . | . | 관리자 권한으로 윈도우 가상화해주기 for wsl2 . Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All . bcdedit /set hypervisorlaunchtype auto . | AMD CPU SVM mode 설정 in Bios for ubuntu 실행 . del 로 bios 진입 . | advanced 진입(F7) . | OC(Overclock) 진입 . | advanced cpu configuration 진입 . | SVM node: Enable . 우측상단 X로 저장후 종료하기 | . | . | wsl2용 ubuntu1804 설치 -&gt; ms store에서 설치(choco는 update안된 버전이라고함) . msstore 사용시 ms계정 요구함 ~@hanmail.net / ~54 | . | 설치 -&gt; 시작 | . | wsl명령어로 우분투 진입 default 계정 및 비번 설정 is2js / | ~213 | . | . | 항상 wsl접속으로 /mnt된 곳이 아니라 cd ~ (linux 홈폴더)를 한 상태에서 code ~/.zshrc 등의 설정을 하자. | Window Terminal 단축키 설정 . vscode와 비슷하게 추가 매핑해준다. . actions 부분에 추가해주면 된다. | . { &quot;command&quot;: &quot;find&quot;, // 검색키 매핑 // &quot;keys&quot;: &quot;ctrl+shift+f&quot;, &quot;keys&quot;: &quot;ctrl+shift+f&quot; }, // 수직분할 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;vertical&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+plus&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;vertical&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;ctrl+ &quot; }, // 수평분할 매핑(추가) //{ &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;horizontal&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+-&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;horizontal&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+0&quot; }, // 탭 끄기 매핑(추가) { &quot;command&quot;: &quot;closePane&quot;, &quot;keys&quot;: &quot;ctrl+w&quot; }, // 포커스key 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;down&quot; }, &quot;keys&quot;: &quot;alt+down&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;down&quot; }, &quot;keys&quot;: &quot;ctrl+alt+down&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;left&quot; }, &quot;keys&quot;: &quot;ctrl+alt+left&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;right&quot; }, &quot;keys&quot;: &quot;ctrl+alt+right&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;up&quot; }, &quot;keys&quot;: &quot;ctrl+alt+up&quot; }, // 창이동 단축키 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 0 }, &quot;keys&quot;: &quot;ctrl+alt+1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 0 }, &quot;keys&quot;: &quot;ctrl+1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 1 }, &quot;keys&quot;: &quot;ctrl+2&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 2 }, &quot;keys&quot;: &quot;ctrl+3&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 3 }, &quot;keys&quot;: &quot;ctrl+4&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 4 }, &quot;keys&quot;: &quot;ctrl+5&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 5 }, &quot;keys&quot;: &quot;ctrl+6&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 6 }, &quot;keys&quot;: &quot;ctrl+7&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 7 }, &quot;keys&quot;: &quot;ctrl+8&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 8 }, &quot;keys&quot;: &quot;ctrl+9&quot; }, // Rename a tab to &quot;Foo&quot; { &quot;command&quot;: { &quot;action&quot;: &quot;renameTab&quot;, &quot;title&quot;: &quot;server&quot; }, &quot;keys&quot;: &quot;f1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;renameTab&quot;, &quot;title&quot;: &quot;jupyter&quot; }, &quot;keys&quot;: &quot;f2&quot; }, . | . Window Terminal 및 wsl2 zsh 세팅 . 터미널에서 설정(ctrl+,) &gt; json파일열기 &gt; ubuntu이름을 wsl2로 바꾸고 . wsl2(ubuntu)의 guid를 복사해서 &gt; defaultProfile key에 넣어 기본 프로필로 설정 | . | Fira code설치후, WindowTerminal 및 vscode-editor + vscode terminal font 변경해주기 . 깃허브 &gt; zip파일 다운후 압축풀고 &gt; ttf 다 설치 . Terminal : 없던 defaults속 fontFace속성을 넣어서 폰트를 설정해준다. . | Vscode : font 검색후, 맨앞에 &quot;Fira code&quot; 추가 후 전체복사 . terminal font 검색 후 복붙 . “Fira code”, Consolas, ‘Courier New’, monospace . | . | . | . | zsh설치(zsh는 root로 설치) . sudo apt update &amp;&amp; upgrade . sudo apt install zsh . | oh my zsh(zsh) 설치 (ohmyzsh부터는 user로 설치?!) . github 들어가서 curl로 설치 명령어 날리기 . sh -c “$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)” . | . | ohmyzsh 플러그인 2개(자동완성, 하이라이팅) 설치 . zsh-syntax-highlighting . git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting . zsh-autosuggestions . git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions . .zshrc에 기입해주기 . code ~/.zshrc . plugin 검색 . plugins=(git) 에 공백으로 추가 해주기 . plugins=(git zsh-syntax-highlighting zsh-autosuggestions) . 나와서 . source ~/.zshrc . | . | p10k(ohmyzsh의 테마) 설치 . 깃허브 에서 ohmyzsh 클릭 후 ohmyzsh 하위폴더로 clone시켜주기 . git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k . | p10k를 zsh의 테마로 설정해주기 . code ~/.zshrc . theme검색후 ZSH_THEME=”robbyrussell”를 . ZSH_THEME=”powerlevel10k/powerlevel10k” . 로 변경 . source ~/.zshrc . | p10k configure 설정이 시작됨 . | . | ls -al 등이 파일명 배경색 직접 변경하기 . cd ~ . code ~/.zshrc . # change filname background color . LS_COLORS=”ow=01;36;40” &amp;&amp; export LS_COLORS . 위 내용 추가 . source ~/.zshrc . | Win-terminal 테마 생성 및 설정해주기 . terminalsplash.com에 들어가서 고른다. . VS code theme를 찾음. 아직 json내부에서 &quot;name&quot;이 없는 상태. | . | &quot;profiles&quot; 밑에 &quot;schemes&quot;에 **name을 추가해주면서 ** custom theme를 등록해야한다. . schemes 에 등록한 뒤, colorScheme로 사용된다 | . &quot;schemes&quot;: [ { &quot;name&quot; : &quot;VScode&quot;, &quot;background&quot; : &quot;#232323&quot;, &quot;black&quot; : &quot;#000000&quot;, &quot;blue&quot; : &quot;#579BD5&quot;, &quot;brightBlack&quot; : &quot;#797979&quot;, &quot;brightBlue&quot; : &quot;#9BDBFE&quot;, &quot;brightCyan&quot; : &quot;#2BC4E2&quot;, &quot;brightGreen&quot; : &quot;#1AD69C&quot;, &quot;brightPurple&quot; : &quot;#DF89DD&quot;, &quot;brightRed&quot; : &quot;#F6645D&quot;, &quot;brightWhite&quot; : &quot;#EAEAEA&quot;, &quot;brightYellow&quot; : &quot;#F6F353&quot;, &quot;cyan&quot; : &quot;#00B6D6&quot;, &quot;foreground&quot; : &quot;#D3D3D3&quot;, &quot;green&quot; : &quot;#3FC48A&quot;, &quot;purple&quot; : &quot;#CA5BC8&quot;, &quot;red&quot; : &quot;#D8473F&quot;, &quot;white&quot; : &quot;#EAEAEA&quot;, &quot;yellow&quot; : &quot;#D7BA7D&quot; }, ], . | wsl2(ubuntu)와 win-terminal or terminal 전에 colorScheme으로 지정해준다. . { &quot;guid&quot;: &quot;{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}&quot;, &quot;name&quot;: &quot;Wsl2&quot;, &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot;, &quot;colorScheme&quot; : &quot;VScode&quot;, }, { // Make changes here to the powershell.exe profile. &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;, &quot;name&quot;: &quot;Windows PowerShell&quot;, &quot;commandline&quot;: &quot;powershell.exe&quot;, &quot;hidden&quot;: false, &quot;colorScheme&quot; : &quot;VScode&quot;, }, . &quot;profiles&quot;: { &quot;defaults&quot;: { // Put settings here that you want to apply to all profiles. &quot;fontFace&quot; : &quot;Fira Code&quot;, &quot;colorScheme&quot; : &quot;VScode&quot;, }, . | . | wsl2 계정 및 폴더 설정 in win10 . 항상 특정유저로 wsl2 진입 . /etc/wsl.conf 없으면 생성 . sudo vi /etc/wsl.confg . [user] default=is2js . | . 윈도우 탐색기에 wsl2경로 네트워크로 만들기 . 윈도우( )탐색기 창에서는 wsl$ 로 우분투로 접속가능하다. config등 경로에서는 //wsl$의 슬래쉬로 사용된다. | 참고) 윈도우탐색기상 wt -d .을 통해, 현재경로에서 윈도우 터미널 열기 | . | . wsl 쉘 킨 상태로 연결유지 | 탐색기 &gt; 내PC 우클릭 &gt; 네트워크 위치 추가 사용자 지정 네트워크 위치 선택 | [인터넷 또는 네트워크주소] 부분에 wsl$입력후 찾아보기 | 원하는 경로선택하기 : 우분투/home/is2js/workspace/ | 원하는 이름 입력 : is2js_workspace | . | 여기서 들어간 뒤 wt -d .로 윈도우 터미널(wsl)을 열면 될듯? | wsl2 ubuntu 기본설정 . 루트 계정 비밀번호 초기화참고 블로그 | 유저계정을 root 화시키기 참고 블로그 usermod -aG sudo [계정명]으로만 주기 | . | . openssl 설치 . sudo apt install openssl . | root의 기본 비밀번호 초기화 . sudo passwd root . # : 관리자 | $ : 일반유저 | . | 유저계정에 root권한부여 (파일3개 수정) . root계정으로 권한설정파일에 유저계정-&gt; root권한부여 . su . vi /etc/sudoers . 아래 root쪽에 내 계정도 추가하기 . # User privilege specification root ALL=(ALL:ALL) ALL is2js ALL=(ALL:ALL) ALL . | . wq! (readonly떠서 강제로 저장후 종료) . | root계정으로 비밀번호설정파일에 유저계정-&gt; root권한부여 . root항목처럼, root:x:0:0:root:/~f로 시작하는 부분에서 앞쪽0 : uid | 뒤쪽0: gid 관리자라면 둘다 0임. | 나는 뒤쪽 그룹id만 0으로줌. | . | . | . vi /etc/passwd . wq! . #is2js:x:1002?:1002?:,,,:/home/is2js:/usr/bin/zsh is2js:x:1002?:0:,,,:/home/is2js:/usr/bin/zsh . | root계정으로 그룹설정파일에 유저계정-&gt; root권한부여 . root가 대장인 0그룹에 추가를 해주면됨 . vi /etc/group . wq! . #root:x:0: root:x:0:is2js . | . | zsh 권한 에러시 . sudo chown -R ${LOGNAME}:staff $HOME . | wsl2-ubuntu 시작계정 설정하기 . powershell 에서 . ubuntu[1804] config --default-user [is2js] . | . | wsl2-ubuntu 시작폴더 설정하기 in WindowTerminal . 터미널의 wsl프로필에다가 옵션을 추가해줌 . 출저 | . &quot;startingDirectory&quot;:&quot; wsl$ Ubuntu-[20.04] home [myskan]&quot; . &quot;guid&quot;: &quot;{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}&quot;, &quot;name&quot;: &quot;Wsl2&quot;, &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot;, &quot;colorScheme&quot; : &quot;VScode&quot;, &quot;startingDirectory&quot;:&quot; wsl$ Ubuntu-18.04 home is2js&quot;, . | 참고 . wsl$ : 탐색기에서 우분투 폴더라도 바로 가기 | . | . | windows 업데이트 이후 wsl error 발생할 때 . . 시작 메뉴에서 기능을 검색해서 Windows 기능 켜기/끄기에 들어가 아래 3개 항목을 선택해제 | 재부팅 | 다시 3개 항목 체크한 뒤 사용 | python-&gt;python3 매핑 . 참고블로그 | 더 좋은 블로그 | . Alternatives는 기본 커맨드의 심볼릭 링크를 관리해주는 리눅스 프로그램입니다. 데비안 계열의 리눅스(우분투)에서는 update-alternatives가 제공됩니다. . | 우분투(Ubuntu)를 설치하면 python path가 2.7로 설정되어 있습니다. . 리눅스의 Alternatives를 이용하면 python 버전을 쉽게 변경하고 관리할 수 있습니다. | . ❯ which python /usr/bin/python . python은 /usr/bin/python의 링크인데 | . ❯ ls -al /usr/bin/ | grep python lrwxrwxrwx 1 root root 9 Apr 16 2018 python -&gt; python2.7 lrwxrwxrwx 1 root root 16 Apr 16 2018 python-config -&gt; python2.7-config lrwxrwxrwx 1 root root 9 Apr 16 2018 python2 -&gt; python2.7 lrwxrwxrwx 1 root root 16 Apr 16 2018 python2-config -&gt; python2.7-config -rwxr-xr-x 1 root root 3633000 Feb 28 2021 python2.7 lrwxrwxrwx 1 root root 33 Feb 28 2021 python2.7-config -&gt; x86_64-linux-gnu-python2.7-config lrwxrwxrwx 1 root root 9 Oct 25 2018 python3 -&gt; python3.6 . ❯ ls -al /usr/bin/python lrwxrwxrwx 1 root root 9 Apr 16 2018 /usr/bin/python -&gt; python2.7 . /usr/bin/python 역시 실행파일이 아닌 /usr/bin/python2.7의 링크이다. . | **즉 ** . /usr/bin/python2.7 -&gt; /usr/bin/python -&gt; python | . | . | --config python로 python에 걸려있는 링크를 확인한다. . sudo update-alternatives --config python [sudo] password for is2js: update-alternatives: error: no alternatives for python . alternatives가 없다고 뜨면, 설정을 해줘야한다. | . | --install [symbolic link path(버전을 제외한 공통 경로)] python [real path(버전명시 경로)] [우선순위number]로 여러버전을 등록한다. . #sudo update-alternatives --install /usr/bin/python(버전제외 공통 경로) python(명령어=링크) /usr/bin/python3(버전명시 경로) 10(우선순위) . python2.7 등록 . sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 2 . | python3.6 등록 . 3.6 한개만 등록하고 해당 버전을 선택안해도 python -&gt; python3.6이 걸리도록 하면 된다. | . sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.6 1 . | . | (만약 2개이상 버전 등록했다면) 다시 한번 --config python으로 등록된 버전 확인 및 선택 . sudo update-alternatives --config python There are 2 choices for the alternative python (providing /usr/bin/python). Selection Path Priority Status * 0 /usr/bin/python2.7 2 auto mode 1 /usr/bin/python2.7 2 manual mode 2 /usr/bin/python3.6 1 manual mode Press &lt;enter&gt; to keep the current choice[*], or type selection number: 2 . | **버전을 선택해주면, python의 링크가 특정버전으로 옮겨져있다. ** . ❯ python -V Python 3.6.9 . | pip도 설정해준다. . 1개만 등록하면 pip -&gt; pip3가 될 것이다. | . ❯ sudo update-alternatives --config pip update-alternatives: error: no alternatives for pip . ❯ sudo update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 1 update-alternatives: using /usr/bin/pip3 to provide /usr/bin/pip (pip) in auto mode update-alternatives: warning: not replacing /usr/bin/pip with a lin . ❯ pip -V pip 9.0.1 from /usr/lib/python3/dist-packages (python 3.6) . | 1개만 alternative를 등록해서 python, pip를 default로 3버전으로 지정해주자. | . # pip3 install sudo apt-get update sudo apt-get install -y python3-pip pip3 --version # python3, pip3 alternatives command sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10 sudo update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 1 . python 가상환경 설정 . pip3 &amp; pyenv(격리된 python) 설치 . python3-pip 설치 . sudo apt update &amp;&amp; upgrade sudo apt install python3-pip pip3 -V pip3 --version . | pyenv 설치 . curl https://pyenv.run | bash . WARNING: seems you still have not added &#39;pyenv&#39; to the load path. # See the README for instructions on how to set up # your shell environment for Pyenv. # Load pyenv-virtualenv automatically by adding # the following to ~/.bashrc: eval &quot;$(pyenv virtualenv-init -)&quot; . clone한 pyenv디렉토리를 zshrc에 환경변수(PYENV_ROOT)로 직접지정해줘야한다. . cd ~ # wsl로 정상적으로 열릴려면, /mnt/상태에서 vscode를 열면 안된다. code ~/.zshrc . source ~/.zshrc . | pyenv사용전, 에러를 일으키는 미설치 패키지 다 설치하기 . sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev . | . | pyenv 사용법 . # 설치가능한 python list 확인하기 pyenv install --list # 원하는 python 버전 설치 pyenv install [파이썬버전] # 설치된 파이썬 버전 확인 pyenv versions # 가상환경 만들기 pyenv virtualenvs [파이썬버전] [가상환경명] # 가상환경 시작하기 pyenv activate [가상환경명] # 가상환경 끝내기 pyenv deactivate # 가상환경 목록 확인 pyenv virtualenvs # 가상환경 삭제하기 pyenv uninstall [가상환경명] ### 실사용 pyenv versions pyenv install 3.8.6 pyenv global 3.8.6 # 3.8.6을 pyenv 기본 python으로 지정 . python 저장위치 root -&gt; /root 가 홈폴더 유저의 경우 -&gt; /home/유저명이 홈폴더 | . | ~/.pyenv/ 라는 곳에 versions/폴더에 설치된다. github다. | . | virtualenvwrapper에서도 ~/.pyenv/versions/3.8에서 자동완성후 /3.8.6/bin/python을 이용한다. | . | . | virtualenv &amp; pyenv-virtualenvwrapper(격리된 python으로 가상환경 생성) 설치 . pip3로 virtualenv virtualenvwrapper 2개 패키지 설치 . pip install virtualenv virtualenvwrapper pip3 install virtualenv virtualenvwrapper #에러나므로 --upgrade까지 pip install --upgrade virtualenvwrapper pip3 install --upgrade virtualenvwrapper . | virtualenvwrapper 설정 . # virtualenv 설정 export WORKON_HOME=~/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python # /usr/bin/python3 . | pyenv-virtualenvwrapper 설치 . git clone https://github.com/pyenv/pyenv-virtualenvwrapper.git $(pyenv root)/plugins/pyenv-virtualenvwrapper . pyenv설정 추가 수정 . # pyenv clone후 경로 직접 지정 export PYENV_ROOT=&quot;$HOME/.pyenv&quot; export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot; if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then eval &quot;$(pyenv init -)&quot; fi pyenv virtualenvwrapper_lazy #에러나서 주석처리했다가 다시 풀어줌 . source ~/.zshrc . | virtualenv 추가 설정 . # virtualenv 설정 export WORKON_HOME=~/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python #source /usr/local/bin/virtualenvwrapper.sh source ~/.local/bin/virtualenvwrapper.sh . | . | 실사용 . pyenv install 3.8.6 pyenv versions #~/.pyenv/versions/ 에 격리된 파이썬들 버전명의 폴더에 설치됨. pyenv global 3.8.6 pyenv versions mkvirtualenv goglekaap which python #/home/is2js/.virtualenvs/goglekaap/bin/python deactivate workon # goglegkaap rmvirtualenv goglekaap # pyenv로 만든 python버전을 지정해서 가상환경 생성 mkvirtualenv -p ~/.pyenv/versions/3.8.6/bin/python goglekaap lsvirtualenv # workon이랑 동일한 듯. . # pyenv pyenv install [version] # Python 버전 설치 pyenv versions # 현재 설치된 Python 버전 목록 pyenv global [version] # 전역 Python 버전 변경 #virtualenv wrapper mkvirtualenv [project name] # 프로젝트를 위해 virtualenv 생성 workon [project name] # virtualenv 활성화 deactivate # virtualenv 비활성화 setvirtualenvproject # 현재 디렉토리를 프로젝트의 Home 디렉토리로 설정하기 rmvirtualenv [project name] # virtualenv 삭제 lsvirtualenv # virtualenv 목록 mkvirtualenv [가상환경이름] mkvirtualenv [-p ~/.pyenv/versions/3.8.6/bin/python] [tester(가상환경이름)] #가상환경이름으로 가상환경을 만들어준다. mkvirtualenv test -p [python-path]로 python 버전을 지정해 줄 수 있다. rmvirtualenv [ 가상환경이름] #해당 가상환경을 지운다. workon [가상환경이름] #해당 가상환경으로 진입한다. setvirtualenvproject # &lt;가상환경 진입상태 by workon&gt;에서 프로젝트 디렉토리로 이동 후, 해당 커맨드를 치면 디렉토리&lt;--&gt; 가상환경이 맵핑된다. 그러면 workon커맨드를 치는것 만으로 해당 디렉토리에 이동까지 시켜준다. 아주좋다. cdproject #setvirtualenvproject를 했을 경우, 현재 어디에 있든 해당 커맨드로 프로젝트 디렉토리에 이동이 가능하다. # 예를 들어, 아무폴더에서 workon [가상환경] -&gt; cdproject deactivate #가상환경에서 빠져나온다. . | 참고) path 관련 확인해보기 . python 설치(PATH) 확인 . linux에서는 python + tab, python3 + tab을 통해 깔린 버전을 간접적으로 파악 가능 python3로 자동완성된다면.. python3만 깔린 것 앞으로 모든 명령어 앞에 python+3 | . | . | python3 --help -m [모듈명] : mod로서, library모듈을 script로 실행시키는 옵션 pip, flask, venv 등에서 쓰임. 물론 패키지가 깔린상태여야함. | python3 -m venv [가상환경명] | . | -V : 버전확인 | -c &quot; python코드 &quot; : python코드를 바로 커맨드라인에서 실행함 | . | . win10 환경변수 path로 설치확인 . win+s 에서 환경 변수검색 &gt; 시스템 환경 변수 편집 . | 고급탭 &gt; 환경변수N &gt; 사용자 변수 or 시스템 변수 . 나는 초콜렛리로 설치하였더니 시스템 변수탭에 Path에 설치됨. C: Python39 Scripts : 스크립트 폴더를 더블클릭해서 가보기 | C: Python39 | . | | . | win10 or wsl2 python os모듈로 확인 . import os . | os.environ (dict) . os.environ.get(‘SHELL’) for wsl2 . os.environ.get(&#39;SHELL&#39;) &#39;/usr/bin/zsh&#39; . | . | python path로 실행가능한 python script만들기(앞에 python3 안달아도됨) . which python3 후 경로를 복사해놓는다. . /usr/bin/python3 | . | python 파일의 가장 위에 #! + python경로를 입력한 뒤, python 코드를 작성하면된다. . code calculate.py . #!/usr/bin/python3 def add(x,y): return x+y print(add(2,3)) . 결과물은 print만 되도록한다.(bash실행이라서?) | . | sudo chmod +x calculate.py . | 실행시 calculate.py가 아니라 ./calculate.py로 실행시킨다. . ./calculate.py | 에러 뜨면 sed -i &#39;s/ r$//&#39; calculate.py 실행후 다시 실행 | . | . | .",
            "url": "blog.chojaeseong.com/configuration/choco/windowsterminal/wsl/pyenv/2021/10/13/%EC%84%B8%ED%8C%851_%EC%9C%88%EB%8F%84%EC%9A%B0_choco_terminal_wsl2_python.html",
            "relUrl": "/configuration/choco/windowsterminal/wsl/pyenv/2021/10/13/%EC%84%B8%ED%8C%851_%EC%9C%88%EB%8F%84%EC%9A%B0_choco_terminal_wsl2_python.html",
            "date": " • Oct 13, 2021"
        }
        
    
  
    
        ,"post85": {
            "title": "vscode) python 실행용 tasks.json 기록",
            "content": "VScode . tasks.json . ctrl+shift+B로 python파일 빠르게 출력하기 함. . | 한번 눌러보고 설정&gt;템플릿생성&gt;Others&gt;기록 . | . { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;Project Label&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;python&quot;, &quot;args&quot;: [ &quot;${file}&quot; ], &quot;presentation&quot;: { &quot;reveal&quot;: &quot;always&quot;, &quot;panel&quot;: &quot;new&quot; }, &quot;options&quot;: { &quot;env&quot;: { &quot;PYTHONIOENCODING&quot;: &quot;UTF-8&quot; } }, &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true } } ] } .",
            "url": "blog.chojaeseong.com/configuration/2021/08/24/tasks.html",
            "relUrl": "/configuration/2021/08/24/tasks.html",
            "date": " • Aug 24, 2021"
        }
        
    
  
    
        ,"post86": {
            "title": "PT내용 기록.",
            "content": "스트레칭 . 양손꽉지 -&gt; 어깨내리고, 엄지세우고 -&gt; 턱을 위로 당기기 10초 | 양속 뒤로 꽉지 -&gt; 고개 아래로 잡아당기기 10초 | 고개회전+굴곡으로 대각선 아래보기 -&gt; 귀와 후두부사이를 4손가락으로 잡아서 아래로 당겨 승모근 늘이기 | 삼각근 늘려주기 코끼리코자세로 팔꿈치위쪽을 쭈욱 당긴 뒤 | 양쪽 어깨 내리고 | 다시 쭈욱 당기기 | . | 삼두근 늘이기 한손을 머리뒤로 넘기고 | 반대손으로 팔꿈치를 꾹 눌러 잠근다음 | 안쪽으로 쭉 당겨주기 | . | 꽉지끼고 허리 굴곡시켜주기 | 꽉지끼고 허리 측굴 시키기 꽉찌 위로 껴서 몸을 조금 측굴 후 | 엉덩이를 반대편으로 밀어서 완전히 측굴 | . | 허리 돌리기 양쪽방향 | . | 손목, 발목 돌리기 반대손으로 손목을 잡은 상태에서, 손목+발목 10, 반대10초 돌리기 | . | 상완전완 . 2 트라이셉스(케이블)푸쉬 다운 p.26 . . . 25:28분 . 가슴 . 가슴운동하는 이유 : 중력에 의해 앞으로 쏠리는 게 편하여 생기는 라운드솔뎌의 단축된 가슴을 펴준다. . 가슴단축을 펴준다. | 프레임이 커진다. 등운동과 같이해서 크게한다. | 푸쉬업보다 벤치프레스가 가동범위가 크다. | . | . 1-1덤벨(벤치) 프레스 p.83 . . . 1주차, 2~4kg 허리 아픈 환자는 벤치위에 양발을 올린 상태해서 하면 편하다 | . | . 준비 : 허리아치 + 어깨 내림 + 견갑골 양간 잡아주기 bar로 하듯이 잡은 상태로 팔을 편 상태가 시작. | . | 아령은 앞으로 넘어갈 때의 전완에 힘이 들어오는 선에서 | 수직선으로 내려갔다가 그대로 올려줌(모으는 느낌X) 속도는 빠르게 | . | 1-2덤벨 플라이 p.84 . . 가슴을 이완시켜 가슴 안쪽을 채워주는 운동 여성분들의 벌어진 가슴을 모음 | 남성분들은 가슴 볼륨감을 높혀줌 | . | . 허리아치 + 어깨 내림 + 견갑골 양간 잡아주기 | 팔꿈치는 수직으로 내려가고 손등은 땅바닥을 보는 방향으로 내려간다 약간 손목을 틀어주면서 해야하므로 좀 어려웠다. | . | 중력을 이용해서 내려가며 + 덤벨을 몸에서 최대한 멀리 다 피지말고 덤벨을 잡을 수 있게 약간만 전완이 굽어진 상태 | . | 어깨 . 가슴~팔을 중간 근육 | 등 운동할때도 포함되는 중간 근육 등, 가슴 근육을 눌려주는시 가운데서 버티는 역할 | . | . 1-3시티드 덤벨 프레스 p.41 . 덤벨프레스는 허리에 과부하가 가므로 반드시 앉아서(시티드) + 약간은 뒤로 기울인 상태로 등/엉덩이가 닿은 상태로 시행하자. | . . 엉덩이, 등을 딱 붙이고, 가슴 내밀고, 어깨 내린 상태에서 팔을 든 상태에서 시작. 허리통증이 없는 사람도 생기게 되니 주의 | . | 수직으로 내려오되, 이마가 아니라 정수리 라인까지 내려오게 한다. 옆에 거울 보면서 수직으로 해야 어깨로 드는 것. | . | 1-4사이드 래터럴 레이즈(사래레) p. 48 . . . 전면 삼각을 운동시키기 위해, 팔을 약간 내회전한 상태에서 시작한다. | . 대각선으로 올라간다. | 올라갔다가 바로 내려온다. 버티기X s | 대퇴, 둔부 . 2스쿼트 . . . 어깨보다 한발씩 더 벌린 상태로 발 앞꿈치로 땅바닥을 잡는다 생각하여 엉덩이를 뛰로 빼더라도 안넘어지도록 한다. | . | 약간 무릎을 바깥쪽으로 뺀 상태로 만들어 엉덩이에 자극을 주고 내려가면서 무릎은 더 바깥쪽으로 벌어져서 둔부가 자극되도록 해야한다 | 무릎이 앞으로 안나온다는 생각으로 엉덩이를 최대한 뒤로 빼면서 내려간다. | . | 허리 아픈 사람은 더 엉덩이로 보강해야해서 중요함. . | 10개 3~4세트 | . 하체 . 2런지 . . . 발을 골반너비 정도만(스쿼트는 어깨넓이) | 한쪽발을 뒤로 한뼘 | 반대발을 앞으로 그만큼 | 뒷발의 뒤꿈치를 확 올리면 앞으로 넘어간다 -&gt; 그만큼 앞으로 이동 | 중심잡기 힘들면 앞발만 바깥쪽으로 조금 회전시켜줌 | 앞무릎 고정상태에서 뒤꿈치 편상태로 뒷무릎만 내려갔다 올라온다. | 10개 3~4세트 . 복근, 기립근 . 크런치 . 팔꿉치가 앞으로 뻣어나간다고 생각하고 시행 | . 플랭크 . 발을 약간 벌려 앞으로 세우기 | 손의 위치랑 입이랑 위치 바꾸기 | 엉덩이는 계속 들고 있기 | 20초 2~3세트 | 슈퍼맨 운동 . 기립근을 직접적으로 키운다. . 대자로 뻗은 뒤 | 고개는 들지말고 팔과 다리를 들어서 1~2초간 버티고 돌아온다. |",
            "url": "blog.chojaeseong.com/pt/%EC%9A%B4%EB%8F%99/2021/08/23/PT.html",
            "relUrl": "/pt/%EC%9A%B4%EB%8F%99/2021/08/23/PT.html",
            "date": " • Aug 23, 2021"
        }
        
    
  
    
        ,"post87": {
            "title": "github index, badge 등 생성하여 꾸미기",
            "content": "참고사이트 . 참고 사이트 https://velog.io/@woo0_hooo/Github-github-profile-%EA%B0%84%EC%A7%80%EB%82%98%EA%B2%8C-%EA%BE%B8%EB%AF%B8%EA%B8%B0 | https://butter-shower.tistory.com/142 | https://velog.io/@colorful-stars/Github-%ED%94%84%EB%A1%9C%ED%95%84-%EA%BE%B8%EB%AF%B8%EA%B8%B0 | http://blog.cowkite.com/blog/2102241544/ | . | . github_id 이름으로 repo 생성 . github ID와 동일한 이름으로 repo만들기 + add Readme . local에 clone하여 환경 세팅하자. C:/jupyter_blog/ + is2js . . | . | capsule-render로 header/footer 작성 . typora에서 미리보기를 활용하여 header footer를 작성한다. . 각 옵션 목록 : https://github.com/kyechan99/capsule-render . | default(변경하면됨) . ![header](https://capsule-render.vercel.app/api?type=waving&amp;color=f6ebe1&amp;height=150&amp;section=header&amp;text=Data Engineer and KMD&amp;fontSize=50&amp;fontColor=152447&amp;desc=데이터 엔지니어를 꿈꾸는 한의사, 조재성입니다.&amp;descAlignY=80) ![footer](https://capsule-render.vercel.app/api?type=rect&amp;color=152447&amp;height=20&amp;section=footer) . . | . | sheilds.io로 기술 스택 badge작성 . shields.io를 통해 기술스택, 연락처 등의 스택아이콘 가져온다. . a태그 &gt; img태그 . | a태그는 링크주소를 / img는 badge를 여기를 통해서 편하게 가져온다. . 각 뱃지 목록 : https://github.com/alexandresanlim/Badges4-README.md-Profile | . &lt;p align=&quot;center&quot;&gt; &lt;a href=&quot;mailto:tingstyle1@gmail.com&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Gmail-d14836?style=flat-square&amp;logo=Gmail&amp;logoColor=white&amp;link=tingstyle1@gmail.com&quot;/&gt;&lt;/a&gt;&amp;nbsp &lt;a href=&quot;https://www.facebook.com/tingstyle1&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Facebook-1877F2?style=flat-square&amp;logo=facebook&amp;logoColor=white&quot;/&gt;&lt;/a&gt;&amp;nbsp &lt;a href=&quot;https://www.github.com/is2js&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/GitHub-100000?style=flat-square&amp;logo=github&amp;logoColor=white&quot;/&gt;&lt;/a&gt;&amp;nbsp &lt;/p&gt; . | . productive-box로 커밋시각 통계(gist) 노출(pinned)하기 . 참고 : http://blog.cowkite.com/blog/2102241544/ | . gist.github.com에 public으로 신규 public으로 바꾼 gist를 생성 . . | github토큰 생성 페이지로 가서 repo, gist를 포함한 scope를 설정한 뒤, 발급받은 토큰을 잘 챙겨둔다. . QQQghp_ysd0aOZbgsOJ3rOTAhj4QQQw4su6rrfPp1oc7WrQQQ . | productive-box repository를 fork한다. . 우측 상단의 Fork 버튼을 누르면 된다. . | fork 된 나의 repository의 Actions 탭에서 enabled 버튼을 눌러 Action을 활성화한다 . | .github/workflow/Schedule.yml . 파일을 수정하여 환경변수를 작성해준다 . uses: is2js/productive-box@master : 내github아이디로 바꿔준다? . maxam2017 -&gt; 내 아이디로 | . | GIST_ID: 사전 작업의 1번 step에서 생성된 gist의 id (gist URL은 gist.github.com//로 생성되기 때문에 주소창을 보면 된다.) 042e89789d6054e9b372e755e75f09f5 | . | TIMEZONE: 타임존을 적어준다. Asia/Seoul 형식으로 적어주면 된다. cf) cron : 분시일월주 cron예제 : https://ponyozzang.tistory.com/402 | . | . | . | . | 해당레포 &gt; Settings 탭 &gt; Secrets에 접속한 뒤 New repository secret 버튼을 클릭하여 환경변수를 설정해준다. . GH_TOKEN: 사전 작업의 2번 step에서 발급받은 토큰 . 토큰은 github &gt; secrets &gt; 환경변수에서 설정해주면, workflows.config.yaml을 그것을 이용한다. | . env: GH_TOKEN: $ . | . . | gist를 내 프로필 pinn에 고정시킨다. . | 내 블로그에 embed시킨다. . 아래 코드에서 gist주소만 복사해서 gist_id.js를 넣어주면 됨. | . | 깃허브 프로필 뱃지 얻기 . Github Developer program . https://developer.github.com/program/ 사이트에서 등록한다. . 2가지만 추가로 채워주면 된다. . | Highlights부분에 뱃지 생김 . . | . | 학생 PRO . 유효한 date를 포함하는, 학생증 찍어서 증명하는 부분이 생겨 나는 포기함. | . https://education.github.com 접속후 Student Developer Pack 클릭 . | Get pack &gt; Get Student benefits &gt; 아래쪽 학교인증 . github에 학교계정으로 email을 등록하고 와야한다. . . | . | 마지막에 plan을 Github Pro로 적어주면 된다. . | 증명서를 내라고한다. 나는.. 졸업해서 그냥 생략.. . | 북극곰 2020.02월 . 나는 우연히 그 때 만들어뒀나보다. | .",
            "url": "blog.chojaeseong.com/git/github/2021/08/19/github-profile.html",
            "relUrl": "/git/github/2021/08/19/github-profile.html",
            "date": " • Aug 19, 2021"
        }
        
    
  
    
        ,"post88": {
            "title": "윈도우 터미널 단축키 모음",
            "content": "단축키 . [ALT] + [SHIFT] + [+] : 가로 창 나누기 ![image-20210715145754288] | [ALT] + [SHIFT] + [-] : 세로 창 나누기 | [ALT] + [SHIFT] + [방향키] : 창 크기 조절 | [ALT] + [방향키] : 커서가 위치하는 창 전환 | [CTRL] + [L] : 클리어 | [CTRL] + [SHIFT] + [ W] : 창 닫기 | [ALT] + [SHIFT] + [D] : 쉘 복제 | [CTRL] + [+/-/마우스 휠] : 글자 크기 조절 | [CTRL] + [,] : 설정 | .",
            "url": "blog.chojaeseong.com/configuration/2021/08/18/WindowTerminal_shortcut.html",
            "relUrl": "/configuration/2021/08/18/WindowTerminal_shortcut.html",
            "date": " • Aug 18, 2021"
        }
        
    
  
    
        ,"post89": {
            "title": "알고리즘 문제 풀기용 array 연습 (python)",
            "content": "input array . 1&#52264;&#50896; list . 10 5 1 10 4 9 2 3 8 5 7 6 . a, b = map(int, input().split()) print(a, b) # 1개는 안된다. 튜플 언패킹시에만 따로 받아진다!! c = map(int, input().split()) print(c) . 10 5 &lt;map object at 0x000001F38F7937C0&gt; . arr = list( map(int, input().split()) ) arr . [1, 10, 4, 9, 2, 3, 8, 5, 7, 6] . 2&#52264;&#50896;(&#44396;&#48516;&#51088;O) . 9 0 0 0 1 1 1 -1 -1 -1 0 0 0 1 1 1 -1 -1 -1 0 0 0 1 1 1 -1 -1 -1 1 1 1 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 1 -1 0 1 -1 0 1 -1 0 -1 1 0 1 -1 0 1 -1 0 1 -1 1 0 -1 0 1 -1 . # - 행수만큼 list comp를 돌리고, # - 그 행의 내부요소들은 1줄을 split -&gt; map(int, ) -&gt; list 까지 만든다. N = int(input().strip()) # paper = [ for i in range(N)] paper = [ list(map(int, input().strip().split())) for i in range(N)] . paper . [[0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, -1, 0, 1, -1, 0, 1, -1], [0, -1, 1, 0, 1, -1, 0, 1, -1], [0, 1, -1, 1, 0, -1, 0, 1, -1]] . 2&#52264;&#50896; &#44396;&#48516;&#51088;X (&#49707;&#51088;&#47196; 1character&#50473;&#47564; &#52264;&#51648;) . 문자열(no split) -&gt; map(1글자를 1글자int로) -&gt; list(1글자들을 열로) | . 3 3 011 111 110 . list(&#39;1019&#39;) . [&#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;9&#39;] . list(map(int, &#39;1019&#39;)) . [1, 0, 1, 9] . # - split대신 list(&#39;문자열&#39;) -&gt; 1글자씩 list # - split대신 list( map(int, &#39;문자열&#39;)) -&gt; 숫자1개씩 list # -- map(int, &#39;문자열&#39;)은 문자열을 하나씩 쪼개받아서 int를씌운다. N, M = map(int, input().split()) # map은 튜플로 할당 받을 수 있다. but 1개 변수에 할당시는 맵객체다. # MIRO = [ for i in range(N) ] # 열은 갯수는 M대신 split이 아닌 문자열-&gt;map-&gt;list -&gt; list(map(())으로 쪼개서 받았다. MIRO = [ list(map(int, input())) for i in range(N) ] . MIRO . [[0, 1, 1], [1, 1, 1], [1, 1, 0]] . &#49440;&#50616; array . input으로 받아서 쪼개서 열을 만들지말고, 이번에는 직접 선언해보자. | numpy를 지원하지 않을 때, 리스트로 만드는 n차원 배열이다. | . INIT = -1 # 각 행렬 요소의 초기화 값이다. W = row = N H = column = M C = channel = 3 B = batch = 3 # 1차원 array : 초기화값이 요소 상태로 list comp D1 = [ INIT for _ in range(W)] # 1차원은 행길이만큼 list comp + [] X -&gt; 행길이만큼 요소롤 복제하도록 list comp + 요소 # D1 = [ INIT ] * N # 요소복제의 2번째 방법, list든 str든 곱하면 extend된다. # - but 내부 list comp 요소 + 외부 [] 그만큼 곱은 주의한다. id가 동일한놈들이 복사된다. # 2차원 array : 행[]들 먼저 행길이만큼 list comp돌고 , 내부 1row를 요소 list comp # D2 = [ [] for _ in range(H)] D2 = [ [ INIT for _ in range(W) ] for _ in range(H)] # 3차원 array : 2차원 밖에 [[]]행렬 갯수만큼 list comp 해줌. D3 = [[[ [ INIT for _ in range(W) ] for _ in range(H)]] for _ in range(C)] # 3차원 array : 2차원 밖에 [[]]행렬 갯수만큼 list comp 해줌. D4 = [[[[ [ INIT for _ in range(W) ] for _ in range(H)]] for _ in range(C)] for _ in range(B)] print(D1) print(D2) print(D3) print(D4) . [-1, -1, -1] [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]] [[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]] [[[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]], [[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]], [[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]]] . 2&#52264;&#50896; &#51025;&#50857; by range . INIT값이 아닌 1부터 순서대로 채운 N*N 행렬 range( , , 열길이)를 이용한다. N씩 건너뛰어서 가니까... | 시작은 1부터 n(n-1) + 2 로 1부터 n-1까지의 합으로 간다? | . | . 1&#48512;&#53552; &#49692;&#49436;&#45824;&#47196; &#52292;&#50868; (N,N)&#54665;&#47148; . 각행의 첫째항을 등차수열(column : N개) 를 이용해서 만들어준다. . 1부터 N의 등차수열 range(1, , N)과 끝값은 N번째항 뽑은 것 + 1 을 넣어준다 | An = a1 + (n-1)d = 1 + n(n-1) -&gt; range( , n*n-1 + 1, ) | . | 각 행렬의 첫째항부터 1씩 증가하여 N개를 채운 행list를 완성한다. . | # - 일단 1 ~ n*(n-1)/2 에서 마지막항의 의미는 그냥 찍어보면 모른다. n = 6 for i in range(1, n*(n-1)+2, n): print(i) print(n*(n-1)+2) . 1 7 13 19 25 31 32 . # - for문 안의 i가 1에서부터 **등차(k)수열**이 되어버림. # 1부터, 등차가 n이면, n열짜리 행1개를 건너띈 다음 행 첫째항이 된다. # 열의 갯수N을 등차로 하여 일반항을 잡고, 행 N개를 가야하므로 # An = 1 + (n-1)*d = n*(n-1) + 1 이 된다. # 등차수열 range(1, ,n)이 n번째항 까지는 가야하므로, n번째항+1을 넣어준 것이다. for i in range(1, n*(n-1)+2, n): print(i, &quot;&lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다.&quot;) . 1 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 7 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 13 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 19 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 25 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 31 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. . # 2중 list comp는 요소만 노출할 경우, 1차원 행렬밖에 # - list로 만들경우, 각 요소들이 list로.. # - 행단위로 묵어서는 못만든다 -&gt; result = [] for문 이용 n = 5 result = [] for i in range(1, n*(n-1)+2, n): # 첫째항 i, 등차1 의 수열을 1~n항까지 listcomp로 모으기 result.append([ i+(j-1)*1 for j in range(1, n+1)]) result . [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]] . # 행마다 돌면서 row에접근후 인덱싱.. [ row[4:6] for row in paper[4:7]] . [[0, 0], [0, 0], [1, -1]] . def check_valid(matrix): print(&quot;dict상태&gt;&gt;&gt;&quot;, count_dict) if len(matrix) == 1: print(&quot;1개짜리 돌입. matrix &gt;&gt;&gt;&quot;, matrix) # 1개짜리라면.. 넣고 +1 count_dict.setdefault(matrix[0][0], 0) count_dict[matrix[0][0]] +=1 return True paper_0_0 = matrix[0][0] flag = False for i in range(len(matrix)): for j in range(len(matrix)): if paper_0_0 != matrix[i][j]: flag = True break if flag: print(&quot;다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : &quot;,matrix ) N = len(matrix) # 3x3중 1x1 -&gt; 열 3구간 다 check_valid([ row[:N//3] for row in matrix[:N//3]]) check_valid([ row[N//3:(N//3)*2] for row in matrix[:N//3]]) check_valid([ row[(N//3)*2:] for row in matrix[:N//3]]) # 3x3중 2x2 check_valid([ row[:N//3] for row in matrix[N//3:(N//3)*2]]) check_valid([ row[N//3:(N//3)*2] for row in matrix[N//3:(N//3)*2]]) check_valid([ row[(N//3)*2:] for row in matrix[N//3:(N//3)*2]]) # 3x3중 3x3 check_valid([ row[:N//3] for row in matrix[(N//3)*2:]]) check_valid([ row[N//3:(N//3)*2] for row in matrix[(N//3)*2:]]) check_valid([ row[(N//3)*2:] for row in matrix[(N//3)*2:]]) else: print(&quot;다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix:&quot;, matrix) count_dict.setdefault(paper_0_0, 0) count_dict[paper_0_0] += 1 return True count_dict = {} check_valid(paper) . dict상태&gt;&gt;&gt; {} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, -1, 0, 1, -1, 0, 1, -1], [0, -1, 1, 0, 1, -1, 0, 1, -1], [0, 1, -1, 1, 0, -1, 0, 1, -1]] dict상태&gt;&gt;&gt; {} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] dict상태&gt;&gt;&gt; {0: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[1, 1, 1], [1, 1, 1], [1, 1, 1]] dict상태&gt;&gt;&gt; {0: 1, 1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]] dict상태&gt;&gt;&gt; {0: 1, 1: 1, -1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[1, 1, 1], [1, 1, 1], [1, 1, 1]] dict상태&gt;&gt;&gt; {0: 1, 1: 2, -1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] dict상태&gt;&gt;&gt; {0: 2, 1: 2, -1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] dict상태&gt;&gt;&gt; {0: 3, 1: 2, -1: 1} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 1, -1], [0, -1, 1], [0, 1, -1]] dict상태&gt;&gt;&gt; {0: 3, 1: 2, -1: 1} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 4, 1: 2, -1: 1} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 4, 1: 3, -1: 1} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 4, 1: 3, -1: 2} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 5, 1: 3, -1: 2} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 5, 1: 3, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 5, 1: 4, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 6, 1: 4, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 6, 1: 5, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 6, 1: 5, -1: 4} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 1, -1], [0, 1, -1], [1, 0, -1]] dict상태&gt;&gt;&gt; {0: 6, 1: 5, -1: 4} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 7, 1: 5, -1: 4} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 7, 1: 6, -1: 4} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 7, 1: 6, -1: 5} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 8, 1: 6, -1: 5} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 8, 1: 7, -1: 5} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 8, 1: 7, -1: 6} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 8, 1: 8, -1: 6} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 9, 1: 8, -1: 6} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 9, 1: 8, -1: 7} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 1, -1], [0, 1, -1], [0, 1, -1]] dict상태&gt;&gt;&gt; {0: 9, 1: 8, -1: 7} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 10, 1: 8, -1: 7} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 10, 1: 9, -1: 7} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 10, 1: 9, -1: 8} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 11, 1: 9, -1: 8} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 11, 1: 10, -1: 8} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 11, 1: 10, -1: 9} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 12, 1: 10, -1: 9} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 12, 1: 11, -1: 9} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] . print(*map(lambda x:x[1], sorted(count_dict.items(), key=lambda x:x[0]))) . 10 12 11 .",
            "url": "blog.chojaeseong.com/boj/python/array/2021/08/12/python_%EB%B0%B0%EC%97%B4_%EC%97%B0%EC%8A%B5.html",
            "relUrl": "/boj/python/array/2021/08/12/python_%EB%B0%B0%EC%97%B4_%EC%97%B0%EC%8A%B5.html",
            "date": " • Aug 12, 2021"
        }
        
    
  
    
        ,"post90": {
            "title": "파이썬을 파이썬답게 노트정리",
            "content": "&#52636;&#51200; . 파이썬을 파이썬답게 실습강의를 듣고 느낀점과 함께 풀어낸 노트입니다. | . &#44277;&#48512; &#51060;&#50976; . 정수를 담은 이차원 리스트, mylist 가 solution 함수의 파라미터로 주어집니다. mylist에 들은 각 원소의 길이를 담은 리스트를 리턴하도록 solution 함수를 작성해주세요. . 제한 조건 | mylist의 길이는 100 이하인 자연수입니다. | mylist 각 원소의 길이는 100 이하인 자연수입니다. | . | 위 문제를 아래와 같이 짰다면, 수강해야한다. 나는 list comp로 짬 . | . 아래와 같은 풀이는 c언어 or 자바 풀이임. . | 이것과 같이 짜야함 . | . 용어 설명 iterable: 자신의 멤버를 한 번에 하나씩 리턴할 수 있는 객체입니다. list, str, tuple, dict 등이 여기에 속합니다. | sequence: int 타입 인덱스를 통해, 원소에 접근할 수 있는 iterable 입니다. iterable의 하위 카테고리라고 생각하시면 됩니다. | list, str, tuple이 여기 속합니다. ( dictionary는 다양한 타입을 통해 원소에 접근할 수 있기 때문에 sequence에 속하지 않습니다.) | . | unpacking: 적절한 번역을 찾고 있습니다. | . | . &#51221;&#49688; (2) . &#47787;&#44284; &#45208;&#47672;&#51648; . 문제 설명 숫자 a, b가 주어졌을 때 a를 b로 나눈 몫과 a를 b로 나눈 나머지를 공백으로 구분해 출력해보세요. 입력 설명 입력으로는 공백으로 구분된 숫자가 두 개 주어집니다. 첫 번째 숫자는 a를 나타내며, 두 번째 숫자는 b를 나타냅니다. 출력 설명 a를 b로 나눈 몫과 a를 b로 나눈 나머지를 공백으로 구분해 출력하세요. 제한 조건 a와 b는 자연수입니다. . &#45236;&#54400;&#51060;(list comp) . input_ = &#39;5 3&#39; num_ = input_.strip().split(&#39; &#39;) a, b = [int(x) for x in num_] str(a//b) + &#39; &#39; + str(a%b) . &#39;1 2&#39; . &#45712;&#45184;&#51216; (divmod + unpacking) . divmod는 한번에 목과 나머지를 구한다. //, %보단 느리지만, 갯수가 많을 땐 더 빨라진다고 한다. | 데이터 변환을 list comp전에 map(str, ) map(int, )도 활용해보자. | tuple을 unpacking(콤마할당)을 하면, iterable객체(tuple)이 알아서 나뉜다. | . a, b = map(int, input_.strip().split(&#39; &#39;)) . a . 5 . b . 3 . divmod(a, b) # 순서대로 몫, 나머지를 반환함. . (1, 2) . print(*divmod(a, b)) #unpakcking을 print하면, 각각을 공백으로 나누어서 프린트해준다. . 1 2 . (&#52428;) n&#51652;&#48277;&#51004;&#47196; &#54364;&#44592;&#46108; string&#51012; 10&#51652;&#48277; &#49707;&#51088;&#47196; &#48320;&#54872;&#54616;&#44592; . 문제 설명 base 진법으로 표기된 숫자를 10진법 숫자 출력해보세요. 입력 설명 입력으로는 공백으로 구분된 숫자가 두 개 주어집니다. 첫 번째 숫자는 num을 나타내며, 두 번째 숫자는 base를 나타냅니다. 출력 설명 base 진법으로 표기된 num을 10진법 숫자로 출력해보세요. 제한 조건 base는 10 이하인 자연수입니다. num은 3000 이하인 자연수입니다. 예시 input output 12 3 5 444 5 124 입출력 예 설명 입출력 예 1 3진법으로 표기된 12는 10진법으로 표현하면 5입니다. ( 1*3 + 2 ) 입출력 예 2 5진법으로 표기된 444는 10진법으로 표현하면 124입니다. ( 455 + 4*5 + 4 ) . &#45236;&#54400;&#51060; . num, base = map(int, input().strip().split(&#39; &#39;)) div_sum = 0 for n in sorted(range(0, len(str(num))), reverse=True): k, num = divmod(num, 10**(n)) div_sum += k * (base**(n)) print(div_sum) . &#51221;&#45813; . n진법으로 표기된 string을 10진법 숫자로 변환하기 - int 함수 . 진법 변환 문제는 알고리즘 문제나 숙제로 자주 나오는 유형이지요. 이번 시간에는 n 진법으로 표기된 문자열을 10진법 숫자로 변환하는 방법을 배워봅시다. . 예시) 5진법으로 적힌 문자열 &#39;3212&#39;를 10진법으로 바꾸기 . 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통 사람들은 for 문을 이용해 숫자를 곱해가며 문제를 풉니다. . num = &#39;3212&#39; base = 5 answer = 0 for idx, number in enumerate(num[::-1]): answer += int(number) * (base ** idx) . 파이썬에서는 파이썬의 int(x, base=10) 함수는 진법 변환을 지원합니다. 이 기본적인 함수를 잘 쓰면 코드를 짧게 쓸 수 있고, 또 시간을 절약할 수 있습니다. . num = &#39;3212&#39; base = 5 answer = int(num, base) . &#45712;&#45184;&#51216;(enumerate, int( , base), &#47928;&#51088;&#50676;&#46020; sequence, [::-1]) . 순서가 필요한 list나 문자열은 enumerate를 활용하자. ex&gt; 진법변환 계산 | 뒤에서부터 시작을 꼭 sorted( ,reverse=True)에 집착X iterable전용인 문자열, array, dataframe등을 생각할 때 [::-1]을 활용하자. 문자열도, list처럼 sequence이다. (flatcontainerimmutablemutable) -&gt; 인덱싱으로 꺼꾸로 시작하게 할 수 있다. | . | 파이썬에서는 진법변환함수를 int( , base)로 제공한다. 필요하다면 쓰자. 진법변환시 첫자리부터 하지말고, str()+ [::-1]을 활용해 일의 자리에서부터 풀자 | . | . num = &#39;432&#39; base = &#39;5&#39; # 일의 자리부터 풀어보자. + enumerate로 번호를 줘가면서 풀어보자. num[::-1] . &#39;234&#39; . answer = 0 for idx, number in enumerate(num[::-1]): answer += int(number) * ( int(base) ** (idx) ) answer . 117 . # base진법으로 표기된 string num을 -&gt; 10진법 숫자(int())변환 answer = int(num, base=int(base)) answer . 117 . &#47928;&#51088;&#50676; (2) . &#47928;&#51088;&#50676; &#51221;&#47148;&#54616;&#44592; . 문제 설명 문자열 s와 자연수 n이 입력으로 주어집니다. 문자열 s를 좌측 / 가운데 / 우측 정렬한 길이 n인 문자열을 한 줄씩 프린트해보세요. 제한조건 s의 길이는 n보다 작습니다. (n - s의 길이)는 짝수입니다. s는 알파벳과 숫자로만 이루어져 있으며, 공백 문자가 포함되어있지 않습니다. . &#45236;&#54400;&#51060; . s, n = input().strip().split(&#39; &#39;) n = int(n) space_num = n-len(s) print(s+&#39; &#39;*space_num) print(&#39; &#39;*(space_num//2)+s+&#39; &#39;*(space_num//2)) print(&#39; &#39;*space_num+s) . abc 7 abc abc abc . &#51221;&#45813; . # -&gt; answer =&#39;&#39; 빈 문자열에 공백의 갯수만큼 돌면서(반복작업용for) 누적합으로 공백을 채운다. s = &#39;가나다라&#39; n = 7 answer = &#39;&#39; for i in range(n-(len(s))): answer+=&#39; &#39; answer+=s answer . &#39; 가나다라&#39; . s = &#39;가나다라&#39; n = 7 s.ljust(7) . &#39;가나다라 &#39; . s.center(7) . &#39; 가나다라 &#39; . s.rjust(7) . &#39; 가나다라&#39; . &#45712;&#45184;&#51216;(ljust, center, rjust) . 문자열로 sequence로 빈리스트+for+append대신 빈문자열+for++=누적합작업을 생각하자 for문을 반복작업에 활용하자. | . | python은 문자열의 공백정렬을 위해 문자열+공백으로 n자리를 채워준다. | string.ljust(공백포함 왼쪽정렬될 n자리), string.center(n), string.rjust() | . &#50508;&#54028;&#48307; &#52636;&#47141;&#54616;&#44592; . 입력으로 0이 주어지면 영문 소문자 알파벳을, 입력으로 1이 주어지면 영문 대문자 알파벳을 사전 순으로 출력하는 코드를 짜세요. 예시 1 입력 0 출력 abcd...(중간생략)..xyz . &#45236;&#54400;&#51060; . ord(&#39;a&#39;) . 97 . chr(97) . &#39;a&#39; . chr(122) . str . chr(65), chr(90) . (&#39;A&#39;, &#39;Z&#39;) . answer = &#39;&#39; for i in range(65, 90+1): answer+=chr(i) print(answer) . ABCDEFGHIJKLMNOPQRSTUVWXYZ . num = int(input().strip()) answer = &quot;&quot; if num: # num이 0이면, 소문자로 # ord(&#39;a&#39;) = 97 -&gt; z -&gt;122 for i in range(65, 90+1): answer+=chr(i) else: for i in range(97, 122+1): answer+=chr(i) print(answer) . 1 ABCDEFGHIJKLMNOPQRSTUVWXYZ . &#51221;&#45813; . import string string.ascii_lowercase # 소문자 abcdefghijklmnopqrstuvwxyz string.ascii_uppercase # 대문자 ABCDEFGHIJKLMNOPQRSTUVWXYZ string.ascii_letters # 대소문자 모두 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ string.digits # 숫자 0123456789 . &#39;0123456789&#39; . num = int(input().strip()) # answer = &quot;&quot; if num: # num이 0이면, 소문자로 # ord(&#39;a&#39;) = 97 -&gt; z -&gt;122 #for i in range(65, 90+1): # answer+=chr(i) print(string.ascii_uppercase) else: #for i in range(97, 122+1): # answer+=chr(i) print(string.ascii_lowercase) # print(answer) . 1 ABCDEFGHIJKLMNOPQRSTUVWXYZ . &#45712;&#45184;&#51216;(str.lower(), upper() -&gt; string&#49345;&#49688;, string&#47784;&#46280;.ascii_ , string&#47784;&#46280;.digits, ) . string모듈이란 것이 따로 있고, 소문자모음, 대문자모음, 소-&gt;대문자모음, 숫자모음을 상수로 제공한다. string.ascii_lowercase # 소문자 abcdefghijklmnopqrstuvwxyz | string.ascii_uppercase # 대문자 ABCDEFGHIJKLMNOPQRSTUVWXYZ | string.ascii_letters # 대소문자 모두 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ | string.digits # 숫자 0123456789 | . | 다른 사람 풀이를 보고선 chr(), ord()를 안써도되고 | 소문자만 or 대문자만 작성해서 str.lower() / str.upper() 메소드도 활용하자. | . | . iterable &#45796;&#47336;&#44592; (4) . Iterable이란? 자신의 멤버를 한번에 리턴할 수 있는 객체입니다. ex) list, str, tuple, dictionary 등 | . &#50896;&#48376;&#51012; &#50976;&#51648;&#54620;&#52292;, &#51221;&#47148;&#46108; &#47532;&#49828;&#53944; &#44396;&#54616;&#44592; - sorted . 파이썬의 sort() 함수를 사용하면 리스트의 원소를 정렬할 수 있습니다. 이때, sort 함수는 원본의 멤버 순서를 변경하지요. 따라서 원본의 순서는 변경하지 않고, 정렬된 값을 구하려면 sort 함수를 사용할 수 없습니다. . 이런 경우는 어떻게 해야 할까요? . 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통 사람들은 deep copy와 sort 함수를 이용합니다. . list1 = [3, 2, 1] list2 = [i for i in list1] # 또는 copy.deepcopy를 사용 list2.sort() . 파이썬에서는 파이썬의 sorted를 사용해보세요. 반복문이나, deepcopy 함수를 사용하지 않아도 새로운 정렬된 리스트를 구할 수 있습니다. . list1 = [3, 2, 1] list2 = sorted(list1) . &#45712;&#45184;&#51216; - (copy.deepcopy() -&gt; sort() &#50752; sorted() ) . sort()함수는 객체 직접 변환을 하니, &lt;같은값 할당은 shallow copy지만&gt; copy.deepcopy()이후 sort()를 한다고 한다. | sorted()는 새로운 정렬 list를 바로 반환한다. 그 인자로는 reverse=True, key=len, key=str.lower, key=lambda 등 정렬기준을 만드는 함수를 인자로 넣을 수 도 있다. | . | . (&#52428;) 2&#52264;&#50896; &#47532;&#49828;&#53944; &#46244;&#51665;&#44592; ( transpose&#47928;&#51228;, &#50612;&#47140;&#50880; ) . 다음을 만족하는 함수, solution을 완성해주세요. solution 함수는 이차원 리스트, mylist를 인자로 받습니다 solution 함수는 mylist 원소의 행과 열을 뒤집은 한 값을 리턴해야합니다. 예를 들어 mylist [[1, 2, 3], [4, 5, 6], [7, 8, 9]]가 주어진 경우, solution 함수는 [[1, 4, 7], [2, 5, 8], [3, 6, 9]] 을 리턴하면 됩니다. 제한 조건 mylist의 원소의 길이는 모두 같습니다. mylist의 길이는 mylist[0]의 길이와 같습니다. 각 리스트의 길이는 100 이하인 자연수입니다. . &#54400;&#51060;2&#44032;&#51648;(&#51221;&#52376;&#44592;&#49885;i&gt;j, &#48712;_list [i]&#54665;&#44284; for j &#44592;&#51316;list[j][i]&#50676;&#51012; &#54620; &#49464;&#53944;&#47196; ) . mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] mylist[::-1] # 1x1 -&gt; 1 # 2x2 -&gt; 3 # 3x3 -&gt; 5 # nxn -&gt; 2n-1 line # 각 k in 2n-1 마다.. # k=1, -&gt; 길이 1 0.0 # k=2, -&gt; 길이 2 1.0 0.1 # k=3, -&gt; 길이 3 2.0 1.1 0.2 # k=4, -&gt; 길이 2 # k=5, -&gt; 길이 5 # gg . [[7, 8, 9], [4, 5, 6], [1, 2, 3]] . # 타 문제에서는 각 행마다 길이가 같다는 보장이 없기 때문??? 이번 강의에서는 zip 함수를 이용해 2차원 배열을 뒤집는 방법을 알아봅시다. 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통은 다음과 같이 2중 for 문을 이용해 리스트의 row와 column을 뒤집습니다. . [[]]*4 . [[], [], [], []] . [[]]*len(mylist) . [[], [], []] . &#45712;&#45184;&#51216;( &#51221;&#52376;&#44592;&#49885;, new_list&#51032; &#54665;i == mylist&#51032; &#50676;i&#47196; &#44256;&#51221;&#49884;&#53020;, j&#47484; &#46028;&#47536; &#49345;&#53468;) . 2중 for문으로 행렬을 뒤집으려면, 빈 list -&gt; 빈 list의 [i]행 고정상태에 append ( mylist [행을 j로 돌리면서] [열은 i열로 고정]시켜서 뽑아낸 것들 ) . 새 list의 i행과 기존 list의 i열을 동일시 하면서 기존 list의 i열 값들을 뽑아내기 위해 j를 돌리면서 append한다. | . | 정처기식으로, i, j가 돌아가는데, 행렬 중에 i&gt;j 부분만 찾아서 한쪽만 swap . | mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] new_list = [[], [], []] for i in range(len(mylist)): for j in range(len(mylist[i])): new_list[i].append(mylist[j][i]) new_list . [[1, 4, 7], [2, 5, 8], [3, 6, 9]] . mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # new_list = [[], [], []] # new_list = [[]]*3 # 주의! 안에 요소가 콤마로 붙는다고 해서 list바깥에서 *3 하지말 것. id똑같은놈들임. # new_list = [[] for x in range(len(mylist))] for i in range(len(mylist)): for j in range(len(mylist)): if i &gt; j: mylist[j][i], mylist[i][j] = mylist[i][j], mylist[j][i] mylist . [[1, 4, 7], [2, 5, 8], [3, 6, 9]] . (&#52428;) 2&#52264;&#50896; &#47532;&#49828;&#53944; &#46244;&#51665;&#44592; - &#11088;&#65039;zip&#11088;&#65039; . &#54400;&#51060; . mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] new_list = list(map(list, zip(*mylist))) . &#45712;&#45184;&#51216;( zip(*&#47588;&#54609; 2&#52264;&#50896; &#47532;&#49828;&#53944;) -&gt; &#44033; &#54665;&#46308;&#47560;&#45796; 1&#44060;&#50473; &#48977;&#50500; tuple&#47196; ) . 행렬(2차원리스트)를 *매핑해서 zip()에 던져주면, 각 행들을 zip(a,b,c,...,n_rows)로 판단해서 나눠쓴다. 즉, for문으로 받을 때는 각 행마다 0열요소들 / 1열 요소들 / ... 들이 튜플로 모여서 들어온다. | . | 번역 : zip(*iterables)는 각 iterables 의 요소들을 모으는 이터레이터를 만듭니다. 튜플의 이터레이터를 돌려주는데, i 번째 튜플은 각 인자로 전달된 시퀀스나 이터러블의 i 번째 요소를 포함합니다. | . | 즉, 각 iter들(*매핑리스트시 - 각행들)의 요소를 하나씩 빼와서 튜플형태로 반환한다. i번째 튜플은 각 데이터(행)의 i번째열들의 모아아두었다. | 길이가 다르면, 짧은 데이터를 기준으로 끝난다. | 원래 집은 **zip으로 튜플들을 반환한다. 꼭 튜플 리스트가 아니더라도 2개의 짝을 이룬 튜플요소들이 반환되면 dict로 반환 가능하다. for문에서는 zip이 반환하는 tuple을 언패킹하는 것일 뿐 | . | . print(mylist) #[[*1*, 2, 3], # [*4*, 5, 6], # [*7*, 8, 9]] zip(*mylist) . [[1, 2, 3], [4, 5, 6], [7, 8, 9]] . &lt;zip at 0x1ed8c381800&gt; . list(zip(*mylist)) # 각 행마다 같은 열들을 튜플로 묶어서, 마치 대각선으로 transpose된다. . [(1, 4, 7), (2, 5, 8), (3, 6, 9)] . list(map(list, zip(*mylist))) # zip으로 만들어진 transpose 튜플 리스트를 map으로 각 요소 list로 변환한다. . [[1, 4, 7], [2, 5, 8], [3, 6, 9]] . print(&#39;mylist&#39;, mylist) print(&#39;*mylist&#39;, *mylist) # 함수에 튜플이나 리스트를 매핑해주면, 알아서 나눠서 쓴다는 의미다. # 인자로 대입한다면, 콤마로 나눠서 넣어줘야한다. (튜플, 리스트로 인자대입X) list(zip(*mylist)) . mylist [[1, 2, 3], [4, 5, 6], [7, 8, 9]] *mylist [1, 2, 3] [4, 5, 6] [7, 8, 9] . [(1, 4, 7), (2, 5, 8), (3, 6, 9)] . list1 = [1, 2, 3, 4, 5] list2 = [100, 120, 30, 300] list3 = [392, 2, 33] answer = [] for number1, number2, number3 in zip(list1, list2, list3): print(number1 + number2 + number3) . 493 124 66 . # 짝을 이룬 튜플리스트는 dict로 변환가능하다! animals = [&#39;cat&#39;, &#39;dog&#39;, &#39;lion&#39;] sounds = [&#39;meow&#39;, &#39;woof&#39;, &#39;roar&#39;] # print(list(zip(animals, sounds))) dict(zip(animals, sounds)) . [(&#39;cat&#39;, &#39;meow&#39;), (&#39;dog&#39;, &#39;woof&#39;), (&#39;lion&#39;, &#39;roar&#39;)] . {&#39;cat&#39;: &#39;meow&#39;, &#39;dog&#39;: &#39;woof&#39;, &#39;lion&#39;: &#39;roar&#39;} . (&#52428;) i&#48264;&#51704; &#50896;&#49548;&#50752; i+1&#48264;&#51704; &#50896;&#49548; - zip . 숫자를 담은 리스트 mylist가 solution 함수의 파라미터로 주어집니다. solution 함수가 mylist의 i번째 원소와 i+1번째 원소의 차를 담은 일차원 리스트에 차례로 담아 리턴하도록 코드를 작성해주세요. 단, 마지막에 있는 원소는 (마지막+1)번째의 원소와의 차를 구할 수 없으니, 이 값은 구하지 않습니다. 제한 조건 mylist의 길이는 1 이상 100 이하인 자연수입니다. mylist의 원소는 1 이상 100 이하인 자연수입니다. 예시 mylist output [83, 48, 13, 4, 71, 11] [35, 35, 9, 67, 60] 설명: 83과 48의 차는 35입니다. 48과 13의 차는 35입니다. 13과 4의 차는 9입니다. 4와 71의 차는 67입니다. 71과 11의 차는 60입니다. 따라서 [35, 35, 9, 67, 60]를 리턴합니다. . &#54400;&#51060; . def solution(mylist): return [abs(mylist[i] - mylist[i+1]) for i in range(len(mylist)-1)] . &#51221;&#45813; &#48143; &#45712;&#45184;&#51216; (zip( list, list[1:]) -&gt; &#51064;&#45937;&#49905; i&#50752; i+1&#51032; value&#47484; &#46041;&#49884;&#51217;&#44540; ) . 원래는 for i in n-1까지만 돌기 -&gt; [i], [i+1] | zip( list, 1개 모자란 list[1:] ) -&gt; 2개 요소 value 바로 접근 zip은 짧은 것 까지니까 자동으로 (0,1) &gt; (n-1,n) (n, ) | . | def solution(mylist): answer = [] for number1, number2 in zip(mylist, mylist[1:]): answer.append(abs(number1 - number2)) return answer . &#47784;&#46304; &#47716;&#48260;&#51032; type &#48320;&#54872;&#54616;&#44592; . 문제 설명 문자열 리스트 mylist를 입력받아, 이 리스트를 정수형 리스트로 바꾼 값을 리턴하는 함수, solution을 만들어주세요. 예를 들어 mylist가 [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] 인 경우, solution 함수는 [1, 100, 33] 을 리턴하면 됩니다. 제한조건 mylist의 길이는 100 이하인 자연수입니다. mylist의 원소는 10진수 숫자로 표현할 수 있는 문자열입니다. 즉, &#39;as2&#39; 와 같은 문자열은 들어있지 않습니다. 예시 input output [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] [1, 100, 33] . def solution(mylist): return [ int(x) for x in mylist ] . &#45712;&#45184;&#51216;(map -&gt; &#54632;&#49688;&#47484; &#51064;&#51088;&#47196; or lambda ) . list comp도 되지만, list(map(각 요소에 적용함수, 데이터)) 로 데이터 변형 가능 map( 내장함수 or 실행부없는 함수 or lambda, 데이터) | . | . list1 = [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] list2 = list(map(len, list1)) list2 . [1, 3, 2] . map &#54632;&#49688; &#51025;&#50857;&#54616;&#44592; . 문제 설명 정수를 담은 이차원 리스트, mylist 가 solution 함수의 파라미터로 주어집니다. solution 함수가 mylist 각 원소의 길이를 담은 리스트를 리턴하도록 빈칸을 완성해보세요. hint) 이전 강의에서 배운 map 함수를 활용해보세요 제한 조건 mylist의 길이는 100 이하인 자연수입니다. mylist 각 원소의 길이는 100 이하인 자연수입니다. 예시 input output [[1], [2]] [1, 1] [[1, 2], [3, 4], [5]] [2, 2, 1] . def solution(mylist): answer = list(map(len, mylist)) return answer . Sequence Types &#45796;&#47336;&#44592; (2) . sequence &#47716;&#48260;&#47484; &#54616;&#45208;&#47196; &#51060;&#50612;&#48537;&#51060;&#44592; - join . 문자열 리스트 mylist를 입력받아, 이 리스트의 원소를 모두 이어붙인 문자열을 리턴하는 함수, solution을 만들어주세요. 예를 들어 mylist가 [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] 인 경우, solution 함수는 &#39;110033&#39;을 리턴하면 됩니다. 제한 조건 mylist의 길이는 100 이하인 자연수입니다. mylist의 원소의 길이는 100 이하인 자연수입니다. . my_list = [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] answer = &#39;&#39; for value in my_list: answer += value . my_list = [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] answer = &#39;&#39;.join(my_list) . &#45712;&#45184;&#51216;( &#39;&#39;.join(sequence) &#44284; &#48712;&#47928;&#51088;&#50676; +=&#45572;&#51201;&#54633; append ) . 빈_문자열 = &#39;&#39; for in 빈문자열 += string(빈 문자열의 누적합 append) -&gt; python join | . &#49340;&#44033;&#54805; &#48324;&#52237;&#44592; - sequence&#51032; *&#50672;&#49328; . 문제 설명 이 문제에는 표준 입력으로 정수 n이 주어집니다. 별(*) 문자를 이용해 높이가 n인 삼각형을 출력해보세요. 제한 조건 n은 100 이하인 자연수입니다. 예시 입력 3 출력 * ** *** . n = int(input().strip()) for i in range(1,n+1): print((&#39;*&#39;*i).ljust(n)) . 5 * ** *** **** ***** . n = int(input().strip()) for i in range(1,n+1): print((&#39;*&#39;*i).center(n)) . 10 * ** *** **** ***** ****** ******* ******** ********* ********** . &#54400;&#51060; . 이번 강의에서는 곱셈 연산 *를 통해 문자열을 반복하는 방법을 배웁니다. | . 예시) . &#39;abc&#39;, &#39;abcabc&#39;, &#39;abcabcabc&#39;, &#39;abcabcabcabc ...&#39; 과 같이 . &#39;abc&#39;가 n번 반복되는 문자열 만들기 (my) 일정길이 문자열의 누적합 반복 -&gt; *) | . | [123, 456, 123, 456, 123, ...] 과같이 123, 456이 n번 반복되는 리스트 만들기 (my) 리스트 안에 요소들전체 의 append 반복 -&gt; *) | . | . answer = &#39;&#39; n = 5 for _ in range(n): answer += &#39;abc&#39; print(answer) . abcabcabcabcabc . # - sequence라 * 연산을 희한하게 한다. answer = &#39;abc&#39; * n answer . &#39;abcabcabcabcabc&#39; . n = 3 answer= [123, 456] * n print(answer) . [123, 456, 123, 456, 123, 456] . answer[3]=3 answer . [123, 456, 123, 3, 123, 456] . &#45712;&#45184;&#51216; (sequence * -&gt; string*, list*) . 문자열 * n : 문자열을 누적합해서 += 한 것처럼 반복된다. | list * n : 기존요소들전체 append | . Itertools / Collections &#47784;&#46280; (4) . (&#52428;) &#44273;&#51665;&#54633;(Cartesian product) &#44396;&#54616;&#44592; - product . 이번 강의에서는 iterable으로 곱집합을 구하는 방법을 알아봅니다. | 예시) 두 스트링 &#39;ABCD&#39;, &#39;xy&#39; 의 곱집합은 Ax Ay Bx By Cx Cy Dx Dy 입니다. | . iterable1 = &#39;ABCD&#39; iterable2 = &#39;xy&#39; iterable3 = &#39;1234&#39; for value1 in iterable1: for value2 in iterable2: for value3 in iterable3: print(value1, value2, value3) . A x 1 A x 2 A x 3 A x 4 A y 1 A y 2 A y 3 A y 4 B x 1 B x 2 B x 3 B x 4 B y 1 B y 2 B y 3 B y 4 C x 1 C x 2 C x 3 C x 4 C y 1 C y 2 C y 3 C y 4 D x 1 D x 2 D x 3 D x 4 D y 1 D y 2 D y 3 D y 4 . # itertools.product를 이용하면, for 문을 사용하지 않고도 곱집합을 구할 수 있습니다. import itertools iterable1 = &#39;ABCD&#39; iterable2 = &#39;xy&#39; iterable3 = &#39;1234&#39; print(list(itertools.product(iterable1, iterable2, iterable3))) . [(&#39;A&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;A&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;A&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;A&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;4&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;4&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;4&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;4&#39;)] . itertools.product(iterable1, iterable2, iterable3) . &lt;itertools.product at 0x1ed8c4750c0&gt; . import itertools iter1 = list(&#39;ABCD&#39;) iter2 = &#39;조재성 조재경 조아라&#39;.split(&#39; &#39;) iter3 = &#39;1234&#39; print(itertools.product(iter1)) # 1개의 iter도 받으며, list()로 변환해야 보인다. print(list(itertools.product(iter1))) # 1개의 iter도 받으며, list()로 변환해야 보인다. print(list(itertools.product(iter1, iter2))) # 2개의 iterable객체를 넣은 순간부터, 곱집합 튜플들의 리스트가 나온다. # 2중 for문을 도는 효과다. [ a + b + c for a,b,c in itertools.product(iter1, iter2, iter3)][:5] . &lt;itertools.product object at 0x000001ED8C58A940&gt; [(&#39;A&#39;,), (&#39;B&#39;,), (&#39;C&#39;,), (&#39;D&#39;,)] [(&#39;A&#39;, &#39;조재성&#39;), (&#39;A&#39;, &#39;조재경&#39;), (&#39;A&#39;, &#39;조아라&#39;), (&#39;B&#39;, &#39;조재성&#39;), (&#39;B&#39;, &#39;조재경&#39;), (&#39;B&#39;, &#39;조아라&#39;), (&#39;C&#39;, &#39;조재성&#39;), (&#39;C&#39;, &#39;조재경&#39;), (&#39;C&#39;, &#39;조아라&#39;), (&#39;D&#39;, &#39;조재성&#39;), (&#39;D&#39;, &#39;조재경&#39;), (&#39;D&#39;, &#39;조아라&#39;)] . [&#39;A조재성1&#39;, &#39;A조재성2&#39;, &#39;A조재성3&#39;, &#39;A조재성4&#39;, &#39;A조재경1&#39;] . &#45712;&#45184;&#51216;( itertools.product(iter1, 2, 3) -&gt; &#51473;&#52393;for &#48152;&#48373;&#51012; &#51228;&#44144; + &#49692;&#49436;&#45824;&#44032; &#51221;&#54644;&#51652; &#51312;&#54633;&#51060;&#45796;.) . itertools.product의 결과물은 list()를 씌워야 튜플 리스트로 들어온다. 1개의iter를 넣어도 (a, ) (b, )의 튜플형태로 받는다. | . | zip은 i, i+1, 같은 위상의 iter들을 동시에 받거나 *2차원리스트 등을 받아서 -&gt; 1차원으로 동시에 처리 itertools.product는 for iter1, for iter2처럼, 누적해서 곱집합을 처리한다. | . | 문자열도 iter로 인식하여 한 문자씩 돌아간다. | . (&#52428;) 2&#52264;&#50896; &#47532;&#49828;&#53944;&#47484; 1&#52264;&#50896; &#47532;&#49828;&#53944;&#47196; &#47564;&#46308;&#44592; - from_iterable . &#45236;&#54400;&#51060;(no pythonic) . def solution(mylist): answer = [] for list_ in mylist: for li in list_: answer.append(li) return answer . my_list = [[1, 2], [3, 4], [5, 6]] [ li for list_ in my_list for li in list_ ] . [1, 2, 3, 4, 5, 6] . &#51221;&#45813; . # 빈리스트[]에 +로 &lt;&lt;괄호떼고&gt;&gt;누적합으로 이어붙이기 . my_list = [[1, 2], [3, 4], [5, 6]] answer = [] for element in my_list: answer += element answer . [1, 2, 3, 4, 5, 6] . sum(my_list, []) . [1, 2, 3, 4, 5, 6] . print(itertools.chain.from_iterable( my_list ) ) list(itertools.chain.from_iterable( my_list ) ) . &lt;itertools.chain object at 0x000001ED8C79CE20&gt; . [1, 2, 3, 4, 5, 6] . # itertools.chain()은 여러 1차 iterable(1글자씩조합-문자열 or list 등)을 분해해서 # -&gt; 통합한 1차 iterable을 만든다. list(itertools.chain(&#39;ABC&#39;, [&#39;abc&#39;,2,3], &#39;F&#39;)) . [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;abc&#39;, 2, 3, &#39;F&#39;] . list(itertools.chain(my_list)) list(itertools.chain(*my_list)) . [1, 2, 3, 4, 5, 6] . 파이썬 * 의 사용 (https://mingrammer.com/understanding-the-asterisk-of-python/) 곱셈 및 거듭제곱 연산으로 사용할 때 | 리스트형 컨테이너 타입의 데이터를 반복 확장하고자 할 때 | 가변인자 (Variadic Arguments)를 사용하고자 할 때 -&gt; 인자시 패킹(내부에서는 *떼고 묶어서 써줘) | 컨테이너 타입의 데이터를 Unpacking 할 때 -&gt; 사용시언패킹(알아서 쪼개줘) | . | . from functools import reduce primes = [2, 3, 5, 7, 11, 13] def product(*numbers): p = reduce(lambda x, y: x * y, numbers) return p product(*primes) # product() 함수가 &lt;이미 내부에서&gt; 가변인자를 받고 있기 때문에, # 실제 입력시에는 콤마로 언패킹상태로 리스트의 데이터를 모두 unpacking하여 함수에 전달해야한다. # -&gt; 인자가 패킹하고있다면, 실제 대입은 콤마, , ,로 나눠서 주던지 *iterable로 알아서 처리하라고 넘겨주면 된다. # 30030 product(primes) # XXXXXXXXXX -&gt; 콤마로 줘야할 곳을 list로 주고 있다. *list로 하면 콤마로 알아서 입력해줘다. # [2, 3, 5, 7, 11, 13] . [2, 3, 5, 7, 11, 13] . list(itertools.chain.from_iterable( my_list )) . [1, 2, 3, 4, 5, 6] . from functools import reduce reduce(lambda x, y: x+y, my_list) from operator import add reduce(add, my_list) . [1, 2, 3, 4, 5, 6] . &#45712;&#45184;&#51216;( 2&#52264;&#50896; : [ ] for += &#44292;&#46524;&#51060;&#50612;&#48537;&#51060;&#44592; / sum( , start =[ ]) / &#54620;&#44732;&#54400; : itertools.chain(*)&#44284; &#51088;&#46041; 2&#44732;&#54400;: chain.from_iterable() / reduce(lambda x,y:x(list)+(new_list), &lt;--2&#52264;&#50896;&#47532;&#49828;&#53944;) . 가장 단순하게 2중 for문 or 2중 list comp로 element까지 가는 것 | 비 파이썬이라도 빈_list[ ]에 for문 1개의 list element에서 append가 아닌 빈_list += 괄호떼고 이어붙이기 | 내장sum(iter)함수에 , start=값을 default 0이 아닌 빈 []에다가 iter각 요소(2차원-&gt;1차원 리스트들)누적되도록 ! sum(iter , start = [] ) | itertools.chain( 1차원or문자열 iterable1 , iter2, ... ) -&gt; 문자열은 1개씩 풀어서, list는 element단위로 풀어서 1차원 iterable로 통합 itertools.chain()은 여러 1차 iterable들을 각각 분해하여 각각 한꺼풀만 벗겨, 통합한 1차 iterable을 만든다. | 2차원을 넣으면 그대로 2차원 반환됨. 한 꺼풀만 벗겨서 다시 통합하므로 -&gt; chain(*2차원)으로 사용시언패킹 시켜주자 | . | %timeit 결과를 보면 sum()함수만 끔찍하게 느리고 나머지 셋은 고만고만함을 알 수 있다. 성능과 가독성 중 무엇을 중시하냐의 차이지만 개인적으로 itertools.chain() 자체도 가독성이 나쁘다고 볼 수 없기에 sum()보다는 chain()을 쓰지 않을까 싶다. | . reduce도 각 데이터 요소들이 와서 연산하는데 lambda로 +연산 or operator.add를 사용해서 list들이 += 누적합이 되도록 해주면 된다. | from itertools import permutations sorted(list(permutations([2, 1,3], 2))) . [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] . (&#52428;) &#49692;&#50676;&#44284; &#51312;&#54633; - combinations, permutations . 문제 설명 숫자를 담은 일차원 리스트, mylist에 대해 mylist의 원소로 이루어진 모든 순열을 사전순으로 리턴하는 함수 solution을 완성해주세요. 제한 조건 mylist 의 길이는 1 이상 100 이하인 자연수입니다. 예시 mylist output [2, 1] [[1, 2], [2, 1]] [1, 2, 3] [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] . from itertools import permutations sorted(list(permutations([2, 1,3],2))) . [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] . &#54056;&#53412;&#51648; &#50630;&#51060; &#49692;&#50676; &#44396;&#54788;( &#54532;&#47196;&#44536;&#47000;&#47672;&#49828; while. &#50612;&#47140;&#50880;) . # # - 자기자신의 index와 value가 같아지는 순간까지만 반복되다가, 다음 index로 넘어가서 반복된다. # # - index가 더크면, 값+1 index 초기화후 # # - 값이 더크거나 같으면, &lt;인덱스+1&gt; 값 초기화 # # my) 값을 인덱스랑 같아질때까지 늘려주는데, 값 증가시 그때마다 i=0부터 시작.. -&gt; 같아지면 index+1 값은 0 # # my) index가 n-1까지 = arr갯수까지만 시행. # # - 그럼, 0` [0`,0] -&gt; `1 [0,`0] -&gt; `0 [`0,1] -&gt; `1 [0, `1] -&gt; 2 [0, 0] -&gt; 조건위배 while중지 # def permute_first(arr): # result = [arr[:]] # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c, arr, result) # # 1. i번째 데이터가 자기 순서(i)보다 값이 작다? 1증가시키고, 처음부터 돌려라. # if c[i] &lt; i : # c[i] +=1 # 값을 +1 # i = 0 # index를 0부터 다시 시작. # # 2. i번째 데이터가 자기 순서(i)보다 크거나 같다? 값을 초기화시키고, 다음 index순서로 넘어가라 # else: # c[i] = 0 # i+=1 # permute_first([0,0]) . # # my) 값을 인덱스랑 같아질때까지 늘려주는데, 값 증가시 그때마다 i=0부터 시작.. -&gt; 같아지면 index+1 값은 0 # # my) index가 n-1까지 = arr갯수까지만 시행. # # - 그럼, 0` [0`,0] -&gt; `1 [0,`0] -&gt; `0 [`0,1] -&gt; `1 [0, `1] -&gt; 2 [0, 0] -&gt; 조건위배 while중지 # # 3. 인덱스가 짝수면, arr[0]번째 값과 해당 index값 arr[i] swap한다. # def permute_two(arr): # result = [arr[:]] # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c[i], c, arr) # if c[i] &lt; i : # # 3. 인덱스가 짝수면, 원본 0번째 값 현재(짝수번째) 값을 교환. # if i % 2 ==0: # arr[0], arr[i] = arr[i], arr[0] # c[i] +=1 # i = 0 # else: # c[i] = 0 # i+=1 # permute_two([0,1,4]) . # result = [arr[:]] # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c[i], c, arr) # if c[i] &lt; i : # # 3. 인덱스가 짝수면, 0번째 값과, 짝수번째 값을 교환. # if i % 2 ==0: # arr[0], arr[i] = arr[i], arr[0] # # 4. 인덱스가 홀수면, [c list의 i번째 값]을 index로 넣고, 데이터 홀수번재 값을 교환 # else: # arr[c[i]], arr[i] = arr[i], arr[c[i]] # c[i] +=1 # i = 0 # else: # c[i] = 0 # i+=1 # permute_three([0,1,4]) . # # - 값이 index랑 같아지는 부분은 횟수를 늘리는 용도일 뿐이라는 말이다. # def permute_four(arr): # result = [arr[:]] # 2차원에 1번째 행을 원본을 넣어놓는다. # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c[i], c, arr) # if c[i] &lt; i : # # 3. 인덱스가 짝수면, 0번째 값과, 짝수번째 값을 교환. # if i % 2 ==0: # arr[0], arr[i] = arr[i], arr[0] # # 4. 인덱스가 홀수면, [c list의 i번째 값]을 index로 넣고, 데이터 홀수번재 값을 교환 # else: # arr[c[i]], arr[i] = arr[i], arr[c[i]] # # 5. arr결과를 result 2차원 리스트(원본을 1행에 가지고 있던 놈)에 append한다. # # - c[i]가 0에서부터 불들어오는 순간부터 교환후 들어올리네. # result.append(arr[:]) # c[i] +=1 # i = 0 # else: # c[i] = 0 # i+=1 # # 6. result 2차원 리스트를 반환한다. # return result # permute_four([1,2,3]) . def permute(arr): result = [arr[:]] c = [0] * len(arr) i = 0 while i &lt; len(arr): if c[i] &lt; i: if i % 2 == 0: arr[0], arr[i] = arr[i], arr[0] else: arr[c[i]], arr[i] = arr[i], arr[c[i]] result.append(arr[:]) c[i] += 1 i = 0 else: c[i] = 0 i += 1 return result . &#48264;&#50808;) python&#51004;&#47196;&#49692;&#50676; &#44396;&#54788;1 (&#48660;&#47196;&#44536;1, &#51116;&#44480;+&#48520;&#53356;&#44256;&#45124;&#44592; ) . https://shoark7.github.io/programming/algorithm/Permutations-and-Combinations | https://programmers.co.kr/learn/courses/4008/lessons/12836 | . arr = [0,1,2,3] r = 2 # def permutation(arr, r): # 1. used(list) : 해당index의 원소 사용 여부 : arr의 길이만큼 빈 [0] * n를 만들자. # - used(list)에는 해당index의 값이 사용됬는지 안됬는지 체크여부. # - 누적합이 아니라도 여부 등은 0 default에서 1 왔다갔다 하면, if문에 False, True로 걸린다. # used = [0] * len(arr) used = [0 for _ in range(len(arr))] # 2. generate( chosen, used ): 함수로 만들어야 -&gt; 내부에서 같은 로직을 한번 더 호출할 수 있다. # - 일단, 빈 list를 던져주고, 사용여부에 따라 append한 다음, 길이가 원하는 순열길이(r)과 같아졌다면 함수를 끝내는 return해준다. # generate([], used) 형태로 사용된다. def generate(chosen, used): # 2-1) default [] chosen이 원하는 길이를 만족했으면 -&gt; 탈출 -&gt; 그전까지는 내부함수 호출로 반복됨. if len(chosen) == r: print(chosen) # 결과값 저장대신 각각 만들어진 경우를 print한다. return # 2-2) arr길이만큼 반복 -&gt; used의 길이랑 arr이랑 같으며, 같이 움직이니까. # arr와 같은 길이의 used는 arr[i]의 사용여부체크시 used[i]를 사용하는 위에 떠있는 데이터 for i in range(len(arr)): # i번째 원소가 아직 사용이 안됬다? print(&#39;used&#39;, used) if not used[i]: # 사용후 -&gt; 사용표시 1 # - 일단 사용안된 i번째 요소를 chosen에 넣고, 사용했다는 표기를 한다. print(&#39;chosen&#39;, chosen) chosen.append(arr[i]) used[i]=1 # i번재 데이터가 담기고 + 사용되었다는 표시와함께 다시 호출하면 # - 재귀적? 반복적으로... i를 제외하고 사용안된 i를 =1,2,3,4에서부터 찾기..전에... generate(chosen, used) # 내부에서, 길이 못채웠고 &amp; 사용된것 넘어가면서 사용안된 것을 j를 0에서부터 찾는다. # 내부에서, 0은 used[0]이 이미 담겨있으니, 1을 chosen에 넣고, 0,1,을 넣은 상태에다. # 내부에서 또 내부함수가 호출되지만, 초기검사에서 r==2를 만족시켜 반환되며 # 내부j에서는, used[j] = 0을 넣고, 안썼다고 표시 + 데이터도 뺀 체로, j=1이 된다. # i=0는 고정상태에서 j=0을 쓴 뒤, j=1을 쓰고, r==2가 만족되면 j=2로 간다... # i 고정 -&gt; j를 돌면서 -&gt; k에서 갯수가 맞추다가,, j를 다돌면, i가 도나보다... used[i] = 0 chosen.pop() # 재귀를 써서 구하는데 # base case가 chosen == r(input)을 맞추면 끝난다... # 이 함수의 핵심이다. 모든 순열은 arr 의 0부터 i-1 번째 값으로 시작하기에 for 문으로 다 만들어야 한다. # recusive case는 nPr = 시작자리에 arr[i] 가 들어갔다고 치면(for를 n번) = N * n-1Pr 이다. # permutation([0,1,2,3], 2) = # ([0],permutation([1,2,3], 1)) + ([1],permutation([0,2,3], 1)) + ([2],permutation([0,1,3], 1))+ ([3],permutation([0,1,2], 1)) # combination([0,1,2,3], 2) = ([0],combination([1,2,3], 1)) + ([1],combination([2,3], 1)) + ([2],combination([3], 1))) # https://cotak.tistory.com/70 . used [0, 0, 0, 0] chosen [] used [1, 0, 0, 0] used [1, 0, 0, 0] chosen [0] [0, 1] used [1, 0, 0, 0] chosen [0] [0, 2] used [1, 0, 0, 0] chosen [0] [0, 3] used [0, 0, 0, 0] chosen [] used [0, 1, 0, 0] chosen [1] [1, 0] used [0, 1, 0, 0] used [0, 1, 0, 0] chosen [1] [1, 2] used [0, 1, 0, 0] chosen [1] [1, 3] used [0, 0, 0, 0] chosen [] used [0, 0, 1, 0] chosen [2] [2, 0] used [0, 0, 1, 0] chosen [2] [2, 1] used [0, 0, 1, 0] used [0, 0, 1, 0] chosen [2] [2, 3] used [0, 0, 0, 0] chosen [] used [0, 0, 0, 1] chosen [3] [3, 0] used [0, 0, 0, 1] chosen [3] [3, 1] used [0, 0, 0, 1] chosen [3] [3, 2] used [0, 0, 0, 1] . def permutation(arr, r): # 1. arr = sorted(arr) # 해당원소가 사용되고 있는 상태인지 arr와 같은길이의 0과 1로 구성될 list 생성 # - 재귀로 내부에서 함수가 또 불려질텐데, 내부함수가 밖에서 어떤 원소가 고정된 상탠지 알려주기 위해 # - 함수 입장에서 전역변수로 만들어준다. used = [0 for _ in range(len(arr))] def generate(chosen, used): # 2.재귀에서 탈출부이다. chosen이 원하는 갯수 r개가 되면 base case로 print하고 해당함수는 끝난다. # - 내부함수들이 끝나는 것이기에... 어느것이 끝나는지는... if len(chosen) == r: print(chosen) return # 3.i번째를 고정시킨 상태에서, # - i에 불이 안들어와있는 상태다 = 가장 바깥은 필요없지만.. 내부함수들은 바깥에서 고정된 것이기에 피해야한다. for i in range(len(arr)): # 사용했다는 불이 안들어온 상태다. 내부함수가 인식하도록, 내부함수호출직전에 켜주고, 직후에 꺼준다. # 맨바깥은 for로 알아서 i가 돌아가고 있기 때문에 노상관. 내부에서 i불들어온 것 제끼고 r-1개 맞추라는 신호임. if not used[i]: # 4. 내부함수가 i원소를 채운 상태로 재귀호출하도록 넣어주고, 불을 켜준다. chosen.append(arr[i]) used[i] = 1 generate(chosen, used) # 재귀상태로, 1개를 채운상태에서 r-1를 채우려고 호출된다. # 5. i고정상태에서 r-1개를 다채워 r개를 완성했다는 뜻이니, 불을 꺼주고, 빼준다. used[i] = 0 chosen.pop() # 6. 자동으로 다음 i가 고정되서 시작한다. generate([], used) permutation(&#39;ABCD&#39;, 2) . [&#39;A&#39;, &#39;B&#39;] [&#39;A&#39;, &#39;C&#39;] [&#39;A&#39;, &#39;D&#39;] [&#39;B&#39;, &#39;A&#39;] [&#39;B&#39;, &#39;C&#39;] [&#39;B&#39;, &#39;D&#39;] [&#39;C&#39;, &#39;A&#39;] [&#39;C&#39;, &#39;B&#39;] [&#39;C&#39;, &#39;D&#39;] [&#39;D&#39;, &#39;A&#39;] [&#39;D&#39;, &#39;B&#39;] [&#39;D&#39;, &#39;C&#39;] . &#48264;&#50808;2 ) python&#51004;&#47196;&#49692;&#50676; &#44396;&#54788;2 (&#48660;&#47196;&#44536;2, full &#51116;&#44480;&#54632;&#49688;&#47196; &#52376;&#47532;. &#45796;&#49884; &#48380; &#44163;) . # 출처: https://cotak.tistory.com/70 [Pool&#39;s Taek] def gen_permutations(arr, n): result = [] if n == 0: return [[]] for i, elem in enumerate(arr): # i번재 원소만 빼고, 대신 n-1개만 나머지로 순열 부분문제 정복상태 -&gt; 각 요소들P for P in gen_permutations(arr[:i] + arr[i+1:], n-1): # i번째 원소를 맨마지막에 extend해서 붙임. # [[2]] # [[1, 2]] # [[0, 1, 2]] # [[0, 1, 2]] # 순열도 제일 마지막에 첨가하면, 조합처럼 n-1개 완성 + 1개요소(n가지)가 된다? result += [[elem]+P] print(result) break return result arr = [0, 1, 2, 3, 4, 5] print(gen_permutations(arr, 3)) . [[2]] [[1, 2]] [[0, 1, 2]] [[0, 1, 2]] . &#51221;&#45813; . # itertools.permutation를 이용하면, for문을 사용하지 않고도 순열을 구할 수 있습니다. import itertools # pool = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] pool = &#39;ABC&#39; print(list(map(&#39;&#39;.join, itertools.permutations(pool)))) # 3개의 원소로 수열 만들기 print(list(map(&#39;&#39;.join, itertools.permutations(pool, 2)))) # 2개의 원소로 수열 만들기 . [&#39;ABC&#39;, &#39;ACB&#39;, &#39;BAC&#39;, &#39;BCA&#39;, &#39;CAB&#39;, &#39;CBA&#39;] [&#39;AB&#39;, &#39;AC&#39;, &#39;BA&#39;, &#39;BC&#39;, &#39;CA&#39;, &#39;CB&#39;] . &#45712;&#45184;&#51216;(itertools.permutations , combinations) . 문자열로 1글자씩으로 구성된 iter라 순열 또는 조합을 구할 수 있다. 리스트는 튜플 조합 리스트로 / 문자열을 문자열그대로의 리스트로 반환됨. | . | 원하는 구성원소갯수를 지정할 수 있다. | . (&#52428;)&#44032;&#51109; &#47566;&#51060; &#46321;&#51109;&#54616;&#45716; &#50508;&#54028;&#48307; &#52286;&#44592; - Counter . 문제 설명 이 문제에는 표준 입력으로 문자열, mystr이 주어집니다. mystr에서 가장 많이 등장하는 알파벳만을 사전 순으로 출력하는 코드를 작성해주세요. 제한 조건 mystr의 원소는 알파벳 소문자로만 주어집니다. mystr의 길이는 1 이상 100 이하입니다. 예시 input output &#39;aab&#39; &#39;a&#39; &#39;dfdefdgf&#39; &#39;df&#39; &#39;bbaa&#39; &#39;ab&#39; . &#45236;&#54400;&#51060; . dict에 단어마다 count 저장함 | dict를 sorted( , reverse=True, key=lambda x:x[1])로 밸류순으로 역순으로 정렬 -&gt; 가장 첫밸류값이 가장 최대값 | 첫, 두번째 밸류 동점일 수 있으니, value만 뽑은 뒤.. dict.items()를 돌면서 value가 같은 것을 출력함. | . my_str = input().strip() counter_dict = {} for key in my_str: counter_dict.setdefault(key, 0) counter_dict[key]+=1 max_value = sorted(counter_dict.items(), key=lambda x:x[1],reverse=True)[0][1] answer_list = [] for k,v in counter_dict.items(): if v == max_value: answer_list.append(k) print(&#39;&#39;.join(sorted(answer_list))) . aab a . &#51221;&#45813; . # 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통 사람들은 반복문을 이용해 수를 셉니다. my_list = [1, 2, 3, 4, 5, 6, 7, 8, 7, 9, 1, 2, 3, 3, 5, 2, 6, 8, 9, 0, 1, 1, 4, 7, 0] answer = {} for number in my_list: try: answer[number] += 1 except KeyError: answer[number] = 1 print(answer[1]) # = 4 print(answer[3]) # = 3 print(answer[100]) # = raise KeyError . import collections my_str = input().strip() answer = collections.Counter(my_str) print(answer) # dict형태로 출력됨. #Counter객체는 .most_common() 으로 key, count의 튜플리스트가 나옴. answer.most_common() # . asdklfjaskdfekekjek Counter({&#39;k&#39;: 5, &#39;e&#39;: 3, &#39;a&#39;: 2, &#39;s&#39;: 2, &#39;d&#39;: 2, &#39;f&#39;: 2, &#39;j&#39;: 2, &#39;l&#39;: 1}) . [(&#39;k&#39;, 5), (&#39;e&#39;, 3), (&#39;a&#39;, 2), (&#39;s&#39;, 2), (&#39;d&#39;, 2), (&#39;f&#39;, 2), (&#39;j&#39;, 2), (&#39;l&#39;, 1)] . dict_ = {&#39;k&#39;: 5, &#39;e&#39;: 3, &#39;a&#39;: 2, &#39;s&#39;: 2, &#39;d&#39;: 2, &#39;f&#39;: 2, &#39;j&#39;: 2, &#39;l&#39;: 1} dict_.values() # dict_.keys(), dict_.items() max(answer.values()) . 5 . # -&gt; values로 max값 바로 찾을 수 있다. # -&gt; max값을 알 때, for문을 돌면서, key값들을 누적할 수 있다? # -&gt; max값이 여러개일 수 있으니, 미리구한 최대값 == count 하면서 돌아야한다. my_list = input() max_count = max(collections.Counter(my_list).values()) [ word for word, count in collections.Counter(my_list).items() if count == max_count] . aaadddwqierie . [&#39;a&#39;, &#39;d&#39;] . &#45712;&#45184;&#51216; ( collections.Counter - dict + .most_common() ) . 비 파이썬이라도 dict에 저장하는 것은 똑같았다. | collections.Counter() -&gt; dict와 유사하니, Counter.values()로 max()를 구하고 | list comp로 Counter.items()를 k,v를 받아서 필터링하자 | . | 빈도순으로 튜플리스트를 반환하는 것은 .most_common()이다. | &#44592;&#53440; (7) . for &#47928;&#44284; if&#47928;&#51012; &#54620;&#48264;&#50640; - List comprehension&#51032; if &#47928; . 문제 설명 정수를 담은 리스트 mylist를 입력받아, 이 리스트의 원소 중 짝수인 값만을 제곱해 담은 새 리스트를 리턴하는 solution함수를 완성해주세요. 예를 들어, [3, 2, 6, 7]이 주어진 경우 3은 홀수이므로 무시합니다. 2는 짝수이므로 제곱합니다. 6은 짝수이므로 제곱합니다. 7은 홀수이므로 무시합니다. 따라서 2의 제곱과 6의 제곱을 담은 리스트인 [4, 36]을 리턴해야합니다. 제한 조건 mylist는 길이가 100이하인 배열입니다. mylist의 원소는 1이상 100 이하인 정수입니다. . mylist = [3, 2, 6, 7] answer = [number**2 for number in mylist if number % 2 == 0] answer . [4, 36] . &#45712;&#45184;&#51216;( X ) . mylist = [3, 2, 6, 7] answer = [] for number in mylist: if number % 2 == 0: answer.append(number**2) # 들여쓰기를 두 번 함 # 파이썬의 list comprehension을 사용하면 한 줄 안에 for 문과 if 문을 한 번에 처리할 수 있습니다. mylist = [3, 2, 6, 7] answer = [number**2 for number in mylist if number % 2 == 0] . (&#52428;) flag&#48320;&#49688; &#45824;&#49888; for-else &#49324;&#50857;&#54616;&#44592; . 문제 설명 본 문제에서는 자연수 5개가 주어집니다. 숫자를 차례로 곱해 나온 수가 제곱수가 되면 found를 출력하고 모든 수를 곱해도 제곱수가 나오지 않았다면 not found를 출력하는 코드를 작성해주세요. 예시 1 입력 2 4 2 5 1 출력 found 설명 수를 곱해나가면 2, 8, 16, 80, 80 이 나옵니다. 16은 4를 제곱해 나온 수이므로 이 수는 제곱수입니다. 따라서 found를 출력합니다. 예시 2 입력 5 1 2 3 1 출력 not found 설명 수를 곱해나가면 5, 5, 10, 30, 30 이 나옵니다. 이중 어떤 수도 제곱 수가 아니므로 not found를 출력합니다. . data = [ int(input()) for _ in range(5)] import math product = 1 check=False for n in data: product*=n if math.sqrt(product) == int(math.sqrt(product)) : print(&#39;found&#39;) check=True break if check == False: print(&#39;not found&#39;) . 2 4 2 5 1 2 1.4142135623730951 8 2.8284271247461903 16 4.0 found 2 not found . &#51221;&#45813; . # https://harryp.tistory.com/317 [Park&#39;s Life] import math data = [ int(input()) for _ in range(5)] product = 1 # check=False # 1. for내부에 if로 끊김을 나타내는 flag변수를 안쓴다. for n in data: product*=n if math.sqrt(product) == int(math.sqrt(product)) : print(&#39;found&#39;) #check=True break # if check == False: # 2. for가 안끊기고 다 돌았다면, else문 실행시킨다. else: print(&#39;not found&#39;) . 2 4 2 5 1 found . &#45712;&#45184;&#51216;( flag&#48320;&#49688; &#45824;&#49888; for-else&#47928; -&gt; for if &#52286;&#50520;&#51004;&#47732; flag break &#45824;&#49888; for if &#52286;&#50520;&#51004;&#47732;&#52376;&#47532; else&#47803;&#52286;&#50520;&#45796;&#52376;&#47532; + &#51228;&#44273;&#49688; + &#49548;&#49688;&#51216;.0&#51032; int&#54869;&#51064;) . for_if 조건: break -&gt; 만약 다 돌았는데도 if brea에 안걸린 not found == for 다돈 경우 else 조건X시 처리 . 원래는.. for문 내부에서 if 걸렸다? -&gt; break하고 for문 뒤에는 실행 X 를 for문 밖 flag=True/False 변수에 전달해줬다. | 이제는 for문 if 걸려서 flag = True + break -&gt; if flag: 처리는 하지 말자. for문 if 걸려서 break -&gt; 만약 안걸리고 다돌면 처리를 else문에서 | . | . | 제곱수의 판단 : math.sqrt()를 씌웠을 때 int여야한다. . 하지만 sqrt()씌우는 순간 int라도 2.0 3.0 이 되어버린다. | 정수.0의 int 판단방법 int()변환값 == 현재값 ( 전환된 값의 비교로 판단 ) | . | cf) 정수 판단 방법 isinstance( , int) | type( v ) == int | . | . | . &#46160; &#48320;&#49688;&#51032; &#44050; &#48148;&#44984;&#44592; - swap . # 비 파이썬은 덮어쓰기 당할 변수값을 temp에 넣어놓고 덮어쓰기 -&gt; 다른쪽 덮어쓰기 a = 3 b = &#39;abc&#39; temp = a a = b b = temp . 파이썬에서는 다음과 같이 한 줄로 두 값을 바꿔치기할 수 있음. . a = 3 b = &#39;abc&#39; a, b = b, a . (&#52428;) &#51060;&#51652; &#53456;&#49353;&#54616;&#44592; - bisect &#47784;&#46280; . 알고리즘 문제를 풀다 보면 이진 탐색을 써야할 때가 많습니다. 이런 문제를 풀 때마다 이진 탐색 알고리즘을 작성하는 건 비효율적이지요. 이번 시간엔 Python의 이진 탐색 모듈, bisect를 알아봅시다. | . # - while문에 if 탈출(break or def-return)이 없다? -&gt; 다돌고 &lt;조건문 직후 상태&gt;로 빠져나와서 최종 처리한다는 뜻 # ex&gt; while low &lt; high -&gt; low &gt;= high순간에 빠져나옴. 주로 직후인 low==high에서 빠져나와 마지막 처리 def bisect(a, x, lo=0, hi=None): if lo &lt; 0: raise ValueError(&#39;lo must be non-negative&#39;) if hi is None: hi = len(a) while lo &lt; hi: mid = (lo + hi) // 2 if a[mid] &lt; x: lo = mid + 1 else: hi = mid return lo mylist = [1, 2, 3, 7, 9, 11, 33] print(bisect(mylist, 5)) # ??? 없는 것도 나온다? . 3 . # 실제 list index의 +1을 반환하는 것 같다. # ** 해당 숫자 n을 어디에 insert해야하는지의 위치를 보여준다.** # 1) 같은게 있으면? 그 index +1 자리에 넣어라 # 2) 같은게 없으면? 오름차순으로 넣어야할 자리는 여기다. import bisect mylist = [1, 2, 3, 7, 9, 11, 33] print(bisect.bisect(mylist, 9)) # 같은게 4에 있으니 5번째 들어가야한다. print(bisect.bisect(mylist, 33)) # 같은게 6에 있으니 7에 들어가야한다. print(bisect.bisect(mylist, 5)) # 없는데 &lt;&lt;오름차순&gt;&gt; 4-&gt;value 3 뒤의 5자리에 들어가야한다. . 5 7 3 . # index 함수는 이진 탐색이 아닌 선형 탐색 함수입니다. # (물론 주어진 input에 대해서 index 함수를 쓰면 정확한 output 값을 얻을 수 있긴 합니다.) # 이진탐색의 시간복잡도는 O(logN) 이나, # index 함수는 선형탐색을 하므로 시간복잡도가 O(N)이라 시간이 오래 걸립니다. # bisect.bisect(mylist, n)의 n은 mylist에서 찾고자하는 값입니다. # bisect.bisect(mylist, n)이 리턴하는 값, x는 mylist에서 n이 위치한 index의 오른쪽 값을 나타냅니다. # insertion point를 리턴합니다. 즉, 3의 인덱스는 2이므로 이 다음에 있는 insertion point는 2+1 = 3이 되는 것이지요. # 말씀하신대로 bisect는 key 가 없으면 key가 들어갈 위치를 반환합니다. . # - 내뱉은 point가 .. 직전에 같은값이 있어서 그 바로 뒤라면? i-1 반환 # - 내뱉은 point가.. 직전에 같은값은 없으나.. 순서라서 줬다면? 그냥 탐색 실패-&gt; -1반환 import bisect def b_s(ary,key): i= bisect.bisect(ary,key) return i-1 if ary[i-1]==key else -1 . &#45712;&#45184;&#51216;(bisect.bisect( list, value) &gt; return or insert point, &#48148;&#47196;&#50526;&#50640; &#51080;&#44144;&#45208; &#47803;&#52286;&#50520;&#51648;&#47564; &#51221;&#47148;&#49345; &#44536;&#51088;&#47532;) . 정렬된 list라면, 이진탐색을 bisect.bisect로 할 수 있다. return된 값이. 실제 있떤 값이면 i + 1 = return값이다. -&gt; return값 - 1을 하자 | return된 값이. 없으나 정렬상 그자리에 들어가라고 return한 값이다 -&gt; ??? 직전과 값이 같앗 뱉은 건지 확인해야한다. if number == list[return value - 1] -&gt;returnvalue -1 else None.. | . | . | . &#53364;&#47000;&#49828; &#51064;&#49828;&#53556;&#49828; &#52636;&#47141;&#54616;&#44592; - class&#51032; &#51088;&#46041; string casting . 이번 강의에서는 인스턴스 출력 형식을 지정하는 방법을 배워봅시다. . 예) 2차원 평면 위의 점을 나타내는 Coord 클래스의 인스턴스를 (x 값, y 값)으로 출력하기 . class Coord(object): def __init__(self, x, y): self.x, self.y = x, y point = Coord(1, 2) print( &#39;({}, {})&#39;.format(point.x, point.y) ) # 또는 def print_coord(coord): print( &#39;({}, {})&#39;.format(coord.x, coord.y) ) print_coord(point) . # __str__ 메소드를 사용해 class 내부에서 **출력 format**을 지정할 수 있습니다. class Coord(object): def __init__ (self, x, y): self.x, self.y = x, y def __str__ (self): return &#39;({}, {})&#39;.format(self.x, self.y) point = Coord(1, 2) print(point) point . (1, 2) . &lt;__main__.Coord at 0x1ed8d397e80&gt; . &#45712;&#45184;&#51216; ( str&#50724;&#48260;&#46972;&#51060;&#46377; ) . print + interpret에 출력까지 될라면 repr를 오버라이딩한다. | 객체정보를 직접 찍어보지말자! 메소드 정의(비파이썬) 나 메소드 오버라이딩으로 확인하자.! | (&#52428;) &#44032;&#51109; &#53360; &#49688;, inf . 코딩 테스트 문제 등을 풀다 보면, 최솟값을 저장하는 변수에 아주 큰 값을 할당해야 할 때가 있습니다. 이번 시간에는 이때에 사용하기 좋은 inf에 대해 알아봅시다. . 이 기능을 모르시는 분은 본인이 생각하는 임의의 큰 수(99999등)를 할당합니다. . # 비파이썬에서, 최소값을 구할려구 미리 큰값을 넣어올 때, min_val = 99999 min_val &gt; 100000000 # ? . # 파이썬에서, 최소값을 구할려구 미리 큰값을 넣어올 때, # 파이썬이 제공하는 inf 를 사용. inf는 어떤 숫자와 비교해도 무조건 크다고 판정 min_val = float(&#39;inf&#39;) min_val &gt; 10000000000 . inf에는 음수 기호를 붙이는 것도 가능합니다. . max_val = float(&#39;-inf&#39;) . &#45712;&#45184;&#51216; - float(&#39;inf&#39;), float(&#39;-inf&#39;) . 최대값을 찾을 때, 일단 작은값을 변수에 넣어놓고 돈다. 가장 작은 값은 float(&#39;-inf&#39;) / 가장 큰 값은 float(&#39;inf&#39;) 로 초기값을 넣고 해결하자! | . | float(&#39;inf&#39;) . inf . float(&#39;-inf&#39;) . -inf . &#54028;&#51068; &#51077;&#52636;&#47141; &#44036;&#45800;&#54616;&#44172; &#54616;&#44592; - with open as f for line in f.readlines() . 이번 강의에서는 파일 입출력 코드를 간결하게 짜는 법을 알아봅시다. . &#39;myfile.txt&#39;라는 이름의 파일을 읽는 코드를 짜보세요 . # 1. open -&gt; 2. 반복문 while -&gt; 3.line = readlins() + if not line: break + line처리 -&gt; 4. close f = open(&#39;myfile.txt&#39;, &#39;r&#39;) while True: line = f.readline() if not line: break raw = line.split() print(raw) f.close() . FileNotFoundError Traceback (most recent call last) &lt;ipython-input-467-4f9a0ee2adde&gt; in &lt;module&gt; 1 # 비파이썬 2 # 1. open -&gt; 2. 반복문 while -&gt; 3.line = readlins() + if not line: break + line처리 -&gt; 4. close -&gt; 3 f = open(&#39;myfile.txt&#39;, &#39;r&#39;) 4 while True: 5 line = f.readline() FileNotFoundError: [Errno 2] No such file or directory: &#39;myfile.txt&#39; . # with - as 구문을 이용하면 코드를 더 간결하게 짤 수 있습니다. 코드를 아래와 같이 쓰면 다음과 같은 장점이 있습니다. # 1. 파일을 close 하지 않아도 됩니다: with - as 블록이 종료되면 파일이 자동으로 close 됩니다. # 2. readlines가 EOF까지만 읽으므로, while 문 안에서 EOF를 체크할 필요가 없습니다. # my) python은 readlines()가 EOF를 알아서 인식하니 -&gt; 반복문 in 자리에 넣으면 된다. -&gt; EOF 체크 필요없음. with open(&#39;myfile.txt&#39;) as file: for line in file.readlines(): print(line.strip().split(&#39; t&#39;)) . FileNotFoundError Traceback (most recent call last) &lt;ipython-input-468-1cec8ae34904&gt; in &lt;module&gt; 5 6 # my) python은 readlines()가 EOF를 알아서 인식하니 -&gt; 반복문 in 자리에 넣으면 된다. -&gt; EOF 체크 필요없음. -&gt; 7 with open(&#39;myfile.txt&#39;) as file: 8 for line in file.readlines(): 9 print(line.strip().split(&#39; t&#39;)) FileNotFoundError: [Errno 2] No such file or directory: &#39;myfile.txt&#39; . &#45712;&#45184;&#51216; - with as &#50752; python readlines() . with as f -&gt; close 안해도됨 + f.readlines()시 EOF 체크 자동으로 되니 반복문에 바로 삽입 | boj input() 등 f.readlines()와 달리 언제 EOF인지는 모를 땐, try except EOFError로 break해주자. | &#52280;&#44256;) &#51077;&#47141;&#51032; &#45149;(EOF) &#54869;&#51064; by except EOFError: break . f.readlines()는 알아서 EOF(end of file)을 체크하지만, boj등 input()이 언제 EOF인지는 모르니까, try except EOFError로 break해주자. | . | . while 1: try: ins=input() ans = fun(ins) if ans == -1: break; else: print(ans) except EOFError: break .",
            "url": "blog.chojaeseong.com/algorithm/2021/08/11/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_python_pythonic.html",
            "relUrl": "/algorithm/2021/08/11/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_python_pythonic.html",
            "date": " • Aug 11, 2021"
        }
        
    
  
    
        ,"post91": {
            "title": "알고리즘 문제 풀기용 input 코드 모음(python)",
            "content": "&#52280;&#44256; . 블로그 | 그외 백준 공식 레퍼런스 | . input.txt&#47484; &#51060;&#50857;&#54620; local &#54400;&#51060; &#44396;&#51312; . 폴더 input.txt | xxx.py | . | . import sys sys.stdin = open(&quot;./input.txt&quot;, &quot;rt&quot;) # jupyter notebook시 필수 input = sys.stdin.readline # 콘솔에선 미리 안해도되며, 속도향상 필요시만 해준다. / ###################################################### N = int(input()) # print(N) data = list(map(int, input().split())) # print(data) . &#44277;&#48177; &#44592;&#51456; &#45936;&#51060;&#53552; &#51077;&#47141;&#48155;&#44592;(map, int, input.split ) . map객체를 이용해 str -&gt; int 변환했지만, sequence는 아니라 인덱싱을 못한다. a, b = map : 인덱싱은 못해도 할당시 나눠받을 수 있다. | list_ = list(map) : 할당시 나눠받기가 불가능할 정도로 많으면, list()로 sequence로 변환시켜 받아야한다. | . | . # - 1개는 map쓰지말자~! n = int(input().strip()) # 2개 - int a, b= map(int, input().split()) # for문으로 n번 2개씩 n = int(input().strip()) for _ in range(n): a, b= map(int, input().split()) # 3개이상의 - list data = list(map(int, input().split())) # for문으로 n번 3개이상시 n = int(input().strip()) for _ in range(n): data = list(map(int, input().split())) . &#49884;&#44036;&#51012; &#45908; &#48736;&#47476;&#44172; &#45936;&#51060;&#53552; &#51077;&#47141;&#48155;&#44592;(sys &#47784;&#46280;) . sys.stdin.readline() 사용 | 단, 입력 후 엔터가 사용되므로 rstrip() 를 함께 사용 | . import sys str = sys.stdin.readline().rstrip() # 1개 - int import sys n = sys.stdin.readline() # 2개 int import sys N, M = map(int, sys.stdin.readline().split()) # 2차원 리스트 입력 받기 # - 행의 수 N을 입력받고, 각 행의 데이터들을 한번에 받아서 split()해서 열로 들어간다. import sys N = sys.stdin.readline() board = [list(map(int,sys.stdin.readline().split())) for _ in range(N)] . ValueError Traceback (most recent call last) &lt;ipython-input-11-198e9d917b91&gt; in &lt;module&gt; 9 # 2개 int 10 import sys &gt; 11 N, M = map(int, sys.stdin.readline().split()) 12 13 ValueError: not enough values to unpack (expected 2, got 0) . &#44277;&#48177;&#44592;&#51456; &#52636;&#47141;&#49884; *(&#49324;&#50857;&#49884;&#50616;&#54056;&#53433;)&#51004;&#47196; . result = [1, 2, 3] # 기본적인 리스트 출력시 print(result) # [1,2,3] # for loop으로 원소를 하나씩 출력 for i in range(len(result)): print(result[i], end=&#39; &#39;) # 1 2 3 # 리스트의 원소를 언패킹 시켜서 출력 print(*result) # 1 2 3 . [1, 2, 3] 1 2 3 1 2 3 . N x M &#53356;&#44592;&#51032; &#51060;&#52264;&#50896; &#47532;&#49828;&#53944; &#52488;&#44592;&#54868; &#48143; &#51077;&#47141;&#48155;&#44592; . 시뮬레이션 문제에서 주어지는 입력 중 가장 많은 형태의 입력을 list comprehension 으로 받을 수 있다. . n, m = map(int, input().split()) board = [list(map(int, input().split())) for _ in range(n)] visited = [[False]*m for _ in range(n)] print(visited) print(board) # 입력(행 열 -&gt; 열의 갯수만큼 False==0으로 채워진 행x열의 visited 2차원 리스트) # 5 9 # 0 0 0 0 0 0 0 0 0 # 0 0 0 1 1 0 0 0 0 # 0 0 0 1 1 0 1 1 0 # 0 0 1 1 1 1 1 1 0 # 0 0 1 1 1 1 1 0 0 . [[False, False, False, False, False], [False, False, False, False, False], [False, False, False, False, False]] [[3], [3], [3]] . &#51116;&#44480;&#54632;&#49688;&#50640;&#49436; &#53084;&#49828;&#53469; &#51228;&#54620;(&#51116;&#44480;&#54620;&#46020;) &#54400;&#50612;&#51452;&#44592; . import sys; sys.setrecursionlimit(10000) .",
            "url": "blog.chojaeseong.com/algorithm/2021/08/10/boj_input_codes.html",
            "relUrl": "/algorithm/2021/08/10/boj_input_codes.html",
            "date": " • Aug 10, 2021"
        }
        
    
  
    
        ,"post92": {
            "title": "타이타닉 정리",
            "content": "import numpy as np import pandas as pd # %matplotlib nbagg %matplotlib inline import matplotlib.pyplot as plt import matplotlib import seaborn as sns sns.set(font_scale=1.5) sns.set_style(&#39;whitegrid&#39;) #whitegrid sns.set_palette(&#39;muted&#39;) # 한글사용가능하게하기 from matplotlib import font_manager font_name = font_manager.FontProperties(fname=&#39;C:/Windows/Fonts/malgun.ttf&#39;).get_name() matplotlib.rc(&#39;font&#39;, family=font_name) print (plt.rcParams[&#39;font.family&#39;] ) . [&#39;Malgun Gothic&#39;] . &#45936;&#51060;&#53552; &#47196;&#46377; . import pandas as pd train = pd.read_csv(&#39;data/titanic/train.csv&#39;) test = pd.read_csv(&#39;data/titanic/test.csv&#39;) . &#45936;&#51060;&#53552; &#54869;&#51064; . train과 test 비교후, test에 없는 칼럼이 종속변수 | head()와 info()를 비교하여 범주형과 숫자형의 type이 제대로 되었는지 확인하기 | . print(train.shape) print(train.columns) train.head() . (891, 12) Index([&#39;PassengerId&#39;, &#39;Survived&#39;, &#39;Pclass&#39;, &#39;Name&#39;, &#39;Sex&#39;, &#39;Age&#39;, &#39;SibSp&#39;, &#39;Parch&#39;, &#39;Ticket&#39;, &#39;Fare&#39;, &#39;Cabin&#39;, &#39;Embarked&#39;], dtype=&#39;object&#39;) . PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | male | 22.0 | 1 | 0 | A/5 21171 | 7.2500 | NaN | S | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | female | 38.0 | 1 | 0 | PC 17599 | 71.2833 | C85 | C | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | female | 26.0 | 0 | 0 | STON/O2. 3101282 | 7.9250 | NaN | S | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 | 1 | 0 | 113803 | 53.1000 | C123 | S | . 4 5 | 0 | 3 | Allen, Mr. William Henry | male | 35.0 | 0 | 0 | 373450 | 8.0500 | NaN | S | . train.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 891 entries, 0 to 890 Data columns (total 12 columns): PassengerId 891 non-null int64 Survived 891 non-null int64 Pclass 891 non-null int64 Name 891 non-null object Sex 891 non-null object Age 714 non-null float64 SibSp 891 non-null int64 Parch 891 non-null int64 Ticket 891 non-null object Fare 891 non-null float64 Cabin 204 non-null object Embarked 889 non-null object dtypes: float64(2), int64(5), object(5) memory usage: 83.6+ KB . print(test.shape) print(test.columns) test.head() . (418, 11) Index([&#39;PassengerId&#39;, &#39;Pclass&#39;, &#39;Name&#39;, &#39;Sex&#39;, &#39;Age&#39;, &#39;SibSp&#39;, &#39;Parch&#39;, &#39;Ticket&#39;, &#39;Fare&#39;, &#39;Cabin&#39;, &#39;Embarked&#39;], dtype=&#39;object&#39;) . PassengerId Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked . 0 892 | 3 | Kelly, Mr. James | male | 34.5 | 0 | 0 | 330911 | 7.8292 | NaN | Q | . 1 893 | 3 | Wilkes, Mrs. James (Ellen Needs) | female | 47.0 | 1 | 0 | 363272 | 7.0000 | NaN | S | . 2 894 | 2 | Myles, Mr. Thomas Francis | male | 62.0 | 0 | 0 | 240276 | 9.6875 | NaN | Q | . 3 895 | 3 | Wirz, Mr. Albert | male | 27.0 | 0 | 0 | 315154 | 8.6625 | NaN | S | . 4 896 | 3 | Hirvonen, Mrs. Alexander (Helga E Lindqvist) | female | 22.0 | 1 | 1 | 3101298 | 12.2875 | NaN | S | . test.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 418 entries, 0 to 417 Data columns (total 11 columns): PassengerId 418 non-null int64 Pclass 418 non-null int64 Name 418 non-null object Sex 418 non-null object Age 332 non-null float64 SibSp 418 non-null int64 Parch 418 non-null int64 Ticket 418 non-null object Fare 417 non-null float64 Cabin 91 non-null object Embarked 418 non-null object dtypes: float64(2), int64(4), object(5) memory usage: 36.0+ KB . &#52860;&#47100;&#47749; &#49548;&#47928;&#51088;&#47196; &#51068;&#44292;&#48320;&#44221; . &#48169;&#48277;1 : &#46357;&#49492;&#45320;&#47532; &#54805;&#53468;&#47196; &#48320;&#44221;( &#51068;&#48512;&#48516;&#47564; &#44032;&#45733;) . train = train.rename( columns = { &#39;PassengerId&#39; : &#39;passengerid&#39;, &#39;Pclass&#39; : &#39;pclass&#39; , &#39;Name&#39; : &#39;name&#39;, &#39;Sex&#39; : &#39;sex&#39;, &#39;Age&#39; : &#39;age&#39;, &#39;SibSp&#39; : &#39;sibsp&#39;, &#39;Ticket&#39; : &#39;ticket&#39; , &#39;Fare&#39; : &#39;fare&#39;, &#39;Cabin&#39; : &#39;cabin&#39;, &#39;Embarked&#39; : &#39;embarked&#39;, &#39;Parch&#39; : &#39;Parch&#39;.lower() , &#39;Survived&#39; : &#39;survived&#39;, }) . test = test.rename( columns = { &#39;PassengerId&#39; : &#39;passengerid&#39;, &#39;Pclass&#39; : &#39;pclass&#39; , &#39;Name&#39; : &#39;name&#39;, &#39;Sex&#39; : &#39;sex&#39;, &#39;Age&#39; : &#39;age&#39;, &#39;SibSp&#39; : &#39;sibsp&#39;, &#39;Ticket&#39; : &#39;ticket&#39; , &#39;Fare&#39; : &#39;fare&#39;, &#39;Cabin&#39; : &#39;cabin&#39;, &#39;Embarked&#39; : &#39;embarked&#39;, &#39;Parch&#39; : &#39;Parch&#39;.lower() , # &#39;Survived&#39; : &#39;survived&#39;, }) . &#47532;&#49828;&#53944; &#52980;&#54532;&#47532;&#54760;&#49496;&#51012; &#53685;&#54620; &#54620;&#48264;&#50640; &#49548;&#47928;&#51088; &#52376;&#47532; . train.columns . Index([&#39;passengerid&#39;, &#39;survived&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;age&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;ticket&#39;, &#39;fare&#39;, &#39;cabin&#39;, &#39;embarked&#39;], dtype=&#39;object&#39;) . [col.lower() for col in train.columns] . [&#39;passengerid&#39;, &#39;survived&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;age&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;ticket&#39;, &#39;fare&#39;, &#39;cabin&#39;, &#39;embarked&#39;] . train.columns = [col.lower() for col in train.columns] train.head() . passengerid survived pclass name sex age sibsp parch ticket fare cabin embarked . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | male | 22.0 | 1 | 0 | A/5 21171 | 7.2500 | NaN | S | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | female | 38.0 | 1 | 0 | PC 17599 | 71.2833 | C85 | C | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | female | 26.0 | 0 | 0 | STON/O2. 3101282 | 7.9250 | NaN | S | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 | 1 | 0 | 113803 | 53.1000 | C123 | S | . 4 5 | 0 | 3 | Allen, Mr. William Henry | male | 35.0 | 0 | 0 | 373450 | 8.0500 | NaN | S | . &#48276;&#51452; &lt;-&gt; &#49707;&#51088; type &#51228;&#45824;&#47196; &#46104;&#50632;&#45716;&#51648; &#54869;&#51064; . Pclass 범주인데 숫자로 | Survived 범주인데 숫자로 | Parch 도 | Sipsp 도 | . train[&#39;survived&#39;] = train[&#39;survived&#39;].astype( object ) train[&#39;pclass&#39;] = train[&#39;pclass&#39;].astype( object ) train[&#39;parch&#39;] = train[&#39;parch&#39;].astype( object ) train[&#39;sibsp&#39;] = train[&#39;sibsp&#39;].astype( object ) . test[&#39;pclass&#39;] = test[&#39;pclass&#39;].astype( object ) train[&#39;parch&#39;] = train[&#39;parch&#39;].astype( object ) train[&#39;sibsp&#39;] = train[&#39;sibsp&#39;].astype( object ) . Null &#52404;&#53356; . train.isnull().sum() . passengerid 0 survived 0 pclass 0 name 0 sex 0 age 177 sibsp 0 parch 0 ticket 0 fare 0 cabin 687 embarked 2 dtype: int64 . train.isnull().sum().reset_index() . index 0 . 0 passengerid | 0 | . 1 survived | 0 | . 2 pclass | 0 | . 3 name | 0 | . 4 sex | 0 | . 5 age | 177 | . 6 sibsp | 0 | . 7 parch | 0 | . 8 ticket | 0 | . 9 fare | 0 | . 10 cabin | 687 | . 11 embarked | 2 | . missing_df = train.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df . columns count . 0 passengerid | 0 | . 1 survived | 0 | . 2 pclass | 0 | . 3 name | 0 | . 4 sex | 0 | . 5 age | 177 | . 6 sibsp | 0 | . 7 parch | 0 | . 8 ticket | 0 | . 9 fare | 0 | . 10 cabin | 687 | . 11 embarked | 2 | . missing_df = train.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df[&#39;missing_rate&#39;] = missing_df[&#39;count&#39;] / train.shape[0] # 미싱 갯수 / 전체데이터의 데이터수 - shape(row,col)의 첫번째!! missing_df . columns count missing_rate . 0 passengerid | 0 | 0.000000 | . 1 survived | 0 | 0.000000 | . 2 pclass | 0 | 0.000000 | . 3 name | 0 | 0.000000 | . 4 sex | 0 | 0.000000 | . 5 age | 177 | 0.198653 | . 6 sibsp | 0 | 0.000000 | . 7 parch | 0 | 0.000000 | . 8 ticket | 0 | 0.000000 | . 9 fare | 0 | 0.000000 | . 10 cabin | 687 | 0.771044 | . 11 embarked | 2 | 0.002245 | . train . missing_df = train.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df[&#39;missing_rate&#39;] = missing_df[&#39;count&#39;] / train.shape[0] # 미싱 갯수 / 전체데이터의 데이터수 - shape(row,col)의 첫번째!! missing_df.loc[ missing_df[&#39;missing_rate&#39;] != 0, :] # missing_Rate가 0이 아닌 것들만 가졍괴 . columns count missing_rate . 5 age | 177 | 0.198653 | . 10 cabin | 687 | 0.771044 | . 11 embarked | 2 | 0.002245 | . test . missing_df = test.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df[&#39;missing_rate&#39;] = missing_df[&#39;count&#39;] / test.shape[0] # 미싱 갯수 / 전체데이터의 데이터수 - shape(row,col)의 첫번째!! missing_df.loc[ missing_df[&#39;missing_rate&#39;] != 0, :] # missing_Rate가 0이 아닌 것들만 가졍괴 . columns count missing_rate . 4 age | 86 | 0.205742 | . 8 fare | 1 | 0.002392 | . 9 cabin | 327 | 0.782297 | . &#51333;&#49549;&#48320;&#49688; &#54869;&#51064; &#48143; &#51333;&#49549;&#48320;&#49688;&#50640; &#45824;&#54620; &#45796;&#47480;&#48320;&#49688;&#46308; &#44288;&#44228; &#52628;&#47200; . &#51333;&#49549;&#48320;&#49688;&#51032; &#48276;&#51452;&#48324; &#48712;&#46020; &#52404;&#53356; . matplotlib &#44592;&#48376; . train[&#39;survived&#39;].value_counts().plot(kind=&#39;bar&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x259dad8add8&gt; . sns . fig, ax = plt.subplots(1, 2, # 1x2 Pieplot + barplot figsize= (12,8)) # 1 X1 Pie plot train[&#39;survived&#39;].value_counts().plot.pie( explode = [0, 0.1], autopct = &#39;%1.1f%%&#39;, # 퍼센트는 소수점1자리까지 ax = ax[0], shadow = True ) ax[0].set_title(&#39;Pie plot&#39;) ax[0].set_ylabel(&#39;&#39;) # # 1 X 2 bar plot (sns.countplot) # train[&#39;survived&#39;].value_counts().plot( # kind= &#39;bar&#39;, # ax = ax[1], # ) sns.countplot( &#39;survived&#39;, #칼럼명 data = train, # df ax = ax[1] # 좌표평면 ) plt.tight_layout() . import relationship as r r.categorical_all(train, &#39;survived&#39;) . 0 549 1 342 Name: survived, dtype: int64 . &#45800;&#48320;&#49688; &#53456;&#49353;1 : &#48276;&#51452;&#54805; &#52860;&#47100;&#51032; &#48712;&#46020; . &#48276;&#51452;&#54805; &#52860;&#47100;&#47749;&#47564; &#44032;&#51256;&#50724;&#44592; &amp; id&#50752; &#51333;&#49549;&#48320;&#49688; &#51228;&#50808;&#49884;&#53412;&#44592; . train[&#39;survived&#39;].dtypes . train[&#39;survived&#39;].dtypes == &quot;object&quot; . category_feature = [ col for col in train.columns if train[col].dtypes == &quot;object&quot;] category_feature . [&#39;survived&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;ticket&#39;, &#39;cabin&#39;, &#39;embarked&#39;] . id&#52860;&#47100;&#44284; &#51333;&#49549;&#48320;&#49688;&#52860;&#47100; &#51228;&#50808;&#49884;&#53412;&#44592; by set . # set으로 마이너스 연산을 한 뒤, list()로 감싸서 다시 리스트로 만든다. categorical_feature = list( set(category_feature) - set( [&#39;passengerid&#39;, &#39;survived&#39;]) ) categorical_feature . [&#39;embarked&#39;, &#39;ticket&#39;, &#39;parch&#39;, &#39;cabin&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;sibsp&#39;] . &#48276;&#51452;&#52860;&#47100;&#47749; &#47532;&#49828;&#53944;&#47484; &#51060;&#50857;&#54620; &#48276;&#51452;&#52860;&#47100;&#46308; &#54620;&#44732;&#48264;&#50640; &#48712;&#46020; &#48372;&#44592; . for col in categorical_feature: f, ax = plt.subplots(1, 1, figsize=(10,7)) sns.countplot( col, #칼럼명 data = train, # df ) plt.title(col) plt.show() # 여러개 그림을 한셀에 띄울 때, plt.show()를 통해 하나씩 끊어주기! . &#54632;&#49688;&#54868;&#54616;&#44592; ( &#45800;&#48320;&#49688; &#48276;&#51452;&#54805; &#52860;&#47100;&#51032; &#48712;&#46020; ) with &#48276;&#51452;&#54805; &#52860;&#47100;&#47749; &#47532;&#49828;&#53944; . def categorical_all(df, categorical_feature): # 칼럼명 하나만 입력시 if type(categorical_feature) is str: sns.countplot( categorical_feature, #칼럼명 1개 data = df, # df ) plt.title(categorical_feature) #칼럼명 1개 plt.tight_layout() plt.show() # 여러개 그림을 한셀에 띄울 때, plt.show()를 통해 하나씩 끊어주기! else: # 범주형 칼럼명 리스트가 들어왔을 때 for col in categorical_feature: sns.countplot( col, #칼럼명 data = df, # df ) plt.title(col) plt.tight_layout() plt.show() # 여러개 그림을 한셀에 띄울 때, plt.show()를 통해 하나씩 끊어주기! . categorical_all(train, &#39;cabin&#39;) . categorical_all(train, categorical_feature) . &#45800;&#48320;&#49688; &#53456;&#49353;2 : &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252; . &#49707;&#51088;&#54805; &#52860;&#47100;&#47749; &#44032;&#51256;&#50724;&#44592; = &#51204;&#52404;&#52860;&#47100; - &#48276;&#51452;&#54805;&#52860;&#47100; - (id+&#51333;&#49549;&#48320;&#49688;) . train.head() . passengerid survived pclass name sex age sibsp parch ticket fare cabin embarked . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | male | 22.0 | 1 | 0 | A/5 21171 | 7.2500 | NaN | S | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | female | 38.0 | 1 | 0 | PC 17599 | 71.2833 | C85 | C | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | female | 26.0 | 0 | 0 | STON/O2. 3101282 | 7.9250 | NaN | S | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 | 1 | 0 | 113803 | 53.1000 | C123 | S | . 4 5 | 0 | 3 | Allen, Mr. William Henry | male | 35.0 | 0 | 0 | 373450 | 8.0500 | NaN | S | . numerical_feature = list( set(train.columns) - set(categorical_feature) - set([&#39;passengerid&#39;, &#39;survived&#39;]) ) numerical_feature . [&#39;age&#39;, &#39;fare&#39;] . np.sort(numerical_feature) . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . numerical_feature = list( set(train.columns) - set(categorical_feature) - set([&#39;passengerid&#39;, &#39;survived&#39;]) ) numerical_feature = np.sort(numerical_feature) numerical_feature . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252; sns.distplot &#54620;&#44732;&#48264;&#50640; &#44536;&#47532;&#44592; . for col in numerical_feature: print(train[col].describe()) sns.distplot( train.loc[train[col].notnull(), col] ) # 해당칼럼 중 NaN아닌것만 인덱싱한 칼럼만 그리기 plt.title(col) plt.show() . count 714.000000 mean 29.699118 std 14.526497 min 0.420000 25% 20.125000 50% 28.000000 75% 38.000000 max 80.000000 Name: age, dtype: float64 . count 891.000000 mean 32.204208 std 49.693429 min 0.000000 25% 7.910400 50% 14.454200 75% 31.000000 max 512.329200 Name: fare, dtype: float64 . &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252;2 boxplot . for col in numerical_feature: print(train[col].describe()) sns.boxplot( data=train.loc[train[col].notnull(), col] ) plt.title(col) plt.show() . count 714.000000 mean 29.699118 std 14.526497 min 0.420000 25% 20.125000 50% 28.000000 75% 38.000000 max 80.000000 Name: age, dtype: float64 . count 891.000000 mean 32.204208 std 49.693429 min 0.000000 25% 7.910400 50% 14.454200 75% 31.000000 max 512.329200 Name: fare, dtype: float64 . &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252;( hist(dist) + boxplot ) &#54620;&#48264;&#50640; &#44536;&#47532;&#44592; . for col in numerical_feature: # 숫자형 칼럼의 기술통계량 print(train[col].describe()) print(f&quot;Skewed : {train[col].skew():.2f}&quot;) f, ax = plt.subplots(1, 2, figsize=(18,9)) # dist sns.distplot( train.loc[train[col].notnull(), col], ax = ax[0] ) ax[0].set_title(col +&#39; &#39;s hist(dist) plot&#39; ) # boxplot sns.boxplot( data=train.loc[train[col].notnull(), col], ax = ax[1] ) ax[1].set_title(col +&#39; &#39;s boxplot&#39;) plt.tight_layout() plt.show() . count 714.000000 mean 29.699118 std 14.526497 min 0.420000 25% 20.125000 50% 28.000000 75% 38.000000 max 80.000000 Name: age, dtype: float64 Skewed : 0.39 . count 891.000000 mean 32.204208 std 49.693429 min 0.000000 25% 7.910400 50% 14.454200 75% 31.000000 max 512.329200 Name: fare, dtype: float64 Skewed : 4.79 . &#54632;&#49688;&#54868;&#54616;&#44592; ( &#45800;&#48320;&#49688; &#49707;&#51088;&#54805; &#48516;&#54252; dist+boxplot ) with &#49707;&#51088;&#54805; &#52860;&#47100;&#47749; &#47532;&#49828;&#53944; . def numerical_all(df, numerical_feature): for col in numerical_feature: # 숫자형 칼럼의 기술통계량 print(df[col].describe()) print(f&quot;Skewed : {train[col].skew():.2f}&quot;) f, ax = plt.subplots(1, 2, figsize=(18,9)) # dist sns.distplot( df.loc[train[col].notnull(), col], ax = ax[0] ) ax[0].set_title(col +&#39; &#39;s hist(dist) plot&#39; ) ax[0].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 # boxplot sns.boxplot( data=df.loc[df[col].notnull(), col], ax = ax[1] ) ax[1].set_title(col +&#39; &#39;s boxplot&#39;) ax[1].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 plt.tight_layout() plt.show() . &#51060;&#48320;&#49688; &#53456;&#49353;1 : &#51333;&#49549;&#48320;&#49688;(&#48276;&#51452;)&#48324; - &#48276;&#51452;&#54805; &#48320;&#49688; . &#48169;&#48277;1: &#53945;&#51221;(&#51333;&#49549;)&#48276;&#51452;&#48324; &#48276;&#51452;&#52860;&#47100; &#51064;&#45937;&#49905;&#54616;&#50668;&#49436; &#44033; &#48276;&#51452;&#48324; series&#47484; df&#47196; &#54633;&#52824;&#44592; . survived = train.loc[ train[&#39;survived&#39;] == 0,&#39;sex&#39; ].value_counts() survived.name = &#39;Survived&#39; dead = train.loc[ train[&#39;survived&#39;] == 1,&#39;sex&#39; ].value_counts() dead.name = &#39;Dead&#39; # 시리즈를 리스트형식으로 df합치기 df = pd.DataFrame( [ survived, dead] ) df.head() . male female . Survived 468 | 81 | . Dead 109 | 233 | . print(df) df.plot(kind=&#39;bar&#39;) . male female Survived 468 81 Dead 109 233 . &lt;matplotlib.axes._subplots.AxesSubplot at 0x2962005c550&gt; . &#48169;&#48277;2 : pd.crosstab &#51004;&#47196; &#44536;&#47532;&#44592; . &#48712;&#46020; . pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;]) . survived 0 1 . sex . female 81 | 233 | . male 468 | 109 | . pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;]).plot(kind=&#39;barh&#39;, stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x296212901d0&gt; . pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;], margins = True).style.background_gradient(cmap=&#39;summer_r&#39;) . survived 0 1 All . sex . female 81 | 233 | 314 | . male 468 | 109 | 577 | . All 549 | 342 | 891 | . &#48708;&#50984; . cross = pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;]) cross_ratio = cross / cross.sum() cross_ratio . survived 0 1 . sex . female 0.147541 | 0.681287 | . male 0.852459 | 0.318713 | . cross_ratio.plot(kind=&#39;bar&#39;, stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cfa31ef0&gt; . cross_ratio.transpose().plot(kind=&#39;bar&#39;, stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cfd34eb8&gt; . &#48169;&#48277;3 : groupby( &#48276;&#51452;) [ &#51333;&#49549;&#48320;&#49688;].&#51665;&#44228;.unstack() - &#48712;&#46020;+&#54217;&#44512;&#46020; &#44032;&#45733; + &#44032;&#49345;df&#47196;&#49436; apply()&#47196; &#48708;&#50984;&#44228;&#49328;&#44032;&#45733;&#54632; . &#48712;&#46020; . sex_to_survived = train.groupby(&#39;sex&#39;) [&#39;survived&#39;].value_counts().unstack() sex_to_survived . survived 0 1 . sex . female 81 | 233 | . male 468 | 109 | . sex_to_survived.plot(kind=&#39;bar&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cf4b85f8&gt; . &#48708;&#50984; : groupby( [&#39;&#48276;&#51452;&#39; ,&#39;&#51333;&#49549;&#39;]) [&#39;&#51333;&#49549;&#39;] &#51004;&#47196; &#48708;&#50984; &#44228;&#49328;&#54616;&#44592; . 비율을 계산하려면, 숫자칼럼 형태( 범주에서 counts() .unstack()도 먹인상태) | .count().unstack() : 범주별, 종속별, 종속의 범주마다 row단순 count -&gt; 칼럼으로 | .count().unstack() 한 것을 칼럼별로 계산하도록 df/df.sum() 으로 비율계산 | .transpose() 를 통해 index = x축에 종속변수가 가야 비율이 가득찬다 | . dict( list( train.groupby([&#39;sex&#39;, &#39;survived&#39;]) ) ).keys() . dict_keys([(&#39;female&#39;, 0), (&#39;female&#39;, 1), (&#39;male&#39;, 0), (&#39;male&#39;, 1)]) . dict( list( train.groupby([&#39;sex&#39;, &#39;survived&#39;]) ) )[&#39;female&#39;, 0].head() . passengerid survived pclass name sex age sibSp parch ticket fare cabin embarked . 14 15 | 0 | 3 | Vestrom, Miss. Hulda Amanda Adolfina | female | 14.0 | 0 | 0 | 350406 | 7.8542 | NaN | S | . 18 19 | 0 | 3 | Vander Planke, Mrs. Julius (Emelia Maria Vande... | female | 31.0 | 1 | 0 | 345763 | 18.0000 | NaN | S | . 24 25 | 0 | 3 | Palsson, Miss. Torborg Danira | female | 8.0 | 3 | 1 | 349909 | 21.0750 | NaN | S | . 38 39 | 0 | 3 | Vander Planke, Miss. Augusta Maria | female | 18.0 | 2 | 0 | 345764 | 18.0000 | NaN | S | . 40 41 | 0 | 3 | Ahlin, Mrs. Johan (Johanna Persdotter Larsson) | female | 40.0 | 1 | 0 | 7546 | 9.4750 | NaN | S | . train.groupby(&#39;sex&#39;)[&#39;survived&#39;].value_counts() . sex survived female 1 233 0 81 male 0 468 1 109 Name: survived, dtype: int64 . cross_df = train.groupby(&#39;sex&#39;) [&#39;survived&#39;].value_counts().unstack() cross_ratio = cross_df / cross_df.sum() cross_ratio . survived 0 1 . sex . female 0.147541 | 0.681287 | . male 0.852459 | 0.318713 | . cross_ratio.transpose().plot(kind=&#39;bar&#39;, stacked=True, figsize=(10,8)) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196d17e84a8&gt; . &#48169;&#48277;4 : sns.countplot( &#39;&#48276;&#51452;&#52860;&#47100;&#39; , hue= &#39;&#51333;&#49549;&#48320;&#49688;&#39; ) -&gt; &#48708;&#50984;&#51008; &#48380; &#49688; &#50630;&#45796; . sns.countplot(&#39;sex&#39;, data = train, hue=&#39;survived&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cfa68080&gt; . &#48276;&#51452;-&#51333;&#49549;(&#48276;&#51452;) &#51333;&#49549;&#48320;&#49688;&#48324; &#48276;&#51452;&#51032; &#48708;&#50984; &#54620;&#48264;&#50640; &#44536;&#47532;&#44592; . cross_df = train.groupby(&#39;pclass&#39;)[&#39;survived&#39;].value_counts().unstack() # 세로로 합하고, 칼럼별로 나누어 비율계산하기 print(pd.DataFrame(cross_df)) cross_ratio = cross_df/ cross_df.sum() # 세로방향기준으로 각 비율이 나눠져있는데, 그냥 그리면 row별로 x축에 틱이 찍힘 # 뒤집기 cross_ratio = cross_ratio.transpose() cross_ratio.plot(kind=&#39;bar&#39;, stacked=True, figsize=(10,5)) . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . &lt;matplotlib.axes._subplots.AxesSubplot at 0x1dd55006e48&gt; . &#51333;&#49549;-&#48276;&#51452;&#54805;&#48320;&#49688; &#44288;&#44228; &#54632;&#49688;&#51221;&#51032;&#54616;&#44592; . def cate_to_categorical(data,name_c, name_d ): # index 범주형 변수/ col 종속 변수 cross_df = data.groupby( name_c)[name_d].value_counts().unstack() # 세로로 합하고, 칼럼별로 나누어 비율계산하기 print(cross_df) cross_ratio = cross_df/ cross_df.sum() # 세로방향기준으로 각 비율이 나눠져있는데, 그냥 그리면 row별로 x축에 틱이 찍힘 # 뒤집기 cross_ratio = cross_ratio.transpose() f, ax = plt.subplots(1, 2, figsize=(18,9)) cross_df.plot(kind=&#39;bar&#39;, ax=ax[0]) ax[0].set_title(name_c +&#39; to &#39; +name_d ) ax[0].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 cross_ratio.plot(kind=&#39;bar&#39;, ax = ax[1], stacked=True) ax[1].set_title(name_d +&#39; to &#39;+name_c +&#39; ratio&#39; ) ax[1].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0)) # 범례 밖으로 빼기 plt.tight_layout() plt.show() # for문에 들어갈 것 대비 끝내기 . relationship_new.cate_to_categorical(train, &#39;survived&#39;, &#39;sex&#39;) . survived 0 1 sex female 81 233 male 468 109 . cate_to_categorical(train, &#39;survived&#39;, &#39;pclass&#39;) . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . import relationship_new relationship_new.cate_to_categorical(train, &#39;survived&#39;, &#39;pclass&#39;) . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . relationship_new.cate_to_categorical(train, &#39;survived&#39;, &#39;parch&#39;) . survived 0 1 parch 0 445.0 233.0 1 53.0 65.0 2 40.0 40.0 3 2.0 3.0 4 4.0 NaN 5 4.0 1.0 6 1.0 NaN . for+&#54632;&#49688;(&#48276;&#51452;-&#48276;&#51452;)&#47928;&#51012; &#53685;&#54644; &#47784;&#46304; &#51333;&#49549;&#52860;&#47100;&#50640; &#45824;&#54644; &#47784;&#46304; &#48276;&#51452;&#52860;&#47100;&#51032; &#48516;&#54252;&#50752; &#48708;&#50984; &#44536;&#47140;&#48372;&#44592; . 범주가 너무 많을때는 금지!! feature engineering | . for col in categorical_feature: relationship_new.cate_to_categorical(train, &#39;survived&#39;, col) . survived 0 1 embarked C 75 93 Q 47 30 S 427 217 . survived 0 1 sex female 81 233 male 468 109 . survived 0 1 name Abbing, Mr. Anthony 1.0 NaN Abbott, Mr. Rossmore Edward 1.0 NaN Abbott, Mrs. Stanton (Rosa Hunt) NaN 1.0 Abelson, Mr. Samuel 1.0 NaN Abelson, Mrs. Samuel (Hannah Wizosky) NaN 1.0 Adahl, Mr. Mauritz Nils Martin 1.0 NaN Adams, Mr. John 1.0 NaN Ahlin, Mrs. Johan (Johanna Persdotter Larsson) 1.0 NaN Aks, Mrs. Sam (Leah Rosen) NaN 1.0 Albimona, Mr. Nassef Cassem NaN 1.0 Alexander, Mr. William 1.0 NaN Alhomaki, Mr. Ilmari Rudolf 1.0 NaN Ali, Mr. Ahmed 1.0 NaN Ali, Mr. William 1.0 NaN Allen, Miss. Elisabeth Walton NaN 1.0 Allen, Mr. William Henry 1.0 NaN Allison, Master. Hudson Trevor NaN 1.0 Allison, Miss. Helen Loraine 1.0 NaN Allison, Mrs. Hudson J C (Bessie Waldo Daniels) 1.0 NaN Allum, Mr. Owen George 1.0 NaN Andersen-Jensen, Miss. Carla Christine Nielsine NaN 1.0 Anderson, Mr. Harry NaN 1.0 Andersson, Master. Sigvard Harald Elias 1.0 NaN Andersson, Miss. Ebba Iris Alfrida 1.0 NaN Andersson, Miss. Ellis Anna Maria 1.0 NaN Andersson, Miss. Erna Alexandra NaN 1.0 Andersson, Miss. Ingeborg Constanzia 1.0 NaN Andersson, Miss. Sigrid Elisabeth 1.0 NaN Andersson, Mr. Anders Johan 1.0 NaN Andersson, Mr. August Edvard (&#34;Wennerstrom&#34;) NaN 1.0 ... ... ... Widegren, Mr. Carl/Charles Peter 1.0 NaN Widener, Mr. Harry Elkins 1.0 NaN Wiklund, Mr. Jakob Alfred 1.0 NaN Wilhelms, Mr. Charles NaN 1.0 Willey, Mr. Edward 1.0 NaN Williams, Mr. Charles Duane 1.0 NaN Williams, Mr. Charles Eugene NaN 1.0 Williams, Mr. Howard Hugh &#34;Harry&#34; 1.0 NaN Williams, Mr. Leslie 1.0 NaN Williams-Lambert, Mr. Fletcher Fellows 1.0 NaN Windelov, Mr. Einar 1.0 NaN Wiseman, Mr. Phillippe 1.0 NaN Woolner, Mr. Hugh NaN 1.0 Wright, Mr. George 1.0 NaN Yasbeck, Mr. Antoni 1.0 NaN Yasbeck, Mrs. Antoni (Selini Alexander) NaN 1.0 Young, Miss. Marie Grice NaN 1.0 Youseff, Mr. Gerious 1.0 NaN Yousif, Mr. Wazli 1.0 NaN Yousseff, Mr. Gerious 1.0 NaN Yrois, Miss. Henriette (&#34;Mrs Harbeck&#34;) 1.0 NaN Zabour, Miss. Hileni 1.0 NaN Zabour, Miss. Thamine 1.0 NaN Zimmerman, Mr. Leo 1.0 NaN de Messemaeker, Mrs. Guillaume Joseph (Emma) NaN 1.0 de Mulder, Mr. Theodore NaN 1.0 de Pelsmaeker, Mr. Alfons 1.0 NaN del Carlo, Mr. Sebastiano 1.0 NaN van Billiard, Mr. Austin Blyler 1.0 NaN van Melkebeke, Mr. Philemon 1.0 NaN [891 rows x 2 columns] . C: Users is2js Anaconda3 lib site-packages matplotlib tight_layout.py:181: UserWarning: Tight layout not applied. The bottom and top margins cannot be made large enough to accommodate all axes decorations. warnings.warn(&#39;Tight layout not applied. &#39; . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . survived 0 1 cabin A10 1.0 NaN A14 1.0 NaN A16 NaN 1.0 A19 1.0 NaN A20 NaN 1.0 A23 NaN 1.0 A24 1.0 NaN A26 NaN 1.0 A31 NaN 1.0 A32 1.0 NaN A34 NaN 1.0 A36 1.0 NaN A5 1.0 NaN A6 NaN 1.0 A7 1.0 NaN B101 NaN 1.0 B102 1.0 NaN B18 NaN 2.0 B19 1.0 NaN B20 NaN 2.0 B22 1.0 1.0 B28 NaN 2.0 B3 NaN 1.0 B30 1.0 NaN B35 NaN 2.0 B37 1.0 NaN B38 1.0 NaN B39 NaN 1.0 B4 NaN 1.0 B41 NaN 1.0 ... ... ... E12 NaN 1.0 E121 NaN 2.0 E17 NaN 1.0 E24 NaN 2.0 E25 NaN 2.0 E31 1.0 NaN E33 NaN 2.0 E34 NaN 1.0 E36 NaN 1.0 E38 1.0 NaN E40 NaN 1.0 E44 1.0 1.0 E46 1.0 NaN E49 NaN 1.0 E50 NaN 1.0 E58 1.0 NaN E63 1.0 NaN E67 1.0 1.0 E68 NaN 1.0 E77 1.0 NaN E8 NaN 2.0 F E69 NaN 1.0 F G63 1.0 NaN F G73 2.0 NaN F2 1.0 2.0 F33 NaN 3.0 F38 1.0 NaN F4 NaN 2.0 G6 2.0 2.0 T 1.0 NaN [147 rows x 2 columns] . C: Users is2js Anaconda3 lib site-packages matplotlib tight_layout.py:181: UserWarning: Tight layout not applied. The bottom and top margins cannot be made large enough to accommodate all axes decorations. warnings.warn(&#39;Tight layout not applied. &#39; . survived 0 1 ticket 110152 NaN 3.0 110413 1.0 2.0 110465 2.0 NaN 110564 NaN 1.0 110813 NaN 1.0 111240 1.0 NaN 111320 1.0 NaN 111361 NaN 2.0 111369 NaN 1.0 111426 NaN 1.0 111427 NaN 1.0 111428 NaN 1.0 112050 1.0 NaN 112052 1.0 NaN 112053 NaN 1.0 112058 1.0 NaN 112059 1.0 NaN 112277 NaN 1.0 112379 1.0 NaN 113028 1.0 NaN 113043 1.0 NaN 113050 1.0 NaN 113051 1.0 NaN 113055 NaN 1.0 113056 1.0 NaN 113059 1.0 NaN 113501 1.0 NaN 113503 1.0 NaN 113505 NaN 2.0 113509 1.0 NaN ... ... ... SOTON/OQ 392082 1.0 NaN SOTON/OQ 392086 1.0 NaN SOTON/OQ 392089 NaN 1.0 SOTON/OQ 392090 1.0 NaN STON/O 2. 3101269 NaN 1.0 STON/O 2. 3101273 1.0 NaN STON/O 2. 3101274 1.0 NaN STON/O 2. 3101275 1.0 NaN STON/O 2. 3101280 1.0 NaN STON/O 2. 3101285 NaN 1.0 STON/O 2. 3101286 NaN 1.0 STON/O 2. 3101288 NaN 1.0 STON/O 2. 3101289 NaN 1.0 STON/O 2. 3101292 1.0 NaN STON/O 2. 3101293 1.0 NaN STON/O 2. 3101294 1.0 NaN STON/O2. 3101271 1.0 NaN STON/O2. 3101279 1.0 1.0 STON/O2. 3101282 NaN 1.0 STON/O2. 3101283 NaN 1.0 STON/O2. 3101290 1.0 NaN SW/PP 751 NaN 1.0 W./C. 14258 NaN 1.0 W./C. 14263 1.0 NaN W./C. 6607 2.0 NaN W./C. 6608 4.0 NaN W./C. 6609 1.0 NaN W.E.P. 5734 1.0 NaN W/C 14208 1.0 NaN WE/P 5735 1.0 1.0 [681 rows x 2 columns] . C: Users is2js Anaconda3 lib site-packages matplotlib tight_layout.py:181: UserWarning: Tight layout not applied. The bottom and top margins cannot be made large enough to accommodate all axes decorations. warnings.warn(&#39;Tight layout not applied. &#39; . &#51060;&#48320;&#49688; &#53456;&#49353;2 &#49707;&#51088;-&#49707;&#51088;&#54805;&#51032; &#49328;&#51216;&#46020;&#54665;&#47148; with &#51333;&#49549;&#48320;&#49688; . numerical_feature . array([&#39;age&#39;, &#39;fare&#39;, &#39;parch&#39;, &#39;sibsp&#39;], dtype=&#39;&lt;U5&#39;) . # list는 (-)연산은 안되도 (+) 연산은 된다. list(numerical_feature) + [&#39;survived&#39;] . [&#39;age&#39;, &#39;fare&#39;, &#39;parch&#39;, &#39;sibsp&#39;, &#39;survived&#39;] . sns.pairplot( train[ list(numerical_feature) + [&#39;survived&#39;] ], hue = &#39;survived&#39;, x_vars = numerical_feature, y_vars = numerical_feature) . C: Users is2js Anaconda3 lib site-packages statsmodels nonparametric kde.py:448: RuntimeWarning: invalid value encountered in greater X = X[np.logical_and(X &gt; clip[0], X &lt; clip[1])] # won&#39;t work for two columns. C: Users is2js Anaconda3 lib site-packages statsmodels nonparametric kde.py:448: RuntimeWarning: invalid value encountered in less X = X[np.logical_and(X &gt; clip[0], X &lt; clip[1])] # won&#39;t work for two columns. . &lt;seaborn.axisgrid.PairGrid at 0x296230e9828&gt; . &#54632;&#49688;&#54868;( &#49707;&#51088; - &#49707;&#51088;&#51032; &#49328;&#51216;&#46020; &#54665;&#47148; : pairplot) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) by &#49707;&#51088;&#54805;&#52860;&#47100;&#47749;&#47532;&#49828;&#53944; . type(numerical_feature) . numpy.ndarray . list().dtype . AttributeError Traceback (most recent call last) &lt;ipython-input-119-0901fc39190d&gt; in &lt;module&gt; -&gt; 1 list().dtype AttributeError: &#39;list&#39; object has no attribute &#39;dtype&#39; . numerical_feature . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . type(list(numerical_feature)) is list . True . len(numerical_feature) . 2 . def num_to_numerical(df, numerical_feature, name_d=None): # 종속변수 없을 때 if name_d == None: sns.pairplot( df[ list(numerical_feature) ] , # 숫자형칼럼들만 인덱싱 x_vars = numerical_feature, y_vars = numerical_feature ) plt.tight_layout() # 숫자 - 숫자 산점도 행렬 with 종속변수 범례 else: sns.pairplot( df[ list(numerical_feature) + [name_d]] , # 숫자형칼럼들 + 종속변수 인덱싱 hue = name_d, # 범례(색)으로 종속변수 추가 x_vars = numerical_feature, y_vars = numerical_feature ) plt.tight_layout() . num_to_numerical(train, {&#39;age&#39;, &#39;fare&#39;}, &#39;survived&#39;) . &#51060;&#48320;&#49688; &#53456;&#49353;3 : &#48276;&#51452;&#48324; - &#49707;&#51088;&#54805; &#52860;&#47100;(&#46308;)&#51032; &#48516;&#54252;(boxplot) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) by &#49707;&#51088;&#54805;&#52860;&#47100;&#47749;&#47532;&#49828;&#53944; . &#48276;&#51452;&#48324; &#49707;&#51088;&#52860;&#47100;1&#44060;&#51032; &#48516;&#54252;(boxplot) . print(train.groupby(&#39;sex&#39;)[&#39;age&#39;].describe()) plt.figure(figsize=(18,9)) sns.boxplot(x=&#39;sex&#39;, y=&#39;age&#39;, data=train.dropna()) plt.title(&quot;Sex - { }&quot;.format(&#39;age&#39;)) plt.show() . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . KeyError Traceback (most recent call last) &lt;ipython-input-277-1a8c01f185d7&gt; in &lt;module&gt; 2 plt.figure(figsize=(18,9)) 3 sns.boxplot(x=&#39;sex&#39;, y=&#39;age&#39;, data=train.dropna()) -&gt; 4 plt.title(&#34;Sex - { }&#34;.format(&#39;age&#39;)) 5 plt.show() KeyError: &#39; &#39; . &#54632;&#49688;&#54868;(&#48276;&#51452;&#48324; &#49707;&#51088;&#52860;&#47100;1&#44060;&#51032; &#48516;&#54252;(boxplot)) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) . def cate_to_num_box(df, name_c, name_n, name_d=None): # 범주별 기술통계량 if name_d != None: print(df.groupby([name_c, name_d])[name_n].describe()) else : print(df.groupby(name_c)[name_n].describe()) # 범주별 boxplot - 범례는 선택 plt.figure(figsize=(18,9)) sns.boxplot(x=name_c, y=name_n, data=df.dropna(), hue = name_d) plt.title(&quot;{} to {}&quot;.format(name_c, name_n)) plt.tight_layout() plt.show() . cate_to_num_box(train, &#39;sex&#39;, &#39;age&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . type(numerical_feature) . numpy.ndarray . type(&quot;age&quot;) . str . &#54632;&#49688;&#54868;( &#48276;&#51452;&#48324; - &#49707;&#51088;&#52860;&#47100;(&#46308;)&#51032; &#48516;&#54252;(boxplot)) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) . def cate_to_num_box(df, name_c, numerical_feature, name_d=None): # 숫자형 칼럼명 1개 ( 칼럼명 = 문자열 1개 직접 입력) if type(numerical_feature) is str: # 범주별 기술통계량 if name_d != None: print(df.groupby([name_c, name_d])[numerical_feature].describe()) else : print(df.groupby(name_c)[numerical_feature].describe()) # 범주별 boxplot - 범례는 선택 plt.figure(figsize=(18,9)) sns.boxplot(x=name_c, y=numerical_feature, data=df.dropna(), hue = name_d) plt.title(&quot;{} to {}&quot;.format(name_c, numerical_feature)) plt.tight_layout() plt.show() # 숫자형 칼럼명 리스트가 들어와서 for문을 돌면서 여러개 그릴 때 else : for col in numerical_feature: if name_d != None: print(df.groupby([name_c, name_d])[col].describe()) else : print(df.groupby(name_c)[col].describe()) plt.figure(figsize=(18,9)) sns.boxplot(x=name_c, # 범주칼럼명 y=col, # 숫자칼럼명 data=df.dropna() , # df hue = name_d ) # 종속칼럼명(선택) plt.title(&quot;{} to {}&quot;.format(name_c, col)) plt.tight_layout() plt.show() . cate_to_num_box(train, &#39;sex&#39;, &#39;age&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . cate_to_num_box(train, &#39;sex&#39;, &#39;age&#39;, &#39;pclass&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 count mean std min 25% 50% 75% max sex pclass female 1 85.0 34.611765 13.612052 2.00 23.000 35.0 44.00 63.0 2 74.0 28.722973 12.872702 2.00 22.250 28.0 36.00 57.0 3 102.0 21.750000 12.729964 0.75 14.125 21.5 29.75 63.0 male 1 101.0 41.281386 15.139570 0.92 30.000 40.0 51.00 80.0 2 99.0 30.740707 14.793894 0.67 23.000 30.0 36.75 70.0 3 253.0 26.507589 12.159514 0.42 20.000 25.0 33.00 74.0 . numerical_feature . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . cate_to_num_box(train, &#39;sex&#39;, numerical_feature, &#39;pclass&#39;) . count mean std min 25% 50% 75% max sex pclass female 1 85.0 34.611765 13.612052 2.00 23.000 35.0 44.00 63.0 2 74.0 28.722973 12.872702 2.00 22.250 28.0 36.00 57.0 3 102.0 21.750000 12.729964 0.75 14.125 21.5 29.75 63.0 male 1 101.0 41.281386 15.139570 0.92 30.000 40.0 51.00 80.0 2 99.0 30.740707 14.793894 0.67 23.000 30.0 36.75 70.0 3 253.0 26.507589 12.159514 0.42 20.000 25.0 33.00 74.0 . count mean std min 25% 50% sex pclass female 1 94.0 106.125798 74.259988 25.9292 57.24480 82.66455 2 76.0 21.970121 10.891796 10.5000 13.00000 22.00000 3 144.0 16.118810 11.690314 6.7500 7.85420 12.47500 male 1 122.0 67.226127 77.548021 0.0000 27.72810 41.26250 2 108.0 19.741782 14.922235 0.0000 12.33125 13.00000 3 347.0 12.661633 11.681696 0.0000 7.75000 7.92500 75% max sex pclass female 1 134.500000 512.3292 2 26.062500 65.0000 3 20.221875 69.5500 male 1 78.459375 512.3292 2 26.000000 73.5000 3 10.008300 69.5500 . &#51060;&#48320;&#49688; &#53456;&#49353;4 : &#48276;&#51452;&#48324; &#49707;&#51088;&#54805;&#52860;&#47100;&#51032; &#48276;&#50948;&#48324; kde&#48516;&#54252; &#53456;&#49353; . facet = sns.FacetGrid(train, hue = &#39;survived&#39;, height = 4.5,aspect=4) facet.map(sns.kdeplot, &#39;age&#39;, shade=True) facet.set(xlim = (0, train[&#39;age&#39;].max())) facet.add_legend() . &lt;seaborn.axisgrid.FacetGrid at 0x2241e1602b0&gt; . facet = sns.FacetGrid(train, hue = &#39;survived&#39;, aspect=4) facet.map(sns.kdeplot, &#39;age&#39;, shade=True) facet.set(xlim = (0, train[&#39;age&#39;].max())) facet.add_legend() plt.xlim([10,20]) . (10, 20) . &#54632;&#49688;&#54868; . # ( dataFrame, &#39;범주형 칼럼명&#39; , &#39;숫자형 칼럼명&#39; ) or # ( dataFrame, &#39;범주형 칼럼명&#39; , &#39;숫자형 칼럼명&#39; , xlim = [ a, b ] ) def cate_to_num_kde(df, name_c, name_n, xlim = None ): print(df.groupby(name_c)[name_n].describe()) facet = sns.FacetGrid(df.dropna(), hue = name_c, aspect=4) # df 및 범주형 변수 설정 및 가로길이(aspect) facet.map(sns.kdeplot, name_n, shade=True) # kdeplot 설정 및 숫자형변수 지정 facet.set(xlim = (df[name_n].min(), df[name_n].max())) # 숫자형 변수의 최소값부터 최대값까지 x범위 최초 지정 facet.add_legend() if xlim != None: print( &#39;범위지정 : {}&#39;.format(xlim)) plt.xlim(xlim) # xlim 지정시 그 범위만 출력 . cate_to_num_kde(train, &#39;sex&#39;, &#39;age&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . cate_to_num_kde(train, &#39;sex&#39;, &#39;age&#39;, xlim = [20, 30]) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 범위지정 : [20, 30] . &#49340;&#48320;&#49688; &#53456;&#49353;1 : &#48276;&#51452;2(&#48276;&#47168;)&#48324;&#47196;&#48372;&#45716; &#48276;&#51452;1(x&#52629;)&#48324; --&gt; &#50672;&#49549;(&#51333;&#49549;)&#48320;&#49688; &#51032; &#48708;&#50984; . 범주1이 종속변수에 끼는 영향에 대해 범주2(범례)의 영향이 있는지(크로스) 없는지(평행) 판단 | . # https://kaggle-kr.tistory.com/17?category=821486 sns.catplot(&#39;sex&#39;, &#39;survived&#39;, hue=&#39;pclass&#39;, data=train, kind=&#39;point&#39;, # default kind - factorplot height=6, aspect=1.5) . &lt;seaborn.axisgrid.FacetGrid at 0x1dd548ba160&gt; . &#54632;&#49688;&#54868; . def legend_to_cate_to_num(df, name_l, name_c, name_n): sns.catplot(name_c, name_n, hue=name_l, data=df, kind=&#39;point&#39;, # default kind - factorplot height=6, aspect=1.5) plt.tight_layout() plt.show() . legend_to_cate_to_num(train, &#39;sex&#39;, &#39;pclass&#39;, &#39;survived&#39;) . &#49340;&#48320;&#49688; &#53456;&#49353;2 : &#48276;&#47168;&#48324;(&#51333;&#49549;&#48320;&#49688;)&#48324;&#47196; &#48372;&#45716; &#48276;&#51452;&#48324;(x&#52629;) &#49707;&#51088;&#54805;(y&#52629;-&#48148;&#51060;&#50732;&#47536;)&#51032; &#48516;&#54252; . sns.violinplot(&quot;pclass&quot;,&quot;age&quot;, hue=&quot;survived&quot;, data=train, scale=&#39;count&#39;, split=True) plt.legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 plt.tight_layout() plt.show() # for문에 들어갈 것 대비 . &#54632;&#49688;&#54868;(&#48276;&#47168;&#48324;(&#51333;&#49549;&#48320;&#49688;)&#48324;&#47196; &#48372;&#45716; &#48276;&#51452;&#48324;(x&#52629;) &#49707;&#51088;&#54805;(y&#52629;-&#48148;&#51060;&#50732;&#47536;)&#51032; &#48516;&#54252;) . def legend_to_cate_to_num_violin(df,name_l, name_c, name_n): sns.violinplot(name_c,name_n, hue=name_l, data=df, scale=&#39;count&#39;, split=True) plt.legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 plt.tight_layout() plt.show() # for문에 들어갈 것 대비 . legend_to_cate_to_num_violin(train, &#39;survived&#39;, &#39;sex&#39;, &#39;age&#39;) . categorical_all(train, &#39;embarked&#39;) . cate_to_categorical(train, &#39;survived&#39;, &#39;embarked&#39;) . survived 0 1 embarked C 75 93 Q 47 30 S 427 217 .",
            "url": "blog.chojaeseong.com/data/2021/08/06/%EC%97%91%EC%85%80%EC%A0%95%EB%A6%AC-05-%EC%BA%90%EA%B8%80-1-%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89-%EB%B3%80%EC%88%98%EB%B3%84-EDA-+-%ED%95%A8%EC%88%98%EC%A0%95%EC%9D%98%EB%A1%9C-%EC%A0%95%EC%9D%98(upload).html",
            "relUrl": "/data/2021/08/06/%EC%97%91%EC%85%80%EC%A0%95%EB%A6%AC-05-%EC%BA%90%EA%B8%80-1-%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89-%EB%B3%80%EC%88%98%EB%B3%84-EDA-+-%ED%95%A8%EC%88%98%EC%A0%95%EC%9D%98%EB%A1%9C-%EC%A0%95%EC%9D%98(upload).html",
            "date": " • Aug 6, 2021"
        }
        
    
  
    
        ,"post93": {
            "title": "fastpages로 블로그 제작",
            "content": "1 fastpages 만들기 . 클릭만으로 repo, actions key 생성/ 추가 merge | . google에서 fastpages검색후 &gt; 깃허브 &gt; setup instruction &gt; on this link (generating by link) . is2js(@naver.com) / 12!@ | . | 블로그 원본 내용이 들어갈 레포지토리 생성임.(github.io 아님) . is2js/blog_raw 이후 자동으로 https://is2js.github.io/blog_raw/ 로 생성된다. | . | . | 조금 기다리면, Pull Request가 자동으로 올라온다. . link클릭으로 create/clone repo + PR으로 설치까지 자동화된 것임. . | PR로 온 Initial Setup부분을 보자. merge전에 1,2,3번은 순서대로 직접 작동시켜야한다. . 1. ctrl+클릭으로 this uility를 클릭 &gt; RSA - 4096 클릭 &gt; 생성된 key 그대로 복사 . Private Key . --BEGIN RSA PRIVATE KEY-- . Publick key . ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCGIVY8FQf9x1Y52HUUJmpAyOfrzH96K4QtGb7 . | 2.도 컨트롤+클릭해서 1.에서 생성한 ssh key를 붙혀넣어 Action secret key를 만든다. . actions secrets 부분에 New repository secret을 클릭해서 붙혀넣음. Name : SSH_DEPLOY_KEY | Value : SSH RSA 4096 private key 복붙 | . | . | 3. 도 컨트롤+클릭해서 fastpages-blog의 Deploy (public) key를 생성해야한다. Add deploy key클릭 . 여기서는 생성한 ssh RSA 4096 key중에 밑에 있는 publick key를 사용한다. . Title : fastpages-blog | Key : SSH RSA 4096 public key 복붙 | [O] Allow write acess | . | . | . | . | PR 아래부분에 merge PR &gt; merge를 눌러준다. . Actions에 보면 Merge가 진행중인 것이 보인다. 2분 정도 걸림. | 다 되고나면, &lt;code&gt;탭으로 와서 맨 첫줄에 블로그 주소가 보이게 된다. | . | 2 설정해주기 . blog 타이틀 변경 . 깃헙을 다룰 줄 알면, 로컬에서 clone을 떠서 수정하면 된다. . push만 해주면, actions가 자동으로 돌아가면서 static 파일로 수정해준다. | 우리가 올린 파일 기준으로 static한 파일을 생성해준다. | . _config.yaml 수정 &gt; title 변경 &gt; commit | jupyter upload . fastpages가 만들어준 readme에 보면, writing blogs with jupyter가 있다. . 여기서는 .md or .ipynb의 파일이름 양식만 참고함. . YYYY-MM-DD-*.ipynb | . 2020-01-28-My-First-Post.ipynb 2012-09-12-how-to-write-a-blog.ipynb . | Front Matter : 내 블로그 첨에 작성된 ipynb글(Fastpages Notebook Blog Post)을 참고해서 가져다 쓴다.(공식은 너무 김) . 쥬피터 노트북 맨 위에 들어갈 markdown 양식이다. . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true - branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . | 올릴 쥬피터에 아래와 같이 작성한다. . | 노트북 이름을 바꾼다. . 2021-08-06-엑셀정리 05 캐글 1 타이타닉 - 변수별 EDA + 함수정의로 정의(upload).ipynb . | github의 _notebooks 폴더로 가서 add file &gt; 업로드 &gt; commit해보았음. . | . | . | markdown upload . 해당 폴더는 _posts다 . | 제목양식은 yyyy-mm-dd-제목.md다 . 실제로 표시되는 이름은 예제파일속 format의 title:이 실제로 포스트 제목이 된다. | _posts &gt; 예제파일.md &gt; raw를 클릭해서 내용을 복사후 &gt; add file &gt; create file | . toc: true layout: post description: A minimal example of using markdown with fastpages. categories: [markdown] title: An Example Markdown Post # Example Markdown Post ## Basic setup . | . 3. local에서 clone해와서 작업해보기 . C: jupyter_blog에 폴더를 만들고, 우클릭 &gt; 터미널 &gt; code . . | git clone https://github.com/is2js/blog_raw.git . C: jupyter_blog blog_raw에 파일 복사됨. . | vscode는 해당 폴더로 들어가야함. . cd blog_raw/ . | . | 블로그 계정(is2js)과, 컴퓨터 전체 git 계정(is3js)이 다르므로, --local로 깃 계정을 설정해준다. . 참고 | . git config --local user.name &quot;is2js&quot; git config --local user.email &quot;is2js@naver.com&quot; . vscode에서 github확장관리에서 로그인을 제공하고 있어서, 로그아웃후 is2js로 로그인했다. | . | 첫화면 수정 . index.html은 첫 화면에 대한 내용을 md형식으로 닮고 있다. | 내용을 수정하고 이미지가 필요하면, images폴더에 업로드후 사용한다. 작성글들은 이 페이지 아래 자동으로 모아진다. | . | 메뉴 추가 . . _pages/폴더에 들가면 각각의 메뉴가 md파일로 작성되어있다. . about은 md파일로 작성되어있으며, 추가 nav 메뉴는 다 md파일로 작성한다. . layout: page title: About Me permalink: /about/ . 파일명이 아니라 양식속 title이 nav메뉴에 뜨는 페이지명이 된다. | . | 404, search, tags는 html파일로 섞어서 작성되어있다. . | . | _pages/에서 파일을 하나 생성하여 메뉴를 추가한다. . about에 있는 양식을 사용한다. | 작성하고 commit해준다. | . | comment 추가 . utterances를 이용하여 깃허브로 댓글 달도록 함. | . 현재 아무 post에나 comment를 달면 is2js/blog_raw/폴더에 앱이 인스톨 안되어있다고 나옴. install_app을 클릭해서 어터런스 설치 | install을 all repo가 아니라 select해준다. 필요한 저장소마다 설치를 추가로 해주면 된다. | . | . | social comment . disqus를 이용하여 소셜 or 깃헙없이 댓글 달도록 함. | utterances설치시 생성된 _includes/utterances.html을 수정하여 스크립트로 disqus스크립트를 넣어준다. disqus는 url기준으로 댓글창을 열어준다. | url만 다르다면, 다른 댓글창이 열린다. | . | . 구글에서 disqus 검색 블로그 &gt; 로고클릭 &gt; com | . | 난 페북으로 로그인함. -&gt; get start | 선택 | i want to comment on sites | I want to install Disqus on my site | . site네임은 is2js_blog_raw로 함 . | basic버전을 subscribe now로 선택함 . | 우리는 스크립트로 넣을 거라 platform선택 없이 아래 i don&#39;t see my platform 선택 . 스크립트는 카피 해놓는다. . &lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt; &lt;script&gt; /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page&#39;s canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page&#39;s unique identifier variable }; */ (function() { // DON&#39;T EDIT BELOW THIS LINE var d = document, s = d.createElement(&#39;script&#39;); s.src = &#39;https://is2js-blog-raw.disqus.com/embed.js&#39;; s.setAttribute(&#39;data-timestamp&#39;, +new Date()); (d.head || d.body).appendChild(s); })(); &lt;/script&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;https://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; . | . | configure(next랑 똑같음) 클릭후 정보는 비워놓아도 된다. . | 4. 추가 커스텀 . 방문자 카운터 . 해당 프로젝트는 오픈소스라 작동이 안되거나 없어질 수 있음. | 키워드를 기억했다가 다른 것을 검색해서 | . 구글에서 github blog hits counter를 검색 . 최상단 hit-counter 깃허브 들어갔음. https://hits.seeyoufarm.com/ | . | . | 해당 내용을 채운다. . . | 3가지 타입으로 넣을 수 있다. 특히 embed로 넣을 수 있는 것은 노션으로도 넣을 수 있다는 말이 된다. . markdown . ![Hits](https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fis2js.github.io%2Fblog_raw&amp;count_bg=%239E9E9E&amp;title_bg=%2308445E&amp;icon=python.svg&amp;icon_color=%23E1DFDF&amp;title=%EB%B0%A9%EB%AC%B8%EC%9E%90+%EC%88%98&amp;edge_flat=false) . | html . &lt;a href=&quot;https://hits.seeyoufarm.com&quot;&gt;&lt;img src=&quot;https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fis2js.github.io%2Fblog_raw&amp;count_bg=%239E9E9E&amp;title_bg=%2308445E&amp;icon=python.svg&amp;icon_color=%23E1DFDF&amp;title=%EB%B0%A9%EB%AC%B8%EC%9E%90+%EC%88%98&amp;edge_flat=false&quot;/&gt;&lt;/a&gt; . | embed url . https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fis2js.github.io%2Fblog_raw&amp;count_bg=%239E9E9E&amp;title_bg=%2308445E&amp;icon=python.svg&amp;icon_color=%23E1DFDF&amp;title=%EB%B0%A9%EB%AC%B8%EC%9E%90+%EC%88%98&amp;edge_flat=false . | . | 이제 markdown을 index.html안에다 넣어주자. . | 5. 깃허브 잔디와 레포 페이지(git.html) 추가 . 잔디이미지는 솔루션을 통해 https://ghchart.rshah.org/is2js | . | 레포정보는 url로 접근하는 github api를 통해 레포들정보 : https://api.github.com/users/[is2js]/repos | 특정레포정보 : [https://api.github.com/repos/[is2js]/[레포명] | . | 참고자료(노션) | . 솔루션(https://ghchart.rshah.org )을 이용하여, 잔디정보를 이미지로 가져올 수 있다. . index.html에 유저이름만 적어준 이미지 url or MD을 붙혀넣어준다. . 이미지 주소 : https://ghchart.rshah.org/is2js . | 이미지태그 . &lt;img src=&quot;https://ghchart.rshah.org/is2js&quot;/&gt; or &lt;img src=&quot;https://ghchart.rshah.org/is2js&quot; /&gt;로 변경 . | 마크다운 주소 . ![잔디](https://ghchart.rshah.org/is2js &quot;https://github.com/is2js&quot;) . | . | index.html의 hits 아래에 넣고 확인해보자. . . | . | 새로운 페이지 /_pages/git.html을 만들자. . 노션에 미리 작성해둔 코드를 복붙하자. . js스크립트를 사용하기 위해 html양식으로 작성한다. github API를 script태그를 이용하여 github repo정보를 가져온 것이다. api -&gt; h2, p, a태그로 map으로 돌면서 정보출력. 원하면 태그를 바꾸면 된다. | . | is2js부분을 해당하는 githubID로 변경해서 사용하면된다. | . layout: default permalink: /gitInfo/ title: gitInfo search_exclude: true &lt;img src=&quot;https://ghchart.rshah.org/is2js&quot; alt=&quot;&quot; style=&quot;width: 660px; height: 100px;&quot;&gt; &lt;div id=&quot;repos&quot;&gt; &lt;script&gt; // 비동기 작업을 위해 async function 선언 const initRepo = async () =&gt;{ const _username = &#39;is2js&#39; // 추가할 dom선택 const repoUl = document.getElementById(&quot;repos&quot;) // headers 설명 : 깃허브에 요청할 형식 지정 let response = await fetch(&#39;https://api.github.com/users/is2js/repos&#39;, {headers:{ &#39;Accept&#39; : &#39;application/vnd.github.v3+json&#39; }}); const repoJson = await response.json() // repo받아온 내용 확인 // console.log(repoJson); // json내용을 map을 이용해 각 dom을 만들고 추가 repoJson.map((repos)=&gt;{ let h2Element = document.createElement(&quot;h2&quot;) h2Element.textContent = repos.name let pElementDesc = document.createElement(&quot;p&quot;) pElementDesc.textContent = &quot;레포설명 : &quot; + repos.description let aElementURL = document.createElement(&quot;a&quot;) aElementURL.href = repos.svn_url aElementURL.textContent = repos.svn_url //각 요소를 &lt;div id=&quot;repos&quot;&gt;에 추가 repoUl.append(h2Element) repoUl.append(pElementDesc) repoUl.append(aElementURL) repoUl.append(document.createElement(&quot;br&quot;)) }) } initRepo() &lt;/script&gt; . | . | 6. repo마다 언어 퍼센트 출력하도록 변경 . 특정 레포 : [https://api.github.com/repos/[is2js]/[레포명] . 특정레포에서 쏴주는 정보를 관찰해보기 : blog_raw . | 랭기쥐만 출력해서 보기 : blog_raw/languages . 각 언어의 line수가 출력된다. | 다 더한 뒤, 총합으로 나누고, 100을 곱해서 %를 만든다. | . { &quot;Jupyter Notebook&quot;: 12491591, &quot;HTML&quot;: 20989, &quot;JavaScript&quot;: 10532, &quot;SCSS&quot;: 9877, &quot;Shell&quot;: 5458, &quot;Python&quot;: 2772, &quot;Smarty&quot;: 1965, &quot;Ruby&quot;: 1945, &quot;Makefile&quot;: 1422, &quot;Dockerfile&quot;: 364 } . | . | . git.html의 script부분(단순정보나열)을 퍼센트까지 뿌려주도록 변경된 스크립트를 복붙해주면 된다. . 모든 line수(values)를 sumcodeline에 더해주고, 각각의 value에다 나눈 뒤, 100을 곱한다. | strong태그로 출력을 해서, h2 아래에 추가해준다. | count변수를 사용해서 불러올 repo를 5개로 지정해준다. 최대갯수는 100개다. | . // 사용한 언어를 return해주는 함수 const repoLanguage = async (repo) =&gt; { let response = await fetch( `https://api.github.com/repos/is2js/${repo}/languages`, { headers: { Accept: &#39;application/vnd.github.v3+json&#39;, }, } ); let resJson = await response.json(); let sumcodeline = Object.values(resJson).reduce((a, b) =&gt; a + b, 0); s = &#39;&#39;; for (const [key, value] of Object.entries(resJson)) { s += `${key} : ${((value / sumcodeline) * 100).toFixed(3)}% `; } return s; }; // 비동기 작업을 위해 async function 선언 const initRepo = async () =&gt; { // 추가할 dom선택 const repoUl = document.getElementById(&#39;repos&#39;); //갯수설정 const count = 5; // headers 설명 : 깃허브에 요청할 형식 지정 let response = await fetch( &#39;https://api.github.com/users/is2js/repos?&#39; + &#39;per_page=&#39; + count, { headers: { Accept: &#39;application/vnd.github.v3+json&#39;, }, } ); const repoJson = await response.json(); // repo받아온 내용 확인 // console.log(repoJson); // json내용을 map을 이용해 각 dom을 만들고 추가 // repoLanguage 함수의 비동기 작업을 위한 async function선언 repoJson.map(async (repos) =&gt; { let h2Element = document.createElement(&#39;h2&#39;); h2Element.textContent = repos.name; let pElementDesc = document.createElement(&#39;p&#39;); pElementDesc.textContent = &#39;레포설명 : &#39; + repos.description; let aElementURL = document.createElement(&#39;a&#39;); aElementURL.href = repos.svn_url; aElementURL.textContent = repos.svn_url; //사용한 언어 불러오기 let language = await repoLanguage(repos.name); let strongElementLang = document.createElement(&#39;strong&#39;); strongElementLang.textContent = &#39;사용언어 : &#39; + language.toString(); //각 요소를 &lt;div id=&quot;repos&quot;&gt;에 추가 repoUl.append(h2Element); //사용언어부분 추가 repoUl.append(strongElementLang); repoUl.append(pElementDesc); repoUl.append(aElementURL); repoUl.append(document.createElement(&#39;br&#39;)); }); }; initRepo(); . | latex 사용 on . _config.yml에서 LaTex 적용이 default가 true가 아니라서 아래와 같이 _config.yml 파일에 use_math 옵션을 true로 변경해주시면 됩니다. . use_math: true . | 구조 . ### . index.html : 첫 화면에 대한 내용을 md형식으로 닮고 있지만, html파일임. . ``/images/diagram.png “https://github.com/fastai/fastpages”) . . ``은 나중에 is2js.github.io/blog_raw/ 폴더(깃허브 블로그 원본 폴더)로 연결된다. | . | . | _pages/ : md or html의 nav메뉴들의 모음 . about.md, search.html 등 | 추가된 md파일의 양식속 title:[ ]이 nav메뉴에 뜨는 페이지명이 된다. resume.md | git.html | . | . | images/ . 사진, favicon | . | . 커스텀 . 커스텀 도메인을 붙이는 조건 . 내 블로그는 is2js.github.io는 아니지만, github의 네임서버가 is2js.github.io.가 작동하는 것 같았다. (뒤에 . 있음) 원래는 리눅스서버의 공인ip주소를 적어줘야한다. | 하지만, github는 따로 ip주소를 제공하지 않으므로, [git_id].github.io.를 적어두고 해당폴더에서 설정과정을 추가한다. | . | . 가비아 DNS관리 페이지로 간다 dns.gabia.com | . | blog라는 서브도메인에다가 CNAME &amp; [github_id].github.io.로 레코드를 추가한다. . | 해당 fastpage 깃폴더 -&gt; settings &gt; pages로 이동한다. custom domain 부분에 dns에 등록한 서브도메인 blog.chojaseong.com을 적어준다. | 어떠한 확인과정이 있는데, 여기서 dns에 적어둔 [git_id.github.io.]에다가 현재깃폴더 배포ip를 배정시켜주는 작업을 하는 듯 싶다 | . | 밑에 https도 되도록 체크해준다. . | LOCAL 블로그폴더의 root에 CNAME이라는 파일을 만들고, 내부에 커스텀 도메인의 url만 적어준다. . CNAME . blog.chojaeseong.com . | root폴더의 _config.yml속 url 과 baseurl을 수정한다. . url: &quot;https://is2js.github.io&quot; -&gt; &quot;blog.chojaeseong.com&quot; | baseurl: &quot;/blog_raw&quot; -&gt; &quot;&quot; 아~ fastpage가 git_id.github.io아름의 레포가 아닌데도 page로 배포된 이유는 url을 git_id.github.io | baseurl을 /레포명으로 가지고 있어서 기 때문이구나. | . | 하지만, 커스텀도메인에서는 레포명까지 풀로 포함되서 github가 해당 커스텀도메인에 배포해준다. 그로 인해 baseurl은 사라진다.(빈문자열) | . | . | . | . . | _action_files폴더 속 settings.ini파일에도 baseurl이 있으니 수정해준다. 지워서 빈칸 남겨놓기 | . | 커스텀도메인으로 접속하는 순간부터, search 결과의 link들이.. 상대주소화되어 있어서, 도메인/search + 도메인/풀/주소.html 형식으로 잇슈가 있음. . search.js에서 만들어주는 a태그의 주소에 https://를 붙혀서 절대주소화 시켜 뒤에 붙지않고 바로 접속되게 한다. | . search.js . var resultLink = document.createElement(&#39;a&#39;); resultLink.classList.add(&#39;search-result&#39;); // a태그에 http:// 등이 없어서, 상대주소로 걸려서 커스텀도메인 + 다시 또 풀경로가 상대주소처럼 붙음.. // -&gt; href에 https://를 명시해주면, 상대주소가 아니라 절대주소로 인식되어 그 주소로만 간다. resultLink.setAttribute(&#39;href&#39;, &quot;https://&quot; + doc.url); //resultLink.setAttribute(&#39;target&#39;, &quot;_blank&quot;); . . |",
            "url": "blog.chojaeseong.com/fastpages/2021/08/06/fastpages%EB%A1%9C_%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%A0%9C%EC%9E%91.html",
            "relUrl": "/fastpages/2021/08/06/fastpages%EB%A1%9C_%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%A0%9C%EC%9E%91.html",
            "date": " • Aug 6, 2021"
        }
        
    
  
    
        ,"post94": {
            "title": "Notebook posting example(title)",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "blog.chojaeseong.com/example/2021/08/05/test.html",
            "relUrl": "/example/2021/08/05/test.html",
            "date": " • Aug 5, 2021"
        }
        
    
  
    
        ,"post95": {
            "title": "markdown 사용법",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . `![](/images/logo.png &quot;fast.ai&#39;s logo&quot;)` . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "blog.chojaeseong.com/example/markdown/2021/08/05/markdown.html",
            "relUrl": "/example/markdown/2021/08/05/markdown.html",
            "date": " • Aug 5, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "준비중입니다. .",
          "url": "blog.chojaeseong.com/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "",
          "content": "공사중입니다(template).. 자세한 정보는 github.com/is2js . 데이터엔지니어로서의 역량 . Data Engineer란? . Data관련 직군 출저 : Youtube-indiflex | . 프로젝트 . python를 활용한 진료보조프로그램들 한방병원 진료기록부(ipywidget, panel) | 초진기록지(ipywidget) | 환자 티칭 프로그램(ipywidget) | 동료선생님들 거주지역 확진자수 알림(flask, GCP, jandi) | . | Class를 활용한 CLI blog (CRUD) | NLP 분석 Packages | . | 사람인 공고 수집 크롤링 프로젝트 - 크롤링 심화 프로젝트 | . | 데이터 분석 프로젝트 . 나만의 데이터분석 노트 gitbook(Updating~) | 나만의 데이터분석(EDA) 패키지 -Cho Package : numpy, pandas, matplotlib, seaborn . | 논문작성을 위한 한의학 박사들의 설문지 분석후 ROC커브 작성 [노트] | DL논문 작성을 위한 image전처리, DL, ROC커브 작성 [노트] | 관심기업 과제와 유사한 데이터 분석 프로젝트 [노트] 관심기업 과제 pandas to SQL | . | inflearn Pipeline . | 멋쟁이사자 X Naver 연계 프로그램 - clovar API이용 프로젝트 | | Flask 프로젝트 게시판 : Docker, MongoDB, Flask, JQuery | 질답앱 : | 대쉬보드 | like finterest 메모대쉬보드 | . | FastAPI 프로젝트 API : | . | Algorithm &amp; Pythonic . Pythonic Python 정리 및 회고 [노트, 출저-프로그래머스] | 알고리즘 패러다임 및 연습문제 풀이 [저장소], 출저-Codeit] | 알고리즘 자료구조 및 연습문제 풀이[노트, 출저-프로그래머스] | 알고리즘 고득점 kit 연습문제 풀이[노트, 출저-프로그래머스] | Python 고급 [저장소] | DataAnalyst . DS스쿨 - DL반 수료 | DS스쿨 - ML반 수료 | FastCampus - 논문작성을 위한 R 통계 수료 | DL(cnn)을 활용한 독성약재감별 논문작성 논문 | 논문 작성을 위한 설문지 분석후 ROC커브 작성 [노트] | 관련 프로젝트 in 고려대 [노트, 프로젝트] | . | penguin package를 활용한 통계분석 정리[노트] | 고려대 빅데이터 청년인재 수료 NLP | Vision | ML, DL | . | Data Engineer . DS스쿨 - Pandas 데이터분석반 수료 | FastCampus - 전처리CAMP 수료 | Udemy - The Complete Python &amp; PostgreSQL Developer Course 수료 | DataCamp - Data Engineering for Everyone 수료 | DB &amp; SQL . DAP자격대비 데이터 모델링 스터디[노트, 출저-데이터와사람들] | SQL 데이터 분석[노트, 출저-책] | SQL, Bigquery를 이용한 코호트 분석[노트, 출저-탈잉] | MySQL 심화[노트, 출저-SSAC] | Postgresql tutorial 4hour[노트, 출저-FreeCodeCamp] | Postgresql for DataEngineer[노트, 출저-itversity] | Postgrsql &amp;Python course[노트, 출저-udemy] | SQL vs Pandas 비교정리[노트, 출저-조재성] | mongoDB for 데이터수집[노트, 출저-멋쟁이사자처럼, 그외] | SQLAlchemy . 2.0과 이전버전 비교 및 튜토리얼[노트, 출저-Youtube] | SQLAlchemy - pandas 비교 튜토리얼[노트] | Infra . 운영체제 공부[ 노트, 출저 - 정보처리기사 및 유튜브 ] | PowerShell vs BashShell 다빈도 명렁어 정리[노트, | Docker 기본 문법[노트, 출저-Indiflex] | Docker &amp; Ncloud[노트, 출저-SSAC] | Linux 기본[노트, 출저-Indiflex] 출저-드림코딩] | git 기본 | git flow | Frontend . HTML, CSS, JAVASCRIPT로 모던 웹페이지 만들기[프로젝트] | Javasctip와 TypeScript 정리 | React | Vue |",
          "url": "blog.chojaeseong.com/_pages/edustudy.html",
          "relUrl": "/_pages/edustudy.html",
          "date": ""
      }
      
  

  

  

  
      ,"page5": {
          "title": "",
          "content": "공사중입니다…(template) 제시한 정보는 github.com/is2js . 기본정보 . Photo Future . | | . Name | 조재성 | . - Chinese | 趙在聖 | . - English | ChoJaeSeong | . Age | 1987 | . Birth Day | 1987.12.18 | . Email | tingstyle1@gmail.com | . Mobile | xxx-46xx-62xx | . 신상정보 . Profile Content . Address | 서울시 관악구 | . Married | 미혼 | . Family | 2남 1녀 | . Blood type | RH+ O | . Religion | 없음 | . 학력정보 . Level School Name Major Start End Status 최종학력 . University | DongShin University | Korean Medicine | YYYY.MM | YYYY.MM | graduated | 최종 | . High School | NamHae High School |   | YYYY.MM | YYYY.MM | graduated |   | . 직장이력 . Period Company Part &gt; Team . 2011.10 - 2013.4 | Company Inc | R&amp;D &gt; Mobile | . 2010.05 - 2011.9 | Company Corp | Big Data &gt; Visualize | . 2008.08 - 2010.3 | Venture | Web &gt; UI | . 2007.02 - 2008.8 | Company Name | Marketing 3 | . 오픈소스 프로젝트 (2012.03 ~ 현재) . 프로젝트 공식 명칭 . 소개 프로젝트에 대한 간략한 소개를 한다. . | 주요기능 주요 기능을 일일이 상세히 나열한다. | . | 사용기술 . 사용된 기술을 상세히 나열한다. | . | 개발기간 : 2013.2.3 을 시작으로 최근까지 xxx 커밋 | 공식 사이트 - http://rhiokim.github.io/resume | 소스 저장소 - https://github.com/rhiokim/resume | . | 마크다운 이력서 표준화 프로젝트 . 소개 . 이력서에 대한 몇가지 불편한 마음을 개선하고자 마크다운 이력서 표준화 프로젝트를 시작한다. . 개발자를 잘 표현할 이력서 양식이 없다. | 2,3 년에 한번씩 업데이트 해야하는 이력서 너무 힘들다. | 이력서 양식이 도구에 너무 의존적이다. | | 주요기능 . 마크다운으로 기술한다. | PDF, HTML, EPUB, Mobi 등 다양한 포맷으로 변환할 수 있다. | 개발자를 잘 표현할 수 있다. | . | 사용기술 마크다운. . | 개발기간 : 2012.3 을 시작으로 약 6개월에 걸쳐 500여 커밋 | 공헌자 : https://github.com/rhiokim/resume/contributors | 공식 사이트 - http://rhiokim.github.io/resume | 소스 저장소 - https://github.com/rhiokim/resume | . | . 기타 공개/비공개 프로젝트 . 프로젝트 명 추가 설명 : https://vimeo.com/51812784 | . | . 진행중인 프로젝트 (2013.04 ~ 현재) . 프로젝트 명 소개 모바일 앱으로 현재 3명의 멤버가 개발 진행 중 . | 사용기술 Node.js, Mongodb, APNS(Apple Notification), Gumby2 (Responsive CSS Framework) . | 역할 RESTful API 디자인, 시스템(Node.js, Mongodb, APNS) 엔지니어링, 웹 사이트 개발 . | . | . 참여한 프로젝트 이력 . 회사명 1 . 프로젝트 소개 프로젝트에 대한 간략한 소개를 한다. . | 역할 자기가 참여한 프로젝트에서 했던 역할에 대해서 기술한다. | . | 사용기술 Backbone.js, jQuery, require.js, grunt.js, twitter bootstrap, Node.js 등 | . | 개발기간: 12개월 | 공식 사이트: https://project.com | 소스 저장소: https://github.com/company/project | . | . 회사명 2 . 프로젝트 소개 프로젝트에 대한 간략한 소개를 한다. . | 역할 자기가 참여한 프로젝트에서 했던 역할에 대해서 기술한다. | . | 사용기술 Backbone.js, jQuery, require.js, grunt.js, twitter bootstrap, Node.js 등 | . | 개발기간: 6개월 | 공식 사이트: https://project.com | 소스 저장소: https://github.com/company/project | . | . 대외 활동 내역 . 커뮤니티 . 커뮤니티명 주제 관련 참고 자료 . 2010.05 | Title | http://slidesha.re/xxxxxx | . 2010.10 | Title | http://scr.bi/xxxxxxx | . 세미나 . 행사 / 모임 주제 규모 관련 참고 자료 . XX R&amp;D Campus | 1. subject 1 | 30 | http://bit.ly/xxxxxx | . 2. subject 2 |   | http://bit.ly/xxxxxx |   | . 컨퍼런스, 강연 . 행사 / 모임 주제 규모 관련 참고 자료 . Conference | Title | 250 | http://bit.ly/xxxxxx | . Conference | Title | 1,000 | http://bit.ly/xxxxxx | . 소셜 . Site URL . Github | https://github.com/{account} | . Twitter | https://twitter.com/{account} | . Facebook | https://facebook.com/{account} | . . 위의 사실은 GNU 정신에 의거하여 사실임을 증명하며, 만약 사실이 아닐 경우 MIT 라이센스로 공개해도 무방합니다. . YYYY년 MM월 DD일 {홍길동} .",
          "url": "blog.chojaeseong.com/_pages/resume.html",
          "relUrl": "/_pages/resume.html",
          "date": ""
      }
      
  

  
  

  

  
  

  

  
  

  

  

  

  

  
  

}