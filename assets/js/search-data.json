{
  
    
        "post0": {
            "title": "TDD 4 자경(controller~view~검증)",
            "content": "ControllerTest for 컨트롤러와 service 형태 결정 . (test)Controller는 InputView를 파라미터로 받는다. . Controller -&gt; ControllerTest에서 컨트롤러 생성 | . controller = new Controller(new InputView()); . (prod)Controller 생성자 내부 new Service( inputXX ) 초기화 . 01 모든 입력을 한번에 다 -&gt; new Service( InputView.getInputDto() ) . 개별 try/catch는 안될 것이다. 처음부터 재입력받는 로직이 필요하다면, 여기를 함수화하고 재귀 걸어주면 될듯 | . | . public Controller(final InputView inputView) { //1-1. 서비스 생성시 inputView에서 한꺼번에 inputDto로 받는 경우 racingService = new RacingService(inputView.getInputDto()); . 01-1 inputDto.of( 개별getInput() , 개별getInput()) 형태로 return . 개별input에서는 출력문 | 기본 scanner input받아서, 공통 NullOrEmpty + 숫자면포맷 | split(,-1)+trim or parseInt의 정제된 형으로 변환 | 원시값 return | | . public class InputView { private static Scanner SCANNER = new Scanner(System.in); //1-3. getINputDto내부에서 사용될 개별 getXXX는 getInput()스캐너에 의존한다. private String getInput() { return SCANNER.nextLine(); } //1-2. 모든 input들을 InputDto.of에 넣어서 InputDto로 반환해주는 작업. // -&gt; dto는 일단 of(모든 속성들을 원시값으로) 받아서 -&gt; new dto( 원시값, 들로 생성)해야한다. public InputDto getInputDto() { return InputDto.of(getNames(), getRound()); } //1-4. 개별 getInput들은 출력 + 공통input검증(nullOrEmpty/format)이 생성된다. // 개별 getInput들은 4단계가 있다고 했다 (1)출력 (2) nullOrEmypy 검증 (3) format검증후convert or split+trim 변환 (4) return public List&lt;String&gt; getNames() { System.out.println(&quot;이름을 입력해주세요&quot;); final String input = getInput(); Validators.checkNullOrEmpty(input); return Arrays.stream(input.split(&quot;,&quot;, -1)) .map(String::trim) .collect(Collectors.toList()); } public int getRound() { System.out.println(&quot;몇 회 진행하겠습니까?&quot;); final String input = getInput(); Validators.checkNullOrEmpty(input); Validators.checkValidFormat(input); return Integer.parseInt(input); } } . 01-2 InputDto는 of 정펙매 -&gt; 생성자 -&gt; 원시값필드 -&gt; getter순으로 정의 . public class InputDto { private final List&lt;String&gt; names; private final int round; public InputDto(final List&lt;String&gt; names, final int round) { this.names = names; this.round = round; } //1-5. of에서 개별input다 받았으면, 그걸로 new생성자 -&gt; 필드 -&gt; getter까지 다 만든다. public static InputDto of(final List&lt;String&gt; names, final int round) { return new InputDto(names, round); } public List&lt;String&gt; getNames() { return names; } public int getRound() { return round; } } . 02 순차적이라면 new Service( 첫input ) -&gt; 메서드파라미터 ( 담input ) . setter금지령으로 인해 -&gt; 메인로직에 필요한 데이터는 생성자에서 객체 생성시 받아 -&gt; 인변에 넣어줘야한다. Controller는 service를 관리하고 있으며, 생성시service 초기화해줘야한다. 그 service 초기화시 받을 input -&gt; 좀있다가 받을 input이 따로 있는 경우 | . | . | . 02-1 첫 입력만 일단 생성자에서 개별input()으로 받는다. . public Controller(final InputView inputView) { // 첫 입력만 일단 생성자에서 개별input()으로 받는다. racingService = new RacingService(inputView.getNames()); . 02-2 개별input() in InputView 정의 . public List&lt;String&gt; getNames() { System.out.println(&quot;이름을 입력해주세요&quot;); final String input = getInput(); Validators.checkNullOrEmpty(input); return Arrays.stream(input.split(&quot;,&quot;, -1)) .map(String::trim) .collect(Collectors.toList()); } . 02-3 그에 따라 Service의 생성자 정의 . public RacingService(final List&lt;String&gt; carNames) { this.cars = new Cars(carNames); } . 원래 service 생성자는.. 일급 및 VO 개발시, 다 받아주는 것으로 정했었다. 여기에 추가해준다. . public RacingService(final List&lt;String&gt; carNames, final int round) { this.cars = new Cars(carNames); this.round = new Round(round); } . | . 03 inputView 콘솔입력(공통검증)부터의 테스트 -&gt; new Controller + InputStream(null불가) . new Controller( new InputView )를 던지면 . Controller생성자에서 inputView.콘솔input() 이 호출된다. | 여러개 개별input()이 포함되어있다면, 그만큼 SequenceInputStream을 던져야한다. | . // 1. 콘솔의 개별input()호출 -&gt; 공통 검증 public Controller(final InputView inputView) { racingService = new RacingService(inputView.getNames()); // 2.정제된 input으로 -&gt; 도메인생성 -&gt; 내부에서 도메인 검증 public RacingService(final List&lt;String&gt; carNames, final int round) { this.cars = new Cars(carNames); . | **테스트는 inpustream에 null은 넣지못하므로 &quot;&quot;빈칸만 테스트한다. ** . 전체 다 맞는 것 + 개별input 갯수만큼 sequence를 만들어줘야하므로 끝나면 가장 마지막에 테스트할 예정으로 바꾼다. | . | . @Test void controller_input_test() { final String argument = &quot;&quot;; final InputStream input = new ByteArrayInputStream((argument + &quot; n&quot;).getBytes()); System.setIn(input); assertThatThrownBy(() -&gt; new Controller(new InputView())) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;빈칸&quot;); } . 재귀추가시 fail 뜨게 되므로 valid한 input을 다시 넣어두자. . @Test void input_null_or_empty_test() { final String argument1 = &quot;&quot;; // 틀 final String argument2 = &quot;재성, 재경&quot;; // 맞아서 재귀 통과 final InputStream input1 = new ByteArrayInputStream((argument1 + &quot; n&quot;).getBytes()); final InputStream input2 = new ByteArrayInputStream((argument2 + &quot; n&quot;).getBytes()); final SequenceInputStream sequenceInputStream = new SequenceInputStream(input1, input2); System.setIn(sequenceInputStream); assertThatThrownBy(() -&gt; new Controller(new InputView())).isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;빈칸&quot;); } . 04 null를 직접하고 싶다면 바로 메서드 유틸Validators.checkNullorEmtpy 자체를 테스트하자. . @Test void input_null_or_empty_in_validator() { assertThatThrownBy(() -&gt; Validators.checkNullOrEmpty(null)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;빈칸&quot;); } . ServiceTest again for 넘어온 정제된input으로 도메인 검증 . 도메인 검증은 controller 생성자에서 inpuView.개별input()에서 건너오는 정제된 input을 받아 관리 도메인으로 넣어주는 Service 생성자에서 한다 . //controller racingService = new RacingService(inputView.getNames()); //service public RacingService(final List&lt;String&gt; carNames) { this.cars = new Cars(carNames); } . | . new Service() -&gt; service.메서드()에서 받아주는 input 순서대로 도메인 검증하기 . new Service( inputView.개별input() )을 호출하면서 내부 ` this.cars = new Cars(carNames);` 도메인 생성자 호출되므로, | inputView.개별input() 자리에 원하는 인자로 테스트한다. | . | . 01 inputView.개별input() 자리에 valid 테스트 데이터 입력 . ServiceTest에서 inputView.개별input()을 받는 곳을 호출하되, 값만 임의로 넣어서 테스트한다. . @Test void valid_domain1_input_check() { //new RacingService(inputView.getNames()) //this.cars = new Cars(carNames); //given final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); //when,then assertDoesNotThrow(() -&gt; new RacingService(names)); } . | . 02 invalid한 테스트 작성하면서, 예외발생토록 도메인 검증 작성 . **invalid한 경우부터는 도메인 검증을 만들고, 예외를 발생시켜야한다. ** . | 도메인 만의 검증을 추가한다. . 복수/일급이라면 복수에 대한 것만 추가한다. | validate( 정제input ) -&gt; 모든 검증 나열하고 나중에, 메서드 추출하기 | . public Cars(final List&lt;String&gt; names) { // 2-5-2. 개별 도메인 검증 메서드 생성 validate(names); this.cars = names.stream() .map(name -&gt; new Car(name)) .collect(Collectors.toList()); } private void validate(final List&lt;String&gt; names) { long distinctCountOfNames = names.stream().distinct().count(); if (distinctCountOfNames != names.size()) { //2-5-3. thr 이후 해당 에외클래스() 생성 -&gt; 필요 예외 상속후 생성자만 메세지 파라미터 없이 정의 -&gt; 내부에서 super(&quot;message&quot;) throw new IllegalArgumentException(&quot;중복값을 입력할 수 없습니다.&quot;); //throw new DuplicateNameException(); } } . | . 03 커스텀 예외클래스 만들기 . thrw new 다음에 발생시킬 에러에 예외 클래스를 명시하고 . 상속할 기존 예외클래스를 extends한 뒤 | 부모예외클래스에서 필요했던 파라미터를 생성자로 받든지 or 내부에서 제공할 것으로, 파라미터 없는 생성자를 정의해주고 | 부모 생성자를 그대로 빌려 super() 내부에서 부모가 필요했던 상수를 생성자 내부에서 정의해주자. | . public class NameDuplicatedException extends IllegalArgumentException { public NameDuplicatedException() { super(&quot;이름이 중복될 수 없습니다.&quot;); } } . | . 04 invalid 테스트 . valid: 올바른_도메인이_들어올_경우를_확인한다 | invalid: 도메인이_중복된_경우_예외를_발생시킨다 | . @Test void invalid_domain2_input_exception_check() { //given final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재성&quot;); //when,then assertThatThrownBy(() -&gt; new RacingService(names)) .isInstanceOf(NameDuplicatedException.class) .hasMessageContaining(&quot;중복&quot;); } . 05 개별input~서비스객체 생성 -&gt; 재귀메서드화 in Controller생성자 . 에러시 재입력 받게 하기 위함. . public Controller(final InputView inputView) { //racingService = new RacingService(inputView.getNames()); getNames(inputView); } private void getNames(final InputView inputView) { try { racingService = new RacingService(inputView.getNames()); } catch (Exception e) { System.out.println(&quot;[ERROR] &quot; + e.getMessage()); getNames(inputView); } } . | . 재귀달린이후 테스트: 틀-&gt;맞으로 구성된 SequenceInputStream . 재귀 달린 순간부터 SequenceInputStream아니어서, 1번 틀리면 ControllerTest 안끝남. . @Test void input_null_or_empty_test() { // final String argument = &quot;&quot;; // final InputStream input = new ByteArrayInputStream((argument + &quot; n&quot;).getBytes()); // // System.setIn(input); final String argument1 = &quot;&quot;; // 틀 final String argument2 = &quot;재성, 재경&quot;; // 맞아서 재귀 통과 final InputStream input1 = new ByteArrayInputStream((argument1 + &quot; n&quot;).getBytes()); final InputStream input2 = new ByteArrayInputStream((argument2 + &quot; n&quot;).getBytes()); final SequenceInputStream sequenceInputStream = new SequenceInputStream(input1, input2); System.setIn(sequenceInputStream); assertThatThrownBy(() -&gt; new Controller(new InputView())).isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;빈칸&quot;); } . | 문제는.. 추가되는 재귀input -&gt; 기존꺼 계속 Sequnece 이어져야함 -&gt; 재귀는 가장 나중에 달던가 [TDD는 하지말자.] . | . 06 메서드 파라미터로 들어오는 개별input과 이미 생성[되었을] service객체 . 이미 controller생성자 위쪽에서, 서비스 생성과 동시에 받아주는 input으로 service객체를 생성한 상태이므로, valid한 앞쪽 개별input을 미리 만들어주고, service객체를 만들어서 테스트해줘야할 듯 싶다. . 먼저 개발된 valid_domain1_input으로 service객체를 먼저 만들면서 메서드 + domain2_input을 넣어주도록 한다. . | 그래야 메서드(initDomain2()) 개발이 된다. . | . @Test void valid_domain2_input_check() { //given final List&lt;String&gt; validNames = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); final int round = 4; //when,then assertDoesNotThrow(() -&gt; new RacingService(validNames).initiateRound(round)) } . | service의 생성자에서 못받은 개별input을, service관리 인변에 넣어주자. . public void initiateRound(final int round) { this.round = new Round(round); } . | 07 invalid case -&gt; 도메인 검증 추가 작업 반복 . @Test void invalid_domain2_input_range_exception() { //given final List&lt;String&gt; validNames = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); final int round = -1; //when,then assertThatThrownBy(() -&gt; new RacingService(validNames).initiateRound(round)) .isInstanceOf(RoundRangeException.class) .hasMessageContaining(&quot;0회 이상&quot;); } . 08 개별input 재귀화 -&gt; TDD는 하지말것 . getRound(inputView); private void getRound(final InputView inputView) { try { racingService.initRound(inputView.getRound()); } catch (Exception e) { System.out.println(&quot;[ERROR] &quot; + e.getMessage()); getRound(inputView); } } . ControllerTest (재귀 올 개발 후 ) . 01 재귀작성 완료후 [개별input ALL 맞-&gt;맞 ]으로 컨트롤러 생성자 테스트 . 재귀가 추가됨에 따라, controller생성시 추가 &amp;&amp; 맞는 것으로 맞춰줘야하는 input이 늘어나기 때문에, controller생성으로 인한 input테스트는 가장 나중에 해야할 것 같다. . 개별input개수만큼 SequenceInputStream으로 들어가게 해준다. | . @Test void controller_input_test() { final String argument1 = &quot;재성, 재경&quot;; // 틀 final String argument2 = &quot;5&quot;; // 맞아서 재귀 통과 final InputStream input1 = new ByteArrayInputStream((argument1 + &quot; n&quot;).getBytes()); final InputStream input2 = new ByteArrayInputStream((argument2 + &quot; n&quot;).getBytes()); SequenceInputStream sequenceInputStream = new SequenceInputStream(input1, input2); System.setIn(sequenceInputStream); assertDoesNotThrow(() -&gt; new Controller(new InputView())); } . | . 02 컨트롤러 생성자withInput 전체를 셋업 올리고 -&gt; Controller.run (new OuputView()) 개발 . Controller controller; @BeforeEach void setUp() { final String argument1 = &quot;재성, 재경&quot;; // 틀 final String argument2 = &quot;5&quot;; // 맞아서 재귀 통과 final InputStream input1 = new ByteArrayInputStream((argument1 + &quot; n&quot;).getBytes()); final InputStream input2 = new ByteArrayInputStream((argument2 + &quot; n&quot;).getBytes()); SequenceInputStream sequenceInputStream = new SequenceInputStream(input1, input2); System.setIn(sequenceInputStream); controller = new Controller(new InputView()); } @Test void controller_run() { controller.run(new OutputView); } . public class OutputView { } . //controller public void run(final OutputView outputView) { //outputView의 기본 프린터 기능 쓰면서 //메인로직 //메인로직이후 service에게서 결과받은 것 -&gt; ouputView가 인자로 받아서 처리 } . 03 controller.run()내부에 service로직 + OuputView처리 . public void run(final OutputView outputView) { outputView.printStartMessage(); while (racingService.isContinuable()) { racingService.race(new RandomNumberGenerator()); racingService.decreaseRound(); } outputView.printRoundResult(racingService.getCurrentCars()); outputView.printWinner(racingService.getWinners()); } . 04 OutputView 결과받아 출력 작성 with OutputView Test . setup . OutputStream output; @BeforeEach void setUp() { output = new ByteArrayOutputStream(); System.setOut(new PrintStream(output)); // output.toString() -&gt; actual 로서 print된 스트링을 받아올 수 있게 된다 } . output에 들어갈 결과(dto or dtoList)를 만들어서 output에 뿌려주기 . @Test void name() { //(1)outputView.printRoundResult(racingService.getCurrentCars()); // racingService.getCurrentCars() -&gt; List&lt;CarDto&gt; 만들어주기 //controller.run()에 사용되던 dto결과들을 단일dto.of() -&gt; dto list -&gt; dtos 까지 직접 만들어준다. final CarDto 재성 = CarDto.of(&quot;재성&quot;, 1); final CarDto 재경 = CarDto.of(&quot;재경&quot;, 2); final List&lt;CarDto&gt; cars = Arrays.asList(재성, 재경); //(2) outputView객체 만들어서 print뿌려주기( output에 박히게 됨 ) new OutputView().printRoundResult(cars); //(3) print뿌려진 output.toString()과 예상string을 비교하기 // -&gt; sout는 System.lineSeparator()로 줄바꿈한다. // -&gt; 내부string은 n로 작성되면 -&gt; n 잡으면 된다. assertThat(output.toString()).isEqualTo(&quot;재성 : - n재경 : -- n&quot; + System.lineSeparator()); } . @Test void name2() { final CarDto 재성 = CarDto.of(&quot;재성&quot;, 1); final CarDto 재경 = CarDto.of(&quot;재경&quot;, 0); final List&lt;CarDto&gt; cars = Arrays.asList(재성, 재경); final CarsDto carsDto = new CarsDto(cars); new OutputView().printRoundResult(cars); assertThat(output.toString()).isEqualTo(&quot;재성 : - n재경 : n&quot; + System.lineSeparator()); } . @Test void name3() { //outputView.printWinner(racingService.getWinners()); // racingService.getWinners() -&gt; CarsDto 만들어주기 final CarDto 재성 = CarDto.of(&quot;재성&quot;, 2); final List&lt;CarDto&gt; cars = Arrays.asList(재성); final CarsDto carsDto = new CarsDto(cars); new OutputView().printWinner(carsDto); assertThat(output.toString()).isEqualTo(&quot;재성&quot; + System.lineSeparator()); } . @Test void name4() { //outputView.printWinner(racingService.getWinners()); // racingService.getWinners() -&gt; CarsDto 만들어주기 final CarDto 재성 = CarDto.of(&quot;재성&quot;, 2); final CarDto 재경 = CarDto.of(&quot;재경&quot;, 2); final List&lt;CarDto&gt; cars = Arrays.asList(재성, 재경); final CarsDto carsDto = new CarsDto(cars); new OutputView().printWinner(carsDto); assertThat(output.toString()).isEqualTo(&quot;재성, 재경&quot; + System.lineSeparator()); } . Application으로 controller.run(new OutputView()) 실행 . import controller.Controller; import view.InputView; import view.OutputView; public class application { public static void main(final String[] args) { final Controller controller = new Controller(new InputView()); controller.run(new OutputView()); } } .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/28/TDD-4-controller~inputview~%EB%8F%84%EB%A9%94%EC%9D%B8%EA%B2%80%EC%A6%9D.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/28/TDD-4-controller~inputview~%EB%8F%84%EB%A9%94%EC%9D%B8%EA%B2%80%EC%A6%9D.html",
            "date": " • Feb 28, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "TDD 3 자경(단일Dto~Service)",
            "content": "Controller와 Service . Controller는 도메인Service 의존하며, 생성자에서 같이 초기화된다. . controller의 생성자에서 inputView와 outputView와 함께, 생성된 or 생성한 service객체를 받아준다. . public GameController(GameService gameService, InputView inputView, OutputView outputView) { //controller가 알고 있던 빈 service객체에 this.gameService = gameService; // 외부에서 받음 this.inputView = inputView; this.outputView = outputView; } . | 컨트롤러 생성시 inputView객체를 받고 . 받은 inputView를 생성자에서 이용하여 inputView.getDto() 등의 데이터를 인자로 받아 Service를 생성한다. | 한번에 input을 받을 수 있을 경우, input에서 getDto로 Service로 다 가져온다. | outputView는 controller 작동시 인자로 받아서 사용된다. | . public GameController(InputView inputView) { //controller가 알고 있던 빈 service객체에 //외부에서 받은 InputView를 이용하여 service를 생성하여 초기화 racingGame = new RacingGame(inputView.getInitDto()); } public void run(OutputView outputView) { playGame(outputView); endGame(outputView); } public static void main(String[] args) { GameController controller = new GameController(new InputView()); controller.run(new OutputView()); } . | 컨트롤러 생성시 컨트롤러 생성자에서 service도 데이터없이 먼저 생성한다. . service가 필요한 데이터는 메서드의 인자로 받아서 service에 set한다. | . public RacingController() { racingService = new RacingService(); } // 한꺼번에 input을 dto로 받는게 아니라면, 개별로 -&gt; 메서드를 통해 input을 따로 입력받는다. racingController.generateRacingCars(carNameInput()); public static void main(String[] args) { RacingController racingController = new RacingController(); racingController.generateRacingCars(carNameInput()); int round = roundInput(); RacingCarOutput.printRoundResultMessage(); race(racingController, round); racingController.checkWinners(); } . | Controller[생성]시 inputView 받 -&gt; Service는 input데이터 받는 안받든 초기화하여 생성. + [작동]시 결과가져 줄OuputView를 받아 전달 . inputView에서 재입력 or 나눠서 받아야하는 경우가 아니라면 new Service( inputView.getInitDto() ) 생성시 받아 생성 | 먼저 서비스부터 생성되고 이후 순서대로 데이터를 set해야하는 경우, 먼저 서비스를 생성 new Service() 이후, 메서드 사용하면서 초기화 | . 객체 -&gt; Service까지 TDD . 단일 객체 TDD . 참고: TDD2 자동차경주 블로그 / DTO 단계별 적용 + 테스트 . 인자 없는 생성자 new Car() + 응답하는 메서드 + 값으로 비교부터 시작해서, 블로그 글을 보고 완성한다. | when 객체 와 생성자로 만든 예상객체를 비교한다. | . @Test void car_move_1step() { final Car car = new Car(&quot;재성&quot;, 0); car.move(4); assertThat(car).isEqualTo(new Car(&quot;재성&quot;, 1)); } @Test void car_move_2step() { final Car car = new Car(&quot;재성&quot;, 0); car.move(4); car.move(4); assertThat(car).isEqualTo(new Car(&quot;재성&quot;, 2)); } @Test void car_move_stop() { final Car car = new Car(&quot;재성&quot;, 0); car.move(3); assertThat(car).isEqualTo(new Car(&quot;재성&quot;, 0)); } . | . 필요시 도메인 검증 테스트 . 단일 Dto TDD . 완성된 단일 객체 -&gt; 꽁꽁 싸멘 일급컬렉션으로 가기 전에, List&lt;단일Dto&gt;가 있어야 일급컬렉션 결과조회 by toDto()로 가능할 것 같다. | . 단일객체의 모든 인스턴스 변수(필드)을 원시값으로 받는 Dto.of( , )로 받도록 정팩매부터 설계하고, getter로 뽑는 확인만 해주자. . final CarDto 재성 = CarDto.of(&quot;재성&quot;, 1); // Car의 모든 필드을 원시값으로 받아 만든다. assertThat(재성.getName()).isEqualTo(&quot;재성&quot;); . private final String name; private final int position; public CarDto(final String name, final int position) { this.name = name; this.position = position; } public static CarDto of(final String name, final int position) { return new CarDto(name, position); } public String getName() { return name; } public int getPosition() { return position; } @Override public boolean equals(final Object object) { . | 일급 TDD . 단일객체들 생성 -&gt; list에 넣기 -&gt; 일급 or 서비스에 넣기 -&gt; 단일객체 조정 -&gt; 그대로 반영 | . 정제가상 재료로 셋업 . input으로 들어오는 List&lt;String&gt;으로 split 정제되어 들어온다고 가정하고 setUp에 세팅한다. . Cars cars; @BeforeEach void setUp() { final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); cars = new Cars(names); } . | 필요시 도메인 검증 테스트 . input에서부터 정제된 데이터(split, convert)가 들어왔을 때, 검증하자. | . 기능 결과 확인용 toDto() 부터 . 일급은 쌓여져있어서 확인이 힘들다. -&gt; toDto()로 List&lt;단일Dto&gt;로 가져와서 확인한다. . 개발1: .getCurrentCars()로서 List&lt;단일Dto&gt;를 가져온다. | . @Test void toDto() { //3-3. 일급의 기능개발 전, 확인이 될 수 있게 현재 객체들을 Dto List로 가져오는 기능 // -&gt; 내부에서 dto가 단일객체를 이용하도록 짤 것 final List&lt;CarDto&gt; currentCars = cars.getCurrentCars(); // assertThat(currentCars.get(0)).isEqualTo(CarDto.of(&quot;재성&quot;, 0)); // List의 검사는 contains, containsOnly로도 검사할 수있따. assertThat(currentCars).contains(CarDto.of(&quot;재경&quot;, 0)); } . | . 일급.toDto()를 통한 메서드 기능 테스트 . 각종 확인 방법 . 일급.toDto() contains ( 예상객체 by Dto.of) | 일급.toDto() containsOnly ( 예상객체1, 2 by Dto.of) isEqualTo ( Arrays.asList(예상객체1, 2 by Dto.of)) | . | 일급.toDto() .get( index) isEqualTo ( **예상객체 by Dto.of **) | 일급.메서드() -&gt; 객체 isEqualTo ( **예상객체 by Dto.of **) | 단일Dto.from( 객체 1개 ) 개발 .getter() isEqualTo ( 값 ) | . @Test void race_move_1step() { cars.race(5); assertThat(cars.getCurrentCars()).contains(CarDto.of(&quot;재성&quot;, 1)); } @Test void race_move_0step() { cars.race(3); assertThat(cars.getCurrentCars()).contains(CarDto.of(&quot;재성&quot;, 0)); } @Test void get_max_position_cars() { cars.race(4); final Car maxPositionCar = cars.getMaxPosition(); assertThat(CarDto.from(maxPositionCar).getPosition()).isEqualTo(1); } . | . 단일Dto.from( 응답객체 ) 개발 -&gt; (객체비교불가상황)응답 값 1개만 getter 추출 -&gt; 값 비교 테스트 . 현재 maxPosition인 Car객체 (List)를 뽑기 위해 중간, Car객체 1개 추출 로직을 테스트해야한다. . actual에서 단일객체 1개마 뽑히는 상황 -&gt; 단일객체1 to 단일Dto로 바로 가도록 단일Dto.from() 정펙매를 만들어줘야 -&gt; 값을 추출할 수 있다. | 필드 1개만 알고 있는 상황을 확인해야하므로, max인 값을 가진 Car를 뽑아내기 때문에, 임의로 CarDto.of( , , )로 만들 수 없는 상황 | . @Test void get_max_position_car() { cars.race(4); final Car maxPositionCar = cars.getMaxPosition(); // 이름은 모름, position만 1인 것을 아는 상황. -&gt; 값으로 비교해야함 -&gt; Dto에서 뽑아내야함. } . public static CarDto from(final Car car) { return new CarDto(car.getName(), car.getPosition()); } . @Test void get_max_position_car() { cars.race(4); final Car maxPositionCar = cars.getMaxPosition(); //my) &lt;일부 속성(이름제외된 숫자속성)만 변화되어, 객체==만든 예상객체&gt;의 비교가 불가능할 경우, // 실제 객체를 -&gt; dto변형 후 값을 뽑아내 -&gt; 값 대 값으로 확인할 수 도 있다. assertThat(CarDto.from(maxPositionCar).getPosition()).isEqualTo(1); } . | . 일급의 응답(List&lt;객체&gt;)는 -&gt; 한방에 DtoList or 복수Dto로 한방에 . 일급이 사용되는 serivce에게는 DtoList or 복수 Dto로 응답해야한다. . 어차피 응답은 객체List로 오니 -&gt; 복수Dto.from( List&lt;객체&gt;)로 한방에 돌리자. | 내부에서 이미 개발된 stream 단일객체 + 단일Dto.from( 단일객체) -&gt; list로만 만들어주면 된다. | 대신 dto용 getter에 이름을… get()로 단순화시키자. | . @Test void get_max_position_cars() { cars.getWinners(); } . //일급 응답이 객체리스트? -&gt; 한방에 복수Dto.from만들기 public List&lt;Car&gt; getWinners() { final Car maxPositionCar = getMaxPosition(); return this.cars.stream() .filter(car -&gt; car.isSamePosition(maxPositionCar)) .collect(Collectors.toList()); } . // 이미 단일Dto.from이 개발된 상황이라면, // 객체리스트 -&gt; 복수Dto 한방에 개발한다. return CarsDto.from(this.cars.stream() .filter(car -&gt; car.isSamePosition(maxPositionCar)) .collect(Collectors.toList())); . public static List&lt;CarDto&gt; from(final List&lt;Car&gt; cars) { // 단일Dto List로 일단 만든 뒤 -&gt; 생성자 호출 예정 return cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList()); } . return CarsDto.from(this.cars.stream() .filter(car -&gt; car.isSamePosition(maxPositionCar)) .collect(Collectors.toList())); . private final List&lt;CarDto&gt; carsDto; public CarsDto(final List&lt;CarDto&gt; carsDto) { this.carsDto = carsDto; } public static CarsDto from(final List&lt;Car&gt; cars) { return new CarsDto(cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList())); } //public List&lt;CarDto&gt; getCarsDto() { public List&lt;CarDto&gt; get() { return carsDto; } . dtoList .get() -&gt; Dto List -&gt; 1개 뽑아서 값 비교..(현재 이름모르고 1개 값만 아는 상태) | . @Test void get_max_position_cars() { cars.race(4); cars.race(4); cars.race(4); final CarsDto winnerCars = cars.getWinners(); //복수Dto.get() -&gt; List &lt;단일Dto&gt; assertThat(winnerCars.get().get(0).getPosition()).isEqualTo(3); } . | . Service 객체 TDD . inputView로부터 오는 도메인의 재료를 컨트롤러 내부에서 생성될 때, 생성자로 될 때 받을지 | 객체생성 후, generate로 | | input재료들 -&gt; 받아서 생성자를 통한 일급 or List단일로의 변환 생성도 서비스 안에서 이루어진다. 필요재료라 인스턴스 변수로 관리해야한다. | . | . 재료없이 service객체 셋업 (원래 미리 생성 in 컨트롤러) . 컨트롤러에서 사용한다고 생각하자. . | 일단 컨트롤러 생성자에서부터 미리 서비스를 미리 생성시킬 예정이다. . 재료가 한번에 오면 initDto -&gt; service미리 생성시킬 시 받아주면 되는데 . @BeforeEach void setup() { racingGame = new RacingGame(InitDto.of(&quot;juri,hunch&quot;, &quot;5&quot;)); } . | 그게 아니라면, service.generate일급()처럼, 원재료를 일급/List객체로 변환하는 작업도 service가 담당한다. . public RacingController() { racingService = new RacingService(); } . | . | 셋업에 서비스 미리 생성 . RacingService racingService; @BeforeEach void setUp() { racingService = new RacingService(); } . | . input재료들을 받는 service 생성자도 만들어, 셋업에서 관리변수 채워놓기. . input을 나중에 받더라도.. 미리 만들어져있어야하구나. 그래야 꺼내는 기능만을 확인할 수 있다. . | service안에 관리 변수에 뭐가 들어있어야… 확인이 된input원재료 -&gt; 관리 변수 (Cars cars)를 통채로 받아주는 놈을 임시로 만들자. . 검증은 각 도메인 내에서 할 것임. 변환생성해주는 서비스에서 하지말자. | . @BeforeEach void setUp() { final List&lt;String&gt; carNames = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;, &quot;아라&quot;); racingService = new RacingService(carNames); } . private Cars cars; public RacingService(final List&lt;String&gt; carNames) { this.cars = new Cars(carNames); } . | . 기능 결과 확인용 일급.toDto() 호출 함수부터 . 서비스는 내부에 인스턴스변수로 일급 (or 객체List)를 관리한다. . 일급이나 객체List를 확인하는 방법은 toDto로 미리 정의해놓았다. | 이것을 부르는 메서드(getCurrent일급())를 먼저 TDD한다. 이름만 get일급()이지, toDto한 List&lt;Dto&gt;를 가져온다. | . | . @Test void get_current_cars() { racingService.getCurrentCars(); } . public class RacingService { public void getCurrentCars() { this.cars.getCurrentCars(); } } . public class RacingService { private Cars cars; public List&lt;CarDto&gt; getCurrentCars() { return this.cars.getCurrentCars(); } } . java @Test void get_current_cars() { final List currentCars = racingService.getCurrentCars(); . assertThat(currentCars).contains(CarDto.of(&quot;재성&quot;, 0)); } . | . 미리 안넣어놓고, 차후 setter역할의 service.generate()로 input재료 -&gt; 해당도메인 객체(일급) 변환 생성 TDD . 서비스는 해당도메인의 기능을 모아둔 것이다. 일단 해당도메인으로 변환시킨다. . 서비스.해당도메인생성( input재료) -&gt; 내부 관리 인스턴스 변수(일급orList)에 set되는 것을 확인해야한다. | 그것을 빼쓰라고 만든게 일급.toDto()있으니, 서비스에서 일급DTO내놔 메서드를 호출해서 컨트롤러에 제공해준다. | . @Test void generate_cars() { //given: input에서 오는 원재료 final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); //when racingService.generateCars(names); } . public class RacingService { public void generateCars(final List&lt;String&gt; names) { this.cars = new Cars(names); } } . public class RacingService { private Cars cars; public void generateCars(final List&lt;String&gt; names) { this.cars = new Cars(names); } } . @Test void generate_cars() { //given: input에서 정제된 원재료 final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); racingService.generateCars(names); //when //then assertThat(racingService.getCurrentCars()).contains(CarDto.of(&quot;재성&quot;, 0)); } . | . 필요시 전략객체 service에서 생성하여, 메서드의 파라미터로 넣어주기 . 들어간 Service 변수(인스턴스 변수, 필요 변수)확인 테스트 . 관리(인스턴스) 변수 중 VO는 getDto없이 asssertThat().extracting으로 내부 인변 바로 뽑아 확인하기 . input정제 VO 원시값까지 받아주는 service 생성자 추가 생성 . @Test void get_round() { racingService = new RacingService(carNames, 5); } . VO 객체 개발 . //서비스 생성자 추가 public RacingService(final List&lt;String&gt; carNames, final int round) { this.cars = new Cars(carNames); this.round = new Round(round); } //VO 개발 public class Round { private final int round; public Round(final int round) { this.round = round; } @Override public boolean equals(final Object object) { . VO를 받아서 생성하는 service를 초기화 후, extracting으로 객체 뽑아서 1:1비교 . 기존 서비스는 노인자 -&gt; names(stringList-&gt;일급) -&gt; names 포함한 VO까지 받아서 처리 | . @Test void get_round() { racingService = new RacingService(carNames, 5); //when, then assertThat(racingService).extracting(&quot;round&quot;).isEqualTo(new Round(5)); } . 메인로직 TDD . 메인로직 실행 . 일급.메서드()를 실행시키는 단순로직 . 응답 값이 없는 실행 메서드다? 사용객체와 예상객체로 비교 | 랜덤값이 포함되어있으면, 그만큼 빼줘야한다… 하지만, 그냥 빼면… 일괄 적용되므로, 인터페이스로 빼고 -&gt; 필요한 곳에서 전략메서드 호출()하도록 뺀다. 테스트에선 전략객체 대신 최종 결과값만 넣어주면 됨. (여기선 생략) | . | . @Test void race() { racingService = new RacingService(carNames, 5); racingService.race(); racingService.race(); assertThat(racingService.getCurrentCars().get(0).getPosition()).isEqualTo(2); } . 전략 인페 + 전략메소드 정의 | 전략을 구현한 랜덤인페 + 메소드 정의 | 전략메소드 호출시점에만, 메소드 호출하여 랜덤 시행 + 그외에는 전략객체만 파라미터로 수정 | 테스트에선 람다식으로 인자 없이 랜덤한 return값을 직접 지정 () -&gt; return을 준다. | | . 메인로직 실행 횟수(VO)의 iterator TDD . service가 만들어질 때나, 만들어진 이후 가지고 set되어야할 VO는 service내부 관리 변수 확인 테스트에서 처음 등장했다. . @Test void get_round() { racingService = new RacingService(carNames, 5); assertThat(racingService).extracting(&quot;round&quot;).isEqualTo(new Round(5)); } . | 컨트롤러에서 service.메인로직()을 service.hasNext(VO)만큼 돌려야한다. . | . 01 service. isContinuable() -&gt; Vo.isNotFinish() -&gt; true/false를 테스트한다. . hasNext패턴의 while()문에 들어갈 조건부이다. . @Test void vo_is_continuable() { racingService = new RacingService(carNames, 5); final boolean isContinuable = racingService.isContinuable(); assertThat(isContinuable).isTrue(); } @Test void vo_is_not_continuable() { racingService = new RacingService(carNames, 0); final boolean isContinuable = racingService.isContinuable(); assertThat(isContinuable).isFalse(); } . //Service public boolean isContinuable() { return this.round.isNotFinish(); } //Round public boolean isNotFinish() { return this.round &gt; 0; } . | . 02 service.play메인로직() 내부에서 -&gt; 메인객체.메인로직() 와 동시에 돌아갈 + VO감소로직 VO.getNext(); 처리 . VO감소 -&gt; 감소된 VO반환하여 service관리 VO를 덮어쓰기 . 이 과정이 while문 true 내부 메인로직 돌아갈 때 같이 돌아가야한다. | . @Test void vo_can_decrease() { racingService = new RacingService(carNames, 4); //프로덕션코드에서는, 반복될 메인로직 실행부 메서드와 같이, race실행시 round감소를 같이시켜줘야한다. //racingService.play(); racingService.playWIthRoundDecrease(); } . //Service public void playWIthRoundDecrease() { //1. 메인(일급)객체.race() //2. decrease된 vo를 받아와야함 *값만 변화(round.decrease())하면 안됨 round = round.getNext(); } . //Round public Round getNext() { // 여기서는 0보다 커야한다는 검증이 있으면 0으로 갈때 에러가 나니 조심! // 검증은 hasNext패턴을 가지는 VO는 무조건 검증을 정팩메에 주자~ return new Round(this.round - 1); } . @Test void vo_can_decrease() { racingService = new RacingService(carNames, 4); //프로덕션코드에서는, 반복될 메인로직 실행부 메서드와 같이, race실행시 round감소를 같이시켜줘야한다. //racingService.play(); racingService.playWIthRoundDecrease(); //내부의 round값이 변화되기 때문에 -&gt; 응답 값이 아닌 사용객체 vs 예쌍객체로 비교해야한다. assertThat(racingService).extracting(&quot;round&quot;).isEqualTo(new Round(3)); } . | . 랜덤응답의 범위 TDD(단위테스트) . 랜덤을 생성하는 메서드를 학습하는 단위테스트 범위내로 들어오나? -&gt; isBetween(a, b) -&gt; a&lt; = &lt;= b의 검사 | . | . 값 1개의 랜덤: @RepeatedTest() + .isBetween . //사용할 객체 만들고 RandomNumberGenerator randomNumberGenerator; @BeforeEach void setUp() { randomNumberGenerator = new RandomNumberGenerator(); } //응답값의 범위 확인을 여러번 @RepeatedTest(100) void range_test() { assertThat(randomNumberGenerator.generate()).isBetween(0, 9); } . List의 랜덤: iterator의 hasNext패턴 -&gt; 객체비교 . @Test void Random_숫자범위_검사() { // 원래는 랜덤으로 차있는 list -&gt; iterator final ListIterator&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 44, 45).listIterator(); // 랜덤값들을 돌면서 검사 while (numbers.hasNext()) { assertThat(numbers.next()) .isGreaterThanOrEqualTo(1) .isLessThanOrEqualTo(45); } } .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/26/TDD-3-%EB%8B%A8%EC%9D%BCDto-~-Service.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/26/TDD-3-%EB%8B%A8%EC%9D%BCDto-~-Service.html",
            "date": " • Feb 26, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "TDD 2 자동차경주(객체Dto)",
            "content": "실패하는 코드를 짜는 이유? 통과하는 코드를 짜려고 하면, case단위가 아니라 다 짜야해서 너무 커진다. | case 만드는 것이 목적 -&gt; 실패 case부터 만든다. | . | 테스트코드도 복잡도를 낮춘다. | . 기능 요구사항 복붙후 정리 . 복붙 . 각 자동차에 이름을 부여할 수 있다. 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다. 자동차 이름은 쉼표(,)를 기준으로 구분한다. 자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한명 이상일 수 있다. . 제목(##) + 앞에 체크박스 만들기 . ## 요구사항 - [ ] 각 자동차에 이름을 부여할 수 있다. - [ ] 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다. - [ ] 자동차 이름은 쉼표(,)를 기준으로 구분한다. - [ ] 자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한명 이상일 수 있다. . 각 요구사항들을 테스트코드 DisplayName으로 작성하기도 한다. | . 키워드 뽑기 . ## 요구사항 - [ ] 각 자동차에 이름을 부여할 수 있다. - [ ] 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다. - [ ] 자동차 이름은 쉼표(,)를 기준으로 구분한다. - [ ] 자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한명 이상일 수 있다. - 자동차 - 이름 - 자동차 이름은 쉼표(,)를 기준 - 전진 - 게임 - 우승 - 우승자는 한명 이상 . 키워드 관계 재배치 . 객체인지 vs 메서드인지 vs 세부 요구사항인지 | 객체 중에 이름만 다르게 뽑을지 -&gt; 뽑는 것은 관리자 객체에서 우승한 자동차 -&gt; 자동차 중 뽑은 것 -&gt; 자동차 경주(관리자) | . | . - 자동차 - 전진: 자동차가 하는 것이니 객체가 아닌 메서드 - 우승한 자동차: 따른 객체인지 vs 자동차 중 뽑아서 이름만 다르게? - 우승자는 한명 이상: 세부 요구사항 - 이름 - 이름은 쉼표(,)를 기준: 세부 요구사항 - 자동차 게임: 자동차에서 우승한 자동차 뽑는 것은 이상하니, 게임이 관리하면서 뽑도록 - 우승한 자동차: 따른 객체인지 vs 자동차 중 뽑아서 이름만 다르게? - 우승자는 한명 이상: 세부 요구사항 . 시작점 고르기 . 자동차 게임 -&gt; 관리자부터 하기엔 잘 모름 | 자동차 -&gt; 핵심이자 간단한 단위 객체 진짜 잘 모르겠으면 이름부터 해도 된다. | . | . 출력, View에 대한 요구사항은 무시하고 객체 설계부터 시작 . UI, view를 맨나중에 붙이면, 객체다운 객체가 완성됨. | . TDD 시작 . 정의 없는 default생성자 사용 / 응답 하는 메서드부터 . TDD 시작점을 new Car();의 생성자에서 부터 시작하는 경우가 많다. . 보통은 Car car = new Car();의 생성자로 TDD를 시작한다. 여기서 시작해서 테스트 코드로 변하게 된다. | . | . @Test void 생성자_검사() { //방법1. 생성시 예외발생안함. assertDoesNotThrow(() -&gt; new Car(재성)); //방법2. 생성한 것이 null이 아님. final Car car = new Car(&quot;재성&quot;); assertThat(car).isNotNull(); } . | 여기서는 객체 생성자와 동시에 상수 먼저 응답하는 기능 메서드를 주 테스트로 시작한다 . 움직였을 때, 1칸 움직였다고 -&gt; 상수 1을 응답할거라 가정하고 작성한다. | . //1. 객체+Test로 테스트 class 작성 public class CarTest { @Test //2. (생성자 따로 검사하는게 아닌) 객체의 기능으로 메서드 명 먼저 작성 void move() { //3. 없어도 객체 생성자 호출 final Car car = new Car(); //4. 객체 기능을 호출하되, 테스트에 용이하도록 &lt;호출시 응답 결과값&gt;이 있을 거라 예상 -&gt; assertThat( actual )에 바로 값 넣어주기 //car.move() //5. 기대하는(나와야하는) 응답 값을 .isEqualTo( expected )에 넣어주기 assertThat(car.move()).isEqualTo(1); } } . | 컴파일 에러들을 잡는다. . 예상하는 응답값을 상수로 바로 나오도록 먼저 작성한다. | . public class Car { public int move() { return 1; } } . | 테스트를 돌려서, 상수 1로 응답하는지 확인한다. . | . case 추가(누적 -&gt; 응답 expected 변경 2) . 복붙으로 다른 Test case(메서드 맨끝_네임 수정)를 작성하며 안돌아가는 코드 구현 . 1칸 움직여서 1 반환하는 case도 있지만, 2번 움직이는 or 안 움직이는 케이스도 있음. . 메서드를 복붙해서 case를 나눈다 | . @Test void move_go() { final Car car = new Car(); assertThat(car.move()).isEqualTo(1); } @Test void move_go2() { final Car car = new Car(); //1. car.move(); //2. assertThat(car.move()).isEqualTo(2); // 2를 응답해줘야함. } . | . 기존 작성된 메서드를 메서드2로 복붙한 뒤 구현 . 기존 코드는 돌아가도록 하는 상태(move() 그대로 두기)에서 move() -&gt; move2()로 복붙한 뒤, 직전꺼도 포함해서 다 돌아가도록 구현 . package domain; public class Car { public int move() { return 1; } public int move2() { return 1; } } . 누적되려면, 저장할 변수가 필요해서 필드(인변)를 선언하여 거기다가 가지고 있도록 한다.. | . public int move2() { return position++; } . public class Car { private int position; public int move() { return 1; } public int move2() { return ++position; } } . | . 복붙 수정 메서드2를 사용해서 통과시켜본다. . 복붙new Test method 에서 복붙 method2()를 사용해서 통과시킨다. . @Test void move_go2() { final Car car = new Car(); //1. car.move2(); //2. assertThat(car.move2()).isEqualTo(2); } . | . 기존case도 수정 메서드2로 변경해보고 -&gt; 기존메서드()는 회색띄운 뒤 삭제 . 처음 테스트도 .move2()를 사용하게 한 뒤 테스트 . | 테스트 통과하면 기존 move()는 사용안되서 회색 떠있음 -&gt; alt + del로 안전삭제 . @Test void move_go() { final Car car = new Car(); assertThat(car.move2()).isEqualTo(1); } @Test void move_go2() { final Car car = new Car(); //1. car.move2(); //2. assertThat(car.move2()).isEqualTo(2); } . | . 최종 수정메서드2 -&gt; 매서드로 이름 변경 . .move2()가 -&gt; .move()를 대체하는 순간 . @Test void move_go() { final Car car = new Car(); assertThat(car.move()).isEqualTo(2); } @Test void move_go2() { final Car car = new Car(); //1. car.move(); //2. assertThat(car.move()).isEqualTo(2); } } . | . case 추가(조건 따라 stop -&gt; expected는 stop일때 나와야하는 값으로 미리 넣어두기 0) . 복붙 Test case 추가 ( 설계전 해당 case expected입력해서 error) . move_stop케이스 추가 -&gt; expected 0을 응답하도록 작성하기 . @Test void move_stop() { final Car car = new Car(); //1. 1번움직였는데 &gt; 0을 응답해야하는 경우도 처리 assertThat(car.move()).isEqualTo(0); } . | . 메서드2()로 복사해서 다시 처리 . 해당 조건일 때만 움직이게 해준다. . public int move2() { if (ThreadLocalRandom.current().nextInt(10) &gt;= 4) { position += 1; } return position; } } . | . 내부 랜덤 포함 메서드는 테스트 실행시마다 결과가 다르다. . 특정 테스트 바깥에 커서를 두고 전체 테스트 실행 랜덤이 껴있는 경우 돌릴 때 마다 다르게 결과 | . | . 랜덤은 가능한 구조로 바꿔주기 . 랜덤부분만 파라미터화시켜 밖으로 빼준다. . 기존 . public int move() { if (ThreadLocalRandom.current().nextInt(10) &gt;= 4) { position += 1; } return position; } . | 파라미터화시켜 밖으로 빼기 . 자동으로 사용중이던 부분(랜덤)이 –&gt;메소드 사용처로 이동된다. | . public int move(final int number) { if (number &gt;= 4) { position += 1; } return position; } . assertThat(car.move(ThreadLocalRandom.current().nextInt(10))).isEqualTo(0); . | . 사용처의 랜덤생성을 특정 상수로 바꾼다. . 랜덤은 프로덕션 코드에서만 사용되므로 추출되어 사용처로 옮겨간 랜덤부분을 테스트에서는 상수로 변경한다. . @Test void move_go2() { final Car car = new Car(); car.move(5); assertThat(car.move(5)).isEqualTo(2); } @Test void move_stop() { final Car car = new Car(); assertThat(car.move(3)).isEqualTo(0); } } . | . 랜덤 뿐만 아니라 랜덤포함조건자체를 객체의 역할로 . 객체가 테스트를 위한 랜덤부분 외부 파라미터로 추출 뿐만 아니라 . | if 조건에 따른 다른 역할을 하는 객체로 취급하고 싶다면 if조건 자체를 인터페이스로 추출할 수 있다. . 전략패턴은 대체가능한 다른전략을 넣는 부분을 인터페이스 -&gt; 전략메서드로 추출해놓는다. | . 바뀔 수 있는 부분을 잡아서 상태에 맞게 메소드로 추출해놓는다. . | 인터페이스 XXXXStrategy + 이름만 가진 추상메서드를 만든다. . | 특정Strategy의 이름을 정해서 impl구상클래스를 추출메소드를 복붙해서 구현한다. . | 특정전략의 메소드가 사용된 곳마다 —&gt; 다른전략을 허용하는 추상화된 인터페이스 객체를 인자로 받은 뒤 -&gt; 추상체.추출메소드()호출로 수정한다. . | 이제 에러난 부분을 타고가면서, *내부 매개변수 정의에 사용된 추상 인자를 호출하는 외부 인자 자리에 new 특정전략()를 넣워준다. . | 테스트에서 다른전략으로 조건부의 상수인 람다함수로 () -&gt; true를 대입하여 움직임을 확인한다. . | | . 확인을 위한 응답 값(조회)이 실제 필요한지 의심해봐야한다 . 내부 position만 바뀌면 되는데, 테스트를 위해 응답하고 있지는 않은지 의심하자. | . 응답하는 것도 1가지 일(조회)다. 위치변경(테스트할 기능) + 조회 2가지 일을 하는 move() . 포지션을 조회하고 싶다면 또다시 car.move()를 호출해서 확인해야하나? 변하면서 조회되므로 이상하다. . public int move(final int number) { if (number &gt;= 4) { position += 1; } return position; } . | 조회는.. 응답 말고도 다른 방법이 있다. 값으로 만드는 객체로 비교 . | . 조회 메서드가 아니라면, 테스트 끝난 후, 응답 값 제거리팩토링 . 메서드2() 복붙 생성하여, 응답이 제거된 메서드2 생성 . public int move(final int number) { if (number &gt;= 4) { position += 1; } return position; } public void move2(final int number) { if (number &gt;= 4) { position += 1; } } . | Test에서는 assertThat()에 응답 값을 넣어줘야하는데? . assertThat(car.move(3)).isEqualTo(0); . | . 응답 값 대신 [해당객체]를 / expected 예상값 대신 예상값으로 생성한 + equals옵라된 [예상객체]를 . 예상값으로 예상객체를 만들어줄 생성자를 추가한다. . | 기존에는 default 생성자로서, 인자 없이 만들었다. Select None으로 기존 것도 사용가능하게 빈 default 생성자를 따로 정의해주자. . . public Car() { } . | 생성된 객체로 비교하기 위해, equals, hashCode를 옵라이딩 . | 응답 없는 메소드2로 치환 후, 객체.메서드2호출 - assertThat(객체). (예상객체) 로 비교 . 이제 전부 응답없는 메소드2로 치환 -&gt; actual 응답 자리에서 빼주기 . @Test void move_go() { final Car car = new Car(); car.move2(4); // 1.actual에는 실제응답 대신, 객체를 assertThat(car).isEqualTo(new Car(1)); // 2. 예상값으로 만든 예상객체 } . | 기존 assertThat( 응답값 ) .isEqualsTo ( 예상값) . assertThat(car.move(4)).isEqualTo(0); . | assertThat( 사용객체 ) .isEqualsTo ( 예상객체) . ar.move2(4); assertThat(car).isEqualTo(new Car(1)); . | . 생성자도… 테스트를 위한 생성자인지 고민 -&gt; 그렇다면 .getPosition() 대신 .position()으로 마무리? . get이라는 네이밍을 빼서 내부에 position이 있는지 모르게 하는게 핵심 | . 외부추출랜덤은 상위 객체 테스트를 막는다 . 자동차.move()의 내부 랜덤 추출 -&gt; 자동차.move(랜덤사용) -&gt; 자동차.move(랜덤사용)을 호출하는 자동차경주가 내부 랜덤을 포함하게 됨. | . 상위 객체(관리자) Test -&gt; List&lt; 테스트끝난객체&gt; 를 받도록 생성 -&gt; 돌면서 시켜야함. . 단일 테스트가 끝난 단일객체에 대해서 일급 컬렉션 생성 전 LIst&lt;단일&gt;을 사용 == 세팅by생성자( List&lt;단일객체&gt; )하는 상위객체, 관리자객체를 Test서부터 만든다. . 필요한 것은 set을 생성자에서 받는다. | 다 못받으면, 필요기능의 메서드 파라미터로 | . @Test void name() { final List&lt;Car&gt; cars = Arrays.asList(new Car(), new Car()); final RacingGame racingGame = new RacingGame(cars); } . public class RacingGame { public RacingGame(final List&lt;Car&gt; cars) { } } . public class RacingGame { private final List&lt;Car&gt; cars; public RacingGame(final List&lt;Car&gt; cars) { this.cars = cars; } } . | 관리자=상위객체에서 메서드() -&gt; list를 돌며 단일객체 메서드 시키기 . public class RacingGame { private final List&lt;Car&gt; cars; public RacingGame(final List&lt;Car&gt; cars) { this.cars = cars; } public void start() { cars.forEach( car -&gt; car.move(ThreadLocalRandom.current().nextInt(10))); } } . | Car만 테스트는 가능하고, 그 상위객체인 RacingGame은 테스트가 불가능한 상태다. . 원한다면 다시 랜덤부분을 파라미터로 추출하면 된다. | 어디까지 테스트가능 구조로 할지는 자기가 선택하는 것 | 상위객체도 테스트 가능한 구조로 만들고 싶다면, 파라미터화시켜 외부로 빼면 된다. | . | 가장 끝단의 객체를 찾고, 테스트 불가 부분을 밖으로 뺀다. . . 한단계 더 올리면, RacingGame도 테스트가 가능해진다. . . | 랜덤, 특정 날짜에만 작동 등이 테스트하기 힘든 코드다. . 외부로 분리해서 주입한다. | . | . .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/24/TDD-2-%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/24/TDD-2-%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Feb 24, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "피드백) 1-1(자동차경주) 코드리뷰",
            "content": "자경 미션 피드백 . PR 1차 피드백 | PR 2차 피드백 리뷰어: 코니 | . | . 네이밍 . if절에 들어가는 메서드명은 is~, has~로 시작하자. | VO의 새객체 반환 메서드네이밍을 toNextRound()로 잡았다. to는 괜찮을까? toString, toDto 같이 형 변환시에만 사용하자.. 또 바꿔야겟넹.. getNextRound() | . | Util이라는 추상적인 이름 대신 Validator처럼 구체적인 이름으로 클래스 잡기 . | 조건문 전체가 아니라, 일부 값 비교에서도 네이밍을 변수로 추출하는게 좋다 . private static void checkDuplicated(List&lt;String&gt; carNames) { if (carNames.stream().distinct().count() != carNames.size()) { long distinctCountOfCarNames = carNames.stream().distinct().count(); if (distinctCountOfCarNames != carNames.size()) { . | 추출할 때, 메서드의 인자는 구체적으로X 좀더 추상적으로 정의해주기 | . 체크 . 메소드 사용 순서대로 배치후 commit -&gt; 커밋전 체크리스트화 structure(alt+7) | . | 불필요 공백 제거후 coimmit | 테스트 코드 돌리고 commit @parameterizedTest &lt;-&gt; @Test | . | intellij 상수, 변수추출을 private으로 최초 1번 옮겨주기 | 유틸이라도 해당 class에서만 사용된다면, private 으로 변경해줘야한다. . | static 유틸 클래스는 private생성자로 객체생성없음을 명시해주기 | 상수 &lt;-&gt; 멤버변수 개행 1줄 넣어주기 . | 전략메서드에는 인페/클래스명에 있는 목적어(number)를 repeat할 필요없다. 동사(generate)만 | . 검증 . 실수로 기입된 내부공백(Blank) 검사는 문자열숫자의 format검사가 있다면 안해도 된다. . | 부정조건문 없애자 . | . 생성자 . static 유틸 클래스는 private생성자로 객체생성없음을 명시해주기 . | 접근제한자 기본은 private으로 바꿔주기 . | 도메인은 input이외에 자체 검증 -&gt; input에서는 공통검증 / 도메인 자체검증 생성자 . | 생성자 로직 private 기본 생성자 | public from( 원본 List&lt; Car&gt;) + Cars검증로직(중복 등) | public fromNames or fromInput(List&lt; String &gt;) + Cars검증로직(중복 등) | . | 테스트에서 단일-&gt; 단일List 만든 뒤, 단일 조정 by메서드 -&gt; 단일List에 반영 -&gt; 반영된 단일List로 일급컬렉션 생성 | 불변을 위해 포인터의 포인터 사용을 막아야하는데, 테스트에서는 포포를 사용할 수 있게 inputString List가 아닌 단일객체List로부터 만드는 생성자(정펙매) 추가 | . | . 기본 . split은 2번재 인자를 줘야, ,, 를 안씹고 간다. -&gt; split( , -1) . String[] split = &quot;,,&quot;.split(&quot;,&quot;); // count 0 String[] split1 = &quot;,,a&quot;.split(&quot;,&quot;); // 3 String[] split2 = &quot;,a,&quot;.split(&quot;,&quot;); // 2 String[] split3 = &quot;a,,&quot;.split(&quot;,&quot;); // 1 . | split후 trim까지 해서 반환해야 a, a를 다른 것으로 인식한다. -&gt; split(,-1).map(String::trim) . return Arrays.stream(value.split(delimiter, -1)) .map(String::trim) .collect(Collectors.toList()); . | convert나 split관련 기본api가 충분하면, 유틸 메서드로 따로 빼지말고 그냥 사용하자. 지식만 늘어난다. . | 조건문의 전략객체(Functional interface)에는 () -&gt; 람다식으로 테스트한다. . | . VO, DTO . Dto는 controller에 일단 넣어준다. . | ROUND는 hasNext패턴으로 줄어가는데, 생성자 검증은 1이상 &lt;-&gt; 1씩 줄여가니 0까지는 감. 생성자에서 검증하되, 새객체 반환은 검증없는 private 기본생성자이용 | . | DTO는 VO나, 포장객체 없이 only 원시값들로 필드가 구성 -&gt; Dto사용을 위한 원본 getter에서는 VO-&gt;value까지 최종반환시킨 getter . | VO를 가진 단일객체의 compareTo에 원시값 비교 x -&gt; VO로 비교 -&gt; VO도 비교가능하게 . | 정펙매 생성자 중간에 VO가 등장할 경우, getter()를 써도 된다. . | VO는 검증/불변을 위해 래핑한 것이므로, 도입했다고 굳이 정펙매를 외부에 오픈안해도 된다 . private Cars getCars() { try { return Cars.fromNames(InputView.getCarNames()); //Cars.fromNames(Names.fromInput(InputView.getCarNames())); . 같은 context에서 사용될 일이 없는, 객체 생성 가운데 활용되는 객체들은 구현을 드러내지 않는 것이 좋을 것 같습니다! | . | . 테스트 . DTO의 테스트는 view처럼 자주 바뀌는 DTO에 대해 테스트를 생각해본다. . | DisplayName은 너무하다 싶을정도로 자세히 쓴다. . class NameTest { //@DisplayName(&quot;이름이 1자 미만, 5자 초과일 경우&quot;) //@DisplayName(&quot;자동차 이름이 1자 미만, 5자 초과하여 유효하지 않은 경우&quot;) @DisplayName(&quot;자동차 이름이 1자 미만, 5자 초과하여 유효하지 않은 경우 예외가 발생한다&quot;) . 이정도로 결과까지 명확하게 서술하면 더 좋습니다. | . | @ValueSource의 빈 문자열과 @EmptySource가 같은 값을 제공하지 않나요? . @EmptySource @ValueSource(strings = {&quot;&quot;, &quot;Wishoon&quot;, &quot;123456&quot;}) . | .",
            "url": "blog.chojaeseong.com/java/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/23/%ED%94%BC%EB%93%9C%EB%B0%B1_%EB%A0%88%EB%B2%A81_1%EB%8B%A8%EA%B3%84_%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_PR_%ED%94%BC%EB%93%9C%EB%B0%B1(%EC%99%84).html",
            "relUrl": "/java/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/23/%ED%94%BC%EB%93%9C%EB%B0%B1_%EB%A0%88%EB%B2%A81_1%EB%8B%A8%EA%B3%84_%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_PR_%ED%94%BC%EB%93%9C%EB%B0%B1(%EC%99%84).html",
            "date": " • Feb 23, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "강의) 네오 1단계 자경 피드백",
            "content": "final 키워드로 값의 변경을 막아라 . 값은 final로 재할당금지 -&gt; 재사용 금지 . . main 메소드 template 인 psvm의 인자에도 final을 붙혀준다. . . | 메서드 내부에서 코드 중간에서 가변 변수를 수정할 때, 위에 재할당 등의 수정이 되었었나 확인해야한다. final로 재할당(재사용)이 불가능한 불변 값사용하다가, 변수의 재사용이 필요할 경우 새 변수를 만들어서 쓰자. | . | 모든 지역변수, 인자에 final을 붙이자. . . | . final 객체의 내부 속성변화 메서드 -&gt; 변한 속성으로 만든 새 객체로 응답 . 객체의 경우는 final로는 완벽한 불변을 못만든다. . final 값와 달리 final 객체는 메소드 등에 의해 내부가 변할 수 있다.(포인터의 포인터에서 껍데기 포인터1) | . | 객체를 불변으로 만든 법상태변화를 일으키는 기능들은 새로운 객체를 반환하도록 정의하자. . 상태변화 시켰던 메서드의 void returnType에 해당 객체를 응답(return)하도록 수정 . public void move() { this.position++; } public Car move() { this.position++; } . | 변화된 상태로 new생성자()로 호출하여 -&gt; 새로운 객체를 반환시킨다. . public Car move() { return new Car(this.position + 1); } public Car(final int position) { this.position = position; } . | | . 객체, 컬렉션(껍데기포인터1)등은 응답시 copy해서 응답하라 . my) 포인터1의 포인터2에 의해 변경될 수 있으니, 껍데기 포인터1 자체를 copy해서 응답해라 . 컨밴션 중 하나가 된다. . final을 붙이는 것은 컨벤션이며 팀 안에서는 따르는게 좋을 수 도 있다. 내 생각에 타당하지 않으면 얘기를 꺼내서 바꿀 수 있다. | . | 컨벤션이라면, 비효율적이라도 그대로 가는 경우가 많다. 디자인 패턴 역시, 효율적이거나 좋은 코드라서 뿐만 아니라, 커뮤니케이션을 줄이는 컨밴션이기 때문에 좋기도 하다. | . | . 참고 글 . 후디 블로그 | . 객체를 객체스럽게 사용해라 . 아래와 같이 getter와 setter만 있는 객체를 구현하지 않는다. | setPosition()같은 setter 대신 move()의 역할로 분리해야한다. | getter()는 안쓰는게 좋은데, setter()는 100% 확정적으로 안쓰는게 좋다. setter() == 생성자 == pushed 로 외부에서 주입은 X | 특히 불변객체의 경우는 속성 변화 -&gt; 새 객체로 응답해야하니, setter란 개념이 없다. | . | view에서 사용하는 getter()는 필수적이다. view에서 getter()안쓰기 위해 toString() 쓰는 것은… 좀 아니다. | getter()쓰지마라라는 말은 도메인에서 getter() 쓰는 대신, 객체에 메세지를 던지면서 협력하라는 뜻이다. | 객체를 직접 사용하지말고, View에서는 dto로 값만 꺼내써라 | . | Q. view에서 cars.get(0).getPosition()은 가능한가요? . my) 디미터법칙 위반이다 -&gt; 책임을 2번째 놈에게 위임해야됌 . | index 0 은 무엇을 말하는지 모른다. . | 가져오려는 이유가 무엇인지 부터 물어보고 싶다. . 우승자를 구하려는 이유라면 메세지를 던지는 식으로 바꿔보자. cars.getWinners() | . | . | .get + .get이 이어지는 경우가 있는데 의심을 해봐야한다. . 점 1개로 줄이도록 해보자. . cars.getFirst().getPosition(); cars.getFirstPosition(); . | 첫번째 포지션 -&gt; 의미가 애매하다 -&gt; 위너로 바꾸자. . cars.getWinners(); . | . | . | . 객체.getXXX()대신 new XXX( 객체 )를 던지는 클래스로 만드는 방법도 . **getter()대신 객체를 생성자로 던져 class를 만들어볼까? ** . new Winner(cars); . | . 객체를 던졌어도, 객체.setter() 등의 주입 대신 역할위임을 하자. . public class Racing { ... public int run(Car car) { int num = random.nextInt(11); int position = car.getPosition(); if (num &gt;= 4) { position++; } car.setPosition(position); return position; } } . car.setPosition(position);대신에 car 내부로 역할이 위임되어서 내부에서 했으면 좋겠다. | . 인변의 접근제한자는 private으로 고정 -&gt; 객체상태에 대한 접근은 제한 . getter()도 지금 허용할까말깐데.. 인변에 접근은 절대 안시킨다. | . . 그렇다면 public, protected는 왜 있는 걸까? 과거에는 의도가 있어서 만들었는데, 요즘에는 필요없다고 느껴졌을 수 가 있음. | 과거에는 왜 여러 접근제한자를 만들었을까? | public으로 열여있으면, getter/setter 동시허용이나 마찬가지다. 어디서든 접근하면 -&gt; 불안해야 한다. | 이 역할만 하면 좋겠다. | 변수를 public으로 열어두면, 변했는지 안했는지 직접 보고 확인해야하는 비용이 든다. | 변수를 public으로 열어두지말고, method를 열어주어 캡슐화된 속성변화를 만들어내자. | . | . | . (내부)랜덤요소는 단위 테스트하기 힘들다. . 내부에 random은 테스트하기 힘들다. . . | . 밖에서 받아오는 메서드로 변경한다. . 테스트하기 힘든 내부 랜덤은 일단 밖에서 주어지는 파라미터로 변경 한다. . 파라미터 추출 단축키 ctrl+shit+P | . public void move() { if (getRandomNo() &gt;= 4) { this.position++; } } car.move(); . public void move(final int number) { if (number &gt;= 4) { this.position++; } } car.move(car.getRandomNo()); // 자동으로 메서드의 인자도 바뀐다. . | 문제점: 밖에서 받아오는 랜덤이 . 단일객체.move( 밖 ) | 일급컬렉션.move( 밖 ) cars.forEach( car -&gt; car.move( 밖 ) ) -&gt; .. | . | 일급컬렉을 사용하는 클래스에서도 ( 밖 ) | 어디 밖까지 빼서 받아올지가 끝이 없다 -&gt; 적절한 경계를 잡아준다. | . | 질문: . car.move ( 밖 )도 테스트 했는데, cars.move ( 밖 ) 도 테스트해야할까? 마음의 평화가 중요함. 자기가 생각해 봐야함. | . | 리뷰어에게는 설계가 담근 readme의 링크와 같이 보낸다. | . | 받아오는 인자를 전략메소드를 가진 인터페이스로 변경하여 -&gt; 랜덤외에 구상 전략객체들도 입력가능하게 만든다. . public interface MovableStrategy { boolean isMove(); } . 인변 수는 최소화한다. . 최대 2개 정도로… . | 기존 인변으로 만들어낼 수 있는 것은, 변수로 선언하지 않는다. . public class RacingGame { private List&lt;Car&gt; cars; private List&lt;String&gt; winners; . | my) 인변으로 둔다 -&gt; 바깥에서(or default값으로) 받아와 알고있고, 의존해야하는 것 . 그게 아니라면, 시간이 좀 걸리더라도, 기존 인변들도 만든다. | 관리포인트를 늘리면 좋은가? 그냥 그때그때 실시간으로 만드는게 좋은 것 같다. | 현대에는 메모리/컴퓨팅 비용성능 «&lt; 인력의 유지보수성 | DB를 이용하는 시점에서 변수 -&gt; 성능을 위한 캐싱을 하기도 한다. | . | . ### setter는 사용을 자제해라 -&gt; 생성자에서 초기화 후 더이상 변경안한다. . 인스턴스 변수는 생성자 초기화 후에 불변을 유지하기 위해 setter는 사용을 자제한다. | setter의 문제점은? 역할을 하지 못하게 된다. | 어디서든 변경되어 -&gt; 내 의도와 다르게 동작한다. | 유지보수성이 떨어진다. | . | . 비즈니스 로직과 UI 로직의 분리 . View관련 코드는 도메인에 넣지말라는 소리 . 90%는 도메인에 View관련 코드를 넣었었다. . public class Car { private int position; ... private void print(int position) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; position; i++) { sb.append(&quot;-&quot;); } System.out.println(sb.toString()); } } . | . | 리뷰를 받으면서 점점 분리한다. . | 왜 분리할까? 그냥 출력하도록 도메인에서 메서드 만들면 되는거 아닌가? . getter쓰지말라고 해서 -&gt; 객체.역할부여()로 출력역할 만들었더니 | 역할부여는 도메인 &amp;&amp; getter없이 하는게 맞지만, 변경이 자주 일어나는 view로직을 예외다. | . | View관련 로직 . 출력관련 역할부여(책임)를 도메인에서 안시킨다. 아예 정의하지말고 도메인은 객체만 넘겨라. . 출력 책임은 객체가 가지게 하지마라 | &lt;변경 빈번&gt; UI변경 -&gt; &lt;변경없어야할 소중한, 중요도가 높은&gt; 도메인에 여파를 일으키면 큰일이 나기 때문 | . | dto로 getter로 값만 꺼내쓰게 할 것이다 . | . | . Collection 활용 로직 처리 . Car 목록에서 최종 우승자를 구하는 로직이다. 이 코드를 Collection 기능을 사용해 어떻게 리팩터링할 것인가? . public class ResultView { private Cars cars = null; private String getTopRankedCar(List&lt;Car&gt; carList) { String topCarString = &quot;&quot;; cars = new Cars(carList); int maxPosition = getMaxPosition(carList); for (int i = 0; i &lt; carList.size(); i++) { if (cars.getPosition(i) == maxPosition) { topCarString += cars.getCarName(i) + &quot;, &quot;; } } return topCarString.substring(0, topCarString.length() - 2); } private int getMaxPosition(List&lt;Car&gt; carList) { int maxPosition = 0; cars = new Cars(carList); for (int i = 0; i &lt; carList.size(); i++) { if (maxPosition &lt; cars.getPosition(i)) { maxPosition = cars.getPosition(i); } } return maxPosition; } } . | . 기본 api를 이용해서 다짜지 말자 . Collection을 활용해 로직을 구현할 때 직접 구현하려 하지 말고 먼저 Collection API를 통해 해결할 수 있는 방법이 있는지 찾는다. 방법을 찾았는데 해결 방법을 찾지 못하는 경우만 직접 구현한다. . . 경계값을 테스트한다. . 다 하는게 아니라 경계값만 테스트 . 모든 테스트 X | . @Test public void 랜덤숫자가_4이상일때만_움직인다() { Car car = new Car(); assertFalse(car.shouldMove(0)); assertFalse(car.shouldMove(1)); assertFalse(car.shouldMove(2)); assertFalse(car.shouldMove(3)); assertTrue(car.shouldMove(4)); assertTrue(car.shouldMove(5)); assertTrue(car.shouldMove(6)); assertTrue(car.shouldMove(7)); assertTrue(car.shouldMove(8)); assertTrue(car.shouldMove(9)); } . | . 테스트 픽스처 생성 . 테스트를 반복적으로 수행할 수 있게 도와주고 매번 동일한 결과를 얻을 수 있게 도와주는 ‘기반이 되는 상태나 환경’을 의미한다. 여러 테스트에서 공용으로 사용할 수 있는 테스트 픽스처는 테스트의 인스턴스 변수 혹은 별도의 클래스에 모아 본다. . 중복제거를 위해 하면 된다. | junit의 @beforEach를 사용하면 된다. 테스트 픽스쳐의 일종이다. | . public class RacingGameTest { private final String[] testNames = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}; private final int testPosition = 5; private final String resultSamePositionString = &quot;, b&quot;; private final String resultWinnersString = &quot;a, b&quot;; RacingGame racingGame; private final Car firstWinner = new Car(testPosition, &quot;a&quot;); private Car secondWinner; private final List&lt;Car&gt; cars = new ArrayList&lt;Car&gt;(); ... } . | . 과정 실습 . 추후 미션이 진행 되면, 복잡해지고 객체가 많아질 경우, 코드를 분리해야됨. . @Test void move() { final Car car = new Car(&quot;재성&quot;); } . | 비슷한 환경의 테스트를 복사해서 case를 나눈다고 가정하자. . @Test void move_go() { final Car car = new Car(&quot;재성&quot;); } @Test void move_stop() { final Car car = new Car(&quot;재성&quot;); } . | 객체의 생성이 반복된다면, Generate &gt; Setup method를 선택해서 @BeforeEach를 생성하자. . @BeforeEach void setUp() { } @Test void move_go() { final Car car = new Car(&quot;재성&quot;); } @Test void move_stop() { final Car car = new Car(&quot;재성&quot;); } . | 공통되는 객체생성코드를 beforeEach로 뺀다 . @BeforeEach void setUp() { final Car car = new Car(&quot;재성&quot;); } @Test void move_go() { } @Test void move_stop() { } . | ctrl+.(show context action)을 눌러서 split declation and assignment를 통해 . 변수 선언은 변수재활용을 위해 클래스변수로 클래스변수에 넣고 매번 초기화한다 -&gt; 변수 재활용한다 -&gt; 변수 재할당한다 -&gt; final은 안된다. | . | 할당만 beforeEach에서 매 테스트마다 새로운 것으로 분리한다. | . @BeforeEach void setUp() { final Car car; car = new Car(&quot;재성&quot;); } . class ApplicationTest { //final Car car; // 매 테스트마다의 재활용 = 재할당 Car car; @BeforeEach void setUp() { car = new Car(&quot;재성&quot;); } . | 픽스쳐가 많아지면, 공통이 맞는지 확인한다. . | . 특정상태를 만들어주기 위한 반복코드 -&gt; 생성자로 상태 바로 만들기 . 과도하게 반복해서 만든다? . public class RacingGameResultTest { @Test public void check_ranking_if_correct() { List&lt;Car&gt; cars = new ArrayList&lt;&gt;(); Car car1 = new Car(&quot;pobi&quot;); Car car2 = new Car(&quot;crong&quot;); Car car3 = new Car(&quot;honux&quot;); car1.move(); car1.move(); car2.move(); car2.move(); car2.move(); car3.move(); cars.add(car1); cars.add(car2); cars.add(car3); ... } } . 단순반복의 경우, 반복문+메서드 호출로 해결할 수도 있지만, 그렇지 않은 경우가 많다. | 상태를 만들기 위해 복잡한 과정이 많은 경우, 상태를 바로 만들어주는 생성자를 만들 수 있다. 여기선, move()테스트가 아니라 우승자를 찾는게 목적이기 때문에, 목적 달성을 위해, 다른 것은 바로 상태를 만드는 생성자를 만들수 도 있음. | 현재는 move()호출방식에 따라 테스트가 의존하여, 변하면 테스트코드가 깨질 수 도 있다. | 테스트를 위해 생성자를 만들지만, 그게 진짜 테스트만을 위한 코드인지 생각해봐야한다. | . | . public Car(final String name, final int position) { this.name = name; this.position = position; } List&lt;Car&gt; cars = new ArrayList&lt;&gt;(); // Car car1 = new Car(&quot;pobi&quot;); // Car car2 = new Car(&quot;crong&quot;); // Car car3 = new Car(&quot;honux&quot;); Car car1 = new Car(&quot;pobi&quot;, 2); Car car2 = new Car(&quot;crong&quot;, 3); Car car3 = new Car(&quot;honux&quot;, 1); // car1.move(); // car1.move(); // car2.move(); // car2.move(); // car2.move(); // car3.move(); cars.add(car1); cars.add(car2); cars.add(car3); . 이 코드가 프로덕션 코드에서 사용되지 않더라도, 객체관점+객체역할에서 봤을 때, 테스트를 위한 기능이 아닐 수 있다. 객체 관점에서 자연스러우면 괜찮다. | position default값을 지정해주는 관점에서 괜찮다. | . | 테스트만을 위한 메서드추가는 문제가 더 큰데, 생성자는 객체를 만드는 방법일 뿐이므로 생성자는 많아도 괜찮다. 충분히 납득이 가능하다. | . | . | 생성자는 여러개 만들면, 인자 많은 것을 주생성자로 취급하고 인자 적은 생성자 -&gt; 위쪽에 위치하고 default값을 this에 넣어주는 부생성자 . // 부 생성자는 주 생성자(name, position)보다 더 앞에 위치하며, 뒤쪽의 주 생성자를 this( , )로 사용한다. public Car(final String name) { this(name, 0); } public Car(final String name, final int position) { this.name = name; this.position = position; } . | 생성자가 너무 많아지거나, 같은 시그니쳐 or 이름을 주고 싶을 때 -&gt; 정팩메로 분리 고려 . | . getter없이 구현 가능? . setter/getter 메서드를 사용하지 말라는 것은 핵심 비지니스 로직을 구현하는 도메인 객체를 의미한다. 도메인 Layer -&gt; View Layer, View Layer -&gt; 도메인 Layer로 데이터를 전달할 때 사용하는 DTO(data transfer object)의 경우 setter/getter를 허용한다. . | 아예 없이 toString으로 구현하는 분들도 있지만, 도메인 Layer에서 사용하는 getter를 만들지마라 == 비즈니스 로직를 위한 getter를 이용하지마라 . 도메인 대신 DTO 구현시 getter/setter는 허용한다. . | DTO라도 setter는 생성자에서 초기화하는 것으로 대신한다. | view에서는 열어야한다. | . | 접근제한자는 최소한으로 열고 시작한다. . | getter로 받아와서 하지말고, 역할을 부여해서 시키는 것 -&gt; 그래야 협력한다. . | . 객체안에서 toDTO를 만들지마라 . 내부에서 toDto()를 만든다? 모델에서 DTO를 알면 왜 안좋을까? | DTO는 뷰에 종속적인 객체 -&gt; view처럼 변경이 많다 -&gt; 도메인에 영향을 줌 | 객체 안에서 DTO를 생성하지마라 | 객체는 밥줄이라 아껴야하고, DTO는 막쓴다. | . | . 테스트를 위한 코드는 구현코드에 분리 . 테스트용 편의 메서드를 구현 코드에서 구현하지마라 | . 생성자로 주입하는 건 괜찮고, setter는 안좋냐? . 똑같은 내부 코드(행위)보다는 역할이나 시점을 봐야한다. | setter가 하나라도 존재하면 내부 상태변화 기능.move()을 따로 가지는 객체지만, 객체를 믿을 수 없게 된다. 기능으로 내부 변하는 것도 좀 그런데… 언제든지 변화시키는 믿을 수 없는 객체가 된다. | . | .",
            "url": "blog.chojaeseong.com/java/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/23/%EA%B0%95%EC%9D%98_%EB%A0%88%EB%B2%A81_1%EB%8B%A8%EA%B3%84_%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_%EB%84%A4%EC%98%A4_%EA%B0%95%EC%9D%98(%EC%99%84).html",
            "relUrl": "/java/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/23/%EA%B0%95%EC%9D%98_%EB%A0%88%EB%B2%A81_1%EB%8B%A8%EA%B3%84_%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_%EB%84%A4%EC%98%A4_%EA%B0%95%EC%9D%98(%EC%99%84).html",
            "date": " • Feb 23, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "Console 입력-검증-생성자 정리",
            "content": "콘솔 프로그램 입력/검증/생성자 . 자동차경주 1,2차 피드백(1단계 미션)후 콘솔입력 -&gt; 검증 -&gt; 개별 모델 생성자 구조를 생각해보았다. . | 아직 Dto - domain 의존은 해결되지 않은 상황 . 나중에 참고할 것: DTO를 의존 하는 domain 문제 PR | . | . InputView . 재활용 SCANNER . 스캐너를 사용하는 public static getInput() . private static final Scanner SCANNER = new Scanner(System.in); public static String getInput() { return SCANNER.nextLine(); } . | 4단계 InputView.getXXX() . 개별 모델input들을 의미하는 getXXX()는 4단계로 구성됨. . public static List&lt;String&gt; getCarNames() { OutputView.printRequestInstruction(REQUEST_CARS_NAME); List&lt;String&gt; carsName = Arrays.stream(getInput().split(SPLIT_DELIMITER, -1)) .map(String::trim) .collect(Collectors.toList()); Validator.validateCarNames(carsName); return carsName; } public static String getRound() { OutputView.printRequestInstruction(REQUEST_ROUND_VALUE); String inputRound = InputView.getInput(); Validator.validateInputNumber(inputRound); return inputRound; } . OuputView.print( 안내메세지 ) . | 스캐너를 사용해서 받은, 복수형이면 split(,-1) by Arrays.stream( ).map().collect() / 단수형이면 그냥 . List&lt;String&gt; or String | . | 복수형이면 실제이름XXXX를 붙이고 / 단수형이면 Input(String) or InputNumber(StringNumber)를 붙인 . Input루트의 공통검증: Validator.validate~ -&gt; 재료는 List&lt;String&gt; 아니면 String(Number)로 무조건 String타입을 검증대상으로 보게 정했다. . 복수형이면 check복수형(개별Empty, 중복) -&gt; for validateInput or validateInputNumber의 단수 공통검증 . private Validator() { // 유틸클래스는 따로 객체생성안한다는 private생성자로 표시 } public static void validateCarNames(List&lt;String&gt; carNames) { checkCarNamesEmpty(carNames); checkDuplicated(carNames); for (String carName : carNames) { validateInput(carName); } } . | 단수형이면 String이냐 StringNumber냐에 따라서 다르게 . String: NullOrEmpty + IncludeBlank | StringNumber: NullOrEmpty + Format(넣으면 IncludeBlank안넣어도 된다) | private static void validateInput(String carName) { checkNullOrEmpty(carName); checkIncludeBlank(carName); } public static void validateInputNumber(String inputRound) { checkNullOrEmpty(inputRound); checkValidFormat(inputRound); } . | | | return List&lt;String&gt; or String(2번) . | | Controller . try/catch . 입력받을 때, 입력 예외발생시 다시 입력받기 받으려면 **getXXXX()가 ** . 검증을 포함하는 부분시켜서 | 재귀호출하는 하도록 메서드화되어 있고 그부분을 try/catch로 쌓여있여있어야하는데, | . | getXXX() + 받아서 모델의 (정펙매)생성자 호출하는 과정까지 try/catch로 감싸면, 도메인 자체검증도 try/catch의 재귀에 걸려 도메인 자체검증 예외발생시에도 재입력받을 수 있게 된다. . 객체 생성로직( 자체 검증 -&gt; 객체 생성)까지 포함시켰으니, 해당 메서드는 try성공시 객체를 returnType으로 | . private Cars getCars() { try { return Cars.fromInput(InputView.getCarNames()); } catch (IllegalArgumentException e) { OutputView.printErrorMessage(e); return getCars(); } } private Round getRound() { try { return Round.fromInput(Integer.parseInt(InputView.getRound())); } catch (IllegalArgumentException e) { OutputView.printErrorMessage(e); return getRound(); } } . RacingGame racingGame = RacingGame.createRacingGame( getCars(), getRound(), new RandomNumberGeneratePolicy() ); . | . Controller getXXX(): InputView.getXXX() 응답 String -&gt; convert+생성자객체생성+try/catch . 대신, 중간에 필요한 객체의 생성자까진 노출할 필요는 없다. . public class RacingGameController { public void startRacing() { RacingGame racingGame = RacingGame.createRacingGame( getCars(), // InputView의 getXXX()는 무조건 String -&gt; 중간 객체(Name)도 다 노출... private Cars getCars() { try { return Cars.fromNames(Names.fromInput(InputView.getCarNames())); . 지금은 Cars를 만들기 위해 Names의 존재를 알아야 하는 상황인데요, 사실 Names는 Cars 안에서만 사용되고 있죠. 그렇다면 Names의 존재가 바깥에 노출될 필요가 있을까요? 구현을 드러내고 있는 건 아닐까요? 원시값 포장한 것은 굳이 생성자를 안드러내도 된다. | . | . private Cars getCars() { try { return Cars.fromInput(InputView.getCarNames()); public static Cars fromInput(List&lt;String&gt; InputNames) { Names names = Names.fromInput(InputNames); return new Cars(names.getNames( . | . 생성자 . 01 private 기본생성자 . 복수( List&lt;단일&gt;) ex&gt; Cars . private Cars(List&lt;Car&gt; cars) { this.cars = cars; } . 단일객체 (포장객체들, Name+Position ) ex&gt; Car . private Car(Name name) { this.name = name; this.position = Position.from(DEFAULT_POSITION_VALUE); } . 일급컬렉션 (List&lt;원시&gt;) ex&gt; Names . private Names(List&lt;Name&gt; names) { this.names = names; } . StringNumber (int ) ex&gt; Round . private Round(int roundNum) { this.roundNum = roundNum; } . String (String ) ex&gt; Name . private Name(String name) { this.name = name; } . 복수Dto (List&lt;CarDto&gt;) ex&gt; CarsDto . private CarsDto(final List&lt;CarDto&gt; carsDto) { this.carsDto = carsDto; } . 단일Dto (원시값들) ex&gt; CarDto . public CarDto(String name, int position) { this.name = name; this.position = position; } . 02 .fromInput ( only String or List&lt;String&gt; ) . inputView에서 기본검증을 거치고 난 뒤, 자체 검증만 필요한 친구들 만약, stream.map 단일객체생성자 등장시 -&gt; 단일객체로 검증이 옮겨짐 | . | . 복수( List&lt;단일&gt;) ex&gt; Cars . public static Cars fromInput(List&lt;String&gt; InputNames) { Names names = Names.fromInput(InputNames); return new Cars(names.getNames().stream() .map(Car::fromName) .collect(Collectors.toList())); } . 단일객체 (포장객체들, Name+Position ) ex&gt; Car . // . 일급컬렉션 (List&lt;원시&gt;) ex&gt; Names . 자체검증하는 대신, stream상에서 단일객체에서 검증이 옮겨짐. | . public static Names fromInput(List&lt;String&gt; names) { return new Names(names.stream() .map(Name::from) .collect(Collectors.toList())); } . StringNumber (int ) ex&gt; Round . public static Round fromInput(int inputRound) { validateRound(inputRound); return new Round(inputRound); } . String (String ) ex&gt; Name . // . 복수Dto (List&lt;CarDto&gt;) ex&gt; CarsDto . // . 단일Dto (원시값들) ex&gt; CarDto . // . 03 .from( 원본재료 ) . 복수 . input없이 프로덕션내부 or 테스트에서 사용된다. -&gt; 유틸화된 공통검증 + 자체 검증 만일, 원본재료가 포장된 객체라면, 자체검증은 포장객에게 갈 수 있다. | . | . public static Cars from(List&lt;Car&gt; cars) { return new Cars(cars); } . VO 는 .from(원본 1개만) . 정팩메 1개 -&gt; input이지만 .from + 유일 자체 검증 생성자 | . public static Position from(int position) { validatePosition(position); return new Position(position); } . 복수( List&lt;단일&gt;) ex&gt; Cars . test코드에서 Car -&gt; Cars로 바로 생성하기 위해 | . public static Cars from(List&lt;Car&gt; cars) { return new Cars(cars); } . 단일객체 (포장객체들, Name+Position ) ex&gt; Car . 일급컬렉션, 복수 쪽에서는 stream을 통해 원본 List -&gt; 단일객체 List -&gt; 일급으로순으로 가기도 한다. | . public static Car fromName(Name name) { return new Car(name); } . 일급컬렉션 (List&lt;원시&gt;) ex&gt; Names . test코드용 | . public static Names from(List&lt;Name&gt; names) { validateNames(names); return new Names(names); } . StringNumber (int ) ex&gt; Round . test를 안하고, controller에서 마지막에 convert시킬거라을 input원본 받을일이 없음. | . // . String (String ) ex&gt; Name . 복수, 일급컬렉션의 Names에서 stream으로 만들어지는 과정 | 테스트용 | . public static Name from(String name) { checkValidLengthOfName(name); return new Name(name); } . 복수Dto (List&lt;CarDto&gt;) ex&gt; CarsDto . 일급컬렉션 내부에서 toDto()호출시 ** List&lt;단일&gt; **유일 필드-&gt; List&lt;단일Dto&gt; 변환후 기본생성자로 복수Dto로 만들어줌 -&gt; from일급컬렉 | 공통적인 기본 private List&lt;단일Dto&gt;를 호출해줄 public -&gt; .from | public static CarsDto fromCars(final List&lt;Car&gt; cars) { //todo: 5. cars -&gt; carsdto의 정펙메( List&lt;Car&gt; ) -&gt; List&lt;CarDto&gt; -&gt; 일급 생성자 // carsDto의 생성자는 car list(cars)를 받아서 -&gt; cardto list -&gt; 일급 dto를 만드는 곳 final List&lt;CarDto&gt; carDtos = cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList()); return new CarsDto(carDtos); } public static CarsDto from(final List&lt;CarDto&gt; carsDto) { return new CarsDto(carsDto); } . 단일Dto (원시값들) ex&gt; CarDto . 복수or일급컬렉션에서 stream에서 Car -&gt; CarDto시 사용될 .from원본( 1:1원본) | OuputView 테스트에서 원시값 필드들로 생성하는단일Dto -&gt; 복수Dto | public CarDto(String name, int position) { this.name = name; this.position = position; } .",
            "url": "blog.chojaeseong.com/java/console/input/validation/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/22/%EC%BD%98%EC%86%94%EC%9E%85%EB%A0%A5_%EA%B2%80%EC%A6%9D_%EC%83%9D%EC%84%B1%EC%9E%90(%EC%99%84).html",
            "relUrl": "/java/console/input/validation/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/22/%EC%BD%98%EC%86%94%EC%9E%85%EB%A0%A5_%EA%B2%80%EC%A6%9D_%EC%83%9D%EC%84%B1%EC%9E%90(%EC%99%84).html",
            "date": " • Feb 22, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "DTO 단계별 적용(자동차경주)",
            "content": "단일DTO . 참고 DTO 쓴 PR | . 01 Controller의 OutputView.print( )에 List&lt;단일Dto&gt; 반환해주기 . OutputView.printResultEveryRound(racingGame.getCurrentCars()); . 관리자객체에서도 List&lt; 단일객체 &gt;나오는 일급에 들어가지 않았으므로 그대로 여기서 return될 타입이 List&lt; 단일Dto &gt;를 예상하자 | . public List&lt;CarDto&gt; getCurrentCars() { return this.cars.getCurrentCars(); } . 02 일급 속 List&lt;단일객체&gt;를 stream.map으로 List&lt;단일Dto&gt;로 변환 . public List&lt;CarDto&gt; getCurrentCars() { return this.cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList()); } . 03 Dto 변환 정펙메는 from(단일객체) -&gt; 모든 속성들 원시값까지 나눠서 get . 이 때, Car는 VO Name, Position이라도, Dto의 속성 및 getter()는 순수 원시값만 가지고 뱉어낸다. 예를 들어, car.getName()은 Name(VO) return이 아니라 this.name.getName()의 원시값을 return해야 CarDto가 생성자에서 개별속성들을 원시값으로 받아먹을 수 있다. | . | . public class CarDto { private final String name; private final int position; public CarDto(String name, int positiion) { this.name = name; this.position = positiion; } public static CarDto from(Car car) { return new CarDto(car.getName(), car.getPosition()); } public String getName() { return this.name; } public int getPosition() { return this.position; } } . 04 OutputView는 List&lt;단일Dto&gt;를 받아서 getter들로 출력 로직 작성 . public static void printResultEveryRound(List&lt;CarDto&gt; currentCars) { for (CarDto currentCar : currentCars) { System.out.println(currentCar.getName() + &quot; : &quot; + collectDash(currentCar.getPosition())); } System.out.println(); } . 일급Dto . 01 일급.toDto()를 통한 List&lt;단일Dto&gt;자리를 일급Dto로 교체 . 단일Dto는 List -&gt; steram -&gt; map 가운데만 등장했으나 | 일급Dto는 this.일급.toDto()의 책임이 주어진다. | . public CarsDto getCurrentCars() { //return this.cars.getCurrentCars(); return this.cars.toDto(); . 02 일급Dto 정펙매 공식 재료는 일급 내부에 있는 List&lt;단일객체&gt; (No List&lt;단일Dto&gt;) . 단일Dto는 Car가 모르고, 내부에서 이용안한다. Cars내부에서 List&lt;CarDto&gt; 만들 때 map에서 사용된다. | 일급Dto는 Cars가 알고 이용하여, 내부에서 변환환다. | 일급내부의 단일객체 List만 건네주면, 내부에서 단일Dto -&gt; 일급Dto 한번에 변환후 생성 다해준다. List&lt;단일Car&gt; —정팩메List&lt;단일Dto&gt;—&gt; CarsDto | . | . // todo: 4. Cars의 toDto()함수는 &lt;&lt;Cars내부지만 CarsDto를 알고, 의존하여&gt;&gt; [CarsDto의 정팩메]를 호출 Cars -&gt; CarsDto로 변환한다. // my) Cars는 CarsDto와 그 정팩메를 알고 있다! public CarsDto toDto() { return CarsDto.fromCars(cars); // from List&lt;단일객체CarDto&gt; vs from다른것 Cars } . 일급Dto 정펙매의 재료가 List&lt;단일Dto&gt;가 아니라 List&lt;단일객체&gt;만 있으면, 내부에서 단일Dto List -&gt; 일급Dto까지 간다. | . public static CarsDto fromCars(final List&lt;Car&gt; cars) { // 필요재료가 List&lt;단일Dto&gt;가 아니라 List&lt;단일객체&gt;만 있으면, 내부에서 단일Dto List -&gt; 일급Dto까지 간다. final List&lt;CarDto&gt; carDtos = cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList()); return new CarsDto(carDtos); } . 03 일급Dto의 getter 네이밍은 get()으로 줄여주자. . 안줄이면. XXXsDto.getXXXsDto() -&gt; get으로 네이밍 줄여주기 | 단일Dto는 개별속성 getter()가 목적이라 Dto.get속성() | . public List&lt;CarDto&gt; get() { return carsDto; } . 04 OutputView내부 List&lt;단일Dto&gt; 사용 -&gt; 일급Dto.get() . //public static void printRacingRecord(List&lt;CarDto&gt; cars) { // for (CarDto car : cars) { public static void printRacingRecord(CarsDto carsDto) { for (CarDto car : carsDto.get()) { . DTO테스트 . 01 Dto를 사용하는 OutputView의 Test로 테스트한다. . ByteArrayOutputStream 변수 + setOut에 설정하기 차후 print명령을 내놓고 -&gt; output.toString()에서 확인하기 | . | . private final ByteArrayOutputStream output = new ByteArrayOutputStream(); @BeforeEach public void setUp_streams() { System.setOut(new PrintStream(output)); } . 02 [원시속성들]로 단일Dto 만드는 깡통 [정펙매of ] 정의 . 메서드로만 변환되는 deafult값의 position필드도 다 받도록 한다. (Dto는 깡통) | 1개 이상의 속성들을 받아야하므로 .of()의 정펙매로 개발한다. | . public static CarDto of(final String name, final int position) { return new CarDto(name, position); } . 03 프로덕션에 없던, 일급Dto의 정펙매from ( List&lt;단일Dto&gt;) 정의 . 프로덕션에서는 일급내부 List&lt;단일&gt; —일급Dto정펙매–&gt; (List&lt;단일Dto변환 -&gt;) 일급Dto 테스트에선 단일Dto 출발 -&gt; List&lt;단일Dto&gt;를 받아 일급Dto 생성해줄 정펙매 필요함. | . | . public static CarsDto from(final List&lt;CarDto&gt; carsDto) { return new CarsDto(carsDto); } . 04 output.toString()은 변수로 못받는다. 바로 확인 . //given final CarsDto carsDto = CarsDto.from(Arrays.asList(CarDto.of(&quot;재성&quot;, 1), CarDto.of(&quot;재경&quot;, 1))); //when: output.toString을 이후 actual변수에 따로 못받음. OutputView.printRacingRecord(carsDto); //then assertThat(output.toString()).contains(&quot;재성 : -&quot; + System.lineSeparator() + &quot;재경 : -&quot;); . final CarsDto carsDto = CarsDto.from(Arrays.asList(CarDto.of(&quot;재성&quot;, 1), CarDto.of(&quot;재2&quot;, 1))); // 우승자가 2명인 상황이라 가정해야됨. &gt; Winner들만 모인 CarsDto를 넘겨받는다. OutputView.printRacingResult(carsDto); assertThat(outputStream.toString()).contains(&quot;재성, 재2가 최종 우승했습니다&quot;); .",
            "url": "blog.chojaeseong.com/java/dto/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/22/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_DTO_%EB%8B%A8%EA%B3%84%EB%B3%84-%EC%A0%81%EC%9A%A9(%EC%99%84).html",
            "relUrl": "/java/dto/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/22/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_DTO_%EB%8B%A8%EA%B3%84%EB%B3%84-%EC%A0%81%EC%9A%A9(%EC%99%84).html",
            "date": " • Feb 22, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "동일성vs동등성(equals, hashCode)",
            "content": "동일(ㅣ)성 = (I)dentity = 메모ㄹ(ㅣ)주소 . 반대로 동등성 = equality = 정해준 값이 같은지 . | equals는 equality가 아닌메모리 주소(identity) 비교가 default라서 오버라이딩 해야한다. . == = 메모리 주소로 비교 = default equals . public boolean equals(Object obj) { return (this == obj); } . | = = 값으로 비교 = 오버라이딩 equals . | . | . 세팅 . public class Car { private final String name; private int position; // 부 생성자는 주 생성자(name, position)보다 더 앞에 위치하며, 뒤쪽의 주 생성자를 this( , )로 사용한다. public Car(final String name) { this(name, 0); } public Car(final String name, final int position) { this.name = name; this.position = position; } } . 오버라이딩 전 default equals -&gt; 메모리비교 . @Test void before_overriding_equals_test() { //1. 오버라이딩 전 deafult equals : 같은 메모리 주소만 true final Car 재성 = new Car(&quot;차&quot;); final Car 석영 = new Car(&quot;차&quot;); assertThat(재성).isEqualTo(석영); //Expected :domain.Car@29647f75 //Actual :domain.Car@355ce81c // -&gt; 서로 다른 객체(메모리주소)를 가져서 deafult equals로는 같다고 할 수 없음. } . 오버라이딩후 equals -&gt; 지정한 값으로 비교 . final Car 재성 = new Car(&quot;차&quot;); final Car 석영 = new Car(&quot;차&quot;); assertThat(재성).isEqualTo(석영); // true . hashCode도 같이 오버라이딩 하는 이유? . hashCode메서드는 실제 메모리 주소 -&gt; 정수값으로 반환해주는 함수이다. 자료구조 등에 사용될 때, 이 hashCode기준으로 같냐/틀리냐를 판단한다. | . | 값 같으면 -&gt; 같은 객체를 만족시켜주기 위해서는 같다의 기준을 바꿔줬었다. 같다의 기준을 메모리 주소 비교 -&gt; 값 비교로 equals 오버라이딩으로 바꿔줘야했지만, | . | 이번엔 자료구조 등이 받아서 읽을해쉬코드 기준을 객체의 메모리주소정수 반환이 아닌 -&gt; 객체(Car)가 가진 값(name)의 메모리 주소 정수 반환로 바꿔준다. cf) 값의 메모리주소 -&gt; 같은 문자열이면 다 같다 | . | . 자료구조들도 같은 객체로 인식 . 쉽게 말해서, 반환되는 hashCode도 값 기준으로 바꿔서, 값 같다 -&gt; 객체의 해쉬코드 같다를 만들어버린다. . 그렇지 않으면, equals는 True로 나올지 몰라도, 자료구조는 다른 객체로 인식하는 상태가 된다. | . @Test void before_overriding_hashcode_test() { final Car 재성 = new Car(&quot;차&quot;); final Car 석영 = new Car(&quot;차&quot;); final HashSet&lt;Car&gt; set = new HashSet&lt;&gt;(); set.add(재성); set.add(석영); assertThat(set.size()).isEqualTo(1); //Expected :1 //Actual :2 // hashCode를 객체기준-&gt;값기준으로 정의해주지 않으면, 자료구조들은 다른 객체로 인식한다. } . hashCode오버라이딩 후 | . @Test void after_overriding_hashcode_test() { //2. final Car 재성 = new Car(&quot;차&quot;); final Car 석영 = new Car(&quot;차&quot;); final HashSet&lt;Car&gt; set = new HashSet&lt;&gt;(); set.add(재성); set.add(석영); assertThat(set.size()).isEqualTo(1); // true } .",
            "url": "blog.chojaeseong.com/java/equals/hashcode/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/%EB%8F%99%EC%9D%BC%EC%84%B1%EA%B3%BC-%EB%8F%99%EB%93%B1%EC%84%B1(%EC%99%84).html",
            "relUrl": "/java/equals/hashcode/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/%EB%8F%99%EC%9D%BC%EC%84%B1%EA%B3%BC-%EB%8F%99%EB%93%B1%EC%84%B1(%EC%99%84).html",
            "date": " • Feb 21, 2022"
        }
        
    
  
    
        ,"post8": {
            "title": "java final 세팅과 사용법",
            "content": "final 키워드로 값의 변경을 막아라 . final 세팅 in IDE, 지역 변수, 메소드 파라미터 . 지역변수, 파라미터 모두 final로 생성되도록 하자 설정 &gt; Editor &gt; Code style &gt; java &gt; Code generation &gt; Make ~ final 체크박스 2개 | . | main 메소드 template 인 psvm의 인자에도 final을 붙혀준다. . 설정 &gt; live template or psvm 검색 &gt; final 붙여주기 | . . | . final 값 -&gt; 재할당을 막아 불변 . 메서드 내부에서 코드 중간에서 가변 변수를 수정할 때, 위에 재할당 등의 수정이 되었었나 확인해야한다. final로 재할당(재사용)이 불가능한 불변 값사용하다가, 변수의 재사용이 필요할 경우 새 변수를 만들어서 쓰자. | . | 모든 지역변수, 인자에 final을 붙이자. . . | final로 값을 초기화(선언후 할당)하는 방법은 2가지다 . //1. final변수 선언과 동시에 &amp;&amp; 할당 -&gt; final은 재할당 불가 -&gt; 변수재사용시 새객체 반환할 것 final int i = 2; i = 4; // java: cannot assign a value to final variable i //2. final변수 먼저 선언 -&gt; 이후 할당 // 생성자 등에서 값을 외부에서 받아와 추가 로직(convert or default 대입 등 특수 case(if) 존재)이후 초기화 final int number; number = 5; . | . final 객체 -&gt; 메서드로 내부 변화 가능 -&gt; 메서드를 항상 새 객체로 응답 . 객체의 경우는 final로는 완벽한 불변을 못만든다. . final 값와 달리 final 객체는 메소드 등에 의해 내부가 변할 수 있다.(포인터의 포인터에서 껍데기 포인터1) | . | 객체를 불변으로 만든 법상태변화를 일으키는 기능들은 새로운 객체를 반환하도록 정의하자. . 상태변화 시켰던 메서드의 void returnType에 해당 객체를 응답(return)하도록 수정 . // 내부변화되는 final 객체 public void move() { this.position++; } // 1. 일단 응답을 동일 객체로 만들어주기 public Car move() { this.position++; } . | 변화된 상태로 new생성자()로 호출하여 -&gt; 새로운 객체를 반환시킨다. . //2. 응답 객체를, 변화된 값으로 새로 만들어서 응답 -&gt; 내부 값은 변화 없다. public Car move() { return new Car(this.position + 1); } //3. 생성자를 통해 응답할 객체를 만들어준다. 내부 값의 변화는 없게 한다. public Car(final int position) { this.position = position; } . | | . final 메서드, 클래스 -&gt; 자식이 못 쓰게 . package domain; final public class FinalParent { final void finalMethod() { final String asdfasdf = &quot;asdfasdf&quot;; } } . package domain; //2. final 클래스는 자식이 상속이 안된다. // java: cannot inherit from final domain.FinalParent public class FinalChild extends FinalParent { //1. final 메소드는 자식이 오버라이딩 못된다. -&gt; 코어 부분에서 변경을 원치 않는 메소드를 명시할 때 사용 //java: cannot find symbol, symbol: class FinalParent @Override protected void finalize() throws Throwable { super.finalize(); } } . final 컬렉션(내부 변경api를 제공하는 껍데기포인터1) 등은 응답시 copy(unmodifiable) 해서 응답하라 . my) 포인터1의 포인터2에 의해 변경될 수 있으니, 껍데기 포인터1 자체를 copy해서 응답해라 | 컬렉션을 반환할 때, 메모리주소가 공유되니, 어디서든 같은 컬렉션이 변경되는 위험이 있다. copy해서 전혀 다른 메모리의 컬렉션으로 응답하자. | . | . List&lt;String&gt; names = List.of(); // unmodifiableList names.add(&quot;텍스트&quot;) // 예외발생 . - 내가 만든 일급컬렉션이라면 불변(내부 변화 기능 제공 않함)이 되겠지만, **일반 컬렉션이라면, 반환시 메모리주소가 공유된다. -&gt; `unmodifiableList`로 copy된 메모리를 반환시켜 테스트 등 변화가 발생하게 하자.** . 컨밴션 중 하나가 된다. . final을 붙이는 것은 컨벤션이며 팀 안에서는 따르는게 좋을 수 도 있다. 내 생각에 타당하지 않으면 얘기를 꺼내서 바꿀 수 있다. | . | 컨벤션이라면, 비효율적이라도 그대로 가는 경우가 많다. 디자인 패턴 역시, 효율적이거나 좋은 코드라서 뿐만 아니라 커뮤니케이션을 줄이는 컨밴션이기 때문에 좋기도 하다. | . | . 참고 글 . 후디 블로그 | .",
            "url": "blog.chojaeseong.com/java/final/%EB%8B%A8%EC%B6%95%ED%82%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/final_%EC%84%B8%ED%8C%85%EA%B3%BC_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/java/final/%EB%8B%A8%EC%B6%95%ED%82%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/final_%EC%84%B8%ED%8C%85%EA%B3%BC_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Feb 21, 2022"
        }
        
    
  
    
        ,"post9": {
            "title": "comparable vs comparator",
            "content": "참고 블로그1 | 참고 블로그2 | . 세팅 . public class Car { private final String name; private int position; public Car(final String name, final int position) { this.name = name; this.position = position; } public String getName() { return name; } public int getPosition() { return position; } } . 기준없이 정렬 . 기준없이 문자열 리스트 정렬 . 문자열은 값이므로 알아서 기준 없이 알아서 정렬된다. . @DisplayName(&quot;정렬기준 없이 문자열 리스트 정렬&quot;) @Test void noStandard_stringList_sort() { final List&lt;String&gt; strings = Arrays.asList(&quot;acd&quot;, &quot;abc&quot;, &quot;dca&quot;); // Collections.sort() 와 .reverse() Collections.sort(strings); System.out.println(strings); // [abc, acd, dca] Collections.reverse(strings); System.out.println(strings); // [dca, acd, abc] } . | String은 이미 내부에서 Comparable을 구현 -&gt; compareTo 오버라이딩 하여 정렬기준을 제시하고 있기 때문 . public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { //... public int compareTo(String anotherString) { byte v1[] = value; byte v2[] = anotherString.value; if (coder() == anotherString.coder()) { return isLatin1() ? StringLatin1.compareTo(v1, v2) : StringUTF16.compareTo(v1, v2); } return isLatin1() ? StringLatin1.compareToUTF16(v1, v2) : StringUTF16.compareToLatin1(v1, v2); } . | . 기준없이 객체 리스트 정렬 . 객체를 넣은 List는 아예 정렬 대상이 안되고 컴파일 에러가 난다. . | 반드시 먼저 정렬기준을 정해줘야한다. . @DisplayName(&quot;정렬기준 없이 객체 리스트 정렬&quot;) @Test void noStandard_carList_sort() { final List&lt;Car&gt; cars = Arrays.asList( new Car(&quot;재성&quot;, 1), new Car(&quot;재경&quot;, 2), new Car(&quot;아라&quot;, 3) ); //2. // no suitable method found for sort(java.util.List&lt;domain.Car&gt;) // method java.util.Collections.&lt;T&gt;sort(java.util.List&lt;T&gt;,java.util.Comparator&lt;? super T&gt;) is not applicable Collections.sort(cars); System.out.println(cars); Collections.reverse(cars); System.out.println(cars); } } . | . 객체에 정렬 기준 주기 . 01 sort()에 안넣어줘도 되는 수동 기준 Comparable . 수동적인 내부 기준인 만큼, 까봐야알고, 수정할려면 다 도메인 내부를 다 바꿔야한다. | . 자기자신 Type의 Comparable을 구현한다. . public class Car implements Comparable&lt;Car&gt; { . | 비교할 원시값Type에 맞게 compareTo를 재정의한다. . int면 Integer.compare( this.xxxx , other.xxxx ) | string이면, 내부 자기가 구현한 this.compareTo(other)를 사용 | . @Override public int compareTo(final Car otherCar) { return this.name.compareTo(otherCar.name); } . | .sort()만 해서 오름/내림차순 확인해보기 . @DisplayName(&quot;comparable -&gt; name 기준으로 객체 리스트 정렬&quot;) @Test void noStandard_carList_sort() { final List&lt;Car&gt; cars = Arrays.asList( new Car(&quot;재성&quot;, 1), new Car(&quot;재경&quot;, 2), new Car(&quot;아라&quot;, 3) ); //3. Collections.sort(cars); System.out.println(cars); // [아라 3, 재경 2, 재성 1] Collections.reverse(cars); System.out.println(cars); // [아라 3, 재경 2, 재성 1] } . | compareTo . 참고 블로그 | . 숫자형 비교 . 기준 값과 비교대상이 동일한 값일 경우 0 . | 기준 값이 비교대상 보다 작은 경우 -1 . | 기준 값이 비교대상 보다 큰 경우 1 . Integer x = 3; Integer y = 4; Double z = 1.0; System.out.println( x.compareTo(y) ); // -1 System.out.println( x.compareTo(3) ); // 0 System.out.println( x.compareTo(2) ); // 1 System.out.println( z.compareTo(2.7) ); // -1 . | . | 숫자형 중 Int의 비교 . compareTo() 대신 Integer.compare(, ) 사용 . int x = 4; int y = 5; Integer.compare(x,y); . | . | 문자열 -&gt; String클래스가 이미 오버라이딩 해놓은 compareTo()이용 . (첫글자 같으면서) 비교대상이 기준에 포함되면 -&gt; 길이의 차이를 return한다. . | (첫글자가 다르면서) 비교대상이 기준에 포함되면 -&gt; 서로 다른 문자열이 시작되는 위치(첫위치)에서 아스키코드 값 차이 . | 포함이 안되는 문자열끼리 비교는 그냥 첫글자의 아스키코드 차이 . String str = &quot;abcd&quot;; // 1) 비교대상에 문자열이 포함되어있을 경우 System.out.println( str.compareTo(&quot;abcd&quot;) ); // 0 (같은 경우는 숫자나 문자나 0을 리턴) System.out.println( str.compareTo(&quot;ab&quot;) ); // 2 System.out.println( str.compareTo(&quot;a&quot;) ); // 3 System.out.println( str.compareTo(&quot;c&quot;) ); // -2 System.out.println( &quot;&quot;.compareTo(str) ); // -4 // 2) 비교대상과 전혀 다른 문자열인 경우 System.out.println( str.compareTo(&quot;zefd&quot;) ); // -25 System.out.println( str.compareTo(&quot;zEFd&quot;) ); // -25 System.out.println( str.compareTo(&quot;ABCD&quot;) ); // 32 . | . | in stream: .집계( ::compareTo) 기준으로 바로 사용 가능 . .집계( 기준이 되어줄 메서드 )로 집계기준으로 바로 사용할 수 있다. | . list.stream() .max(Car::compareTo) .collect(Collectors ... ); . 단점: 정렬기준 변화시 모두 수정 + 까봐야 앎 + 네이밍 . 다른 개발자들이 implements Comparable&lt;Car&gt; 만 보고도어떤 기준으로 정렬될지 모른다. -&gt; 지식으로서 compareTo를 다 까봐야한다. | 그리고 이 기준이 바뀌지 않을 거라 장담할 수 없다. 구현부 compareTo를 하나하나 수정해줘야한다. | 네이밍 수정을 못함. compareTo보다 더 직관적인 네이밍 필요 | . 02 .sort( , ) 2번째 인자에 넣어주는 능동적 기준 Comparator . list.sort()의 첫번째 인자 혹은 Arrays.sort(, )나 Collections.sort(, )의 두번째 파라미터로 comparator를 받는 메소드가 오버로딩 되어있다. 따라서 수동적 기준인 natural ordering 으로 정렬하기 원할 경우, compareTo만 정의해서 기준으로 넣어주면 되고 | 정렬 기준을 동적으로 할당하고 싶을 경우, .sort( , )1~2번째 파라미터로 Comparator를 정의해서 전달하자. | . | . comparator 직접 구현 for 네이밍 . new Comparator롤 작성한 뒤-&gt; &lt;Car&gt;의 클래스만 입력해주고 -&gt; implements메소드 -&gt; compare만 선택한다. . new Comparator&lt;Car&gt;() . | **getter()도.. 들어가서.. 불러와서.. 비교시킨다. ** . 문자열이면, compareTo() String클래스꺼 | 인트면, Integer.compare() | . java new Comparator() { @Override public int compare(final Car o1, final Car o2) { return o1.getName().compareTo(o2.getName()); } }; . | 변수로 받아서 정렬기준 객체의 네이밍을 완성한다. . final Comparator&lt;Car&gt; carNameComparator = new Comparator&lt;&gt;() { @Override public int compare(final Car o1, final Car o2) { return o1.getName().compareTo(o2.getName()); } }; final Comparator&lt;Car&gt; carPositionComparator = new Comparator&lt;&gt;() { @Override public int compare(final Car o1, final Car o2) { return Integer.compare(o1.getPosition(), o2.getPosition()); } }; . | .sort( , )의 2번째 인자에 능동적으로 기준을 넣어준다. . Collections.sort(cars, carNameComparator); System.out.println(cars); // [아라 3, 재경 2, 재성 1] Collections.sort(cars, carPositionComparator); System.out.println(cars); // [재성 1, 재경 2, 아라 3] . | Comparator.api + getter() for 가장편함. . 따로 impl하거나 new 구현할 필요 없이, sort()의 2번째 인자에 바로 넣어준다. | Comparator.comparing() .reversed()를 붙혀 역순 지정가능 | . Collections.sort(cars, Comparator.comparing(Car::getName)); System.out.println(cars); // [아라 3, 재경 2, 재성 1] Collections.sort(cars, Comparator.comparing(Car::getName) .reversed()); System.out.println(cars); // [재성 1, 재경 2, 아라 3] Collections.sort(cars, Comparator.comparing(Car::getPosition)); System.out.println(cars); // [재성 1, 재경 2, 아라 3] Collections.sort(cars, Comparator.comparing(Car::getPosition) .reversed()); System.out.println(cars); // [아라 3, 재경 2, 재성 1] . Comparator.api + getter() in stream . max ( Comparator.comparingInt ( 클래스::getter )) . 정리 . Comparable 보다는 Comparator를 사용하여 정렬 기준만큼은 도메인에서 제외시켜 외부에 위치시켜 변경에 유연하게 만든다. | 외부에서는 comparable -&gt; compareTo -&gt; .sort() 수동적 내부 기준으로 정렬시 밖에서 보면 무엇을 기준으로 정렬되는지 모른다. . | Comparator 는 도메인 클래스에 변경을 가하지 않고도 변경에 유연해진다. | 정렬 기준을 코드 자체로 나타내기 때문에 협업에도 더 좋은 것 같다. | . | .",
            "url": "blog.chojaeseong.com/java/comparable/comparator/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/comparable_vs_comparator(%EC%99%84).html",
            "relUrl": "/java/comparable/comparator/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/comparable_vs_comparator(%EC%99%84).html",
            "date": " • Feb 21, 2022"
        }
        
    
  
    
        ,"post10": {
            "title": "git강의(upstream, git객체)",
            "content": "준의 git 강의 . upstream . . 기본적으로 최초push에서는 local -&gt; origin의 연결에 local에 대한 상대적 상류(upstream) 를 -u로 명시해줘야한다. . | -u는 --set-upstream으로 상대적인 상류를 표기한 것이다. . | . | 일반적으로 origin에 대한 origin이 upstream이라고 별칭한다. 미션repo(upstream) -&gt; fork repo(origin) -&gt; clone repo(local) | . | 최초 명시해준 것처럼 upstream은 downstream에 대해 상대적인 것이다. | . | 깃허브 초기 메세지 박스를 보면 -u가 있는데 상대적 상-하 관계를 설정하는 upstream설정을 요약한 단어다 . 없으면 push가 안된다. | 내 local의 remote인 origin이라는 원천이라는 upstream으로 사용한다 보통은 원천(origin)보다 위쪽(stream)은 없다. | 하지만, fork로 가운데origin이 생기면서, 원본 repo를별칭stream을 사용하게 된다. | 우테코의 경우, 미션repo를 fork해해서 origin보다 더 상위단계가 생기므로 upstream | . | . . 여러개의 downstream이 존재함을 안보이더라도 생각해야한다. git clone시((origin &lt;-&gt; local)에는 origin을 알고 있기 때문에 자동으로 stream관계가 설정되어 push할 때 -u를 통한 upstream 설정은 안해도 된다. | . | . | . –help명령어와 git 객체 . 퀴즈1 . O . git help메세지들을 잘 보자. . .git안에 깃 저장소를 초기화 했습니다. | ls -al 숨긴 파일, 폴더 보면 .git이 깃 저장소(로컬 저장소)가 보인다. | . . tree .git/으로 로컬저장소의 구조를 보면 | . | 명령어 도움말은 명령어 + --help를 뒤에 달면된다. . | . | 퀴즈2 . blob은 파일으로 생각하자. . | 답은 5번 . branch는 commit객체에 대한 참조만 가지고 있다. | . . | commit . 커밋 = 작업 디렉토리 스냅샷 = 세이브 포인트 | 돌아가기 위한 포인트.. commit + push만 하지말자 | 돌아가기 위한 정보를 어떻게 담고 있을까 | . . | add시 생성객체, commit시 생성객체를 나누었다. . . add하면, git이 a.txt를 관리대상으로 인식한다. 아까는 없었던, index와 object가 추가 된다. | . | . . commit하면, tree(파일관련), commit(tree를 담고 있는)객체까지 만들어서 2개가 더 만들어진다. | . . | 퀴즈3 . . git은 변경사항만 저장한다? 흔한 오해 -&gt; 파일을 통채로 저장한다! | 엄청 뒤로 갈 때, 변경사항만으로 추적? -&gt; 연산 엄청 많아진다. 그냥 속도측면을 중요시해서 통채로 저장 = 객체로 관리 | 원본 파일마다 tree객체를 가지고 있다. 통채로 저장해놓고, 그것들을 관리하기 위한 커밋이 가진다. 마지막 commit상태의 blob을 본다. | 변경사항을 저장하는게 아니라서.. | . | . | . | . | .",
            "url": "blog.chojaeseong.com/git/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/17/%EC%A4%80)-upstream%EA%B3%BC-git%EA%B0%9D%EC%B2%B4-%EA%B0%95%EC%9D%98(%EC%99%84).html",
            "relUrl": "/git/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/17/%EC%A4%80)-upstream%EA%B3%BC-git%EA%B0%9D%EC%B2%B4-%EA%B0%95%EC%9D%98(%EC%99%84).html",
            "date": " • Feb 17, 2022"
        }
        
    
  
    
        ,"post11": {
            "title": "그림판으로 보는 git협업 미션",
            "content": "git-mission . https://github.com/woowacourse/retrospective/discussions/4 . 미션repo 관리자와 fork하는 페어1과 페어2가 있다. 관리자(upstream) - 페어1,2(origin) - 각 로컬(local) 형태로 구성할 예정 | . | . 관리자는 github에서 repo(git-mission)를 파고, readme.MD를 작성한다. . README.md # 백엔드팀 . . | pair1, pair2가 각각 관리자의 repo( 예정upstream) -&gt; fork(origin) -&gt; clone(local)한 뒤 . main만 있던 repo안에 작업용 각자의 {github_id}로 . | 미션repo(관리자repo)는 main만 일단 유지한다고 가정하며, . | 작업자들은 main fork -&gt; main clone -&gt; local main외 local {본인github_id}를 파서 작업하자. . git checkout -b is2js&lt;github_id&gt; . git branch -a . . 우테코와 같이 특수한 경우(관리자 repo가 main이외에 개별 br를 다 가지고 있는 경우) 작업자들은 학습사이트를 통해 생성된 main + 수많은 {본인github_id} fork -&gt; --single-branch하여 {본인github_id} clone ** -&gt; local {본인github_id} 외에 **step1 을 파서 작업한다. | . | . | . | pair1부터 readme.md를 수정 -&gt; pair2는 대기(파일 수정해도 됨) . 파일수정 . | add + commit . | (clone해왔지만, br바꿨기 때문에) push with origin과의 upstream 최초 설정 . git push --set-upstream origin is2js&lt;github_id&gt; . . | . | pair1은 [fork repo]의 main외 작업br{github_id} -&gt; [원본repo] main에 PR을 날릴 수 있다. . 보통 fork -&gt; clone -&gt; 작업br 파기 -&gt;(origin입장에서 new br인)작업br push -&gt; fork 작업br to 원본 main br로 PR in github | . | 관리자의 merge in github . | pair2가 conflict를 내기 위해 관리자 최신main from pair1 or pair1 최신을 가져오지 않고 . pair1이 작업끝내기 전에 같은 파일에 작업시작 | . . | pair2의 무지성 PR -&gt; conflict를 github가 알려준다. . 공통 작업자가 있다면, 같은 파일 수정 가능성이 있다면, PR전에 pair나 upstream의 pull부터 해야함. | github에서 PR을 만드려고 하면 conflict를 알려준다. | . | **pair2는 최신소스가 업데이트된 원본repo를 받아오기 위해 local &lt;-&gt; 원본repo upstream으로 등록하고, 받아와야한다. ** . pair1을 pair로 등록하고 받아와도 될 것 같은데, 중심은 원본repo에서 받아온다. . | 중간 다리인 fork는 주고/받을 때 별 영향이 없다. local과 원본repo가 연결되어야 최신소스를 받으니, upstream라는 별칭으로 원격저장소를 추가하여 연결한다. . . git remote -v # fork -&gt; clone으로 형성된 origin = fork레포만 연결되어있다. git remote add upstream&lt;원본레포 별칭&gt; &lt;원본레포 URL&gt; git remote -v git fetch upstream # fetch는 커밋내역만 가져오는데 [원격저장소별칭]만으로 가져올 수 있다. # 가져올 br이 있는지 확인한다. git branch -a git merge upstream/main # 가져올 [원격저장소별칭/br] 형태로 merge를 요청한다. . | . | 가져와서 conflict를 (vscode 등에서) 해결하고, 다시 fork(origin)으로 push -&gt; github에서 PR을 날리면 된다. . git push origin is2js{github_id} . . | 우테코의 코드리뷰는 더 복잡하다. . 원본repo의 관리자 -&gt; 리뷰어들이 merge를 담당한다 . | fork전, 우테코 학습사이트를 통해 원본repo에 main외 내 {github_id}로 하면서 PR의 최종merge가 각자의 {github_id}로 되도록 먼저 생성한다. . | fork하면, main + 모든 리뷰이들의 {github_id}들이 있다. -&gt; 내 {gihub_id}의 br만 로컬로 clone해와야한다. . git clone -b is2js&lt;내github_id&gt; --single-branch https://github.com/is2js/java- racingcar.git&lt;url&gt; . | clone후, 내입장에서의 main branch인 {github_id}에서 작업용=리뷰어br인 step1부터 파서 시작한다. . | 만약, 페어가 있다면 한 곳의 step1을 선택한 다음, 작업이 끝나면 찢어진 뒤 . pair라는 별칭으로 git remote add pair &lt;URL&gt;을 하고 | fetch -&gt; merge하여 작업된 pair의 코드를 가져온 뒤, 작업을 시작한다. | . | . . |",
            "url": "blog.chojaeseong.com/git/%ED%98%91%EC%97%85/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/17/git_%EA%B7%B8%EB%A6%BC%ED%8C%90%EC%9C%BC%EB%A1%9C_%EB%B3%B4%EB%8A%94_%ED%98%91%EC%97%85%EB%AF%B8%EC%85%98(%EC%99%84).html",
            "relUrl": "/git/%ED%98%91%EC%97%85/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/17/git_%EA%B7%B8%EB%A6%BC%ED%8C%90%EC%9C%BC%EB%A1%9C_%EB%B3%B4%EB%8A%94_%ED%98%91%EC%97%85%EB%AF%B8%EC%85%98(%EC%99%84).html",
            "date": " • Feb 17, 2022"
        }
        
    
  
    
        ,"post12": {
            "title": "코드리뷰 방법 2단계(step1 PR merge이후)",
            "content": "그 전 1단계 마무리 . local의 step1 브랜치에서 local commit만 한다. | 각종 검토후 push한 뒤, 최초PR을 날린다. (local step1 —&gt;) forkrepo step1 -&gt; 원본repo is2js | . | 최초PR이후, local commit만하다가, 2번쨰 push부터는 피드백 반영된다. | 리뷰어는 PR을 merge . **리뷰어는 ** . Push하여 피드백 반영된 fork-step1 —&gt; 원본-is2js의 PR을 merge시키는 권한이 있다. . 피드백 최종반영 fork step1 to 원본 is2js PR후 N번 피드백push . | 리뷰어의 PR을 merge . . | . | . | . 1단계완성br {github_id} -&gt; local 반영 . 참고문서: 코드리뷰 3단계 | . local 먼저 {github_id} checkout . . local branch를 일단 is2js{github_id}로 넘어온다. . . git checkout is2js&lt;github_id&gt; . | . 원본repo와 동기화 . 원본repo를 별칭upstream으로 remote add . . 현재 local에 달린 git remote 확인하기 . origin: fork레포 | (B라면, pair: A의 repo) | . git remote -v . 결과 . origin https://github.com/is2js/java-racingcar.git (fetch) origin https://github.com/is2js/java-racingcar.git (push) pair https://github.com/Wishoon/java-racingcar.git (fetch) pair https://github.com/Wishoon/java-racingcar.git (push) . | . | 원본(미션)repo를 upstream이라는 별칭으로 원격저장소 등록해주기 . git remote add upstream&lt;별칭&gt; https://github.com/woowacourse/java-racingcar.git&lt;원본(미션)repo&gt; . git remote add upstream https://github.com/woowacourse/java-racingcar.git . 결과 . git remote add upstream https://github.com/woowacourse/java-racingcar.git git remote -v origin https://github.com/is2js/java-racingcar.git (fetch) origin https://github.com/is2js/java-racingcar.git (push) pair https://github.com/Wishoon/java-racingcar.git (fetch) pair https://github.com/Wishoon/java-racingcar.git (push) upstream https://github.com/woowacourse/java-racingcar.git (fetch) upstream https://github.com/woowacourse/java-racingcar.git (push) . | . | . fetch로 원본repo상 merge된 내 br {github_id} -&gt; {remotes/별칭/내br}으로 가져오기 . . fetch로 원본repo상에 리뷰어에 의해 merge된 is2js를 -&gt; local is2js로 가져오기 . git fetch upstream&lt;별칭&gt; is2js&lt;가져올br명&gt; . 결과 . git fetch upstream is2js remote: Enumerating objects: 1, done. remote: Counting objects: 100% (1/1), done. remote: Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (1/1), 2.22 KiB | 759.00 KiB/s, done. From https://github.com/woowacourse/java-racingcar * branch is2js -&gt; FETCH_HEAD * [new branch] is2js -&gt; upstream/is2js . | . | git branch -a를 확인해보면 remotes/별칭/{merge된 내br=github_id}로 생성되었다. . git branch -a . 결과 . . | . | . rebase(1줄 이어붙merge)로 {fetch한 원격br}을 -&gt; {로컬br}과 동기화 . . 원격br -&gt; 로컬br에 끊어진 이후부터 &lt;merge와 달리 1줄&gt;로 이어붙이는 작업인 것 같다. . git rebase upstream/is2js . 결과: fetch한 remotes/upstream/is2js랑 local의 is2js랑 완전히 동일해졌다. . . | 참고로 rebase는 커밋 n개 합치기용(-i) or merge를 깨끗하게( . merge와 비교 장점: 커밋해쉬 유지 및 흐름 유지되어 돌아갈 수 있음 | 단점: merge라는 불필요커밋을 생성함. | . | rebase 장점: 주는놈위에 받는놈위주로 정리가 됨. 깨끗한 커밋 히스토리가 됨. | . | . | . | . 2단계 br 생성하기 . step2 br 생성과 동시에 checkout . 최신화(fetch -&gt; rebase)된 is2js{github_id}에서 받아와 생성되도록 한다. . git checkout -b step2 . | . 이후 step2에 작업후 add/commit/push-&gt;PR-&gt;push반복-&gt;merge . 나는 step1에 작업하던 것이 남아서 step2에서 merge받았다. . . | . step1 삭제 . 1단계 br은 이제 삭제한다. . git branch -d step1 . | .",
            "url": "blog.chojaeseong.com/git/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%ED%98%91%EC%97%85/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/16/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-2%EB%8B%A8%EA%B3%84(%EC%99%84).html",
            "relUrl": "/git/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%ED%98%91%EC%97%85/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/16/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-2%EB%8B%A8%EA%B3%84(%EC%99%84).html",
            "date": " • Feb 16, 2022"
        }
        
    
  
    
        ,"post13": {
            "title": "생성자와 일급컬렉션(사용이유, 테스트)",
            "content": "생성자 규칙 . 나만의 규칙 . 생성 루트가 여러개 ex&gt; List&lt;String&gt; or List&lt;Car&gt;인 일급컬렉션 private 필요속성(만) 받는 기본생성자 | public fromStrings( List&lt; String &gt; ) inputView에서 검증을 하고 오므로 검증없이 -&gt; List&lt;객체&gt;로 변환 -&gt; 생성자 | . | public from객체(List&lt; 객체 &gt;) test등에서 단일객체 -&gt; List add되어 들어오는데, 복수 검증(중복)을 추가후 -&gt; 생성자 | . | | VO, 단일객체라도 숫자형이라면 -&gt; inputView에서 형변환후, 해당형으로 검증되도록 inputView에서 따로 검증안한다면, public 생성자에서 검증까지 다 처리하면 될 듯함. inputView에서는 VO는 형변환하고나서 -&gt; 검증하자. | . | inputView 검증해야하는 상황이라면? -&gt; 형변환후 int만 검증 public 기본생성자(원본 타입) with 노검증(for inputView거친 뒤 controller or 숫자VO 연산) | public fromNumber(원본타입) with 검증(for 테스트 or int직접생성) | | | . 일급컬렉션 생성자와 사용이유 . 생성자 2+1개 . fromXXXX: InputView에서 검증된 List&lt; String &gt;를 받는 public 정적팩토리메서드 . InputView.getXXX() 에서 검증 후 들어오는 ** -&gt; **List&lt; String &gt;으로 들어올 것이기 때문에 .fromStrings( )형식으로 작성한다. . String List -&gt; 단일객체 List로 변환되어 -&gt; 기본 생성자를 부른다. | . public static Cars fromNames(List&lt;String&gt; values) { //input에서 검증하고 와서, 변환만 List&lt;Car&gt; cars = values.stream() .map(value -&gt; Car.from(value)) .collect(Collectors.toList()); return new Cars(cars); } . | . from: 테스트 등에서 List&lt; 단일객체 &gt;를 받는 public 정적팩토리메서드 . 기본생성자는 private하게 유지하기 위해, 테스트용 public 기본 생성자 from ( List&lt; 단일객체 &gt;로 생각하자. . 따로 개별 검증은 필요 없고(단일객체 생성시 이미 검증) -&gt; 중복검사 등만 필요 | . public static Cars from(List&lt;Car&gt; cars) { //중복 검증 등 return new Cars(cars); } . | . 기본생성자: private + List&lt; 단일객체 &gt; . inputView 검증-&gt; fromStrings . | test -&gt; from -&gt; 복수검증 . | 기본생성자는 일단 검증 없이 생성만 하는 역할을 하게 한다. . private Cars(List&lt;Car&gt; cars) { this.cars = cars; } . | . 쓰는 이유 4가지 . 참고 블로그 | . 01 검증 통과해야만 생성 가능한 자료구조(비지니스 종속 자료구조) . 흩어져있는 검증 기능들을 외울 수 없다. 신입사원이 와도 바로 작동하도록 하는 객체를 만들어야한다. . | 해당, util등에서 처리할게 아니라 검증 만족시 생성가능한 자료구조를 만들어 신입사원도 쓸 수 있게 해야한다. . public static Cars from(List&lt;Car&gt; cars) { Validator.validateCarsName(getCarNames(cars)); return new Cars(cars); } . | . 02 setter/add 등이 없는 불변구조 . List는 add, map은 put 등의 메서드를 제공하는데 . 일급컬렉션으로 감싸서 생성자와 getter류 기능만 제공하도록하고 setter 등을 제공하지 않음녀 불변구조가 된다. . | 자료구조에 final을 붙혀도 해당 context에서 재할당만 불가 -&gt; add, put 등은 가능함. . cf) 일급컬렉션에 변수는 1개이며, final이 붙어서 최초생성이후 변경할 수 없게 한다. | . private final List&lt;Car&gt; cars; . | . | . 03 상태(변수)와 행위(기능)을 자료구조와 함께 한 class에 다 모으기(냉무) . 05 이름을 가지는 자료구조가 됨.(냉무) . 일급컬렉션 테스트 . 단일객체 -&gt; 일급컬렉션 순서대로 생성 . 단일객체 -&gt; 일급컬렉션 순서대로 생성하도록 전역변수 -&gt; @BeforeEach에서 List&lt; Car &gt;를 받으면서 중복 등 다수검증하는 from으로 생성한다. | 단일 객체생성은 여기서는 다루지 않지만, 검증이 들어간 로직으로 해야할 듯. | . | . //1. 일급컬렉 Test: @BeforeEach에서 단일객체 개별생성 후(그래야 개별조작 가능 -&gt; 반영) List에 담아놓기 Car 코니; Car 재성; Cars cars; @BeforeEach void setUp() { 코니 = new Car(&quot;코니&quot;); 재성 = new Car(&quot;재성&quot;); cars = Cars.from(Arrays.asList(코니, 재성)); } . given자리에 단일객체 조작을! when에서는 일급컬렉 기능을! . given자리에 일급컬렉션과 공유된 개별 객체들을 조작후 -&gt; 테스트한다. . @Test void getMaxposition_method_test() { //given -&gt; 단일객체를 조작 코니.move(() -&gt; true); 재성.move(() -&gt; false); //when Car actualMaxPositionCar = getMaxPositionCar2(); //then assertThat(actualMaxPositionCar).isEqualTo(코니); } // private하며 메서드 내부의 메서드 -&gt; 복사하고, 인자를 바꿔주자. private Car getMaxPositionCar2() { Car maxPositionCar = Arrays.asList(코니, 재성).stream() .max(Car::compareTo) .orElseThrow(() -&gt; new IllegalArgumentException()); return maxPositionCar; } . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%ED%85%8C%EC%8A%A4%ED%8A%B8/%EC%83%9D%EC%84%B1%EC%9E%90/2022/02/15/%EC%83%9D%EC%84%B1%EC%9E%90_%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98_%EC%82%AC%EC%9A%A9%EC%9D%B4%EC%9C%A0_%ED%85%8C%EC%8A%A4%ED%8A%B8(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%ED%85%8C%EC%8A%A4%ED%8A%B8/%EC%83%9D%EC%84%B1%EC%9E%90/2022/02/15/%EC%83%9D%EC%84%B1%EC%9E%90_%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98_%EC%82%AC%EC%9A%A9%EC%9D%B4%EC%9C%A0_%ED%85%8C%EC%8A%A4%ED%8A%B8(%EC%99%84).html",
            "date": " • Feb 15, 2022"
        }
        
    
  
    
        ,"post14": {
            "title": "commit.template과 message양식",
            "content": "commit.template 활용하기 . template(.gitmessage.txt) 생성 . 이미 지정된 commit.template의 터미널에서 확인 . 없으면 원하는 경로에서 .gitmessage.txt를 생성하면 됨. | . git config --global commit.template . C: Users cho_desktop .gitmessage.txt에 지정 해놨었다. . cf) 적용 코드 . git config --global commit.template C: Users cho_desktop .gitmessage.txt . | . | . | 해당 경로(윈도우의 경우, 풀 경로)로 가서 커밋.템플릿을 생성/수정한다. . .gitmessage.txt . #commit전: 클-상-변개행/F8/pub메 테스트만/함수순서/불필요개행&amp;매직넘버/ 테스트돌리기 #fix | feat | build | chore | ci | docs | style | refactor | perf | test: ##### Subject 50 characters ## don&#39;t finish with . ##-&gt;| ######## 본문은 한 줄에 최대 72 글자까지만 입력 ########################### -&gt; | # 제목에서 한줄 띄고, 여러줄운 &quot;- 내용1 - 내용2&quot; , &quot;무엇을&quot; &quot;왜&quot; 기술 &gt;&gt; &quot;어떻게&quot; 72자 제한 ################################ # 꼬릿말은 아래에 작성: ex) #이슈 번호 # COMMIT END # &lt;타입&gt; 리스트 # feat : 기능 (새로운 기능) # fix : 버그 (버그 수정) # refactor: 리팩토링 # style : 스타일 (코드 형식, 세미콜론 추가: 비즈니스 로직에 변경 없음) # docs : 문서 (문서 추가, 수정, 삭제) # test : 테스트 (테스트 코드 추가, 수정, 삭제: 비즈니스 로직에 변경 없음) # chore : 기타 변경사항 (빌드 스크립트 수정 등) # # 제목 첫 글자 -&gt; 대문자 # 제목 명령문 # 제목 끝에 마침표(.) 금지 # 제목과 본문을 한 줄 띄워 분리하기 # 본문은 &quot;어떻게&quot; 보다 &quot;무엇을&quot;, &quot;왜&quot;를 설명한다. # 본문에 여러줄의 메시지를 작성할 땐 &quot;-&quot;로 구분 # . | . | . 생성 템플릿 적용하기 . global 설정 . 명령어를 통해 지정 . git config --global commit.template C: Users cho_desktop .gitmessage.txt . | .gitconfig의 [commit]블럭안에 template을 직접 수정 . [commit] template = C: Users cho_desktop .gitmessage.txt . | repository별 설정 . ~/.gitconfig를 사용하는 대신 해당 repository안에 있는 .git/config에 위에서 설명한 [commit]블락을 추가 . [commit] template = C: Users cho_desktop .gitmessage.txt . | .",
            "url": "blog.chojaeseong.com/git/%ED%98%91%EC%97%85/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/2022/02/15/commit.template%EA%B3%BC-%EC%96%91%EC%8B%9D-%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/git/%ED%98%91%EC%97%85/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/2022/02/15/commit.template%EA%B3%BC-%EC%96%91%EC%8B%9D-%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Feb 15, 2022"
        }
        
    
  
    
        ,"post15": {
            "title": "intellij 협업 세팅",
            "content": "인텔리제이 세팅 . Gradle buildType 변경 및 assertj 추가 . gradle build Type 변경 -&gt; intellij로 변경(속도) . gradle검색후 build and run intellij로 바꿔주기 | . 라이브러리에 assertj 넣어주고 리프레쉬 재ㅜ기 . build.gradle의 dependency에 assertj 라이브러리 넣어주고 refresh 하기 . testImplementation &#39;org.assertj:assertj-core:3.22.0&#39; testImplementation &#39;org.junit.jupiter:junit-jupiter-params:5.4.2&#39; //@ParameterizedTest 안될 때 . | Ctrl+Shift+O 또는 우측상단에 떠있을 코끼리버튼을 클릭해줘야 반영이 된다. . 단축키는 keymap에서 덮어써줘야 작동됨. . | 그래도 잘 안되면, Test파일에 static import해놓고 reload from disk . import static org.assertj.core.api.Assertions.*; . | . | . gradle의 테스트 해보기 . . shift 2번 or f1 -&gt; gradle task선택 gradle clean 수행 | gradle test 수행 | | utf 8 설정(file encoding) . utf8, lf설정 되어있나 확인하기 . editor &gt; File Encodings &gt; 체크 3가지 모두 utf-8 | . | shift 2번연속 클릭 (search everywhere) . vm검색 Edit Custom VM option 클릭 | 맨 마지막 줄에 -Dfile.encoding=UTF-8 추가 | . | . | build.gradle 설정 추가 . compileJava.options.encoding = &#39;UTF-8&#39; // UTF-8 설정 compileTestJava.options.encoding = &#39;UTF-8&#39; . | . Save Actions / code style / saveActions / 페어 컨벤션 / LF(editorConfig) / checkstyle . 저장시 새줄 추가 with Save Actions . Plugins &gt; market &gt; save actions를 검색해서 설치한다. 아래와 같은 3개를 체크해준다. | . | Editor &gt; General &gt; 에서 해당 박스를 체크한다. | . code style . 우테코javastyleXML, naverConventionXML 다운로드 프로젝트폴더 최상단에 넣어준다. | . | Editor &gt; code style &gt; Scheme &gt; 톱니바퀴 &gt; Import Scheme &gt; Intellij IDEA XML intellij-java-wooteco-style.xml 선택해주기 | . | (추가) method의 local variable final로 생성 + tab말고 4space . Editor &gt; Code style &gt; java &gt; Code generation &gt; [x] make ~ final 체크박스 2개 . | Editor &gt; Code style &gt; java &gt; tabs and indents &gt; [ ] Use tab character 체크해제 + Continuation indent 8-&gt;4 . OS마다 tab의 크기가 다르므로 space를 사용하게 tab사용 체크해제하는 것 | . | . (추가) 변수를 final로 추출(최초 1회) . 추출할 때, ctrl + alt + v를 2번 눌러서, Declare final체크 | . (추가) 상수를 private로 추출(최초 1회) . 추출할 때, ctrl + alt + c를 2번 눌러서, public -&gt; private로 옮겨놓기 | . 페어 컨벤션(링크) . 구글 스프레트 시트 링크로 매번 업데이트 된 것 활용하기 | . .editorConfig for windows에서도 LF로 저장 . 다양한 에디터들에게 공통적인 코드컨벤션을 적용시킨다. 적용시 windows에서도 LF로 저장되게 한다. | . | 루트에서 NEW &gt; EditorConfig 검색후 생성한다. . | 아래 내용을 복붙한다. . # top-most EditorConfig file root = true [*] # [encoding-utf8] charset = utf-8 # [newline-lf] end_of_line = lf # [newline-eof] insert_final_newline = true [*.bat] end_of_line = crlf [*.java] # [indentation-tab] indent_style = tab # [4-spaces-tab] indent_size = 4 tab_width = 4 # [no-trailing-spaces] trim_trailing_whitespace = true [line-length-120] max_line_length = 120 . checkstyle . | . 일단 LF로 push하기 위한 git 전역설정이 되어있어야한다. . 윈도우에서는 git commit시 CRLF로 새줄을 저장하지만, 위 설정을 통해 push시에는 LF로 올라가게 한다. . Git은 커밋할 때 자동으로 CRLF를 LF로 변환해주고 | windows로 clone하면 다시 LF가 CRLF가 됨 | . git config --global core.autocrlf true . | . | 없다면 플러그인 Plugins 에서 CheckStyle-IDEA검색 후부터 설치한다. . CheckStyle-IDEA 설치 | 프로젝트 최상단에 naver-checkstyle-rules.xml를 위치시키고 | Tools &gt; Checkstyle에서 버전을 8.24 이상으로, | Scan Scope를 All sources(including tests)로 맞추고 - 테스트 한글함수를 위해서 tests 포함안해도 될 듯? | +를 눌러, 위에서 편집해준 naver-checkstyle-rule를 추가해준다. | naver-checkstyle-rule을 선택해준다. | . | . | 네이버핵데이 컨벤션 및 CheckStyle 적용하기 . 요약 . Settings &gt; Editor &gt; Code style &gt; Java &gt; Scheme &gt; 톱니바퀴 &gt; import Scheme &gt; (ideaProject폴더에 다운받아놓은 )InteliJ ~ .xml 파일 찾아 적용 cf) code style&gt; java에서 use tab character를 풀어야 4스페이스가 된다. Tab 사용하도록 체크하자. | | 파일을 저장 할 때마다 포멧터 자동 적용설정 by Save Actions plugin을 활용하면 파일을 저장하는 순간 포멧터를 자동 적용할 수 있다. File &gt; Settings ( Ctrl + Alt + S ) &gt; Plugins 메뉴로 이동 | Marketplace 탭에서 ‘Save Actions’ 로 검색 | Save Actions&#39; plugin의 상세 설명 화면에서 [Install]` 버튼 클릭 | IntelliJ를 재시작 | File &gt; Settings &gt; Other Settions &gt; Save Actions 메뉴로 이동 | 아래 항목을 체크 Activate save actions on save | Optimize imoprts | Refomat file | . | | 플러그인 CheckStyle-IDEA 플러그인을 검색 후 설치 Tools &gt; CheckStyle에서 Checkstyle version을 8.24 이상, Scan Scope를 All sources (including tests) 로 설정 | Configuration file에 다운받고 수정한 XML 파일(ideaProject폴더에 다운받아놓은 naver~checkstyle rule.xml)을 추가 | 하단에 checkstyle 창(단축키 직접지정 alt+shift+k)로 코드짜고 확인하기 | | | . . . intellij용 xml파일 다운로드 | 설치가이드 https://naver.github.io/hackday-conventions-java/#intellij-formatter | 나는 지금 플러그인 : google-java-format&gt; android 버전을쓰고있는데.. 취소시킴 | . | checkStyle적용하기 . CheckStyle은 Java 코드를 작성 할 때 규칙(이 경우 코딩 컨벤션)들을 선언해두고 이를 어길 시 에러 또는 경고를 뿜어내어 개발자로 하여금 컨벤션을 강제로 지킬 수 있도록 도와주는 코딩 컨벤션 검사 도구다. 네이버 핵데이 Java 코딩 컨벤션을 적용할 시 다음을 제외한 나머지들에 대한 컨벤션을 검사할 수 있다. . 한국어 발음대로의 표기 금지 | 클래스 이름에 명사 사용 | 인터페이스 이름에 명사/형용사 사용 | 메서드 이름은 동사/전치사로 시작 | 테스트 클래스는 ‘Test’로 끝남 | 대괄호 뒤에 공백 삽입 | 주석문 기호 전후의 공백 삽입 | . | 적용방법 . Naver CheckStyle Rules XML 파일을 다운받는다. 나는 프로젝트 최상단($rootDir)에 이를 추가했다. . 내문서 &gt; IdeaProjects폴더에 저장함. | . | 우선 나는 다른 규칙을 덮어쓸 생각이 없어서 여기를 참고하여 XML 파일에서 다음을 삭제했다. 이를 삭제하지 않으면 다음 단계에서 suppressionFile 변수에 파일을 할당해야한다. . &lt;module name=&quot;SuppressionFilter&quot;&gt; ​&lt;property name=&quot;file&quot; value=&quot;${suppressionFile}&quot;/&gt; ​&lt;property name=&quot;optional&quot; value=&quot;false&quot;/&gt; &lt;/module&gt; . | . | ide에 적용하기 . File &gt; Settings &gt; Plugins 메뉴에서 CheckStyle-IDEA 플러그인을 검색 후 설치한다. | Tools &gt; CheckStyle에서 Checkstyle version을 8.24 이상, Scan Scope를 All sources (including tests) 로 설정한 후 Configuration file에 다운받고 수정한 XML 파일을 추가하자 | 이제 우리가 설정한 코딩 컨벤션을 어기는 코드를 작성하면 다음과 같이 경고 표시가 나타난다. | | . | .",
            "url": "blog.chojaeseong.com/intellij/%EC%9A%B0%ED%85%8C%EC%BD%94/%ED%98%91%EC%97%85/2022/02/13/intellij%ED%98%91%EC%97%85%EC%84%B8%ED%8C%85(%EC%99%84).html",
            "relUrl": "/intellij/%EC%9A%B0%ED%85%8C%EC%BD%94/%ED%98%91%EC%97%85/2022/02/13/intellij%ED%98%91%EC%97%85%EC%84%B8%ED%8C%85(%EC%99%84).html",
            "date": " • Feb 13, 2022"
        }
        
    
  
    
        ,"post16": {
            "title": "intellij 단축키 및 플러그인",
            "content": "인텔리제이 플러그인 및 단축키 . 플러그인 . vscode keymap검색 install . keymap탭 가서 VSCode로 바꾸기 | . | key Promoter X 설치 vscode keymap 바꾼것도 보여준다. | | Rainbow Brackets | .ignore : 우클릭으로 ignore파일을 만들어주는데, . 우클릭 &gt; new &gt; ignore file &gt; .gitignore파일 &gt; 선택하면 될듯핟. | 자동완성도 해줌. | . | cobalt2 theme . | editor &gt; font &gt; jetbrain Mono -&gt; fira code + ligature 허용 . | 맨끝에 newline없으면 생성해주기 . 설정 &gt; editor &gt; general &gt; on save 탭 &gt; [x] ensure lien feed at file end on save . ensure every saved file ends with a line break | . . | | translation Plugin &gt; MarketPlace &gt; Translation검색 . . | Tools 내부에 있음. 기본적인 세팅은 구글번역 . | 단축키 일부 재정의 . 공부용 영-&gt;한 번역기: ctrl+shift+ Y 아무것도 없는 곳에 두고 누르면 code with me 단축키 | . | 코딩작명용 한-&gt;영 즉시번역 : ctrl+shift+X Translate and Replace: 설정창에 묻혀서 단축키 재정의 (ctrl+shift+x)-&gt; 다른것 remove) | . | . | | 단축키(vscode keymap기준) . shift 2번 : 전체 검색(유지) vscode F1 | . | keymap 들어가서 move To opposite group검색후 ctrl+shift+ 오른화살표지정하기 ctrl + 이후 넘기기..왼쪽넘기기 기능 자체는 없나보다. | alt+shift+0으로 세로로 넘기기 가능 | . | alt+shift+F : reformat code -&gt; 한파일내 패키지 or 폴더 선택후 alft+shift+F | . | keymap 들어가서 back검색후 ctrl+u지정하기 | ctrl + .으로 메인메소드 내용을 extract method 호돌스에서 봄. | 메소드 분리 및 패키지명 작성하고 폴더이동시키기 | . | 신세계) alt+insert로 생성자를 만듬 | **신세계) 메서드사용을 위한 객체 만들 때(인스턴스화) 할 때, ** new 클래스명(); 기입후 ctrl+.으로 local변수 자동(선택후)생성하자. | 객체.메서드();기입후 ctrl+.으로 메서드결과값 받는 변수 자동(선택후)생성 | . | keymap -&gt; extend line selection -&gt; ctrl+L을 추가해서 사용하기 라인 선택하기 shift+alt+아래화살표로 복사할때,, 라인 선택해서해야.. 꼬임없을 듯 | . | . | shift+ alt+ F10: 실행할 class파일 선택해서 실행 ctrl+alt+F10은 바로 실행. | . | shift + alt + x: 현재 파일들 다 close | shift + alt + a : 긴글 주석? . | alt + ~ : git관련 명령어들 목록나옴 . | ctrl+F11 or ctrl+shift+{key}로 북마크 지정 -&gt; ctrl+해당번호로 이동 | keymap -&gt; show bookmaks검색후 -&gt; CTRL+SHIFT + F11 으로 지정함 | . | ctrl+f3 : 같은단어 이동가능한 검색한 상태로 만들기 == ctrl+f f3 : 같은 단어 다음으로 이동 | shift+f3 : 같은단어 이전 단어로 이동 | . | shift+F5 : 실행중인 작업 종료 ctrl+F5 : 실행 | shift+ alt + f10 : main함수 골라서 실행 | . | alt+7: 현재파일 Structure(메소드 등) 한눈에 보기 유틸메서드로 빼기, 상수 옮기기 : f6으로 편하게 | . | 리팩토링 alt+ctrl+c : 값을 상수로 등록해버리기 | alt+ctrl+m : 코드를 메서드화 시키기 2번 눌르면 창으로 하는 듯 | . | alt+ctrl+v: new 클래스()까지 입력후 참조변수 바로 생성 | alt+ctrl+p: 클래스내 변수/메서드 사용을 -&gt; 작성중인 메서드의 파라미터로 빼고 싶을 때 ex&gt; 테스트를 위해 내부랜덤요소를 파라미터로 받도록 설게 | . | . | 축약어 iter | fori 추가 | itar | ifn | inn | . | F8: 오류바로 찾아가기 | ctrl+f -&gt; F3 or shift + F3 : 검색항목 순서대로 찾아가기 . | alt + del : 메소드 등 안전하게 지우기 . | keymap -&gt; refresh gradle dependen~검색 후 -&gt; shift+ c+a + G로 추가해서 사용 gradle에 추가한 라이브러리 재갱신시킬 때!! | . | keymap -&gt; checkstyle -&gt; alt+shift+k로 지정함 naver checkstyle 적용해보기 위함임. | . | F3 -&gt; 함수단위로 건너띄기 검색후 F3 : 다음 검색결과로 넘어가기 shift는 이전으로 넘어가짐. | . | . | ctrl+Tab : 직전창 왔다갔다하기 shift 안눌러도됨. | 메인로직(controller) 옆에서, readme &lt;-&gt; 세부작업중 파일싱글톤관리자, 서브화면 왓따갔다 하면 좋음 | . | ctrl+shift+alt+ I 후 -&gt; unused desc 검색후 -&gt; test파일 제외 체크 -&gt; 사용하지 않는 험수들 손수 제거하기 safe delete하니까..ㅠㅠ 설정 꼬였음. . | File -&gt; invalidate cache 캐쉬삭제 &amp; restart 해서 처리.. . | . | 라이브 템플릿 추가하기 싱글톤용 -&gt; sgt으로 생성 외부에서 메인로직관리싱글톤Class.getInstance()로 작성후 | 클래스 생성 후 sgt으로 채워주기 | . | 검증하며 무한호출하는 재귀 getInput InputView.getInput()작성후 getMany or getOne | . | 랩핑클래스용 | 이넘용 | . | keymap에서 Toggle case검색후 vscode의 대문자(U), 소문자(L)에 해당하는 것 2개를 다 추가해주기 . ctrl+alt+U , ctrl+alt+L | . . | try/catch등 한방에 씌우기: ctrl+alt+t . | ctrl+alt+O : library 적용안될 때 refresh시키는 단축키 덮어주기 default 단축키로 지정되어있지만, 겹치는게 많아서 잘 적용이 안되더라. 다른거 remove하면서 덮어준다. | . | ctrl+F2 : 동일단어 한번에 전체 선택 . | ctrl+space x 2 : 기존 navigate error 역할인 F8이 너무 멀어서 추가함 keymap -&gt; navigate error검색후 add ctrl+space + second stroke ctrl+space 추가 -&gt; 기존 F8 leave | . | .",
            "url": "blog.chojaeseong.com/intellij/%EC%9A%B0%ED%85%8C%EC%BD%94/%EB%8B%A8%EC%B6%95%ED%82%A4/%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8/2022/02/13/intellij%EB%8B%A8%EC%B6%95%ED%82%A4(%EC%99%84).html",
            "relUrl": "/intellij/%EC%9A%B0%ED%85%8C%EC%BD%94/%EB%8B%A8%EC%B6%95%ED%82%A4/%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8/2022/02/13/intellij%EB%8B%A8%EC%B6%95%ED%82%A4(%EC%99%84).html",
            "date": " • Feb 13, 2022"
        }
        
    
  
    
        ,"post17": {
            "title": "fastpages change index.html",
            "content": "참고블로그 및 깃허브 이분은 옛날 버전인 것 같으며, index.md로 paginationd이 작동한다. | 그러나 내 버전의 _config.yml은 md파일을 html파일로 수정하라고 명시하고 있다. | . | . index.md를 posts pagination을 제공 안함. . index.md를 사용하면, 아래 posts의 pagination이 안된다고 _config.yml에 명시되어있었다. 그래서 index.md로 빌드는 되니, 빌드후 html소스를 복붙해서 index.html로 옮기는 방식으로 꾸미려고 한다. | . | index.html을 삭제한 상태에서 main으로 빌드 되어 표기는 되더라. | . index.html -&gt; index_backup.html로 빼놓기 . root에 index.html이 존재하면, index.md이 반영이 안되어 백업해놓는다. | . index.md 생성 후 내용 채워 push . 나름의 시행착오 끝에 완성한 index.md(생성해야함.) | . layout: home search_exclude: true ![](/images/logo_github.png &quot;로고&quot;){: style=&quot;float: right; margin-left: 20px&quot; width=&quot;180&quot;} ## I&#39;m... 평범한 한의사 `돌아온범생`의 우아한 엔지니어 도전기를 기록합니다.&lt;br/&gt; &lt;br/&gt; 조재성 Jaeseong Cho | &lt;br/&gt; Doctor of Korean Medicine, Currently studying SW engineering and biostatistics&lt;br/&gt; [more...](/about) ## Posts . markdown에서 이미지를 float시키는 방법 참고해보자. . !()[]{: style=&quot;float: right; margin-left: 20px&quot; width=&quot;180&quot;} . | . . . 블로그 -&gt; 소스보기 -&gt; html코드로 복붙 . &lt;main class=&quot;page-content&quot; aria-label=&quot;Content&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;home&quot;&gt;&lt;p&gt;&lt;img src=&quot;/images/logo_github.png&quot; alt=&quot;&quot; title=&quot;로고&quot; style=&quot;float: right; margin-left: 25px&quot; width=&quot;200&quot; /&gt;&lt;/p&gt; &lt;h2 id=&quot;iam&quot;&gt;I’m…&lt;/h2&gt; &lt;p&gt;평범한 한의사 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;돌아온범생&lt;/code&gt;의 우아한 엔지니어 도전기를 기록합니다.&lt;br /&gt; &lt;br /&gt; 조재성 Jaeseong Cho | &lt;br /&gt; Doctor of Korean Medicine, Currently studying SW engineering and biostatistics&lt;br /&gt; &lt;a href=&quot;/about&quot;&gt;more…&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;posts&quot;&gt;Posts&lt;/h3&gt; . . index.html 부활시키기 + md는 삭제 . . . layout: home search_exclude: true image: images/logo_github.png &lt;main class=&quot;page-content&quot; aria-label=&quot;Content&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;home&quot;&gt;&lt;p&gt;&lt;img src=&quot;/images/logo_github.png&quot; alt=&quot;&quot; title=&quot;로고&quot; style=&quot;float: right; margin-left: 25px&quot; width=&quot;200&quot; /&gt;&lt;/p&gt; &lt;h2 id=&quot;iam&quot;&gt;I’m…&lt;/h2&gt; &lt;p&gt;평범한 한의사 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;돌아온범생&lt;/code&gt;의 우아한 엔지니어 도전기를 기록합니다.&lt;br /&gt; &lt;br /&gt; 조재성 Jaeseong Cho | &lt;br /&gt; Doctor of Korean Medicine, Currently studying SW engineering and biostatistics&lt;br /&gt; &lt;a href=&quot;/about&quot;&gt;more…&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;posts&quot;&gt;Posts&lt;/h2&gt; .",
            "url": "blog.chojaeseong.com/fastpages/2022/02/13/fastpages_%EB%A9%94%EC%9D%B8%ED%99%94%EB%A9%B4%EB%B0%94%EA%BE%B8%EA%B8%B0.html",
            "relUrl": "/fastpages/2022/02/13/fastpages_%EB%A9%94%EC%9D%B8%ED%99%94%EB%A9%B4%EB%B0%94%EA%BE%B8%EA%B8%B0.html",
            "date": " • Feb 13, 2022"
        }
        
    
  
    
        ,"post18": {
            "title": "TDD 1 문자열계산기",
            "content": "TDD . red -&gt; green -&gt; refactoring . 실패하는 코드(red)부터 짠다. . 테스트코드부터 짠다. | 프로덕션 코드를 생성하지 않은 체로 작성하면서 생성한다. | given(data), when(actual), then(assert문)의 순서로 짠다. | 최초 에러를 내기 위해 throw new IllegalStateException();를 활용한다. | | green을 만들 때는, 모든case 통과 풀 구현이 아니라, (현재까지의 테스트를 모두 만족시키는) 최소한의 최소한의 수정만 한다. . 예를 들어 expected 1을 만족시키는 코드를 짤 때 . return Integer.parseInt(&quot;1&quot;);이 아닌 return 1;으로 짜야한다. | . | 임의의 1개 case가 아닌 다양한 expected를 만족시켜야할 경우, assert문을 여러개 짜지말고, @Test메서드를 늘려서 2번째부터는 일반화시키는 풀구현을 하자. . @Test void splitAndSum_숫자하나() { final int actual = StringCalculator.splitAndSum(&quot;1&quot;); assertThat(actual).isEqualTo(1); //assertThat(actual).isEqualTo(2); } // assert문 추가가 아니라 테스트를 추가한다. @Test void splitAndSum_숫자하나_2() { final int actual = StringCalculator.splitAndSum(&quot;2&quot;); assertThat(actual).isEqualTo(2); //에러를 고치려면 어쩔 수 없이 2번째부터는 일반화된 풀 구현 } . | . | refactoring은 . 메서드 추출 시, 새롭게 추출된 메서드의 관점에서 인자를 수정할 수 도 있다. . 대상: indent를 늘리는 반복문을 포함한 부분 or 다른 일을 하는 곳 . 참고: method refactoring | . | 인자에 final을 달아서 엄청 긴 코드의 끝에서도 안심하고 사용할 수 있게 해보자. 요즘 언어들은 불변을 default로 한다고 한다. . | 매개변수의 이름도 바뀌어야한다 splitValues -&gt; values . //private static int sum(String[] splitValues) { private static int sum(String[] values) { int result = 0; for (String value : values) { result += Integer.parseInt(value); } return result; . | . | . | 복잡한 요구사항 -&gt; 쪼갠 학습테스트 활용 . 예를 들어, 문자열을 커스텀 문자열로 split -&gt; sum 을 구해야하는데, 일단 split부터 되도록 학습테스트를 작성한다. . 요구사항 . @Test void splitAndSum_custom_구분자() { final int actual = StringCalculator.splitAndSum(&quot;//; n1;2;3&quot;); assertThat(actual).isEqualTo(6); } . | 단계별 학습테스트 추가 1 . 쪼갰을 때 나와야하는 값을 expected로 생각하고 테스트하면 된다. | . @Test void split() { // given final String text = &quot;//; n1;2;3&quot;; // split해보고 -&gt; **내 기준에서 나와야하는 값(**이게 나와야한다**)을 &lt;expected&gt;자리에 넣고 테스트해본다.** // when String[] splitValues = text.split(&quot; n&quot;); assertThat(splitValues[0]).isEqualTo(&quot;//;&quot;); // 앞부분에서 나와야하는 값이 통과했다면, -&gt; 뒷부분도 테스트 코드를 추가해서 돌려본다. assertThat(splitValues[1]).isEqualTo(&quot;1;2;3&quot;); } . | 단계별 학습테스트 추가2 . 잘 쪼개졌어도, 구분자가 기존 코드와는 다른 경우이므로, if 검사 후 -&gt; ealry return 로직을 추가해야하는 상황이다. 특정 경우를 잘 골라내는지 boolean이 expected로 되는 학습테스트를 추가하자. | . | . @Test void startsWith() { //given // data -&gt; &quot;//&quot;로 시작하는지를 확인하는 학습테스트를 만든다. final String text = &quot;//; n1;2;3&quot;; //when // actual -&gt; 슬래쉬 2개로 시작하는 커스텀이냐? boolean isCustom = text.startsWith(&quot;//&quot;); //then // expected -&gt; 나와야하는 값 = true assertThat(isCustom).isTrue(); } . | 학습테스트 통과한 코드를 —&gt; 프로덕션 코드에 반영하자 . | . | . 일부분 수정(private함수or 코드) TDD -&gt; 영향받지 않게 복붙메서드 활용 . [private ] 특정함수 수정 TDD -&gt; Test에 [특정함수]만 복붙 . 요구사항: 음수 -&gt; 예외발생시키세요. -&gt; split한 리팩토링으로 splitAndSum 중 private sum()함수만 TDD해야한다. . Test클래스로 private함수를 복붙해온다. . 복붙을 한 순간, 기존 코드에 영향주지 않는 코드가 된다. | XXX.sum() -&gt; XXXTest.sum()으로 사용해서 테스트할 예정이다. | . | 전체 메서드(splitAndSum)중 일부분(sum())만 가져왔으므로 테스트 호출 메소드도 달라질 것이다. . 기존 전체메서드 테스트 가정 (나중에 완성될 테스트) . @Test void splitAndSum_negative() { assertThatThrownBy(() -&gt; StringCalculator.splitAndSum(&quot;-1,2,3&quot;)) .isInstanceOf(RuntimeException.class); } . | 일부분(전체에 비해 인자 달라짐) 메서드 테스트 ( Test로 복사해온 private함수라 XXXXTest.sum() ) . void sum_negative() { // sum(&quot;-1,2,3&quot;); // sum(&quot;-1,2,3&quot;.split()) // StringCalculatorTest.sum(&quot;-1,2,3&quot;.split(&quot;,&quot;)); assertThatThrownBy(() -&gt; StringCalculatorTest.sum(&quot;-1,2,3&quot;.split(&quot;,&quot;))) .isInstanceOf(RuntimeException.class); } . | Test코드로 복붙해온 일부분 메서드( 이놈을 수정해서 구현후 반영할 예정 ) . private static int sum(String[] values) throws RuntimeException { int result = 0; for (String value : values) { result += Integer.parseInt(value); } return result; } . | . | 예외처리 로직을 중간에 추가 by 변수 추출 . 좌항 = 우항 으로 우항이 할당되기 전 &lt;if 예외처리&gt;로직 추가를 위해서 변수 추출(Ctrl+Alt+V)을 활용한다. . result += Integer.parseInt(value); //우항이 넘어가기 전에 받아준다. int number = Integer.parseInt(value); result += number; int number = Integer.parseInt(value); // 우항이 넘어가기전에 받아 예외처리를 해준다. if (number &lt; 0) { throw new RuntimeException(); } result += number; . | . | 테스트통과시 복붙한 sum()메서드를 -&gt; 원본에 반영 + 원본 테스트함수 돌려보기 . 끝난 코드는 날리는게 맞다. | . | | . [public ] 특정[코드] TDD -&gt; 바로 밑에 [코드포함 222메서드 함수] 복붙 . 예를 들어, 어느정도 완성된 public splitAndSum() 메서드에서 text==null이외에 text.isEmpty() 검사를 추가하고 싶다. 하지만, 이미 다른 코드들과 섞여있는 일부분의 코드이므로 다른 코드에 영향주지 않게 테스트하려고 한다. . 코드를 포함한 메서드 복사 붙혀넣기를 통해 기존 코드 영향 받지 않는 메소드2를 새롭게 생성해서 테스트한다. . // 기존 메소드 public static int splitAndSum(final String text) { if (text == null) { return 0; } return sum(split(text)); } // if 조건에 .isEmpty()를 추가할 예정인데 -&gt; sum(split(text)))가 섞여있으므로 // 코드 수정시 영향이 갈 수 있다. // -&gt; 포함 메서드를 통째로 복붙한 메서드2로 테스트한다. // 대신 테스트할 메서드2 public static int splitAndSum2(final String text) { if (text == null || text.isEmpty()) { return 0; } return sum(split(text)); } . | 메서드2로 테스트하는 테스트메서드를 생성한다. . 기존 null테스트에서 인자 + expected(나와야할 값) + 복붙한 메서드2()로 이름 바꾸기 | . //splitAndSum2 를 테스트 @Test void splitAndSum_emtpy() { final int actual = StringCalculator.splitAndSum2(&quot;&quot;); assertThat(actual).isEqualTo(0); } . | 테스트가 완료되면 수정된 일부 코드만 기존함수에 반영하고, 222메서드랑 테스트는 날린다. . if (text == null || text.isEmpty()) . | . | . 그외 . assertThat()을 여러게 사용하지마라 -&gt; 테스트를 그만큼 만들다보면 일반화 혹온 @ParameterizedTest활용 | . | 테스트메서드는 영어로 대충 짓고 -&gt; @DisplayName()으로 한글을 제대로 적어주자. | private함수를 Test에 복붙해서 테스트하는 것외에 접근제어자를 지워 default로 만들어서 테스트할 수 도 있다. | 메서드명은 snake_Case를 써도 된다. | . 상수화 네이밍 . 검증시 if ~ thr로직 -&gt; checkXXXX . | index들 -&gt; CASE_CASE2_INDEX / 구분자 -&gt; CASE_CASE2_DELIMITER . if (text.startsWith(&quot;//&quot;)){ String[] splitValues = text.split(&quot; n&quot;); String delimiter = splitValues[0].substring(2); String customText = splitValues[1]; return customText.split(delimiter); } if (text.startsWith(CUSTOM_PREFIX)){ String[] splitValues = text.split(CUSTOM_DELIMITER); String delimiter = splitValues[CUSTOM_DELIMITER_INDEX].substring(CUSTOM_PREFIX.length()); String customText = splitValues[CUSTOM_TEXT_INDEX]; return customText.split(delimiter); } . | 특정문자열 다음에 나오는 문자열 추출 -&gt; substring( 특정문자열.length() ) . 예를 들어, “//;”에서 ;를 추출하고 싶다면? | ”//;”.substring( “//”.length()) text.substring( CUSTOM_DELIMITER_PREFIX.length() ) | . | . | assert문을 여러개하지말고, 테스트를 추가하다보면, 일반화할 수 밖에 없다. . | . 강타입 vs 약타입 . 강타입 : 자료형이 맞지 않을 시에 에러 발생, 암묵적 변환을 지원하지 않음 | 약타입 : 자료형이 맞지 않을 시에 암묵적으로 타입을 변환하는 언어 | . 정적타입 vs 동적타입 . 정적타입 언어 : 정적타입 언어는 컴파일 시에 변수의 타입이 결정되는 언어를 의미한다. | 동적타입 언어 : 동적타입 언어는 런타임 시 자료형이 결정되는 언어를 의미한다. | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/12/TDD-%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%84%EC%82%B0%EA%B8%B0_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/12/TDD-%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%84%EC%82%B0%EA%B8%B0_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Feb 12, 2022"
        }
        
    
  
    
        ,"post19": {
            "title": "전략,팩토리,싱글톤,hasNext,isEmpty",
            "content": "전략패턴 for 대체를 [테스트에서 상수]로 . 전략패턴은 전략을 사용자가 선택해서 상황에 맞는 행동을 하게 할때 주로 사용 필요시 다른 환율적용한 계산 반영 | 해쉬값 생성시 알고리즘을 다르게 적용 | 다른 적용 전략으로서 [랜덤값 포함 조건문] -&gt; [()- &gt; true] 테스트에 적용 여기서는 랜덤값을 -&gt; 테스트용 상수로 적용하기 위해서, 랜덤값 포함 조건문에 전략패턴을 건다 | . | 예시 코드 블로그(노션) | . | . 바뀔 수 있는 부분을 잡아서 상태에 맞게 메소드로 추출해놓는다. . 해당메소드는 인터페이스 impl 구상클래스로 갈 것이다. . public void move() { if( Util.generateRandomNumber() &gt;= 4 ){ this.position++; } } . public void move() { if(isMovable()){ this.position++; } } private boolean isMovable() { return Util.generateRandomNumber() &gt;= 4; } . | . | 인터페이스 XXXXStrategy + 이름만 가진 추상메서드를 만든다. . 랜덤한 조건문이 -&gt; 테스트용으로 대체될 예정이라면 -&gt; boolean등 반환형 + 추출한 메서드를 추상메서드로 이름만 정의한다 | . public interface MoveConditionStrategy { boolean isMovable(); } . | 특정Strategy의 이름을 정해서 impl구상클래스를 추출메소드를 복붙해서 구현한다. . public class RandomMoveConditionStrategy implements MoveConditionStrategy{ @Override public boolean isMovable() { return false; } } . public class RandomMoveConditionStrategy implements MoveConditionStrategy{ @Override public boolean isMovable() { return Util.generateRandomNumber() &gt;= 4; } } . | 특정전략의 메소드가 사용된 곳마다 —&gt; 다른전략을 허용하는 추상화된 인터페이스 객체를 인자로 받은 뒤 -&gt; 추상체.추출메소드()호출로 수정한다. . public void move() { if(isMovable()){ this.position++; } } . public void move(MoveConditionStrategy moveConditionStrategy) { if(moveConditionStrategy.isMovable()){ this.position++; } } . | 이제 에러난 부분을 타고가면서, 내부 매개변수 정의에 사용된 추상 인자를 호출하는 외부 인자 자리에 new 특정전략()를 넣워준다. . 여기서는 매 car마다 랜덤 전략이 각각 적용되어야하는 부분 -&gt; 특정전략을 인자로 넣어준다. | . public void move() { this.cars.forEach(car -&gt; car.move()); } . public void move() { this.cars.forEach(car -&gt; car.move(new RandomMoveConditionStrategy())); } . | 테스트에서 다른전략으로 조건부의 상수인 람다함수로 () -&gt; true를 대입하여 움직임을 확인한다. . 랜덤이 섞인 기능은 테스트하기 힘들다 -&gt; 전략자리로 바꿔서 항상 같은 값인 상수를 들어가게해서 다른 기능을 테스트한다. | . @Test void 자동차_움직임() { Car js = Car.of(&quot;js&quot;); // +1 움직임의 조건부를 &lt;다른전략 사용가능한 전략패턴&gt;으로 정의했으니 -&gt; 특정전략을 넘겨 결정한다. RandomMoveConditionStrategy randomMoveConditionStrategy = new RandomMoveConditionStrategy(); js.move(randomMoveConditionStrategy); js.move(randomMoveConditionStrategy); js.move(randomMoveConditionStrategy); js.printPosition(); // 전략자리-랜덤조건부 대신&gt; [다른전략으로서 람다함수 상수로서 true]로 줘버릴 수 있다. // -&gt; 테스트용으로 항상 움직임을 확인할 수 있다. Car jk = Car.of(&quot;jk&quot;); jk.move( () -&gt; true); jk.move( () -&gt; true); jk.move( () -&gt; true); jk.printPosition(); } js의 위치: 0 jk의 위치: 3 . | 정적 팩토리 메소드 네이밍 컨벤션 . from: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메소드 ex) Date d = Date.from(instant); | Of: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메소드 ex) Set faceCards = EnumSet.of(JACK, QUEEN, KING); | valueOf: from과 of의 더 자세한 버전 ex) BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);; | instance 혹은 getInstance: 매게변수를 받는다면 매게변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다. ex) StackWalker luke = StackWalker,getInstance(options); | create 혹은 newInstance: instance 혹은 getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장한다. . | 참고: 생성자내부에서만 this.필드 = 할당이 가능함. 팩토리 메서드는 변환or검증만 | . 싱글톤 패턴(관리자Machine, InputView스캐너) . //1. class내부에 default생성자로 static finale 객체를 미리 생성해놓는다 -&gt; for getInstance시 반환할 수 있게 미리 생성 private static final $CLASS_NAME$ $VALUE_NAME$ = new $CLASS_NAME$(); //2. 차후 입력시, 싱글톤이 받아서 [관리하는 데이터]를 쌓아둔다. //private Cars cars; //3. 싱글톤 private생성자는 미리 생성해야해서 매개변수 없이 default생성자로 만든다. private $CLASS_NAME$() { } //4. 관리자로서 [관리 데이터]를 매 구동시 초기화 할 수 있게 한다. public void init() { // this.cars = new ArrayList&lt;&gt;(); } //5. 싱글톤은 언제든지 부르면 나갈 수 있게 public static getInstance()메소드르 ㄹ정의한다. public static $CLASS_NAME$ getInstance() { return $VALUE_NAME$; } . //1. class 내부에 default? 생성자로 미리 static final 객체 생성 private static final Scanner scanner = new Scanner(System.in); //2. 싱글톤scanner(getInstance) + .nextLine() &gt; getInput()으로 싱글톤 + 메서드까지 사용 public static String getInput() { return scanner.nextLine(); } . 값객체.hasNext()패턴 . if 남은수 0보다 큰지 물어본다 0보다 크면 1빠진 값객체로 재할당받고 | true를 return해서 바깥 반복문이 계속 돌아가게 한다. | . | 남은수가 0보다 같거나 작으면 false를 return해서 바깥 반복문에 진입을 막는다. | . | public boolean hasNextGame() { if (this.gameCount.moreThanZero()){ this.gameCount = this.gameCount.next(); return true; } return false; } //... public boolean hasNextGame() { return count &gt; 0; } public Count next() { return new Count(this.count - 1); } . isEmpty &lt; isBlank . isEmpy: &quot;&quot;의 빈값 | isBlank: &quot;&quot;를 포함하여 &quot; &quot;까지 다 True되는 넓은 범위 | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/11/%EC%A0%84%EB%9E%B5,-%ED%8C%A9%ED%86%A0%EB%A6%AC,-%EC%8B%B1%EA%B8%80%ED%86%A4,-hasNext,isEmpty.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/11/%EC%A0%84%EB%9E%B5,-%ED%8C%A9%ED%86%A0%EB%A6%AC,-%EC%8B%B1%EA%B8%80%ED%86%A4,-hasNext,isEmpty.html",
            "date": " • Feb 11, 2022"
        }
        
    
  
    
        ,"post20": {
            "title": "DTO와 VO를 비교",
            "content": "DTO vs VO . 참고 사이트 테크톡1 | 테크톡2(인비) | 포모 블로그 | . | . 혼용 사례 . 특정 책 1판에 의해서 사람들이 잘못 인지하게 됨. 지금은 데이터 전달은 TO + Data -&gt; DTO로만 사용 | VO = 값 표현용 | . | . DTO(Data Transfer Object) . DTO는 프로세스 간에 데이터를 전달하는 객체 | 주로 비동기 처리를 해야할 때 사용 | 로직을 갖고 있지 않은 순수한 데이터 전달객체라 setter(보내는쪽)/getter(받는쪽)로만 구성되는데, DB에서 값을 받아오므로 setter가 없이. 생성자에서 값할당한 이후 끝. . | 정확히는 계층간 데이터 전달 객체 Controller(웹)와 Service(서비스)사이에 데이터 전달용으로 사용된다. | . | . 예시를 통한 DTO 학습(CrewDto) . . service layer에서 데이터를 보낼 때 (받는 쪽에서 사용하라고 정의만) . createXXX()메서드를 통해 DTO생성 + Dto에 정의한 setter()로 데이터 박아로 데이터전달`을 수행한다. | . | controllerlayer(웹 레이어)에서 데이터를 받을 땐 . **service에 정의해둔 createXXX()메서드를 통해 -&gt; ** 데이터박힌 DTO 생성 | DTO.getter로 데이터들 받기 | . | . | setter를 제거하고 생성자로만 데이터를 받아 생성된 불변의 DTO주도록 수정 . setter를 삭제한다 -&gt; VO처럼 불변객체가 됨 -&gt; 데이터 전달과정 시 불변성 보장 -&gt; 안정적 | . . | . Entity와 분리 . . View는 요구사항에 의해 자주 변경되는 부분이다. entity기준으로 테이블 생성/ 스키마변경하는 class -&gt; 요청/응닶값 전달 클래스로 사용하지 말 것 view변경시마다 entity도 매번 변경해야함. | 관련된 수많은 비지니스 로직(class)들이 영향을 끼치게 됨. | . | view변경에 따라 -&gt; 다른 class에 영향을 끼치지 않는 DTO class를 요청/응답값에 사용 join한 결과값 조회 -&gt; entity로는 다 표현X | . | . | . 예시(로또, Car 정의) . 예시 - 로또 . | 예시 - Car . class CarDTO { private String name; private int position; } . 생성이후 OutputView로 가공된 DTO 객체를 보내줄 수 있습니다. | . | . 특징 . 데이터 접근 메서드만 가진다. | 정렬과 직렬화 메서드는 가질 수 있다. | 데이터 캡슐화 -&gt; 유연하게 대응된다. 데이터 요청수 감소 효과 | . | VO(Value Object) . 값 객체 | VO의 핵심은 equals()와 hashcode()를 오버라이딩하하여 내부에 선언된 속성(필드)의 모든 값들이 같으면 &gt; 똑같은 객체라고 판단하게 한다 | 원시 값을 감싼다 -&gt; validation이 가장 큰 역할 중 하나 my) 식별자로 접근해야 데이터 변화에 대응한다 | . | . 예시를 통한 VO 학습(Money) . 고유번호 = 내부 값이 같으면 -&gt; 같은 객체 . | Money class . . VO는 값 자체 표현 = DTO처럼 불변 객체 DTO처럼, setter성격의 메소드 X 생성자로서만 초기화 | VO는 DTO와 달리 getter이외에 로직을 포함 ex&gt; getHalfValue | . | . | 일반적인 객체 -&gt; equals비교와 hashCode비교가 불일치로 나온다. . . | 완전한 VO를 위하여 . hashCode()의 return값 비교 -&gt; 같으면 equals()로 한번더 비교 . | 완전한 VO == 객체를 속성값으로만 비교하게 하기 위해 -&gt; 2개 메소드 오버라이딩 . 속성값인 value로만 비교할 수 있게 된다. | . . | . | . 예시(Car) . Car - 움직임이 있다면( 내부 속성이 변함) -&gt; new 새로운 객체로 반환하여 -&gt; 원래 자기가 가지던 값은 변하지 않고 -&gt; 변한 것은 다른 값 객체로 취급 . 내부속성 변화가 없다면 (움직이지않았다면) -&gt; 자기자신 반환 return this; | . public Car move(int randomNum) { if (randomNum &gt;= MOVE_POINT) { return new Car(this.name, position+1) } return this; } . | . 특징 . 값 자체로 의미를 가진다. . | 변하지 않는 값을 가진다 . 불변 보장(변하면 새객체)해서 안전성과 생산성 | . | 객체 비교시 ID를 사용하지 않음 . | 같은 객체로는 속성들의 값을 비교한다. . | DTO와 VO공통점과 차이점 . DTO: 레이어간 데이터 전달을 위함 객체 동등비교시, 속성값 같다고 같은 객체 아니다. | setter를 넣어준다면 가변, 보통 불변 | getter/setter외 로직X | . | VO: 값 자체 표현 객체 동등비교시, 속성값 같으면 같은 객체 by 오버라이딩 | setter없이 생성자로 초기화하는 불변 | getter/setter외 로직을 가질 수 있다. | . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/11/DTO-vs-VO(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/11/DTO-vs-VO(%EC%99%84).html",
            "date": " • Feb 11, 2022"
        }
        
    
  
    
        ,"post21": {
            "title": "method refactoring",
            "content": "메소드관련 리팩토링 . . . 01 메서드 추출로 [for indent] 제거 . . indent는 메서드 분리로 해결한다. . . | . 02 early return으로 [else] 제거 . else 제거 by early return . . | . . 03 메서드 분리 -&gt; [일을 1가지씩 순차적으로] . 1가지 일만하도록 메서드 분리 convert(문자열[]-&gt; 숫자[] ) + 누적합sum | . | . . . 보기 좋음 »&gt; 약간의 성능저하 | . 04 로컬변수 제거 -&gt; [ line 줄이기] . . . 05 compose method 패턴 -&gt; [조건문 보기 좋게] . 조건문에 적용: https://wooyaggo.tistory.com/34 | 심화: https://mygumi.tistory.com/343 | . . 조건문을 의도를 가진 메서드로 바꾼다 -&gt; 파라미터의 type이나 조건이 바뀔 때 사용된 조건문을 일괄해서 바꿀 수 있다. | . . 읽기좋게 레벨 맞추기 . . | 비교 . . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/10/method_refactoring(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/10/method_refactoring(%EC%99%84).html",
            "date": " • Feb 10, 2022"
        }
        
    
  
    
        ,"post22": {
            "title": "assertj 및 @annotation 모음",
            "content": "학습 테스트 with Junit5 . 학습테스트: 모듈 사용법 읽히기 -&gt; 다른사람이 만든 코드(api)를 검증 = 학습 테스트 | 단위테스트: 내가 짠 코드를 검증하기 위해 만드는 테스트 단위테스트부터 모든 코드를 설계하는 -&gt; TDD | . | . StringTest . dependency . build.gradle에 assertj추가 -&gt; depenecies run or 우측에 gradle &gt; Reload All Gradle Project . testImplementation &#39;org.assertj:assertj-core:3.22.0&#39; . assertThat()메서드 사용안될 시 . import static org.assertj.core.api.Assertions.*; . | . | assertThat . given(data) -&gt; when(actual값) -&gt; then(expected넣어서 비교) 나눠서 코드를 짠다. . 배열 Test: .contains( ) or .containsExactly() + 콤마로 개별원소 입력 | . @Test void 숫자2개_분리() { //given String data = &quot;1,2&quot;; //when String[] actual = data.split(&quot;,&quot;); //then // assertThat(actual).contains(&quot;1&quot;, &quot;2&quot;); assertThat(actual).containsExactly(&quot;1&quot;, &quot;2&quot;); } @Test void 숫자1개_분리() { //given String data = &quot;1&quot;; //when String[] actual = data.split(&quot;,&quot;); //then // assertThat(actual).contains(&quot;1&quot;, &quot;2&quot;); assertThat(actual).containsExactly(&quot;1&quot;); } @Test void 괄호제거() { String data = &quot;(1,2)&quot;; String actual = data.substring(1, 4); assertThat(actual).isEqualTo(&quot;1,2&quot;); } . | assertThatThrownBy . 지정한 에러가 나타나야 통과 . 에러 내는 테스트는 assertThatThrownBy( () -&gt; {} ).isinstanceof();에다가 예외이름.class를 인자로 줘서 해당 예외일때 통과된다. . **필요하다면, 해당에러 + 에러메세지까지 확인하기 위해 .hasMessageContaining( &quot;메세지&quot; );까지 체이닝한다. ** | . //원하는 에러을 안줬더니... 테스트 통과 못한다. @Test @DisplayName(&quot;문자열 인덱스 에러 테스트1&quot;) void 문자열_인덱스_테스트() { assertThatThrownBy(() -&gt; { &quot;abc&quot;.charAt(4); }).isInstanceOf(IllegalArgumentException.class); } // java.lang.AssertionError: // Expecting actual throwable to be an instance of: // java.lang.IllegalArgumentException // but was: // java.lang.StringIndexOutOfBoundsException: String index out of range: 4 @Test @DisplayName(&quot;문자열 인덱스 에러 테스트2&quot;) void 문자열_인덱스_테스트2() { assertThatThrownBy(() -&gt; { &quot;abc&quot;.charAt(4); }).isInstanceOf(StringIndexOutOfBoundsException.class); } . | assertThatThrownBy + hasMessageContaining . 해당 에러 + 해당 메세지까지 내어야 통과 . 도메인 생성자에 포함된 로직에서 메세지까지 같이 검사하자 | . @DisplayName(&quot;로또 번호가 유효하지 않는 경우 예외를 발생시킨다.&quot;) @ParameterizedTest @ValueSource(strings = {&quot;0&quot;, &quot;46&quot;, &quot;-1&quot;}) void input_lottoNumber_invalid(final String number) { assertThatThrownBy(() -&gt; new LottoNumber(number)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;로또 번호가 유효한 범위&quot;); } . | . 자동차경주 . assertDoesNotThrow . assertThatThrownBy와 달리 에러가 안나야 통과 . @ParameterizedTest @ValueSource(strings = {&quot;o&quot;, &quot;brown&quot;}) @DisplayName(&quot;1이상 5이하의 자동차 이름의 길이 확인&quot;) public void car_name_length_of_positive_name(String name) { assertDoesNotThrow(() -&gt; new Car(name)); } . | . assertThat().isNotNull(); . inputView에서 하는 null or Empty검사시 할 것 같다. | . final Car car = new Car(&quot;재성&quot;); assertThat(car).isNotNull(); . assertThat( service ).extracting(“내부 인스턴스 변수”) . service 내부에 존재하는 일급or객체List를 toDto로 가져오는 반면, VO나 단일 값 변수는 직접 가져와 객체-예상객체 / 값-예상값으로 비교할 수 있다. | . @Test void get_round() { racingService = new RacingService(carNames, 5); //when, then assertThat(racingService).extracting(&quot;round&quot;).isEqualTo(new Round(5)); } . 범위검사 . 값 1개: 랜던뽑기를 여러번 @RepeatedTest(100) + assertThat().isBetween(a,b) 랜덤응답의 범위 검사 . //사용할 객체 만들고 RandomNumberGenerator randomNumberGenerator; @BeforeEach void setUp() { randomNumberGenerator = new RandomNumberGenerator(); } //응답값의 범위 확인을 여러번 @RepeatedTest(100) void range_test() { assertThat(randomNumberGenerator.generate()).isBetween(0, 9); } . 랜덤값 List 원소들 : 매번범위 검사 : listIterator()를 만든 뒤, while( .hasNext() )동안 next()하면서, 체이닝으로 .크거나같(최소값 객체) .작거나같(최대값 객체) . @Test void Random_숫자범위_검사() { // 원래는 랜덤으로 차있는 list -&gt; iterator final ListIterator&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 44, 45).listIterator(); // 랜덤값들을 돌면서 검사 while (numbers.hasNext()) { assertThat(numbers.next()) .isGreaterThanOrEqualTo(1) .isLessThanOrEqualTo(20); } } . SetTest . @BeforeEach . 매번 초기화해야하는 변수는 Test안에서의 class &lt;빈&gt; 변수 + @BeforeEach로 정의한 setUp메소드에서 초기화 + 데이터삽입해준다. . public class SetTest { // [빈 변수] -&gt; 매 TEST마다 초기화+데이터 삽입을 반복해준다. private HashSet&lt;Integer&gt; numbers; @BeforeEach void setUp() { numbers = new HashSet&lt;&gt;(); numbers.add(1); numbers.add(1); numbers.add(2); numbers.add(3); } @Test void 사이즈_확인() { //given, when int size = numbers.size(); //then assertThat(size).isEqualTo(3); } } . | @ParameterizeedTest . @ValueSource . @ParameterizedTest로 중복해서 테스트할 필요없이, given으로 들어갈 메소드인자 or given + expected로 들어갈 메소드 인자들을 지정해서 여러 케이스를 테스트한다. . @ValueSource(ints = {1,2,3,4}) . 한가지 값만 뿌려줄 때 | . @ParameterizedTest @ValueSource(ints = {1,2,3,4}) public void set_contains(int number) { assertThat(numbers.contains(number)).isTrue(); } . | . @CsvSource . @CsvSource(value = {“1:true”, “2:true”, “3:true”, “4:false”}, delimiter = ‘:’) . 여러가지 값 -&gt; 여러개의 인자로 뿌려 줄 때 | delimiter 옵션을 안쓰려면, 그냥 ,콤마로 데이터들을 구분해주면 된다. @CsvSource({“1:,rue”, “2,true”, “3,true”, “4,false”}) | . | . @ParameterizedTest @CsvSource(value = {&quot;1:true&quot;, &quot;2:true&quot;, &quot;3:true&quot;, &quot;4:false&quot;}, delimiter = &#39;:&#39;) void set_contains2(int number, boolean expected) { assertEquals(numbers.contains(number), expected); } . | . @NullAndEmptySource . 테스트 메서드의 인자에다가 @어노테이션으로는 null을 넘길 수 없다. . @NullAndEmptySource를 달아주면, 인자에 1,2번째로 null과 emtpy가 전달된다. | 추가로 @ValueSouce를 주면 3번째 인자로 넘어간다. &quot;이 름&quot;를 주게 되면 blank까지 테스트가 된다. | . | . @ParameterizedTest @NullAndEmptySource @ValueSource(strings = {&quot;이 름&quot;}) void nullAndEmpty_or_blank(String name) { System.out.println(name); assertThatThrownBy(() -&gt; new Car(name)) .isInstanceOf(IllegalArgumentException.class); } . | . 그외 Assertj 메소드 모음 . isEqualTo(obj) obj 와 같다 . isNotEqualTo(obj) | obj 와 다르다 | . isEqualToIgnoringCase(str) | str 와 같다 (대소문자 무시) | . contains(str) | str 를 포함한다 | . containsIgnoringCase(str) | str 를 포함한다 (대소문자 무시) | . doesNotContain(str) | str 를 포함하지 않는다 | . startsWith(str) | str 로 시작한다 | . doesNotStartWith(str) | str 로 시작하지 않는다 | . endsWith(str) | str 로 끝난다 | . doesNotEndWith(str) | str 로 끝나지 않는다 | . matches(regex) | regex 정규식과 같다 | . doesNotMatch(regex) | regex 정규식과 같지 않다 | . isLowerCase(str) | str 은 소문자로 이루어져 있다 | . isUpperCase(str) | str 은 대문자로 이루어져 있다 | . isZero(n) | n 은 0 이다 | . isNotZero(n) | n 은 0 이 아니다 | . isOne(n) | n 은 1 이다 | . isPositive(n) | n 은 양수 이다 | . isNegative(n) | n 은 음수 이다 | . isNotPositive(n) | n 은 양수 또는 0 이다 | . isBetween(start, end) | start 와 end 사이의 값 이다 | . isStrictlyBetween(start, end) | start 와 end 사이의 값이 아니다 | . isCloseTo(n, within 또는 offset) | 주어진 within 또는 offset 에 가까운 값이다. | . isNotCloseTo(n, byLessThan 또는 offset) | 주어진 within 또는 offset 에 가까운 값이 아니다 | . isCloseTo(n, withinPercentage) | 주어진 백분율 내에서 주어진 숫자에 가깝다 | . isNotCloseTo(n, withinPercentage) | 주어진 백분율 내에서 주어진 숫자에 가깝지 않다 | . isTrue() | 참이다 | . isFalse() | 거짓이다 | . isNull() | null 값 이다 | . isNotNull() | null 값 아니다 | . isBlank() | 빈 값 이다 (공백 미포함) | . isNotBlank() | 빈 값 아니다 (공백 미포함) | . isEmpty() | 빈 값 이다 (공백 포함) | . isNotEmpty() | 빈 값 아니다 (공백 미포함) | . isNullOrEmpty() | null 값 이거나 빈 값 이다 (공백 포함) | . isLessThan(str) | str 보다 낮은 문자열 이다 (Ascii 코드) | . isIn(…obj) | 여러개의 obj 중 1개와 같다 | . isNotIn(…obj) | 여러개의 obj 와 모두 다르다 | . filteredOn(…) | list 필터 | . extracting(…) | list 프로퍼티 값 | . assertj string 예제 . assertThat(&quot;Hello, world! Nice to meet you.&quot;) // 주어진 &quot;Hello, world! Nice to meet you.&quot;라는 문자열은 .isNotEmpty() // 비어있지 않고 .contains(&quot;Nice&quot;) // &quot;Nice&quot;를 포함하고 .contains(&quot;world&quot;) // &quot;world&quot;도 포함하고 .doesNotContain(&quot;ZZZ&quot;) // &quot;ZZZ&quot;는 포함하지 않으며 .startsWith(&quot;Hell&quot;) // &quot;Hell&quot;로 시작하고 .endsWith(&quot;u.&quot;) // &quot;u.&quot;로 끝나며 .isEqualTo(&quot;Hello, world! Nice to meet you.&quot;); // &quot;Hello, world! Nice to meet you.&quot;과 일치합니다. . assertj number 예제 . assertThat(3.14d) // 주어진 3.14라는 숫자는 .isPositive() // 양수이고 .isGreaterThan(3) // 3보다 크며 .isLessThan(4) // 4보다 작습니다 .isEqualTo(3, offset(1d)) // 오프셋 1 기준으로 3과 같고 .isEqualTo(3.1, offset(0.1d)) // 오프셋 0.1 기준으로 3.1과 같으며 .isEqualTo(3.14); // 오프셋 없이는 3.14와 같습니다 .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%ED%85%8C%EC%8A%A4%ED%8A%B8/assertj/tdd/2022/02/10/assertj-%EB%B0%8F-annotation-%EB%AA%A8%EC%9D%8C.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%ED%85%8C%EC%8A%A4%ED%8A%B8/assertj/tdd/2022/02/10/assertj-%EB%B0%8F-annotation-%EB%AA%A8%EC%9D%8C.html",
            "date": " • Feb 10, 2022"
        }
        
    
  
    
        ,"post23": {
            "title": "코드리뷰 방법 1단계 및 피드백",
            "content": "개별 셋팅 . 관리자 짝 매칭 실시 . 관리자 매칭 실시 . | 피매칭자은 확인함. . | . 원본레포에 각 github_id br 생성 . lecture클릭후 미션시작 클릭시 -&gt; 자동으로 내 github_id로 —&gt; 미션repo에 브랜치생성 | 미션시작으로 내 브랜치를 생성하면, 리뷰어도 자동 배정된다. ) 동시성 잇슈가 있을 땐, 관리자가 리뷰어를 재배정한다. | . | 저장소로 와서 내 github_id로 생성된 branch가 정상 생성되었는지 미션repo에 branch 검색해서 확인한다 . . | 원본레포 각 fork . 강의홈페이지를 통해 branch가 생성되었으나 팀원X push권한 X -&gt; fork를 먼저 한다. 문서를 보면서 스텝바이스텝으로 한다. | 여기선 1단계까지만 한다. 코드리뷰 요청 1단계: 미션 진행 후 github에 올리는 단계 | 코드리뷰 요청 2단계: 코드리뷰 요청을 보내고, 피드백을 받은 후 피드백 반영 및 merge하는 단계 | 코드리뷰 요청 3단계: 다음 단계 미션을 위해 준비하는 단계 | . | 이렇게 권한은 없지만 [강의홈페이지를 통한 원본repo에 이름만 내 github_id branch]가 생성된 상태로 -&gt; fork한다. fork가 내 계정으로 잘되어있어야한다 | . | fork를 해도 기존 원본repo의 모든 branch들이 다 fork되어있다. 기본 main으로 되어있다. | . | github_id single-branch만 clone . fork는 모든 branch그대로 보유 —&gt; clone을 통해서 로컬로 가져올 때는 --single-branch만 가져오는 것이 가능하다. . 현업에서는 10개이내 branch이므로 git clone -b [branch명] --single-branch [fork한 레포명]가 필요가 없다 . | 내 이름의 branch가 main브랜치다. | . git clone -b {본인_아이디} --single-branch https://github.com/{본인_아이디}/{저장소 아이디} ex) git clone -b javajigi --single-branch https://github.com/javajigi/java-baseball.git . git clone -b is2js --single-branch https://github.com/is2js/java-racingcar.git intellij 터미널에서 작업하면 된다. | . | . PS C: Users cho_desktop IdeaProjects missions&gt; git clone -b is2js --single-branch https://github.com/is2js/java- racingcar.git . | ​ - . intellij에서 clone한 폴더를 open한다 내 이름의 싱글브랜치만 가져와지는지 확인한다. | . | step1 br(작업 br) 생성 . git checkout -b step1으로 첫번째 리뷰용 브랜치를 만든다. . –single-branch clone 한 입장에서 , 내 id_branch -&gt; main브랜치 | 작업할 branch -&gt; step1 -&gt; ... . | cf) **git alias는 집착해서 알아야한다.-&gt; ** . gco main = git command . | gba = git branch -a . # windows git alias git config --global alias.co checkout git config --global alias.ci commit git config --global alias.st status git config --global alias.br branch git config --global alias.hist &quot;log --pretty=format:&#39;%h %ad | %s%d [%an]&#39; --graph --date=short&quot; git config --global alias.type &#39;cat-file -t&#39; git config --global alias.dump &#39;cat-file -p&#39; # shell git alias alias gs=&#39;git status &#39; alias ga=&#39;git add &#39; alias gb=&#39;git branch &#39; alias gc=&#39;git commit&#39; alias gd=&#39;git diff&#39; alias gco=&#39;git checkout &#39; alias gk=&#39;gitk --all&amp;&#39; alias gx=&#39;gitx --all&#39; alias got=&#39;git &#39; alias get=&#39;git &#39; . | . | . . | 협업 시작 (A와 B) . 일단 github_id가 local에의 user.name과 동일한지 확인한다. . git config user.name . | . . 작업레포(local, A) 정하기 . 페어와 CodeWithMe등으로 작업할 local 레포 정하기 . 나의 경우, 네트워크 잇슈로 화면공유 + B를 colaborator 등록하여 B가 local에 step1만 --single-branch clone후 서로 push &amp;&amp; pull 해서 작성함. . git clone -b step1 --single-branch [git주소] [폴더명 or .] . | . | 작업을 완료한 뒤 push까지 끝낸다. . | . A fork레포(remote 2) -&gt; B local레포 . 협업해서 push된 [A 원격레포-step1]를 2번째 remote repo로 등록한다. . 1번째는 fork한 나(B)의 원격레포 . | 2번째는 fork한 A의 원격레포 . git remote add pair&lt;원격레포별칭&gt; &lt;Repo URL for pairs fork&gt; git remote -v . origin: 원격 저장소를 가리키는 일반적인 별칭 | pair: 내가 정한 추가 원격 레포의 별칭 | . | . | A 원격레포(remote pair)의 step1(협업했던br)의 내용만 fetch해온다. . A pair repo -&gt; B local repo 우리는 pull을 해버렸다. pull할때마다 merge로 표기되니 조심. | . | git fetch : 다른 사람의 branch의 내용을 가져와 확인한 뒤 (나중에) merge 하고 싶을때 fetch를 사용 | 아직 merge는 하지 않았기 때문에 인텔리제이에 가져온 코드들이 보이진 않을 것이다. | . git fetch pair step1 . 안되면 git fetch pair/step1 | . | fetch로 내역들을 확인했으면 merge한다. . git merge pair step1 . 안되면 git merge pair/step1 | . | A fork레포(remote2) -&gt; B fork레포(remote1) . 정보를 줄 pair(remote2)의 협업br(step1)로 HEAD 이동시켜놓기 . git checkout pair&lt;원격레포별칭&gt;/step1&lt;협업br&gt; . | 정보를 받을 origin(remote1)의 협업br(step1)으로 push하기 . A pair repo -&gt; B remote repo remote —&gt; remote로 commit내역을 넘기나보다. | fetch -&gt; merge로 local에 가져왔다면, 원격에서 원격으로 한번더 가져오나보다. | . | . git push --force origin step1 . | 사실… B local -&gt; B fork로 가는게 맞다? . 동기 크루 중 1분의 블로그 git remote add pair url | git fetch pair step1 | git merge pair step1 | git push origin step1 | . | . 코드리뷰 요청 . 페어 끊기 . 우테코 홈피 -&gt; 나의팀 -&gt; 피드백을 누르면 페어가 끊어진다. 페어가 끊어져야 리뷰요청이 활성화된다?! | . | forkRepo -&gt; 원본Repo PR (리뷰요청) . 내 fork 원격레포 의 step1 br로 이동한 뒤, 원본(미션)repo로 PR를 누른다. PR을 통한 코드리뷰는 fork레포- 작업br(step1)에서 PR을 걸어 -&gt; 원본레포의 나와관련된 br(is2js)에 요청하는 것 | fork레포의 관련br(is2js)가 아닌 것에 주의하자. | . | PR 받는 곳 원본레포: base repository - is2js(관련 br) | PR 보내는 곳 fork레포: head repository - step1(작업br) branch를 잘 선택해야한다. | . | . | PR메세지까지 다 작성해서 제출한다. | 홈피-&gt;slack에 리뷰요청 알림 . 우측 상단에 리뷰요청 . | slack으로 메세지 전달 . . | slack-&gt;피드백 알림 -&gt; 로컬수정 -&gt; PUSH로 피드백반영 -&gt; 홈피 리뷰요청2 . 슬랙으로 피드백 반영해달라고 알림이 온다 날렸던 PR에 그대로 코드리뷰가 반영되어있다. | . | local에서 step1 br로 수정한다. | local step1 -&gt; remote step1 PUSH 하는 순간 피드백 반영되므로 조심하자. 추가 PR은 필요 없다. | . | push로 피드백 반영이 끝났으면 우테코 학습 홈피 -&gt; 우측상단 리뷰요청 -&gt; 리뷰요청 -&gt; slack메세지 | 리뷰어가 피드백을 보고 merge해줄 것이다. 그럼 다음 단계로 진행하면 된다. |",
            "url": "blog.chojaeseong.com/git/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%ED%98%91%EC%97%85/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/09/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-1%EB%8B%A8%EA%B3%84-%EB%B0%8F-%ED%94%BC%EB%93%9C%EB%B0%B1(%EC%99%84).html",
            "relUrl": "/git/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%ED%98%91%EC%97%85/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/09/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-1%EB%8B%A8%EA%B3%84-%EB%B0%8F-%ED%94%BC%EB%93%9C%EB%B0%B1(%EC%99%84).html",
            "date": " • Feb 9, 2022"
        }
        
    
  
    
        ,"post24": {
            "title": "fastpages font & tag page change",
            "content": "font 바꾸기 . 참고: 한국 블로그 | . _includes폴더 &gt; head.html파일에서 웹 폰트 link태그 추가해주기 . &lt;!-- 폰트추가를 위한 link태그 삽입 --&gt; &lt;!-- 폰트1: 기본 spoqa 웹폰트 --&gt; &lt;!-- css에서 * {} 다 뒤집어씀. --&gt; &lt;link href=&#39;//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSansNeo.css&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&gt; &lt;!-- 폰트2: 블로그 제목들 sunflower 웹폰트 --&gt; &lt;!-- 쥬피터 등 포스트 내부 글자 h1, h2 제목은 sunflower체 도입 --&gt; &lt;link href=&quot;//fonts.googleapis.com/css?family=Sunflower:300,500,700&quot; rel=&quot;stylesheet&quot;&gt; . | 해당 폰트를 사용하기 위해 assets폴더 &gt; css폴더 &gt; styles.css를 수정한다 나의 경우, scss수정시 잘 안됬다. 모든 것을 여기서 설정해줬다. | font-family 검색해서 모두 font-family: &#39;Spoqa Han Sans Neo&#39;, normal;로 바꿔주기 | 전역으로 다 먹이기 + 제목들은 다른 글자체로 먹이기 /* 제목들은 먹히는데, 제목만쓰질 않으니.. */ /* test-&gt; 전체를 font-familty 덮어쓰기 */ *{ font-family:&#39;Spoqa Han Sans Neo&#39;, normal!important; } /* font2 제목 글자는 선플라워 */ h1, h2, h3, h4, h5, h6, tag-name { font-family:&quot;Sunflower&quot;, normal!important; color: #152447; } . | . | a태그 리셋시켜서 색 적용되게 하기 /** Links */ /** 폰트 색 (링크 색) -&gt; 이것만 바꾼다고 변경안됨.. */ /* 모든 a태그 프로퍼티들을 리셋 */ a { all: unset; } /* a태그의 가상클래스도 같이 리셋 */ a:link { text-decoration: none; color: #152447; } a:visited { text-decoration: none; color: #152447; } /* 누른상태 */ a:active { text-decoration: none; color: #152447; } /* 갖다덴 상태 */ a:hover { text-decoration: none; color: #152447; } a { color: #152447; text-decoration: none; } a:visited { color: #152447; } a:hover { color: #313266; text-decoration: underline; } . | 마크다운 강조색을 빨간색 글자로 변경 pre, code { font-family: &#39;Spoqa Han Sans Neo&#39;, &quot;Menlo&quot;, &quot;Inconsolata&quot;, &quot;Consolas&quot;, &quot;Roboto Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; font-size: 0.9375em; border: 1px solid #f9f2f4; border-radius: 3px; background-color: #f9f2f4; color:#E53A40;} . | tags.html 수정하기 . 예전 블로그의 css를 가져와 적용할 준비를 한다. style.css /** 예전 블로그에서 쓰던 tag모음 + 각 개별tag적용 css */ .entry-meta { font-size: 12px; font-size: 0.75rem; text-transform: uppercase; color: #152447; } .entry-meta a { color: #152447; } .entry-meta .vcard:before { content: &quot; by &quot;; } .entry-meta .tag { display: inline-block; margin: 4px; color: #fff; border-radius: 3px; background-color: rgba(162, 162, 162, 0.8); } /*my) 상단 태그들 모음 tag1 shap(#) */ .entry-meta .tag span { float: left; padding: 6px 6px; color: #152447; font-family: inherit; /* background-color: #ffffff; */ } /*my) 상단 태그들의 tag2 name(태그명) 색*/ .entry-meta .tag .tag-name { color: #ffffff; background-color: #152447; border-radius: 0 3px 3px 0; /*3px 이상 오그리면, 하이퍼링크랑 막 난리남.*/ } .entry-meta .tag:hover { background-color: rgba(136, 136, 136, 0.8); } .entry-meta .entry-reading-time { float: right; } .inline-list { list-style: none; margin-left: 0; padding-left: 0; } .inline-list li { list-style-type: none; display: inline; } /* 추가) 각 제목들도 tag 작은모양처럼*/ .eachtag { color: #ffffff; background-color: #152447; border-radius: 0 3px 3px 0; } . | tags.html코드를 수정한다. ul태그에 entry-meta inline-list 속성을 추가한다 | 그외 tag, tag-name, eachtag 등의 속성을 이용해서 꾸민다. | . &lt;ul class=&quot;entry-meta inline-list&quot;&gt; &lt;/ul&gt; . |",
            "url": "blog.chojaeseong.com/fastpages/2022/02/09/fastpages-font-&-tags-page-change.html",
            "relUrl": "/fastpages/2022/02/09/fastpages-font-&-tags-page-change.html",
            "date": " • Feb 9, 2022"
        }
        
    
  
    
        ,"post25": {
            "title": "fastpages post preview setting",
            "content": "fast pages 메인에서 preview image 보이게 하기 . 참고: 이미지를 표기하는 fastpages | . _config.yml에서 show_image: false -&gt; true로 변경 . | 미리캔버스를 검색해서 템플릿으로 생성할 이미지 만들기 참고 블로그 | 생성 목록 algo.png | blog.png | config.png | data.png | default.png | git.png | java.png | python.png | sql.png | wootech.png | . | . | 최상단 images폴더 &gt; posts폴더에 이미지들 넣어두기 . | post마다 image: &quot;images/posts/blog.png&quot;형식으로 preview 이미지 설정하기 메인 위쪽은 index.html | 메인 아래쪽 포스트 담당은 home.html이다 | . _config.yml에서 show.image: true일 경우 post_list.html(글만) -&gt; post_list_image_card.html로 바뀌어서 보인다. | . | . |",
            "url": "blog.chojaeseong.com/fastpages/2022/02/08/fastpages-post-preview-setting.html",
            "relUrl": "/fastpages/2022/02/08/fastpages-post-preview-setting.html",
            "date": " • Feb 8, 2022"
        }
        
    
  
    
        ,"post26": {
            "title": "TDD 기본 싸이클 작성",
            "content": "TDD 싸이클 . TDD 구현 싸이클 fail떨어지는 test코드 생성 case별로 메서드_이름을 표기하여 작성한다. | . | main(프로덕션)코드 작성 후 pass 2번째부터는 개별 pass -&gt; 전체pass 순으로 확인 | . | refactoring(rename부터 시작) | | . | . test에서 package &gt; XXXTest class를 먼저 만든다. . . generate(alt+insert)기능으로 @test로 생성 . | 메서드_명은 한글명으로 해도 되고, 단위테스트가 의미하는 바만 잘 나타내면된다. 여기선 여러 경우 중 1가지(구분자 없는) 경우로 시작을 한다. . | . . | 클래스명 + 메소드명을 먼저 사용하여 할당을 반환형 actual변수로 받은 뒤 given(값 -&gt; 변수 선언 등) -&gt; when(actual까지 로직) -&gt; then( asesertThat(actual).isEqualTo(expected)) . // given String data = &quot;(1,2)&quot;; // when String result = data.substring(1, data.length()-1); // then assertThat(result).isEqualTo(&quot;1,2&quot;); . | . | assertThat( actual ).isEqualTo( )에서 인자에 예상값(우리가 원하는 값)을 넣는다. . | SC 없는 클래스를 만들 되, 미리 main쪽에 package를 만들어 놓은 상태에서 -&gt; 생성경로를 main으로 바꿔준다. . test &gt; package &gt; XXXTest class | 내부 XXX클래스.메서드() —&gt; main &gt; package &gt; XXX class로 생성 | test에만 존재하는 package를 선택하면, main에 못만드니 미리 만들어놔야한다. | . | **클래스 생성 직후 바로 돌아와(Back기능 ctrl+u) method도 만들어준다 ** . 이 때, actual(1)을 반환하지 않는 불완전한 메소드를 수정없이 test실행부터해서 Error를 낸다 . . | . | test코드(SCTest)가 pass하도록 프로덕션코드(main코드, SC)를 수정한다. . . | pass한 프로덕션 메소드를 refactoring한다. . 파라미터 이름 바꾸는 것도 F2 = refactoring | @test 막 사용했던 class이름(XXX) 바꾸는 것도 F2 = refactoring 이 때, test class이름 XXXTest도 바꾸자고 권유한다. | . | . | 더이상 refactoring할게 없다면 -&gt; 새로운 단위테스트를 클래스.메소드()부터 만들어서 나아간다. . 직전에 만든 테코랑 비슷하다면, 복붙해서 시작한다. . | 테케는 가능한 가장 작은 단위를 만드는 경우며, 케이스 -&gt; if 상황별 새로운 메소드로 나누고 -&gt; 상황에 맞게 인자 변경 -&gt; expected . 구분자 없음 -&gt; “1” -&gt; 1 | 컴마 구분자 -&gt; “1,2” -&gt; 3 | . . | . | 다음 테케도 프로덕션 코드 수정없이 일단 돌려서 fail을 떨어뜨린 뒤-&gt; 에러보고 참고하여 찾아가서 수정 . | 해당 테케실행 -&gt; 전체 테케도 실행해서 전체 통과하는지 확인을 한다. . | pass후엔 refactoring하기 . for문으로 들어가는 indent -&gt; 메소드 추출 refactoring . return문까지 잡아서 추출해보기(alt+ctrl+m -&gt; 안되면 ctrl+.) . . | . | . | input/output이 명확한 쉬운 TDD였다. . 자동차 경주를 하려면, 너무 힘들 것 | 단위테스트만 만들어서 해볼 것 | fail하는 test생성 -&gt; 프로덕션수정으로 pass -&gt; refactoring | . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/08/TDD%EC%8B%B8%EC%9D%B4%ED%81%B4(%EB%8D%A7%EC%85%88%EA%B3%84%EC%82%B0%EA%B8%B0)(%EC%99%842).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/08/TDD%EC%8B%B8%EC%9D%B4%ED%81%B4(%EB%8D%A7%EC%85%88%EA%B3%84%EC%82%B0%EA%B8%B0)(%EC%99%842).html",
            "date": " • Feb 8, 2022"
        }
        
    
  
    
        ,"post27": {
            "title": "우테코 프리코스 3주간 요구사항들",
            "content": "요구사항 체크리스트 모음 . 1주차 . 자바의 버전이 8버전인가 | 자바 코드 컨벤션을 지키는가 | Randoms의 pickNumberInRange()를 사용했는가 (3주차) pickNumberInList()를 사용했는가 | . | Console의 readLine()을 사용했는가 | 3항 연산자를 쓰지 않는가 | indent depth가 2이하인가 | 하나의 함수가 한 가지 일만 하도록 하였는가 | (추가) 하드코딩 하진 않았는가 | (추가) style check 및 convention 적용 하였는가 | gradlew.bat clean test의 모든 테스트가 통과하는가 | 과제 제출시 우테코 플랫폼에서도 제출하였는가 | . 2주차(피드백 및 과제에서 추가) . 함수(또는 메소드)의 길이가 15라인을 넘어가지 않도록 구현한다. | else 예약어를 쓰지 않는다 . | 기능 목록을 업데이트하고 재검토 한다 | Class 구현순서( 상수-&gt;멤버 변수-&gt;생성자-&gt;메서드) 지키기 | . 3주차 . 기능 목록에 예외상황도 기록한다. | 일급컬랙션 및 단일변수도 포장한다. | 변수를 줄이려고 노력한다. | . 주차별 미션 수행 키포인트 정리 . 1주차 과제 수행시 키포인트 . 개발 시작전에 요구사항 충분히 파악하기 | 기본 프로젝트 구조 및 뼈대 코드 작성하고 시작하기 | 라이브러리 확인 및 컨벤션 포맷터 적용, 버전 확인 등 기본적인 협업환경 확인하기 | Application에 개발하지 않고 각 class에서 개발하여 구동하기 | scanner 등 input, outview은 static으로 작성해서 재활용하기 | 문자열type의 숫자입력시 검증 여러가지 해보기(길이-&gt; 포맷-&gt; 범위-&gt; 중복여부 등 기타) | else 안쓰고, 반복문안에 if는 method로 빼서 method내에서 하여 indent줄이기 | 무한반복시 조건변수를 결과로 업데이트 하면 됬으나, 재시작 등 추가분기가 필요한 경우, status변수 추가 도입하기 | 상수도 반복되니 따로 class로 빼기 | 중복확인은 list길이로 하는 데, stream으로 편하게 하기 list 중복확인 : list.stream().distinct().count() | 입력받은 문자열배열 -&gt; 정수 list변환 : Arrays.stream(). mapToint(Integer::parseInt).boxed().collect(Collectors.toList()); | . | . 2주차 과제 수행시 키포인트 . Live template을 활용함. 1주차와 반복되는 input코드 등을 미리 작성해둠. | . | fork한 repo를 clone후에 branch부터 바꾸자! 실수로 main브랜치에 commit and push하여 새로 작성하는 경우가 발생했었음. | . | 일급컬렉션 사용하여 객체List에 대한 검증 및 관련 로직을 모음. 쪼개어지는 Input을 받을 때 ex&gt; Names -&gt; Name 미리 names에서 검증을 다 해버리는 전략을 세움 | 쪼개어놓고 내부에서 검증할 시, 다시 입력받으러 가기가 쉽지가 않음. | . | 조건절에서 getter쓰지말고, 객체.부등호를메서드화() 시켜 메세지보낼 것. 비교시 필요한 값은 메서드의 파라미터로 | 입력 받은 int 변수를 포장한 래핑클래스를 만들고 countdown 메서드 구현해보기 | 학습했던 stream위주로 코드 짜보기 max( Comparator)를 쓰더라도 1번에 max값을 충족시키는 여러개의 객체를 구하기는 쉽지 않음. | mapToInt( ) 집계값 구한 뒤 -&gt; 일치하는 객체 List(우승자들) 구하는 방식 | 간단한 출력문은 toString()오버라이딩 해서 쉽게 출력되도록 이용 하기 | | 상수들 및 에러 메세지들의 리팩토링 IDE를 이용하면 정말 간단하게 해결할 수 있음을 깨닫게 됨. | . | . 3주차 과제 수행시 키포인트 . 객체의 각 필드에도 wrapping class를 적용함 원시변수 및 if문의 최소화 -&gt; 래핑변수 및 stream의 활용 | . | 정규식 패턴검사에 stream을 활용함 | List대신 Map 자료구조 래핑하여 DB처럼 사용함 상품 정보등은 List를 포장한 일급컬렉션으로 만들어놓고 정보조회시 사용함 | . | 싱글톤 객체를 활용하여 전체 로직을 운영함 controller 반복문의 조건변수도 싱글톤객체에 메세지를 보내니 상태에 따른 값을 얻어와서 구현하기 수월했음 | . | 자판기 작동 로직에 대해 고민하여 기능 구현 목록을 작성함 | .",
            "url": "blog.chojaeseong.com/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/2021/12/15/%EC%9A%B0%ED%85%8C%EC%BD%94%EA%B0%80_%EB%82%98%ED%95%9C%ED%85%8C_%EC%A4%80_%EC%84%A0%EB%AC%BC.html",
            "relUrl": "/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/2021/12/15/%EC%9A%B0%ED%85%8C%EC%BD%94%EA%B0%80_%EB%82%98%ED%95%9C%ED%85%8C_%EC%A4%80_%EC%84%A0%EB%AC%BC.html",
            "date": " • Dec 15, 2021"
        }
        
    
  
    
        ,"post28": {
            "title": "intelliJ 세팅(vscode keymap + 협업 세팅)",
            "content": "vscode keymap 관련 플러그인 설치 . 설정 &gt; Plugin &gt; vscode kemap검색 후 설치 | key Promoter X 설치 (해당 기능의 단축키를 우측하단에 띄워줌) | | . vscode keymap 기준 단축키 정리 . shift 2번 : 전체 검색(유지) vscode F1 | . | keymap 들어가서 move to opposite group검색후 ctrl+shift+ 오른화살표지정하기 ctrl + 이후 넘기기..왼쪽넘기기 기능 자체는 없나보다. | alt+shift+0으로 세로로 넘기기 가능 | . | alt+shift+F : reformat code -&gt; 한파일내 패키지 or 폴더 선택후 alft+shift+F | . | keymap 들어가서 back검색후 ctrl+u지정하기 . | ctrl + .으로 메인메소드 내용을 extract method 메소드 분리 및 패키지명 작성하고 폴더이동시키기 | . | 신세계) alt+insert로 생성자, getter 등 오버라이딩 . | **신세계) 메서드사용을 위한 객체 만들 때(인스턴스화) 할 때, ** new 클래스명(); 기입후 ctrl+.으로 local변수 자동(선택후)생성하자. | 객체.메서드();기입후 ctrl+.으로 메서드결과값 받는 변수 자동(선택후)생성 | . | keymap -&gt; extend line selection -&gt; ctrl+L을 추가해서 사용하기 라인 선택하기 shift+alt+아래화살표로 복사할때,, 라인 선택해서해야.. 꼬임없을 듯 | . | . | shift+ alt+ F10: 실행할 class파일 선택해서 실행 ctrl+alt+F10은 바로 실행. | . | shift + alt + x: 현재 파일들 다 close . | shift + alt + a : 긴글 주석? . | alt + ~ : git관련 명령어들 목록나옴 . | ctrl+F11 or ctrl+shift+{key}로 북마크 지정 -&gt; ctrl+해당번호로 이동 | keymap -&gt; show bookmaks검색후 -&gt; CTRL+SHIFT + F11 으로 지정함 | . | ctrl+f3 : 같은단어 이동가능한 검색한 상태로 만들기 == ctrl+f f3 : 같은 단어 다음으로 이동 | shift+f3 : 같은단어 이전 단어로 이동 | . | shift+F5 : 실행중인 작업 종료 ctrl+F5 : 실행 | shift+ alt + f10 : main함수 골라서 실행 | . | alt+7: 현재파일 Structure(메소드 등) 한눈에 보기 유틸메서드로 빼기, 상수 옮기기 : f6으로 편하게 | . | 리팩토링 alt+ctrl+c : 값을 상수로 등록해버리기 | alt+ctrl+m : 코드를 메서드화 시키기 2번 눌르면 창으로 하는 듯 | . | alt+ctrl+v: new 클래스()까지 입력후 참조변수 바로 생성 | . | 축약어 iter | fori 추가 | itar | ifn | inn | . | F8: 오류바로 찾아가기 | ctrl+f -&gt; F3 or shift + F3 : 검색항목 순서대로 찾아가기 | . 프리코스를 위한 java8 협업 세팅 요약본 . clone후 branch부터 생성후 바꾸기 . git checkout -b is2js . git CRLF -&gt; LF로 바꾸기 설정하기 . git config --global core.autocrlf true . utf 8 설정 . utf8, lf설정 되어있나 확인하기 . editor &gt; File Encodings &gt; 체크 3가지 모두 utf-8 shift 2번연속 클릭 (search everywhere) . vm검색 Edit Custom VM option 클릭 맨 마지막 줄에 -Dfile.encoding=UTF-8 추가 | . | . | . | . | . | build.gradle 설정 추가 . compileJava.options.encoding = &#39;UTF-8&#39; // UTF-8 설정 compileTestJava.options.encoding = &#39;UTF-8&#39; . | . code style 3가지 / Checkstyle / saveActions . code style에서 . scheme지정 | n으로 선택해주기 | detect하도록도 체크함.. | java탭으로 내려가서 &gt; scheme 지정확인 checkstyle에 안걸리게 됨. | . | | Tools &gt; CheckStyle . 8.24이상 버전 (default) . | scope를 All sources(테스트포함, 나는 테스ㅡㅌ제외)로 변경 . | 파일 선택(일부코드 삭제하여 수정한)하여 추가 -&gt; +로 추가 . . | 해당 스타일체크후 alt +shift + k혹은 하단 체크스타일에서 추가한 naver style선택하여두기 . | | 다 풀고 **맽밑 Other settings &gt; Save Actions &gt; 3가지 체크 ** . . | . java8로 통일하기 . 설정&gt; Build&gt; Build Tools &gt; Gradle &gt; intelliJ IDEA + Gradle JVM 1.8로 바꾸기 exception 및 디버깅용으로 gradle 변경하는 것 | . | 설정&gt; Build&gt; Build Tools &gt; Compiler &gt; Java Compiler &gt; javac의 1.8 바꾸기 | 프로젝트구조(c +s + a + s) &gt;Project &gt; Project SDK 및 language level 1.8, 8 선택 | 프로젝트구조(c +s + a + s) &gt; Modules &gt; 랭귀지레벨에서 8버전 맞나 확인하기 | 프로젝트구조(c +s + a + s) &gt; SDKs에서 1.8버전 확인하기 | window intellij에서 gradle clean, test 해보기 . . shift 2번 or f1 -&gt; gradle task선택 gradle clean 수행 | gradle test 수행 코드 다짜고나서 | | |",
            "url": "blog.chojaeseong.com/java/configuration/2021/12/14/java_intellij_keymap.html",
            "relUrl": "/java/configuration/2021/12/14/java_intellij_keymap.html",
            "date": " • Dec 14, 2021"
        }
        
    
  
    
        ,"post29": {
            "title": "코딩테스트용 라이브러리 정리",
            "content": "참고 벨로그 | justkode | . | . 표준라이브러리 6가지 . 내장함수 . sum, min, max, eval, sorted(key=, reverse=) . result = eval(&quot;(3 + 5) * 7&quot;) print(result) . | . itertools . 반복되는 형태의 데이터를 처리하는 기능을 제공, 순열과 조합 라이브러리르 제공 . permutations(r개의 데이터를 뽑아 나열하는 모든 경우(순열)) . | combinations(r개의 데이터를 뽑아 순서를 고려하지 않고 나열하는 모든 경우(조합)) . | products(r개의 데이터를 뽑아 일렬로 나열하는 모든 경우(순열)를 계산한다. 다만 원소를 중복하여 뽑는다.) . from itertools import product data = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] # 데이터 준비 result = list(product(data, repeat=2)) # 2개를 뽑는 모든 순열 구하기(중복 허용) print(result) # [(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;C&#39;)] . | . heapq . 힙을 활용한 우선순위 큐 기능을 구현할 때 사용되며, O(NlogN)에 오름차순 정렬을 제공한다. PriorityQueue 라이브러리가 따로 있지만, heapq가 더 빠르게 동작한다. . PriorityQueue를 리스트나 힙으로 구현할 수 있지만 리스트는 삽입 O(1) 삭제 O(N) 의 복잡도를 가지지만, | 힙은 삽입 O(logN) 삭제 O(logN) 의 복잡도를 가진다. 그래서 우선순위 큐는 보통 힙으로 구현하고, 시간복잡도도 힙으로 구현한 시간복잡도를 사용한다. | . | . | heapq.heappush() : 원소 삽입 | heapq.heappop() : 원소 꺼내기 | heapq.heapify() | . import heapq def heapsort(iterable): h = [] result = [] # 모든 원소를 차례대로 힙에 삽입 for value in iterable: heapq.heappush(h, value) # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기 for i in range(len(h)): result.append(heapq.heappop(h)) return result result = heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) print(result) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . 히피파이를 이용한 힙정렬 기존에 있는 list 객체로 힙 정렬 만들기 | . | . import heapq h = [3, 9, 1, 4, 2] heapq.heapify(h) # 파라미터로 list 객체를 받는다. for _ in range(6): print(-heapq.heappop(h)) # 작은 값부터 출력된다. . bisect . 이진 탐색을 쉽게 구현할 수 있도록 bisect 라이브러리를 제공함. ‘정렬된 배열’에서 특정한 원소를 찾아야 할 때 매우 효과적이다. O(logN)에 정렬된 배열에 맞는 위치를 찾아준다. | ‘정렬된 리스트’에서 특정 범위에 속하는 원소의 개수를 구하는데 효과적이다. bisect_left(a, x) : 정렬된 순서를 유지하면서 리스트 a에서 데이터 x를 삽입할 가장 왼쪽 인덱스를 찾는 메서드 | bisect_right(a, x) : 정렬된 순서를 유지하면서 리스트 a에서 데이터 x를 삽입할 가장 오른쪽 인덱스를 찾는 메서드 | . | bisect 모듈은 이미 정렬되어 있는 list의 정렬 상태를 유지하기 위해 사용되는 모듈입니다. 이를 이용해서, 기존에 있는 list의 정렬 상태를 유지 할 수 있고, 이를 응용해서 Binary Search 또한 구현할 수 있습니다. | . from bisect import bisect_left, bisect_right a = [1, 2, 4, 4, 8] x = 4 print(bisect_left(a, x)) # 2 print(bisect_right(a, x)) # 4 . 정렬된 리스트’에서 특정 범위(시작과 끝)에 속하는 원소의 개수를 구하는데 효과적이다. . left는 같아도 젤 왼쪽 index(포함), right는 같아도 젤 오른쪽index(미포함, 들어가야하는 자리)를 반환하므로 시작과 끝 index를 알 수 있다. | . from bisect import bisect_left, bisect_right # 값이 [left_value, right_value]인 데이터의 개수를 반환하는 함수 def count_by_range(a, left_value, right_value): right_index = bisect_right(a, right_value) left_index = bissect_left(a, left_value) return right_index - left_index # 리스트 선언 a = [1, 2, 3, 3, 3, 3, 4, 4, 8, 9] # 값이 4인 데이터 개수 출력 print(count_by_range(a, 4, 4)) # 2 # 값이 [-1, 3] 범위에 있는 데이터 개수 출력 print(count_by_range(a, -1, 3)) # 6 . lgN으로 정렬까지 해주는 bisect.insort( )도 있다. . | bisect 모듈은 이미 정렬되어 있는 list의 정렬 상태를 유지하기 위해 사용되는 모듈입니다. 이를 이용해서, 기존에 있는 list의 정렬 상태를 유지 할 수 있고, 이를 응용해서 Binary Search 또한 구현할 수 있습니다. . | . # 1. 삽입 되어야 하는 index 찾기 import bisect arr = [1, 2, 3, 3, 4, 5] print(bisect.bisect_left(arr, 6)) # 6이 들어가야 하는 Index인 6을 반환 print(bisect.bisect_right(arr, 6)) # arr에 6이 없기 때문에 위와 똑같은 값을 반환한다. print(bisect.bisect_left(arr, 3)) # 중복 되는 값 제일 왼쪽, 2를 반환한다. print(bisect.bisect_right(arr, 3)) # 중복 되는 값 제일 오른쪽 + 1, 4를 반환한다. bisect.insort_left(arr, 3) # 중복 되는 값 왼쪽에 삽입 bisect.insort_right(arr, 3) # 중복 되는 값 오른쪽에 삽입 print(arr) . #2. Binary Search 구현 from bisect import bisect_left arr = [1, 2, 3, 3, 4, 5] def bs(arr, x): i = bisect_left(arr, x) # 들어가야 하는 &#39;제일 왼쪽&#39; index 반환 if i != len(arr) and arr[i] == x: # 들어가야 하는 index가 return i # 마지막 index + 1 이라면, arr에 x가 없는 것 else: # arr[i] == x가 아니라면, arr에 x가 없는 것 return -1 a = [1, 2, 4, 4, 8] x = 4 res = bs(a, x) if res == -1: print(x, &quot;는 없습니다!&quot;) else: print(&quot;첫번째&quot;, x, &quot;가 등장한 위치는&quot;, res) . collections . 덱(deque), 카운터(Counter) 등의 유용한 자료구조를 포함하고 있는 라이브러리 . deque . 파이썬에서는 일반적으로 deque를 활용해 큐를 구현한다. | Queue 라이브러리 있지만 일반적인 큐 자료구조를 구현하는 라이브러리는 아니다. | 리스트와 다르게 인덱싱, 슬라이싱 등의 기능은 사용할 수 없다. | 데이터의 시작이나 끝부분에 데이터를 삽입하는데 효과적이다. | . . | Counter 등장 횟수를 세는 기능을 제공한다. iterable 객체가 주어졌을 때, 해당 객체 내부 원소가 몇 번 등장했는지 알려준다. . | . math . 수학적 기능을 제공하는 라이브러리 . 자주 사용되는 수학적인 기능을 포함하고 있는 라이브러리 팩토리얼, 제곱근, 최대공약수(GCD) 등을 계산해주는 기능을 포함 . 종류 math.factorial() : 팩토리얼 | math.sqrt() : 제곱근 | math.gcd() : 최대공약수 | math.pi : 파이 | math.e : 자연상수 | . | . import math print(math.factorial(5)) # 120 print(math.sqrt(7)) # 2.6457513110645907 print(math.gcd(21, 14)) # 7 print(math.pi) # 3.141592653589793 print(math.e) # 2.718281828459045 . . 그외 . map, split, sorted . 주의점 . input말고 . 뭐 어느정도로 더 빠르고 느리냐는, 코딩 테스트 문제푸는 수준에서 다룰만한 내용이 아니므로 넘어가도록 하고, 직관적으로만 느꼈던 것은, input() 으로 코드를 제출할 시, 시간초과가 뜨지만, sys.stdin.readline() 으로 제출할 시 정답이 뜨더라는 것이다. 이와 비슷한 이슈는 이미 이전부터 있었다. | . 한편, 나는 입출력을 지금까지 이런 방식으로 했다. . a = [int(x) for x in input().split()] # a = [1, 2, 3, 4 ,5] . 하지만, 이 방법보다 다음 방법이 더 권장된다. (위와 같은 이유로) . import sys a = list(map(int, sys.stdin.readline().split()))# a = [1, 2, 3, 4, 5] . 재귀풀기 . 이전에 문제풀다가 말한 적이 있는데, 특히 자주접하는 DFS, BFS 문제의 경우 그렇다. . 파이썬의 재귀 허용 깊이의 기본치가 c 보다 약한건지, c 로 짠 DFS, BFS의 경우 문제 없이 돌아가지만, 파이썬으로 돌리면 런타임 오류가 뜨는 경우가 있다. 그래서 다음과 같이 재귀 허용 깊이를 수동으로 늘려주는 코드를, 코드 상단에 적어줘야 한다. . import sys sys.setrecursionlimit(10**8) # 10^8 까지 늘림. . | . Pypy . PyPy 가 뭔지 찾아보니, 쉽게말해 파이썬 보다 몇 배 더 빠른 개선된 파이썬이라고 생각하면 된다. . 좀 더 자세히 말하면, Python3 는 내부적으로는 C로 짜여져있는데 (이 이유 때문에 Python2 보다 빠르다.), 이를 C가 아니라 Python으로 다시 짠 것이다. 당연히 느릴 것 같은데, 의외로 빠르단다. 자세한 내용은 나무위키 참고. . 때문에, 일반적으로 Python3 보다 PyPy로 제출해서 내는게 더 안전한 듯 하다. (빠르다는 의미에서) . 한편, PyPy에서는 sys.setrecursionlimit(10**8) 이 안먹는다. 즉 임의로 재귀 호출 깊이를 설정할 수 없다는 것에 주의해야 한다. . 파이썬으로 문제푸는 게 편한점도 많지만 아직 어색하고, 이런 자잘한 리스크가 많은 듯 하다. 이후 또 뭔가 발견하면 남겨놔야겠다. . | .",
            "url": "blog.chojaeseong.com/algorithm/2021/10/22/python_%EB%AA%A8%EB%93%88%EC%A0%95%EB%A6%AC.html",
            "relUrl": "/algorithm/2021/10/22/python_%EB%AA%A8%EB%93%88%EC%A0%95%EB%A6%AC.html",
            "date": " • Oct 22, 2021"
        }
        
    
  
    
        ,"post30": {
            "title": "협업2)오픈소스PR + 팀원PR + issue로 PR",
            "content": "여러가지 Pull Request 날려보기 . Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . 노팀원 fork PR(팀원-PR받기만/ 타인(나)-Fork후 수정용브랜치로 push하여 타인의 PR) . 앞에서 PR = 팀원1(주인):수정용브랜치 -&gt; 팀원2:collaborator이며 리뷰만 PR(주인-수정용브랜치 / 팀원-리뷰만) 실습 로컬 : git_seminar | 원격 : CS100_Git in is3js . 협동자: is3js | . | . | . | 소샬코딩의 PR . 오픈소스 레포(is3js) : py . 주인 혹은 collaborator임. | . | 기여하고 싶은사람(is2js, 나): py(fork) . 팀원이 아닌 이상 일단 fork한다 | 팀원이 아니더라도 clone후 로컬에서 topic branch를 따서 작업한다. | fork레포(내꺼)에 commit, push한다 | 팀원이 아니지만, fork레포 - topic branch의 변동사항을 push로 PR한다. | . . | . | . 팀원아니더라도 fork-clone-topic따서 작업한 뒤 -&gt; (merge하지않고) commit, push . 나는 오픈소스의 collaborator가 아니므로 오픈소스(py)를 fork한다. . | 작업을 하려면 일단 clone부터해서 local에 가지고 온다. . ❯ git clone https://github.com/is2js/py.git .❯ code . . git 설정을 한번 확인해준다. . ❯ git config --list . remote.origin.url=https://github.com/is2js/py.gitremote.origin.fetch=+refs/heads/*:refs/remotes/origin/*branch.main.remote=originbranch.main.merge=refs/heads/main . | . | fork를 해온 상태는 main브랜치이다. 새로운 topic 브랜치 work를 따서 작업 -&gt; commit -&gt; work를 push까지해보자. . 브랜치 클릭 -&gt; +새 분기 만들기 &gt; work . | main에 merge하는게 아니라 topic branch를 commit -&gt; push해야 팀원아닌데도 PR을 날릴 준비를 할 수 있다. . 명령어로 할 거면 . git push origin [topic branch명] . | . | . | fork한 내 레포라도 topic branch가 merge없이 push되었으면 PR로 인식된다. . 내 개인소스 수정: merge –no-ff -&gt; main commit -&gt; push PR : no merge -&gt; topic commit -&gt; topic push | . | 원본레포인 is3js/py는 미동도 없고, fork한 내 레포 is2js/py에만 PR이 들어온다. | . | topic push로 만든 Fork레포 PR클릭시 원본레포(baserepo) PR을 유도: 전제-main(master)는 변화없이 topicbr만 변화! cf) Fork레포(headrepo)로 merge도 가능함. . 일단 기본적으로 fork한 내 레포(head repo) : is2js/py에서 | 원본 레포(base repo) : is3js/py로 PR를 보내는 것을 기본적으로 수행하려 한다. | fork레포에서 PR버튼 눌렀는데, 이미 원본레포(is3js/py)로 이동되어있다. | . | . . base repo를 수정하면, fork-main &lt;- fork-topic 도 가능한가보다. . | Create pull request해보자. . 원본레포에다가 날리는 것이다. | 원본레포에서 보면 PR이 불들어와있다. | . . | fork레포는 PR에 아무 표시도 안된다. . | 원본레포 팀원은, 팀원X-Fork-topic-PR 날린 것을 commit을 직접 확인하여 request chagnge하거나 approve해준다. . PR 확인후 해당 topic branch의 커밋까지 찾아들어간다. . . | 코멘트를 날릴 땐, +드래그해서 많이 날릴 수 있음. . | 최종적으로는 우측 상단의 review changes &gt; approve까지 해야하지 merge된다. . . | 최종승인하면 원본의 기본branch인 main으로 알아서 merge된다. . | 팀원이 아니더라도 PR(merge)후 delete branch가 원칙: 로컬에서 로컬+fork 2개다 해줌. . 로컬에서 내 fork레포 및 내 로컬레포의 topic branch를 삭제해준다. . main으로 바꾸고, 삭제 | . ❯ git branch -a❯ git checkout main❯ git branch -d work . | . 로컬topic 삭제 -&gt; remote(fork레포)도 자동삭제 반영시키기: git remote update –prune . 로컬에 topic branch가 삭제된 상태에서 git remote update --prune을 사용하여 로컬에 맞춰서 branch삭제 시킨다. . | ❯ git remote update --prune . | 안되서 나는 git push origin :remote_br . git push origin :work . | 참고) origin과 upstream . 레퍼런스: https://pers0n4.io/github-remote-repository-and-upstream/ | . Upstream &amp; Downstream . GitHub에서 repo를 생성하고 나면 다들 origin이라는 용어를 보셨을 겁니다. clone했을 때는 origin이 자동으로 등록돼있고, init했을 때는 git remote add origin ...으로 origin을 직접 등록하라고 안내하죠. 여기서 말하는 origin이 깃허브에 존재하는 repository 즉, remote를 뜻하는 단어입니다. 다만 remote에 origin이라는 이름을 붙인 것뿐이랍니다. . upstream과 downstream은 상대적인 개념이라 origin과 local을 기준으로 생각하면 origin이 upstream, local이 downstream이 됩니다. 그 이유는 push와 pull을 기준으로 생각했을 때 origin으로부터 local로 흐르는 관계가 형성되기 때문입니다. . local에서 origin으로 push한다 | origin에서 local로 pull한다 | . 만약 CLI로 push를 해보셨다면 git push -u origin main3이라는 명령어를 입력했을 텐데, 여기서 -u 옵션이 --set-upstream 옵션의 줄임으로 upstream을 설정한다는 뜻입니다. upstream을 한 번 설정하고 나면 다음부터는 git push 또는 git pull이라고 명령어만 입력해도 자동으로 origin의 main 브랜치로부터 push와 pull을 진행하는 이유가 upstream 옵션을 통해 해당 브랜치에서 upstream과 downstream 관계가 설정됐기 때문이죠. . Fork . GitHub에서 오픈소스 프로젝트에 기여한다거나, 협업을 진행할 때 fork를 이용하게 됩니다. fork는 다른 사람의 repository를 내 소유의 repository로 복사하는 일이죠. 따라서 원래 소유자의 remote repository와 내가 fork한 remote repository 사이에도 upstream과 downstream이라는 관계가 형성된답니다. 그래서 보통 원래 소유자의 remote를 말할 때 upstream, 내가 포크한 remote를 말할 때 origin이라는 용어를 사용하곤 합니다. . 노팀원이지만 [원본repo(오픈소스)] -&gt; fork레포 및 local레포를 최신형으로 유지 by local에서 upstream으로 등록하여 upstream(원본레포) -&gt; origin(fork레포), upstream -&gt; local 통로뚫고 가져오기: git remote add upstream [url] -&gt; git fetch upstream -&gt;[fork레포 ]merge버튼 + [local]git merge upstream/main . 상황 . 갑자기 오픈소스 author가 원본repo -&gt; main을 변경했다면? . 나한테(fork레포, local레포)의 main도 수정된 내용이 들어와야한다. | . . | 기존 local repo에서 -&gt; fork repo를 origin 이라 별칭했음 . local repo에서 -&gt; 원본repo를 upstream으로 별칭 등록 및 원본repo - fork repo를 연결 | . | git fetch: origin to local . git fetch upstream: 원본repo(upstream) to fork repo(origin)으로 업데이트 내용 받아오기 | git merge upstream/main으로 원본repo(upstream) to local repo(local)로 업데이트 내용 받아오기 | . | . | my) 원본repo를 노팀원이 upstream으로 local에서 등록하면 . upstream -&gt; fork | upstream -&gt; local 업데이트가 가능하다. | . | . | 관련 명령어 . . | 참고) upstream 삭제 . 참고 블로그 . git remote -v git remote rm upstream git remote -v . | . | . local에서 원본repo를 upstream으로 등록한다. . ❯ git remote add upstream https://github.com/is3js/py.git . . | git fetch upstream명령어로 upstream의 최신정보를 origin이 받을 수 있도록 업데이트해온다.(아직 받진 X) . ❯ git fetch upstream remote: Enumerating objects: 8, done. remote: Counting objects: 100% (8/8), done. remote: Compressing objects: 100% (3/3), done. remote: Total 5 (delta 2), reused 4 (delta 2), pack-reused 0 Unpacking objects: 100% (5/5), done. From https://github.com/is3js/py * [new branch] main -&gt; upstream/main . origin(fork repo)에 가보면, Fetch해왔다고 뜬다. | . | fork repo에 들어가 git fetch upstream정보를 이용해 최종 merge시킨다. by Fetch upsteam&gt; Fetch and merge 버튼 . | local에서는 git merge upstream/main명령어를 이용해 upstream정보를 가져온다. . 왠지 origin을 pull해서 업데이트 해도될것같긴한데… 따로 upstream -&gt; local로 받는다? | . ❯ git merge upstream/main Updating 476f70b..f7dd8e8 Fast-forward .gitignore | 11 ++++++++++- rb.py | 3 +++ 2 files changed, 13 insertions(+), 1 deletion(-) . 참고) 만약 merge가 conflict나면 . git merge upstream/master --allow-unrelated-histories . | . | 앞으로 계속 . ❯ git fetch upstream # fork repo가서 merge 버튼 # local에서 merge ❯ git merge upstream/main . | 팀작업1: 내부팀원 (not 오픈소스) 초대 및 작업하기 . 내부 소스( not 오픈소스)라고 가정한다. | 관련 명령어 | . 팀리더(is3js)가 팀원(is2js)초대 : github-settings-manage acess-add people(invite collaborator) . 초대받은 사람은 등록 email로만 초대를 받음. push권한이 있다고 한다. = 글쓰기 기능이 있다. | . | . 팀원은 초대되었다면,fork(-&gt; clone -&gt; topic -&gt; PR)할 필요가 없이 clone(-&gt;push)or(-&gt;topic-&gt; review=팀원PR)만 한다. 팀원이라면 바로 local-&gt;팀repo에 바로 push가 가능 . 팀원은 초대되었다면,fork(-&gt; clone -&gt; topic -&gt; PR)할 필요가 없이 clone(-&gt;topic-&gt;push or review=팀원PR) . ❯ mkdir team_py❯ cd team_py❯ git clone https://github.com/is3js/py.git . . | 해당 폴더로 이동후 수정하고 commit -&gt; push까지해보자. . 원래는 topic -&gt; | . code .# main에서 바로 # 파일수정# add commit -&gt;push . | 팀원이라면, 팀repo에 바로 push가 된다. . | 팀작업2: 내부팀원의 clone (local)에서 topic push로 PR권유 -&gt; topic push한 사람만 PR요청 가능 -&gt; 타 팀원review받기 (review안받을거면 main push했음) . . topic push한 작업팀원만, 자신에게 PR권유를 확인 및 요청할 수 있다. . 팀원은 fork필요없이 local clone후 main push해도 되지만, review를 받기 위해 topic push로 PR한다 . user-login topic branch 생성 . git checkout -b user-login . | login.py 생성 후 작업 . | add, commit, (topic branch) push . | | **팀원repo에 들어가도 ** . topic branch를 보낸 사람이 아니면.. PR권유가 안뜬다. . is3js(타팀원) . PR권유는 topic br push한 사람 자신에게만 보인다. | . . branch로는 보여도, PR은 타팀원이 결정안함. | . . | is2js( topic br push한 작업 팀원) . . | . | . | topic br push를 pull request한다. . 메세지에 코드리뷰 부탁한다고 남기자. | . | 타팀원은 PR 불-&gt; commit 메세지-&gt; commit 클릭 -&gt; 코드 리뷰 . author가 아니더라도 모든 팀원들이 확인할 수 있게 ** **PR에 불이 들어와있다. . | Merge를 누르기 전에 메세지에 달려있는 커밋까지 직접들어가서 코드를 살펴보자. . . | code line에서 +를 드래그해서 코드 리뷰를 해준다. . | 거절을 의미하는 코드 리뷰를 해주자. 코드리뷰한 것 바로 밑에 Reply도 달 수 있으니 확인하면된다. | 코드 리뷰를 데면 우측에 Finish your review(1)가 뜬다. 클릭해서 리뷰를 끝내자. | . | 코드 리뷰를 달면, 자동으로 작업 팀원에게 email도 보내준다. | (topic push -&gt;PR했던) 작업 팀원은 확인해서 1) Reply + 2) local에서 추가작업 -&gt; 3) topic br PUSH -&gt; 4) 자동 PR timeline에 추가 . . 거절성 코드리뷰에 대해 대답을 해주고 . | PR 날렸던 topic br로 다시 돌아와서 . 추가 작업을 함. . ❯ git checkout user-login . | . | 다시 한번 topic br push하면, 추가 PR을 안날려도 자동으로 PR 타임라인에 추가된다. . | 타팀원의 2번째 review부터는 [작업팀원의 추가push]가 자동으로 PR timelien에 추가된다. . 타팀원 화면에서는 작업팀원의 추가작업한 커밋 위에 View changes가 떠있다. . 작업팀원이 커밋할 때 . . | 타팀원(리뷰팀원)화면 . | . | 승인은 LGTM(looks good to me) . 코드 리뷰를 다시 한번 남기고 | finish your review에서 approve를 선택해주면 끝난다. 이 때 멘트는 LGMT를 많이 쓴다. | approval이 떴다면, 작업팀원이 merge PR해도 된다. 아무나 팀원이면 다된다. merge후에는 delete (topic) branch -&gt; local code 최신화(git pull) -&gt; local의 topic branch는 직접 삭제() . approve 확인되면 | 작업한 팀원이라도 merge시킬 수 있다. . | 작업이 끝난 topic branch를 삭제하라고 뜬다. 삭제한다. . | 로컬의 main 코드를 최신화하기 위해 main branch로 와서 git pull로 코드 최신화한다. . ❯ git checkout main . | 로컬의 topic branch도 직접 삭제한다. . ❯ git branch -d user-login Deleted branch user-login (was b7bde3a). . | cf) 혹시 delete branch 안해서 서버에 남아있다면? . local branch 수동 삭제 . | remote 동기화로 삭제 . git remote update --prune . | 팀작업3: issue(개선기록) 와 PR(팀원1(주인)-수정용브랜치push PR / 팀원2-리뷰만) 실습 . 로컬 : git_seminar . | 원격 : CS100_Git in is2js . 협동자: is3js | . | . 로컬 readme생성후 -&gt; 원격 빈레포에 push로 시작. 1번째 가이드: …or create a new repository on the command line(init, readme push) . 로컬에서, 빈 레포 생성시 주어지는 가이드1 번째인 …or create a new repository on the command line를 따라치기 . echo &quot;# CS100_Git&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;first commit&quot; git branch -M main git remote add origin https://github.com/is2js/CS100_Git.git git push -u origin main . 아직 git init안한 상태에서 readme.md를 먼저 만들고,, 시작하네 | . | . | 원격레포에 issue생성: issue는 TODO list 역할이나 논의사항 정리용 . 원격레포의 issue 탭 &gt; new issue 클릭 . readme.md 파일을 좀 더 구체적으로 작성해주라고 issue 생성하기 | . | issue 오른쪽 사이드바에 보이는 Assignees를 클릭하여, issue해결자 10명 중 1명으로 나를 등록한다. . . | issue 해결 전에, collaborator 추가 (상대방은 메일로만 초대받음) . settings &gt; manage access &gt; add people . is2js(tingstyle1@gmail.com, 현재) -&gt; (시크릿창) is3js 계정 추가 . . is3js(is2js@naver.com)계정은 깃허브알림 없이 메일로만 초대장이 옴 | . | . | . 로컬에서 생성 후 파일 수정하기: git checkout -b [생성후전환될 브랜치] . 로컬(is2js)에서 feature/readMe 라는 파일 수정용 브랜치를 생성하자 . ❯ git checkout -b feature/readMeSwitched to a new branch &#39;feature/readMe&#39;&gt;glg # git log(HEAD -&gt; feature/readMe, origin/main, main) . branch 변경 후 git log를 확인하니 HEAD가 브랜치를 잘 따라오고 있다. | . | 파일 수정후에는 add전 gitt diff로 어느부분 수정되어있는지 확인 . ❯ git diffdiff --git a/README.md b/README.mdindex 1743ce5..a6cac92 100644 a/README.md+++ b/README.md@@ -1 +1,3 @@ # CS100_Git++This is CS100 No newline at end of file . | add - status - commit 단계를 거친다. . ❯ git add README.md❯ git status . | (PR날릴 브랜치는)순수 git commit후 메세지 작성되는 부분에 [- issue #번호] 삽입하여, 해당issue에 커밋 걸어주기 . git commit만 입력하기 . &gt; git commit . | commit 메세지 작성 에디터에서 - issue #1의 관련된 issue 번호를 기입해주기 . ADD more description in README- issue #1 . . | 나중에 저렇게 삽입한 커밋속 issue #1지정 부분은 PR속에서 issue를 연결해준다. . **즉, issue에 대한 하여 PR(팀원검토)시에는 `#번호`를 커밋메세지에 넣어두자.** . . | . | 원격레포에 없는 지만, push해주면 &lt;알아서생성+PR권유&gt; . 로컬에서 원격레포로 수정용 브랜치를 push . ❯ git push origin feature/readMeCounting objects: 3, done.Writing objects: 100% (3/3), 289 bytes | 289.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)remote: remote: Create a pull request for &#39;feature/readMe&#39; on GitHub by visiting:remote: https://github.com/is2js/CS100_Git/pull/new/feature/readMeremote: To https://github.com/is2js/CS100_Git.git * [new branch] feature/readMe -&gt; feature/readMe . | github에 가보면, . 새로운 브랜치 생성 확인: 로컬에서 수정용브랜치를 push해서 자동으로 생성한 것 . . | 현재는 main우주만 보여주고 있음. 수정한 평행우주는 브랜치를 선택해서 들어가야 보임 . | . | 혼자는merge지만, PR은 를 팀원(collaborator)들에게 확인요청이니 메세지 한번더! . 혼자 작업했다면, . 로컬에서 수정용브랜치 -&gt; main브랜치 merge하면 끝 | . | 여러명 작업시 merge대신 . 로컬에서 수정용 브랜치생성후 파일 수정 . | 원격레포에 push하여 수정용브랜치 생성 . | 합치기전에 PR과정을 전시하여 팀원들에게 확인받기 . | . | . Compare &amp; pull request 클릭 . . | PR은 팀원확인요청이다. 로컬 커밋메세지가 default로 적혀있는데, 커밋메세지에 PR메세지로서 추가로 적어준다. . . | 아래와 같이 커밋메세지 따로에, PR메세지가 덮어서 보인다. . | PR을 검수할 팀원에게 review요청하기(수정용브랜치를 merge해도될지) . PR메세지 우측에 Reviewers가 있다. 여길 선택해서, PR review를 요청하자. | . is3js(팀원)계정을 시크릿창으로 들어가보자. . 레포 &gt; Pull request &gt; 해당PR까지 클릭하고 가야지 Review요청한 것이 보인다. (호버해도 보이긴하네) . . | | . | 리뷰요청받은 뒤 Add your review는 lineByline으로 피드백 주는 것 . add your review 클릭 . | 플러스버튼으로 피드백을 주면되는데 드래그로 여러라인에 대한 피드백을 줄 수 도 있다. . | 리뷰요청시 피드백(라인별코멘트)과 별개로, 칼을 뽑아야함: Approve(merge) or Request changes(다시push해) . 코멘트를 다 남겼으면, 우측 상단에 Finish you review로 칼을 뽑아야한다. . 이 경우 수정이 좀 더 필요하다고 하여 승인거절한다.내용없이 Reqeust changes 클릭 | . | 내가 남긴 코멘트의 위치 및 승인거절=변화요구의 메세지를 확인한다. . | [로컬] review내용인 1) 라인별코멘트에 [대한 대답reply] &amp; 2) 변화요구에 대한 [에서 수정후 다시 push] . 라인별 코멘트에 대한 대답 . | 리뷰어에 의한 Changes requested는 feature/readMe에 푸싱함으로써 커밋을 추가하라고 뜬다. . reviewer에 의한 request changes는 &lt;수정용 브랜치로 추가 커밋하면 다시 검토&gt;를 말하는 것이다. | . 다시 로컬 해당 브랜치로 와서 . | 요구대로 새롭게 작성후 push까지 해준다. . # 파일 수정# add전 git gtatusgit status#git add 파일명git add README.mdgit commitgit loggit push origin feature/readMe . | | PR은 의 단위라서 아직 merge안됬다면, 해당브랜치는 이어지며 가서 확인한다. . git push origin feature/readMe를 통해 push했으면, 아직 해당 PR상황에서 커밋이 추가된다. . main에서는 추가 PR 안내가 없음. 수정용 브랜치에서는 평행우주의 내용은 변화되었음. | . | reviewer에 의해 request changes는 &lt;수정용브랜치로 추가 커밋하면 다시 검토&gt;를 말하는 것이다. 즉, 검토하고 있던 PR상황으로 다시 직접들어가보면, 추가 push를 확인할 수 있게 됨. | . | . . | **의 추가push후**에는 되면 **또다시 review 요청해야한다.** . . | 또다시 PR(수정용브랜치 merge검토)에 대한 review요청을 받음. -&gt; LGTM approve해주기 . 역시 해당 PR까지 클릭해서 들어와야 보인다. . add your review . 라인별 코멘트 -&gt; 생략 | LGTM(Loos Good To me)와 함께 Approve | . . | . | . review가 approve해야 드디어 merge가 뜬다. 동시에 . . . 우측의 Delete branch를 눌러 수정용브랜치를 삭제해주자. . | PR탭은 Merged로 해결됨. . | [issue탭]에서도 Merged가 뜸. -&gt; [PR-&gt;merged]의 해결된 issue를 닫기 . . issue작성 후 . 수정용브랜치 생성 | PR를 위해 커밋 커밋시 issue번호를 #번호형태로 커밋메세지 속에 남기면 issue탭에서도 표기가 된다. | . | . | 수정용브랜치 push -&gt; PR 생성 -&gt; review -&gt; merged로 해결되었으면 issue도 닫아야한다. . 메세지로 닫는다 알리기 . . | Close issue를 눌러서 해당 issue를 닫는다. . | | [로컬]에서 default [main]브랜치로 옮겨와, PR-&gt;merged된 프로젝트 정보를 git pull로 내려받아서, 로컬에서도 통합 및 브랜치삭제가 반영되도록 한다. . 삭제당한 feature/readme&lt;수정용브랜치&gt;가 아닌 default main브랜치로 옮겨와서 git pull받는다. | ❯ git checkout main ❯ git fetch ❯ git pull # git pull origin main 으로 정확하게 표시하면 upstream설정이 안뜬다. # 그러나 한번만 업스트림하면 되므로 그냥 해준다. ❯ git branch --set-upstream-to=origin/main main Branch &#39;main&#39; set up to track remote branch &#39;main&#39; from &#39;origin&#39;. ❯ git fetch ❯ git pull Updating 99ce761..1ed16b7 Fast-forward README.md | 4 ++++ 1 file changed, 4 insertions(+) .",
            "url": "blog.chojaeseong.com/git/2021/10/17/%EA%B9%834_PR%ED%8C%80%EC%9E%91%EC%97%85_1%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4_2%ED%8C%80%EC%9E%91%EC%97%85_3%EC%9E%87%EC%8A%88%EC%99%80%EB%A6%AC%EB%B7%B0%EC%9A%A9PR.html",
            "relUrl": "/git/2021/10/17/%EA%B9%834_PR%ED%8C%80%EC%9E%91%EC%97%85_1%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4_2%ED%8C%80%EC%9E%91%EC%97%85_3%EC%9E%87%EC%8A%88%EC%99%80%EB%A6%AC%EB%B7%B0%EC%9A%A9PR.html",
            "date": " • Oct 17, 2021"
        }
        
    
  
    
        ,"post31": {
            "title": "SKTacademy 코테 TIP과 자료구조",
            "content": "reference SKTacademy | | . 알고리즘 푸는 이유 . 구현: 생각하는 내용을 코드로 옮긴다. 연습안하면 안된다. 500문제 이상 풀어야함. 반복해야 언제 어떤 변수를 선언하고 언제 전처리 해야하는지 알 수 있게 된다. 빨라지고 나만의 코딩스타일이 생긴다. | 효율성: 계속 구현하다보면, 효율성을 챙기면서, 자주 사용하는 함수로 최적화 | 다른 사람들의 코드를 보면서, 효율적인 코드 작성 | . | 절차적 사고: 절차적인 사고에 익숙해짐. 언제 어떤 과정을 하고, 다음은 어떻게 해야하는지 | 적재적소한 알고리즘을 선택할 수 있게 된다. 그럴려면 자료구조, 알고리즘을 따로 공부해야한다. | . | . | 디버깅: 한번만에 맞는 경우는 거의 없다. 예외케이스 탐색을 많이 해야한다. 최저, 최대, 최악 경우를 넣어보면서 한다. | 코드(에러)를 읽는 능력 | . | . | 재미: 적은시간으로 연습 가능 | 프로젝트와 다르게 짧은 주기로 성취감 | . | 문제보고 감잡기 . 1초당 가능한 복잡도 간 미리 계산하기 . python으로 . 백만번(10^6) 반복문or덧셈곱셈 등… -&gt; 1초 안에 다 풀린다. | 천만번(10^7) -&gt; 1초 안에 대부분 풀린다. python으로 1초안에 천만~5천만(10^7 ~ 5* 10^7)까지 연산 가능하다 생각하자. | . | 1억(10^8) -&gt; 불가능 -&gt; 알고리즘 바꿔야함. | . | 다시 문제보기 . 시간제한부터 보기 . 1초 -&gt; 10&amp;7 안에 풀어야한다. | . | 입력 보고, 반복문 횟수 갸늠하기 . n = 10억 = 10^9 -&gt; 단순 반복문 O(N)으로 는 불가능하다. | 입력을 보고 O(N)이상 불가 -&gt; 루트(n) or lgN or O(1)으로 해야한다. | . | . | . | PS팁 . 입력과 초기화 . python의 input은 3가지 종류를 받는다. . 숫자1개 . python에서는 항상 string으로 들어온형변환부터 해준다. | . . | 문자열 . 일반 문장 | 쪼개면서, [i]번째 인덱싱도 하고 싶다 -&gt; list() immutable한 string 대신 list로 변환시켜줘야한다. | . | 다시 붙일려면 ”“.join사용 | . . | 숫자 배열 . map을 써서 형변환한다. | . . | . | **list(배열)의 초기화는 comprehension으로 ** . . | . | 에러메세지 확인하기 RE: 런타임에러 -&gt; zerodivision or indexError | TLE: 시간초과 -&gt; 잘짰는데 무한루프가 있거나, 알고리즘이 안 좋거나 | . | 추상화와 기능분리 . 맨 처음 반복문에 돌아가면서 기능을 해줄 or 테케마다 처리해줄 input()받기부터 시작하는 함수를 짜자. 대충 로직을 슈도코드 짜듯이 짜면서 반복문 - 체크 - 결과값 저장 등의 로직을 짠다. . | 코딩하는 2가지 방법 . 현재가 main함수라고 가정하고 while 문에서 다 돌리기 | process함수를 따로 만들어놓고, 테케를 process함수에서 받아 main에서 돌림 | . | 처음에는 다 while문에 넣고 돌린다. . | 하지만, main함수는 최소화 해서 가벼워야한다. 내용들은 다 함수로 보낸다. . 반복문을 돌되, 각 TestCase마다 따로 처리되도록 함수로, TC별 처리되도록 하는 함수를 만들어서 돌린다. | . . 일단 위에 스샷기준으로는.. 테케별 처리도되록 함수에서 input을 받고 -&gt; 리하고 -&gt; return 하고-&gt; main에서 for문 print(함수return값) | . | . | 예를 들어, 삼성기출-사다리조작문제를 보자. (풀이는 안함) . 삼성쪽은 문제가 되게 길다. 그림 위 수치 위주로 빠르게 한번 보자. . 일단 수치(숫자)를 먼저보고 &quot;아~ 사다리가 5줄, 6줄 되는 구나 &quot; . | 사다리를 중간에 넣을 수 있구나 . | 사다리를 진행해나가는 과정이 있구나 . . | . | 입력 양식(예제 입력)보기 . 첫줄의 숫자와, 나머지 아래 숫자가 같으니까 아 대충 아래쪽이 사다리를 의미하겠구나 | . | 문제를 자세히 읽기 시작하는데 출력 요구사항을 먼저 본다 . | 문제가 복잡해보인다. . **이 때, main함수를 간단하게 만들기 위해, 반복문 어떻게 돌릴지 판단 -&gt; 그안에서 사용될 기능 분리하여 일단 슈도코드로 함수들을 작성해 기능분리 시켜준다. ** . | 사다리를 최대3개까지 놓는데, . i에 놓을지 . j에 놓을지 . k에 놓을지 선택할 수 있게 3중for문을 만들어 탐색가능하게 함. . | 3개에 따라 가능한지 확인하는 check(i,j,k) 함수를 사용하고 슈도코드로 위에다 작성해둔다. . | 가능할 때, 그 i번째 사다리가 i로 내려오는지 체크해주는 함수result()도 슈도코드로 작성해둔다. . | . . | . | | . | 코드를 줄여 가독성을 높이는 조건문, 반복문, 함수 by python indent를 줄이기 . 반복문 eX&gt; N by N by N 3중 포문 . 똑같이 N**3 만큼 횟수는 동일하게 돌아가는데, 한번에 for num in range(N**3)으로 돌리면서 . i = num을 N^2으로 나눈 몫 = num // (N*N) | j = num을 N으로 나눈 몫을, 다시 N으로 나눈 나머지 = num//N % N | k = num을 N으로 나눈 나머지 = num % N | . | **내가 만든 2중 포문을 indent 1개로 ** . i = num을 N으로 나눈 몫 N*N을 통해, ` 0~N-1을 첫번째 구간으로해서 N개` 존재하는데, 0~N-1구간: 행을 0으로 간주해요 | N~2N-1 : 행을 1로 간주해요 | … | ~N^2-1 N개의 구간이 있어요 | . | . | j = num을 N으로 나눈 나머지 구간별로 0~N-1의 열을 담당해요. | . | . for num in range(N**2): i, j = num//N, num%N print(f&quot;({i},{j})&quot; , end = &quot; &quot;) . | 진법, 진수를 활용하면 더 쉬워진다고 한다. . | . | main 반복문 속 조건문을 if True:시 process()가 아니라 if not False시: continue로 아래 process() 건너띄기를 통해 indent를 챙길 수 있다. . . process()함수 위에다가 if not 조건문 :continue를 활용해서 탈락시 건너띄기하면, 반복문내 indent를 줄일 수 있다. | . | 함수안에 if : return 다음에는 else가 필요없다. . **if return / return도 return 삼항연산자로 줄일 수 있다. ** 가장 선호. flag도 이런식으로 할 수 있다. | . | . . | | 변수명은 snake_case로, 함수명은 cameCase로, Pascal은 시작부터 대문자인 Camel . | 적용해보기 주사위네개 . 나는 Counter를 활용했지만.. | . # 기존 내코드 N = int(input()) from collections import Counter max_money = float(&#39;-inf&#39;) # 같은 눈이 4개가 나오면 50,000원+(같은 눈)×5,000원의 상금을 받게 된다. # 같은 눈이 3개만 나오면 10,000원+(3개가 나온 눈)×1,000원의 상금을 받게 된다. # 같은 눈이 2개씩 두 쌍이 나오는 경우에는 2,000원+(2개가 나온 눈)×500원+(또 다른 2개가 나온 눈)×500원의 상금을 받게 된다. # 같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)×100원의 상금을 받게 된다. # 모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)×100원의 상금을 받게 된다. def calc_money(data): max_cnt = max(data.values()) val_lst = [ x[0] for x in data.items() if x[1]==max_cnt] if max_cnt == 4: return 50000 + (val_lst[0]*5000) elif max_cnt == 3: # val_lst = [ x[0] for x in data.items() if x[1]==max_cnt] return 10000 + (val_lst[0]*1000) elif max_cnt == 2: # val_lst = [ x[0] for x in data.items() if x[1]==max_cnt] if len(val_lst) == 2: return 2000+(val_lst[0]*500) + (val_lst[1]*500) else: return 1000 + (val_lst[0]*100) else: return max(data.keys())*100 for _ in range(N): data = list(map(int, input().split())) data = Counter(data) money = calc_money(data) max_money = max(max_money, money) print(max_money) . 수학을 이용하면서 . 기능분리 by 함수 | 입력과 초기화 by 튜플, 컴프리헨션 | 반복문, 조건문 줄이기 by 한번에돌기+ if reutrn후에는 no else noelif + 삼항연산자 | . . | . | 수학 . 반복문을 . range(min(a,b))로 길이를 줄이거나 | range(min(a,b),,-1)로 거꾸로 시작하거나 | range(,,n)으로 간격을 주는 것을 생각하자. | . | 유호제법은 코드로 외우자. . math.gcd써도될듯.. | . # a&gt;b def gcd(a,b): # 1) b가 a의 약수면.. 그냥 b가 최대 공약수 # 2) 그게 아니라면, 재귀로서 gcd(b, a%b)로 재귀로 빨리 구하자. return b if a%b==0 else:gcd(b, a%b) . | 소수판별과 에라토스테네스의 체 . 소수판별 isPrime은 . 이론상 소수=1과 자기자신만을 약수로 가짐 = 2~n-1까지 약수없음, 약수 나오면 탈락인데 . 약수와 배수의 관계에서 약수는 항상 짝을 이루어 존재하니 2~루트(n)까지만 검사한다. | . . | . | 에라토스테네스의 체 . 범위가 주어진다 1~n까지 중 소스의 갯수는? 1은 소수가 아니여서 지움 | 2부터 isPrime으로 소수판별 소수로 판별되면 -&gt; 소수의 배수들을 싹다 지움(어떤수의 배수는.. 소수가 아님 무조건 x2, x3들이 약수가 되니까 | . | . | . . 뭔가를 지울 때는 chk, ck배열에다가 index - T/F를 hashing하여 활용한다. 이미 범위가 정해져있으면 거의 이렇게 사용한다. count 정렬 | 에라토스 테네스의 체 | DFS BFS? | . | . . 그외 자세히 주석으로 달음 . def era(N): # 체크는 hasing용으로서, n index를 쓸 거기때문에 0부터 시작했더라도 range(N+1)까지 돌려준다. ck = [ False for _ in range(N+1) ] p = [] # 1은 소수가 아니므로 제끼고 2부터 체크한다. # 소수의 배수들을 True를 채워놓고, 다음에 올 때 건너뛰게 한다. # 과거에서 판단한 소수의 배수들에 안걸렸으면, 아직 False로 남아있는, 소수는 바로 append해 줘도 된다. # -&gt; 맨처음 2만, 최초이기 때문에 과거에서 True로 소수탈락시킨 경험이 없다. for i in range(2, N+1): # 아직 False인 것만 체크한다. # 아래에서, 미래원소들 중에 소수라고 판별내어놨으면 건너뛴다. # -&gt; check를 활용해서 건너뛰는 [ck 미래 -&gt; continue 로직]이다. if ck[i] == True: continue # False = 2의 배수부터 시작해서, 소수탈락(True)에 안걸렸다면, 소수라고 판단한다. p.append(i) # 현재 i는 소수라는 뜻인데, 소수-&gt; 소수의 배수를 True(소수탈락)로 지워야한다. # * i배수 조작-&gt; i배수는 range(시작수, 끝수, i)를 통해 +i씩 움직인다. # 이 때, i+i or i*2부터 +i씩 i*3, i*4를 지워나가는게 아니라 # * &lt; ixi &gt;부터 시작해서 i의 배수를 지워나간다 range(i*i, N+1, i) # -&gt; 왜냐하면, 이미 과거에서 지워났기 때문인데 # -&gt; 예를 들어, 6은.. 이미 2에서 지워놨음. 3에서 지울 필요X. # -&gt; 3은 뭐부터 지워나가야할까? -&gt; 앞에서 안나왔을, 3의배수로서만 존재하는, # -&gt; 3만을 약수로 가지는 = 9부터 지워나가면 된다. # -&gt; 2*i부터 지눠나가도 괜찮다. # for j in range(i*2, N+1, i): for j in range(i*i, N+1, i): ck[j] = True # 이제 리얼소수는 p 배열에, 체크여부는 ck(소수탈락시True?)로 반환한다. return ck, p print(era(10)) # ([False, False, False, False, True, False, True, False, True, True, True], [2, 3, 5, 7]) . | . | . | 하노이 = 분할정복 by 재귀 . n번째 자체처리를 잘 넣어주자. | 재귀가 꼭 return해줄 필요는 없다. return안한다면 꼭 + 등의 연산으로 연결해줄 필요가 없다. 갯수: return f(n-1) * 2 +1 | 출력: f(n-1) + print(n자체) + f(n-1) f(n-1)내부에서도 print가 호출됨. | . | BUT 재귀함수의 base case if는 반드시 return으로 종료시켜줘야한다!! | . | 변하는 것들을 인자로 잘 넣어주자. 숫자 명칭이 고정이라면, 합이 일정한 것도 이용하자. | . # 1-&gt;3def hanoi(st, ed, n): if n==1: return print(st,ed) # 1-&gt;2 n-1 # st-&gt;mid hanoi(st, 6-(st+ed), n-1) # 1-&gt;3 print(st, ed) # 2-&gt;3 n-1 # mid -&gt;ed hanoi(6-(st+ed), ed, n-1) . | 정렬 . 선택정렬(i+1~n-1와 비교 최소값 찾으면 swap, 매번 맨왼쪽 최소값 확정), 버블정렬( 매번 인접한수 비교후 크면 오른쪽으로 swap, 매번 맨오른쪽 최대값 확정)은 n, n-1, .. 1번 모두 탐색해야해서 시복 O( n(n+1)/2) = O(N^2)으로 너무 느리다. . | 퀵 소트 . 재귀로 구현. 1)p정하고 2) 작, 큰그룹나눠서 3)p자리 확정의 과정을 작은그룹에서 1번, 큰그룹에서 1번 다시 시행한다. . def quick_sort(array): # 리스트가 하나 이하의 원소만을 담고 있다면 종료 if len(array) &lt;= 1: return array pivot = array[0] # 피벗은 첫 번째 원소 tail = array[1:] # 피벗을 제외한 리스트 left_side = [x for x in tail if x &lt;= pivot] # 분할된 왼쪽 부분 right_side = [x for x in tail if x &gt; pivot] # 분할된 오른쪽 부분 return quick_sort(left_side) + [pivot] + quick_sort(right_side) . | . | 머지 소트 . 재귀시, divide후 conquer과정에 투포인터 개념으로 merge를 해야한다. . | 1)절반으로 나누고, 2) 각각을 투포인터개념으로 합친다. . # 합병정렬에서는 conquer과정이 복잡하다. # [divide] 는 그냥 반씩 쪼개면 되지만, # [conquer]된(정렬된 list2개) 것들을 [combine](2개 list 합하여 정렬)시 복잡하기 때문에 이 부분을 merge함수로 뺀다. def merge(list1, list2): merged_list = [] i = 0 j = 0 while i &lt; len(list1) and j &lt; len(list2): if list1[i] &lt; list2[j]: merged_list.append(list1[i]) i+=1 else: merged_list.append(list2[j]) j+=1 if i == len(list1): merged_list += list2[j:] elif j == len(list2): merged_list += list1[i:] return merged_list def merge_sort(my_list): # base case if len(my_list) &lt; 2: return my_list # divide and conquer left_half = my_list[:len(my_list)//2] right_half = my_list[len(my_list)//2:] # 부분문제는 원래함수(부분)을 한 상태가.. 정복된 상태다 조심! return merge(merge_sort(left_half), merge_sort(right_half)) print(merge_sort([12, 13, 11, 14, 10])) . 2개의 배열을 merge할 때, 4개짜리 배열을 미리 대기시켜놓고, 투포인터로 넣어줘야한다. | 즉, 메모리할당이 많아진다. | 머지 소트는 정렬 문제에서 메모리가 넉넉할 때 쓴다. | 퀵 소트는, 최악(역순정렬&amp;p를 맨첫값)의 경우 NN이 될 수도 있다. | . | python sort(), sorted()는 퀵소트, 머지소트보다 더 최적화된 정렬을 쓰니. 그냥 이걸 쓰자. . | . | 라딕스 소트(radix sort) = 카운팅정렬 -&gt; 이범정(10^6~10^7 이하)일 때 . **이미 최소~최대값의 범위가 정해져있을 때 **, 그 범위를 index로 hashing시킨 배열을 미리 만들어놓고 . | 카운팅한다. . | 카운팅수만큼 연속해서 나열� . | | 자료구조 . 쓰는이유: 효율성. 쓰는 의미가 있음. 사용처가 정해져있다. 메모리를 효율적으로 쓴다. ex&gt; stack: undo 마지막에 했던 작업을 되돌리기 위해. 직전꺼를 되돌리기 | . | 추상적: 코드가 정해져있지 않음. 개념이므로 라이브러리가 아니더라도 어느 언어라도 구현가능해야한다. | 재사용성: 계속 쓰기 위해 라이브러리를 제공함 python은 collections에 많음. | . | . | stack 접시닦고 다시 가져가는 것에 비유 많이함. undo | 넣고push 위에서부터 빼는pop 2가지가 핵심 | 배열과 다른점은, 맨 마지막이 빠져나가는 점 : LIFO | python에서는 따로 library없고 배열[]로 바로 사용한다. | 예제 : 괄호 -&gt; 여는괄호만 넣어서 쌓으며, 닫괄시.. 직전에 넣은 여괄 부터 꺼내 짝이 맞나 확인해야한다. | . | queue와 deque 왜쓸까? 배열이랑 달라보이지만, 불필요 메모리를 줄인다.메모리를 효율적으로사용하기 위해 배열로도 구현가능(pop한 앞부분으로 index를 한칸씩 당긴다.?) | 이미 pop한 것들을 붙잡을 이유가 없어서 그럴필요가 없음. | . | server에서 여러 queue를 써서, 여유로운 queue에 task를 넣어주는 형식(task분할) | python에서는 deque = stack + queue라서 queue문제는 deque | 예제: 요세푸스 돌면서 제거된 사람을 빼야하는 경우 -&gt; deque의 queue로 popleft + append를 rotate로 해결 | . | . | . 그래프와 Tree의 저장방법 . 그래프의 특이한 형태로서, 나가는 간선(outdegree)만 있으면 Tree . Tree도 2가지 저장방법이 있다. . 자식마다 부모는 only 1개씩, 자식배열에 저장 cycle없이 root node제외하고 다 부모가 1개씩 존재 | 밑에서부터 부모를 찾아 올라갈 수 있다. 4의 부모 2 -&gt; 2의부모 1 -&gt; 1의 부모 0 == root | . | . | 부모마다 여러개자식을, 자식list로 2차원배열에 저장 인접리스트 저장시, 아래로 내려가면서 순환을 돌기 좋다. 1의 자식2 -&gt; 2는 아래로 4,5,6을 볼 수 있으니 4번 부터 본다. -&gt; 4번은 비어서 leaf node로 끝났따 -&gt; 5번 보고 6번보고 하자. | . | . | . | Tree의 부모저장배열 -&gt; LCA찾기 예시가 촌수문제다. . 조상들 모을 default 0의 N+1개짜리 부모저장배열 생성 입력정보를 배열에 저장함. 부모 없으면 0 | . | 2개 node의 공통조상찾는다? 각각의 (조상, 촌수) 튜플이 담길 list를 선언 | 한번 타고올라갈때마다 거리를 더해줄 각각의 촌수변수 선언 | . | 각 node마다 부모가 없을 때까지 찾아가야한다. default 0이며, 안쓰는 p[0]에 0이 들어가있어 무한루프의 가능성이 있으니, 부모가 0되는 순간 빠져나와서, 아직 처리안된상태로 나와, 마지막에 한번더 처리해준다. | 나부터 시작, 거리0으로서 튜플로(조상,거리)를 모아준다. | 재귀적으로 한번 찾아갈때마다 B = p[B] 로서, 나를 부모로 업데이트해준다. 그러면 나의 부모의 부모를 찾아가도록 된다. | . | . N = int(input()) A, B = map(int, input().split()) # 1. 촌수는 Tree형태 그래프인데, 문제에서 부모(1개만) 저장하는 방식을 택했으니 # -&gt; 1차원 배열에 다가 받아준다. # -&gt; 자신의 부모를 모두 0으로 초기화 해놓는다. (1부터 시작하는 node -&gt; 0은 부모가 없다는 것을 표현함.) # cf) 자식들y는 여러개일 수 있어서 index에 놓고, 각 자식들에 대한 부모는 1명밖이다 -&gt; value로서 1개 p = [0 for _ in range(N+1)] # 2. 관계수를 for문에서 바로 받아, 각 관계 -&gt; 부모배열을 채운다. for _ in range(int(input())): x, y = map(int, input().split()) # * 3.우리는 1차원 배열에 [부모만!] 저장한다. # 1 2 중에 1이 부모니까 index 2에다가 1를 저장한다. # cf) 자식들y는 여러개일 수 있어서 index에 놓고, 각 자식들에 대한 부모는 1명밖이다 -&gt; value로서 1개 p[y] = x # 3. A와 B의 공통 조상을 찾기전에, # * A의 조상들을 모두 모은다, B의 조상들을 모은다 -&gt; 교집합? # ** 참고로, A조상을 모을 때는, A자신을 포함해서 A자신 정보, 촌수거리0 부터 시작해서 -&gt; 재귀적으로 (부모, 부모까지거리(+=1)의 정보를 호출해서 담는다. Aa, Ba =[], [] # Aa: A의 조상a, Ba : B의 조상a # * A의 조상들(부모, 부모의 부모.. ) 모으는 과정에서, A와의 촌수도 같이 튜플로 저장하기 위해 Ad, Bd = 0, 0 # 1) 자신x&lt;-부모p[x]로 업데이트하여, 부모의 부모도 다음번에 찾아가게함 # 2) 자신&lt;-부모 업데이트할 때, 거리도 +1 업데이트해서, 촌수도 올라가게 함. # 3) p[x] &gt; 0를 while if조건절에 놓아서, p[x]==0 부모가없는 지점까지 올라간다. while p[A]&gt;0: # 3-1) 제일처음에 들어가면, 나와의거리Ad=0인.. 나 자신을 0촌 조상으로 튜플로 넣어준다. (나, 나와의거리) Aa.append( (A, Ad)) # 3-2) 재귀적으로 내가 부모가 되도록 업데이트해서, # while p[updated A]부모의부모가 있다면 -&gt; (나 updated A=부모, 전보단 늘어난 거리updated Ad +1) # 을 조상으로서 재귀적으로 모아준다. Ad+=1 A = p[A] # 내가 내 부모가 된다. for 다음단계를 위한 업데이트 # * 부모가 없는 p[A]=0의 root node도 넣어줘야한다... root node가 공통조상이 될 확류은 높다. # - 현재 p[A]==0상태이며, 첫 0이라서.. 루트노드로 업데이트된 것 일 것이다.. 마지막에 한번만 넣어주자. Aa.append((A, Ad)) # 4. B도 마찬가지다. while p[B]&gt;0: Ba.append( (B, Bd)) Bd+=1 B = p[B] Ba.append((B, Bd)) # print(p) # * 5. 2개배열을, &lt;2중 포문&gt;으로 1:1매칭 해보면서, 튜플 (조상, 촌수) 중 조상이 같을 때를 찾늗나. # -&gt; 조상이 같은 순간에서 촌수를 더해버리면 된다. for i in Aa: for j in Ba: # 여기는 Aa, Ba 조상들의 1:1매칭 공간 if i[0] == j[0]: print(i[1]+j[1]) # 등장하면, 제일 빠른 것을 만난 순간 바로 프로그램을 종료하면 된다. exit() else: print(-1) . | . | 나가는 간선외 들어오는 간선(indegree)까지 있으면 Graph . 그래프는 2가지 저장방법이 있음 . 인접행렬 : 행: 출발점 -&gt; 열: 도착점을 나타내는 N by N행렬 . 인접행렬도 3가지가 있음. 노방향 | 방향 | 방향+가중치 | . | . | 인접 리스트 : 튜플로 갈수 있는 (가중치, 노드) list를 인접한 list에 저정함. . 1의 indegree는? 0 (들어오는게 없다) . | 1의 outdgree는? 3 (3개가 나간다.) . in, outdegree가 중요한 이유는 indegree가 0인 지점이 시작점 일 될 수도, 한붓그리기 는 짝수여야한다. 등의 규칙이 있음 | . . | . | 이렇게 그래프를 저장하면, 최단거리나 가중치를 고려한 최소비용 등을 계산할 수 있게 된다 . | . | . | . 규칙적용된 tree인 이진트리로 heap/bst . 이진트리: Tree구조 자체가 graph만큼 어려워서 규칙을 정했는데 Tree의 rootnode가 1부터가 시작 | 자식은 최대2개로 하여-&gt;왼쪽자식node == 부모node의 2배가 너넘버링된다. 나node//2 는 부모node | . | | heap: NlgN으로 정렬을 유지하면서 데이터 pop/push가 가능하다. 그림 출저 | . | bst: python에서는 set, dict의 key를 원소-&gt; hash값 -&gt; hash값들을 bst 구조로 만들어 내부에서 사용되어 중복안되고 bst로 검색해서 빠르다? | . 그래프, 일반Tree, 점, 격자판 다 탐색하는 DFS와 BFS . DFS 전수조사시 사용되하는데, 1-&gt;0 마지막 탐색지점에서 빽할 때, 직전 node가 필요한데, 직전node를 stack 선언후 쌓아두는게 아니라, 재귀를 이용해서 stack을 자동 사용한다. 재귀함수=함수=stack메모리에서 관리되어 stack처럼 쓰임 | . | . | BFS 시작좌표(시작점, root node)에서 시작하여 level별 = 최단거리별 기록하기 위해 queue(deque)을 사용한다. 목표좌표가 나타나는 최단거리(level)을 구하거나 | 해당 level이 끝났을 때 최단거리의 수? | . | level별로 좌-&gt;우순으로 검색한다. | queue에 시작좌표를 넣어놓고 빼고 -&gt; (목표좌푠지확인) -&gt; 자식들 탐색 -&gt; 검사 -&gt; 넣기전 자체처리 -&gt; queue에 넣기 -&gt; (level별 시행시 L+=1) | . | . | . | 2개의 사용차이 찾는 범위가 국한되어서 n번안에 찾아지는 것이 확신을 할 수 있을 경우 -&gt; BFS 숨바꼭질2 | . | 모든 범위를 찾아봐야 하는 경우(매 탐색마다 1-&gt;0 바뀌는 끝을 찍어야하는 경우?) -&gt; DFS 단지번호 붙이기 | . | | . 앞으로 공부하는 방법 . 많이풀기 삼성은 DFS, BFS 30문제정도 | 카카오는 Trie를 포함해서 30문제정도 | | 암기하기 이해로는 X 많이 쓰면서 암기하는 과정이 필요하다. | 자기만의 템플릿이 있어야 한다. | | 주기적 체크하기 대회? | 안내서 노션 | |",
            "url": "blog.chojaeseong.com/algorithm/2021/10/17/sktacademy_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_python_%EB%AC%B8%EB%B2%95TIP.html",
            "relUrl": "/algorithm/2021/10/17/sktacademy_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_python_%EB%AC%B8%EB%B2%95TIP.html",
            "date": " • Oct 17, 2021"
        }
        
    
  
    
        ,"post32": {
            "title": "협업1) 나혼자 투컴으로 협업",
            "content": "나혼자 투컴협업(local to remote to local2) . Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . local to remote . 이미 로컬에서 관리하던 프로젝트를 github로 . local에서 작업시작 . 폴더 생성: . /home/is2js/workspace/git-github . | git init . | 계정입력(이미 global로 했으면 안해도됨) . | 파일 생성 . cat | mouse | . | 커밋 . ❯ git add -A ❯ git commit -m &quot;FIRST COMMIT&quot; . | . | 혹시나 연결된 원격레포가 있는지 확인 . git remote 아무것도 안뜨면 없는 것 | . | . | 깃헙 레포 생성(git-github) for 로컬을 원격으로 . readmd 등 생성하지 말아야함! 이미 local에서 git으로 관리하고 있던 프로젝트를 올리는 것이므로 아무것도 없어야함. | 아무것도 코드가 없을 때 나타나는 화면이 나와야함 | 구성 : https://github.com/is2js/git-github.git githuburl + /유저명/레포명.git | . | . | . | git status로 현재까지의 상황이 다 커밋되어있는지 확인한다. . ❯ git status On branch master nothing to commit, working tree clean . 빠진게 있으면 전부 add -A해서 commit | . | 로컬내용을 빈 원격레포에: git remote 등록 git push 내용옮기기 . 원격레포에 코드가 없을 경우 뜨는 페이지에서 …or push an existing repository from the command line 란을 복사버튼을 눌러서 . 현존하는 로컬 깃관리 레포를, 원격레포에 push하도록 복사한 내용을 cli에 붙혀넣기 해준다. . 현재는 코드가 main브랜치를 만들고, main 브랜치로 push하도록 변경되어있다. . | 복붙후 내 로컬도 main브랜치로 바껴있다. . | 아예 master브랜치 -&gt; main브랜치로 브랜치이름변경하는 명령어 인가보다. . git branch -M main . With a -m or -M option, will be renamed to | . &gt; git branch * main (END) . | . &gt; git remote add origin https://github.com/is2js/git-github.git git branch -M main git push -u origin main Counting objects: 4, done. Delta compression using up to 12 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (4/4), 273 bytes | 273.00 KiB/s, done. Total 4 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-github.git * [new branch] main -&gt; main Branch &#39;main&#39; set up to track remote branch &#39;main&#39; from &#39;origin&#39;. . | 이 때, 명령어를 뜯어보면 . git remote add origin https://github.com/is2js/git-github.git . git remote add [원격레포의 별칭, default origin] [레포 url]로서 원격레포url의 원격레포를 별칭(origin)으로 등록 | . | git branch -M main . 브랜치명을 main으로 변경 | . | git push -u origin main . git push -u [등록된 원격레포별칭, default origin] [올릴 원격레포의 branch] | . | 이후 나오는 메세지 중 현재 main브랜치가 , 원격레포인 origin의 원격 브랜치main을 추적한다.고 메세지가 뜬다. . Branch &#39;main&#39; set up to track remote branch &#39;main&#39; from &#39;origin&#39;. . | . | git remote명령어로 실제로 연결이 잘되었는지 확인 . ❯ git remote origin . | . | 빈 원격레포에, 관리되던 로컬 프로젝트 내용이 올라갔다면, 레포의 기본페이지가 바뀐다. . 커밋내용은 로컬에서 커밋한 기록들이 다 뜬다. | . | 소스트리에서 해보기 . 소스트리로 해당 레포 열기 | 저장소탭 &gt; 원격 설정 클릭 현재 나는 이미 터미널로 연결된 상태라, 원격 저정소 경로에 하나가 추가 되어있다. | . | 추가 클릭 원격 이름: 원격url의 원격레포에 대한 별칭, default origin | URL/경로: 원격레포의 url 복붙 | 호스트 종류: github | 사용자명: github id 입력 | . | 원격 탭에서 원격레포의 별칭(주로 origin)으로 확인하기 . | push버튼 클릭 로컬 / 원격(리모트) 브랜치를 각각 선택해주고 push해주자. | . | 파일추가(수정) 후 commit까지 한 뒤 push: git push [원격레포별칭] [그 레포의 브랜치] . dog파일 추가 . | git add - A, git commit -m , git push [원격레포별칭, 주로origin] [그 레포의 브랜치] . ❯ git add -A ❯ git commit -m &quot;ADD dog&quot; [main 15a73f6] ADD dog 1 file changed, 1 insertion(+) create mode 100644 dog ❯ git push origin main Counting objects: 3, done. Delta compression using up to 12 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 302 bytes | 302.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-github.git d33f3a8..15a73f6 main -&gt; main . | 올릴필요가 없거나(코드로 자동생성) 올려선 안되는 파일(DB계정 등)처리: .gitignore . 올릴 필요가 없는 파일 : 코드로 자동 빌드되는 파일들 그 때 그 때 실행해서 만들면 되므로 올릴 필요가 없다. 안드로이드나 스프링 등에서 처음부터 골격이 세팅된 체 시작하는 프로젝트들을 생성하면 .gitignore가 미리 만들어져있다!! | . | . | .gitignore에 등록하면 add + commit의 대상으로 안봄. 버전관리 안됨. | . | . 프로젝트폴더 최상위 공간안에 .gitignore파일 생성 . 숨김파일로 지정되니 참고해야함 | . | gitignore에 넣을 파일 secret-animal을 만들고, git status로 상황을 확인하자. . Untracked files(add해야할 목록)로서 아직 add안된 파일 2개를 알려준다. . Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) .gitignore secret-animal . | . | 이 상태에서 secret-animal 파일을 .gitignore에 적으면, git status상 add해야하는 파일에서 제외된다. . 아하~ 아예 add할 파일로조차 보지도 않음. | 내 프로젝트에 있어도 add + commit을 안하므로 push도 관리도 안됨. | . Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) .gitignore . | remote to com1,2 . 원격repo를 현재폴더에다가 가져오기: git clone [url] . . 1개 컴으로 연습하려면, 폴더 2개를 만들어서 해보면 된다. . . 일단 폴더 2개를 만든다 computer-1 | computer-2 | . | 참고) clone시 해당목적지 폴더로이동 &gt; git clone [url] [.] | 소스트리는 해당 목적지폴더 선택만 | . | . | . 컴퓨터1의 폴더를 vscode로 연 다음, 터미널도 켠다. . 윈도우탐색기 &gt; wt -d . &gt; code . &gt; ctrl + ~ + wsl로 repoen? 윈도우 통해서 들어가면.. vscode wsl원격버전이 안켜진다. | . | wt &gt; wsl &gt; 해당폴더로 이동 &gt; code . | . | 기존 작업하던 원격레포(git-github)의 url를 복사한 뒤, vscode 폴더 터미널에다가 git clone한다. . #git clone [url] [.] git clone https://github.com/is2js/git-github.git . . 만약, clone시 [.] 현재폴더 옵션을 안주면, 그 내부에 폴더를 새롭게 만들어버림 . 새로운 컴퓨터의 로컬폴더 컴퓨터-1에다가 원격repogit-github의 내용을 가져왔다. | . | . | 연결된 나의 원격repo가 아니라 아무 원격repo를 클론해오더라도 git log로 모든 작업내역을 볼 수 있다. . git log . | 이제 소스트리로 컴퓨터-2 로컬폴더로 clone해보자. . + (new) tab &gt; Clone &gt; . 소스경로/URL : 원격레포url | 목적지 경로: computer-2폴더 지정 git clone 시에는 [원격레포url] [.] 현재폴더로의 옵션을 붙혀줘야하지만, 소스트리에서는 안해주고 폴더만 선택해주면, 그 폴더로 다 clone | . | . . | 이제 컴퓨터-2도 vscode로 열자. . | . | 새로올린(뒤쳐진) 커밋 내역 자동 확인: git fetch + git status . 컴1작업 -&gt; 원격레포에 push -&gt; 컴-2에서 일일히 작업내역을 확인하지 않고, git fetch로 뒤쳐진 내역이 있는지 확인 컴퓨터1 | 컴퓨터2 | . | . 컴1에서 dog name을 수정하고, add, commit호 원격레포에 push까지 해보자. . local의 global계정이 내 계정이라서 그런가 바로 push된다. . ❯ git add -A ❯ git commit -m &quot;EDIT dog&quot; [main 1eaa722] EDIT dog 1 file changed, 1 insertion(+), 1 deletion(-) ❯ git push origin main . . | . | 이제 컴2에서 일일히 github에 새로 올라운 커밋내역을 확인하기 힘드니 git fetch로 뒤쳐진==새로올라온 커밋의 갯수를 확인한다. . ❯ git fetch ❯ git status On branch main Your branch is behind &#39;origin/main&#39; by 1 commit, and can be fast-forwarded. (use &quot;git pull&quot; to update your local branch) nothing to commit, working tree clean . 원격레포/main 브랜치에비해, 내 브랜치가 1개 커밋 뒤쳐져있다고 나온다. | . | 뒤쳐진 내용 받아오기: git pull [원격별칭] [브랜치명] . 컴2에서 뒤쳐진 1개의 커밋을 받아온다. . &gt; git pull origin main From https://github.com/is2js/git-github * branch main -&gt; FETCH_HEAD Updating 15a73f6..1eaa722 Fast-forward dog | 2 +- 1 file changed, 1 insertion(+), 1 deletion(- . . | 소스트리에서도 git pull을 하기위해 . 컴2에서 dog 이름 수정 . | 소스트리 컴2에서 커밋과 동시에 push . . | 소스트리에서 컴1 폴더를 add . | 컴1폴더에서 패치버튼 선택 &gt; 모든 원격저장소에서 가져오기 선택 . . | main 브랜치에 당겨올 것들이 있다고 메세지가 뜸 . | pull버튼으로 받아오기 . | . | 일단 작업전에 메세지 안떠도 pull부터 누르고 시작하자 . 나혼자 투컴협업 branch, conflict . 브랜치를 이용해서 투컴협업 . 브랜치 전환, 없으면 생성해서 : git checkout -b [브랜치명] . branch기본 생성 : git branch [이름] | 전환 : git checkout [이름] | . | 브랜치 생성과 동시에 전환 git checkout -b [이름] checkout은 커밋id, 브랜치, tag 다되므로.. -b옵션을 주면 브랜치전환인데, 없으면 생성까지 | . | . | . 컴1에서 my-idea 브랜치 생성 . git checkout -b my-idea . . git branch . | my-idea이라는 평행우주에서 파일을 수정하고 add commit까지 한 뒤 push할 준비를 해자. . mouse 삭제 . | dinosaur 추가 . ❯ git add -A ❯ git commit -m &quot;ADD dino&quot; [my-idea e43a292] ADD dino 2 files changed, 1 insertion(+), 1 deletion(-) create mode 100644 dinosaur delete mode 100644 mouse . | . | 새로운 브랜치(평행우주)를 push: git push [origin] [새로운 origin의 브랜치명] . my-idea 브랜치를 -&gt; origin의 특정브랜치로 생성해서 push할 수 있다. 하지만 보통은 원격레포에 로컬과 같은 브랜치명으로 생성해서 올린다. | . | . 컴1의 my-idea브랜치와 동일한 이름으로 원격레포의 브랜치를 생성해서 push까지 해보자. . ❯ git push origin my-idea Counting objects: 3, done. Delta compression using up to 12 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 304 bytes | 304.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) remote: remote: Create a pull request for &#39;my-idea&#39; on GitHub by visiting: remote: https://github.com/is2js/git-github/pull/new/my-idea remote: To https://github.com/is2js/git-github.git * [new branch] my-idea -&gt; my-idea . **new branch로서 [로컬my-idea] -&gt; [원격my-idea]으로 push했다고 나온다. ** 즉, 로컬의 평행우주를 push한다고 해서 1:1대응 되는 것이 아니라 원격의 원하는 이름의 평행우주를 만들어서 push하는 구나. | . | . | 원격레포에서 새로운 브랜치(평행우주)가 생성되었고, push도 되었으니 PR를 고려해보라고 메세지가 뜬다. . . my) PR는 push된 임의의, 새로운 평행우주를 기본branch로 합치겠습니까? 정도이다. | 브랜치를 바꿔서 들어가보면, **새로운 평행우주가 로컬-컴1의 my-idea그대로 ** 펼쳐진다. | . | 원격레포의 새로운브랜치를 받는 방법은 [브랜치 생성&amp;전환명령어] 응용: git fetch -&gt; git branch -a -&gt; git checkout -b [생성할 로컬 브랜치(결국엔 뒤에 기입한 원격브랜치를 받아올 브랜치)] [origin(별칭)/pull해올 원격 브랜치명] . git checkout -b [생성할브랜치(결국엔 뒤에 기입한 원격브랜치를 받아올 로컬 브랜치)] [origin(별칭)/pull해올 원격브랜치명] 브랜치 생성&amp;전환 명령어로 원격레포브랜치를 pull까지 해버린다. | git checkout -b : 생성과 동시에 전환 | [생성할 로컬 브랜치(결국엔 뒤에 기입한 원격브랜치를 받아올 로컬 브랜치)] : 아직 원격이 새 평행우주(branch)가 없는 로컬에서, 받아줄 브랜치(평행우주)를 지정한다. | [origin/pull해올 원격브랜치명] : 원격레포 속 받고 싶은 평행우주 | . | 컴2에서 원격레포의 새로운브랜치(평행우주)를 받아보자. 굳이 main에 합쳐진 것이 아니어도 받아서 사용해도 된다. | . | . 컴2에서 로컬용 git branch에 -a옵션까지 더해서 원격 브랜치도 확인한다 . git branch -a * main remotes/origin/HEAD -&gt; origin/main remotes/origin/main . 원격branch는 github의 소식을 업데이트를 해줘야한다 | . git fetch git branch -a * main remotes/origin/HEAD -&gt; origin/main remotes/origin/main remotes/origin/my-idea . 원격레포의 (HEAD, default 작업장소)가 보는 곳은 아니지만 밑에 새로운 평행우주가 추가되었음 | . | 원격레포의 새로운 평행우주(my-idea)를 컴2의 my-dea로 받아와 보자. . 브랜치 생성&amp;전환명령어로 원격레포브랜치를 pull까지 해버린다. | . #git checkout -b [로컬브랜치명] [origin/원격브랜치명] ❯ git checkout -b my-idea origin/my-idea Branch &#39;my-idea&#39; set up to track remote branch &#39;my-idea&#39; from &#39;origin&#39;. Switched to a new branch &#39;my-idea&#39; . git branch로 확인해보자. . main * my-idea . | . | 소스트리로 컴2:new브랜치생성 to 원격 to 컴1으로 넘겨보기 . 이번엔 소스트리로 컴-2에서 브랜치를 생성후 원격레포에 생성과 동시에 PUSH . 브랜치 탭 &gt; 새 브랜치 : my-another-idea . | cat이름을 nyang으로 변경 . | 커밋과 동시에 origin푸쉬 by 소스트리 . . 만약 소스트리가 아니라면? . ❯ git add -A ❯ git commit -m &quot;EDIT cat name&quot; ❯ git push origin my-another-idea . push origin은 없으면 해당 브랜치 생성해서 push한다. | . | . | 깃허브에서 branch 생성 확인 . . | . | 컴-1의 소스트리에서 컴2-new브랜치(my-anther-idea)받아보기 . **컴1의 소스트리 &gt; 원격 탭 클릭 &gt; 원격의 새 브랜치 더블클릭 &gt; 새 브랜치로 체크아웃 ** . . | **원격 브랜치의 체크아웃만으로 로컬의 새브랜치를 생성 및 가져온다. ** . 따로 pull의 과정이 없는 것이 cli 든 소스트리든 마찬가지다 | . | . | my) 새 브랜치는 pull이 아닌 [checkout -b]만으로 로컬에 새 브랜치를 생성 및 내용을 가져온다. . 로컬 컴1-main에 브랜치들 merge(자동커밋)후 push -&gt; 컴2에서 fetch로 확인후 받아오기 . 컴1에서 브랜치병합후 원격레포에 push해보자. | . main(master)로 이동(받는놈) . | 주는놈인 my-another-idea 우클릭 &gt; 병합하기 . 현재 브랜치로 (주는놈) 병합 | . | push할 커밋수 확인해보기 . 병합전: main옆에 1은 push할 커밋수다. . . | 병합(자동커밋!)후: main2로 push할 커밋 1개 늘어남. . | . | 병합된 내역(커밋)까지 컴1 -&gt; 원격 레포에 소스트리로 push . push버튼 &gt; 병합된 내역 push | . | 이제 컴2의 소스트리에서 fetch로 원격상황 받아오기 . main브랜치에 pull받을 것들이 있다고 업데이트된다. . . | main으로 이동후 pull받아오기 . | . | ### . 충돌해결로 협업 . 한쪽에서 파일1을 수정해서 push했는데 . 다른쪽에서 파일1을 pull받지 않은 상태로 수정후 로컬커밋한 상태 . . | 다른쪽에서 pull받아야하는데, 같은파일이 수정된체 커밋된 상태면, conflict . . | . | . 직접 충돌내보기 . 컴1에서 dog파일 수정, 커밋, push . 한쪽 수정(bark: wang wang)이 push한 상태 . ❯ git add -A ❯ git commit -m &quot;EDIT dog bark wang&quot; ❯ git push . | . | 컴2에서 pull 받지도 않은 체 dog파일 수정후 커밋 . 다른 쪽이 pull안한체로 수정후 커밋한 상태 . ❯ git add -A ❯ git commit -m &quot;EDIT dog bark warl&quot; . ❯ git push To https://github.com/is2js/git-github.git ! [rejected] main -&gt; main (fetch first) error: failed to push some refs to &#39;https://github.com/is2js/git-github.git&#39; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., &#39;git pull ...&#39;) before pushing again. hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details. . pull할게 있으면 push가 안된다. | . | . | push가 안되면 . 원격에 누가 새 작업을 올렸구나. pull부터 받자라고 생각 . ❯ git pull . | . | pull받았는데 conflict나면 . 저쪽에서 같은 파일 수정했구나 ㅠㅠ라고 생각 . | git status로 더 자세한 상황을 보자. . ❯ git status #... both modified: dog #...저쪽과 나 모두 dog파일을 수정했네.. . | vscode에서 처리하기 . HEAD : 내가 작성한 부분 . | ===아래부분 : 저쪽이 작성한 부분 . . | . | . | conflict 후에는 git commit 을 -m 없이 커밋하여, 충돌 메세지를 그대로 저장하도록 한다. . git add -A git commit . git push해서 수정본을 원격레포로 보낸다. | . git push . | 브랜치삭제, 원격브랜치삭제: git branch -d vs git push -d [origin] [원격브랜치] . git branch 목록보기 . git branch -a . | 로컬 삭제 &amp; 원격 삭제 . 로컬 : git branch -d [브랜치명] | 원격 : git push -d origin [브랜치명] | . ❯ git branch -d my-idea Deleted branch my-idea (was e43a292). ❯ git push -d origin my-idea To https://github.com/is2js/git-github.git - [deleted] my-idea . | 소스트리로 충돌만들고 해결해보기 . 충돌일으키기 : pull받기 전, 같은 파일 수정후 로컬 커밋 push하면 충돌 발생 | 소스트리는 커밋과 동시에 push하므로 커밋당시에 발생 | . | 서로 다른브랜치(평행우주)라도 같은파일 수정상태면 conflict남 | . pull받기전에, 저쪽에서 수정한 파일을, 나도 수정한 뒤 소스트리로 커밋&amp;push를 눌러본다. 커밋은 성공했다고 따로 메세지 뜸. | . | push시 에러 -&gt; pull받자 -&gt; conflict뜨면? -&gt; 같은파일수정했네 pull을 했더니 소스트리에서 conflict를 알려준다. | . | **파일상태 탭으로 가보면, ** 충돌파일은 아직 add되지 않은 unstaged된 파일로서 존재 | 충돌파일 클릭시 충돌내용이 vscode처럼 나옴 | 충돌 커밋메세지는 자동 작성되어있음 cli라면 git commit만 하란 소리 | . | . | 직접 에디터(vscode)로 가서 수정해줘야한다. | 다시 소스트리로 와서 add후 커밋&amp;push | my) push에러 -&gt; pull받자 -&gt; conflict -&gt; 같은파일 수정했네. .",
            "url": "blog.chojaeseong.com/git/2021/10/16/%EA%B9%833_%EB%82%98%ED%98%BC%EC%9E%90%ED%88%AC%EC%BB%B4%ED%98%91%EC%97%85_branch_conflict.html",
            "relUrl": "/git/2021/10/16/%EA%B9%833_%EB%82%98%ED%98%BC%EC%9E%90%ED%88%AC%EC%BB%B4%ED%98%91%EC%97%85_branch_conflict.html",
            "date": " • Oct 16, 2021"
        }
        
    
  
    
        ,"post33": {
            "title": "심화) vscode로 git 심화 학습",
            "content": "Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . 깃 기본 with vscode . extension 2개 설치 . git extension pack | git extension pack 검색후 설치 | gitlens와 gitignore가 동시에 설치되어진다. | 왼쪽메뉴에 소스제어 를 클릭하면, gitlens가 통합되서 나온다. | 설정 &gt; git enable이 활성화 되어있는지 확인한다. . | gitlens layout 수정 . gitlens를 왼쪽메뉴에 따로 보이게 되었는데, 설명서를 읽으니 gitlens.setViewsLayout 검색 &gt; default로 클릭해야 source control탭에서 통합해서 볼 수 있다. | . | _git history는 팔레트에서 git log를 검색해서 사용 | . markdown all in one | markdown all in one검색 후 설치 . gitignore (팔레트커맨드) . add전에 설치된 gitignore를 사용하기 위해서ctrl+shift+p(모든 명령어, 팔레트)에서 gitignore를 검색하여, add ignore를 클릭 이후 python 을 검색해서 선택 -&gt; 파이썬을 제외시키는게 아니라 python관련 불필요 파일들이 등록이 된다. | create .gitignore가 생성되었다고 뜬다. | . | 소스제어에서, gitignore도 뜨는데, [파일열기]버튼이 따로 있다. . | python프로젝트를 선택하더라도 .vscode/폴더를 맨끝에 추가해준다. . .vscode로 달아도 되지만, 폴더라서 마지막에 슬래쉬도 넣어준다. | . . | . add remote(팔레트커맨드) . 빈repo를 생성 . readme파일만 체크해서 생성( 첨부터 push안되게 충돌내기 위함. ) | . | &gt; add remote 후 repo 선택 . 주의 [remote name]: origin으로 기본적으로 설정한다!!! . | 참고) add remote를 2개 했다면? git remote + remove [remote name] . | . | git config --list로 연결된 원격레포의 주소 확인하기 . | add, commit, and push in commits . U 파일들에서, +버튼을 눌러 add시키면, staging된 변경사항으로 이동한다. . | commit은 상단의 [소스제어]에서 체크버튼으로 staging된 변경사항을 한번에 다 commit시킨다. . | [commits] 탭 push를 클릭했다. . 해당 repo에서 push내역을 확인 | . . | . pull(명령어) 및 이질적인 프로젝트 병합 허용(–allow-unrelated-histories) . git pull origin main . 현재 remote가 빈 레포가 아니므로, push가 바로 안됨 . readme.md가 있기 때문에 pull당겨와서 충돌해결하고 해야함. . fatal: refusing to merge unrelated histories . | 이건 뭔짓을 하더라도 안됨. 따로 설정하면서 pull을 해줘야한다. . | . | . git pull origin main --allow-unrelated-histories . push . 갑자기 commits탭에서 사라져서.. 그냥 . vscode 작업표시줄을 클릭하여 push . | F1(팔레트)열고 git push검색해서 push . 해도 됨 . | . . | . [개념] branch (실무 많이) . main은 항상 deploy상태로 유지 | topic branch = 수정용 브랜치 = push해서 PR하는 브랜치 push를 자주해서 날라가는 것을 방지하자. | 검토후 merged(PR)후에 바로 삭제하는 브랜치 | . | develop branch는 삭제안한다. | main브랜치는 항상 최신으로 유지하므로 각 기능별 브랜치는 main에서 딴다. | [실습] branch(명령어) . . from-br없이 브랜치를 따면, 현재 브랜치에서 따는 것이므로 git branch명령어를 확인하고 따자. git branch new-br from-br | git branch git branch new-br | . | . | -로 직전브랜치를 checkout할 수 있다. . | checkout -b [new-br] [from-br]로 생성하면서 동시에 브랜치를 변경하게 되므로 가장 자주 쓴다. . git branch testbr main git branch * main testbr git checkout testbr Switched to branch &#39;testbr&#39; git branch main * testbr git checkout - Switched to branch &#39;main&#39; Your branch is up to date with &#39;origin/main&#39;. git branch * main testbr git checkout -b work main Switched to a new branch &#39;work&#39; git branch main testbr * work . | . git merge 와 fastforwad . 그림 출저 | . . merge commit은 서로 다른 상태의 브랜치를 병합해서 새로운 commit을 만드는 경우이고 . fast forward는 동일 내용이 포함되는 브랜치일 경우 브랜치 이동만으로 병합해서 따로 commit을 생성하지 않는 경우입니다. . | . topic branch(작업용브랜치) main에 merge후 삭제: git merge –no-ff / git branch -d . 현재 브런치 목록 . main testbr * work remotes/origin/main . | . work를 토픽브랜치라 가정하고 파일 work.py생성 후 커밋 . | main으로 돌아오면 당연히 파일이 없음. . | main에서 merge했다는 커밋을 남기면서(--no-ff) work브랜치를 받아오자. . 파일의 변화가 차이밖에 없는 경우. HEAD만 이동시키는 merge는 커밋이 발생안하고 앞으로 이동만 -&gt; fast forward가 발생하는데, 여기서는 직접 merge 메세지도 남긴다. | . ❯ git merge --no-ff work . | merge의 log확인을 git history라는 익스텐션으로 해보자. . 나는 git graph라는 익스텐션도 보인다. . . git history . | git graph . . | git log –oneline –graph 의 명령어 . . | . | . | merge확인후 topic branch삭제 . ❯ git branch -d work Deleted branch work (was cbf2765). . | git 탭에서 브랜치 변경후 개별커밋들 확인 . . 해당브랜치 화살표누르면 switch (checkout 됨) . | 왼쪽 화살표를 누르면, 각 브랜치마다 커밋 목록이 보인다. . 브랜치 생성이전 main브랜치 커밋이 그대로 보이는 듯함. | . . | testbr에서만 파일 생성후 커밋해보자. . testbr이 위로 올라왔다. branch 생성이후부터 달라진 커밋 차이가 난다. | . | . | [중요] topic branch에서 [다른topic이 merge된 main] 의 파일 1개만 받아오고 싶다면: git checkout -p . testbr에서 main속 work.py를 가져오고 싶다면 . git checkout -p [가져올브랜치명] [가져올파일명]을 이용한다. wsl2에서 안되서 windows 상태에서 하니깐 됬음. | . | . | . ​ 1. git checkout -p main work + y 로 main브랜치의 work.py를 가지고 온다. . ❯ git checkout -p main work.py diff --git b/work.py a/work.py new file mode 100644 index 0000000..e69de29 (1/1) Apply addition to index and worktree [y,n,q,a,d,?]? y . 현재 상태를 보면 add까진 된체 로 온다. add전후 살펴보는 git status로 봐도, 이미 Add는 되어있다. | . | work.py에 내용을 조금 넣어주고 commit하자. | 직전 commit의 메시지 변경: git commit –amend . git commit --amend를 치면, 직전 commit에 대한 메세지 수정사항이 editor 로 열린다. | git commit --amend . 메세지를 저장하면 자동으로 반영되어진다. . | 참고 . 마지막 커밋A에 일부만 빠졌다? 3을 빼고 1,2만 add 및 커밋한 상태 | 3을 git add한 뒤 git commit --amend | . | 그냥 커밋메세지만 변경 git commit --amend -m &quot;메세지&quot; | . | . | HEAD포함 n번째[에] commit 합치기or삭제 등 commit history 조절: git rebase -i HEAD~[숫자] -&gt; fixup or squash . HEAD~ = HEAD~1 HEAD포함 HEAD1개 전 ~1 = HEAD^ : 헤드의 부모, 헤드의 1개전 | . | . | rebase는 명령어로 하는게 더 빠르고 쉽다. | . . commit 1개당 1개의 의미를 가져야하나, 의미가 없는 커밋들을 하나로 합칠 때 , git rebase -i HEAD~ + [합칠 커밋갯수] 이후에 fixup: (귀찮아서) HEAD포함 n번째커밋에 커밋합치면서 n번째 커밋명으로 커밋합침 | squash: (새로운커밋명을 위해) HEAD포함 n번째커밋에 커밋합치면서 + 새로운 커밋명으로 합침 | 그외 reword(= amend), drop 등: 사용안한다. | . | . 커밋을 1111,222,3333333,4444,55555 5개를 새로 만들자 . | git rebase -i HEAD~[head포함 합칠 커밋갯수 &amp; head에서 뒤로 2칸 간 곳에서 합쳐짐.]을 커맨드로 입력한다. . ❯ git rebase -i HEAD~2 . . 여기서 커밋메시지 같은 git-rebase-todo 메세지에서 pick대신 fixup을 적어서 뭉개자. 최근커밋인 5555(HEAD)를 fixup으로 뭉개서 저장시키면 된다. | . | . 따로 뭔가 뜨지 않으면 .git &gt; rebase-merge &gt; git-rebase-todo를 클릭한다. . | 도착지(HEAD포함 n번째 커밋)는 선택지가 없다. . 최근 것이며 뭉개지는 HEAD는 선택지가 있다. . 여기서 fixup을 선택하면, 귀찮게 새로운 커밋메세지를 작성안하고 n번째 커밋명을 이용하게 된다. . . | start rebase를 해서 커밋을 합친다. . | . | . | 이제 444 -&gt;333으로 . git rebase -i . . 최근 것(아래 것)을 pick to squash로 변경해보자. . 과거커밋으로 합치는데 커밋메세지는 새로작성한다는 것이다. . . | 맨 위에 커밋메세지를 적으면 적용된다. . | . | 이미해버린 commit 취소는 직전HEAD로 돌아가면서 취소: git reset –hard HEAD~ . reset은 해당커밋까지가면서 자연스럽게 삭제한다. | . head의 부모로 가면서, head는 삭제 . ❯ git reset --hard HEAD~HEAD is now at 3460720 Merge branch &#39;testbr&#39; of https://github.com/is2js/git-ssac into testbr . . | add(staging) 취소는 아직commit안됬으므로 commit전 HEAD로 돌아가면서 취소: - or git reset HEAD . git extension으로 는 그냥 -버튼을 누르면 add가 취소됨 . | 명령어로는 git reset HEAD로서 . --hard없이 code를 살린체 최근HEAD로 돌아가면 -&gt; add취소가 자동으로 | . . git reset HEAD # HEAD 대문자여야함. . . | . 깃 심화1 with vscode . ### . git tag는 release의 의미를 가지므로 main에서 딴다. tag 혼자 = 커밋의 합 = 강의 n화 | 협업 = topic -&gt; main에서 merge후에 main에서 배포버전으로서 tag를 딴다. | . | . | . merge는 항상 명령어로 –no-ff를 붙여 커밋을 남기자 . --no-ff를 붙이면 fastfoward = 커밋없이 head위치만 바꾸는 것을 안하고 항상 merge커밋을 남긴다. conflict나면, Accept incoming후 git commit만 입력해주면 메세지 완성되어있음. | . | . main브랜치로 넘어가기 . | 명령어로 merge하기 . ❯ git merge --no-ff testbr Merge made by the &#39;recursive&#39; strategy. hello.py | 3 +++ testbr.py | 0 work.py | 1 + 3 files changed, 4 insertions(+) create mode 100644 testbr.py . | merge후 topic branch는 삭제: git branch -d . merge가 되었다면, topic 브랜치 삭제하기!! . git branch -d testbr Deleted branch testbr (was 74296bb). . 만약, fully merge가 안되었다고 뜨면? 대문자 -D로 강제 삭제해준다. . git branch -D testbr . | . | tag 확인 및 생성 in main브랜치:git tag [v0.0.1] . tag는 release될 main브랜치에서 작성한다. | tag는 release단위 = 배포단위로 생성한다. | tag는 소스코드를 push를 해놓은 상태에서 -&gt; tag를 local에서 따고 -&gt;tag를 push한다. | . ❯ git tag ❯ git tag v0.0.1 ❯ git tag v0.0.1 (END) . tag는 commit과 별개로 따로 push: git push origin [tag(=버전)] . git push origin [태그명=버전명] . ❯ git push origin v0.0.1 Total 0 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-ssac.git * [new tag] v0.0.1 -&gt; v0.0.1 . | git repo에, tag가 생긴 것을 우측사이드에서 확인가능 . | code수정 후 commit-&gt;push 끝난 뒤, 따로 tag 따고 -&gt; push . 파일(코드) 수정 . | local git commit . | local -&gt; origin(원격레포)로 push . ❯ git add -A ❯ git commit -m &quot;askldjflkasd&quot; ❯ git push . | commit의 push가 끝난 뒤, tag를 딴다. . ❯ git tag v0.0.2 ❯ git push origin v0.0.2 Total 0 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-ssac.git * [new tag] v0.0.2 -&gt; v0.0.2 . | tag는 과감하게 돌아가기: git reset –hard [태그] . git reset --hard [commit_hash]를 하면 해당 커밋까지 돌아가면서 자연스럽게 그 이후의 내용들은 삭제되었다. 하지만, 태그의 경우, code + commit은 돌아가나 tag는 삭제안되고 남아있다. | . | . ❯ git reset --hard v0.0.1 HEAD is now at bd4c018 Merge branch &#39;testbr&#39; into main ❯ git tag v0.0.1 v0.0.2 . 되돌아가도 tag는 남아있으니 직접 삭제해줘야한다. | . reset tag이후에도 local+remote tag 따로 삭제: git tag -d 태그 / git push origin -d 태그 . 로컬 tag를 삭제한다. . git tag -d v0.0.2 Deleted tag &#39;v0.0.2&#39; (was 476f70b) . | 원격에 남아있는 tag도 삭제한다. . git push origin -d v0.0.2 To https://github.com/is3js/py.git - [deleted] v0.0.2 . | 깃 심화2 with 개념위주 . 실수로 다른브랜치에 커밋or코드의존성때문에 다른사람 커밋이 필요할 때: git cherry-pick 으로 특정커밋만 똑! 가져올 때 . . 코드의존성 . 다른사람 커밋 위에서 일해야하는 경우 ex&gt; 다른사람이 버그고침 -&gt; 나는 그위에서 일을 해야할 때 | . | . | master branch의 cccccccc커밋만 -&gt; my branch로 . 커밋해쉬 앞 7글자 . git cherry-pick ccccccc . . | . | . git reset 총정리(add취소, commit취소) . ADD취소 2가지 . 옵션을 안주면 mixed | . . | 커밋취소 3가지 . HEAD뒤에 눈웃음 한개 ^ --soft : commit만 취소 + add + 내용물 그대로 | (mixed) : commt취소 + add취소 + 내용물만 그대로(unstaged) | --hard : commit취소 + add취소 + 내용물취소 | . | . . | . HEAD와 ^, ~숫자 . HEAD: 로컬 workingDir의 현재 작업중인 커밋 switch하면 작업폴더, 작업하는곳도 바뀌니 head도 바뀐다. | add만 했다면? 커밋이 아직 아니므로 HEAD가 보고 있진 않다. | . | HEAD^: 현재작업중 커밋의 부모커밋 ^^ : 부모의부모 | ~3 : ^^^쓰지말고, 3단계 전 커밋 | . | . 다시git reset HEAD 살펴보기with 돌아가서 자연스럽게 취소 . add 취소 . 커밋이 아니므로, HEAD는 아직 안보고 있다. . | 그래서 git reset HEAD를 하게 되면, HEAD커밋을 삭제하는게 아니라 git reset [여기] = [여기]로 돌아가겠다 = 해당커밋이후로 add는 커밋은 필요없다. 자연스럽게 add를 취소 . . | . | 커밋취소 . git reset HEAD^ 현재의 부모커밋으로 가고 싶다. . | 를 통해서 현재커밋을 취소 . . | . | 작업중에 다른작업요청시 commit도 reset도 애매한 임시저장: git stash . 로그인 브랜치에서 작업중인데, 갑자기 로그아웃 브랜치를 수정해달라고함. . 브랜치를 정리해야지만 브랜치변경이 가능함. 커밋한다음 reset을 해도되긴하겠지만,,, | . | 커밋하기엔 미완성, 작업물을 날릴순 없다. 임시저장으로 정리 | . | 현재 어느정도는 add된 상태 . unstage된 = add되지 않는 파일도 있음. . . | add, unstage 다 합쳐서 사진을 스태시! 하고 찍는다. . git stash . . 커밋이후의 상황들 전체가 stash 바구니에 담기게 됨. . . | . | 바구니에 담기면 사라진다. . | . | git stash pop을 통해 stash바구니에서 꺼내면 다시 적용된다. . . stack처럼 pop으로 나온다. | . | git stash, git stash pop 이외에 git stash list도 있다. . | . 마지막 커밋 변경(내용추가, 메세지변경): git commit –amend . . 마지막 커밋A에 일부만 빠졌다? 3을 빼고 1,2만 add 및 커밋한 상태 | 3을 git add한 뒤 git commit --amend | . | 그냥 커밋메세지만 변경 git commit --amend -m &quot;메세지&quot; | . | . merge말고 1줄로 합치는데, 상대주는놈branch 위에 올려서 합칠 때:git rebase . 내 브랜치들을 주는놈branch 위에서 적용시키고 싶을 때 . 최근브랜치가 내꺼가 되면서, 내가 주는놈 위에 적용됨. | . . . | 주의할점으로, 주는놈위에 쌓아올려질 때, 그대로 가는게 아니라 커밋해쉬가 달라짐 . | . merge vs rebase . . merge와 비교 장점: 커밋해쉬 유지 및 흐름 유지되어 돌아갈 수 있음 | 단점: merge라는 불필요커밋을 생성함. | . | rebase 장점: 주는놈위에 받는놈위주로 정리가 됨. 깨끗한 커밋 히스토리가 됨. | . | . 커밋 합침, 삭제 등 커밋 히스토리 조절: git rebase -i . . pull받은이후 rebase로 커밋해쉬가 바뀌었다면? 어쩔수 없이 git push –force . . remote branch2개를 잘 받아왔다. . | 이후 git rebase(주는놈위에 쌓아서 합침)로 내 커밋해쉬가 바뀌었다면? . . 이 상태에서 git push하면 reject된다. | . | 어쩔수 없이 git push --force로 덮어씌워야함. . | 협업중엔 조심해야한다. . 남자가 rebase후 푸쉬포스로 덮어씌워진다면,, . . | 같은 브랜치 협업중에는 미리 말안하는 이상 rebase 및 push force를 하면 안될듯 . | . | . alias . git push까지 . status diff add cache? commit log | . | git폴더에 . . | 내 환경설정에 . | 참고 . 히데쿠마 설정 . ## alias # git alias gst=&#39;git status&#39; alias gc=&#39;git commit&#39; alias gm=&#39;git merge&#39; alias gr=&#39;git reset&#39; alias ga=&#39;git add&#39; alias gaa=&#39;git add --all&#39; alias gloga=&#39;git log --oneline --decorate --color --graph --all&#39; alias glog=&#39;git log --oneline --decorate --color --graph&#39; alias gco=&#39;git checkout&#39; alias gb=&#39;git branch&#39; alias gcb=&#39;git branch | fzf -m | xargs git checkout&#39; alias gmb=&#39;git branch | fzf -m | xargs git merge&#39; alias gdb=&#39;git branch | fzf -m | xargs git branch -D&#39; alias gp=&#39;git push&#39; alias gf=&#39;git fetch&#39; alias gl=&#39;git pull&#39; alias gd=&#39;git diff&#39; alias ghf=&#39;git ls-files -v | grep &quot;^h&quot; | cut -c3-&#39; # dkr alias dkr=&#39;docker&#39; alias dkrp=&#39;docker-compose&#39; # for docker #sudo mount --bind /mnt/c /c sudo mount --bind /mnt/d /d export DOCKER_HOST=tcp://0.0.0.0:2375 # basic alias dotfiles=&#39;cd ~/dotfiles&#39; alias ll=&#39;ls -al&#39; alias l=&#39;clear &amp;&amp; ls -al&#39; #alias cdd=&#39;cd /d/&#39; alias ws=&#39;cd /d/workspace&#39; #alias solup=&#39;cd /d/workspace/solup&#39; alias echost=&#39;cd /d/workspace/solup/echost&#39; alias 12r=&#39;cd /d/workspace/solup/12r&#39; alias private=&#39;cd /d/workspace/private&#39; alias ..=&#39;cd ..&#39; alias ..2=&#39;.. &amp;&amp; ..&#39; alias ..3=&#39;..2 &amp;&amp; ..&#39; # some more ls aliases #alias ll=&#39;ls -alF&#39; alias la=&#39;ls -A&#39; #alias l=&#39;ls -CF&#39; # Add an &quot;alert&quot; alias for long running commands. Use like so: # sleep 10; alert alias alert=&#39;notify-send --urgency=low -i &quot;$([ $? = 0 ] &amp;&amp; echo terminal || echo error)&quot; &quot;$(history|tail -n1|sed -e &#39; &#39;&#39;s/^ s*[0-9] + s*//;s/[;&amp;|] s*alert$//&#39; &#39;&#39;)&quot;&#39; # for python alias python=&#39;python3&#39; alias pip=&#39;pip3&#39; export WORKON_HOME=~/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=&#39;/usr/bin/python3&#39; # Usage of python3 source ~/.local/bin/virtualenvwrapper.sh # for pyenv export PYENV_ROOT=&quot;$HOME/.pyenv&quot; export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot; export PYTHON_CONFIGURE_OPTS=&quot;--enable-shared&quot; export PYENV_VIRTUALENV_DISABLE_PROMPT=1 if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then eval &quot;$(pyenv init -)&quot; eval &quot;$(pyenv virtualenv-init -)&quot; fi . | . | .",
            "url": "blog.chojaeseong.com/git/2021/10/15/%EA%B9%832_%EA%B9%83%EA%B8%B0%EB%B3%B8(vscode)_%EA%B9%83%EC%8B%AC%ED%99%941(vscode)_%EA%B9%83%EC%8B%AC%ED%99%942(%EA%B0%9C%EB%85%90).html",
            "relUrl": "/git/2021/10/15/%EA%B9%832_%EA%B9%83%EA%B8%B0%EB%B3%B8(vscode)_%EA%B9%83%EC%8B%AC%ED%99%941(vscode)_%EA%B9%83%EC%8B%AC%ED%99%942(%EA%B0%9C%EB%85%90).html",
            "date": " • Oct 15, 2021"
        }
        
    
  
    
        ,"post34": {
            "title": "기본) commit&tag/revert&reset/branch",
            "content": "타인repo를 clone후 commit, tag 코드 옮겨다니기 . 실습레포: /home/is2js/workspace/git-test | Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . commit_hash or tag로 점프: git checkout [hash or tag] . 환경변수를 파악하고 code . . | vscode로 리조지토리 초기화 . | vscode push 버튼으로 올리기 . . | git fetch는 해두는 게 좋다 . 내 repo에 누가 작업을 추가했는지 파악만 해주는 것 | . | 강의별로 commit을 한다면? . 커밋별로 tag를 추가로 만들어준다. . | 예를 들어 . 5화 작업 . 5화 커밋 git tag 5 | . | . | 6화 작업 . 6화 커밋 git tag 6 | . | . | push by vscode push버튼 . . | . | . | git checkout [git_id]으로 5화 이전의 4화로 점프띄어보자. . 4화 부분의 git id 복사 . | 해당 폴더의 vscode 터미널에서 git checkout [git_id] . git checkout fefc0cacbf262ae0794e64a632afa2da095b622a . 이때 brunch자체가 [git_id]로 변하면서 과거로 돌아간다 | . | 현재로 돌아오려면, 기존 branch(master)로 checkout한다 . git checkout master . | . | git checkout [tag명]으로 점프띄어보자 . 각 커밋마다 커밋후 쉬운 이름표인 tag를 만들어준다. . 아까 5화 작업 끝나고, git tag 5 . 5화 끝난후의 소스를 보고 싶을 땐 이렇게 이동한다 . #git checkout [tag명] git checkout 5 . . | . | . | 다 참조가 끝났다면, 다시 최근소스의 branch로 오면된다. . git checkout master . | . | tag는 대신 따로 push를 해줘야한다. . 커밋들을 push한거로는 tag까지 push가 안됨. | . git push --tags . 버튼으로는 잘 안보이고 팔레트 &gt; push 검색 &gt; git push tags를 선택해준다. . | 참고) . 맨첨 커밋에는 0.0.0의 tag를 만들어주고 . | 그 이후로는 1.0.0부터 쭉 만들면된다. . . | . | . | . 내 repo 돌아가기, 되돌리기 . 기본 세팅 . /home/is2js/workspace/git-practice | . 소스트리 설치 . vscode에서는 설정(ctrl+,)에서 exclude 검색후 .git을 삭제하여 보이게 하기 | . | 디렉토리에서 vscode열기 . vscode 터미널 열여서 git설정 저장하기 . git config --global user.name &quot;is2js&quot; git config --global user.name &quot;tingstyle1@gmail.com&quot; . | . | .git폴더를 삭제후 소스트리에서 해보기 . create를 통해 해당폴더를 선택해서 만들어준다. 이미 폴더가 있는데 이 내부에 .git생성할까 물어보면 OK | . | . | 2개의 파일을 만들고 이 상태를 저장하기 . cat | mouse | . | git status(gst)를 통해 아직 untracked 파일들 확인 후 add . git add -A . git status . | 메세지(-m)와 함께 묻기(commit 해주기) git commit -m &quot;First commit&quot; . | 묻은 것을 소스트리에서 확인해보기 . 터미널에서 히스토리 확인하기 git log --oneline . | 소스트리는 git status없이 묻을 파일을 자동으로 알려준다. . vscode도 extensiont쪽에 알려줌? | dog라는 파일을 만들고 소스트리에서 확인해서 add + 커밋까지해보자. | . | . | 파일 삭제 + 변경 + 생성을 한꺼번에 한 뒤 git status로 보자. 삭제+변경과 생성을 따로따로 알려주며 다 알려주긴 한다. | 소스트리도 아이콘으로 알려준다. | . | git log로 이때까지 묻은 캡슐들을 한꺼번에 볼 수 있음. 소스트리에서는 History탭에서 보면 된다. . . | 과감한 돌아가기: git reset [commit_hash] –hard . . 돌아갈때는 과감한방법과 신중한방법이 있다. . 과감한방법(--hard) : 복원이후시점은 완전히 지우겠다. . git log상의 commit_id 앞6글자만 복사후 . | git reset [commit_id] --hard . . | . | 다시 한번 cat삭제 + dog이름변경 + 펭귄추가를 해주고 commit한뒤 소스트리로 reset –hard해보자. . 이 커밋까지 현재브린치를 초기화 | Hard(버림) 선택 | . | . | 신중한방법(--soft): 시점만 돌아가고 + 그 이후는 커밋되지 않은 상태로 파일은 유지 . | . (반대동작으로 취소시켜, 돌아갈 미래를 남긴체) 되돌리기 : git revert . **[reset으로 돌아갈 수 있는 미래]를 남겨두기 위해, [반대동작으로 취소시켜] 되돌리기 ** . | 다시 3번째 커밋까지 만들어준다. | 이번에는 돌아갈시점 6자리 for reset이 아닌 취소할 시점 6자리 for revert를 git log에서 찾는다. 취소할 커밋을 revert(취소)했다는 커밋이 그대로 이어서 남는다. 소스트리를 통해 확인하면, 정확히 취소할 커밋이, 커밋시 수행한 동작을 정확히 반대로 수행하여 취소함. | 취소할커밋이 커밋기록으로 남아있으니, reset --hard(이 커밋까지 현재브런치를 초기화)을 통한 해당 커밋으로 과감하게 돌아갈 수도 있다. | . | . | **즉, [reset으로 돌아갈 수 있는 미래]를 남겨두는 [반대동작으로 취소시켜] 되돌리기 ** | . 가장 최근 것을 revert로 취소시켜보자. . git log . 제일 최근시점을 취소시키기 위해, 최근 커밋(현재커밋) 6글자 복붙 | . | git revert [취소시점6자리] + :wq . 커밋메세지 작성화면으로 들어온다. | 여기선 :wq로 나와야 해당 revert 커밋메세지가 전달된다. | . | 3번째 커밋이 취소된 것을 파일이 reset처럼 과거상태로 돌아감을 보면 알 수 있다. . | git log를 확인해보니, 돌아간시점이후로 가 삭제된 것(reset –hard, 과감한 돌아가기)가 아니라 새 커밋이 형성되었다. . 소스트리에서 보아도 3번째 커밋을 상쇄시키는 커밋이 추가로 발생함 | . . 자세히 보면, 소스트리를 통해 확인하면, 정확히 취소할 커밋이, 커밋시 수행한 동작을 정확히 반대로 수행하여 취소함 3번째 커밋(취소할 커밋) 때 한 동작들 | 4번째 커밋인 3번째 커밋을 취소함(revert)를 할때의 동작들 | . | . | revert를 통해 취소할커밋도 reset-hard와 다르게 기록으로 남아있으니 reset을 통해 취소하기 전의 3번째 커밋상태로 과감하게 돌아갈 수도 있다. . . | 소스트리를 통한 revert는 커밋 되돌리기다. . 역시.. (반대동작으로 취소시켜) 되돌리기 = revert . 커밋 되돌리기 == 반대동작을 통해 해당 커밋을 취소시킴 . . | . | . | 내repo branch(평행우주) 만들기 for 기존플젝에 새로운 도전 . 회사 프로젝트를 내가 함부로 수정할 수 없으니 현재 프로젝트에서 다른 시도를 해보고 싶을 때, branch를 만들어 평행우주로 넘어간다. | . | . 평행우주로 이동도:git checkout [브랜] or 더블클릭 in 소스트리 . 브랜치 생성 . 브랜치 : 현 시점에서 2개의 미래로 분기를 시작하겠다. 현 시점과 동일한 상태 그대로 가져가면서 분기함. | . | . #git branch [만들 브랜치명] git branch my-idea . . 확인은 git branch만 . . | . | 브랜치 이동도 git checkout . 과거로 점프갔다오기 : git checkout [commit_id or tag] . 과거로 돌아가기 : git reset –hard or git revert [commit_id] | . | 과거가 아닌 현재-&gt;다른평행우주(branch)로 이동도 git checkout + 브랜치명 . #git checktout [브랜치명]git checktout my-idea . . branch변경해도, 내 파일상태에는 변함이 없음. 현재 상태를 그대로 가지고 평행우주를 만들어서 | . | . | 데이터 변경 후 커밋하기 in my-idea브랜치 . mouse 삭제, dinosaur 추가 . 용이름 둘리 | . | 현 branch에서 커밋하기 . git add -Agit commit -m &quot;Add dino&quot; . . | . | 상사가 부를 땐, 원래 우주로 돌아간다. . 원래 브랜치는 master였다. . 이동 전 . | 이동 후 (파일이 원래대로 돌아옴) . git checkout master . . | . | git을 처음 배울때는 파일이 잘못될까바 불안해서 사용안할 수도 있는데, 앞으로 계속 사용해보자~ . | . | 소스트리에서 다시 해보자. 더블클릭으로도 우주를 왔다갔다 하며 확인할 수 있다. . 브랜치 부분에 my-idea가 추가됨. 여기서 각 브랜치를 더블클릭할 때마다, vscode의 파일도 같이 바뀌더라. | . | 브랜치에서 새 브랜치 따기 . my-idea로 checkout된 상태에서, 상단의 브랜치탭에서 새로 생성해보자. . 이 때, 새 브랜치로 체크아웃을 체크해주면, 자동으로 새 브랜치로 넘어가진 상태가 된다. | . . my-idea에서 파생된 브랜치라 그 상태를 그대로 가져갔다. | . | 브랜치의 브랜치 상태에서, 데이터를 변경후 커밋까지 . cat 이름을 변경:tom to nyang | . . | 연결된 3개의 평행우주에서 상황맞이 . 상사가 master의 내용을 바꾸길 원함. . . 요구 대로 바꿔고, commit한다. . git add -Agit commit -m &quot;EDIT dog name&quot; . . | . | 평행우주에서, 타 브랜치의 base가 되는 branch(여기선 maser)가 한발(commit) 나서게 되면, 분기된 branch가 나눠서 그려진다. . . | 다른 우주(의지를 이은 가장 바깥가지 브랜치)에서 변화 가져오기: [ 받을놈branch이동후] git merge [줄놈branch] . 현재 메인프로젝트 master의 변경내용과는 서로다른 평행우주끼리 다른파일 수정이라면, 브랜치의 브랜치라도 편하게 master로 merge되는 것을 권유할 수 있다. . 아래 내용을 상사에게 권해본다. . my-idea에서 mouse삭제 후 dino 추가했고 | my-idea - my-another-idea에서 cat이름을 변경했는데 이것들을 메인프로젝트에 적용해도될까요? Okay 승인 | . | . . | 2개의 평행우주에서 일어난 일을 master브랜치로 가져야가한다. . 이 때, 브랜치1의 브랜치2는 생성부터 브랜치1의 변화를 그대로 가져와서 생성되므로 브랜치2만 반영시키면 된다. . . | . | . | merge를 위해서는 . 먼저 받는놈 브랜치(master)로 이동(checkout)한 상태여야한다. . git merge [줄놈 브랜치명] | . git checkout mastergit merge my-another-idea . . | 변화를 보니 master의 상사지시 + 평행우주에서 한 것들이 모두 반영되어있다. . master에서의 dog name to 바꾼 것도 반영되어이있지만 | my-another-idea에서의 쥐삭제+용추가 한 것도 동시에 반영된 상태다. | . | . | 확인은 . 소스트리 | vscode git graph가 아니라면 | git log --graph --all --decorate로 확인하란다 git log --graph --oneline정도면 충분할듯? | . | . | reset –hard로 merge전으로 돌아간 후, 소스트리로 merge하기 . 소스트리로 실습하기 위해 merge전으로 돌아가보자. | . merge 직전의 받는놈 브랜치의 가장 마지막 커밋 == merge전 커밋으로 . git reset –hard . | 소스트리: 이 커밋까지 현재 브랜치를 초기화 . . | . | 소스트리로 merge하려면 더 간단한데 받는놈의 branch를 더블클릭해서 이동 | 주는놈 branch를 우클릭 &gt; 현재 브랜치(받는놈 더블클릭 상태)로 my-another-idea(주는놈, 우클리상태) 병합 | . | 나중에는.. 수많은 폴더와 파일을 다뤄야하기 때문에, 기존프로젝트에 새 도전을 하려면 반드시 git branch써야함. | . | 아름답지 않은 merge + conflict후에는 메세지없이 git commit . 원래 merge가 성공하면 git이 자동 add + commit까지 한다. | . bark-wang브랜치 생성후, dog 파일 수정 -&gt; commit . ❯ git branch bark-wang❯ git checkout bark-wangSwitched to branch &#39;bark-wang&#39;❯ git add -A❯ git commit -m &quot;EDIT dog file&quot; . . | 이제 받는놈인 master로 돌아와서 같은 dog파일 수정하자. . ❯ git checkout masterSwitched to branch &#39;master&#39;❯ git add -A❯ git commit -m &quot;EDIT dog file bar warlwarl&quot; . master가 한발짝 나가는 순간부터 분기가 갈라져 보인다. | . | 현재, master 와 bark-wang이 서로 같은 파일을 수정한 상태다. . 아까의 merge는 서로 다른파일이 수정된 상태라 merge가 쉽게 되었다. . | 한번 merge해보자 . ❯ git checkout masterAlready on &#39;master&#39;❯ git merge bark-wangAuto-merging dogCONFLICT (content): Merge conflict in dogAutomatic merge failed; fix conflicts and then commit the result. . . | . | merge시 conflict가 뜨는데 같은 파일을 여러 평행우주에서 수정했기 때문이다. conflic가 없었을 때의 merge는? merge를 자동으로 커밋까지 해주는 커밋메세지 확인이 떴었다. | . | terminal에 안내문이 뜬다 | 소스트리에서는 그래프가 회색으로 연결안되어있으면서 &quot;커밋하지 않은 변경사항&quot;의 상태로 뜬다. | vscode에서는 conflict된 부분을 나눠서 알려준다. | | conflict는 vscode에서 택1해서 지울건 지운 뒤, add후 git commit을 -m 없는 상태로 커밋을 날리면 자동으로 merge 메세지가 뜬다. . accept incoming ~ in vscode | . git add -Agit commit . . conflic후 commit은 메세지없이 git commit만 날리며 알아서 merge 메세지가 미리 작성되어있다. . . | . | 앞으로 다른 브랜치끼리는 같은파일을 수정안하도록 작업하면 merge가 편안해진다. | 다른우주도 1줄로 만들어 통합: git rebase(재배치) . 프로젝트의 성격에 따라 필요한 것을 선택해서 사용하면 된다. . . | 지금은 git log상 2갈래 정도만 나오지만 . 실제로는 엄청나게 많은 줄기가 생기게 된다. . . | . | 딱 1줄로 통합되도록 merge하는 방법이 git rebase다 . 소스트리상으로는 master(받는놈)에서 주는놈(bark-warl) 우클릭 &gt; 재배치(rebase)를 클릭한다. . . | 같은 파일을 건들인 상황이니 똑같이 conflict해결후 add+commit한다. . | 재배치가 끝나면 분기가1 줄로 나타난다. . 브랜치라도 합쳐지는 모양이 아니다. | . . | . | . 다 쓴 브랜치 삭제: git branch -D . rebase는 1줄로 받는놈(masetr)에 통합되어버린다. . 그럼 작업한 branch(주는놈)은 더이상 필요 없을 것이다. . | 대문자로 -D옵션을 준다 | 소스트리는 우클릭으로 바로 할 수 있다. | . ❯ git branch -D bark-wang Deleted branch bark-wang (was 5fefbe0). . ​ . | merge를 통해 분기가 합쳐졌던 branch들도 git branch -D로 삭제하였더니 . 분기 표기는 남아있는데, branch만 사라졌다. | . . | .",
            "url": "blog.chojaeseong.com/git/2021/10/14/%EA%B9%831_%EC%BB%A4%EB%B0%8B%ED%83%9C%EA%B7%B8%EC%9D%B4%EB%8F%99_%EB%8F%8C%EC%95%84%EA%B0%80%EA%B8%B0%EB%90%98%EB%8F%8C%EB%A6%AC%EA%B8%B0_%EB%B8%8C%EB%9E%9C%EC%B9%98.html",
            "relUrl": "/git/2021/10/14/%EA%B9%831_%EC%BB%A4%EB%B0%8B%ED%83%9C%EA%B7%B8%EC%9D%B4%EB%8F%99_%EB%8F%8C%EC%95%84%EA%B0%80%EA%B8%B0%EB%90%98%EB%8F%8C%EB%A6%AC%EA%B8%B0_%EB%B8%8C%EB%9E%9C%EC%B9%98.html",
            "date": " • Oct 14, 2021"
        }
        
    
  
    
        ,"post35": {
            "title": "winTerminal + Pyenv in Wsl2",
            "content": "chocolately로 초기 설치 . 관리자권한 powershell . 초코랫리 겟스타트 -&gt; 인스톨 코드 복붙 | 경고떠도됨. 관리자권한으로 다시 껐다 키기 | . | find pakage에서 terminal 검색후 설치 . choco install microsoft-windows-terminal . | python 3 검색후 3.9 설치 . choco install python3 . | vscode 설치 . choco install vscode . | git 설치 . choco install git . git config –global user.name “2js” . git config –global user.email “1@gmail” . | wsl2 설치 -&gt; 재부팅후 한번 더 실행 (-y -f ??) . choco install wsl2 -y -f . 참고사이트 . | 참고) 정식 가이드로 설치시 해주는 다운로드전 설정 . dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart # WSL 활성화 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart # VM platform 활성화 . | . | 관리자 권한으로 윈도우 가상화해주기 for wsl2 . Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All . bcdedit /set hypervisorlaunchtype auto . | AMD CPU SVM mode 설정 in Bios for ubuntu 실행 . del 로 bios 진입 . | advanced 진입(F7) . | OC(Overclock) 진입 . | advanced cpu configuration 진입 . | SVM node: Enable . 우측상단 X로 저장후 종료하기 | . | . | wsl2용 ubuntu1804 설치 -&gt; ms store에서 설치(choco는 update안된 버전이라고함) . msstore 사용시 ms계정 요구함 ~@hanmail.ent / ~54 | . | 설치 -&gt; 시작 | . | wsl명령어로 우분투 진입 default 계정 및 비번 설정 is2js / | ~213 | . | . | 항상 wsl접속으로 /mnt된 곳이 아니라 cd ~ (linux 홈폴더)를 한 상태에서 code ~/.zshrc 등의 설정을 하자. | Window Terminal 단축키 설정 . vscode와 비슷하게 추가 매핑해준다. . actions 부분에 추가해주면 된다. | . { &quot;command&quot;: &quot;find&quot;, // 검색키 매핑 // &quot;keys&quot;: &quot;ctrl+shift+f&quot;, &quot;keys&quot;: &quot;ctrl+shift+f&quot; }, // 수직분할 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;vertical&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+plus&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;vertical&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;ctrl+ &quot; }, // 수평분할 매핑(추가) //{ &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;horizontal&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+-&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;horizontal&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+0&quot; }, // 탭 끄기 매핑(추가) { &quot;command&quot;: &quot;closePane&quot;, &quot;keys&quot;: &quot;ctrl+w&quot; }, // 포커스key 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;down&quot; }, &quot;keys&quot;: &quot;alt+down&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;down&quot; }, &quot;keys&quot;: &quot;ctrl+alt+down&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;left&quot; }, &quot;keys&quot;: &quot;ctrl+alt+left&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;right&quot; }, &quot;keys&quot;: &quot;ctrl+alt+right&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;up&quot; }, &quot;keys&quot;: &quot;ctrl+alt+up&quot; }, // 창이동 단축키 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 0 }, &quot;keys&quot;: &quot;ctrl+alt+1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 0 }, &quot;keys&quot;: &quot;ctrl+1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 1 }, &quot;keys&quot;: &quot;ctrl+2&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 2 }, &quot;keys&quot;: &quot;ctrl+3&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 3 }, &quot;keys&quot;: &quot;ctrl+4&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 4 }, &quot;keys&quot;: &quot;ctrl+5&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 5 }, &quot;keys&quot;: &quot;ctrl+6&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 6 }, &quot;keys&quot;: &quot;ctrl+7&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 7 }, &quot;keys&quot;: &quot;ctrl+8&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 8 }, &quot;keys&quot;: &quot;ctrl+9&quot; }, // Rename a tab to &quot;Foo&quot; { &quot;command&quot;: { &quot;action&quot;: &quot;renameTab&quot;, &quot;title&quot;: &quot;server&quot; }, &quot;keys&quot;: &quot;f1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;renameTab&quot;, &quot;title&quot;: &quot;jupyter&quot; }, &quot;keys&quot;: &quot;f2&quot; }, . | . Window Terminal 및 wsl2 zsh 세팅 . 터미널에서 설정(ctrl+,) &gt; json파일열기 &gt; ubuntu이름을 wsl2로 바꾸고 . wsl2(ubuntu)의 guid를 복사해서 &gt; defaultProfile key에 넣어 기본 프로필로 설정 | . | Fira code설치후, WindowTerminal 및 vscode-editor + vscode terminal font 변경해주기 . 깃허브 &gt; zip파일 다운후 압축풀고 &gt; ttf 다 설치 . Terminal : 없던 defaults속 fontFace속성을 넣어서 폰트를 설정해준다. . | Vscode : font 검색후, 맨앞에 &quot;Fira code&quot; 추가 후 전체복사 . terminal font 검색 후 복붙 . “Fira code”, Consolas, ‘Courier New’, monospace . | . | . | . | zsh설치(zsh는 root로 설치) . sudo apt update &amp;&amp; upgrade . sudo apt install zsh . | oh my zsh(zsh) 설치 (ohmyzsh부터는 user로 설치?!) . github 들어가서 curl로 설치 명령어 날리기 . sh -c “$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)” . | . | ohmyzsh 플러그인 2개(자동완성, 하이라이팅) 설치 . zsh-syntax-highlighting . git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting . zsh-autosuggestions . git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions . .zshrc에 기입해주기 . code ~/.zshrc . plugin 검색 . plugins=(git) 에 공백으로 추가 해주기 . plugins=(git zsh-syntax-highlighting zsh-autosuggestions) . 나와서 . source ~/.zshrc . | . | p10k(ohmyzsh의 테마) 설치 . 깃허브 에서 ohmyzsh 클릭 후 ohmyzsh 하위폴더로 clone시켜주기 . git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k . | p10k를 zsh의 테마로 설정해주기 . code ~/.zshrc . theme검색후 ZSH_THEME=”robbyrussell”를 . ZSH_THEME=”powerlevel10k/powerlevel10k” . 로 변경 . source ~/.zshrc . | p10k configure 설정이 시작됨 . | . | ls -al 등이 파일명 배경색 직접 변경하기 . cd ~ . code ~/.zshrc . # change filname background color . LS_COLORS=”ow=01;36;40” &amp;&amp; export LS_COLORS . 위 내용 추가 . source ~/.zshrc . | Win-terminal 테마 생성 및 설정해주기 . terminalsplash.com에 들어가서 고른다. . VS code theme를 찾음. 아직 json내부에서 &quot;name&quot;이 없는 상태. | . | &quot;profiles&quot; 밑에 &quot;schemes&quot;에 **name을 추가해주면서 ** custom theme를 등록해야한다. . schemes 에 등록한 뒤, colorScheme로 사용된다 | . &quot;schemes&quot;: [ { &quot;name&quot; : &quot;VScode&quot;, &quot;background&quot; : &quot;#232323&quot;, &quot;black&quot; : &quot;#000000&quot;, &quot;blue&quot; : &quot;#579BD5&quot;, &quot;brightBlack&quot; : &quot;#797979&quot;, &quot;brightBlue&quot; : &quot;#9BDBFE&quot;, &quot;brightCyan&quot; : &quot;#2BC4E2&quot;, &quot;brightGreen&quot; : &quot;#1AD69C&quot;, &quot;brightPurple&quot; : &quot;#DF89DD&quot;, &quot;brightRed&quot; : &quot;#F6645D&quot;, &quot;brightWhite&quot; : &quot;#EAEAEA&quot;, &quot;brightYellow&quot; : &quot;#F6F353&quot;, &quot;cyan&quot; : &quot;#00B6D6&quot;, &quot;foreground&quot; : &quot;#D3D3D3&quot;, &quot;green&quot; : &quot;#3FC48A&quot;, &quot;purple&quot; : &quot;#CA5BC8&quot;, &quot;red&quot; : &quot;#D8473F&quot;, &quot;white&quot; : &quot;#EAEAEA&quot;, &quot;yellow&quot; : &quot;#D7BA7D&quot; }, ], . | wsl2(ubuntu)와 win-terminal or terminal 전에 colorScheme으로 지정해준다. . { &quot;guid&quot;: &quot;{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}&quot;, &quot;name&quot;: &quot;Wsl2&quot;, &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot;, &quot;colorScheme&quot; : &quot;VScode&quot;, }, { // Make changes here to the powershell.exe profile. &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;, &quot;name&quot;: &quot;Windows PowerShell&quot;, &quot;commandline&quot;: &quot;powershell.exe&quot;, &quot;hidden&quot;: false, &quot;colorScheme&quot; : &quot;VScode&quot;, }, . &quot;profiles&quot;: { &quot;defaults&quot;: { // Put settings here that you want to apply to all profiles. &quot;fontFace&quot; : &quot;Fira Code&quot;, &quot;colorScheme&quot; : &quot;VScode&quot;, }, . | . | wsl2 계정 및 폴더 설정 in win10 . 항상 특정유저로 wsl2 진입 . /etc/wsl.conf 없으면 생성 . sudo vi /etc/wsl.confg . [user] default=is2js . | . 윈도우 탐색기에 wsl2경로 네트워크로 만들기 . 윈도우( )탐색기 창에서는 wsl$ 로 우분투로 접속가능하다. config등 경로에서는 //wsl$의 슬래쉬로 사용된다. | 참고) 윈도우탐색기상 wt -d .을 통해, 현재경로에서 윈도우 터미널 열기 | . | . wsl 쉘 킨 상태로 연결유지 | 탐색기 &gt; 내PC 우클릭 &gt; 네트워크 위치 추가 사용자 지정 네트워크 위치 선택 | [인터넷 또는 네트워크주소] 부분에 wsl$입력후 찾아보기 | 원하는 경로선택하기 : 우분투/home/is2js/workspace/ | 원하는 이름 입력 : is2js_workspace | . | 여기서 들어간 뒤 wt -d .로 윈도우 터미널(wsl)을 열면 될듯? | wsl2 ubuntu 기본설정 . 루트 계정 비밀번호 초기화참고 블로그 | 유저계정을 root 화시키기 참고 블로그 usermod -aG sudo [계정명]으로만 주기 | . | . openssl 설치 . sudo apt install openssl . | root의 기본 비밀번호 초기화 . sudo passwd root . # : 관리자 | $ : 일반유저 | . | 유저계정에 root권한부여 (파일3개 수정) . root계정으로 권한설정파일에 유저계정-&gt; root권한부여 . su . vi /etc/sudoers . 아래 root쪽에 내 계정도 추가하기 . # User privilege specification root ALL=(ALL:ALL) ALL is2js ALL=(ALL:ALL) ALL . | . wq! (readonly떠서 강제로 저장후 종료) . | root계정으로 비밀번호설정파일에 유저계정-&gt; root권한부여 . root항목처럼, root:x:0:0:root:/~f로 시작하는 부분에서 앞쪽0 : uid | 뒤쪽0: gid 관리자라면 둘다 0임. | 나는 뒤쪽 그룹id만 0으로줌. | . | . | . vi /etc/passwd . wq! . #is2js:x:1002?:1002?:,,,:/home/is2js:/usr/bin/zsh is2js:x:1002?:0:,,,:/home/is2js:/usr/bin/zsh . | root계정으로 그룹설정파일에 유저계정-&gt; root권한부여 . root가 대장인 0그룹에 추가를 해주면됨 . vi /etc/group . wq! . #root:x:0: root:x:0:is2js . | . | zsh 권한 에러시 . sudo chown -R ${LOGNAME}:staff $HOME . | wsl2-ubuntu 시작계정 설정하기 . powershell 에서 . ubuntu[1804] config --default-user [is2js] . | . | wsl2-ubuntu 시작폴더 설정하기 in WindowTerminal . 터미널의 wsl프로필에다가 옵션을 추가해줌 . 출저 | . &quot;startingDirectory&quot;:&quot; wsl$ Ubuntu-[20.04] home [myskan]&quot; . &quot;guid&quot;: &quot;{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}&quot;, &quot;name&quot;: &quot;Wsl2&quot;, &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot;, &quot;colorScheme&quot; : &quot;VScode&quot;, &quot;startingDirectory&quot;:&quot; wsl$ Ubuntu-18.04 home is2js&quot;, . | 참고 . wsl$ : 탐색기에서 우분투 폴더라도 바로 가기 | . | . | python-&gt;python3 매핑 . 참고블로그 | 더 좋은 블로그 | . Alternatives는 기본 커맨드의 심볼릭 링크를 관리해주는 리눅스 프로그램입니다. 데비안 계열의 리눅스(우분투)에서는 update-alternatives가 제공됩니다. . | 우분투(Ubuntu)를 설치하면 python path가 2.7로 설정되어 있습니다. . 리눅스의 Alternatives를 이용하면 python 버전을 쉽게 변경하고 관리할 수 있습니다. | . ❯ which python /usr/bin/python . python은 /usr/bin/python의 링크인데 | . ❯ ls -al /usr/bin/ | grep python lrwxrwxrwx 1 root root 9 Apr 16 2018 python -&gt; python2.7 lrwxrwxrwx 1 root root 16 Apr 16 2018 python-config -&gt; python2.7-config lrwxrwxrwx 1 root root 9 Apr 16 2018 python2 -&gt; python2.7 lrwxrwxrwx 1 root root 16 Apr 16 2018 python2-config -&gt; python2.7-config -rwxr-xr-x 1 root root 3633000 Feb 28 2021 python2.7 lrwxrwxrwx 1 root root 33 Feb 28 2021 python2.7-config -&gt; x86_64-linux-gnu-python2.7-config lrwxrwxrwx 1 root root 9 Oct 25 2018 python3 -&gt; python3.6 . ❯ ls -al /usr/bin/python lrwxrwxrwx 1 root root 9 Apr 16 2018 /usr/bin/python -&gt; python2.7 . /usr/bin/python 역시 실행파일이 아닌 /usr/bin/python2.7의 링크이다. . | **즉 ** . /usr/bin/python2.7 -&gt; /usr/bin/python -&gt; python | . | . | --config python로 python에 걸려있는 링크를 확인한다. . sudo update-alternatives --config python [sudo] password for is2js: update-alternatives: error: no alternatives for python . alternatives가 없다고 뜨면, 설정을 해줘야한다. | . | --install [symbolic link path(버전을 제외한 공통 경로)] python [real path(버전명시 경로)] [우선순위number]로 여러버전을 등록한다. . #sudo update-alternatives --install /usr/bin/python(버전제외 공통 경로) python(명령어=링크) /usr/bin/python3(버전명시 경로) 10(우선순위) . python2.7 등록 . sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 2 . | python3.6 등록 . 3.6 한개만 등록하고 해당 버전을 선택안해도 python -&gt; python3.6이 걸리도록 하면 된다. | . sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.6 1 . | . | (만약 2개이상 버전 등록했다면) 다시 한번 --config python으로 등록된 버전 확인 및 선택 . sudo update-alternatives --config python There are 2 choices for the alternative python (providing /usr/bin/python). Selection Path Priority Status * 0 /usr/bin/python2.7 2 auto mode 1 /usr/bin/python2.7 2 manual mode 2 /usr/bin/python3.6 1 manual mode Press &lt;enter&gt; to keep the current choice[*], or type selection number: 2 . | **버전을 선택해주면, python의 링크가 특정버전으로 옮겨져있다. ** . ❯ python -V Python 3.6.9 . | pip도 설정해준다. . 1개만 등록하면 pip -&gt; pip3가 될 것이다. | . ❯ sudo update-alternatives --config pip update-alternatives: error: no alternatives for pip . ❯ sudo update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 1 update-alternatives: using /usr/bin/pip3 to provide /usr/bin/pip (pip) in auto mode update-alternatives: warning: not replacing /usr/bin/pip with a lin . ❯ pip -V pip 9.0.1 from /usr/lib/python3/dist-packages (python 3.6) . | 1개만 alternative를 등록해서 python, pip를 default로 3버전으로 지정해주자. | . # pip3 install sudo apt-get update sudo apt-get install -y python3-pip pip3 --version # python3, pip3 alternatives command sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10 sudo update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 1 . python 가상환경 설정 . pip3 &amp; pyenv(격리된 python) 설치 . python3-pip 설치 . sudo apt update &amp;&amp; upgrade sudo apt install python3-pip pip3 -V pip3 --version . | pyenv 설치 . curl https://pyenv.run | bash . WARNING: seems you still have not added &#39;pyenv&#39; to the load path. # See the README for instructions on how to set up # your shell environment for Pyenv. # Load pyenv-virtualenv automatically by adding # the following to ~/.bashrc: eval &quot;$(pyenv virtualenv-init -)&quot; . clone한 pyenv디렉토리를 zshrc에 환경변수(PYENV_ROOT)로 직접지정해줘야한다. . cd ~ # wsl로 정상적으로 열릴려면, /mnt/상태에서 vscode를 열면 안된다. code ~/.zshrc . source ~/.zshrc . | pyenv사용전, 에러를 일으키는 미설치 패키지 다 설치하기 . sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev . | . | pyenv 사용법 . # 설치가능한 python list 확인하기 pyenv install --list # 원하는 python 버전 설치 pyenv install [파이썬버전] # 설치된 파이썬 버전 확인 pyenv versions # 가상환경 만들기 pyenv virtualenvs [파이썬버전] [가상환경명] # 가상환경 시작하기 pyenv activate [가상환경명] # 가상환경 끝내기 pyenv deactivate # 가상환경 목록 확인 pyenv virtualenvs # 가상환경 삭제하기 pyenv uninstall [가상환경명] ### 실사용 pyenv versions pyenv install 3.8.6 pyenv global 3.8.6 # 3.8.6을 pyenv 기본 python으로 지정 . python 저장위치 root -&gt; /root 가 홈폴더 유저의 경우 -&gt; /home/유저명이 홈폴더 | . | ~/.pyenv/ 라는 곳에 versions/폴더에 설치된다. github다. | . | virtualenvwrapper에서도 ~/.pyenv/versions/3.8에서 자동완성후 /3.8.6/bin/python을 이용한다. | . | . | virtualenv &amp; pyenv-virtualenvwrapper(격리된 python으로 가상환경 생성) 설치 . pip3로 virtualenv virtualenvwrapper 2개 패키지 설치 . pip install virtualenv virtualenvwrapper pip3 install virtualenv virtualenvwrapper #에러나므로 --upgrade까지 pip install --upgrade virtualenvwrapper pip3 install --upgrade virtualenvwrapper . | virtualenvwrapper 설정 . # virtualenv 설정 export WORKON_HOME=~/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python # /usr/bin/python3 . | pyenv-virtualenvwrapper 설치 . git clone https://github.com/pyenv/pyenv-virtualenvwrapper.git $(pyenv root)/plugins/pyenv-virtualenvwrapper . pyenv설정 추가 수정 . # pyenv clone후 경로 직접 지정 export PYENV_ROOT=&quot;$HOME/.pyenv&quot; export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot; if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then eval &quot;$(pyenv init -)&quot; fi pyenv virtualenvwrapper_lazy #에러나서 주석처리했다가 다시 풀어줌 . source ~/.zshrc . | virtualenv 추가 설정 . # virtualenv 설정 export WORKON_HOME=~/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python #source /usr/local/bin/virtualenvwrapper.sh source ~/.local/bin/virtualenvwrapper.sh . | . | 실사용 . pyenv install 3.8.6 pyenv versions #~/.pyenv/versions/ 에 격리된 파이썬들 버전명의 폴더에 설치됨. pyenv global 3.8.6 pyenv versions mkvirtualenv goglekaap which python #/home/is2js/.virtualenvs/goglekaap/bin/python deactivate workon # goglegkaap rmvirtualenv goglekaap # pyenv로 만든 python버전을 지정해서 가상환경 생성 mkvirtualenv -p ~/.pyenv/versions/3.8.6/bin/python goglekaap lsvirtualenv # workon이랑 동일한 듯. . # pyenv pyenv install [version] # Python 버전 설치 pyenv versions # 현재 설치된 Python 버전 목록 pyenv global [version] # 전역 Python 버전 변경 #virtualenv wrapper mkvirtualenv [project name] # 프로젝트를 위해 virtualenv 생성 workon [project name] # virtualenv 활성화 deactivate # virtualenv 비활성화 setvirtualenvproject # 현재 디렉토리를 프로젝트의 Home 디렉토리로 설정하기 rmvirtualenv [project name] # virtualenv 삭제 lsvirtualenv # virtualenv 목록 mkvirtualenv [가상환경이름] mkvirtualenv [-p ~/.pyenv/versions/3.8.6/bin/python] [tester(가상환경이름)] #가상환경이름으로 가상환경을 만들어준다. mkvirtualenv test -p [python-path]로 python 버전을 지정해 줄 수 있다. rmvirtualenv [ 가상환경이름] #해당 가상환경을 지운다. workon [가상환경이름] #해당 가상환경으로 진입한다. setvirtualenvproject # &lt;가상환경 진입상태 by workon&gt;에서 프로젝트 디렉토리로 이동 후, 해당 커맨드를 치면 디렉토리&lt;--&gt; 가상환경이 맵핑된다. 그러면 workon커맨드를 치는것 만으로 해당 디렉토리에 이동까지 시켜준다. 아주좋다. cdproject #setvirtualenvproject를 했을 경우, 현재 어디에 있든 해당 커맨드로 프로젝트 디렉토리에 이동이 가능하다. # 예를 들어, 아무폴더에서 workon [가상환경] -&gt; cdproject deactivate #가상환경에서 빠져나온다. . | 참고) path 관련 확인해보기 . python 설치(PATH) 확인 . linux에서는 python + tab, python3 + tab을 통해 깔린 버전을 간접적으로 파악 가능 python3로 자동완성된다면.. python3만 깔린 것 앞으로 모든 명령어 앞에 python+3 | . | . | python3 --help -m [모듈명] : mod로서, library모듈을 script로 실행시키는 옵션 pip, flask, venv 등에서 쓰임. 물론 패키지가 깔린상태여야함. | python3 -m venv [가상환경명] | . | -V : 버전확인 | -c &quot; python코드 &quot; : python코드를 바로 커맨드라인에서 실행함 | . | . win10 환경변수 path로 설치확인 . win+s 에서 환경 변수검색 &gt; 시스템 환경 변수 편집 . | 고급탭 &gt; 환경변수N &gt; 사용자 변수 or 시스템 변수 . 나는 초콜렛리로 설치하였더니 시스템 변수탭에 Path에 설치됨. C: Python39 Scripts : 스크립트 폴더를 더블클릭해서 가보기 | C: Python39 | . | | . | win10 or wsl2 python os모듈로 확인 . import os . | os.environ (dict) . os.environ.get(‘SHELL’) for wsl2 . os.environ.get(&#39;SHELL&#39;) &#39;/usr/bin/zsh&#39; . | . | python path로 실행가능한 python script만들기(앞에 python3 안달아도됨) . which python3 후 경로를 복사해놓는다. . /usr/bin/python3 | . | python 파일의 가장 위에 #! + python경로를 입력한 뒤, python 코드를 작성하면된다. . code calculate.py . #!/usr/bin/python3 def add(x,y): return x+y print(add(2,3)) . 결과물은 print만 되도록한다.(bash실행이라서?) | . | sudo chmod +x calculate.py . | 실행시 calculate.py가 아니라 ./calculate.py로 실행시킨다. . ./calculate.py | 에러 뜨면 sed -i &#39;s/ r$//&#39; calculate.py 실행후 다시 실행 | . | . | .",
            "url": "blog.chojaeseong.com/configuration/2021/10/13/%EC%84%B8%ED%8C%851_%EC%9C%88%EB%8F%84%EC%9A%B0_choco_terminal_wsl2_python.html",
            "relUrl": "/configuration/2021/10/13/%EC%84%B8%ED%8C%851_%EC%9C%88%EB%8F%84%EC%9A%B0_choco_terminal_wsl2_python.html",
            "date": " • Oct 13, 2021"
        }
        
    
  
    
        ,"post36": {
            "title": "vscode) python 실행용 tasks.json 기록",
            "content": "VScode . tasks.json . ctrl+shift+B로 python파일 빠르게 출력하기 함. . | 한번 눌러보고 설정&gt;템플릿생성&gt;Others&gt;기록 . | . { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;Project Label&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;python&quot;, &quot;args&quot;: [ &quot;${file}&quot; ], &quot;presentation&quot;: { &quot;reveal&quot;: &quot;always&quot;, &quot;panel&quot;: &quot;new&quot; }, &quot;options&quot;: { &quot;env&quot;: { &quot;PYTHONIOENCODING&quot;: &quot;UTF-8&quot; } }, &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true } } ] } .",
            "url": "blog.chojaeseong.com/configuration/2021/08/24/tasks.html",
            "relUrl": "/configuration/2021/08/24/tasks.html",
            "date": " • Aug 24, 2021"
        }
        
    
  
    
        ,"post37": {
            "title": "PT내용 기록.",
            "content": "스트레칭 . 양손꽉지 -&gt; 어깨내리고, 엄지세우고 -&gt; 턱을 위로 당기기 10초 | 양속 뒤로 꽉지 -&gt; 고개 아래로 잡아당기기 10초 | 고개회전+굴곡으로 대각선 아래보기 -&gt; 귀와 후두부사이를 4손가락으로 잡아서 아래로 당겨 승모근 늘이기 | 삼각근 늘려주기 코끼리코자세로 팔꿈치위쪽을 쭈욱 당긴 뒤 | 양쪽 어깨 내리고 | 다시 쭈욱 당기기 | . | 삼두근 늘이기 한손을 머리뒤로 넘기고 | 반대손으로 팔꿈치를 꾹 눌러 잠근다음 | 안쪽으로 쭉 당겨주기 | . | 꽉지끼고 허리 굴곡시켜주기 | 꽉지끼고 허리 측굴 시키기 꽉찌 위로 껴서 몸을 조금 측굴 후 | 엉덩이를 반대편으로 밀어서 완전히 측굴 | . | 허리 돌리기 양쪽방향 | . | 손목, 발목 돌리기 반대손으로 손목을 잡은 상태에서, 손목+발목 10, 반대10초 돌리기 | . | 상완전완 . 2 트라이셉스(케이블)푸쉬 다운 p.26 . . . 25:28분 . 가슴 . 가슴운동하는 이유 : 중력에 의해 앞으로 쏠리는 게 편하여 생기는 라운드솔뎌의 단축된 가슴을 펴준다. . 가슴단축을 펴준다. | 프레임이 커진다. 등운동과 같이해서 크게한다. | 푸쉬업보다 벤치프레스가 가동범위가 크다. | . | . 1-1덤벨(벤치) 프레스 p.83 . . . 1주차, 2~4kg 허리 아픈 환자는 벤치위에 양발을 올린 상태해서 하면 편하다 | . | . 준비 : 허리아치 + 어깨 내림 + 견갑골 양간 잡아주기 bar로 하듯이 잡은 상태로 팔을 편 상태가 시작. | . | 아령은 앞으로 넘어갈 때의 전완에 힘이 들어오는 선에서 | 수직선으로 내려갔다가 그대로 올려줌(모으는 느낌X) 속도는 빠르게 | . | 1-2덤벨 플라이 p.84 . . 가슴을 이완시켜 가슴 안쪽을 채워주는 운동 여성분들의 벌어진 가슴을 모음 | 남성분들은 가슴 볼륨감을 높혀줌 | . | . 허리아치 + 어깨 내림 + 견갑골 양간 잡아주기 | 팔꿈치는 수직으로 내려가고 손등은 땅바닥을 보는 방향으로 내려간다 약간 손목을 틀어주면서 해야하므로 좀 어려웠다. | . | 중력을 이용해서 내려가며 + 덤벨을 몸에서 최대한 멀리 다 피지말고 덤벨을 잡을 수 있게 약간만 전완이 굽어진 상태 | . | 어깨 . 가슴~팔을 중간 근육 | 등 운동할때도 포함되는 중간 근육 등, 가슴 근육을 눌려주는시 가운데서 버티는 역할 | . | . 1-3시티드 덤벨 프레스 p.41 . 덤벨프레스는 허리에 과부하가 가므로 반드시 앉아서(시티드) + 약간은 뒤로 기울인 상태로 등/엉덩이가 닿은 상태로 시행하자. | . . 엉덩이, 등을 딱 붙이고, 가슴 내밀고, 어깨 내린 상태에서 팔을 든 상태에서 시작. 허리통증이 없는 사람도 생기게 되니 주의 | . | 수직으로 내려오되, 이마가 아니라 정수리 라인까지 내려오게 한다. 옆에 거울 보면서 수직으로 해야 어깨로 드는 것. | . | 1-4사이드 래터럴 레이즈(사래레) p. 48 . . . 전면 삼각을 운동시키기 위해, 팔을 약간 내회전한 상태에서 시작한다. | . 대각선으로 올라간다. | 올라갔다가 바로 내려온다. 버티기X s | 대퇴, 둔부 . 2스쿼트 . . . 어깨보다 한발씩 더 벌린 상태로 발 앞꿈치로 땅바닥을 잡는다 생각하여 엉덩이를 뛰로 빼더라도 안넘어지도록 한다. | . | 약간 무릎을 바깥쪽으로 뺀 상태로 만들어 엉덩이에 자극을 주고 내려가면서 무릎은 더 바깥쪽으로 벌어져서 둔부가 자극되도록 해야한다 | 무릎이 앞으로 안나온다는 생각으로 엉덩이를 최대한 뒤로 빼면서 내려간다. | . | 허리 아픈 사람은 더 엉덩이로 보강해야해서 중요함. . | 10개 3~4세트 | . 하체 . 2런지 . . . 발을 골반너비 정도만(스쿼트는 어깨넓이) | 한쪽발을 뒤로 한뼘 | 반대발을 앞으로 그만큼 | 뒷발의 뒤꿈치를 확 올리면 앞으로 넘어간다 -&gt; 그만큼 앞으로 이동 | 중심잡기 힘들면 앞발만 바깥쪽으로 조금 회전시켜줌 | 앞무릎 고정상태에서 뒤꿈치 편상태로 뒷무릎만 내려갔다 올라온다. | 10개 3~4세트 . 복근, 기립근 . 크런치 . 팔꿉치가 앞으로 뻣어나간다고 생각하고 시행 | . 플랭크 . 발을 약간 벌려 앞으로 세우기 | 손의 위치랑 입이랑 위치 바꾸기 | 엉덩이는 계속 들고 있기 | 20초 2~3세트 | 슈퍼맨 운동 . 기립근을 직접적으로 키운다. . 대자로 뻗은 뒤 | 고개는 들지말고 팔과 다리를 들어서 1~2초간 버티고 돌아온다. |",
            "url": "blog.chojaeseong.com/pt/%EC%9A%B4%EB%8F%99/2021/08/23/PT.html",
            "relUrl": "/pt/%EC%9A%B4%EB%8F%99/2021/08/23/PT.html",
            "date": " • Aug 23, 2021"
        }
        
    
  
    
        ,"post38": {
            "title": "github index, badge 등 생성하여 꾸미기",
            "content": "참고사이트 . 참고 사이트 https://velog.io/@woo0_hooo/Github-github-profile-%EA%B0%84%EC%A7%80%EB%82%98%EA%B2%8C-%EA%BE%B8%EB%AF%B8%EA%B8%B0 | https://butter-shower.tistory.com/142 | https://velog.io/@colorful-stars/Github-%ED%94%84%EB%A1%9C%ED%95%84-%EA%BE%B8%EB%AF%B8%EA%B8%B0 | http://blog.cowkite.com/blog/2102241544/ | . | . github_id 이름으로 repo 생성 . github ID와 동일한 이름으로 repo만들기 + add Readme . local에 clone하여 환경 세팅하자. C:/jupyter_blog/ + is2js . . | . | capsule-render로 header/footer 작성 . typora에서 미리보기를 활용하여 header footer를 작성한다. . 각 옵션 목록 : https://github.com/kyechan99/capsule-render . | default(변경하면됨) . ![header](https://capsule-render.vercel.app/api?type=waving&amp;color=f6ebe1&amp;height=150&amp;section=header&amp;text=Data Engineer and KMD&amp;fontSize=50&amp;fontColor=152447&amp;desc=데이터 엔지니어를 꿈꾸는 한의사, 조재성입니다.&amp;descAlignY=80) ![footer](https://capsule-render.vercel.app/api?type=rect&amp;color=152447&amp;height=20&amp;section=footer) . . | . | sheilds.io로 기술 스택 badge작성 . shields.io를 통해 기술스택, 연락처 등의 스택아이콘 가져온다. . a태그 &gt; img태그 . | a태그는 링크주소를 / img는 badge를 여기를 통해서 편하게 가져온다. . 각 뱃지 목록 : https://github.com/alexandresanlim/Badges4-README.md-Profile | . &lt;p align=&quot;center&quot;&gt; &lt;a href=&quot;mailto:tingstyle1@gmail.com&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Gmail-d14836?style=flat-square&amp;logo=Gmail&amp;logoColor=white&amp;link=tingstyle1@gmail.com&quot;/&gt;&lt;/a&gt;&amp;nbsp &lt;a href=&quot;https://www.facebook.com/tingstyle1&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Facebook-1877F2?style=flat-square&amp;logo=facebook&amp;logoColor=white&quot;/&gt;&lt;/a&gt;&amp;nbsp &lt;a href=&quot;https://www.github.com/is2js&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/GitHub-100000?style=flat-square&amp;logo=github&amp;logoColor=white&quot;/&gt;&lt;/a&gt;&amp;nbsp &lt;/p&gt; . | . productive-box로 커밋시각 통계(gist) 노출(pinned)하기 . 참고 : http://blog.cowkite.com/blog/2102241544/ | . gist.github.com에 public으로 신규 public으로 바꾼 gist를 생성 . . | github토큰 생성 페이지로 가서 repo, gist를 포함한 scope를 설정한 뒤, 발급받은 토큰을 잘 챙겨둔다. . QQQghp_ysd0aOZbgsOJ3rOTAhj4QQQw4su6rrfPp1oc7WrQQQ . | productive-box repository를 fork한다. . 우측 상단의 Fork 버튼을 누르면 된다. . | fork 된 나의 repository의 Actions 탭에서 enabled 버튼을 눌러 Action을 활성화한다 . | .github/workflow/Schedule.yml . 파일을 수정하여 환경변수를 작성해준다 . uses: is2js/productive-box@master : 내github아이디로 바꿔준다? . maxam2017 -&gt; 내 아이디로 | . | GIST_ID: 사전 작업의 1번 step에서 생성된 gist의 id (gist URL은 gist.github.com//로 생성되기 때문에 주소창을 보면 된다.) 042e89789d6054e9b372e755e75f09f5 | . | TIMEZONE: 타임존을 적어준다. Asia/Seoul 형식으로 적어주면 된다. cf) cron : 분시일월주 cron예제 : https://ponyozzang.tistory.com/402 | . | . | . | . | 해당레포 &gt; Settings 탭 &gt; Secrets에 접속한 뒤 New repository secret 버튼을 클릭하여 환경변수를 설정해준다. . GH_TOKEN: 사전 작업의 2번 step에서 발급받은 토큰 . 토큰은 github &gt; secrets &gt; 환경변수에서 설정해주면, workflows.config.yaml을 그것을 이용한다. | . env: GH_TOKEN: $ . | . . | gist를 내 프로필 pinn에 고정시킨다. . | 내 블로그에 embed시킨다. . 아래 코드에서 gist주소만 복사해서 gist_id.js를 넣어주면 됨. | . | 깃허브 프로필 뱃지 얻기 . Github Developer program . https://developer.github.com/program/ 사이트에서 등록한다. . 2가지만 추가로 채워주면 된다. . | Highlights부분에 뱃지 생김 . . | . | 학생 PRO . 유효한 date를 포함하는, 학생증 찍어서 증명하는 부분이 생겨 나는 포기함. | . https://education.github.com 접속후 Student Developer Pack 클릭 . | Get pack &gt; Get Student benefits &gt; 아래쪽 학교인증 . github에 학교계정으로 email을 등록하고 와야한다. . . | . | 마지막에 plan을 Github Pro로 적어주면 된다. . | 증명서를 내라고한다. 나는.. 졸업해서 그냥 생략.. . | 북극곰 2020.02월 . 나는 우연히 그 때 만들어뒀나보다. | .",
            "url": "blog.chojaeseong.com/git/github/2021/08/19/github-profile.html",
            "relUrl": "/git/github/2021/08/19/github-profile.html",
            "date": " • Aug 19, 2021"
        }
        
    
  
    
        ,"post39": {
            "title": "powershell_vs_bashshell명령어",
            "content": "개요 . 출저 : 유튜브-드림코딩 . | 참고 : 티스토리 리눅스 명령어모음 블로그 . | 나는 Windows Terminal을 다운 받은 뒤, powershell vs wsl에서 실습하였다. . window의 powershell은 alias를 제공하여 unix shell과 비슷한 명령어를 사용할 수 있다. . . | . | 아직 많은 개발자들이 window를 사용함 . . | . powershell 최신버전 설치 . 링크 : https://docs.microsoft.com/ko-kr/powershell/scripting/install/installing-powershell-core-on-windows?view=powershell-7.1 | . 기본 명령어 . man, clear . manual의 약자다. 잘 모를 때 참고하는 명령어 . man man . | Get-Help 명령어를 링크 해놓은 것이다. . | 청소해주는 명령어 . | . man clear clear . 파일 탐색 . pwd(경로 확인) . Print Woring Directory의 약자 | . explorer.exe .(경로상 탐색기열기) . mac에서는 open .을 사용한다. . | explorer가 아니라 explorer.exe .연다. . | . ls [하위폴더] (경로상 파일목록) . list의 약자 . | powershell에서는 mode까지 같이 나오는 반면, . powershell은 ls만 가능하다. ls -l등의 format활용은 X. 처음부터 다 보여준다. . | wsl/mac에서는 파일명만 나온다. . ls -al, ls -atl 등을 활용하면 mode까지 같이 출력된다. | . | . . | . ls . format for WSL2 . ls -l : long의 약자 . . | ls -a : all의 약자 . ui상에서는 보여주지 않는 숨겨진 폴더, 파일을 보여준다. | . . | ls -al : all(숨겨진) + long(mode까지) . . | . format for Powershell . powershell의 ls는 기본적으로 long모드로 보여주는 듯 했다. . | ls -name : 이름만 보고 싶을 때 . mac, wsl의 ls기본과 똑같다. | . | ls -force : 숨겨진 폴더, 파일을 보고 싶을 때 . . | . 폴더이동 . cd [./../-/~] . change directory의 약자 . . : 현재 경로. cd .는 제자리 이동. . | .. : 상위 경로 . | ~ : **현재설정된 사용자의 최상위 폴더 = home 디렉토리 ** . powershell에서도 cd ~를 하면, C: Users 사용자 | wsl에서 cd ~를 하면, root계정 : /root | 특정사용자 : /Users/사용자 | . | . . | - : 직전경로 . powershell은 cd -가 안된다. -&gt; 7.14버전으로 업데이트 해보는 중. . 7버전으로 업데이트하면 된다… . . | 대신, 직전경로 1번만 사용가능하며, 이후 C: 로 이동된다.. . | . | . | . | . 파일, 디렉토리 찾기 . find [경로] -type [f/d] -name “*.*” for shell . 입력한 경로부터 시작하여 하위까지 해당 파일or폴더를 찾는다. . 예시 . 나같은 경우 -type file , -type directory해도 안되길래, f, d로 약어로 넣으니 됬다. | permission denied나니까, 관리자 모드로 접속하자. | . find . -type d -name &quot;*flask*&quot; . find . -type f -name &quot;*.csv&quot; . | . | . get-childitem for powershell . powershell사실상 안된다고 보면 된다. get-childitem -File -Filter &quot;*.txt&quot; -Recurse | . | . 프로그램 설치/설정 위치 . which for shell . 프로그램의 실행경로를 확인한다. . which node which code . | . gcm for powershell . get-command의 약자인 gcd를 이용한다. . | 경로는 창을 키워야 보임 . gcm node gcm code . | . 파일 생성 및 관리 . touch [파일명] (파일생성) . 존재하지 않으면, 파일 생성 | . man touch touch new_file1.txt . 이후 new_file1.txt를 열어 파일 | . new-item [파일명] for powershell . touch의 생성은 powershell에 없다. 하지만 cat, echo는 존재함. | . new-item new_file4.txt cat new_file4.txt . cat [파일] [파일2] (파일내용확인) . touch와 달리, powershell에도 사용가능함(alias존재) . | touch로 생성한 파일의 내용을 빠르게 확인 . 여러 파일을 동시에 쓰면, 붙혀서 string으로 확인됨. | . | . touch new_file2.txt cat new_file2.txt second line# cat new_file1.txt new_file2.txt first line 텍스트 추가second line# . echo “문자열” &gt;(») [파일] (&gt;파일생성+컨텐츠입력/ » 컨텐츠 추가) . 기본사용은 작성한 문자열을 터미널에 출력한다. (터미널에 에코~) 거의 사용안한다. | powershell에서도 사용가능하다. | &gt; [파일명]을 통해 파일생성+해당문자열을 컨텐츠로 넣어줌(덮어쓰기) | . echo &quot;third line&quot; &gt; new_file3.txt cat new_file3.txt third line . echo &quot;third line&quot; &gt; new_file3.txt cat new_file3.txt third line . &gt;&gt; [파일명] : 파일생성+덮어쓰기가 아니라 기존파일에 컨텐츠 append개념이다. | . echo &quot;third line--&quot; &gt;&gt; new_file3.txt cat new_file3.txt third line third line-- . 디렉토리 생성 . mkdir -p [폴더/하위폴더/하하위폴더] . make directory의 약자, 폴더 = 경로를 생성하는 명령어 | powershell 공용 | . mkdir dir1 ls -al . -p 옵션을 주면서 하위폴더들을 /로 연결하여 줄줄이 생성할 수 있다. | . mkdir -p dir2/subdir1/subdir2 ls dir2 subdir1 ls dir2/subdir1 subdir2 . 파일관리 cp/mv/rm . 3가지 다 powershell에서 사용가능 | . cp [파일] [원하는 경로/]or[새파일명] . copy의 약자 | . mv [파일] [원하는 경로/]or[새파일명] (파일이동/이름변경) . 이름바꾸는 것도 mv로 하는구나. . mv new_file2.txt file2.txt ll . | . rm [삭제파일명] / rm -r [디렉토리명] . -r 이라는 recursive옵션을 주면 디렉토리삭제+하위경로도 삭제 2가지 역할을 해주게 된다. 파일삭제는 rm 파일명 | 디렉토리삭제는 rm -r 디렉토리명 | . | . rm new_file4.txt rm -r dir3 . rm [디렉토리] 후 선택 / rm [디렉토리] -Recurse . 이부분 만 shell과 다름. | 그냥 rm하면 경고창(wsl)없이 선택화면이 나온다. 디렉토리를 선택하면됨. | 디렉토리 빠르게 삭제는 -r 옵션을 중간에 주는게 아니라 마지막에 -Recurse powershell에서도 마지막에 -r 줘도 삭제되는 듯 싶다. | . | . Grep (select-string) . Global regular expression print 의약자. . | 파일에서 검색 or *를 활용한 프로젝트 전체폴더에서 검색 . | . grep “검색문자열” [파일명] . grep &quot;line&quot; *.txt file2.txt:second line new_file1.txt:first line new_file3.txt:third line new_file3.txt:third line-- . grep -n : 라인정보 같이출력 . 찾은 것이 몇번째 라인에 있는지까지도 같이 출력 | . grep -n &quot;line&quot; *.txt file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . grep -ni : 대소문자상관없이 검색후 라인정보출력 . -i : intensive 옵션을 주면 대소문자 상관없이 검색하라는 말이다. | . grep -ni &quot;LINE&quot; *.txt file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . grep -nir “문자열” . : 프로젝트최상경로에서 하위끝까지 전체를 검색 . grep -nir &quot;LINE&quot; . ./file2.txt:1:second line ./new_file1.txt:1:first line ./new_file3.txt:1:third line ./new_file3.txt:2:third line-- . select-string [파일명] -pattern “검색문자열” . default로 대소문자상관없이 + 라인정보도 같이 출력된다. . select-string *.txt -pattern &quot;LINE&quot; file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . | . select-string [*, */*] -pattern “검색문자열” . -ni는 자동이고, -r 옵션은 없어서 직접 *와 ,를 연결한 경로를 지정(경로패턴)해줘야 전체 프로젝트 검색이 된다. | . select-string *, */* -pattern &quot;LINE&quot; file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . 대소문자를 구분하고 싶다면, 맨 뒤에 -CaseSensitive옵션을 주면 된다. | . 환경변수 설정 . 모바일, 웹 개발시 환경변수를 설정함 | 내 컴퓨터에서 특정한 키워드가 어떤 일을 하거나 경로를 저장할 수 있게 만드는 것. | . env . 지정한 환경변수 목록을 본다. 사용시에는 앞에 $를 붙인다. . env . | . ls env: . powershell에서 보는 환경변수목록. 사용시에는 $env:를 앞에 붙인다. . ls env: . | . export [대문자_변수명]=”경로or문자열” (환경변수 설정) . 대문자를 사용하고 사이에는 _를 이용하여 구분한다. . mkdir dir1 env # 모든 환경 변수 확인 export MY_DIR=&quot;dir1&quot; . | . $env:[환경변수명] = “경로or문자열” for powershell . $env:MY_DIR = &quot;dir1&quot; . cd $환경변수명 (환경변수 사용) . 환경변수를 터미널 등에서 사용할 수 있다. . cd $MY_DIR pwd . | . cd $env:[환경변수명] for powershell . unset 환경변수명 (환경변수 삭제) . unset MY_DIR env . $env:[환경변수명] = “” . powershell에서 환경변수 삭제는 빈 문자열을 넣어서 없애준다. . $env:MY_DIR = &quot;&quot; ls env: . | .",
            "url": "blog.chojaeseong.com/shell/powershell/windowsterminal/windows/2021/08/18/powershell_and_bashshell.html",
            "relUrl": "/shell/powershell/windowsterminal/windows/2021/08/18/powershell_and_bashshell.html",
            "date": " • Aug 18, 2021"
        }
        
    
  
    
        ,"post40": {
            "title": "윈도우 터미널 단축키 모음",
            "content": "단축키 . [ALT] + [SHIFT] + [+] : 가로 창 나누기 ![image-20210715145754288] | [ALT] + [SHIFT] + [-] : 세로 창 나누기 | [ALT] + [SHIFT] + [방향키] : 창 크기 조절 | [ALT] + [방향키] : 커서가 위치하는 창 전환 | [CTRL] + [L] : 클리어 | [CTRL] + [SHIFT] + [ W] : 창 닫기 | [ALT] + [SHIFT] + [D] : 쉘 복제 | [CTRL] + [+/-/마우스 휠] : 글자 크기 조절 | [CTRL] + [,] : 설정 | .",
            "url": "blog.chojaeseong.com/configuration/2021/08/18/WindowTerminal_shortcut.html",
            "relUrl": "/configuration/2021/08/18/WindowTerminal_shortcut.html",
            "date": " • Aug 18, 2021"
        }
        
    
  
    
        ,"post41": {
            "title": "알고리즘 문제 풀기용 array 연습 (python)",
            "content": "input array . 1&#52264;&#50896; list . 10 5 1 10 4 9 2 3 8 5 7 6 . a, b = map(int, input().split()) print(a, b) # 1개는 안된다. 튜플 언패킹시에만 따로 받아진다!! c = map(int, input().split()) print(c) . 10 5 &lt;map object at 0x000001F38F7937C0&gt; . arr = list( map(int, input().split()) ) arr . [1, 10, 4, 9, 2, 3, 8, 5, 7, 6] . 2&#52264;&#50896;(&#44396;&#48516;&#51088;O) . 9 0 0 0 1 1 1 -1 -1 -1 0 0 0 1 1 1 -1 -1 -1 0 0 0 1 1 1 -1 -1 -1 1 1 1 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 1 -1 0 1 -1 0 1 -1 0 -1 1 0 1 -1 0 1 -1 0 1 -1 1 0 -1 0 1 -1 . # - 행수만큼 list comp를 돌리고, # - 그 행의 내부요소들은 1줄을 split -&gt; map(int, ) -&gt; list 까지 만든다. N = int(input().strip()) # paper = [ for i in range(N)] paper = [ list(map(int, input().strip().split())) for i in range(N)] . paper . [[0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, -1, 0, 1, -1, 0, 1, -1], [0, -1, 1, 0, 1, -1, 0, 1, -1], [0, 1, -1, 1, 0, -1, 0, 1, -1]] . 2&#52264;&#50896; &#44396;&#48516;&#51088;X (&#49707;&#51088;&#47196; 1character&#50473;&#47564; &#52264;&#51648;) . 문자열(no split) -&gt; map(1글자를 1글자int로) -&gt; list(1글자들을 열로) | . 3 3 011 111 110 . list(&#39;1019&#39;) . [&#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;9&#39;] . list(map(int, &#39;1019&#39;)) . [1, 0, 1, 9] . # - split대신 list(&#39;문자열&#39;) -&gt; 1글자씩 list # - split대신 list( map(int, &#39;문자열&#39;)) -&gt; 숫자1개씩 list # -- map(int, &#39;문자열&#39;)은 문자열을 하나씩 쪼개받아서 int를씌운다. N, M = map(int, input().split()) # map은 튜플로 할당 받을 수 있다. but 1개 변수에 할당시는 맵객체다. # MIRO = [ for i in range(N) ] # 열은 갯수는 M대신 split이 아닌 문자열-&gt;map-&gt;list -&gt; list(map(())으로 쪼개서 받았다. MIRO = [ list(map(int, input())) for i in range(N) ] . MIRO . [[0, 1, 1], [1, 1, 1], [1, 1, 0]] . &#49440;&#50616; array . input으로 받아서 쪼개서 열을 만들지말고, 이번에는 직접 선언해보자. | numpy를 지원하지 않을 때, 리스트로 만드는 n차원 배열이다. | . INIT = -1 # 각 행렬 요소의 초기화 값이다. W = row = N H = column = M C = channel = 3 B = batch = 3 # 1차원 array : 초기화값이 요소 상태로 list comp D1 = [ INIT for _ in range(W)] # 1차원은 행길이만큼 list comp + [] X -&gt; 행길이만큼 요소롤 복제하도록 list comp + 요소 # D1 = [ INIT ] * N # 요소복제의 2번째 방법, list든 str든 곱하면 extend된다. # - but 내부 list comp 요소 + 외부 [] 그만큼 곱은 주의한다. id가 동일한놈들이 복사된다. # 2차원 array : 행[]들 먼저 행길이만큼 list comp돌고 , 내부 1row를 요소 list comp # D2 = [ [] for _ in range(H)] D2 = [ [ INIT for _ in range(W) ] for _ in range(H)] # 3차원 array : 2차원 밖에 [[]]행렬 갯수만큼 list comp 해줌. D3 = [[[ [ INIT for _ in range(W) ] for _ in range(H)]] for _ in range(C)] # 3차원 array : 2차원 밖에 [[]]행렬 갯수만큼 list comp 해줌. D4 = [[[[ [ INIT for _ in range(W) ] for _ in range(H)]] for _ in range(C)] for _ in range(B)] print(D1) print(D2) print(D3) print(D4) . [-1, -1, -1] [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]] [[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]] [[[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]], [[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]], [[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]]] . 2&#52264;&#50896; &#51025;&#50857; by range . INIT값이 아닌 1부터 순서대로 채운 N*N 행렬 range( , , 열길이)를 이용한다. N씩 건너뛰어서 가니까... | 시작은 1부터 n(n-1) + 2 로 1부터 n-1까지의 합으로 간다? | . | . 1&#48512;&#53552; &#49692;&#49436;&#45824;&#47196; &#52292;&#50868; (N,N)&#54665;&#47148; . 각행의 첫째항을 등차수열(column : N개) 를 이용해서 만들어준다. . 1부터 N의 등차수열 range(1, , N)과 끝값은 N번째항 뽑은 것 + 1 을 넣어준다 | An = a1 + (n-1)d = 1 + n(n-1) -&gt; range( , n*n-1 + 1, ) | . | 각 행렬의 첫째항부터 1씩 증가하여 N개를 채운 행list를 완성한다. . | # - 일단 1 ~ n*(n-1)/2 에서 마지막항의 의미는 그냥 찍어보면 모른다. n = 6 for i in range(1, n*(n-1)+2, n): print(i) print(n*(n-1)+2) . 1 7 13 19 25 31 32 . # - for문 안의 i가 1에서부터 **등차(k)수열**이 되어버림. # 1부터, 등차가 n이면, n열짜리 행1개를 건너띈 다음 행 첫째항이 된다. # 열의 갯수N을 등차로 하여 일반항을 잡고, 행 N개를 가야하므로 # An = 1 + (n-1)*d = n*(n-1) + 1 이 된다. # 등차수열 range(1, ,n)이 n번째항 까지는 가야하므로, n번째항+1을 넣어준 것이다. for i in range(1, n*(n-1)+2, n): print(i, &quot;&lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다.&quot;) . 1 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 7 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 13 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 19 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 25 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 31 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. . # 2중 list comp는 요소만 노출할 경우, 1차원 행렬밖에 # - list로 만들경우, 각 요소들이 list로.. # - 행단위로 묵어서는 못만든다 -&gt; result = [] for문 이용 n = 5 result = [] for i in range(1, n*(n-1)+2, n): # 첫째항 i, 등차1 의 수열을 1~n항까지 listcomp로 모으기 result.append([ i+(j-1)*1 for j in range(1, n+1)]) result . [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]] . # 행마다 돌면서 row에접근후 인덱싱.. [ row[4:6] for row in paper[4:7]] . [[0, 0], [0, 0], [1, -1]] . def check_valid(matrix): print(&quot;dict상태&gt;&gt;&gt;&quot;, count_dict) if len(matrix) == 1: print(&quot;1개짜리 돌입. matrix &gt;&gt;&gt;&quot;, matrix) # 1개짜리라면.. 넣고 +1 count_dict.setdefault(matrix[0][0], 0) count_dict[matrix[0][0]] +=1 return True paper_0_0 = matrix[0][0] flag = False for i in range(len(matrix)): for j in range(len(matrix)): if paper_0_0 != matrix[i][j]: flag = True break if flag: print(&quot;다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : &quot;,matrix ) N = len(matrix) # 3x3중 1x1 -&gt; 열 3구간 다 check_valid([ row[:N//3] for row in matrix[:N//3]]) check_valid([ row[N//3:(N//3)*2] for row in matrix[:N//3]]) check_valid([ row[(N//3)*2:] for row in matrix[:N//3]]) # 3x3중 2x2 check_valid([ row[:N//3] for row in matrix[N//3:(N//3)*2]]) check_valid([ row[N//3:(N//3)*2] for row in matrix[N//3:(N//3)*2]]) check_valid([ row[(N//3)*2:] for row in matrix[N//3:(N//3)*2]]) # 3x3중 3x3 check_valid([ row[:N//3] for row in matrix[(N//3)*2:]]) check_valid([ row[N//3:(N//3)*2] for row in matrix[(N//3)*2:]]) check_valid([ row[(N//3)*2:] for row in matrix[(N//3)*2:]]) else: print(&quot;다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix:&quot;, matrix) count_dict.setdefault(paper_0_0, 0) count_dict[paper_0_0] += 1 return True count_dict = {} check_valid(paper) . dict상태&gt;&gt;&gt; {} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, -1, 0, 1, -1, 0, 1, -1], [0, -1, 1, 0, 1, -1, 0, 1, -1], [0, 1, -1, 1, 0, -1, 0, 1, -1]] dict상태&gt;&gt;&gt; {} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] dict상태&gt;&gt;&gt; {0: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[1, 1, 1], [1, 1, 1], [1, 1, 1]] dict상태&gt;&gt;&gt; {0: 1, 1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]] dict상태&gt;&gt;&gt; {0: 1, 1: 1, -1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[1, 1, 1], [1, 1, 1], [1, 1, 1]] dict상태&gt;&gt;&gt; {0: 1, 1: 2, -1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] dict상태&gt;&gt;&gt; {0: 2, 1: 2, -1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] dict상태&gt;&gt;&gt; {0: 3, 1: 2, -1: 1} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 1, -1], [0, -1, 1], [0, 1, -1]] dict상태&gt;&gt;&gt; {0: 3, 1: 2, -1: 1} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 4, 1: 2, -1: 1} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 4, 1: 3, -1: 1} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 4, 1: 3, -1: 2} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 5, 1: 3, -1: 2} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 5, 1: 3, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 5, 1: 4, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 6, 1: 4, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 6, 1: 5, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 6, 1: 5, -1: 4} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 1, -1], [0, 1, -1], [1, 0, -1]] dict상태&gt;&gt;&gt; {0: 6, 1: 5, -1: 4} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 7, 1: 5, -1: 4} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 7, 1: 6, -1: 4} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 7, 1: 6, -1: 5} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 8, 1: 6, -1: 5} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 8, 1: 7, -1: 5} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 8, 1: 7, -1: 6} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 8, 1: 8, -1: 6} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 9, 1: 8, -1: 6} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 9, 1: 8, -1: 7} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 1, -1], [0, 1, -1], [0, 1, -1]] dict상태&gt;&gt;&gt; {0: 9, 1: 8, -1: 7} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 10, 1: 8, -1: 7} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 10, 1: 9, -1: 7} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 10, 1: 9, -1: 8} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 11, 1: 9, -1: 8} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 11, 1: 10, -1: 8} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 11, 1: 10, -1: 9} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 12, 1: 10, -1: 9} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 12, 1: 11, -1: 9} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] . print(*map(lambda x:x[1], sorted(count_dict.items(), key=lambda x:x[0]))) . 10 12 11 .",
            "url": "blog.chojaeseong.com/boj/python/array/2021/08/12/python_%EB%B0%B0%EC%97%B4_%EC%97%B0%EC%8A%B5.html",
            "relUrl": "/boj/python/array/2021/08/12/python_%EB%B0%B0%EC%97%B4_%EC%97%B0%EC%8A%B5.html",
            "date": " • Aug 12, 2021"
        }
        
    
  
    
        ,"post42": {
            "title": "파이썬을 파이썬답게 노트정리",
            "content": "&#52636;&#51200; . 파이썬을 파이썬답게 실습강의를 듣고 느낀점과 함께 풀어낸 노트입니다. | . &#44277;&#48512; &#51060;&#50976; . 정수를 담은 이차원 리스트, mylist 가 solution 함수의 파라미터로 주어집니다. mylist에 들은 각 원소의 길이를 담은 리스트를 리턴하도록 solution 함수를 작성해주세요. . 제한 조건 | mylist의 길이는 100 이하인 자연수입니다. | mylist 각 원소의 길이는 100 이하인 자연수입니다. | . | 위 문제를 아래와 같이 짰다면, 수강해야한다. 나는 list comp로 짬 . | . 아래와 같은 풀이는 c언어 or 자바 풀이임. . | 이것과 같이 짜야함 . | . 용어 설명 iterable: 자신의 멤버를 한 번에 하나씩 리턴할 수 있는 객체입니다. list, str, tuple, dict 등이 여기에 속합니다. | sequence: int 타입 인덱스를 통해, 원소에 접근할 수 있는 iterable 입니다. iterable의 하위 카테고리라고 생각하시면 됩니다. | list, str, tuple이 여기 속합니다. ( dictionary는 다양한 타입을 통해 원소에 접근할 수 있기 때문에 sequence에 속하지 않습니다.) | . | unpacking: 적절한 번역을 찾고 있습니다. | . | . &#51221;&#49688; (2) . &#47787;&#44284; &#45208;&#47672;&#51648; . 문제 설명 숫자 a, b가 주어졌을 때 a를 b로 나눈 몫과 a를 b로 나눈 나머지를 공백으로 구분해 출력해보세요. 입력 설명 입력으로는 공백으로 구분된 숫자가 두 개 주어집니다. 첫 번째 숫자는 a를 나타내며, 두 번째 숫자는 b를 나타냅니다. 출력 설명 a를 b로 나눈 몫과 a를 b로 나눈 나머지를 공백으로 구분해 출력하세요. 제한 조건 a와 b는 자연수입니다. . &#45236;&#54400;&#51060;(list comp) . input_ = &#39;5 3&#39; num_ = input_.strip().split(&#39; &#39;) a, b = [int(x) for x in num_] str(a//b) + &#39; &#39; + str(a%b) . &#39;1 2&#39; . &#45712;&#45184;&#51216; (divmod + unpacking) . divmod는 한번에 목과 나머지를 구한다. //, %보단 느리지만, 갯수가 많을 땐 더 빨라진다고 한다. | 데이터 변환을 list comp전에 map(str, ) map(int, )도 활용해보자. | tuple을 unpacking(콤마할당)을 하면, iterable객체(tuple)이 알아서 나뉜다. | . a, b = map(int, input_.strip().split(&#39; &#39;)) . a . 5 . b . 3 . divmod(a, b) # 순서대로 몫, 나머지를 반환함. . (1, 2) . print(*divmod(a, b)) #unpakcking을 print하면, 각각을 공백으로 나누어서 프린트해준다. . 1 2 . (&#52428;) n&#51652;&#48277;&#51004;&#47196; &#54364;&#44592;&#46108; string&#51012; 10&#51652;&#48277; &#49707;&#51088;&#47196; &#48320;&#54872;&#54616;&#44592; . 문제 설명 base 진법으로 표기된 숫자를 10진법 숫자 출력해보세요. 입력 설명 입력으로는 공백으로 구분된 숫자가 두 개 주어집니다. 첫 번째 숫자는 num을 나타내며, 두 번째 숫자는 base를 나타냅니다. 출력 설명 base 진법으로 표기된 num을 10진법 숫자로 출력해보세요. 제한 조건 base는 10 이하인 자연수입니다. num은 3000 이하인 자연수입니다. 예시 input output 12 3 5 444 5 124 입출력 예 설명 입출력 예 1 3진법으로 표기된 12는 10진법으로 표현하면 5입니다. ( 1*3 + 2 ) 입출력 예 2 5진법으로 표기된 444는 10진법으로 표현하면 124입니다. ( 455 + 4*5 + 4 ) . &#45236;&#54400;&#51060; . num, base = map(int, input().strip().split(&#39; &#39;)) div_sum = 0 for n in sorted(range(0, len(str(num))), reverse=True): k, num = divmod(num, 10**(n)) div_sum += k * (base**(n)) print(div_sum) . &#51221;&#45813; . n진법으로 표기된 string을 10진법 숫자로 변환하기 - int 함수 . 진법 변환 문제는 알고리즘 문제나 숙제로 자주 나오는 유형이지요. 이번 시간에는 n 진법으로 표기된 문자열을 10진법 숫자로 변환하는 방법을 배워봅시다. . 예시) 5진법으로 적힌 문자열 &#39;3212&#39;를 10진법으로 바꾸기 . 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통 사람들은 for 문을 이용해 숫자를 곱해가며 문제를 풉니다. . num = &#39;3212&#39; base = 5 answer = 0 for idx, number in enumerate(num[::-1]): answer += int(number) * (base ** idx) . 파이썬에서는 파이썬의 int(x, base=10) 함수는 진법 변환을 지원합니다. 이 기본적인 함수를 잘 쓰면 코드를 짧게 쓸 수 있고, 또 시간을 절약할 수 있습니다. . num = &#39;3212&#39; base = 5 answer = int(num, base) . &#45712;&#45184;&#51216;(enumerate, int( , base), &#47928;&#51088;&#50676;&#46020; sequence, [::-1]) . 순서가 필요한 list나 문자열은 enumerate를 활용하자. ex&gt; 진법변환 계산 | 뒤에서부터 시작을 꼭 sorted( ,reverse=True)에 집착X iterable전용인 문자열, array, dataframe등을 생각할 때 [::-1]을 활용하자. 문자열도, list처럼 sequence이다. (flatcontainerimmutablemutable) -&gt; 인덱싱으로 꺼꾸로 시작하게 할 수 있다. | . | 파이썬에서는 진법변환함수를 int( , base)로 제공한다. 필요하다면 쓰자. 진법변환시 첫자리부터 하지말고, str()+ [::-1]을 활용해 일의 자리에서부터 풀자 | . | . num = &#39;432&#39; base = &#39;5&#39; # 일의 자리부터 풀어보자. + enumerate로 번호를 줘가면서 풀어보자. num[::-1] . &#39;234&#39; . answer = 0 for idx, number in enumerate(num[::-1]): answer += int(number) * ( int(base) ** (idx) ) answer . 117 . # base진법으로 표기된 string num을 -&gt; 10진법 숫자(int())변환 answer = int(num, base=int(base)) answer . 117 . &#47928;&#51088;&#50676; (2) . &#47928;&#51088;&#50676; &#51221;&#47148;&#54616;&#44592; . 문제 설명 문자열 s와 자연수 n이 입력으로 주어집니다. 문자열 s를 좌측 / 가운데 / 우측 정렬한 길이 n인 문자열을 한 줄씩 프린트해보세요. 제한조건 s의 길이는 n보다 작습니다. (n - s의 길이)는 짝수입니다. s는 알파벳과 숫자로만 이루어져 있으며, 공백 문자가 포함되어있지 않습니다. . &#45236;&#54400;&#51060; . s, n = input().strip().split(&#39; &#39;) n = int(n) space_num = n-len(s) print(s+&#39; &#39;*space_num) print(&#39; &#39;*(space_num//2)+s+&#39; &#39;*(space_num//2)) print(&#39; &#39;*space_num+s) . abc 7 abc abc abc . &#51221;&#45813; . # -&gt; answer =&#39;&#39; 빈 문자열에 공백의 갯수만큼 돌면서(반복작업용for) 누적합으로 공백을 채운다. s = &#39;가나다라&#39; n = 7 answer = &#39;&#39; for i in range(n-(len(s))): answer+=&#39; &#39; answer+=s answer . &#39; 가나다라&#39; . s = &#39;가나다라&#39; n = 7 s.ljust(7) . &#39;가나다라 &#39; . s.center(7) . &#39; 가나다라 &#39; . s.rjust(7) . &#39; 가나다라&#39; . &#45712;&#45184;&#51216;(ljust, center, rjust) . 문자열로 sequence로 빈리스트+for+append대신 빈문자열+for++=누적합작업을 생각하자 for문을 반복작업에 활용하자. | . | python은 문자열의 공백정렬을 위해 문자열+공백으로 n자리를 채워준다. | string.ljust(공백포함 왼쪽정렬될 n자리), string.center(n), string.rjust() | . &#50508;&#54028;&#48307; &#52636;&#47141;&#54616;&#44592; . 입력으로 0이 주어지면 영문 소문자 알파벳을, 입력으로 1이 주어지면 영문 대문자 알파벳을 사전 순으로 출력하는 코드를 짜세요. 예시 1 입력 0 출력 abcd...(중간생략)..xyz . &#45236;&#54400;&#51060; . ord(&#39;a&#39;) . 97 . chr(97) . &#39;a&#39; . chr(122) . str . chr(65), chr(90) . (&#39;A&#39;, &#39;Z&#39;) . answer = &#39;&#39; for i in range(65, 90+1): answer+=chr(i) print(answer) . ABCDEFGHIJKLMNOPQRSTUVWXYZ . num = int(input().strip()) answer = &quot;&quot; if num: # num이 0이면, 소문자로 # ord(&#39;a&#39;) = 97 -&gt; z -&gt;122 for i in range(65, 90+1): answer+=chr(i) else: for i in range(97, 122+1): answer+=chr(i) print(answer) . 1 ABCDEFGHIJKLMNOPQRSTUVWXYZ . &#51221;&#45813; . import string string.ascii_lowercase # 소문자 abcdefghijklmnopqrstuvwxyz string.ascii_uppercase # 대문자 ABCDEFGHIJKLMNOPQRSTUVWXYZ string.ascii_letters # 대소문자 모두 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ string.digits # 숫자 0123456789 . &#39;0123456789&#39; . num = int(input().strip()) # answer = &quot;&quot; if num: # num이 0이면, 소문자로 # ord(&#39;a&#39;) = 97 -&gt; z -&gt;122 #for i in range(65, 90+1): # answer+=chr(i) print(string.ascii_uppercase) else: #for i in range(97, 122+1): # answer+=chr(i) print(string.ascii_lowercase) # print(answer) . 1 ABCDEFGHIJKLMNOPQRSTUVWXYZ . &#45712;&#45184;&#51216;(str.lower(), upper() -&gt; string&#49345;&#49688;, string&#47784;&#46280;.ascii_ , string&#47784;&#46280;.digits, ) . string모듈이란 것이 따로 있고, 소문자모음, 대문자모음, 소-&gt;대문자모음, 숫자모음을 상수로 제공한다. string.ascii_lowercase # 소문자 abcdefghijklmnopqrstuvwxyz | string.ascii_uppercase # 대문자 ABCDEFGHIJKLMNOPQRSTUVWXYZ | string.ascii_letters # 대소문자 모두 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ | string.digits # 숫자 0123456789 | . | 다른 사람 풀이를 보고선 chr(), ord()를 안써도되고 | 소문자만 or 대문자만 작성해서 str.lower() / str.upper() 메소드도 활용하자. | . | . iterable &#45796;&#47336;&#44592; (4) . Iterable이란? 자신의 멤버를 한번에 리턴할 수 있는 객체입니다. ex) list, str, tuple, dictionary 등 | . &#50896;&#48376;&#51012; &#50976;&#51648;&#54620;&#52292;, &#51221;&#47148;&#46108; &#47532;&#49828;&#53944; &#44396;&#54616;&#44592; - sorted . 파이썬의 sort() 함수를 사용하면 리스트의 원소를 정렬할 수 있습니다. 이때, sort 함수는 원본의 멤버 순서를 변경하지요. 따라서 원본의 순서는 변경하지 않고, 정렬된 값을 구하려면 sort 함수를 사용할 수 없습니다. . 이런 경우는 어떻게 해야 할까요? . 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통 사람들은 deep copy와 sort 함수를 이용합니다. . list1 = [3, 2, 1] list2 = [i for i in list1] # 또는 copy.deepcopy를 사용 list2.sort() . 파이썬에서는 파이썬의 sorted를 사용해보세요. 반복문이나, deepcopy 함수를 사용하지 않아도 새로운 정렬된 리스트를 구할 수 있습니다. . list1 = [3, 2, 1] list2 = sorted(list1) . &#45712;&#45184;&#51216; - (copy.deepcopy() -&gt; sort() &#50752; sorted() ) . sort()함수는 객체 직접 변환을 하니, &lt;같은값 할당은 shallow copy지만&gt; copy.deepcopy()이후 sort()를 한다고 한다. | sorted()는 새로운 정렬 list를 바로 반환한다. 그 인자로는 reverse=True, key=len, key=str.lower, key=lambda 등 정렬기준을 만드는 함수를 인자로 넣을 수 도 있다. | . | . (&#52428;) 2&#52264;&#50896; &#47532;&#49828;&#53944; &#46244;&#51665;&#44592; ( transpose&#47928;&#51228;, &#50612;&#47140;&#50880; ) . 다음을 만족하는 함수, solution을 완성해주세요. solution 함수는 이차원 리스트, mylist를 인자로 받습니다 solution 함수는 mylist 원소의 행과 열을 뒤집은 한 값을 리턴해야합니다. 예를 들어 mylist [[1, 2, 3], [4, 5, 6], [7, 8, 9]]가 주어진 경우, solution 함수는 [[1, 4, 7], [2, 5, 8], [3, 6, 9]] 을 리턴하면 됩니다. 제한 조건 mylist의 원소의 길이는 모두 같습니다. mylist의 길이는 mylist[0]의 길이와 같습니다. 각 리스트의 길이는 100 이하인 자연수입니다. . &#54400;&#51060;2&#44032;&#51648;(&#51221;&#52376;&#44592;&#49885;i&gt;j, &#48712;_list [i]&#54665;&#44284; for j &#44592;&#51316;list[j][i]&#50676;&#51012; &#54620; &#49464;&#53944;&#47196; ) . mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] mylist[::-1] # 1x1 -&gt; 1 # 2x2 -&gt; 3 # 3x3 -&gt; 5 # nxn -&gt; 2n-1 line # 각 k in 2n-1 마다.. # k=1, -&gt; 길이 1 0.0 # k=2, -&gt; 길이 2 1.0 0.1 # k=3, -&gt; 길이 3 2.0 1.1 0.2 # k=4, -&gt; 길이 2 # k=5, -&gt; 길이 5 # gg . [[7, 8, 9], [4, 5, 6], [1, 2, 3]] . # 타 문제에서는 각 행마다 길이가 같다는 보장이 없기 때문??? 이번 강의에서는 zip 함수를 이용해 2차원 배열을 뒤집는 방법을 알아봅시다. 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통은 다음과 같이 2중 for 문을 이용해 리스트의 row와 column을 뒤집습니다. . [[]]*4 . [[], [], [], []] . [[]]*len(mylist) . [[], [], []] . &#45712;&#45184;&#51216;( &#51221;&#52376;&#44592;&#49885;, new_list&#51032; &#54665;i == mylist&#51032; &#50676;i&#47196; &#44256;&#51221;&#49884;&#53020;, j&#47484; &#46028;&#47536; &#49345;&#53468;) . 2중 for문으로 행렬을 뒤집으려면, 빈 list -&gt; 빈 list의 [i]행 고정상태에 append ( mylist [행을 j로 돌리면서] [열은 i열로 고정]시켜서 뽑아낸 것들 ) . 새 list의 i행과 기존 list의 i열을 동일시 하면서 기존 list의 i열 값들을 뽑아내기 위해 j를 돌리면서 append한다. | . | 정처기식으로, i, j가 돌아가는데, 행렬 중에 i&gt;j 부분만 찾아서 한쪽만 swap . | mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] new_list = [[], [], []] for i in range(len(mylist)): for j in range(len(mylist[i])): new_list[i].append(mylist[j][i]) new_list . [[1, 4, 7], [2, 5, 8], [3, 6, 9]] . mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # new_list = [[], [], []] # new_list = [[]]*3 # 주의! 안에 요소가 콤마로 붙는다고 해서 list바깥에서 *3 하지말 것. id똑같은놈들임. # new_list = [[] for x in range(len(mylist))] for i in range(len(mylist)): for j in range(len(mylist)): if i &gt; j: mylist[j][i], mylist[i][j] = mylist[i][j], mylist[j][i] mylist . [[1, 4, 7], [2, 5, 8], [3, 6, 9]] . (&#52428;) 2&#52264;&#50896; &#47532;&#49828;&#53944; &#46244;&#51665;&#44592; - &#11088;&#65039;zip&#11088;&#65039; . &#54400;&#51060; . mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] new_list = list(map(list, zip(*mylist))) . &#45712;&#45184;&#51216;( zip(*&#47588;&#54609; 2&#52264;&#50896; &#47532;&#49828;&#53944;) -&gt; &#44033; &#54665;&#46308;&#47560;&#45796; 1&#44060;&#50473; &#48977;&#50500; tuple&#47196; ) . 행렬(2차원리스트)를 *매핑해서 zip()에 던져주면, 각 행들을 zip(a,b,c,...,n_rows)로 판단해서 나눠쓴다. 즉, for문으로 받을 때는 각 행마다 0열요소들 / 1열 요소들 / ... 들이 튜플로 모여서 들어온다. | . | 번역 : zip(*iterables)는 각 iterables 의 요소들을 모으는 이터레이터를 만듭니다. 튜플의 이터레이터를 돌려주는데, i 번째 튜플은 각 인자로 전달된 시퀀스나 이터러블의 i 번째 요소를 포함합니다. | . | 즉, 각 iter들(*매핑리스트시 - 각행들)의 요소를 하나씩 빼와서 튜플형태로 반환한다. i번째 튜플은 각 데이터(행)의 i번째열들의 모아아두었다. | 길이가 다르면, 짧은 데이터를 기준으로 끝난다. | 원래 집은 **zip으로 튜플들을 반환한다. 꼭 튜플 리스트가 아니더라도 2개의 짝을 이룬 튜플요소들이 반환되면 dict로 반환 가능하다. for문에서는 zip이 반환하는 tuple을 언패킹하는 것일 뿐 | . | . print(mylist) #[[*1*, 2, 3], # [*4*, 5, 6], # [*7*, 8, 9]] zip(*mylist) . [[1, 2, 3], [4, 5, 6], [7, 8, 9]] . &lt;zip at 0x1ed8c381800&gt; . list(zip(*mylist)) # 각 행마다 같은 열들을 튜플로 묶어서, 마치 대각선으로 transpose된다. . [(1, 4, 7), (2, 5, 8), (3, 6, 9)] . list(map(list, zip(*mylist))) # zip으로 만들어진 transpose 튜플 리스트를 map으로 각 요소 list로 변환한다. . [[1, 4, 7], [2, 5, 8], [3, 6, 9]] . print(&#39;mylist&#39;, mylist) print(&#39;*mylist&#39;, *mylist) # 함수에 튜플이나 리스트를 매핑해주면, 알아서 나눠서 쓴다는 의미다. # 인자로 대입한다면, 콤마로 나눠서 넣어줘야한다. (튜플, 리스트로 인자대입X) list(zip(*mylist)) . mylist [[1, 2, 3], [4, 5, 6], [7, 8, 9]] *mylist [1, 2, 3] [4, 5, 6] [7, 8, 9] . [(1, 4, 7), (2, 5, 8), (3, 6, 9)] . list1 = [1, 2, 3, 4, 5] list2 = [100, 120, 30, 300] list3 = [392, 2, 33] answer = [] for number1, number2, number3 in zip(list1, list2, list3): print(number1 + number2 + number3) . 493 124 66 . # 짝을 이룬 튜플리스트는 dict로 변환가능하다! animals = [&#39;cat&#39;, &#39;dog&#39;, &#39;lion&#39;] sounds = [&#39;meow&#39;, &#39;woof&#39;, &#39;roar&#39;] # print(list(zip(animals, sounds))) dict(zip(animals, sounds)) . [(&#39;cat&#39;, &#39;meow&#39;), (&#39;dog&#39;, &#39;woof&#39;), (&#39;lion&#39;, &#39;roar&#39;)] . {&#39;cat&#39;: &#39;meow&#39;, &#39;dog&#39;: &#39;woof&#39;, &#39;lion&#39;: &#39;roar&#39;} . (&#52428;) i&#48264;&#51704; &#50896;&#49548;&#50752; i+1&#48264;&#51704; &#50896;&#49548; - zip . 숫자를 담은 리스트 mylist가 solution 함수의 파라미터로 주어집니다. solution 함수가 mylist의 i번째 원소와 i+1번째 원소의 차를 담은 일차원 리스트에 차례로 담아 리턴하도록 코드를 작성해주세요. 단, 마지막에 있는 원소는 (마지막+1)번째의 원소와의 차를 구할 수 없으니, 이 값은 구하지 않습니다. 제한 조건 mylist의 길이는 1 이상 100 이하인 자연수입니다. mylist의 원소는 1 이상 100 이하인 자연수입니다. 예시 mylist output [83, 48, 13, 4, 71, 11] [35, 35, 9, 67, 60] 설명: 83과 48의 차는 35입니다. 48과 13의 차는 35입니다. 13과 4의 차는 9입니다. 4와 71의 차는 67입니다. 71과 11의 차는 60입니다. 따라서 [35, 35, 9, 67, 60]를 리턴합니다. . &#54400;&#51060; . def solution(mylist): return [abs(mylist[i] - mylist[i+1]) for i in range(len(mylist)-1)] . &#51221;&#45813; &#48143; &#45712;&#45184;&#51216; (zip( list, list[1:]) -&gt; &#51064;&#45937;&#49905; i&#50752; i+1&#51032; value&#47484; &#46041;&#49884;&#51217;&#44540; ) . 원래는 for i in n-1까지만 돌기 -&gt; [i], [i+1] | zip( list, 1개 모자란 list[1:] ) -&gt; 2개 요소 value 바로 접근 zip은 짧은 것 까지니까 자동으로 (0,1) &gt; (n-1,n) (n, ) | . | def solution(mylist): answer = [] for number1, number2 in zip(mylist, mylist[1:]): answer.append(abs(number1 - number2)) return answer . &#47784;&#46304; &#47716;&#48260;&#51032; type &#48320;&#54872;&#54616;&#44592; . 문제 설명 문자열 리스트 mylist를 입력받아, 이 리스트를 정수형 리스트로 바꾼 값을 리턴하는 함수, solution을 만들어주세요. 예를 들어 mylist가 [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] 인 경우, solution 함수는 [1, 100, 33] 을 리턴하면 됩니다. 제한조건 mylist의 길이는 100 이하인 자연수입니다. mylist의 원소는 10진수 숫자로 표현할 수 있는 문자열입니다. 즉, &#39;as2&#39; 와 같은 문자열은 들어있지 않습니다. 예시 input output [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] [1, 100, 33] . def solution(mylist): return [ int(x) for x in mylist ] . &#45712;&#45184;&#51216;(map -&gt; &#54632;&#49688;&#47484; &#51064;&#51088;&#47196; or lambda ) . list comp도 되지만, list(map(각 요소에 적용함수, 데이터)) 로 데이터 변형 가능 map( 내장함수 or 실행부없는 함수 or lambda, 데이터) | . | . list1 = [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] list2 = list(map(len, list1)) list2 . [1, 3, 2] . map &#54632;&#49688; &#51025;&#50857;&#54616;&#44592; . 문제 설명 정수를 담은 이차원 리스트, mylist 가 solution 함수의 파라미터로 주어집니다. solution 함수가 mylist 각 원소의 길이를 담은 리스트를 리턴하도록 빈칸을 완성해보세요. hint) 이전 강의에서 배운 map 함수를 활용해보세요 제한 조건 mylist의 길이는 100 이하인 자연수입니다. mylist 각 원소의 길이는 100 이하인 자연수입니다. 예시 input output [[1], [2]] [1, 1] [[1, 2], [3, 4], [5]] [2, 2, 1] . def solution(mylist): answer = list(map(len, mylist)) return answer . Sequence Types &#45796;&#47336;&#44592; (2) . sequence &#47716;&#48260;&#47484; &#54616;&#45208;&#47196; &#51060;&#50612;&#48537;&#51060;&#44592; - join . 문자열 리스트 mylist를 입력받아, 이 리스트의 원소를 모두 이어붙인 문자열을 리턴하는 함수, solution을 만들어주세요. 예를 들어 mylist가 [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] 인 경우, solution 함수는 &#39;110033&#39;을 리턴하면 됩니다. 제한 조건 mylist의 길이는 100 이하인 자연수입니다. mylist의 원소의 길이는 100 이하인 자연수입니다. . my_list = [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] answer = &#39;&#39; for value in my_list: answer += value . my_list = [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] answer = &#39;&#39;.join(my_list) . &#45712;&#45184;&#51216;( &#39;&#39;.join(sequence) &#44284; &#48712;&#47928;&#51088;&#50676; +=&#45572;&#51201;&#54633; append ) . 빈_문자열 = &#39;&#39; for in 빈문자열 += string(빈 문자열의 누적합 append) -&gt; python join | . &#49340;&#44033;&#54805; &#48324;&#52237;&#44592; - sequence&#51032; *&#50672;&#49328; . 문제 설명 이 문제에는 표준 입력으로 정수 n이 주어집니다. 별(*) 문자를 이용해 높이가 n인 삼각형을 출력해보세요. 제한 조건 n은 100 이하인 자연수입니다. 예시 입력 3 출력 * ** *** . n = int(input().strip()) for i in range(1,n+1): print((&#39;*&#39;*i).ljust(n)) . 5 * ** *** **** ***** . n = int(input().strip()) for i in range(1,n+1): print((&#39;*&#39;*i).center(n)) . 10 * ** *** **** ***** ****** ******* ******** ********* ********** . &#54400;&#51060; . 이번 강의에서는 곱셈 연산 *를 통해 문자열을 반복하는 방법을 배웁니다. | . 예시) . &#39;abc&#39;, &#39;abcabc&#39;, &#39;abcabcabc&#39;, &#39;abcabcabcabc ...&#39; 과 같이 . &#39;abc&#39;가 n번 반복되는 문자열 만들기 (my) 일정길이 문자열의 누적합 반복 -&gt; *) | . | [123, 456, 123, 456, 123, ...] 과같이 123, 456이 n번 반복되는 리스트 만들기 (my) 리스트 안에 요소들전체 의 append 반복 -&gt; *) | . | . answer = &#39;&#39; n = 5 for _ in range(n): answer += &#39;abc&#39; print(answer) . abcabcabcabcabc . # - sequence라 * 연산을 희한하게 한다. answer = &#39;abc&#39; * n answer . &#39;abcabcabcabcabc&#39; . n = 3 answer= [123, 456] * n print(answer) . [123, 456, 123, 456, 123, 456] . answer[3]=3 answer . [123, 456, 123, 3, 123, 456] . &#45712;&#45184;&#51216; (sequence * -&gt; string*, list*) . 문자열 * n : 문자열을 누적합해서 += 한 것처럼 반복된다. | list * n : 기존요소들전체 append | . Itertools / Collections &#47784;&#46280; (4) . (&#52428;) &#44273;&#51665;&#54633;(Cartesian product) &#44396;&#54616;&#44592; - product . 이번 강의에서는 iterable으로 곱집합을 구하는 방법을 알아봅니다. | 예시) 두 스트링 &#39;ABCD&#39;, &#39;xy&#39; 의 곱집합은 Ax Ay Bx By Cx Cy Dx Dy 입니다. | . iterable1 = &#39;ABCD&#39; iterable2 = &#39;xy&#39; iterable3 = &#39;1234&#39; for value1 in iterable1: for value2 in iterable2: for value3 in iterable3: print(value1, value2, value3) . A x 1 A x 2 A x 3 A x 4 A y 1 A y 2 A y 3 A y 4 B x 1 B x 2 B x 3 B x 4 B y 1 B y 2 B y 3 B y 4 C x 1 C x 2 C x 3 C x 4 C y 1 C y 2 C y 3 C y 4 D x 1 D x 2 D x 3 D x 4 D y 1 D y 2 D y 3 D y 4 . # itertools.product를 이용하면, for 문을 사용하지 않고도 곱집합을 구할 수 있습니다. import itertools iterable1 = &#39;ABCD&#39; iterable2 = &#39;xy&#39; iterable3 = &#39;1234&#39; print(list(itertools.product(iterable1, iterable2, iterable3))) . [(&#39;A&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;A&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;A&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;A&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;4&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;4&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;4&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;4&#39;)] . itertools.product(iterable1, iterable2, iterable3) . &lt;itertools.product at 0x1ed8c4750c0&gt; . import itertools iter1 = list(&#39;ABCD&#39;) iter2 = &#39;조재성 조재경 조아라&#39;.split(&#39; &#39;) iter3 = &#39;1234&#39; print(itertools.product(iter1)) # 1개의 iter도 받으며, list()로 변환해야 보인다. print(list(itertools.product(iter1))) # 1개의 iter도 받으며, list()로 변환해야 보인다. print(list(itertools.product(iter1, iter2))) # 2개의 iterable객체를 넣은 순간부터, 곱집합 튜플들의 리스트가 나온다. # 2중 for문을 도는 효과다. [ a + b + c for a,b,c in itertools.product(iter1, iter2, iter3)][:5] . &lt;itertools.product object at 0x000001ED8C58A940&gt; [(&#39;A&#39;,), (&#39;B&#39;,), (&#39;C&#39;,), (&#39;D&#39;,)] [(&#39;A&#39;, &#39;조재성&#39;), (&#39;A&#39;, &#39;조재경&#39;), (&#39;A&#39;, &#39;조아라&#39;), (&#39;B&#39;, &#39;조재성&#39;), (&#39;B&#39;, &#39;조재경&#39;), (&#39;B&#39;, &#39;조아라&#39;), (&#39;C&#39;, &#39;조재성&#39;), (&#39;C&#39;, &#39;조재경&#39;), (&#39;C&#39;, &#39;조아라&#39;), (&#39;D&#39;, &#39;조재성&#39;), (&#39;D&#39;, &#39;조재경&#39;), (&#39;D&#39;, &#39;조아라&#39;)] . [&#39;A조재성1&#39;, &#39;A조재성2&#39;, &#39;A조재성3&#39;, &#39;A조재성4&#39;, &#39;A조재경1&#39;] . &#45712;&#45184;&#51216;( itertools.product(iter1, 2, 3) -&gt; &#51473;&#52393;for &#48152;&#48373;&#51012; &#51228;&#44144; + &#49692;&#49436;&#45824;&#44032; &#51221;&#54644;&#51652; &#51312;&#54633;&#51060;&#45796;.) . itertools.product의 결과물은 list()를 씌워야 튜플 리스트로 들어온다. 1개의iter를 넣어도 (a, ) (b, )의 튜플형태로 받는다. | . | zip은 i, i+1, 같은 위상의 iter들을 동시에 받거나 *2차원리스트 등을 받아서 -&gt; 1차원으로 동시에 처리 itertools.product는 for iter1, for iter2처럼, 누적해서 곱집합을 처리한다. | . | 문자열도 iter로 인식하여 한 문자씩 돌아간다. | . (&#52428;) 2&#52264;&#50896; &#47532;&#49828;&#53944;&#47484; 1&#52264;&#50896; &#47532;&#49828;&#53944;&#47196; &#47564;&#46308;&#44592; - from_iterable . &#45236;&#54400;&#51060;(no pythonic) . def solution(mylist): answer = [] for list_ in mylist: for li in list_: answer.append(li) return answer . my_list = [[1, 2], [3, 4], [5, 6]] [ li for list_ in my_list for li in list_ ] . [1, 2, 3, 4, 5, 6] . &#51221;&#45813; . # 빈리스트[]에 +로 &lt;&lt;괄호떼고&gt;&gt;누적합으로 이어붙이기 . my_list = [[1, 2], [3, 4], [5, 6]] answer = [] for element in my_list: answer += element answer . [1, 2, 3, 4, 5, 6] . sum(my_list, []) . [1, 2, 3, 4, 5, 6] . print(itertools.chain.from_iterable( my_list ) ) list(itertools.chain.from_iterable( my_list ) ) . &lt;itertools.chain object at 0x000001ED8C79CE20&gt; . [1, 2, 3, 4, 5, 6] . # itertools.chain()은 여러 1차 iterable(1글자씩조합-문자열 or list 등)을 분해해서 # -&gt; 통합한 1차 iterable을 만든다. list(itertools.chain(&#39;ABC&#39;, [&#39;abc&#39;,2,3], &#39;F&#39;)) . [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;abc&#39;, 2, 3, &#39;F&#39;] . list(itertools.chain(my_list)) list(itertools.chain(*my_list)) . [1, 2, 3, 4, 5, 6] . 파이썬 * 의 사용 (https://mingrammer.com/understanding-the-asterisk-of-python/) 곱셈 및 거듭제곱 연산으로 사용할 때 | 리스트형 컨테이너 타입의 데이터를 반복 확장하고자 할 때 | 가변인자 (Variadic Arguments)를 사용하고자 할 때 -&gt; 인자시 패킹(내부에서는 *떼고 묶어서 써줘) | 컨테이너 타입의 데이터를 Unpacking 할 때 -&gt; 사용시언패킹(알아서 쪼개줘) | . | . from functools import reduce primes = [2, 3, 5, 7, 11, 13] def product(*numbers): p = reduce(lambda x, y: x * y, numbers) return p product(*primes) # product() 함수가 &lt;이미 내부에서&gt; 가변인자를 받고 있기 때문에, # 실제 입력시에는 콤마로 언패킹상태로 리스트의 데이터를 모두 unpacking하여 함수에 전달해야한다. # -&gt; 인자가 패킹하고있다면, 실제 대입은 콤마, , ,로 나눠서 주던지 *iterable로 알아서 처리하라고 넘겨주면 된다. # 30030 product(primes) # XXXXXXXXXX -&gt; 콤마로 줘야할 곳을 list로 주고 있다. *list로 하면 콤마로 알아서 입력해줘다. # [2, 3, 5, 7, 11, 13] . [2, 3, 5, 7, 11, 13] . list(itertools.chain.from_iterable( my_list )) . [1, 2, 3, 4, 5, 6] . from functools import reduce reduce(lambda x, y: x+y, my_list) from operator import add reduce(add, my_list) . [1, 2, 3, 4, 5, 6] . &#45712;&#45184;&#51216;( 2&#52264;&#50896; : [ ] for += &#44292;&#46524;&#51060;&#50612;&#48537;&#51060;&#44592; / sum( , start =[ ]) / &#54620;&#44732;&#54400; : itertools.chain(*)&#44284; &#51088;&#46041; 2&#44732;&#54400;: chain.from_iterable() / reduce(lambda x,y:x(list)+(new_list), &lt;--2&#52264;&#50896;&#47532;&#49828;&#53944;) . 가장 단순하게 2중 for문 or 2중 list comp로 element까지 가는 것 | 비 파이썬이라도 빈_list[ ]에 for문 1개의 list element에서 append가 아닌 빈_list += 괄호떼고 이어붙이기 | 내장sum(iter)함수에 , start=값을 default 0이 아닌 빈 []에다가 iter각 요소(2차원-&gt;1차원 리스트들)누적되도록 ! sum(iter , start = [] ) | itertools.chain( 1차원or문자열 iterable1 , iter2, ... ) -&gt; 문자열은 1개씩 풀어서, list는 element단위로 풀어서 1차원 iterable로 통합 itertools.chain()은 여러 1차 iterable들을 각각 분해하여 각각 한꺼풀만 벗겨, 통합한 1차 iterable을 만든다. | 2차원을 넣으면 그대로 2차원 반환됨. 한 꺼풀만 벗겨서 다시 통합하므로 -&gt; chain(*2차원)으로 사용시언패킹 시켜주자 | . | %timeit 결과를 보면 sum()함수만 끔찍하게 느리고 나머지 셋은 고만고만함을 알 수 있다. 성능과 가독성 중 무엇을 중시하냐의 차이지만 개인적으로 itertools.chain() 자체도 가독성이 나쁘다고 볼 수 없기에 sum()보다는 chain()을 쓰지 않을까 싶다. | . reduce도 각 데이터 요소들이 와서 연산하는데 lambda로 +연산 or operator.add를 사용해서 list들이 += 누적합이 되도록 해주면 된다. | from itertools import permutations sorted(list(permutations([2, 1,3], 2))) . [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] . (&#52428;) &#49692;&#50676;&#44284; &#51312;&#54633; - combinations, permutations . 문제 설명 숫자를 담은 일차원 리스트, mylist에 대해 mylist의 원소로 이루어진 모든 순열을 사전순으로 리턴하는 함수 solution을 완성해주세요. 제한 조건 mylist 의 길이는 1 이상 100 이하인 자연수입니다. 예시 mylist output [2, 1] [[1, 2], [2, 1]] [1, 2, 3] [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] . from itertools import permutations sorted(list(permutations([2, 1,3],2))) . [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] . &#54056;&#53412;&#51648; &#50630;&#51060; &#49692;&#50676; &#44396;&#54788;( &#54532;&#47196;&#44536;&#47000;&#47672;&#49828; while. &#50612;&#47140;&#50880;) . # # - 자기자신의 index와 value가 같아지는 순간까지만 반복되다가, 다음 index로 넘어가서 반복된다. # # - index가 더크면, 값+1 index 초기화후 # # - 값이 더크거나 같으면, &lt;인덱스+1&gt; 값 초기화 # # my) 값을 인덱스랑 같아질때까지 늘려주는데, 값 증가시 그때마다 i=0부터 시작.. -&gt; 같아지면 index+1 값은 0 # # my) index가 n-1까지 = arr갯수까지만 시행. # # - 그럼, 0` [0`,0] -&gt; `1 [0,`0] -&gt; `0 [`0,1] -&gt; `1 [0, `1] -&gt; 2 [0, 0] -&gt; 조건위배 while중지 # def permute_first(arr): # result = [arr[:]] # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c, arr, result) # # 1. i번째 데이터가 자기 순서(i)보다 값이 작다? 1증가시키고, 처음부터 돌려라. # if c[i] &lt; i : # c[i] +=1 # 값을 +1 # i = 0 # index를 0부터 다시 시작. # # 2. i번째 데이터가 자기 순서(i)보다 크거나 같다? 값을 초기화시키고, 다음 index순서로 넘어가라 # else: # c[i] = 0 # i+=1 # permute_first([0,0]) . # # my) 값을 인덱스랑 같아질때까지 늘려주는데, 값 증가시 그때마다 i=0부터 시작.. -&gt; 같아지면 index+1 값은 0 # # my) index가 n-1까지 = arr갯수까지만 시행. # # - 그럼, 0` [0`,0] -&gt; `1 [0,`0] -&gt; `0 [`0,1] -&gt; `1 [0, `1] -&gt; 2 [0, 0] -&gt; 조건위배 while중지 # # 3. 인덱스가 짝수면, arr[0]번째 값과 해당 index값 arr[i] swap한다. # def permute_two(arr): # result = [arr[:]] # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c[i], c, arr) # if c[i] &lt; i : # # 3. 인덱스가 짝수면, 원본 0번째 값 현재(짝수번째) 값을 교환. # if i % 2 ==0: # arr[0], arr[i] = arr[i], arr[0] # c[i] +=1 # i = 0 # else: # c[i] = 0 # i+=1 # permute_two([0,1,4]) . # result = [arr[:]] # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c[i], c, arr) # if c[i] &lt; i : # # 3. 인덱스가 짝수면, 0번째 값과, 짝수번째 값을 교환. # if i % 2 ==0: # arr[0], arr[i] = arr[i], arr[0] # # 4. 인덱스가 홀수면, [c list의 i번째 값]을 index로 넣고, 데이터 홀수번재 값을 교환 # else: # arr[c[i]], arr[i] = arr[i], arr[c[i]] # c[i] +=1 # i = 0 # else: # c[i] = 0 # i+=1 # permute_three([0,1,4]) . # # - 값이 index랑 같아지는 부분은 횟수를 늘리는 용도일 뿐이라는 말이다. # def permute_four(arr): # result = [arr[:]] # 2차원에 1번째 행을 원본을 넣어놓는다. # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c[i], c, arr) # if c[i] &lt; i : # # 3. 인덱스가 짝수면, 0번째 값과, 짝수번째 값을 교환. # if i % 2 ==0: # arr[0], arr[i] = arr[i], arr[0] # # 4. 인덱스가 홀수면, [c list의 i번째 값]을 index로 넣고, 데이터 홀수번재 값을 교환 # else: # arr[c[i]], arr[i] = arr[i], arr[c[i]] # # 5. arr결과를 result 2차원 리스트(원본을 1행에 가지고 있던 놈)에 append한다. # # - c[i]가 0에서부터 불들어오는 순간부터 교환후 들어올리네. # result.append(arr[:]) # c[i] +=1 # i = 0 # else: # c[i] = 0 # i+=1 # # 6. result 2차원 리스트를 반환한다. # return result # permute_four([1,2,3]) . def permute(arr): result = [arr[:]] c = [0] * len(arr) i = 0 while i &lt; len(arr): if c[i] &lt; i: if i % 2 == 0: arr[0], arr[i] = arr[i], arr[0] else: arr[c[i]], arr[i] = arr[i], arr[c[i]] result.append(arr[:]) c[i] += 1 i = 0 else: c[i] = 0 i += 1 return result . &#48264;&#50808;) python&#51004;&#47196;&#49692;&#50676; &#44396;&#54788;1 (&#48660;&#47196;&#44536;1, &#51116;&#44480;+&#48520;&#53356;&#44256;&#45124;&#44592; ) . https://shoark7.github.io/programming/algorithm/Permutations-and-Combinations | https://programmers.co.kr/learn/courses/4008/lessons/12836 | . arr = [0,1,2,3] r = 2 # def permutation(arr, r): # 1. used(list) : 해당index의 원소 사용 여부 : arr의 길이만큼 빈 [0] * n를 만들자. # - used(list)에는 해당index의 값이 사용됬는지 안됬는지 체크여부. # - 누적합이 아니라도 여부 등은 0 default에서 1 왔다갔다 하면, if문에 False, True로 걸린다. # used = [0] * len(arr) used = [0 for _ in range(len(arr))] # 2. generate( chosen, used ): 함수로 만들어야 -&gt; 내부에서 같은 로직을 한번 더 호출할 수 있다. # - 일단, 빈 list를 던져주고, 사용여부에 따라 append한 다음, 길이가 원하는 순열길이(r)과 같아졌다면 함수를 끝내는 return해준다. # generate([], used) 형태로 사용된다. def generate(chosen, used): # 2-1) default [] chosen이 원하는 길이를 만족했으면 -&gt; 탈출 -&gt; 그전까지는 내부함수 호출로 반복됨. if len(chosen) == r: print(chosen) # 결과값 저장대신 각각 만들어진 경우를 print한다. return # 2-2) arr길이만큼 반복 -&gt; used의 길이랑 arr이랑 같으며, 같이 움직이니까. # arr와 같은 길이의 used는 arr[i]의 사용여부체크시 used[i]를 사용하는 위에 떠있는 데이터 for i in range(len(arr)): # i번째 원소가 아직 사용이 안됬다? print(&#39;used&#39;, used) if not used[i]: # 사용후 -&gt; 사용표시 1 # - 일단 사용안된 i번째 요소를 chosen에 넣고, 사용했다는 표기를 한다. print(&#39;chosen&#39;, chosen) chosen.append(arr[i]) used[i]=1 # i번재 데이터가 담기고 + 사용되었다는 표시와함께 다시 호출하면 # - 재귀적? 반복적으로... i를 제외하고 사용안된 i를 =1,2,3,4에서부터 찾기..전에... generate(chosen, used) # 내부에서, 길이 못채웠고 &amp; 사용된것 넘어가면서 사용안된 것을 j를 0에서부터 찾는다. # 내부에서, 0은 used[0]이 이미 담겨있으니, 1을 chosen에 넣고, 0,1,을 넣은 상태에다. # 내부에서 또 내부함수가 호출되지만, 초기검사에서 r==2를 만족시켜 반환되며 # 내부j에서는, used[j] = 0을 넣고, 안썼다고 표시 + 데이터도 뺀 체로, j=1이 된다. # i=0는 고정상태에서 j=0을 쓴 뒤, j=1을 쓰고, r==2가 만족되면 j=2로 간다... # i 고정 -&gt; j를 돌면서 -&gt; k에서 갯수가 맞추다가,, j를 다돌면, i가 도나보다... used[i] = 0 chosen.pop() # 재귀를 써서 구하는데 # base case가 chosen == r(input)을 맞추면 끝난다... # 이 함수의 핵심이다. 모든 순열은 arr 의 0부터 i-1 번째 값으로 시작하기에 for 문으로 다 만들어야 한다. # recusive case는 nPr = 시작자리에 arr[i] 가 들어갔다고 치면(for를 n번) = N * n-1Pr 이다. # permutation([0,1,2,3], 2) = # ([0],permutation([1,2,3], 1)) + ([1],permutation([0,2,3], 1)) + ([2],permutation([0,1,3], 1))+ ([3],permutation([0,1,2], 1)) # combination([0,1,2,3], 2) = ([0],combination([1,2,3], 1)) + ([1],combination([2,3], 1)) + ([2],combination([3], 1))) # https://cotak.tistory.com/70 . used [0, 0, 0, 0] chosen [] used [1, 0, 0, 0] used [1, 0, 0, 0] chosen [0] [0, 1] used [1, 0, 0, 0] chosen [0] [0, 2] used [1, 0, 0, 0] chosen [0] [0, 3] used [0, 0, 0, 0] chosen [] used [0, 1, 0, 0] chosen [1] [1, 0] used [0, 1, 0, 0] used [0, 1, 0, 0] chosen [1] [1, 2] used [0, 1, 0, 0] chosen [1] [1, 3] used [0, 0, 0, 0] chosen [] used [0, 0, 1, 0] chosen [2] [2, 0] used [0, 0, 1, 0] chosen [2] [2, 1] used [0, 0, 1, 0] used [0, 0, 1, 0] chosen [2] [2, 3] used [0, 0, 0, 0] chosen [] used [0, 0, 0, 1] chosen [3] [3, 0] used [0, 0, 0, 1] chosen [3] [3, 1] used [0, 0, 0, 1] chosen [3] [3, 2] used [0, 0, 0, 1] . def permutation(arr, r): # 1. arr = sorted(arr) # 해당원소가 사용되고 있는 상태인지 arr와 같은길이의 0과 1로 구성될 list 생성 # - 재귀로 내부에서 함수가 또 불려질텐데, 내부함수가 밖에서 어떤 원소가 고정된 상탠지 알려주기 위해 # - 함수 입장에서 전역변수로 만들어준다. used = [0 for _ in range(len(arr))] def generate(chosen, used): # 2.재귀에서 탈출부이다. chosen이 원하는 갯수 r개가 되면 base case로 print하고 해당함수는 끝난다. # - 내부함수들이 끝나는 것이기에... 어느것이 끝나는지는... if len(chosen) == r: print(chosen) return # 3.i번째를 고정시킨 상태에서, # - i에 불이 안들어와있는 상태다 = 가장 바깥은 필요없지만.. 내부함수들은 바깥에서 고정된 것이기에 피해야한다. for i in range(len(arr)): # 사용했다는 불이 안들어온 상태다. 내부함수가 인식하도록, 내부함수호출직전에 켜주고, 직후에 꺼준다. # 맨바깥은 for로 알아서 i가 돌아가고 있기 때문에 노상관. 내부에서 i불들어온 것 제끼고 r-1개 맞추라는 신호임. if not used[i]: # 4. 내부함수가 i원소를 채운 상태로 재귀호출하도록 넣어주고, 불을 켜준다. chosen.append(arr[i]) used[i] = 1 generate(chosen, used) # 재귀상태로, 1개를 채운상태에서 r-1를 채우려고 호출된다. # 5. i고정상태에서 r-1개를 다채워 r개를 완성했다는 뜻이니, 불을 꺼주고, 빼준다. used[i] = 0 chosen.pop() # 6. 자동으로 다음 i가 고정되서 시작한다. generate([], used) permutation(&#39;ABCD&#39;, 2) . [&#39;A&#39;, &#39;B&#39;] [&#39;A&#39;, &#39;C&#39;] [&#39;A&#39;, &#39;D&#39;] [&#39;B&#39;, &#39;A&#39;] [&#39;B&#39;, &#39;C&#39;] [&#39;B&#39;, &#39;D&#39;] [&#39;C&#39;, &#39;A&#39;] [&#39;C&#39;, &#39;B&#39;] [&#39;C&#39;, &#39;D&#39;] [&#39;D&#39;, &#39;A&#39;] [&#39;D&#39;, &#39;B&#39;] [&#39;D&#39;, &#39;C&#39;] . &#48264;&#50808;2 ) python&#51004;&#47196;&#49692;&#50676; &#44396;&#54788;2 (&#48660;&#47196;&#44536;2, full &#51116;&#44480;&#54632;&#49688;&#47196; &#52376;&#47532;. &#45796;&#49884; &#48380; &#44163;) . # 출처: https://cotak.tistory.com/70 [Pool&#39;s Taek] def gen_permutations(arr, n): result = [] if n == 0: return [[]] for i, elem in enumerate(arr): # i번재 원소만 빼고, 대신 n-1개만 나머지로 순열 부분문제 정복상태 -&gt; 각 요소들P for P in gen_permutations(arr[:i] + arr[i+1:], n-1): # i번째 원소를 맨마지막에 extend해서 붙임. # [[2]] # [[1, 2]] # [[0, 1, 2]] # [[0, 1, 2]] # 순열도 제일 마지막에 첨가하면, 조합처럼 n-1개 완성 + 1개요소(n가지)가 된다? result += [[elem]+P] print(result) break return result arr = [0, 1, 2, 3, 4, 5] print(gen_permutations(arr, 3)) . [[2]] [[1, 2]] [[0, 1, 2]] [[0, 1, 2]] . &#51221;&#45813; . # itertools.permutation를 이용하면, for문을 사용하지 않고도 순열을 구할 수 있습니다. import itertools # pool = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] pool = &#39;ABC&#39; print(list(map(&#39;&#39;.join, itertools.permutations(pool)))) # 3개의 원소로 수열 만들기 print(list(map(&#39;&#39;.join, itertools.permutations(pool, 2)))) # 2개의 원소로 수열 만들기 . [&#39;ABC&#39;, &#39;ACB&#39;, &#39;BAC&#39;, &#39;BCA&#39;, &#39;CAB&#39;, &#39;CBA&#39;] [&#39;AB&#39;, &#39;AC&#39;, &#39;BA&#39;, &#39;BC&#39;, &#39;CA&#39;, &#39;CB&#39;] . &#45712;&#45184;&#51216;(itertools.permutations , combinations) . 문자열로 1글자씩으로 구성된 iter라 순열 또는 조합을 구할 수 있다. 리스트는 튜플 조합 리스트로 / 문자열을 문자열그대로의 리스트로 반환됨. | . | 원하는 구성원소갯수를 지정할 수 있다. | . (&#52428;)&#44032;&#51109; &#47566;&#51060; &#46321;&#51109;&#54616;&#45716; &#50508;&#54028;&#48307; &#52286;&#44592; - Counter . 문제 설명 이 문제에는 표준 입력으로 문자열, mystr이 주어집니다. mystr에서 가장 많이 등장하는 알파벳만을 사전 순으로 출력하는 코드를 작성해주세요. 제한 조건 mystr의 원소는 알파벳 소문자로만 주어집니다. mystr의 길이는 1 이상 100 이하입니다. 예시 input output &#39;aab&#39; &#39;a&#39; &#39;dfdefdgf&#39; &#39;df&#39; &#39;bbaa&#39; &#39;ab&#39; . &#45236;&#54400;&#51060; . dict에 단어마다 count 저장함 | dict를 sorted( , reverse=True, key=lambda x:x[1])로 밸류순으로 역순으로 정렬 -&gt; 가장 첫밸류값이 가장 최대값 | 첫, 두번째 밸류 동점일 수 있으니, value만 뽑은 뒤.. dict.items()를 돌면서 value가 같은 것을 출력함. | . my_str = input().strip() counter_dict = {} for key in my_str: counter_dict.setdefault(key, 0) counter_dict[key]+=1 max_value = sorted(counter_dict.items(), key=lambda x:x[1],reverse=True)[0][1] answer_list = [] for k,v in counter_dict.items(): if v == max_value: answer_list.append(k) print(&#39;&#39;.join(sorted(answer_list))) . aab a . &#51221;&#45813; . # 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통 사람들은 반복문을 이용해 수를 셉니다. my_list = [1, 2, 3, 4, 5, 6, 7, 8, 7, 9, 1, 2, 3, 3, 5, 2, 6, 8, 9, 0, 1, 1, 4, 7, 0] answer = {} for number in my_list: try: answer[number] += 1 except KeyError: answer[number] = 1 print(answer[1]) # = 4 print(answer[3]) # = 3 print(answer[100]) # = raise KeyError . import collections my_str = input().strip() answer = collections.Counter(my_str) print(answer) # dict형태로 출력됨. #Counter객체는 .most_common() 으로 key, count의 튜플리스트가 나옴. answer.most_common() # . asdklfjaskdfekekjek Counter({&#39;k&#39;: 5, &#39;e&#39;: 3, &#39;a&#39;: 2, &#39;s&#39;: 2, &#39;d&#39;: 2, &#39;f&#39;: 2, &#39;j&#39;: 2, &#39;l&#39;: 1}) . [(&#39;k&#39;, 5), (&#39;e&#39;, 3), (&#39;a&#39;, 2), (&#39;s&#39;, 2), (&#39;d&#39;, 2), (&#39;f&#39;, 2), (&#39;j&#39;, 2), (&#39;l&#39;, 1)] . dict_ = {&#39;k&#39;: 5, &#39;e&#39;: 3, &#39;a&#39;: 2, &#39;s&#39;: 2, &#39;d&#39;: 2, &#39;f&#39;: 2, &#39;j&#39;: 2, &#39;l&#39;: 1} dict_.values() # dict_.keys(), dict_.items() max(answer.values()) . 5 . # -&gt; values로 max값 바로 찾을 수 있다. # -&gt; max값을 알 때, for문을 돌면서, key값들을 누적할 수 있다? # -&gt; max값이 여러개일 수 있으니, 미리구한 최대값 == count 하면서 돌아야한다. my_list = input() max_count = max(collections.Counter(my_list).values()) [ word for word, count in collections.Counter(my_list).items() if count == max_count] . aaadddwqierie . [&#39;a&#39;, &#39;d&#39;] . &#45712;&#45184;&#51216; ( collections.Counter - dict + .most_common() ) . 비 파이썬이라도 dict에 저장하는 것은 똑같았다. | collections.Counter() -&gt; dict와 유사하니, Counter.values()로 max()를 구하고 | list comp로 Counter.items()를 k,v를 받아서 필터링하자 | . | 빈도순으로 튜플리스트를 반환하는 것은 .most_common()이다. | &#44592;&#53440; (7) . for &#47928;&#44284; if&#47928;&#51012; &#54620;&#48264;&#50640; - List comprehension&#51032; if &#47928; . 문제 설명 정수를 담은 리스트 mylist를 입력받아, 이 리스트의 원소 중 짝수인 값만을 제곱해 담은 새 리스트를 리턴하는 solution함수를 완성해주세요. 예를 들어, [3, 2, 6, 7]이 주어진 경우 3은 홀수이므로 무시합니다. 2는 짝수이므로 제곱합니다. 6은 짝수이므로 제곱합니다. 7은 홀수이므로 무시합니다. 따라서 2의 제곱과 6의 제곱을 담은 리스트인 [4, 36]을 리턴해야합니다. 제한 조건 mylist는 길이가 100이하인 배열입니다. mylist의 원소는 1이상 100 이하인 정수입니다. . mylist = [3, 2, 6, 7] answer = [number**2 for number in mylist if number % 2 == 0] answer . [4, 36] . &#45712;&#45184;&#51216;( X ) . mylist = [3, 2, 6, 7] answer = [] for number in mylist: if number % 2 == 0: answer.append(number**2) # 들여쓰기를 두 번 함 # 파이썬의 list comprehension을 사용하면 한 줄 안에 for 문과 if 문을 한 번에 처리할 수 있습니다. mylist = [3, 2, 6, 7] answer = [number**2 for number in mylist if number % 2 == 0] . (&#52428;) flag&#48320;&#49688; &#45824;&#49888; for-else &#49324;&#50857;&#54616;&#44592; . 문제 설명 본 문제에서는 자연수 5개가 주어집니다. 숫자를 차례로 곱해 나온 수가 제곱수가 되면 found를 출력하고 모든 수를 곱해도 제곱수가 나오지 않았다면 not found를 출력하는 코드를 작성해주세요. 예시 1 입력 2 4 2 5 1 출력 found 설명 수를 곱해나가면 2, 8, 16, 80, 80 이 나옵니다. 16은 4를 제곱해 나온 수이므로 이 수는 제곱수입니다. 따라서 found를 출력합니다. 예시 2 입력 5 1 2 3 1 출력 not found 설명 수를 곱해나가면 5, 5, 10, 30, 30 이 나옵니다. 이중 어떤 수도 제곱 수가 아니므로 not found를 출력합니다. . data = [ int(input()) for _ in range(5)] import math product = 1 check=False for n in data: product*=n if math.sqrt(product) == int(math.sqrt(product)) : print(&#39;found&#39;) check=True break if check == False: print(&#39;not found&#39;) . 2 4 2 5 1 2 1.4142135623730951 8 2.8284271247461903 16 4.0 found 2 not found . &#51221;&#45813; . # https://harryp.tistory.com/317 [Park&#39;s Life] import math data = [ int(input()) for _ in range(5)] product = 1 # check=False # 1. for내부에 if로 끊김을 나타내는 flag변수를 안쓴다. for n in data: product*=n if math.sqrt(product) == int(math.sqrt(product)) : print(&#39;found&#39;) #check=True break # if check == False: # 2. for가 안끊기고 다 돌았다면, else문 실행시킨다. else: print(&#39;not found&#39;) . 2 4 2 5 1 found . &#45712;&#45184;&#51216;( flag&#48320;&#49688; &#45824;&#49888; for-else&#47928; -&gt; for if &#52286;&#50520;&#51004;&#47732; flag break &#45824;&#49888; for if &#52286;&#50520;&#51004;&#47732;&#52376;&#47532; else&#47803;&#52286;&#50520;&#45796;&#52376;&#47532; + &#51228;&#44273;&#49688; + &#49548;&#49688;&#51216;.0&#51032; int&#54869;&#51064;) . for_if 조건: break -&gt; 만약 다 돌았는데도 if brea에 안걸린 not found == for 다돈 경우 else 조건X시 처리 . 원래는.. for문 내부에서 if 걸렸다? -&gt; break하고 for문 뒤에는 실행 X 를 for문 밖 flag=True/False 변수에 전달해줬다. | 이제는 for문 if 걸려서 flag = True + break -&gt; if flag: 처리는 하지 말자. for문 if 걸려서 break -&gt; 만약 안걸리고 다돌면 처리를 else문에서 | . | . | 제곱수의 판단 : math.sqrt()를 씌웠을 때 int여야한다. . 하지만 sqrt()씌우는 순간 int라도 2.0 3.0 이 되어버린다. | 정수.0의 int 판단방법 int()변환값 == 현재값 ( 전환된 값의 비교로 판단 ) | . | cf) 정수 판단 방법 isinstance( , int) | type( v ) == int | . | . | . &#46160; &#48320;&#49688;&#51032; &#44050; &#48148;&#44984;&#44592; - swap . # 비 파이썬은 덮어쓰기 당할 변수값을 temp에 넣어놓고 덮어쓰기 -&gt; 다른쪽 덮어쓰기 a = 3 b = &#39;abc&#39; temp = a a = b b = temp . 파이썬에서는 다음과 같이 한 줄로 두 값을 바꿔치기할 수 있음. . a = 3 b = &#39;abc&#39; a, b = b, a . (&#52428;) &#51060;&#51652; &#53456;&#49353;&#54616;&#44592; - bisect &#47784;&#46280; . 알고리즘 문제를 풀다 보면 이진 탐색을 써야할 때가 많습니다. 이런 문제를 풀 때마다 이진 탐색 알고리즘을 작성하는 건 비효율적이지요. 이번 시간엔 Python의 이진 탐색 모듈, bisect를 알아봅시다. | . # - while문에 if 탈출(break or def-return)이 없다? -&gt; 다돌고 &lt;조건문 직후 상태&gt;로 빠져나와서 최종 처리한다는 뜻 # ex&gt; while low &lt; high -&gt; low &gt;= high순간에 빠져나옴. 주로 직후인 low==high에서 빠져나와 마지막 처리 def bisect(a, x, lo=0, hi=None): if lo &lt; 0: raise ValueError(&#39;lo must be non-negative&#39;) if hi is None: hi = len(a) while lo &lt; hi: mid = (lo + hi) // 2 if a[mid] &lt; x: lo = mid + 1 else: hi = mid return lo mylist = [1, 2, 3, 7, 9, 11, 33] print(bisect(mylist, 5)) # ??? 없는 것도 나온다? . 3 . # 실제 list index의 +1을 반환하는 것 같다. # ** 해당 숫자 n을 어디에 insert해야하는지의 위치를 보여준다.** # 1) 같은게 있으면? 그 index +1 자리에 넣어라 # 2) 같은게 없으면? 오름차순으로 넣어야할 자리는 여기다. import bisect mylist = [1, 2, 3, 7, 9, 11, 33] print(bisect.bisect(mylist, 9)) # 같은게 4에 있으니 5번째 들어가야한다. print(bisect.bisect(mylist, 33)) # 같은게 6에 있으니 7에 들어가야한다. print(bisect.bisect(mylist, 5)) # 없는데 &lt;&lt;오름차순&gt;&gt; 4-&gt;value 3 뒤의 5자리에 들어가야한다. . 5 7 3 . # index 함수는 이진 탐색이 아닌 선형 탐색 함수입니다. # (물론 주어진 input에 대해서 index 함수를 쓰면 정확한 output 값을 얻을 수 있긴 합니다.) # 이진탐색의 시간복잡도는 O(logN) 이나, # index 함수는 선형탐색을 하므로 시간복잡도가 O(N)이라 시간이 오래 걸립니다. # bisect.bisect(mylist, n)의 n은 mylist에서 찾고자하는 값입니다. # bisect.bisect(mylist, n)이 리턴하는 값, x는 mylist에서 n이 위치한 index의 오른쪽 값을 나타냅니다. # insertion point를 리턴합니다. 즉, 3의 인덱스는 2이므로 이 다음에 있는 insertion point는 2+1 = 3이 되는 것이지요. # 말씀하신대로 bisect는 key 가 없으면 key가 들어갈 위치를 반환합니다. . # - 내뱉은 point가 .. 직전에 같은값이 있어서 그 바로 뒤라면? i-1 반환 # - 내뱉은 point가.. 직전에 같은값은 없으나.. 순서라서 줬다면? 그냥 탐색 실패-&gt; -1반환 import bisect def b_s(ary,key): i= bisect.bisect(ary,key) return i-1 if ary[i-1]==key else -1 . &#45712;&#45184;&#51216;(bisect.bisect( list, value) &gt; return or insert point, &#48148;&#47196;&#50526;&#50640; &#51080;&#44144;&#45208; &#47803;&#52286;&#50520;&#51648;&#47564; &#51221;&#47148;&#49345; &#44536;&#51088;&#47532;) . 정렬된 list라면, 이진탐색을 bisect.bisect로 할 수 있다. return된 값이. 실제 있떤 값이면 i + 1 = return값이다. -&gt; return값 - 1을 하자 | return된 값이. 없으나 정렬상 그자리에 들어가라고 return한 값이다 -&gt; ??? 직전과 값이 같앗 뱉은 건지 확인해야한다. if number == list[return value - 1] -&gt;returnvalue -1 else None.. | . | . | . &#53364;&#47000;&#49828; &#51064;&#49828;&#53556;&#49828; &#52636;&#47141;&#54616;&#44592; - class&#51032; &#51088;&#46041; string casting . 이번 강의에서는 인스턴스 출력 형식을 지정하는 방법을 배워봅시다. . 예) 2차원 평면 위의 점을 나타내는 Coord 클래스의 인스턴스를 (x 값, y 값)으로 출력하기 . class Coord(object): def __init__(self, x, y): self.x, self.y = x, y point = Coord(1, 2) print( &#39;({}, {})&#39;.format(point.x, point.y) ) # 또는 def print_coord(coord): print( &#39;({}, {})&#39;.format(coord.x, coord.y) ) print_coord(point) . # __str__ 메소드를 사용해 class 내부에서 **출력 format**을 지정할 수 있습니다. class Coord(object): def __init__ (self, x, y): self.x, self.y = x, y def __str__ (self): return &#39;({}, {})&#39;.format(self.x, self.y) point = Coord(1, 2) print(point) point . (1, 2) . &lt;__main__.Coord at 0x1ed8d397e80&gt; . &#45712;&#45184;&#51216; ( str&#50724;&#48260;&#46972;&#51060;&#46377; ) . print + interpret에 출력까지 될라면 repr를 오버라이딩한다. | 객체정보를 직접 찍어보지말자! 메소드 정의(비파이썬) 나 메소드 오버라이딩으로 확인하자.! | (&#52428;) &#44032;&#51109; &#53360; &#49688;, inf . 코딩 테스트 문제 등을 풀다 보면, 최솟값을 저장하는 변수에 아주 큰 값을 할당해야 할 때가 있습니다. 이번 시간에는 이때에 사용하기 좋은 inf에 대해 알아봅시다. . 이 기능을 모르시는 분은 본인이 생각하는 임의의 큰 수(99999등)를 할당합니다. . # 비파이썬에서, 최소값을 구할려구 미리 큰값을 넣어올 때, min_val = 99999 min_val &gt; 100000000 # ? . # 파이썬에서, 최소값을 구할려구 미리 큰값을 넣어올 때, # 파이썬이 제공하는 inf 를 사용. inf는 어떤 숫자와 비교해도 무조건 크다고 판정 min_val = float(&#39;inf&#39;) min_val &gt; 10000000000 . inf에는 음수 기호를 붙이는 것도 가능합니다. . max_val = float(&#39;-inf&#39;) . &#45712;&#45184;&#51216; - float(&#39;inf&#39;), float(&#39;-inf&#39;) . 최대값을 찾을 때, 일단 작은값을 변수에 넣어놓고 돈다. 가장 작은 값은 float(&#39;-inf&#39;) / 가장 큰 값은 float(&#39;inf&#39;) 로 초기값을 넣고 해결하자! | . | float(&#39;inf&#39;) . inf . float(&#39;-inf&#39;) . -inf . &#54028;&#51068; &#51077;&#52636;&#47141; &#44036;&#45800;&#54616;&#44172; &#54616;&#44592; - with open as f for line in f.readlines() . 이번 강의에서는 파일 입출력 코드를 간결하게 짜는 법을 알아봅시다. . &#39;myfile.txt&#39;라는 이름의 파일을 읽는 코드를 짜보세요 . # 1. open -&gt; 2. 반복문 while -&gt; 3.line = readlins() + if not line: break + line처리 -&gt; 4. close f = open(&#39;myfile.txt&#39;, &#39;r&#39;) while True: line = f.readline() if not line: break raw = line.split() print(raw) f.close() . FileNotFoundError Traceback (most recent call last) &lt;ipython-input-467-4f9a0ee2adde&gt; in &lt;module&gt; 1 # 비파이썬 2 # 1. open -&gt; 2. 반복문 while -&gt; 3.line = readlins() + if not line: break + line처리 -&gt; 4. close -&gt; 3 f = open(&#39;myfile.txt&#39;, &#39;r&#39;) 4 while True: 5 line = f.readline() FileNotFoundError: [Errno 2] No such file or directory: &#39;myfile.txt&#39; . # with - as 구문을 이용하면 코드를 더 간결하게 짤 수 있습니다. 코드를 아래와 같이 쓰면 다음과 같은 장점이 있습니다. # 1. 파일을 close 하지 않아도 됩니다: with - as 블록이 종료되면 파일이 자동으로 close 됩니다. # 2. readlines가 EOF까지만 읽으므로, while 문 안에서 EOF를 체크할 필요가 없습니다. # my) python은 readlines()가 EOF를 알아서 인식하니 -&gt; 반복문 in 자리에 넣으면 된다. -&gt; EOF 체크 필요없음. with open(&#39;myfile.txt&#39;) as file: for line in file.readlines(): print(line.strip().split(&#39; t&#39;)) . FileNotFoundError Traceback (most recent call last) &lt;ipython-input-468-1cec8ae34904&gt; in &lt;module&gt; 5 6 # my) python은 readlines()가 EOF를 알아서 인식하니 -&gt; 반복문 in 자리에 넣으면 된다. -&gt; EOF 체크 필요없음. -&gt; 7 with open(&#39;myfile.txt&#39;) as file: 8 for line in file.readlines(): 9 print(line.strip().split(&#39; t&#39;)) FileNotFoundError: [Errno 2] No such file or directory: &#39;myfile.txt&#39; . &#45712;&#45184;&#51216; - with as &#50752; python readlines() . with as f -&gt; close 안해도됨 + f.readlines()시 EOF 체크 자동으로 되니 반복문에 바로 삽입 | boj input() 등 f.readlines()와 달리 언제 EOF인지는 모를 땐, try except EOFError로 break해주자. | &#52280;&#44256;) &#51077;&#47141;&#51032; &#45149;(EOF) &#54869;&#51064; by except EOFError: break . f.readlines()는 알아서 EOF(end of file)을 체크하지만, boj등 input()이 언제 EOF인지는 모르니까, try except EOFError로 break해주자. | . | . while 1: try: ins=input() ans = fun(ins) if ans == -1: break; else: print(ans) except EOFError: break .",
            "url": "blog.chojaeseong.com/algorithm/2021/08/11/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_python_pythonic.html",
            "relUrl": "/algorithm/2021/08/11/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_python_pythonic.html",
            "date": " • Aug 11, 2021"
        }
        
    
  
    
        ,"post43": {
            "title": "알고리즘 문제 풀기용 input 코드 모음(python)",
            "content": "&#52280;&#44256; . 블로그 | 그외 백준 공식 레퍼런스 | . input.txt&#47484; &#51060;&#50857;&#54620; local &#54400;&#51060; &#44396;&#51312; . 폴더 input.txt | xxx.py | . | . import sys sys.stdin = open(&quot;./input.txt&quot;, &quot;rt&quot;) # jupyter notebook시 필수 input = sys.stdin.readline # 콘솔에선 미리 안해도되며, 속도향상 필요시만 해준다. / ###################################################### N = int(input()) # print(N) data = list(map(int, input().split())) # print(data) . &#44277;&#48177; &#44592;&#51456; &#45936;&#51060;&#53552; &#51077;&#47141;&#48155;&#44592;(map, int, input.split ) . map객체를 이용해 str -&gt; int 변환했지만, sequence는 아니라 인덱싱을 못한다. a, b = map : 인덱싱은 못해도 할당시 나눠받을 수 있다. | list_ = list(map) : 할당시 나눠받기가 불가능할 정도로 많으면, list()로 sequence로 변환시켜 받아야한다. | . | . # - 1개는 map쓰지말자~! n = int(input().strip()) # 2개 - int a, b= map(int, input().split()) # for문으로 n번 2개씩 n = int(input().strip()) for _ in range(n): a, b= map(int, input().split()) # 3개이상의 - list data = list(map(int, input().split())) # for문으로 n번 3개이상시 n = int(input().strip()) for _ in range(n): data = list(map(int, input().split())) . &#49884;&#44036;&#51012; &#45908; &#48736;&#47476;&#44172; &#45936;&#51060;&#53552; &#51077;&#47141;&#48155;&#44592;(sys &#47784;&#46280;) . sys.stdin.readline() 사용 | 단, 입력 후 엔터가 사용되므로 rstrip() 를 함께 사용 | . import sys str = sys.stdin.readline().rstrip() # 1개 - int import sys n = sys.stdin.readline() # 2개 int import sys N, M = map(int, sys.stdin.readline().split()) # 2차원 리스트 입력 받기 # - 행의 수 N을 입력받고, 각 행의 데이터들을 한번에 받아서 split()해서 열로 들어간다. import sys N = sys.stdin.readline() board = [list(map(int,sys.stdin.readline().split())) for _ in range(N)] . ValueError Traceback (most recent call last) &lt;ipython-input-11-198e9d917b91&gt; in &lt;module&gt; 9 # 2개 int 10 import sys &gt; 11 N, M = map(int, sys.stdin.readline().split()) 12 13 ValueError: not enough values to unpack (expected 2, got 0) . &#44277;&#48177;&#44592;&#51456; &#52636;&#47141;&#49884; *(&#49324;&#50857;&#49884;&#50616;&#54056;&#53433;)&#51004;&#47196; . result = [1, 2, 3] # 기본적인 리스트 출력시 print(result) # [1,2,3] # for loop으로 원소를 하나씩 출력 for i in range(len(result)): print(result[i], end=&#39; &#39;) # 1 2 3 # 리스트의 원소를 언패킹 시켜서 출력 print(*result) # 1 2 3 . [1, 2, 3] 1 2 3 1 2 3 . N x M &#53356;&#44592;&#51032; &#51060;&#52264;&#50896; &#47532;&#49828;&#53944; &#52488;&#44592;&#54868; &#48143; &#51077;&#47141;&#48155;&#44592; . 시뮬레이션 문제에서 주어지는 입력 중 가장 많은 형태의 입력을 list comprehension 으로 받을 수 있다. . n, m = map(int, input().split()) board = [list(map(int, input().split())) for _ in range(n)] visited = [[False]*m for _ in range(n)] print(visited) print(board) # 입력(행 열 -&gt; 열의 갯수만큼 False==0으로 채워진 행x열의 visited 2차원 리스트) # 5 9 # 0 0 0 0 0 0 0 0 0 # 0 0 0 1 1 0 0 0 0 # 0 0 0 1 1 0 1 1 0 # 0 0 1 1 1 1 1 1 0 # 0 0 1 1 1 1 1 0 0 . [[False, False, False, False, False], [False, False, False, False, False], [False, False, False, False, False]] [[3], [3], [3]] . &#51116;&#44480;&#54632;&#49688;&#50640;&#49436; &#53084;&#49828;&#53469; &#51228;&#54620;(&#51116;&#44480;&#54620;&#46020;) &#54400;&#50612;&#51452;&#44592; . import sys; sys.setrecursionlimit(10000) .",
            "url": "blog.chojaeseong.com/algorithm/2021/08/10/boj_input_codes.html",
            "relUrl": "/algorithm/2021/08/10/boj_input_codes.html",
            "date": " • Aug 10, 2021"
        }
        
    
  
    
        ,"post44": {
            "title": "타이타닉 정리",
            "content": "import numpy as np import pandas as pd # %matplotlib nbagg %matplotlib inline import matplotlib.pyplot as plt import matplotlib import seaborn as sns sns.set(font_scale=1.5) sns.set_style(&#39;whitegrid&#39;) #whitegrid sns.set_palette(&#39;muted&#39;) # 한글사용가능하게하기 from matplotlib import font_manager font_name = font_manager.FontProperties(fname=&#39;C:/Windows/Fonts/malgun.ttf&#39;).get_name() matplotlib.rc(&#39;font&#39;, family=font_name) print (plt.rcParams[&#39;font.family&#39;] ) . [&#39;Malgun Gothic&#39;] . &#45936;&#51060;&#53552; &#47196;&#46377; . import pandas as pd train = pd.read_csv(&#39;data/titanic/train.csv&#39;) test = pd.read_csv(&#39;data/titanic/test.csv&#39;) . &#45936;&#51060;&#53552; &#54869;&#51064; . train과 test 비교후, test에 없는 칼럼이 종속변수 | head()와 info()를 비교하여 범주형과 숫자형의 type이 제대로 되었는지 확인하기 | . print(train.shape) print(train.columns) train.head() . (891, 12) Index([&#39;PassengerId&#39;, &#39;Survived&#39;, &#39;Pclass&#39;, &#39;Name&#39;, &#39;Sex&#39;, &#39;Age&#39;, &#39;SibSp&#39;, &#39;Parch&#39;, &#39;Ticket&#39;, &#39;Fare&#39;, &#39;Cabin&#39;, &#39;Embarked&#39;], dtype=&#39;object&#39;) . PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | male | 22.0 | 1 | 0 | A/5 21171 | 7.2500 | NaN | S | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | female | 38.0 | 1 | 0 | PC 17599 | 71.2833 | C85 | C | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | female | 26.0 | 0 | 0 | STON/O2. 3101282 | 7.9250 | NaN | S | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 | 1 | 0 | 113803 | 53.1000 | C123 | S | . 4 5 | 0 | 3 | Allen, Mr. William Henry | male | 35.0 | 0 | 0 | 373450 | 8.0500 | NaN | S | . train.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 891 entries, 0 to 890 Data columns (total 12 columns): PassengerId 891 non-null int64 Survived 891 non-null int64 Pclass 891 non-null int64 Name 891 non-null object Sex 891 non-null object Age 714 non-null float64 SibSp 891 non-null int64 Parch 891 non-null int64 Ticket 891 non-null object Fare 891 non-null float64 Cabin 204 non-null object Embarked 889 non-null object dtypes: float64(2), int64(5), object(5) memory usage: 83.6+ KB . print(test.shape) print(test.columns) test.head() . (418, 11) Index([&#39;PassengerId&#39;, &#39;Pclass&#39;, &#39;Name&#39;, &#39;Sex&#39;, &#39;Age&#39;, &#39;SibSp&#39;, &#39;Parch&#39;, &#39;Ticket&#39;, &#39;Fare&#39;, &#39;Cabin&#39;, &#39;Embarked&#39;], dtype=&#39;object&#39;) . PassengerId Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked . 0 892 | 3 | Kelly, Mr. James | male | 34.5 | 0 | 0 | 330911 | 7.8292 | NaN | Q | . 1 893 | 3 | Wilkes, Mrs. James (Ellen Needs) | female | 47.0 | 1 | 0 | 363272 | 7.0000 | NaN | S | . 2 894 | 2 | Myles, Mr. Thomas Francis | male | 62.0 | 0 | 0 | 240276 | 9.6875 | NaN | Q | . 3 895 | 3 | Wirz, Mr. Albert | male | 27.0 | 0 | 0 | 315154 | 8.6625 | NaN | S | . 4 896 | 3 | Hirvonen, Mrs. Alexander (Helga E Lindqvist) | female | 22.0 | 1 | 1 | 3101298 | 12.2875 | NaN | S | . test.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 418 entries, 0 to 417 Data columns (total 11 columns): PassengerId 418 non-null int64 Pclass 418 non-null int64 Name 418 non-null object Sex 418 non-null object Age 332 non-null float64 SibSp 418 non-null int64 Parch 418 non-null int64 Ticket 418 non-null object Fare 417 non-null float64 Cabin 91 non-null object Embarked 418 non-null object dtypes: float64(2), int64(4), object(5) memory usage: 36.0+ KB . &#52860;&#47100;&#47749; &#49548;&#47928;&#51088;&#47196; &#51068;&#44292;&#48320;&#44221; . &#48169;&#48277;1 : &#46357;&#49492;&#45320;&#47532; &#54805;&#53468;&#47196; &#48320;&#44221;( &#51068;&#48512;&#48516;&#47564; &#44032;&#45733;) . train = train.rename( columns = { &#39;PassengerId&#39; : &#39;passengerid&#39;, &#39;Pclass&#39; : &#39;pclass&#39; , &#39;Name&#39; : &#39;name&#39;, &#39;Sex&#39; : &#39;sex&#39;, &#39;Age&#39; : &#39;age&#39;, &#39;SibSp&#39; : &#39;sibsp&#39;, &#39;Ticket&#39; : &#39;ticket&#39; , &#39;Fare&#39; : &#39;fare&#39;, &#39;Cabin&#39; : &#39;cabin&#39;, &#39;Embarked&#39; : &#39;embarked&#39;, &#39;Parch&#39; : &#39;Parch&#39;.lower() , &#39;Survived&#39; : &#39;survived&#39;, }) . test = test.rename( columns = { &#39;PassengerId&#39; : &#39;passengerid&#39;, &#39;Pclass&#39; : &#39;pclass&#39; , &#39;Name&#39; : &#39;name&#39;, &#39;Sex&#39; : &#39;sex&#39;, &#39;Age&#39; : &#39;age&#39;, &#39;SibSp&#39; : &#39;sibsp&#39;, &#39;Ticket&#39; : &#39;ticket&#39; , &#39;Fare&#39; : &#39;fare&#39;, &#39;Cabin&#39; : &#39;cabin&#39;, &#39;Embarked&#39; : &#39;embarked&#39;, &#39;Parch&#39; : &#39;Parch&#39;.lower() , # &#39;Survived&#39; : &#39;survived&#39;, }) . &#47532;&#49828;&#53944; &#52980;&#54532;&#47532;&#54760;&#49496;&#51012; &#53685;&#54620; &#54620;&#48264;&#50640; &#49548;&#47928;&#51088; &#52376;&#47532; . train.columns . Index([&#39;passengerid&#39;, &#39;survived&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;age&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;ticket&#39;, &#39;fare&#39;, &#39;cabin&#39;, &#39;embarked&#39;], dtype=&#39;object&#39;) . [col.lower() for col in train.columns] . [&#39;passengerid&#39;, &#39;survived&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;age&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;ticket&#39;, &#39;fare&#39;, &#39;cabin&#39;, &#39;embarked&#39;] . train.columns = [col.lower() for col in train.columns] train.head() . passengerid survived pclass name sex age sibsp parch ticket fare cabin embarked . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | male | 22.0 | 1 | 0 | A/5 21171 | 7.2500 | NaN | S | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | female | 38.0 | 1 | 0 | PC 17599 | 71.2833 | C85 | C | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | female | 26.0 | 0 | 0 | STON/O2. 3101282 | 7.9250 | NaN | S | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 | 1 | 0 | 113803 | 53.1000 | C123 | S | . 4 5 | 0 | 3 | Allen, Mr. William Henry | male | 35.0 | 0 | 0 | 373450 | 8.0500 | NaN | S | . &#48276;&#51452; &lt;-&gt; &#49707;&#51088; type &#51228;&#45824;&#47196; &#46104;&#50632;&#45716;&#51648; &#54869;&#51064; . Pclass 범주인데 숫자로 | Survived 범주인데 숫자로 | Parch 도 | Sipsp 도 | . train[&#39;survived&#39;] = train[&#39;survived&#39;].astype( object ) train[&#39;pclass&#39;] = train[&#39;pclass&#39;].astype( object ) train[&#39;parch&#39;] = train[&#39;parch&#39;].astype( object ) train[&#39;sibsp&#39;] = train[&#39;sibsp&#39;].astype( object ) . test[&#39;pclass&#39;] = test[&#39;pclass&#39;].astype( object ) train[&#39;parch&#39;] = train[&#39;parch&#39;].astype( object ) train[&#39;sibsp&#39;] = train[&#39;sibsp&#39;].astype( object ) . Null &#52404;&#53356; . train.isnull().sum() . passengerid 0 survived 0 pclass 0 name 0 sex 0 age 177 sibsp 0 parch 0 ticket 0 fare 0 cabin 687 embarked 2 dtype: int64 . train.isnull().sum().reset_index() . index 0 . 0 passengerid | 0 | . 1 survived | 0 | . 2 pclass | 0 | . 3 name | 0 | . 4 sex | 0 | . 5 age | 177 | . 6 sibsp | 0 | . 7 parch | 0 | . 8 ticket | 0 | . 9 fare | 0 | . 10 cabin | 687 | . 11 embarked | 2 | . missing_df = train.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df . columns count . 0 passengerid | 0 | . 1 survived | 0 | . 2 pclass | 0 | . 3 name | 0 | . 4 sex | 0 | . 5 age | 177 | . 6 sibsp | 0 | . 7 parch | 0 | . 8 ticket | 0 | . 9 fare | 0 | . 10 cabin | 687 | . 11 embarked | 2 | . missing_df = train.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df[&#39;missing_rate&#39;] = missing_df[&#39;count&#39;] / train.shape[0] # 미싱 갯수 / 전체데이터의 데이터수 - shape(row,col)의 첫번째!! missing_df . columns count missing_rate . 0 passengerid | 0 | 0.000000 | . 1 survived | 0 | 0.000000 | . 2 pclass | 0 | 0.000000 | . 3 name | 0 | 0.000000 | . 4 sex | 0 | 0.000000 | . 5 age | 177 | 0.198653 | . 6 sibsp | 0 | 0.000000 | . 7 parch | 0 | 0.000000 | . 8 ticket | 0 | 0.000000 | . 9 fare | 0 | 0.000000 | . 10 cabin | 687 | 0.771044 | . 11 embarked | 2 | 0.002245 | . train . missing_df = train.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df[&#39;missing_rate&#39;] = missing_df[&#39;count&#39;] / train.shape[0] # 미싱 갯수 / 전체데이터의 데이터수 - shape(row,col)의 첫번째!! missing_df.loc[ missing_df[&#39;missing_rate&#39;] != 0, :] # missing_Rate가 0이 아닌 것들만 가졍괴 . columns count missing_rate . 5 age | 177 | 0.198653 | . 10 cabin | 687 | 0.771044 | . 11 embarked | 2 | 0.002245 | . test . missing_df = test.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df[&#39;missing_rate&#39;] = missing_df[&#39;count&#39;] / test.shape[0] # 미싱 갯수 / 전체데이터의 데이터수 - shape(row,col)의 첫번째!! missing_df.loc[ missing_df[&#39;missing_rate&#39;] != 0, :] # missing_Rate가 0이 아닌 것들만 가졍괴 . columns count missing_rate . 4 age | 86 | 0.205742 | . 8 fare | 1 | 0.002392 | . 9 cabin | 327 | 0.782297 | . &#51333;&#49549;&#48320;&#49688; &#54869;&#51064; &#48143; &#51333;&#49549;&#48320;&#49688;&#50640; &#45824;&#54620; &#45796;&#47480;&#48320;&#49688;&#46308; &#44288;&#44228; &#52628;&#47200; . &#51333;&#49549;&#48320;&#49688;&#51032; &#48276;&#51452;&#48324; &#48712;&#46020; &#52404;&#53356; . matplotlib &#44592;&#48376; . train[&#39;survived&#39;].value_counts().plot(kind=&#39;bar&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x259dad8add8&gt; . sns . fig, ax = plt.subplots(1, 2, # 1x2 Pieplot + barplot figsize= (12,8)) # 1 X1 Pie plot train[&#39;survived&#39;].value_counts().plot.pie( explode = [0, 0.1], autopct = &#39;%1.1f%%&#39;, # 퍼센트는 소수점1자리까지 ax = ax[0], shadow = True ) ax[0].set_title(&#39;Pie plot&#39;) ax[0].set_ylabel(&#39;&#39;) # # 1 X 2 bar plot (sns.countplot) # train[&#39;survived&#39;].value_counts().plot( # kind= &#39;bar&#39;, # ax = ax[1], # ) sns.countplot( &#39;survived&#39;, #칼럼명 data = train, # df ax = ax[1] # 좌표평면 ) plt.tight_layout() . import relationship as r r.categorical_all(train, &#39;survived&#39;) . 0 549 1 342 Name: survived, dtype: int64 . &#45800;&#48320;&#49688; &#53456;&#49353;1 : &#48276;&#51452;&#54805; &#52860;&#47100;&#51032; &#48712;&#46020; . &#48276;&#51452;&#54805; &#52860;&#47100;&#47749;&#47564; &#44032;&#51256;&#50724;&#44592; &amp; id&#50752; &#51333;&#49549;&#48320;&#49688; &#51228;&#50808;&#49884;&#53412;&#44592; . train[&#39;survived&#39;].dtypes . train[&#39;survived&#39;].dtypes == &quot;object&quot; . category_feature = [ col for col in train.columns if train[col].dtypes == &quot;object&quot;] category_feature . [&#39;survived&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;ticket&#39;, &#39;cabin&#39;, &#39;embarked&#39;] . id&#52860;&#47100;&#44284; &#51333;&#49549;&#48320;&#49688;&#52860;&#47100; &#51228;&#50808;&#49884;&#53412;&#44592; by set . # set으로 마이너스 연산을 한 뒤, list()로 감싸서 다시 리스트로 만든다. categorical_feature = list( set(category_feature) - set( [&#39;passengerid&#39;, &#39;survived&#39;]) ) categorical_feature . [&#39;embarked&#39;, &#39;ticket&#39;, &#39;parch&#39;, &#39;cabin&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;sibsp&#39;] . &#48276;&#51452;&#52860;&#47100;&#47749; &#47532;&#49828;&#53944;&#47484; &#51060;&#50857;&#54620; &#48276;&#51452;&#52860;&#47100;&#46308; &#54620;&#44732;&#48264;&#50640; &#48712;&#46020; &#48372;&#44592; . for col in categorical_feature: f, ax = plt.subplots(1, 1, figsize=(10,7)) sns.countplot( col, #칼럼명 data = train, # df ) plt.title(col) plt.show() # 여러개 그림을 한셀에 띄울 때, plt.show()를 통해 하나씩 끊어주기! . &#54632;&#49688;&#54868;&#54616;&#44592; ( &#45800;&#48320;&#49688; &#48276;&#51452;&#54805; &#52860;&#47100;&#51032; &#48712;&#46020; ) with &#48276;&#51452;&#54805; &#52860;&#47100;&#47749; &#47532;&#49828;&#53944; . def categorical_all(df, categorical_feature): # 칼럼명 하나만 입력시 if type(categorical_feature) is str: sns.countplot( categorical_feature, #칼럼명 1개 data = df, # df ) plt.title(categorical_feature) #칼럼명 1개 plt.tight_layout() plt.show() # 여러개 그림을 한셀에 띄울 때, plt.show()를 통해 하나씩 끊어주기! else: # 범주형 칼럼명 리스트가 들어왔을 때 for col in categorical_feature: sns.countplot( col, #칼럼명 data = df, # df ) plt.title(col) plt.tight_layout() plt.show() # 여러개 그림을 한셀에 띄울 때, plt.show()를 통해 하나씩 끊어주기! . categorical_all(train, &#39;cabin&#39;) . categorical_all(train, categorical_feature) . &#45800;&#48320;&#49688; &#53456;&#49353;2 : &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252; . &#49707;&#51088;&#54805; &#52860;&#47100;&#47749; &#44032;&#51256;&#50724;&#44592; = &#51204;&#52404;&#52860;&#47100; - &#48276;&#51452;&#54805;&#52860;&#47100; - (id+&#51333;&#49549;&#48320;&#49688;) . train.head() . passengerid survived pclass name sex age sibsp parch ticket fare cabin embarked . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | male | 22.0 | 1 | 0 | A/5 21171 | 7.2500 | NaN | S | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | female | 38.0 | 1 | 0 | PC 17599 | 71.2833 | C85 | C | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | female | 26.0 | 0 | 0 | STON/O2. 3101282 | 7.9250 | NaN | S | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 | 1 | 0 | 113803 | 53.1000 | C123 | S | . 4 5 | 0 | 3 | Allen, Mr. William Henry | male | 35.0 | 0 | 0 | 373450 | 8.0500 | NaN | S | . numerical_feature = list( set(train.columns) - set(categorical_feature) - set([&#39;passengerid&#39;, &#39;survived&#39;]) ) numerical_feature . [&#39;age&#39;, &#39;fare&#39;] . np.sort(numerical_feature) . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . numerical_feature = list( set(train.columns) - set(categorical_feature) - set([&#39;passengerid&#39;, &#39;survived&#39;]) ) numerical_feature = np.sort(numerical_feature) numerical_feature . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252; sns.distplot &#54620;&#44732;&#48264;&#50640; &#44536;&#47532;&#44592; . for col in numerical_feature: print(train[col].describe()) sns.distplot( train.loc[train[col].notnull(), col] ) # 해당칼럼 중 NaN아닌것만 인덱싱한 칼럼만 그리기 plt.title(col) plt.show() . count 714.000000 mean 29.699118 std 14.526497 min 0.420000 25% 20.125000 50% 28.000000 75% 38.000000 max 80.000000 Name: age, dtype: float64 . count 891.000000 mean 32.204208 std 49.693429 min 0.000000 25% 7.910400 50% 14.454200 75% 31.000000 max 512.329200 Name: fare, dtype: float64 . &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252;2 boxplot . for col in numerical_feature: print(train[col].describe()) sns.boxplot( data=train.loc[train[col].notnull(), col] ) plt.title(col) plt.show() . count 714.000000 mean 29.699118 std 14.526497 min 0.420000 25% 20.125000 50% 28.000000 75% 38.000000 max 80.000000 Name: age, dtype: float64 . count 891.000000 mean 32.204208 std 49.693429 min 0.000000 25% 7.910400 50% 14.454200 75% 31.000000 max 512.329200 Name: fare, dtype: float64 . &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252;( hist(dist) + boxplot ) &#54620;&#48264;&#50640; &#44536;&#47532;&#44592; . for col in numerical_feature: # 숫자형 칼럼의 기술통계량 print(train[col].describe()) print(f&quot;Skewed : {train[col].skew():.2f}&quot;) f, ax = plt.subplots(1, 2, figsize=(18,9)) # dist sns.distplot( train.loc[train[col].notnull(), col], ax = ax[0] ) ax[0].set_title(col +&#39; &#39;s hist(dist) plot&#39; ) # boxplot sns.boxplot( data=train.loc[train[col].notnull(), col], ax = ax[1] ) ax[1].set_title(col +&#39; &#39;s boxplot&#39;) plt.tight_layout() plt.show() . count 714.000000 mean 29.699118 std 14.526497 min 0.420000 25% 20.125000 50% 28.000000 75% 38.000000 max 80.000000 Name: age, dtype: float64 Skewed : 0.39 . count 891.000000 mean 32.204208 std 49.693429 min 0.000000 25% 7.910400 50% 14.454200 75% 31.000000 max 512.329200 Name: fare, dtype: float64 Skewed : 4.79 . &#54632;&#49688;&#54868;&#54616;&#44592; ( &#45800;&#48320;&#49688; &#49707;&#51088;&#54805; &#48516;&#54252; dist+boxplot ) with &#49707;&#51088;&#54805; &#52860;&#47100;&#47749; &#47532;&#49828;&#53944; . def numerical_all(df, numerical_feature): for col in numerical_feature: # 숫자형 칼럼의 기술통계량 print(df[col].describe()) print(f&quot;Skewed : {train[col].skew():.2f}&quot;) f, ax = plt.subplots(1, 2, figsize=(18,9)) # dist sns.distplot( df.loc[train[col].notnull(), col], ax = ax[0] ) ax[0].set_title(col +&#39; &#39;s hist(dist) plot&#39; ) ax[0].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 # boxplot sns.boxplot( data=df.loc[df[col].notnull(), col], ax = ax[1] ) ax[1].set_title(col +&#39; &#39;s boxplot&#39;) ax[1].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 plt.tight_layout() plt.show() . &#51060;&#48320;&#49688; &#53456;&#49353;1 : &#51333;&#49549;&#48320;&#49688;(&#48276;&#51452;)&#48324; - &#48276;&#51452;&#54805; &#48320;&#49688; . &#48169;&#48277;1: &#53945;&#51221;(&#51333;&#49549;)&#48276;&#51452;&#48324; &#48276;&#51452;&#52860;&#47100; &#51064;&#45937;&#49905;&#54616;&#50668;&#49436; &#44033; &#48276;&#51452;&#48324; series&#47484; df&#47196; &#54633;&#52824;&#44592; . survived = train.loc[ train[&#39;survived&#39;] == 0,&#39;sex&#39; ].value_counts() survived.name = &#39;Survived&#39; dead = train.loc[ train[&#39;survived&#39;] == 1,&#39;sex&#39; ].value_counts() dead.name = &#39;Dead&#39; # 시리즈를 리스트형식으로 df합치기 df = pd.DataFrame( [ survived, dead] ) df.head() . male female . Survived 468 | 81 | . Dead 109 | 233 | . print(df) df.plot(kind=&#39;bar&#39;) . male female Survived 468 81 Dead 109 233 . &lt;matplotlib.axes._subplots.AxesSubplot at 0x2962005c550&gt; . &#48169;&#48277;2 : pd.crosstab &#51004;&#47196; &#44536;&#47532;&#44592; . &#48712;&#46020; . pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;]) . survived 0 1 . sex . female 81 | 233 | . male 468 | 109 | . pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;]).plot(kind=&#39;barh&#39;, stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x296212901d0&gt; . pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;], margins = True).style.background_gradient(cmap=&#39;summer_r&#39;) . survived 0 1 All . sex . female 81 | 233 | 314 | . male 468 | 109 | 577 | . All 549 | 342 | 891 | . &#48708;&#50984; . cross = pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;]) cross_ratio = cross / cross.sum() cross_ratio . survived 0 1 . sex . female 0.147541 | 0.681287 | . male 0.852459 | 0.318713 | . cross_ratio.plot(kind=&#39;bar&#39;, stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cfa31ef0&gt; . cross_ratio.transpose().plot(kind=&#39;bar&#39;, stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cfd34eb8&gt; . &#48169;&#48277;3 : groupby( &#48276;&#51452;) [ &#51333;&#49549;&#48320;&#49688;].&#51665;&#44228;.unstack() - &#48712;&#46020;+&#54217;&#44512;&#46020; &#44032;&#45733; + &#44032;&#49345;df&#47196;&#49436; apply()&#47196; &#48708;&#50984;&#44228;&#49328;&#44032;&#45733;&#54632; . &#48712;&#46020; . sex_to_survived = train.groupby(&#39;sex&#39;) [&#39;survived&#39;].value_counts().unstack() sex_to_survived . survived 0 1 . sex . female 81 | 233 | . male 468 | 109 | . sex_to_survived.plot(kind=&#39;bar&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cf4b85f8&gt; . &#48708;&#50984; : groupby( [&#39;&#48276;&#51452;&#39; ,&#39;&#51333;&#49549;&#39;]) [&#39;&#51333;&#49549;&#39;] &#51004;&#47196; &#48708;&#50984; &#44228;&#49328;&#54616;&#44592; . 비율을 계산하려면, 숫자칼럼 형태( 범주에서 counts() .unstack()도 먹인상태) | .count().unstack() : 범주별, 종속별, 종속의 범주마다 row단순 count -&gt; 칼럼으로 | .count().unstack() 한 것을 칼럼별로 계산하도록 df/df.sum() 으로 비율계산 | .transpose() 를 통해 index = x축에 종속변수가 가야 비율이 가득찬다 | . dict( list( train.groupby([&#39;sex&#39;, &#39;survived&#39;]) ) ).keys() . dict_keys([(&#39;female&#39;, 0), (&#39;female&#39;, 1), (&#39;male&#39;, 0), (&#39;male&#39;, 1)]) . dict( list( train.groupby([&#39;sex&#39;, &#39;survived&#39;]) ) )[&#39;female&#39;, 0].head() . passengerid survived pclass name sex age sibSp parch ticket fare cabin embarked . 14 15 | 0 | 3 | Vestrom, Miss. Hulda Amanda Adolfina | female | 14.0 | 0 | 0 | 350406 | 7.8542 | NaN | S | . 18 19 | 0 | 3 | Vander Planke, Mrs. Julius (Emelia Maria Vande... | female | 31.0 | 1 | 0 | 345763 | 18.0000 | NaN | S | . 24 25 | 0 | 3 | Palsson, Miss. Torborg Danira | female | 8.0 | 3 | 1 | 349909 | 21.0750 | NaN | S | . 38 39 | 0 | 3 | Vander Planke, Miss. Augusta Maria | female | 18.0 | 2 | 0 | 345764 | 18.0000 | NaN | S | . 40 41 | 0 | 3 | Ahlin, Mrs. Johan (Johanna Persdotter Larsson) | female | 40.0 | 1 | 0 | 7546 | 9.4750 | NaN | S | . train.groupby(&#39;sex&#39;)[&#39;survived&#39;].value_counts() . sex survived female 1 233 0 81 male 0 468 1 109 Name: survived, dtype: int64 . cross_df = train.groupby(&#39;sex&#39;) [&#39;survived&#39;].value_counts().unstack() cross_ratio = cross_df / cross_df.sum() cross_ratio . survived 0 1 . sex . female 0.147541 | 0.681287 | . male 0.852459 | 0.318713 | . cross_ratio.transpose().plot(kind=&#39;bar&#39;, stacked=True, figsize=(10,8)) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196d17e84a8&gt; . &#48169;&#48277;4 : sns.countplot( &#39;&#48276;&#51452;&#52860;&#47100;&#39; , hue= &#39;&#51333;&#49549;&#48320;&#49688;&#39; ) -&gt; &#48708;&#50984;&#51008; &#48380; &#49688; &#50630;&#45796; . sns.countplot(&#39;sex&#39;, data = train, hue=&#39;survived&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cfa68080&gt; . &#48276;&#51452;-&#51333;&#49549;(&#48276;&#51452;) &#51333;&#49549;&#48320;&#49688;&#48324; &#48276;&#51452;&#51032; &#48708;&#50984; &#54620;&#48264;&#50640; &#44536;&#47532;&#44592; . cross_df = train.groupby(&#39;pclass&#39;)[&#39;survived&#39;].value_counts().unstack() # 세로로 합하고, 칼럼별로 나누어 비율계산하기 print(pd.DataFrame(cross_df)) cross_ratio = cross_df/ cross_df.sum() # 세로방향기준으로 각 비율이 나눠져있는데, 그냥 그리면 row별로 x축에 틱이 찍힘 # 뒤집기 cross_ratio = cross_ratio.transpose() cross_ratio.plot(kind=&#39;bar&#39;, stacked=True, figsize=(10,5)) . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . &lt;matplotlib.axes._subplots.AxesSubplot at 0x1dd55006e48&gt; . &#51333;&#49549;-&#48276;&#51452;&#54805;&#48320;&#49688; &#44288;&#44228; &#54632;&#49688;&#51221;&#51032;&#54616;&#44592; . def cate_to_categorical(data,name_c, name_d ): # index 범주형 변수/ col 종속 변수 cross_df = data.groupby( name_c)[name_d].value_counts().unstack() # 세로로 합하고, 칼럼별로 나누어 비율계산하기 print(cross_df) cross_ratio = cross_df/ cross_df.sum() # 세로방향기준으로 각 비율이 나눠져있는데, 그냥 그리면 row별로 x축에 틱이 찍힘 # 뒤집기 cross_ratio = cross_ratio.transpose() f, ax = plt.subplots(1, 2, figsize=(18,9)) cross_df.plot(kind=&#39;bar&#39;, ax=ax[0]) ax[0].set_title(name_c +&#39; to &#39; +name_d ) ax[0].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 cross_ratio.plot(kind=&#39;bar&#39;, ax = ax[1], stacked=True) ax[1].set_title(name_d +&#39; to &#39;+name_c +&#39; ratio&#39; ) ax[1].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0)) # 범례 밖으로 빼기 plt.tight_layout() plt.show() # for문에 들어갈 것 대비 끝내기 . relationship_new.cate_to_categorical(train, &#39;survived&#39;, &#39;sex&#39;) . survived 0 1 sex female 81 233 male 468 109 . cate_to_categorical(train, &#39;survived&#39;, &#39;pclass&#39;) . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . import relationship_new relationship_new.cate_to_categorical(train, &#39;survived&#39;, &#39;pclass&#39;) . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . relationship_new.cate_to_categorical(train, &#39;survived&#39;, &#39;parch&#39;) . survived 0 1 parch 0 445.0 233.0 1 53.0 65.0 2 40.0 40.0 3 2.0 3.0 4 4.0 NaN 5 4.0 1.0 6 1.0 NaN . for+&#54632;&#49688;(&#48276;&#51452;-&#48276;&#51452;)&#47928;&#51012; &#53685;&#54644; &#47784;&#46304; &#51333;&#49549;&#52860;&#47100;&#50640; &#45824;&#54644; &#47784;&#46304; &#48276;&#51452;&#52860;&#47100;&#51032; &#48516;&#54252;&#50752; &#48708;&#50984; &#44536;&#47140;&#48372;&#44592; . 범주가 너무 많을때는 금지!! feature engineering | . for col in categorical_feature: relationship_new.cate_to_categorical(train, &#39;survived&#39;, col) . survived 0 1 embarked C 75 93 Q 47 30 S 427 217 . survived 0 1 sex female 81 233 male 468 109 . survived 0 1 name Abbing, Mr. Anthony 1.0 NaN Abbott, Mr. Rossmore Edward 1.0 NaN Abbott, Mrs. Stanton (Rosa Hunt) NaN 1.0 Abelson, Mr. Samuel 1.0 NaN Abelson, Mrs. Samuel (Hannah Wizosky) NaN 1.0 Adahl, Mr. Mauritz Nils Martin 1.0 NaN Adams, Mr. John 1.0 NaN Ahlin, Mrs. Johan (Johanna Persdotter Larsson) 1.0 NaN Aks, Mrs. Sam (Leah Rosen) NaN 1.0 Albimona, Mr. Nassef Cassem NaN 1.0 Alexander, Mr. William 1.0 NaN Alhomaki, Mr. Ilmari Rudolf 1.0 NaN Ali, Mr. Ahmed 1.0 NaN Ali, Mr. William 1.0 NaN Allen, Miss. Elisabeth Walton NaN 1.0 Allen, Mr. William Henry 1.0 NaN Allison, Master. Hudson Trevor NaN 1.0 Allison, Miss. Helen Loraine 1.0 NaN Allison, Mrs. Hudson J C (Bessie Waldo Daniels) 1.0 NaN Allum, Mr. Owen George 1.0 NaN Andersen-Jensen, Miss. Carla Christine Nielsine NaN 1.0 Anderson, Mr. Harry NaN 1.0 Andersson, Master. Sigvard Harald Elias 1.0 NaN Andersson, Miss. Ebba Iris Alfrida 1.0 NaN Andersson, Miss. Ellis Anna Maria 1.0 NaN Andersson, Miss. Erna Alexandra NaN 1.0 Andersson, Miss. Ingeborg Constanzia 1.0 NaN Andersson, Miss. Sigrid Elisabeth 1.0 NaN Andersson, Mr. Anders Johan 1.0 NaN Andersson, Mr. August Edvard (&#34;Wennerstrom&#34;) NaN 1.0 ... ... ... Widegren, Mr. Carl/Charles Peter 1.0 NaN Widener, Mr. Harry Elkins 1.0 NaN Wiklund, Mr. Jakob Alfred 1.0 NaN Wilhelms, Mr. Charles NaN 1.0 Willey, Mr. Edward 1.0 NaN Williams, Mr. Charles Duane 1.0 NaN Williams, Mr. Charles Eugene NaN 1.0 Williams, Mr. Howard Hugh &#34;Harry&#34; 1.0 NaN Williams, Mr. Leslie 1.0 NaN Williams-Lambert, Mr. Fletcher Fellows 1.0 NaN Windelov, Mr. Einar 1.0 NaN Wiseman, Mr. Phillippe 1.0 NaN Woolner, Mr. Hugh NaN 1.0 Wright, Mr. George 1.0 NaN Yasbeck, Mr. Antoni 1.0 NaN Yasbeck, Mrs. Antoni (Selini Alexander) NaN 1.0 Young, Miss. Marie Grice NaN 1.0 Youseff, Mr. Gerious 1.0 NaN Yousif, Mr. Wazli 1.0 NaN Yousseff, Mr. Gerious 1.0 NaN Yrois, Miss. Henriette (&#34;Mrs Harbeck&#34;) 1.0 NaN Zabour, Miss. Hileni 1.0 NaN Zabour, Miss. Thamine 1.0 NaN Zimmerman, Mr. Leo 1.0 NaN de Messemaeker, Mrs. Guillaume Joseph (Emma) NaN 1.0 de Mulder, Mr. Theodore NaN 1.0 de Pelsmaeker, Mr. Alfons 1.0 NaN del Carlo, Mr. Sebastiano 1.0 NaN van Billiard, Mr. Austin Blyler 1.0 NaN van Melkebeke, Mr. Philemon 1.0 NaN [891 rows x 2 columns] . C: Users is2js Anaconda3 lib site-packages matplotlib tight_layout.py:181: UserWarning: Tight layout not applied. The bottom and top margins cannot be made large enough to accommodate all axes decorations. warnings.warn(&#39;Tight layout not applied. &#39; . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . survived 0 1 cabin A10 1.0 NaN A14 1.0 NaN A16 NaN 1.0 A19 1.0 NaN A20 NaN 1.0 A23 NaN 1.0 A24 1.0 NaN A26 NaN 1.0 A31 NaN 1.0 A32 1.0 NaN A34 NaN 1.0 A36 1.0 NaN A5 1.0 NaN A6 NaN 1.0 A7 1.0 NaN B101 NaN 1.0 B102 1.0 NaN B18 NaN 2.0 B19 1.0 NaN B20 NaN 2.0 B22 1.0 1.0 B28 NaN 2.0 B3 NaN 1.0 B30 1.0 NaN B35 NaN 2.0 B37 1.0 NaN B38 1.0 NaN B39 NaN 1.0 B4 NaN 1.0 B41 NaN 1.0 ... ... ... E12 NaN 1.0 E121 NaN 2.0 E17 NaN 1.0 E24 NaN 2.0 E25 NaN 2.0 E31 1.0 NaN E33 NaN 2.0 E34 NaN 1.0 E36 NaN 1.0 E38 1.0 NaN E40 NaN 1.0 E44 1.0 1.0 E46 1.0 NaN E49 NaN 1.0 E50 NaN 1.0 E58 1.0 NaN E63 1.0 NaN E67 1.0 1.0 E68 NaN 1.0 E77 1.0 NaN E8 NaN 2.0 F E69 NaN 1.0 F G63 1.0 NaN F G73 2.0 NaN F2 1.0 2.0 F33 NaN 3.0 F38 1.0 NaN F4 NaN 2.0 G6 2.0 2.0 T 1.0 NaN [147 rows x 2 columns] . C: Users is2js Anaconda3 lib site-packages matplotlib tight_layout.py:181: UserWarning: Tight layout not applied. The bottom and top margins cannot be made large enough to accommodate all axes decorations. warnings.warn(&#39;Tight layout not applied. &#39; . survived 0 1 ticket 110152 NaN 3.0 110413 1.0 2.0 110465 2.0 NaN 110564 NaN 1.0 110813 NaN 1.0 111240 1.0 NaN 111320 1.0 NaN 111361 NaN 2.0 111369 NaN 1.0 111426 NaN 1.0 111427 NaN 1.0 111428 NaN 1.0 112050 1.0 NaN 112052 1.0 NaN 112053 NaN 1.0 112058 1.0 NaN 112059 1.0 NaN 112277 NaN 1.0 112379 1.0 NaN 113028 1.0 NaN 113043 1.0 NaN 113050 1.0 NaN 113051 1.0 NaN 113055 NaN 1.0 113056 1.0 NaN 113059 1.0 NaN 113501 1.0 NaN 113503 1.0 NaN 113505 NaN 2.0 113509 1.0 NaN ... ... ... SOTON/OQ 392082 1.0 NaN SOTON/OQ 392086 1.0 NaN SOTON/OQ 392089 NaN 1.0 SOTON/OQ 392090 1.0 NaN STON/O 2. 3101269 NaN 1.0 STON/O 2. 3101273 1.0 NaN STON/O 2. 3101274 1.0 NaN STON/O 2. 3101275 1.0 NaN STON/O 2. 3101280 1.0 NaN STON/O 2. 3101285 NaN 1.0 STON/O 2. 3101286 NaN 1.0 STON/O 2. 3101288 NaN 1.0 STON/O 2. 3101289 NaN 1.0 STON/O 2. 3101292 1.0 NaN STON/O 2. 3101293 1.0 NaN STON/O 2. 3101294 1.0 NaN STON/O2. 3101271 1.0 NaN STON/O2. 3101279 1.0 1.0 STON/O2. 3101282 NaN 1.0 STON/O2. 3101283 NaN 1.0 STON/O2. 3101290 1.0 NaN SW/PP 751 NaN 1.0 W./C. 14258 NaN 1.0 W./C. 14263 1.0 NaN W./C. 6607 2.0 NaN W./C. 6608 4.0 NaN W./C. 6609 1.0 NaN W.E.P. 5734 1.0 NaN W/C 14208 1.0 NaN WE/P 5735 1.0 1.0 [681 rows x 2 columns] . C: Users is2js Anaconda3 lib site-packages matplotlib tight_layout.py:181: UserWarning: Tight layout not applied. The bottom and top margins cannot be made large enough to accommodate all axes decorations. warnings.warn(&#39;Tight layout not applied. &#39; . &#51060;&#48320;&#49688; &#53456;&#49353;2 &#49707;&#51088;-&#49707;&#51088;&#54805;&#51032; &#49328;&#51216;&#46020;&#54665;&#47148; with &#51333;&#49549;&#48320;&#49688; . numerical_feature . array([&#39;age&#39;, &#39;fare&#39;, &#39;parch&#39;, &#39;sibsp&#39;], dtype=&#39;&lt;U5&#39;) . # list는 (-)연산은 안되도 (+) 연산은 된다. list(numerical_feature) + [&#39;survived&#39;] . [&#39;age&#39;, &#39;fare&#39;, &#39;parch&#39;, &#39;sibsp&#39;, &#39;survived&#39;] . sns.pairplot( train[ list(numerical_feature) + [&#39;survived&#39;] ], hue = &#39;survived&#39;, x_vars = numerical_feature, y_vars = numerical_feature) . C: Users is2js Anaconda3 lib site-packages statsmodels nonparametric kde.py:448: RuntimeWarning: invalid value encountered in greater X = X[np.logical_and(X &gt; clip[0], X &lt; clip[1])] # won&#39;t work for two columns. C: Users is2js Anaconda3 lib site-packages statsmodels nonparametric kde.py:448: RuntimeWarning: invalid value encountered in less X = X[np.logical_and(X &gt; clip[0], X &lt; clip[1])] # won&#39;t work for two columns. . &lt;seaborn.axisgrid.PairGrid at 0x296230e9828&gt; . &#54632;&#49688;&#54868;( &#49707;&#51088; - &#49707;&#51088;&#51032; &#49328;&#51216;&#46020; &#54665;&#47148; : pairplot) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) by &#49707;&#51088;&#54805;&#52860;&#47100;&#47749;&#47532;&#49828;&#53944; . type(numerical_feature) . numpy.ndarray . list().dtype . AttributeError Traceback (most recent call last) &lt;ipython-input-119-0901fc39190d&gt; in &lt;module&gt; -&gt; 1 list().dtype AttributeError: &#39;list&#39; object has no attribute &#39;dtype&#39; . numerical_feature . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . type(list(numerical_feature)) is list . True . len(numerical_feature) . 2 . def num_to_numerical(df, numerical_feature, name_d=None): # 종속변수 없을 때 if name_d == None: sns.pairplot( df[ list(numerical_feature) ] , # 숫자형칼럼들만 인덱싱 x_vars = numerical_feature, y_vars = numerical_feature ) plt.tight_layout() # 숫자 - 숫자 산점도 행렬 with 종속변수 범례 else: sns.pairplot( df[ list(numerical_feature) + [name_d]] , # 숫자형칼럼들 + 종속변수 인덱싱 hue = name_d, # 범례(색)으로 종속변수 추가 x_vars = numerical_feature, y_vars = numerical_feature ) plt.tight_layout() . num_to_numerical(train, {&#39;age&#39;, &#39;fare&#39;}, &#39;survived&#39;) . &#51060;&#48320;&#49688; &#53456;&#49353;3 : &#48276;&#51452;&#48324; - &#49707;&#51088;&#54805; &#52860;&#47100;(&#46308;)&#51032; &#48516;&#54252;(boxplot) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) by &#49707;&#51088;&#54805;&#52860;&#47100;&#47749;&#47532;&#49828;&#53944; . &#48276;&#51452;&#48324; &#49707;&#51088;&#52860;&#47100;1&#44060;&#51032; &#48516;&#54252;(boxplot) . print(train.groupby(&#39;sex&#39;)[&#39;age&#39;].describe()) plt.figure(figsize=(18,9)) sns.boxplot(x=&#39;sex&#39;, y=&#39;age&#39;, data=train.dropna()) plt.title(&quot;Sex - { }&quot;.format(&#39;age&#39;)) plt.show() . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . KeyError Traceback (most recent call last) &lt;ipython-input-277-1a8c01f185d7&gt; in &lt;module&gt; 2 plt.figure(figsize=(18,9)) 3 sns.boxplot(x=&#39;sex&#39;, y=&#39;age&#39;, data=train.dropna()) -&gt; 4 plt.title(&#34;Sex - { }&#34;.format(&#39;age&#39;)) 5 plt.show() KeyError: &#39; &#39; . &#54632;&#49688;&#54868;(&#48276;&#51452;&#48324; &#49707;&#51088;&#52860;&#47100;1&#44060;&#51032; &#48516;&#54252;(boxplot)) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) . def cate_to_num_box(df, name_c, name_n, name_d=None): # 범주별 기술통계량 if name_d != None: print(df.groupby([name_c, name_d])[name_n].describe()) else : print(df.groupby(name_c)[name_n].describe()) # 범주별 boxplot - 범례는 선택 plt.figure(figsize=(18,9)) sns.boxplot(x=name_c, y=name_n, data=df.dropna(), hue = name_d) plt.title(&quot;{} to {}&quot;.format(name_c, name_n)) plt.tight_layout() plt.show() . cate_to_num_box(train, &#39;sex&#39;, &#39;age&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . type(numerical_feature) . numpy.ndarray . type(&quot;age&quot;) . str . &#54632;&#49688;&#54868;( &#48276;&#51452;&#48324; - &#49707;&#51088;&#52860;&#47100;(&#46308;)&#51032; &#48516;&#54252;(boxplot)) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) . def cate_to_num_box(df, name_c, numerical_feature, name_d=None): # 숫자형 칼럼명 1개 ( 칼럼명 = 문자열 1개 직접 입력) if type(numerical_feature) is str: # 범주별 기술통계량 if name_d != None: print(df.groupby([name_c, name_d])[numerical_feature].describe()) else : print(df.groupby(name_c)[numerical_feature].describe()) # 범주별 boxplot - 범례는 선택 plt.figure(figsize=(18,9)) sns.boxplot(x=name_c, y=numerical_feature, data=df.dropna(), hue = name_d) plt.title(&quot;{} to {}&quot;.format(name_c, numerical_feature)) plt.tight_layout() plt.show() # 숫자형 칼럼명 리스트가 들어와서 for문을 돌면서 여러개 그릴 때 else : for col in numerical_feature: if name_d != None: print(df.groupby([name_c, name_d])[col].describe()) else : print(df.groupby(name_c)[col].describe()) plt.figure(figsize=(18,9)) sns.boxplot(x=name_c, # 범주칼럼명 y=col, # 숫자칼럼명 data=df.dropna() , # df hue = name_d ) # 종속칼럼명(선택) plt.title(&quot;{} to {}&quot;.format(name_c, col)) plt.tight_layout() plt.show() . cate_to_num_box(train, &#39;sex&#39;, &#39;age&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . cate_to_num_box(train, &#39;sex&#39;, &#39;age&#39;, &#39;pclass&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 count mean std min 25% 50% 75% max sex pclass female 1 85.0 34.611765 13.612052 2.00 23.000 35.0 44.00 63.0 2 74.0 28.722973 12.872702 2.00 22.250 28.0 36.00 57.0 3 102.0 21.750000 12.729964 0.75 14.125 21.5 29.75 63.0 male 1 101.0 41.281386 15.139570 0.92 30.000 40.0 51.00 80.0 2 99.0 30.740707 14.793894 0.67 23.000 30.0 36.75 70.0 3 253.0 26.507589 12.159514 0.42 20.000 25.0 33.00 74.0 . numerical_feature . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . cate_to_num_box(train, &#39;sex&#39;, numerical_feature, &#39;pclass&#39;) . count mean std min 25% 50% 75% max sex pclass female 1 85.0 34.611765 13.612052 2.00 23.000 35.0 44.00 63.0 2 74.0 28.722973 12.872702 2.00 22.250 28.0 36.00 57.0 3 102.0 21.750000 12.729964 0.75 14.125 21.5 29.75 63.0 male 1 101.0 41.281386 15.139570 0.92 30.000 40.0 51.00 80.0 2 99.0 30.740707 14.793894 0.67 23.000 30.0 36.75 70.0 3 253.0 26.507589 12.159514 0.42 20.000 25.0 33.00 74.0 . count mean std min 25% 50% sex pclass female 1 94.0 106.125798 74.259988 25.9292 57.24480 82.66455 2 76.0 21.970121 10.891796 10.5000 13.00000 22.00000 3 144.0 16.118810 11.690314 6.7500 7.85420 12.47500 male 1 122.0 67.226127 77.548021 0.0000 27.72810 41.26250 2 108.0 19.741782 14.922235 0.0000 12.33125 13.00000 3 347.0 12.661633 11.681696 0.0000 7.75000 7.92500 75% max sex pclass female 1 134.500000 512.3292 2 26.062500 65.0000 3 20.221875 69.5500 male 1 78.459375 512.3292 2 26.000000 73.5000 3 10.008300 69.5500 . &#51060;&#48320;&#49688; &#53456;&#49353;4 : &#48276;&#51452;&#48324; &#49707;&#51088;&#54805;&#52860;&#47100;&#51032; &#48276;&#50948;&#48324; kde&#48516;&#54252; &#53456;&#49353; . facet = sns.FacetGrid(train, hue = &#39;survived&#39;, height = 4.5,aspect=4) facet.map(sns.kdeplot, &#39;age&#39;, shade=True) facet.set(xlim = (0, train[&#39;age&#39;].max())) facet.add_legend() . &lt;seaborn.axisgrid.FacetGrid at 0x2241e1602b0&gt; . facet = sns.FacetGrid(train, hue = &#39;survived&#39;, aspect=4) facet.map(sns.kdeplot, &#39;age&#39;, shade=True) facet.set(xlim = (0, train[&#39;age&#39;].max())) facet.add_legend() plt.xlim([10,20]) . (10, 20) . &#54632;&#49688;&#54868; . # ( dataFrame, &#39;범주형 칼럼명&#39; , &#39;숫자형 칼럼명&#39; ) or # ( dataFrame, &#39;범주형 칼럼명&#39; , &#39;숫자형 칼럼명&#39; , xlim = [ a, b ] ) def cate_to_num_kde(df, name_c, name_n, xlim = None ): print(df.groupby(name_c)[name_n].describe()) facet = sns.FacetGrid(df.dropna(), hue = name_c, aspect=4) # df 및 범주형 변수 설정 및 가로길이(aspect) facet.map(sns.kdeplot, name_n, shade=True) # kdeplot 설정 및 숫자형변수 지정 facet.set(xlim = (df[name_n].min(), df[name_n].max())) # 숫자형 변수의 최소값부터 최대값까지 x범위 최초 지정 facet.add_legend() if xlim != None: print( &#39;범위지정 : {}&#39;.format(xlim)) plt.xlim(xlim) # xlim 지정시 그 범위만 출력 . cate_to_num_kde(train, &#39;sex&#39;, &#39;age&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . cate_to_num_kde(train, &#39;sex&#39;, &#39;age&#39;, xlim = [20, 30]) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 범위지정 : [20, 30] . &#49340;&#48320;&#49688; &#53456;&#49353;1 : &#48276;&#51452;2(&#48276;&#47168;)&#48324;&#47196;&#48372;&#45716; &#48276;&#51452;1(x&#52629;)&#48324; --&gt; &#50672;&#49549;(&#51333;&#49549;)&#48320;&#49688; &#51032; &#48708;&#50984; . 범주1이 종속변수에 끼는 영향에 대해 범주2(범례)의 영향이 있는지(크로스) 없는지(평행) 판단 | . # https://kaggle-kr.tistory.com/17?category=821486 sns.catplot(&#39;sex&#39;, &#39;survived&#39;, hue=&#39;pclass&#39;, data=train, kind=&#39;point&#39;, # default kind - factorplot height=6, aspect=1.5) . &lt;seaborn.axisgrid.FacetGrid at 0x1dd548ba160&gt; . &#54632;&#49688;&#54868; . def legend_to_cate_to_num(df, name_l, name_c, name_n): sns.catplot(name_c, name_n, hue=name_l, data=df, kind=&#39;point&#39;, # default kind - factorplot height=6, aspect=1.5) plt.tight_layout() plt.show() . legend_to_cate_to_num(train, &#39;sex&#39;, &#39;pclass&#39;, &#39;survived&#39;) . &#49340;&#48320;&#49688; &#53456;&#49353;2 : &#48276;&#47168;&#48324;(&#51333;&#49549;&#48320;&#49688;)&#48324;&#47196; &#48372;&#45716; &#48276;&#51452;&#48324;(x&#52629;) &#49707;&#51088;&#54805;(y&#52629;-&#48148;&#51060;&#50732;&#47536;)&#51032; &#48516;&#54252; . sns.violinplot(&quot;pclass&quot;,&quot;age&quot;, hue=&quot;survived&quot;, data=train, scale=&#39;count&#39;, split=True) plt.legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 plt.tight_layout() plt.show() # for문에 들어갈 것 대비 . &#54632;&#49688;&#54868;(&#48276;&#47168;&#48324;(&#51333;&#49549;&#48320;&#49688;)&#48324;&#47196; &#48372;&#45716; &#48276;&#51452;&#48324;(x&#52629;) &#49707;&#51088;&#54805;(y&#52629;-&#48148;&#51060;&#50732;&#47536;)&#51032; &#48516;&#54252;) . def legend_to_cate_to_num_violin(df,name_l, name_c, name_n): sns.violinplot(name_c,name_n, hue=name_l, data=df, scale=&#39;count&#39;, split=True) plt.legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 plt.tight_layout() plt.show() # for문에 들어갈 것 대비 . legend_to_cate_to_num_violin(train, &#39;survived&#39;, &#39;sex&#39;, &#39;age&#39;) . categorical_all(train, &#39;embarked&#39;) . cate_to_categorical(train, &#39;survived&#39;, &#39;embarked&#39;) . survived 0 1 embarked C 75 93 Q 47 30 S 427 217 .",
            "url": "blog.chojaeseong.com/data/2021/08/06/%EC%97%91%EC%85%80%EC%A0%95%EB%A6%AC-05-%EC%BA%90%EA%B8%80-1-%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89-%EB%B3%80%EC%88%98%EB%B3%84-EDA-+-%ED%95%A8%EC%88%98%EC%A0%95%EC%9D%98%EB%A1%9C-%EC%A0%95%EC%9D%98(upload).html",
            "relUrl": "/data/2021/08/06/%EC%97%91%EC%85%80%EC%A0%95%EB%A6%AC-05-%EC%BA%90%EA%B8%80-1-%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89-%EB%B3%80%EC%88%98%EB%B3%84-EDA-+-%ED%95%A8%EC%88%98%EC%A0%95%EC%9D%98%EB%A1%9C-%EC%A0%95%EC%9D%98(upload).html",
            "date": " • Aug 6, 2021"
        }
        
    
  
    
        ,"post45": {
            "title": "fastpages로 블로그 제작",
            "content": "1 fastpages 만들기 . 클릭만으로 repo, actions key 생성/ 추가 merge | . google에서 fastpages검색후 &gt; 깃허브 &gt; setup instruction &gt; on this link (generating by link) . is2js(@naver.com) / 12!@ | . | 블로그 원본 내용이 들어갈 레포지토리 생성임.(github.io 아님) . is2js/blog_raw 이후 자동으로 https://is2js.github.io/blog_raw/ 로 생성된다. | . | . | 조금 기다리면, Pull Request가 자동으로 올라온다. . link클릭으로 create/clone repo + PR으로 설치까지 자동화된 것임. . | PR로 온 Initial Setup부분을 보자. merge전에 1,2,3번은 순서대로 직접 작동시켜야한다. . 1. ctrl+클릭으로 this uility를 클릭 &gt; RSA - 4096 클릭 &gt; 생성된 key 그대로 복사 . Private Key . --BEGIN RSA PRIVATE KEY-- . Publick key . ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCGIVY8FQf9x1Y52HUUJmpAyOfrzH96K4QtGb7 . | 2.도 컨트롤+클릭해서 1.에서 생성한 ssh key를 붙혀넣어 Action secret key를 만든다. . actions secrets 부분에 New repository secret을 클릭해서 붙혀넣음. Name : SSH_DEPLOY_KEY | Value : SSH RSA 4096 private key 복붙 | . | . | 3. 도 컨트롤+클릭해서 fastpages-blog의 Deploy (public) key를 생성해야한다. Add deploy key클릭 . 여기서는 생성한 ssh RSA 4096 key중에 밑에 있는 publick key를 사용한다. . Title : fastpages-blog | Key : SSH RSA 4096 public key 복붙 | [O] Allow write acess | . | . | . | . | PR 아래부분에 merge PR &gt; merge를 눌러준다. . Actions에 보면 Merge가 진행중인 것이 보인다. 2분 정도 걸림. | 다 되고나면, &lt;code&gt;탭으로 와서 맨 첫줄에 블로그 주소가 보이게 된다. | . | 2 설정해주기 . blog 타이틀 변경 . 깃헙을 다룰 줄 알면, 로컬에서 clone을 떠서 수정하면 된다. . push만 해주면, actions가 자동으로 돌아가면서 static 파일로 수정해준다. | 우리가 올린 파일 기준으로 static한 파일을 생성해준다. | . _config.yaml 수정 &gt; title 변경 &gt; commit | jupyter upload . fastpages가 만들어준 readme에 보면, writing blogs with jupyter가 있다. . 여기서는 .md or .ipynb의 파일이름 양식만 참고함. . YYYY-MM-DD-*.ipynb | . 2020-01-28-My-First-Post.ipynb 2012-09-12-how-to-write-a-blog.ipynb . | Front Matter : 내 블로그 첨에 작성된 ipynb글(Fastpages Notebook Blog Post)을 참고해서 가져다 쓴다.(공식은 너무 김) . 쥬피터 노트북 맨 위에 들어갈 markdown 양식이다. . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true - branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . | 올릴 쥬피터에 아래와 같이 작성한다. . | 노트북 이름을 바꾼다. . 2021-08-06-엑셀정리 05 캐글 1 타이타닉 - 변수별 EDA + 함수정의로 정의(upload).ipynb . | github의 _notebooks 폴더로 가서 add file &gt; 업로드 &gt; commit해보았음. . | . | . | markdown upload . 해당 폴더는 _posts다 . | 제목양식은 yyyy-mm-dd-제목.md다 . 실제로 표시되는 이름은 예제파일속 format의 title:이 실제로 포스트 제목이 된다. | _posts &gt; 예제파일.md &gt; raw를 클릭해서 내용을 복사후 &gt; add file &gt; create file | . toc: true layout: post description: A minimal example of using markdown with fastpages. categories: [markdown] title: An Example Markdown Post # Example Markdown Post ## Basic setup . | . 3. local에서 clone해와서 작업해보기 . C: jupyter_blog에 폴더를 만들고, 우클릭 &gt; 터미널 &gt; code . . | git clone https://github.com/is2js/blog_raw.git . C: jupyter_blog blog_raw에 파일 복사됨. . | vscode는 해당 폴더로 들어가야함. . cd blog_raw/ . | . | 블로그 계정(is2js)과, 컴퓨터 전체 git 계정(is3js)이 다르므로, --local로 깃 계정을 설정해준다. . 참고 | . git config --local user.name &quot;is2js&quot; git config --local user.email &quot;is2js@naver.com&quot; . vscode에서 github확장관리에서 로그인을 제공하고 있어서, 로그아웃후 is2js로 로그인했다. | . | 첫화면 수정 . index.html은 첫 화면에 대한 내용을 md형식으로 닮고 있다. | 내용을 수정하고 이미지가 필요하면, images폴더에 업로드후 사용한다. 작성글들은 이 페이지 아래 자동으로 모아진다. | . | 메뉴 추가 . . _pages/폴더에 들가면 각각의 메뉴가 md파일로 작성되어있다. . about은 md파일로 작성되어있으며, 추가 nav 메뉴는 다 md파일로 작성한다. . layout: page title: About Me permalink: /about/ . 파일명이 아니라 양식속 title이 nav메뉴에 뜨는 페이지명이 된다. | . | 404, search, tags는 html파일로 섞어서 작성되어있다. . | . | _pages/에서 파일을 하나 생성하여 메뉴를 추가한다. . about에 있는 양식을 사용한다. | 작성하고 commit해준다. | . | comment 추가 . utterances를 이용하여 깃허브로 댓글 달도록 함. | . 현재 아무 post에나 comment를 달면 is2js/blog_raw/폴더에 앱이 인스톨 안되어있다고 나옴. install_app을 클릭해서 어터런스 설치 | install을 all repo가 아니라 select해준다. 필요한 저장소마다 설치를 추가로 해주면 된다. | . | . | social comment . disqus를 이용하여 소셜 or 깃헙없이 댓글 달도록 함. | utterances설치시 생성된 _includes/utterances.html을 수정하여 스크립트로 disqus스크립트를 넣어준다. disqus는 url기준으로 댓글창을 열어준다. | url만 다르다면, 다른 댓글창이 열린다. | . | . 구글에서 disqus 검색 블로그 &gt; 로고클릭 &gt; com | . | 난 페북으로 로그인함. -&gt; get start | 선택 | i want to comment on sites | I want to install Disqus on my site | . site네임은 is2js_blog_raw로 함 . | basic버전을 subscribe now로 선택함 . | 우리는 스크립트로 넣을 거라 platform선택 없이 아래 i don&#39;t see my platform 선택 . 스크립트는 카피 해놓는다. . &lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt; &lt;script&gt; /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page&#39;s canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page&#39;s unique identifier variable }; */ (function() { // DON&#39;T EDIT BELOW THIS LINE var d = document, s = d.createElement(&#39;script&#39;); s.src = &#39;https://is2js-blog-raw.disqus.com/embed.js&#39;; s.setAttribute(&#39;data-timestamp&#39;, +new Date()); (d.head || d.body).appendChild(s); })(); &lt;/script&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;https://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; . | . | configure(next랑 똑같음) 클릭후 정보는 비워놓아도 된다. . | 4. 추가 커스텀 . 방문자 카운터 . 해당 프로젝트는 오픈소스라 작동이 안되거나 없어질 수 있음. | 키워드를 기억했다가 다른 것을 검색해서 | . 구글에서 github blog hits counter를 검색 . 최상단 hit-counter 깃허브 들어갔음. https://hits.seeyoufarm.com/ | . | . | 해당 내용을 채운다. . . | 3가지 타입으로 넣을 수 있다. 특히 embed로 넣을 수 있는 것은 노션으로도 넣을 수 있다는 말이 된다. . markdown . ![Hits](https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fis2js.github.io%2Fblog_raw&amp;count_bg=%239E9E9E&amp;title_bg=%2308445E&amp;icon=python.svg&amp;icon_color=%23E1DFDF&amp;title=%EB%B0%A9%EB%AC%B8%EC%9E%90+%EC%88%98&amp;edge_flat=false) . | html . &lt;a href=&quot;https://hits.seeyoufarm.com&quot;&gt;&lt;img src=&quot;https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fis2js.github.io%2Fblog_raw&amp;count_bg=%239E9E9E&amp;title_bg=%2308445E&amp;icon=python.svg&amp;icon_color=%23E1DFDF&amp;title=%EB%B0%A9%EB%AC%B8%EC%9E%90+%EC%88%98&amp;edge_flat=false&quot;/&gt;&lt;/a&gt; . | embed url . https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fis2js.github.io%2Fblog_raw&amp;count_bg=%239E9E9E&amp;title_bg=%2308445E&amp;icon=python.svg&amp;icon_color=%23E1DFDF&amp;title=%EB%B0%A9%EB%AC%B8%EC%9E%90+%EC%88%98&amp;edge_flat=false . | . | 이제 markdown을 index.html안에다 넣어주자. . | 5. 깃허브 잔디와 레포 페이지(git.html) 추가 . 잔디이미지는 솔루션을 통해 https://ghchart.rshah.org/is2js | . | 레포정보는 url로 접근하는 github api를 통해 레포들정보 : https://api.github.com/users/[is2js]/repos | 특정레포정보 : [https://api.github.com/repos/[is2js]/[레포명] | . | 참고자료(노션) | . 솔루션(https://ghchart.rshah.org )을 이용하여, 잔디정보를 이미지로 가져올 수 있다. . index.html에 유저이름만 적어준 이미지 url or MD을 붙혀넣어준다. . 이미지 주소 : https://ghchart.rshah.org/is2js . | 이미지태그 . &lt;img src=&quot;https://ghchart.rshah.org/is2js&quot;/&gt; or &lt;img src=&quot;https://ghchart.rshah.org/is2js&quot; /&gt;로 변경 . | 마크다운 주소 . ![잔디](https://ghchart.rshah.org/is2js &quot;https://github.com/is2js&quot;) . | . | index.html의 hits 아래에 넣고 확인해보자. . . | . | 새로운 페이지 /_pages/git.html을 만들자. . 노션에 미리 작성해둔 코드를 복붙하자. . js스크립트를 사용하기 위해 html양식으로 작성한다. github API를 script태그를 이용하여 github repo정보를 가져온 것이다. api -&gt; h2, p, a태그로 map으로 돌면서 정보출력. 원하면 태그를 바꾸면 된다. | . | is2js부분을 해당하는 githubID로 변경해서 사용하면된다. | . layout: default permalink: /gitInfo/ title: gitInfo search_exclude: true &lt;img src=&quot;https://ghchart.rshah.org/is2js&quot; alt=&quot;&quot; style=&quot;width: 660px; height: 100px;&quot;&gt; &lt;div id=&quot;repos&quot;&gt; &lt;script&gt; // 비동기 작업을 위해 async function 선언 const initRepo = async () =&gt;{ const _username = &#39;is2js&#39; // 추가할 dom선택 const repoUl = document.getElementById(&quot;repos&quot;) // headers 설명 : 깃허브에 요청할 형식 지정 let response = await fetch(&#39;https://api.github.com/users/is2js/repos&#39;, {headers:{ &#39;Accept&#39; : &#39;application/vnd.github.v3+json&#39; }}); const repoJson = await response.json() // repo받아온 내용 확인 // console.log(repoJson); // json내용을 map을 이용해 각 dom을 만들고 추가 repoJson.map((repos)=&gt;{ let h2Element = document.createElement(&quot;h2&quot;) h2Element.textContent = repos.name let pElementDesc = document.createElement(&quot;p&quot;) pElementDesc.textContent = &quot;레포설명 : &quot; + repos.description let aElementURL = document.createElement(&quot;a&quot;) aElementURL.href = repos.svn_url aElementURL.textContent = repos.svn_url //각 요소를 &lt;div id=&quot;repos&quot;&gt;에 추가 repoUl.append(h2Element) repoUl.append(pElementDesc) repoUl.append(aElementURL) repoUl.append(document.createElement(&quot;br&quot;)) }) } initRepo() &lt;/script&gt; . | . | 6. repo마다 언어 퍼센트 출력하도록 변경 . 특정 레포 : [https://api.github.com/repos/[is2js]/[레포명] . 특정레포에서 쏴주는 정보를 관찰해보기 : blog_raw . | 랭기쥐만 출력해서 보기 : blog_raw/languages . 각 언어의 line수가 출력된다. | 다 더한 뒤, 총합으로 나누고, 100을 곱해서 %를 만든다. | . { &quot;Jupyter Notebook&quot;: 12491591, &quot;HTML&quot;: 20989, &quot;JavaScript&quot;: 10532, &quot;SCSS&quot;: 9877, &quot;Shell&quot;: 5458, &quot;Python&quot;: 2772, &quot;Smarty&quot;: 1965, &quot;Ruby&quot;: 1945, &quot;Makefile&quot;: 1422, &quot;Dockerfile&quot;: 364 } . | . | . git.html의 script부분(단순정보나열)을 퍼센트까지 뿌려주도록 변경된 스크립트를 복붙해주면 된다. . 모든 line수(values)를 sumcodeline에 더해주고, 각각의 value에다 나눈 뒤, 100을 곱한다. | strong태그로 출력을 해서, h2 아래에 추가해준다. | count변수를 사용해서 불러올 repo를 5개로 지정해준다. 최대갯수는 100개다. | . // 사용한 언어를 return해주는 함수 const repoLanguage = async (repo) =&gt; { let response = await fetch( `https://api.github.com/repos/is2js/${repo}/languages`, { headers: { Accept: &#39;application/vnd.github.v3+json&#39;, }, } ); let resJson = await response.json(); let sumcodeline = Object.values(resJson).reduce((a, b) =&gt; a + b, 0); s = &#39;&#39;; for (const [key, value] of Object.entries(resJson)) { s += `${key} : ${((value / sumcodeline) * 100).toFixed(3)}% `; } return s; }; // 비동기 작업을 위해 async function 선언 const initRepo = async () =&gt; { // 추가할 dom선택 const repoUl = document.getElementById(&#39;repos&#39;); //갯수설정 const count = 5; // headers 설명 : 깃허브에 요청할 형식 지정 let response = await fetch( &#39;https://api.github.com/users/is2js/repos?&#39; + &#39;per_page=&#39; + count, { headers: { Accept: &#39;application/vnd.github.v3+json&#39;, }, } ); const repoJson = await response.json(); // repo받아온 내용 확인 // console.log(repoJson); // json내용을 map을 이용해 각 dom을 만들고 추가 // repoLanguage 함수의 비동기 작업을 위한 async function선언 repoJson.map(async (repos) =&gt; { let h2Element = document.createElement(&#39;h2&#39;); h2Element.textContent = repos.name; let pElementDesc = document.createElement(&#39;p&#39;); pElementDesc.textContent = &#39;레포설명 : &#39; + repos.description; let aElementURL = document.createElement(&#39;a&#39;); aElementURL.href = repos.svn_url; aElementURL.textContent = repos.svn_url; //사용한 언어 불러오기 let language = await repoLanguage(repos.name); let strongElementLang = document.createElement(&#39;strong&#39;); strongElementLang.textContent = &#39;사용언어 : &#39; + language.toString(); //각 요소를 &lt;div id=&quot;repos&quot;&gt;에 추가 repoUl.append(h2Element); //사용언어부분 추가 repoUl.append(strongElementLang); repoUl.append(pElementDesc); repoUl.append(aElementURL); repoUl.append(document.createElement(&#39;br&#39;)); }); }; initRepo(); . | latex 사용 on . _config.yml에서 LaTex 적용이 default가 true가 아니라서 아래와 같이 _config.yml 파일에 use_math 옵션을 true로 변경해주시면 됩니다. . use_math: true . | 구조 . ### . index.html : 첫 화면에 대한 내용을 md형식으로 닮고 있지만, html파일임. . ``/images/diagram.png “https://github.com/fastai/fastpages”) . . ``은 나중에 is2js.github.io/blog_raw/ 폴더(깃허브 블로그 원본 폴더)로 연결된다. | . | . | _pages/ : md or html의 nav메뉴들의 모음 . about.md, search.html 등 | 추가된 md파일의 양식속 title:[ ]이 nav메뉴에 뜨는 페이지명이 된다. resume.md | git.html | . | . | images/ . 사진, favicon | . | . 커스텀 . 커스텀 도메인을 붙이는 조건 . 내 블로그는 is2js.github.io는 아니지만, github의 네임서버가 is2js.github.io.가 작동하는 것 같았다. (뒤에 . 있음) 원래는 리눅스서버의 공인ip주소를 적어줘야한다. | 하지만, github는 따로 ip주소를 제공하지 않으므로, [git_id].github.io.를 적어두고 해당폴더에서 설정과정을 추가한다. | . | . 가비아 DNS관리 페이지로 간다 dns.gabia.com | . | blog라는 서브도메인에다가 CNAME &amp; [github_id].github.io.로 레코드를 추가한다. . | 해당 fastpage 깃폴더 -&gt; settings &gt; pages로 이동한다. custom domain 부분에 dns에 등록한 서브도메인 blog.chojaseong.com을 적어준다. | 어떠한 확인과정이 있는데, 여기서 dns에 적어둔 [git_id.github.io.]에다가 현재깃폴더 배포ip를 배정시켜주는 작업을 하는 듯 싶다 | . | 밑에 https도 되도록 체크해준다. . | LOCAL 블로그폴더의 root에 CNAME이라는 파일을 만들고, 내부에 커스텀 도메인의 url만 적어준다. . CNAME . blog.chojaeseong.com . | root폴더의 _config.yml속 url 과 baseurl을 수정한다. . url: &quot;https://is2js.github.io&quot; -&gt; &quot;blog.chojaeseong.com&quot; | baseurl: &quot;/blog_raw&quot; -&gt; &quot;&quot; 아~ fastpage가 git_id.github.io아름의 레포가 아닌데도 page로 배포된 이유는 url을 git_id.github.io | baseurl을 /레포명으로 가지고 있어서 기 때문이구나. | . | 하지만, 커스텀도메인에서는 레포명까지 풀로 포함되서 github가 해당 커스텀도메인에 배포해준다. 그로 인해 baseurl은 사라진다.(빈문자열) | . | . | . | . . | _action_files폴더 속 settings.ini파일에도 baseurl이 있으니 수정해준다. 지워서 빈칸 남겨놓기 | . | 커스텀도메인으로 접속하는 순간부터, search 결과의 link들이.. 상대주소화되어 있어서, 도메인/search + 도메인/풀/주소.html 형식으로 잇슈가 있음. . search.js에서 만들어주는 a태그의 주소에 https://를 붙혀서 절대주소화 시켜 뒤에 붙지않고 바로 접속되게 한다. | . search.js . var resultLink = document.createElement(&#39;a&#39;); resultLink.classList.add(&#39;search-result&#39;); // a태그에 http:// 등이 없어서, 상대주소로 걸려서 커스텀도메인 + 다시 또 풀경로가 상대주소처럼 붙음.. // -&gt; href에 https://를 명시해주면, 상대주소가 아니라 절대주소로 인식되어 그 주소로만 간다. resultLink.setAttribute(&#39;href&#39;, &quot;https://&quot; + doc.url); //resultLink.setAttribute(&#39;target&#39;, &quot;_blank&quot;); . . |",
            "url": "blog.chojaeseong.com/fastpages/2021/08/06/fastpages%EB%A1%9C_%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%A0%9C%EC%9E%91.html",
            "relUrl": "/fastpages/2021/08/06/fastpages%EB%A1%9C_%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%A0%9C%EC%9E%91.html",
            "date": " • Aug 6, 2021"
        }
        
    
  
    
        ,"post46": {
            "title": "Notebook posting example(title)",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "blog.chojaeseong.com/example/2021/08/05/test.html",
            "relUrl": "/example/2021/08/05/test.html",
            "date": " • Aug 5, 2021"
        }
        
    
  
    
        ,"post47": {
            "title": "markdown 사용법",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . `![](/images/logo.png &quot;fast.ai&#39;s logo&quot;)` . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "blog.chojaeseong.com/example/markdown/2021/08/05/markdown.html",
            "relUrl": "/example/markdown/2021/08/05/markdown.html",
            "date": " • Aug 5, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "준비중입니다. .",
          "url": "blog.chojaeseong.com/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "",
          "content": "공사중입니다(template).. 자세한 정보는 github.com/is2js . 데이터엔지니어로서의 역량 . Data Engineer란? . Data관련 직군 출저 : Youtube-indiflex | . 프로젝트 . python를 활용한 진료보조프로그램들 한방병원 진료기록부(ipywidget, panel) | 초진기록지(ipywidget) | 환자 티칭 프로그램(ipywidget) | 동료선생님들 거주지역 확진자수 알림(flask, GCP, jandi) | . | Class를 활용한 CLI blog (CRUD) | NLP 분석 Packages | . | 사람인 공고 수집 크롤링 프로젝트 - 크롤링 심화 프로젝트 | . | 데이터 분석 프로젝트 . 나만의 데이터분석 노트 gitbook(Updating~) | 나만의 데이터분석(EDA) 패키지 -Cho Package : numpy, pandas, matplotlib, seaborn . | 논문작성을 위한 한의학 박사들의 설문지 분석후 ROC커브 작성 [노트] | DL논문 작성을 위한 image전처리, DL, ROC커브 작성 [노트] | 관심기업 과제와 유사한 데이터 분석 프로젝트 [노트] 관심기업 과제 pandas to SQL | . | inflearn Pipeline . | 멋쟁이사자 X Naver 연계 프로그램 - clovar API이용 프로젝트 | | Flask 프로젝트 게시판 : Docker, MongoDB, Flask, JQuery | 질답앱 : | 대쉬보드 | like finterest 메모대쉬보드 | . | FastAPI 프로젝트 API : | . | Algorithm &amp; Pythonic . Pythonic Python 정리 및 회고 [노트, 출저-프로그래머스] | 알고리즘 패러다임 및 연습문제 풀이 [저장소], 출저-Codeit] | 알고리즘 자료구조 및 연습문제 풀이[노트, 출저-프로그래머스] | 알고리즘 고득점 kit 연습문제 풀이[노트, 출저-프로그래머스] | Python 고급 [저장소] | DataAnalyst . DS스쿨 - DL반 수료 | DS스쿨 - ML반 수료 | FastCampus - 논문작성을 위한 R 통계 수료 | DL(cnn)을 활용한 독성약재감별 논문작성 논문 | 논문 작성을 위한 설문지 분석후 ROC커브 작성 [노트] | 관련 프로젝트 in 고려대 [노트, 프로젝트] | . | penguin package를 활용한 통계분석 정리[노트] | 고려대 빅데이터 청년인재 수료 NLP | Vision | ML, DL | . | Data Engineer . DS스쿨 - Pandas 데이터분석반 수료 | FastCampus - 전처리CAMP 수료 | Udemy - The Complete Python &amp; PostgreSQL Developer Course 수료 | DataCamp - Data Engineering for Everyone 수료 | DB &amp; SQL . DAP자격대비 데이터 모델링 스터디[노트, 출저-데이터와사람들] | SQL 데이터 분석[노트, 출저-책] | SQL, Bigquery를 이용한 코호트 분석[노트, 출저-탈잉] | MySQL 심화[노트, 출저-SSAC] | Postgresql tutorial 4hour[노트, 출저-FreeCodeCamp] | Postgresql for DataEngineer[노트, 출저-itversity] | Postgrsql &amp;Python course[노트, 출저-udemy] | SQL vs Pandas 비교정리[노트, 출저-조재성] | mongoDB for 데이터수집[노트, 출저-멋쟁이사자처럼, 그외] | SQLAlchemy . 2.0과 이전버전 비교 및 튜토리얼[노트, 출저-Youtube] | SQLAlchemy - pandas 비교 튜토리얼[노트] | Infra . 운영체제 공부[ 노트, 출저 - 정보처리기사 및 유튜브 ] | PowerShell vs BashShell 다빈도 명렁어 정리[노트, | Docker 기본 문법[노트, 출저-Indiflex] | Docker &amp; Ncloud[노트, 출저-SSAC] | Linux 기본[노트, 출저-Indiflex] 출저-드림코딩] | git 기본 | git flow | Frontend . HTML, CSS, JAVASCRIPT로 모던 웹페이지 만들기[프로젝트] | Javasctip와 TypeScript 정리 | React | Vue |",
          "url": "blog.chojaeseong.com/_pages/edustudy.html",
          "relUrl": "/_pages/edustudy.html",
          "date": ""
      }
      
  

  

  

  
      ,"page5": {
          "title": "",
          "content": "공사중입니다…(template) 제시한 정보는 github.com/is2js . 기본정보 . Photo Future . | | . Name | 조재성 | . - Chinese | 趙在聖 | . - English | ChoJaeSeong | . Age | 1987 | . Birth Day | 1987.12.18 | . Email | tingstyle1@gmail.com | . Mobile | xxx-46xx-62xx | . 신상정보 . Profile Content . Address | 서울시 관악구 | . Married | 미혼 | . Family | 2남 1녀 | . Blood type | RH+ O | . Religion | 없음 | . 학력정보 . Level School Name Major Start End Status 최종학력 . University | DongShin University | Korean Medicine | YYYY.MM | YYYY.MM | graduated | 최종 | . High School | NamHae High School |   | YYYY.MM | YYYY.MM | graduated |   | . 직장이력 . Period Company Part &gt; Team . 2011.10 - 2013.4 | Company Inc | R&amp;D &gt; Mobile | . 2010.05 - 2011.9 | Company Corp | Big Data &gt; Visualize | . 2008.08 - 2010.3 | Venture | Web &gt; UI | . 2007.02 - 2008.8 | Company Name | Marketing 3 | . 오픈소스 프로젝트 (2012.03 ~ 현재) . 프로젝트 공식 명칭 . 소개 프로젝트에 대한 간략한 소개를 한다. . | 주요기능 주요 기능을 일일이 상세히 나열한다. | . | 사용기술 . 사용된 기술을 상세히 나열한다. | . | 개발기간 : 2013.2.3 을 시작으로 최근까지 xxx 커밋 | 공식 사이트 - http://rhiokim.github.io/resume | 소스 저장소 - https://github.com/rhiokim/resume | . | 마크다운 이력서 표준화 프로젝트 . 소개 . 이력서에 대한 몇가지 불편한 마음을 개선하고자 마크다운 이력서 표준화 프로젝트를 시작한다. . 개발자를 잘 표현할 이력서 양식이 없다. | 2,3 년에 한번씩 업데이트 해야하는 이력서 너무 힘들다. | 이력서 양식이 도구에 너무 의존적이다. | | 주요기능 . 마크다운으로 기술한다. | PDF, HTML, EPUB, Mobi 등 다양한 포맷으로 변환할 수 있다. | 개발자를 잘 표현할 수 있다. | . | 사용기술 마크다운. . | 개발기간 : 2012.3 을 시작으로 약 6개월에 걸쳐 500여 커밋 | 공헌자 : https://github.com/rhiokim/resume/contributors | 공식 사이트 - http://rhiokim.github.io/resume | 소스 저장소 - https://github.com/rhiokim/resume | . | . 기타 공개/비공개 프로젝트 . 프로젝트 명 추가 설명 : https://vimeo.com/51812784 | . | . 진행중인 프로젝트 (2013.04 ~ 현재) . 프로젝트 명 소개 모바일 앱으로 현재 3명의 멤버가 개발 진행 중 . | 사용기술 Node.js, Mongodb, APNS(Apple Notification), Gumby2 (Responsive CSS Framework) . | 역할 RESTful API 디자인, 시스템(Node.js, Mongodb, APNS) 엔지니어링, 웹 사이트 개발 . | . | . 참여한 프로젝트 이력 . 회사명 1 . 프로젝트 소개 프로젝트에 대한 간략한 소개를 한다. . | 역할 자기가 참여한 프로젝트에서 했던 역할에 대해서 기술한다. | . | 사용기술 Backbone.js, jQuery, require.js, grunt.js, twitter bootstrap, Node.js 등 | . | 개발기간: 12개월 | 공식 사이트: https://project.com | 소스 저장소: https://github.com/company/project | . | . 회사명 2 . 프로젝트 소개 프로젝트에 대한 간략한 소개를 한다. . | 역할 자기가 참여한 프로젝트에서 했던 역할에 대해서 기술한다. | . | 사용기술 Backbone.js, jQuery, require.js, grunt.js, twitter bootstrap, Node.js 등 | . | 개발기간: 6개월 | 공식 사이트: https://project.com | 소스 저장소: https://github.com/company/project | . | . 대외 활동 내역 . 커뮤니티 . 커뮤니티명 주제 관련 참고 자료 . 2010.05 | Title | http://slidesha.re/xxxxxx | . 2010.10 | Title | http://scr.bi/xxxxxxx | . 세미나 . 행사 / 모임 주제 규모 관련 참고 자료 . XX R&amp;D Campus | 1. subject 1 | 30 | http://bit.ly/xxxxxx | . 2. subject 2 |   | http://bit.ly/xxxxxx |   | . 컨퍼런스, 강연 . 행사 / 모임 주제 규모 관련 참고 자료 . Conference | Title | 250 | http://bit.ly/xxxxxx | . Conference | Title | 1,000 | http://bit.ly/xxxxxx | . 소셜 . Site URL . Github | https://github.com/{account} | . Twitter | https://twitter.com/{account} | . Facebook | https://facebook.com/{account} | . . 위의 사실은 GNU 정신에 의거하여 사실임을 증명하며, 만약 사실이 아닐 경우 MIT 라이센스로 공개해도 무방합니다. . YYYY년 MM월 DD일 {홍길동} .",
          "url": "blog.chojaeseong.com/_pages/resume.html",
          "relUrl": "/_pages/resume.html",
          "date": ""
      }
      
  

  
  

  

  
  

  

  
  

  

  

  
  

}