{
  
    
        "post0": {
            "title": "3주간 프리코스 요구사항 체크리스트 및 주차별 키포인트 정리",
            "content": "image: “images/posts/default.png” . site.baseurl /images/posts/default.png . site.baseurl post.url /images/posts/default.png . site.baseurl post.url | absolute_url /images/posts/default.png site.baseurl post.url | relative_url /images/posts/default.png . 요구사항 체크리스트 모음 . 1주차 . 자바의 버전이 8버전인가 | 자바 코드 컨벤션을 지키는가 | Randoms의 pickNumberInRange()를 사용했는가 (3주차) pickNumberInList()를 사용했는가 | . | Console의 readLine()을 사용했는가 | 3항 연산자를 쓰지 않는가 | indent depth가 2이하인가 | 하나의 함수가 한 가지 일만 하도록 하였는가 | (추가) 하드코딩 하진 않았는가 | (추가) style check 및 convention 적용 하였는가 | gradlew.bat clean test의 모든 테스트가 통과하는가 | 과제 제출시 우테코 플랫폼에서도 제출하였는가 | . 2주차(피드백 및 과제에서 추가) . 함수(또는 메소드)의 길이가 15라인을 넘어가지 않도록 구현한다. | else 예약어를 쓰지 않는다 . | 기능 목록을 업데이트하고 재검토 한다 | Class 구현순서( 상수-&gt;멤버 변수-&gt;생성자-&gt;메서드) 지키기 | . 3주차 . 기능 목록에 예외상황도 기록한다. | 일급컬랙션 및 단일변수도 포장한다. | 변수를 줄이려고 노력한다. | . 주차별 미션 수행 키포인트 정리 . 1주차 과제 수행시 키포인트 . 개발 시작전에 요구사항 충분히 파악하기 | 기본 프로젝트 구조 및 뼈대 코드 작성하고 시작하기 | 라이브러리 확인 및 컨벤션 포맷터 적용, 버전 확인 등 기본적인 협업환경 확인하기 | Application에 개발하지 않고 각 class에서 개발하여 구동하기 | scanner 등 input, outview은 static으로 작성해서 재활용하기 | 문자열type의 숫자입력시 검증 여러가지 해보기(길이-&gt; 포맷-&gt; 범위-&gt; 중복여부 등 기타) | else 안쓰고, 반복문안에 if는 method로 빼서 method내에서 하여 indent줄이기 | 무한반복시 조건변수를 결과로 업데이트 하면 됬으나, 재시작 등 추가분기가 필요한 경우, status변수 추가 도입하기 | 상수도 반복되니 따로 class로 빼기 | 중복확인은 list길이로 하는 데, stream으로 편하게 하기 list 중복확인 : list.stream().distinct().count() | 입력받은 문자열배열 -&gt; 정수 list변환 : Arrays.stream(). mapToint(Integer::parseInt).boxed().collect(Collectors.toList()); | . | . 2주차 과제 수행시 키포인트 . Live template을 활용함. 1주차와 반복되는 input코드 등을 미리 작성해둠. | . | fork한 repo를 clone후에 branch부터 바꾸자! 실수로 main브랜치에 commit and push하여 새로 작성하는 경우가 발생했었음. | . | 일급컬렉션 사용하여 객체List에 대한 검증 및 관련 로직을 모음. 쪼개어지는 Input을 받을 때 ex&gt; Names -&gt; Name 미리 names에서 검증을 다 해버리는 전략을 세움 | 쪼개어놓고 내부에서 검증할 시, 다시 입력받으러 가기가 쉽지가 않음. | . | 조건절에서 getter쓰지말고, 객체.부등호를메서드화() 시켜 메세지보낼 것. 비교시 필요한 값은 메서드의 파라미터로 | 입력 받은 int 변수를 포장한 래핑클래스를 만들고 countdown 메서드 구현해보기 | 학습했던 stream위주로 코드 짜보기 max( Comparator)를 쓰더라도 1번에 max값을 충족시키는 여러개의 객체를 구하기는 쉽지 않음. | mapToInt( ) 집계값 구한 뒤 -&gt; 일치하는 객체 List(우승자들) 구하는 방식 | 간단한 출력문은 toString()오버라이딩 해서 쉽게 출력되도록 이용 하기 | | 상수들 및 에러 메세지들의 리팩토링 IDE를 이용하면 정말 간단하게 해결할 수 있음을 깨닫게 됨. | . | . 3주차 과제 수행시 키포인트 . 객체의 각 필드에도 wrapping class를 적용함 원시변수 및 if문의 최소화 -&gt; 래핑변수 및 stream의 활용 | . | 정규식 패턴검사에 stream을 활용함 | List대신 Map 자료구조 래핑하여 DB처럼 사용함 상품 정보등은 List를 포장한 일급컬렉션으로 만들어놓고 정보조회시 사용함 | . | 싱글톤 객체를 활용하여 전체 로직을 운영함 controller 반복문의 조건변수도 싱글톤객체에 메세지를 보내니 상태에 따른 값을 얻어와서 구현하기 수월했음 | . | 자판기 작동 로직에 대해 고민하여 기능 구현 목록을 작성함 | .",
            "url": "blog.chojaeseong.com/%ED%94%84%EB%A6%AC%EC%BD%94%EC%8A%A4/java/intellij/2021/12/15/%EC%9A%B0%ED%85%8C%EC%BD%94%EA%B0%80_%EB%82%98%ED%95%9C%ED%85%8C_%EC%A4%80_%EC%84%A0%EB%AC%BC.html",
            "relUrl": "/%ED%94%84%EB%A6%AC%EC%BD%94%EC%8A%A4/java/intellij/2021/12/15/%EC%9A%B0%ED%85%8C%EC%BD%94%EA%B0%80_%EB%82%98%ED%95%9C%ED%85%8C_%EC%A4%80_%EC%84%A0%EB%AC%BC.html",
            "date": " • Dec 15, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "vscode keymap을 적용한 intellij 세팅 및 프리코스 협업 세팅",
            "content": "vscode keymap 관련 플러그인 설치 . 설정 &gt; Plugin &gt; vscode kemap검색 후 설치 | key Promoter X 설치 (해당 기능의 단축키를 우측하단에 띄워줌) | | . vscode keymap 기준 단축키 정리 . shift 2번 : 전체 검색(유지) vscode F1 | . | keymap 들어가서 move opposite group검색후 ctrl+shift+ 오른화살표지정하기 ctrl + 이후 넘기기..왼쪽넘기기 기능 자체는 없나보다. | alt+shift+0으로 세로로 넘기기 가능 | . | alt+shift+F : reformat code -&gt; 한파일내 패키지 or 폴더 선택후 alft+shift+F | . | keymap 들어가서 back검색후 ctrl+u지정하기 . | ctrl + .으로 메인메소드 내용을 extract method 메소드 분리 및 패키지명 작성하고 폴더이동시키기 | . | 신세계) alt+insert로 생성자, getter 등 오버라이딩 . | **신세계) 메서드사용을 위한 객체 만들 때(인스턴스화) 할 때, ** new 클래스명(); 기입후 ctrl+.으로 local변수 자동(선택후)생성하자. | 객체.메서드();기입후 ctrl+.으로 메서드결과값 받는 변수 자동(선택후)생성 | . | keymap -&gt; extend line selection -&gt; ctrl+L을 추가해서 사용하기 라인 선택하기 shift+alt+아래화살표로 복사할때,, 라인 선택해서해야.. 꼬임없을 듯 | . | . | shift+ alt+ F10: 실행할 class파일 선택해서 실행 ctrl+alt+F10은 바로 실행. | . | shift + alt + x: 현재 파일들 다 close . | shift + alt + a : 긴글 주석? . | alt + ~ : git관련 명령어들 목록나옴 . | ctrl+F11 or ctrl+shift+{key}로 북마크 지정 -&gt; ctrl+해당번호로 이동 | keymap -&gt; show bookmaks검색후 -&gt; CTRL+SHIFT + F11 으로 지정함 | . | ctrl+f3 : 같은단어 이동가능한 검색한 상태로 만들기 == ctrl+f f3 : 같은 단어 다음으로 이동 | shift+f3 : 같은단어 이전 단어로 이동 | . | shift+F5 : 실행중인 작업 종료 ctrl+F5 : 실행 | shift+ alt + f10 : main함수 골라서 실행 | . | alt+7: 현재파일 Structure(메소드 등) 한눈에 보기 유틸메서드로 빼기, 상수 옮기기 : f6으로 편하게 | . | 리팩토링 alt+ctrl+c : 값을 상수로 등록해버리기 | alt+ctrl+m : 코드를 메서드화 시키기 2번 눌르면 창으로 하는 듯 | . | alt+ctrl+v: new 클래스()까지 입력후 참조변수 바로 생성 | . | 축약어 iter | fori 추가 | itar | ifn | inn | . | F8: 오류바로 찾아가기 | ctrl+f -&gt; F3 or shift + F3 : 검색항목 순서대로 찾아가기 | . 프리코스를 위한 java8 협업 세팅 요약본 . clone후 branch부터 생성후 바꾸기 . git checkout -b is2js . git CRLF -&gt; LF로 바꾸기 설정하기 . git config --global core.autocrlf true . utf 8 설정 . utf8, lf설정 되어있나 확인하기 . editor &gt; File Encodings &gt; 체크 3가지 모두 utf-8 shift 2번연속 클릭 (search everywhere) . vm검색 Edit Custom VM option 클릭 맨 마지막 줄에 -Dfile.encoding=UTF-8 추가 | . | . | . | . | . | build.gradle 설정 추가 . compileJava.options.encoding = &#39;UTF-8&#39; // UTF-8 설정 compileTestJava.options.encoding = &#39;UTF-8&#39; . | . code style 3가지 / Checkstyle / saveActions . code style에서 . scheme지정 | n으로 선택해주기 | detect하도록도 체크함.. | java탭으로 내려가서 &gt; scheme 지정확인 checkstyle에 안걸리게 됨. | . | | Tools &gt; CheckStyle . 8.24이상 버전 (default) . | scope를 All sources(테스트포함, 나는 테스ㅡㅌ제외)로 변경 . | 파일 선택(일부코드 삭제하여 수정한)하여 추가 -&gt; +로 추가 . . | 해당 스타일체크후 alt +shift + k혹은 하단 체크스타일에서 추가한 naver style선택하여두기 . | | 다 풀고 **맽밑 Other settings &gt; Save Actions &gt; 3가지 체크 ** . . | . java8로 통일하기 . 설정&gt; Build&gt; Build Tools &gt; Gradle &gt; intelliJ IDEA + Gradle JVM 1.8로 바꾸기 exception 및 디버깅용으로 gradle 변경하는 것 | . | 설정&gt; Build&gt; Build Tools &gt; Compiler &gt; Java Compiler &gt; javac의 1.8 바꾸기 | 프로젝트구조(c +s + a + s) &gt;Project &gt; Project SDK 및 language level 1.8, 8 선택 | 프로젝트구조(c +s + a + s) &gt; Modules &gt; 랭귀지레벨에서 8버전 맞나 확인하기 | 프로젝트구조(c +s + a + s) &gt; SDKs에서 1.8버전 확인하기 | window intellij에서 gradle clean, test 해보기 . . shift 2번 or f1 -&gt; gradle task선택 gradle clean 수행 | gradle test 수행 코드 다짜고나서 | | |",
            "url": "blog.chojaeseong.com/java/intellij/2021/12/14/java_intellij_keymap.html",
            "relUrl": "/java/intellij/2021/12/14/java_intellij_keymap.html",
            "date": " • Dec 14, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "알고리즘) 코딩테스트용 모듈 정리",
            "content": "참고 벨로그 | justkode | . | . 표준라이브러리 6가지 . 내장함수 . sum, min, max, eval, sorted(key=, reverse=) . result = eval(&quot;(3 + 5) * 7&quot;) print(result) . | . itertools . 반복되는 형태의 데이터를 처리하는 기능을 제공, 순열과 조합 라이브러리르 제공 . permutations(r개의 데이터를 뽑아 나열하는 모든 경우(순열)) . | combinations(r개의 데이터를 뽑아 순서를 고려하지 않고 나열하는 모든 경우(조합)) . | products(r개의 데이터를 뽑아 일렬로 나열하는 모든 경우(순열)를 계산한다. 다만 원소를 중복하여 뽑는다.) . from itertools import product data = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] # 데이터 준비 result = list(product(data, repeat=2)) # 2개를 뽑는 모든 순열 구하기(중복 허용) print(result) # [(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;C&#39;)] . | . heapq . 힙을 활용한 우선순위 큐 기능을 구현할 때 사용되며, O(NlogN)에 오름차순 정렬을 제공한다. PriorityQueue 라이브러리가 따로 있지만, heapq가 더 빠르게 동작한다. . PriorityQueue를 리스트나 힙으로 구현할 수 있지만 리스트는 삽입 O(1) 삭제 O(N) 의 복잡도를 가지지만, | 힙은 삽입 O(logN) 삭제 O(logN) 의 복잡도를 가진다. 그래서 우선순위 큐는 보통 힙으로 구현하고, 시간복잡도도 힙으로 구현한 시간복잡도를 사용한다. | . | . | heapq.heappush() : 원소 삽입 | heapq.heappop() : 원소 꺼내기 | heapq.heapify() | . import heapq def heapsort(iterable): h = [] result = [] # 모든 원소를 차례대로 힙에 삽입 for value in iterable: heapq.heappush(h, value) # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기 for i in range(len(h)): result.append(heapq.heappop(h)) return result result = heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) print(result) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . 히피파이를 이용한 힙정렬 기존에 있는 list 객체로 힙 정렬 만들기 | . | . import heapq h = [3, 9, 1, 4, 2] heapq.heapify(h) # 파라미터로 list 객체를 받는다. for _ in range(6): print(-heapq.heappop(h)) # 작은 값부터 출력된다. . bisect . 이진 탐색을 쉽게 구현할 수 있도록 bisect 라이브러리를 제공함. ‘정렬된 배열’에서 특정한 원소를 찾아야 할 때 매우 효과적이다. O(logN)에 정렬된 배열에 맞는 위치를 찾아준다. | ‘정렬된 리스트’에서 특정 범위에 속하는 원소의 개수를 구하는데 효과적이다. bisect_left(a, x) : 정렬된 순서를 유지하면서 리스트 a에서 데이터 x를 삽입할 가장 왼쪽 인덱스를 찾는 메서드 | bisect_right(a, x) : 정렬된 순서를 유지하면서 리스트 a에서 데이터 x를 삽입할 가장 오른쪽 인덱스를 찾는 메서드 | . | bisect 모듈은 이미 정렬되어 있는 list의 정렬 상태를 유지하기 위해 사용되는 모듈입니다. 이를 이용해서, 기존에 있는 list의 정렬 상태를 유지 할 수 있고, 이를 응용해서 Binary Search 또한 구현할 수 있습니다. | . from bisect import bisect_left, bisect_right a = [1, 2, 4, 4, 8] x = 4 print(bisect_left(a, x)) # 2 print(bisect_right(a, x)) # 4 . 정렬된 리스트’에서 특정 범위(시작과 끝)에 속하는 원소의 개수를 구하는데 효과적이다. . left는 같아도 젤 왼쪽 index(포함), right는 같아도 젤 오른쪽index(미포함, 들어가야하는 자리)를 반환하므로 시작과 끝 index를 알 수 있다. | . from bisect import bisect_left, bisect_right # 값이 [left_value, right_value]인 데이터의 개수를 반환하는 함수 def count_by_range(a, left_value, right_value): right_index = bisect_right(a, right_value) left_index = bissect_left(a, left_value) return right_index - left_index # 리스트 선언 a = [1, 2, 3, 3, 3, 3, 4, 4, 8, 9] # 값이 4인 데이터 개수 출력 print(count_by_range(a, 4, 4)) # 2 # 값이 [-1, 3] 범위에 있는 데이터 개수 출력 print(count_by_range(a, -1, 3)) # 6 . lgN으로 정렬까지 해주는 bisect.insort( )도 있다. . | bisect 모듈은 이미 정렬되어 있는 list의 정렬 상태를 유지하기 위해 사용되는 모듈입니다. 이를 이용해서, 기존에 있는 list의 정렬 상태를 유지 할 수 있고, 이를 응용해서 Binary Search 또한 구현할 수 있습니다. . | . # 1. 삽입 되어야 하는 index 찾기 import bisect arr = [1, 2, 3, 3, 4, 5] print(bisect.bisect_left(arr, 6)) # 6이 들어가야 하는 Index인 6을 반환 print(bisect.bisect_right(arr, 6)) # arr에 6이 없기 때문에 위와 똑같은 값을 반환한다. print(bisect.bisect_left(arr, 3)) # 중복 되는 값 제일 왼쪽, 2를 반환한다. print(bisect.bisect_right(arr, 3)) # 중복 되는 값 제일 오른쪽 + 1, 4를 반환한다. bisect.insort_left(arr, 3) # 중복 되는 값 왼쪽에 삽입 bisect.insort_right(arr, 3) # 중복 되는 값 오른쪽에 삽입 print(arr) . #2. Binary Search 구현 from bisect import bisect_left arr = [1, 2, 3, 3, 4, 5] def bs(arr, x): i = bisect_left(arr, x) # 들어가야 하는 &#39;제일 왼쪽&#39; index 반환 if i != len(arr) and arr[i] == x: # 들어가야 하는 index가 return i # 마지막 index + 1 이라면, arr에 x가 없는 것 else: # arr[i] == x가 아니라면, arr에 x가 없는 것 return -1 a = [1, 2, 4, 4, 8] x = 4 res = bs(a, x) if res == -1: print(x, &quot;는 없습니다!&quot;) else: print(&quot;첫번째&quot;, x, &quot;가 등장한 위치는&quot;, res) . collections . 덱(deque), 카운터(Counter) 등의 유용한 자료구조를 포함하고 있는 라이브러리 . deque . 파이썬에서는 일반적으로 deque를 활용해 큐를 구현한다. | Queue 라이브러리 있지만 일반적인 큐 자료구조를 구현하는 라이브러리는 아니다. | 리스트와 다르게 인덱싱, 슬라이싱 등의 기능은 사용할 수 없다. | 데이터의 시작이나 끝부분에 데이터를 삽입하는데 효과적이다. | . . | Counter 등장 횟수를 세는 기능을 제공한다. iterable 객체가 주어졌을 때, 해당 객체 내부 원소가 몇 번 등장했는지 알려준다. . | . math . 수학적 기능을 제공하는 라이브러리 . 자주 사용되는 수학적인 기능을 포함하고 있는 라이브러리 팩토리얼, 제곱근, 최대공약수(GCD) 등을 계산해주는 기능을 포함 . 종류 math.factorial() : 팩토리얼 | math.sqrt() : 제곱근 | math.gcd() : 최대공약수 | math.pi : 파이 | math.e : 자연상수 | . | . import math print(math.factorial(5)) # 120 print(math.sqrt(7)) # 2.6457513110645907 print(math.gcd(21, 14)) # 7 print(math.pi) # 3.141592653589793 print(math.e) # 2.718281828459045 . . 그외 . map, split, sorted . 주의점 . input말고 . 뭐 어느정도로 더 빠르고 느리냐는, 코딩 테스트 문제푸는 수준에서 다룰만한 내용이 아니므로 넘어가도록 하고, 직관적으로만 느꼈던 것은, input() 으로 코드를 제출할 시, 시간초과가 뜨지만, sys.stdin.readline() 으로 제출할 시 정답이 뜨더라는 것이다. 이와 비슷한 이슈는 이미 이전부터 있었다. | . 한편, 나는 입출력을 지금까지 이런 방식으로 했다. . a = [int(x) for x in input().split()] # a = [1, 2, 3, 4 ,5] . 하지만, 이 방법보다 다음 방법이 더 권장된다. (위와 같은 이유로) . import sys a = list(map(int, sys.stdin.readline().split()))# a = [1, 2, 3, 4, 5] . 재귀풀기 . 이전에 문제풀다가 말한 적이 있는데, 특히 자주접하는 DFS, BFS 문제의 경우 그렇다. . 파이썬의 재귀 허용 깊이의 기본치가 c 보다 약한건지, c 로 짠 DFS, BFS의 경우 문제 없이 돌아가지만, 파이썬으로 돌리면 런타임 오류가 뜨는 경우가 있다. 그래서 다음과 같이 재귀 허용 깊이를 수동으로 늘려주는 코드를, 코드 상단에 적어줘야 한다. . import sys sys.setrecursionlimit(10**8) # 10^8 까지 늘림. . | . Pypy . PyPy 가 뭔지 찾아보니, 쉽게말해 파이썬 보다 몇 배 더 빠른 개선된 파이썬이라고 생각하면 된다. . 좀 더 자세히 말하면, Python3 는 내부적으로는 C로 짜여져있는데 (이 이유 때문에 Python2 보다 빠르다.), 이를 C가 아니라 Python으로 다시 짠 것이다. 당연히 느릴 것 같은데, 의외로 빠르단다. 자세한 내용은 나무위키 참고. . 때문에, 일반적으로 Python3 보다 PyPy로 제출해서 내는게 더 안전한 듯 하다. (빠르다는 의미에서) . 한편, PyPy에서는 sys.setrecursionlimit(10**8) 이 안먹는다. 즉 임의로 재귀 호출 깊이를 설정할 수 없다는 것에 주의해야 한다. . 파이썬으로 문제푸는 게 편한점도 많지만 아직 어색하고, 이런 자잘한 리스크가 많은 듯 하다. 이후 또 뭔가 발견하면 남겨놔야겠다. . | .",
            "url": "blog.chojaeseong.com/pythonic/algorithm/2021/10/22/python_%EB%AA%A8%EB%93%88%EC%A0%95%EB%A6%AC.html",
            "relUrl": "/pythonic/algorithm/2021/10/22/python_%EB%AA%A8%EB%93%88%EC%A0%95%EB%A6%AC.html",
            "date": " • Oct 22, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "알고리즘) SKTacademy 코테 푸는 문법 TIP / 자료구조 요령 정리",
            "content": "reference SKTacademy | | . 알고리즘 푸는 이유 . 구현: 생각하는 내용을 코드로 옮긴다. 연습안하면 안된다. 500문제 이상 풀어야함. 반복해야 언제 어떤 변수를 선언하고 언제 전처리 해야하는지 알 수 있게 된다. 빨라지고 나만의 코딩스타일이 생긴다. | 효율성: 계속 구현하다보면, 효율성을 챙기면서, 자주 사용하는 함수로 최적화 | 다른 사람들의 코드를 보면서, 효율적인 코드 작성 | . | 절차적 사고: 절차적인 사고에 익숙해짐. 언제 어떤 과정을 하고, 다음은 어떻게 해야하는지 | 적재적소한 알고리즘을 선택할 수 있게 된다. 그럴려면 자료구조, 알고리즘을 따로 공부해야한다. | . | . | 디버깅: 한번만에 맞는 경우는 거의 없다. 예외케이스 탐색을 많이 해야한다. 최저, 최대, 최악 경우를 넣어보면서 한다. | 코드(에러)를 읽는 능력 | . | . | 재미: 적은시간으로 연습 가능 | 프로젝트와 다르게 짧은 주기로 성취감 | . | 문제보고 감잡기 . 1초당 가능한 복잡도 간 미리 계산하기 . python으로 . 백만번(10^6) 반복문or덧셈곱셈 등… -&gt; 1초 안에 다 풀린다. | 천만번(10^7) -&gt; 1초 안에 대부분 풀린다. python으로 1초안에 천만~5천만(10^7 ~ 5* 10^7)까지 연산 가능하다 생각하자. | . | 1억(10^8) -&gt; 불가능 -&gt; 알고리즘 바꿔야함. | . | 다시 문제보기 . 시간제한부터 보기 . 1초 -&gt; 10&amp;7 안에 풀어야한다. | . | 입력 보고, 반복문 횟수 갸늠하기 . n = 10억 = 10^9 -&gt; 단순 반복문 O(N)으로 는 불가능하다. | 입력을 보고 O(N)이상 불가 -&gt; 루트(n) or lgN or O(1)으로 해야한다. | . | . | . | PS팁 . 입력과 초기화 . python의 input은 3가지 종류를 받는다. . 숫자1개 . python에서는 항상 string으로 들어온형변환부터 해준다. | . . | 문자열 . 일반 문장 | 쪼개면서, [i]번째 인덱싱도 하고 싶다 -&gt; list() immutable한 string 대신 list로 변환시켜줘야한다. | . | 다시 붙일려면 ”“.join사용 | . . | 숫자 배열 . map을 써서 형변환한다. | . . | . | **list(배열)의 초기화는 comprehension으로 ** . . | . | 에러메세지 확인하기 RE: 런타임에러 -&gt; zerodivision or indexError | TLE: 시간초과 -&gt; 잘짰는데 무한루프가 있거나, 알고리즘이 안 좋거나 | . | 추상화와 기능분리 . 맨 처음 반복문에 돌아가면서 기능을 해줄 or 테케마다 처리해줄 input()받기부터 시작하는 함수를 짜자. 대충 로직을 슈도코드 짜듯이 짜면서 반복문 - 체크 - 결과값 저장 등의 로직을 짠다. . | 코딩하는 2가지 방법 . 현재가 main함수라고 가정하고 while 문에서 다 돌리기 | process함수를 따로 만들어놓고, 테케를 process함수에서 받아 main에서 돌림 | . | 처음에는 다 while문에 넣고 돌린다. . | 하지만, main함수는 최소화 해서 가벼워야한다. 내용들은 다 함수로 보낸다. . 반복문을 돌되, 각 TestCase마다 따로 처리되도록 함수로, TC별 처리되도록 하는 함수를 만들어서 돌린다. | . . 일단 위에 스샷기준으로는.. 테케별 처리도되록 함수에서 input을 받고 -&gt; 리하고 -&gt; return 하고-&gt; main에서 for문 print(함수return값) | . | . | 예를 들어, 삼성기출-사다리조작문제를 보자. (풀이는 안함) . 삼성쪽은 문제가 되게 길다. 그림 위 수치 위주로 빠르게 한번 보자. . 일단 수치(숫자)를 먼저보고 &quot;아~ 사다리가 5줄, 6줄 되는 구나 &quot; . | 사다리를 중간에 넣을 수 있구나 . | 사다리를 진행해나가는 과정이 있구나 . . | . | 입력 양식(예제 입력)보기 . 첫줄의 숫자와, 나머지 아래 숫자가 같으니까 아 대충 아래쪽이 사다리를 의미하겠구나 | . | 문제를 자세히 읽기 시작하는데 출력 요구사항을 먼저 본다 . | 문제가 복잡해보인다. . **이 때, main함수를 간단하게 만들기 위해, 반복문 어떻게 돌릴지 판단 -&gt; 그안에서 사용될 기능 분리하여 일단 슈도코드로 함수들을 작성해 기능분리 시켜준다. ** . | 사다리를 최대3개까지 놓는데, . i에 놓을지 . j에 놓을지 . k에 놓을지 선택할 수 있게 3중for문을 만들어 탐색가능하게 함. . | 3개에 따라 가능한지 확인하는 check(i,j,k) 함수를 사용하고 슈도코드로 위에다 작성해둔다. . | 가능할 때, 그 i번째 사다리가 i로 내려오는지 체크해주는 함수result()도 슈도코드로 작성해둔다. . | . . | . | | . | 코드를 줄여 가독성을 높이는 조건문, 반복문, 함수 by python indent를 줄이기 . 반복문 eX&gt; N by N by N 3중 포문 . 똑같이 N**3 만큼 횟수는 동일하게 돌아가는데, 한번에 for num in range(N**3)으로 돌리면서 . i = num을 N^2으로 나눈 몫 = num // (N*N) | j = num을 N으로 나눈 몫을, 다시 N으로 나눈 나머지 = num//N % N | k = num을 N으로 나눈 나머지 = num % N | . | **내가 만든 2중 포문을 indent 1개로 ** . i = num을 N으로 나눈 몫 N*N을 통해, ` 0~N-1을 첫번째 구간으로해서 N개` 존재하는데, 0~N-1구간: 행을 0으로 간주해요 | N~2N-1 : 행을 1로 간주해요 | … | ~N^2-1 N개의 구간이 있어요 | . | . | j = num을 N으로 나눈 나머지 구간별로 0~N-1의 열을 담당해요. | . | . for num in range(N**2): i, j = num//N, num%N print(f&quot;({i},{j})&quot; , end = &quot; &quot;) . | 진법, 진수를 활용하면 더 쉬워진다고 한다. . | . | main 반복문 속 조건문을 if True:시 process()가 아니라 if not False시: continue로 아래 process() 건너띄기를 통해 indent를 챙길 수 있다. . . process()함수 위에다가 if not 조건문 :continue를 활용해서 탈락시 건너띄기하면, 반복문내 indent를 줄일 수 있다. | . | 함수안에 if : return 다음에는 else가 필요없다. . **if return / return도 return 삼항연산자로 줄일 수 있다. ** 가장 선호. flag도 이런식으로 할 수 있다. | . | . . | | 변수명은 snake_case로, 함수명은 cameCase로, Pascal은 시작부터 대문자인 Camel . | 적용해보기 주사위네개 . 나는 Counter를 활용했지만.. | . # 기존 내코드 N = int(input()) from collections import Counter max_money = float(&#39;-inf&#39;) # 같은 눈이 4개가 나오면 50,000원+(같은 눈)×5,000원의 상금을 받게 된다. # 같은 눈이 3개만 나오면 10,000원+(3개가 나온 눈)×1,000원의 상금을 받게 된다. # 같은 눈이 2개씩 두 쌍이 나오는 경우에는 2,000원+(2개가 나온 눈)×500원+(또 다른 2개가 나온 눈)×500원의 상금을 받게 된다. # 같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)×100원의 상금을 받게 된다. # 모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)×100원의 상금을 받게 된다. def calc_money(data): max_cnt = max(data.values()) val_lst = [ x[0] for x in data.items() if x[1]==max_cnt] if max_cnt == 4: return 50000 + (val_lst[0]*5000) elif max_cnt == 3: # val_lst = [ x[0] for x in data.items() if x[1]==max_cnt] return 10000 + (val_lst[0]*1000) elif max_cnt == 2: # val_lst = [ x[0] for x in data.items() if x[1]==max_cnt] if len(val_lst) == 2: return 2000+(val_lst[0]*500) + (val_lst[1]*500) else: return 1000 + (val_lst[0]*100) else: return max(data.keys())*100 for _ in range(N): data = list(map(int, input().split())) data = Counter(data) money = calc_money(data) max_money = max(max_money, money) print(max_money) . 수학을 이용하면서 . 기능분리 by 함수 | 입력과 초기화 by 튜플, 컴프리헨션 | 반복문, 조건문 줄이기 by 한번에돌기+ if reutrn후에는 no else noelif + 삼항연산자 | . . | . | 수학 . 반복문을 . range(min(a,b))로 길이를 줄이거나 | range(min(a,b),,-1)로 거꾸로 시작하거나 | range(,,n)으로 간격을 주는 것을 생각하자. | . | 유호제법은 코드로 외우자. . math.gcd써도될듯.. | . # a&gt;b def gcd(a,b): # 1) b가 a의 약수면.. 그냥 b가 최대 공약수 # 2) 그게 아니라면, 재귀로서 gcd(b, a%b)로 재귀로 빨리 구하자. return b if a%b==0 else:gcd(b, a%b) . | 소수판별과 에라토스테네스의 체 . 소수판별 isPrime은 . 이론상 소수=1과 자기자신만을 약수로 가짐 = 2~n-1까지 약수없음, 약수 나오면 탈락인데 . 약수와 배수의 관계에서 약수는 항상 짝을 이루어 존재하니 2~루트(n)까지만 검사한다. | . . | . | 에라토스테네스의 체 . 범위가 주어진다 1~n까지 중 소스의 갯수는? 1은 소수가 아니여서 지움 | 2부터 isPrime으로 소수판별 소수로 판별되면 -&gt; 소수의 배수들을 싹다 지움(어떤수의 배수는.. 소수가 아님 무조건 x2, x3들이 약수가 되니까 | . | . | . . 뭔가를 지울 때는 chk, ck배열에다가 index - T/F를 hashing하여 활용한다. 이미 범위가 정해져있으면 거의 이렇게 사용한다. count 정렬 | 에라토스 테네스의 체 | DFS BFS? | . | . . 그외 자세히 주석으로 달음 . def era(N): # 체크는 hasing용으로서, n index를 쓸 거기때문에 0부터 시작했더라도 range(N+1)까지 돌려준다. ck = [ False for _ in range(N+1) ] p = [] # 1은 소수가 아니므로 제끼고 2부터 체크한다. # 소수의 배수들을 True를 채워놓고, 다음에 올 때 건너뛰게 한다. # 과거에서 판단한 소수의 배수들에 안걸렸으면, 아직 False로 남아있는, 소수는 바로 append해 줘도 된다. # -&gt; 맨처음 2만, 최초이기 때문에 과거에서 True로 소수탈락시킨 경험이 없다. for i in range(2, N+1): # 아직 False인 것만 체크한다. # 아래에서, 미래원소들 중에 소수라고 판별내어놨으면 건너뛴다. # -&gt; check를 활용해서 건너뛰는 [ck 미래 -&gt; continue 로직]이다. if ck[i] == True: continue # False = 2의 배수부터 시작해서, 소수탈락(True)에 안걸렸다면, 소수라고 판단한다. p.append(i) # 현재 i는 소수라는 뜻인데, 소수-&gt; 소수의 배수를 True(소수탈락)로 지워야한다. # * i배수 조작-&gt; i배수는 range(시작수, 끝수, i)를 통해 +i씩 움직인다. # 이 때, i+i or i*2부터 +i씩 i*3, i*4를 지워나가는게 아니라 # * &lt; ixi &gt;부터 시작해서 i의 배수를 지워나간다 range(i*i, N+1, i) # -&gt; 왜냐하면, 이미 과거에서 지워났기 때문인데 # -&gt; 예를 들어, 6은.. 이미 2에서 지워놨음. 3에서 지울 필요X. # -&gt; 3은 뭐부터 지워나가야할까? -&gt; 앞에서 안나왔을, 3의배수로서만 존재하는, # -&gt; 3만을 약수로 가지는 = 9부터 지워나가면 된다. # -&gt; 2*i부터 지눠나가도 괜찮다. # for j in range(i*2, N+1, i): for j in range(i*i, N+1, i): ck[j] = True # 이제 리얼소수는 p 배열에, 체크여부는 ck(소수탈락시True?)로 반환한다. return ck, p print(era(10)) # ([False, False, False, False, True, False, True, False, True, True, True], [2, 3, 5, 7]) . | . | . | 하노이 = 분할정복 by 재귀 . n번째 자체처리를 잘 넣어주자. | 재귀가 꼭 return해줄 필요는 없다. return안한다면 꼭 + 등의 연산으로 연결해줄 필요가 없다. 갯수: return f(n-1) * 2 +1 | 출력: f(n-1) + print(n자체) + f(n-1) f(n-1)내부에서도 print가 호출됨. | . | BUT 재귀함수의 base case if는 반드시 return으로 종료시켜줘야한다!! | . | 변하는 것들을 인자로 잘 넣어주자. 숫자 명칭이 고정이라면, 합이 일정한 것도 이용하자. | . # 1-&gt;3def hanoi(st, ed, n): if n==1: return print(st,ed) # 1-&gt;2 n-1 # st-&gt;mid hanoi(st, 6-(st+ed), n-1) # 1-&gt;3 print(st, ed) # 2-&gt;3 n-1 # mid -&gt;ed hanoi(6-(st+ed), ed, n-1) . | 정렬 . 선택정렬(i+1~n-1와 비교 최소값 찾으면 swap, 매번 맨왼쪽 최소값 확정), 버블정렬( 매번 인접한수 비교후 크면 오른쪽으로 swap, 매번 맨오른쪽 최대값 확정)은 n, n-1, .. 1번 모두 탐색해야해서 시복 O( n(n+1)/2) = O(N^2)으로 너무 느리다. . | 퀵 소트 . 재귀로 구현. 1)p정하고 2) 작, 큰그룹나눠서 3)p자리 확정의 과정을 작은그룹에서 1번, 큰그룹에서 1번 다시 시행한다. . def quick_sort(array): # 리스트가 하나 이하의 원소만을 담고 있다면 종료 if len(array) &lt;= 1: return array pivot = array[0] # 피벗은 첫 번째 원소 tail = array[1:] # 피벗을 제외한 리스트 left_side = [x for x in tail if x &lt;= pivot] # 분할된 왼쪽 부분 right_side = [x for x in tail if x &gt; pivot] # 분할된 오른쪽 부분 return quick_sort(left_side) + [pivot] + quick_sort(right_side) . | . | 머지 소트 . 재귀시, divide후 conquer과정에 투포인터 개념으로 merge를 해야한다. . | 1)절반으로 나누고, 2) 각각을 투포인터개념으로 합친다. . # 합병정렬에서는 conquer과정이 복잡하다. # [divide] 는 그냥 반씩 쪼개면 되지만, # [conquer]된(정렬된 list2개) 것들을 [combine](2개 list 합하여 정렬)시 복잡하기 때문에 이 부분을 merge함수로 뺀다. def merge(list1, list2): merged_list = [] i = 0 j = 0 while i &lt; len(list1) and j &lt; len(list2): if list1[i] &lt; list2[j]: merged_list.append(list1[i]) i+=1 else: merged_list.append(list2[j]) j+=1 if i == len(list1): merged_list += list2[j:] elif j == len(list2): merged_list += list1[i:] return merged_list def merge_sort(my_list): # base case if len(my_list) &lt; 2: return my_list # divide and conquer left_half = my_list[:len(my_list)//2] right_half = my_list[len(my_list)//2:] # 부분문제는 원래함수(부분)을 한 상태가.. 정복된 상태다 조심! return merge(merge_sort(left_half), merge_sort(right_half)) print(merge_sort([12, 13, 11, 14, 10])) . 2개의 배열을 merge할 때, 4개짜리 배열을 미리 대기시켜놓고, 투포인터로 넣어줘야한다. | 즉, 메모리할당이 많아진다. | 머지 소트는 정렬 문제에서 메모리가 넉넉할 때 쓴다. | 퀵 소트는, 최악(역순정렬&amp;p를 맨첫값)의 경우 NN이 될 수도 있다. | . | python sort(), sorted()는 퀵소트, 머지소트보다 더 최적화된 정렬을 쓰니. 그냥 이걸 쓰자. . | . | 라딕스 소트(radix sort) = 카운팅정렬 -&gt; 이범정(10^6~10^7 이하)일 때 . **이미 최소~최대값의 범위가 정해져있을 때 **, 그 범위를 index로 hashing시킨 배열을 미리 만들어놓고 . | 카운팅한다. . | 카운팅수만큼 연속해서 나열� . | | 자료구조 . 쓰는이유: 효율성. 쓰는 의미가 있음. 사용처가 정해져있다. 메모리를 효율적으로 쓴다. ex&gt; stack: undo 마지막에 했던 작업을 되돌리기 위해. 직전꺼를 되돌리기 | . | 추상적: 코드가 정해져있지 않음. 개념이므로 라이브러리가 아니더라도 어느 언어라도 구현가능해야한다. | 재사용성: 계속 쓰기 위해 라이브러리를 제공함 python은 collections에 많음. | . | . | stack 접시닦고 다시 가져가는 것에 비유 많이함. undo | 넣고push 위에서부터 빼는pop 2가지가 핵심 | 배열과 다른점은, 맨 마지막이 빠져나가는 점 : LIFO | python에서는 따로 library없고 배열[]로 바로 사용한다. | 예제 : 괄호 -&gt; 여는괄호만 넣어서 쌓으며, 닫괄시.. 직전에 넣은 여괄 부터 꺼내 짝이 맞나 확인해야한다. | . | queue와 deque 왜쓸까? 배열이랑 달라보이지만, 불필요 메모리를 줄인다.메모리를 효율적으로사용하기 위해 배열로도 구현가능(pop한 앞부분으로 index를 한칸씩 당긴다.?) | 이미 pop한 것들을 붙잡을 이유가 없어서 그럴필요가 없음. | . | server에서 여러 queue를 써서, 여유로운 queue에 task를 넣어주는 형식(task분할) | python에서는 deque = stack + queue라서 queue문제는 deque | 예제: 요세푸스 돌면서 제거된 사람을 빼야하는 경우 -&gt; deque의 queue로 popleft + append를 rotate로 해결 | . | . | . 그래프와 Tree의 저장방법 . 그래프의 특이한 형태로서, 나가는 간선(outdegree)만 있으면 Tree . Tree도 2가지 저장방법이 있다. . 자식마다 부모는 only 1개씩, 자식배열에 저장 cycle없이 root node제외하고 다 부모가 1개씩 존재 | 밑에서부터 부모를 찾아 올라갈 수 있다. 4의 부모 2 -&gt; 2의부모 1 -&gt; 1의 부모 0 == root | . | . | 부모마다 여러개자식을, 자식list로 2차원배열에 저장 인접리스트 저장시, 아래로 내려가면서 순환을 돌기 좋다. 1의 자식2 -&gt; 2는 아래로 4,5,6을 볼 수 있으니 4번 부터 본다. -&gt; 4번은 비어서 leaf node로 끝났따 -&gt; 5번 보고 6번보고 하자. | . | . | . | Tree의 부모저장배열 -&gt; LCA찾기 예시가 촌수문제다. . 조상들 모을 default 0의 N+1개짜리 부모저장배열 생성 입력정보를 배열에 저장함. 부모 없으면 0 | . | 2개 node의 공통조상찾는다? 각각의 (조상, 촌수) 튜플이 담길 list를 선언 | 한번 타고올라갈때마다 거리를 더해줄 각각의 촌수변수 선언 | . | 각 node마다 부모가 없을 때까지 찾아가야한다. default 0이며, 안쓰는 p[0]에 0이 들어가있어 무한루프의 가능성이 있으니, 부모가 0되는 순간 빠져나와서, 아직 처리안된상태로 나와, 마지막에 한번더 처리해준다. | 나부터 시작, 거리0으로서 튜플로(조상,거리)를 모아준다. | 재귀적으로 한번 찾아갈때마다 B = p[B] 로서, 나를 부모로 업데이트해준다. 그러면 나의 부모의 부모를 찾아가도록 된다. | . | . N = int(input()) A, B = map(int, input().split()) # 1. 촌수는 Tree형태 그래프인데, 문제에서 부모(1개만) 저장하는 방식을 택했으니 # -&gt; 1차원 배열에 다가 받아준다. # -&gt; 자신의 부모를 모두 0으로 초기화 해놓는다. (1부터 시작하는 node -&gt; 0은 부모가 없다는 것을 표현함.) # cf) 자식들y는 여러개일 수 있어서 index에 놓고, 각 자식들에 대한 부모는 1명밖이다 -&gt; value로서 1개 p = [0 for _ in range(N+1)] # 2. 관계수를 for문에서 바로 받아, 각 관계 -&gt; 부모배열을 채운다. for _ in range(int(input())): x, y = map(int, input().split()) # * 3.우리는 1차원 배열에 [부모만!] 저장한다. # 1 2 중에 1이 부모니까 index 2에다가 1를 저장한다. # cf) 자식들y는 여러개일 수 있어서 index에 놓고, 각 자식들에 대한 부모는 1명밖이다 -&gt; value로서 1개 p[y] = x # 3. A와 B의 공통 조상을 찾기전에, # * A의 조상들을 모두 모은다, B의 조상들을 모은다 -&gt; 교집합? # ** 참고로, A조상을 모을 때는, A자신을 포함해서 A자신 정보, 촌수거리0 부터 시작해서 -&gt; 재귀적으로 (부모, 부모까지거리(+=1)의 정보를 호출해서 담는다. Aa, Ba =[], [] # Aa: A의 조상a, Ba : B의 조상a # * A의 조상들(부모, 부모의 부모.. ) 모으는 과정에서, A와의 촌수도 같이 튜플로 저장하기 위해 Ad, Bd = 0, 0 # 1) 자신x&lt;-부모p[x]로 업데이트하여, 부모의 부모도 다음번에 찾아가게함 # 2) 자신&lt;-부모 업데이트할 때, 거리도 +1 업데이트해서, 촌수도 올라가게 함. # 3) p[x] &gt; 0를 while if조건절에 놓아서, p[x]==0 부모가없는 지점까지 올라간다. while p[A]&gt;0: # 3-1) 제일처음에 들어가면, 나와의거리Ad=0인.. 나 자신을 0촌 조상으로 튜플로 넣어준다. (나, 나와의거리) Aa.append( (A, Ad)) # 3-2) 재귀적으로 내가 부모가 되도록 업데이트해서, # while p[updated A]부모의부모가 있다면 -&gt; (나 updated A=부모, 전보단 늘어난 거리updated Ad +1) # 을 조상으로서 재귀적으로 모아준다. Ad+=1 A = p[A] # 내가 내 부모가 된다. for 다음단계를 위한 업데이트 # * 부모가 없는 p[A]=0의 root node도 넣어줘야한다... root node가 공통조상이 될 확류은 높다. # - 현재 p[A]==0상태이며, 첫 0이라서.. 루트노드로 업데이트된 것 일 것이다.. 마지막에 한번만 넣어주자. Aa.append((A, Ad)) # 4. B도 마찬가지다. while p[B]&gt;0: Ba.append( (B, Bd)) Bd+=1 B = p[B] Ba.append((B, Bd)) # print(p) # * 5. 2개배열을, &lt;2중 포문&gt;으로 1:1매칭 해보면서, 튜플 (조상, 촌수) 중 조상이 같을 때를 찾늗나. # -&gt; 조상이 같은 순간에서 촌수를 더해버리면 된다. for i in Aa: for j in Ba: # 여기는 Aa, Ba 조상들의 1:1매칭 공간 if i[0] == j[0]: print(i[1]+j[1]) # 등장하면, 제일 빠른 것을 만난 순간 바로 프로그램을 종료하면 된다. exit() else: print(-1) . | . | 나가는 간선외 들어오는 간선(indegree)까지 있으면 Graph . 그래프는 2가지 저장방법이 있음 . 인접행렬 : 행: 출발점 -&gt; 열: 도착점을 나타내는 N by N행렬 . 인접행렬도 3가지가 있음. 노방향 | 방향 | 방향+가중치 | . | . | 인접 리스트 : 튜플로 갈수 있는 (가중치, 노드) list를 인접한 list에 저정함. . 1의 indegree는? 0 (들어오는게 없다) . | 1의 outdgree는? 3 (3개가 나간다.) . in, outdegree가 중요한 이유는 indegree가 0인 지점이 시작점 일 될 수도, 한붓그리기 는 짝수여야한다. 등의 규칙이 있음 | . . | . | 이렇게 그래프를 저장하면, 최단거리나 가중치를 고려한 최소비용 등을 계산할 수 있게 된다 . | . | . | . 규칙적용된 tree인 이진트리로 heap/bst . 이진트리: Tree구조 자체가 graph만큼 어려워서 규칙을 정했는데 Tree의 rootnode가 1부터가 시작 | 자식은 최대2개로 하여-&gt;왼쪽자식node == 부모node의 2배가 너넘버링된다. 나node//2 는 부모node | . | | heap: NlgN으로 정렬을 유지하면서 데이터 pop/push가 가능하다. 그림 출저 | . | bst: python에서는 set, dict의 key를 원소-&gt; hash값 -&gt; hash값들을 bst 구조로 만들어 내부에서 사용되어 중복안되고 bst로 검색해서 빠르다? | . 그래프, 일반Tree, 점, 격자판 다 탐색하는 DFS와 BFS . DFS 전수조사시 사용되하는데, 1-&gt;0 마지막 탐색지점에서 빽할 때, 직전 node가 필요한데, 직전node를 stack 선언후 쌓아두는게 아니라, 재귀를 이용해서 stack을 자동 사용한다. 재귀함수=함수=stack메모리에서 관리되어 stack처럼 쓰임 | . | . | BFS 시작좌표(시작점, root node)에서 시작하여 level별 = 최단거리별 기록하기 위해 queue(deque)을 사용한다. 목표좌표가 나타나는 최단거리(level)을 구하거나 | 해당 level이 끝났을 때 최단거리의 수? | . | level별로 좌-&gt;우순으로 검색한다. | queue에 시작좌표를 넣어놓고 빼고 -&gt; (목표좌푠지확인) -&gt; 자식들 탐색 -&gt; 검사 -&gt; 넣기전 자체처리 -&gt; queue에 넣기 -&gt; (level별 시행시 L+=1) | . | . | . | 2개의 사용차이 찾는 범위가 국한되어서 n번안에 찾아지는 것이 확신을 할 수 있을 경우 -&gt; BFS 숨바꼭질2 | . | 모든 범위를 찾아봐야 하는 경우(매 탐색마다 1-&gt;0 바뀌는 끝을 찍어야하는 경우?) -&gt; DFS 단지번호 붙이기 | . | | . 앞으로 공부하는 방법 . 많이풀기 삼성은 DFS, BFS 30문제정도 | 카카오는 Trie를 포함해서 30문제정도 | | 암기하기 이해로는 X 많이 쓰면서 암기하는 과정이 필요하다. | 자기만의 템플릿이 있어야 한다. | | 주기적 체크하기 대회? | 안내서 노션 | |",
            "url": "blog.chojaeseong.com/algorithm/pythonic/2021/10/17/sktacademy_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_python_%EB%AC%B8%EB%B2%95TIP.html",
            "relUrl": "/algorithm/pythonic/2021/10/17/sktacademy_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_python_%EB%AC%B8%EB%B2%95TIP.html",
            "date": " • Oct 17, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "협업2) 오픈소스에 PR + 팀원이 PR + issue와 함께 PR 날리는 법을 학습",
            "content": "여러가지 Pull Request 날려보기 . Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . 노팀원 fork PR(팀원-PR받기만/ 타인(나)-Fork후 수정용브랜치로 push하여 타인의 PR) . 앞에서 PR = 팀원1(주인):수정용브랜치 -&gt; 팀원2:collaborator이며 리뷰만 PR(주인-수정용브랜치 / 팀원-리뷰만) 실습 로컬 : git_seminar | 원격 : CS100_Git in is3js . 협동자: is3js | . | . | . | 소샬코딩의 PR . 오픈소스 레포(is3js) : py . 주인 혹은 collaborator임. | . | 기여하고 싶은사람(is2js, 나): py(fork) . 팀원이 아닌 이상 일단 fork한다 | 팀원이 아니더라도 clone후 로컬에서 topic branch를 따서 작업한다. | fork레포(내꺼)에 commit, push한다 | 팀원이 아니지만, fork레포 - topic branch의 변동사항을 push로 PR한다. | . . | . | . 팀원아니더라도 fork-clone-topic따서 작업한 뒤 -&gt; (merge하지않고) commit, push . 나는 오픈소스의 collaborator가 아니므로 오픈소스(py)를 fork한다. . | 작업을 하려면 일단 clone부터해서 local에 가지고 온다. . ❯ git clone https://github.com/is2js/py.git .❯ code . . git 설정을 한번 확인해준다. . ❯ git config --list . remote.origin.url=https://github.com/is2js/py.gitremote.origin.fetch=+refs/heads/*:refs/remotes/origin/*branch.main.remote=originbranch.main.merge=refs/heads/main . | . | fork를 해온 상태는 main브랜치이다. 새로운 topic 브랜치 work를 따서 작업 -&gt; commit -&gt; work를 push까지해보자. . 브랜치 클릭 -&gt; +새 분기 만들기 &gt; work . | main에 merge하는게 아니라 topic branch를 commit -&gt; push해야 팀원아닌데도 PR을 날릴 준비를 할 수 있다. . 명령어로 할 거면 . git push origin [topic branch명] . | . | . | fork한 내 레포라도 topic branch가 merge없이 push되었으면 PR로 인식된다. . 내 개인소스 수정: merge –no-ff -&gt; main commit -&gt; push PR : no merge -&gt; topic commit -&gt; topic push | . | 원본레포인 is3js/py는 미동도 없고, fork한 내 레포 is2js/py에만 PR이 들어온다. | . | topic push로 만든 Fork레포 PR클릭시 원본레포(baserepo) PR을 유도: 전제-main(master)는 변화없이 topicbr만 변화! cf) Fork레포(headrepo)로 merge도 가능함. . 일단 기본적으로 fork한 내 레포(head repo) : is2js/py에서 | 원본 레포(base repo) : is3js/py로 PR를 보내는 것을 기본적으로 수행하려 한다. | fork레포에서 PR버튼 눌렀는데, 이미 원본레포(is3js/py)로 이동되어있다. | . | . . base repo를 수정하면, fork-main &lt;- fork-topic 도 가능한가보다. . | Create pull request해보자. . 원본레포에다가 날리는 것이다. | 원본레포에서 보면 PR이 불들어와있다. | . . | fork레포는 PR에 아무 표시도 안된다. . | 원본레포 팀원은, 팀원X-Fork-topic-PR 날린 것을 commit을 직접 확인하여 request chagnge하거나 approve해준다. . PR 확인후 해당 topic branch의 커밋까지 찾아들어간다. . . | 코멘트를 날릴 땐, +드래그해서 많이 날릴 수 있음. . | 최종적으로는 우측 상단의 review changes &gt; approve까지 해야하지 merge된다. . . | 최종승인하면 원본의 기본branch인 main으로 알아서 merge된다. . | 팀원이 아니더라도 PR(merge)후 delete branch가 원칙: 로컬에서 로컬+fork 2개다 해줌. . 로컬에서 내 fork레포 및 내 로컬레포의 topic branch를 삭제해준다. . main으로 바꾸고, 삭제 | . ❯ git branch -a❯ git checkout main❯ git branch -d work . | . 로컬topic 삭제 -&gt; remote(fork레포)도 자동삭제 반영시키기: git remote update –prune . 로컬에 topic branch가 삭제된 상태에서 git remote update --prune을 사용하여 로컬에 맞춰서 branch삭제 시킨다. . | ❯ git remote update --prune . | 안되서 나는 git push origin :remote_br . git push origin :work . | 참고) origin과 upstream . 레퍼런스: https://pers0n4.io/github-remote-repository-and-upstream/ | . Upstream &amp; Downstream . GitHub에서 repo를 생성하고 나면 다들 origin이라는 용어를 보셨을 겁니다. clone했을 때는 origin이 자동으로 등록돼있고, init했을 때는 git remote add origin ...으로 origin을 직접 등록하라고 안내하죠. 여기서 말하는 origin이 깃허브에 존재하는 repository 즉, remote를 뜻하는 단어입니다. 다만 remote에 origin이라는 이름을 붙인 것뿐이랍니다. . upstream과 downstream은 상대적인 개념이라 origin과 local을 기준으로 생각하면 origin이 upstream, local이 downstream이 됩니다. 그 이유는 push와 pull을 기준으로 생각했을 때 origin으로부터 local로 흐르는 관계가 형성되기 때문입니다. . local에서 origin으로 push한다 | origin에서 local로 pull한다 | . 만약 CLI로 push를 해보셨다면 git push -u origin main3이라는 명령어를 입력했을 텐데, 여기서 -u 옵션이 --set-upstream 옵션의 줄임으로 upstream을 설정한다는 뜻입니다. upstream을 한 번 설정하고 나면 다음부터는 git push 또는 git pull이라고 명령어만 입력해도 자동으로 origin의 main 브랜치로부터 push와 pull을 진행하는 이유가 upstream 옵션을 통해 해당 브랜치에서 upstream과 downstream 관계가 설정됐기 때문이죠. . Fork . GitHub에서 오픈소스 프로젝트에 기여한다거나, 협업을 진행할 때 fork를 이용하게 됩니다. fork는 다른 사람의 repository를 내 소유의 repository로 복사하는 일이죠. 따라서 원래 소유자의 remote repository와 내가 fork한 remote repository 사이에도 upstream과 downstream이라는 관계가 형성된답니다. 그래서 보통 원래 소유자의 remote를 말할 때 upstream, 내가 포크한 remote를 말할 때 origin이라는 용어를 사용하곤 합니다. . 노팀원이지만 [원본repo(오픈소스)] -&gt; fork레포 및 local레포를 최신형으로 유지 by local에서 upstream으로 등록하여 upstream(원본레포) -&gt; origin(fork레포), upstream -&gt; local 통로뚫고 가져오기: git remote add upstream [url] -&gt; git fetch upstream -&gt;[fork레포 ]merge버튼 + [local]git merge upstream/main . 상황 . 갑자기 오픈소스 author가 원본repo -&gt; main을 변경했다면? . 나한테(fork레포, local레포)의 main도 수정된 내용이 들어와야한다. | . . | 기존 local repo에서 -&gt; fork repo를 origin 이라 별칭했음 . local repo에서 -&gt; 원본repo를 upstream으로 별칭 등록 및 원본repo - fork repo를 연결 | . | git fetch: origin to local . git fetch upstream: 원본repo(upstream) to fork repo(origin)으로 업데이트 내용 받아오기 | git merge upstream/main으로 원본repo(upstream) to local repo(local)로 업데이트 내용 받아오기 | . | . | my) 원본repo를 노팀원이 upstream으로 local에서 등록하면 . upstream -&gt; fork | upstream -&gt; local 업데이트가 가능하다. | . | . | 관련 명령어 . . | 참고) upstream 삭제 . 참고 블로그 . git remote -v git remote rm upstream git remote -v . | . | . local에서 원본repo를 upstream으로 등록한다. . ❯ git remote add upstream https://github.com/is3js/py.git . . | git fetch upstream명령어로 upstream의 최신정보를 origin이 받을 수 있도록 업데이트해온다.(아직 받진 X) . ❯ git fetch upstream remote: Enumerating objects: 8, done. remote: Counting objects: 100% (8/8), done. remote: Compressing objects: 100% (3/3), done. remote: Total 5 (delta 2), reused 4 (delta 2), pack-reused 0 Unpacking objects: 100% (5/5), done. From https://github.com/is3js/py * [new branch] main -&gt; upstream/main . origin(fork repo)에 가보면, Fetch해왔다고 뜬다. | . | fork repo에 들어가 git fetch upstream정보를 이용해 최종 merge시킨다. by Fetch upsteam&gt; Fetch and merge 버튼 . | local에서는 git merge upstream/main명령어를 이용해 upstream정보를 가져온다. . 왠지 origin을 pull해서 업데이트 해도될것같긴한데… 따로 upstream -&gt; local로 받는다? | . ❯ git merge upstream/main Updating 476f70b..f7dd8e8 Fast-forward .gitignore | 11 ++++++++++- rb.py | 3 +++ 2 files changed, 13 insertions(+), 1 deletion(-) . 참고) 만약 merge가 conflict나면 . git merge upstream/master --allow-unrelated-histories . | . | 앞으로 계속 . ❯ git fetch upstream # fork repo가서 merge 버튼 # local에서 merge ❯ git merge upstream/main . | 팀작업1: 내부팀원 (not 오픈소스) 초대 및 작업하기 . 내부 소스( not 오픈소스)라고 가정한다. | 관련 명령어 | . 팀리더(is3js)가 팀원(is2js)초대 : github-settings-manage acess-add people(invite collaborator) . 초대받은 사람은 등록 email로만 초대를 받음. push권한이 있다고 한다. = 글쓰기 기능이 있다. | . | . 팀원은 초대되었다면,fork(-&gt; clone -&gt; topic -&gt; PR)할 필요가 없이 clone(-&gt;push)or(-&gt;topic-&gt; review=팀원PR)만 한다. 팀원이라면 바로 local-&gt;팀repo에 바로 push가 가능 . 팀원은 초대되었다면,fork(-&gt; clone -&gt; topic -&gt; PR)할 필요가 없이 clone(-&gt;topic-&gt;push or review=팀원PR) . ❯ mkdir team_py❯ cd team_py❯ git clone https://github.com/is3js/py.git . . | 해당 폴더로 이동후 수정하고 commit -&gt; push까지해보자. . 원래는 topic -&gt; | . code .# main에서 바로 # 파일수정# add commit -&gt;push . | 팀원이라면, 팀repo에 바로 push가 된다. . | 팀작업2: 내부팀원의 clone (local)에서 topic push로 PR권유 -&gt; topic push한 사람만 PR요청 가능 -&gt; 타 팀원review받기 (review안받을거면 main push했음) . . topic push한 작업팀원만, 자신에게 PR권유를 확인 및 요청할 수 있다. . 팀원은 fork필요없이 local clone후 main push해도 되지만, review를 받기 위해 topic push로 PR한다 . user-login topic branch 생성 . git checkout -b user-login . | login.py 생성 후 작업 . | add, commit, (topic branch) push . | | **팀원repo에 들어가도 ** . topic branch를 보낸 사람이 아니면.. PR권유가 안뜬다. . is3js(타팀원) . PR권유는 topic br push한 사람 자신에게만 보인다. | . . branch로는 보여도, PR은 타팀원이 결정안함. | . . | is2js( topic br push한 작업 팀원) . . | . | . | topic br push를 pull request한다. . 메세지에 코드리뷰 부탁한다고 남기자. | . | 타팀원은 PR 불-&gt; commit 메세지-&gt; commit 클릭 -&gt; 코드 리뷰 . author가 아니더라도 모든 팀원들이 확인할 수 있게 ** **PR에 불이 들어와있다. . | Merge를 누르기 전에 메세지에 달려있는 커밋까지 직접들어가서 코드를 살펴보자. . . | code line에서 +를 드래그해서 코드 리뷰를 해준다. . | 거절을 의미하는 코드 리뷰를 해주자. 코드리뷰한 것 바로 밑에 Reply도 달 수 있으니 확인하면된다. | 코드 리뷰를 데면 우측에 Finish your review(1)가 뜬다. 클릭해서 리뷰를 끝내자. | . | 코드 리뷰를 달면, 자동으로 작업 팀원에게 email도 보내준다. | (topic push -&gt;PR했던) 작업 팀원은 확인해서 1) Reply + 2) local에서 추가작업 -&gt; 3) topic br PUSH -&gt; 4) 자동 PR timeline에 추가 . . 거절성 코드리뷰에 대해 대답을 해주고 . | PR 날렸던 topic br로 다시 돌아와서 . 추가 작업을 함. . ❯ git checkout user-login . | . | 다시 한번 topic br push하면, 추가 PR을 안날려도 자동으로 PR 타임라인에 추가된다. . | 타팀원의 2번째 review부터는 [작업팀원의 추가push]가 자동으로 PR timelien에 추가된다. . 타팀원 화면에서는 작업팀원의 추가작업한 커밋 위에 View changes가 떠있다. . 작업팀원이 커밋할 때 . . | 타팀원(리뷰팀원)화면 . | . | 승인은 LGTM(looks good to me) . 코드 리뷰를 다시 한번 남기고 | finish your review에서 approve를 선택해주면 끝난다. 이 때 멘트는 LGMT를 많이 쓴다. | approval이 떴다면, 작업팀원이 merge PR해도 된다. 아무나 팀원이면 다된다. merge후에는 delete (topic) branch -&gt; local code 최신화(git pull) -&gt; local의 topic branch는 직접 삭제() . approve 확인되면 | 작업한 팀원이라도 merge시킬 수 있다. . | 작업이 끝난 topic branch를 삭제하라고 뜬다. 삭제한다. . | 로컬의 main 코드를 최신화하기 위해 main branch로 와서 git pull로 코드 최신화한다. . ❯ git checkout main . | 로컬의 topic branch도 직접 삭제한다. . ❯ git branch -d user-login Deleted branch user-login (was b7bde3a). . | cf) 혹시 delete branch 안해서 서버에 남아있다면? . local branch 수동 삭제 . | remote 동기화로 삭제 . git remote update --prune . | 팀작업3: issue(개선기록) 와 PR(팀원1(주인)-수정용브랜치push PR / 팀원2-리뷰만) 실습 . 로컬 : git_seminar . | 원격 : CS100_Git in is2js . 협동자: is3js | . | . 로컬 readme생성후 -&gt; 원격 빈레포에 push로 시작. 1번째 가이드: …or create a new repository on the command line(init, readme push) . 로컬에서, 빈 레포 생성시 주어지는 가이드1 번째인 …or create a new repository on the command line를 따라치기 . echo &quot;# CS100_Git&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;first commit&quot; git branch -M main git remote add origin https://github.com/is2js/CS100_Git.git git push -u origin main . 아직 git init안한 상태에서 readme.md를 먼저 만들고,, 시작하네 | . | . | 원격레포에 issue생성: issue는 TODO list 역할이나 논의사항 정리용 . 원격레포의 issue 탭 &gt; new issue 클릭 . readme.md 파일을 좀 더 구체적으로 작성해주라고 issue 생성하기 | . | issue 오른쪽 사이드바에 보이는 Assignees를 클릭하여, issue해결자 10명 중 1명으로 나를 등록한다. . . | issue 해결 전에, collaborator 추가 (상대방은 메일로만 초대받음) . settings &gt; manage access &gt; add people . is2js(tingstyle1@gmail.com, 현재) -&gt; (시크릿창) is3js 계정 추가 . . is3js(is2js@naver.com)계정은 깃허브알림 없이 메일로만 초대장이 옴 | . | . | . 로컬에서 생성 후 파일 수정하기: git checkout -b [생성후전환될 브랜치] . 로컬(is2js)에서 feature/readMe 라는 파일 수정용 브랜치를 생성하자 . ❯ git checkout -b feature/readMeSwitched to a new branch &#39;feature/readMe&#39;&gt;glg # git log(HEAD -&gt; feature/readMe, origin/main, main) . branch 변경 후 git log를 확인하니 HEAD가 브랜치를 잘 따라오고 있다. | . | 파일 수정후에는 add전 gitt diff로 어느부분 수정되어있는지 확인 . ❯ git diffdiff --git a/README.md b/README.mdindex 1743ce5..a6cac92 100644 a/README.md+++ b/README.md@@ -1 +1,3 @@ # CS100_Git++This is CS100 No newline at end of file . | add - status - commit 단계를 거친다. . ❯ git add README.md❯ git status . | (PR날릴 브랜치는)순수 git commit후 메세지 작성되는 부분에 [- issue #번호] 삽입하여, 해당issue에 커밋 걸어주기 . git commit만 입력하기 . &gt; git commit . | commit 메세지 작성 에디터에서 - issue #1의 관련된 issue 번호를 기입해주기 . ADD more description in README- issue #1 . . | 나중에 저렇게 삽입한 커밋속 issue #1지정 부분은 PR속에서 issue를 연결해준다. . **즉, issue에 대한 하여 PR(팀원검토)시에는 `#번호`를 커밋메세지에 넣어두자.** . . | . | 원격레포에 없는 지만, push해주면 &lt;알아서생성+PR권유&gt; . 로컬에서 원격레포로 수정용 브랜치를 push . ❯ git push origin feature/readMeCounting objects: 3, done.Writing objects: 100% (3/3), 289 bytes | 289.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)remote: remote: Create a pull request for &#39;feature/readMe&#39; on GitHub by visiting:remote: https://github.com/is2js/CS100_Git/pull/new/feature/readMeremote: To https://github.com/is2js/CS100_Git.git * [new branch] feature/readMe -&gt; feature/readMe . | github에 가보면, . 새로운 브랜치 생성 확인: 로컬에서 수정용브랜치를 push해서 자동으로 생성한 것 . . | 현재는 main우주만 보여주고 있음. 수정한 평행우주는 브랜치를 선택해서 들어가야 보임 . | . | 혼자는merge지만, PR은 를 팀원(collaborator)들에게 확인요청이니 메세지 한번더! . 혼자 작업했다면, . 로컬에서 수정용브랜치 -&gt; main브랜치 merge하면 끝 | . | 여러명 작업시 merge대신 . 로컬에서 수정용 브랜치생성후 파일 수정 . | 원격레포에 push하여 수정용브랜치 생성 . | 합치기전에 PR과정을 전시하여 팀원들에게 확인받기 . | . | . Compare &amp; pull request 클릭 . . | PR은 팀원확인요청이다. 로컬 커밋메세지가 default로 적혀있는데, 커밋메세지에 PR메세지로서 추가로 적어준다. . . | 아래와 같이 커밋메세지 따로에, PR메세지가 덮어서 보인다. . | PR을 검수할 팀원에게 review요청하기(수정용브랜치를 merge해도될지) . PR메세지 우측에 Reviewers가 있다. 여길 선택해서, PR review를 요청하자. | . is3js(팀원)계정을 시크릿창으로 들어가보자. . 레포 &gt; Pull request &gt; 해당PR까지 클릭하고 가야지 Review요청한 것이 보인다. (호버해도 보이긴하네) . . | | . | 리뷰요청받은 뒤 Add your review는 lineByline으로 피드백 주는 것 . add your review 클릭 . | 플러스버튼으로 피드백을 주면되는데 드래그로 여러라인에 대한 피드백을 줄 수 도 있다. . | 리뷰요청시 피드백(라인별코멘트)과 별개로, 칼을 뽑아야함: Approve(merge) or Request changes(다시push해) . 코멘트를 다 남겼으면, 우측 상단에 Finish you review로 칼을 뽑아야한다. . 이 경우 수정이 좀 더 필요하다고 하여 승인거절한다.내용없이 Reqeust changes 클릭 | . | 내가 남긴 코멘트의 위치 및 승인거절=변화요구의 메세지를 확인한다. . | [로컬] review내용인 1) 라인별코멘트에 [대한 대답reply] &amp; 2) 변화요구에 대한 [에서 수정후 다시 push] . 라인별 코멘트에 대한 대답 . | 리뷰어에 의한 Changes requested는 feature/readMe에 푸싱함으로써 커밋을 추가하라고 뜬다. . reviewer에 의한 request changes는 &lt;수정용 브랜치로 추가 커밋하면 다시 검토&gt;를 말하는 것이다. | . 다시 로컬 해당 브랜치로 와서 . | 요구대로 새롭게 작성후 push까지 해준다. . # 파일 수정# add전 git gtatusgit status#git add 파일명git add README.mdgit commitgit loggit push origin feature/readMe . | | PR은 의 단위라서 아직 merge안됬다면, 해당브랜치는 이어지며 가서 확인한다. . git push origin feature/readMe를 통해 push했으면, 아직 해당 PR상황에서 커밋이 추가된다. . main에서는 추가 PR 안내가 없음. 수정용 브랜치에서는 평행우주의 내용은 변화되었음. | . | reviewer에 의해 request changes는 &lt;수정용브랜치로 추가 커밋하면 다시 검토&gt;를 말하는 것이다. 즉, 검토하고 있던 PR상황으로 다시 직접들어가보면, 추가 push를 확인할 수 있게 됨. | . | . . | **의 추가push후**에는 되면 **또다시 review 요청해야한다.** . . | 또다시 PR(수정용브랜치 merge검토)에 대한 review요청을 받음. -&gt; LGTM approve해주기 . 역시 해당 PR까지 클릭해서 들어와야 보인다. . add your review . 라인별 코멘트 -&gt; 생략 | LGTM(Loos Good To me)와 함께 Approve | . . | . | . review가 approve해야 드디어 merge가 뜬다. 동시에 . . . 우측의 Delete branch를 눌러 수정용브랜치를 삭제해주자. . | PR탭은 Merged로 해결됨. . | [issue탭]에서도 Merged가 뜸. -&gt; [PR-&gt;merged]의 해결된 issue를 닫기 . . issue작성 후 . 수정용브랜치 생성 | PR를 위해 커밋 커밋시 issue번호를 #번호형태로 커밋메세지 속에 남기면 issue탭에서도 표기가 된다. | . | . | 수정용브랜치 push -&gt; PR 생성 -&gt; review -&gt; merged로 해결되었으면 issue도 닫아야한다. . 메세지로 닫는다 알리기 . . | Close issue를 눌러서 해당 issue를 닫는다. . | | [로컬]에서 default [main]브랜치로 옮겨와, PR-&gt;merged된 프로젝트 정보를 git pull로 내려받아서, 로컬에서도 통합 및 브랜치삭제가 반영되도록 한다. . 삭제당한 feature/readme&lt;수정용브랜치&gt;가 아닌 default main브랜치로 옮겨와서 git pull받는다. | ❯ git checkout main ❯ git fetch ❯ git pull # git pull origin main 으로 정확하게 표시하면 upstream설정이 안뜬다. # 그러나 한번만 업스트림하면 되므로 그냥 해준다. ❯ git branch --set-upstream-to=origin/main main Branch &#39;main&#39; set up to track remote branch &#39;main&#39; from &#39;origin&#39;. ❯ git fetch ❯ git pull Updating 99ce761..1ed16b7 Fast-forward README.md | 4 ++++ 1 file changed, 4 insertions(+) .",
            "url": "blog.chojaeseong.com/git/2021/10/16/%EA%B9%834_PR%ED%8C%80%EC%9E%91%EC%97%85_1%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4_2%ED%8C%80%EC%9E%91%EC%97%85_3%EC%9E%87%EC%8A%88%EC%99%80%EB%A6%AC%EB%B7%B0%EC%9A%A9PR.html",
            "relUrl": "/git/2021/10/16/%EA%B9%834_PR%ED%8C%80%EC%9E%91%EC%97%85_1%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4_2%ED%8C%80%EC%9E%91%EC%97%85_3%EC%9E%87%EC%8A%88%EC%99%80%EB%A6%AC%EB%B7%B0%EC%9A%A9PR.html",
            "date": " • Oct 16, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "협업1) 나혼자 2컴으로 협업(원격작업)하는 방법",
            "content": "나혼자 투컴협업(local to remote to local2) . Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . local to remote . 이미 로컬에서 관리하던 프로젝트를 github로 . local에서 작업시작 . 폴더 생성: . /home/is2js/workspace/git-github . | git init . | 계정입력(이미 global로 했으면 안해도됨) . | 파일 생성 . cat | mouse | . | 커밋 . ❯ git add -A ❯ git commit -m &quot;FIRST COMMIT&quot; . | . | 혹시나 연결된 원격레포가 있는지 확인 . git remote 아무것도 안뜨면 없는 것 | . | . | 깃헙 레포 생성(git-github) for 로컬을 원격으로 . readmd 등 생성하지 말아야함! 이미 local에서 git으로 관리하고 있던 프로젝트를 올리는 것이므로 아무것도 없어야함. | 아무것도 코드가 없을 때 나타나는 화면이 나와야함 | 구성 : https://github.com/is2js/git-github.git githuburl + /유저명/레포명.git | . | . | . | git status로 현재까지의 상황이 다 커밋되어있는지 확인한다. . ❯ git status On branch master nothing to commit, working tree clean . 빠진게 있으면 전부 add -A해서 commit | . | 로컬내용을 빈 원격레포에: git remote 등록 git push 내용옮기기 . 원격레포에 코드가 없을 경우 뜨는 페이지에서 …or push an existing repository from the command line 란을 복사버튼을 눌러서 . 현존하는 로컬 깃관리 레포를, 원격레포에 push하도록 복사한 내용을 cli에 붙혀넣기 해준다. . 현재는 코드가 main브랜치를 만들고, main 브랜치로 push하도록 변경되어있다. . | 복붙후 내 로컬도 main브랜치로 바껴있다. . | 아예 master브랜치 -&gt; main브랜치로 브랜치이름변경하는 명령어 인가보다. . git branch -M main . With a -m or -M option, will be renamed to | . &gt; git branch * main (END) . | . &gt; git remote add origin https://github.com/is2js/git-github.git git branch -M main git push -u origin main Counting objects: 4, done. Delta compression using up to 12 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (4/4), 273 bytes | 273.00 KiB/s, done. Total 4 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-github.git * [new branch] main -&gt; main Branch &#39;main&#39; set up to track remote branch &#39;main&#39; from &#39;origin&#39;. . | 이 때, 명령어를 뜯어보면 . git remote add origin https://github.com/is2js/git-github.git . git remote add [원격레포의 별칭, default origin] [레포 url]로서 원격레포url의 원격레포를 별칭(origin)으로 등록 | . | git branch -M main . 브랜치명을 main으로 변경 | . | git push -u origin main . git push -u [등록된 원격레포별칭, default origin] [올릴 원격레포의 branch] | . | 이후 나오는 메세지 중 현재 main브랜치가 , 원격레포인 origin의 원격 브랜치main을 추적한다.고 메세지가 뜬다. . Branch &#39;main&#39; set up to track remote branch &#39;main&#39; from &#39;origin&#39;. . | . | git remote명령어로 실제로 연결이 잘되었는지 확인 . ❯ git remote origin . | . | 빈 원격레포에, 관리되던 로컬 프로젝트 내용이 올라갔다면, 레포의 기본페이지가 바뀐다. . 커밋내용은 로컬에서 커밋한 기록들이 다 뜬다. | . | 소스트리에서 해보기 . 소스트리로 해당 레포 열기 | 저장소탭 &gt; 원격 설정 클릭 현재 나는 이미 터미널로 연결된 상태라, 원격 저정소 경로에 하나가 추가 되어있다. | . | 추가 클릭 원격 이름: 원격url의 원격레포에 대한 별칭, default origin | URL/경로: 원격레포의 url 복붙 | 호스트 종류: github | 사용자명: github id 입력 | . | 원격 탭에서 원격레포의 별칭(주로 origin)으로 확인하기 . | push버튼 클릭 로컬 / 원격(리모트) 브랜치를 각각 선택해주고 push해주자. | . | 파일추가(수정) 후 commit까지 한 뒤 push: git push [원격레포별칭] [그 레포의 브랜치] . dog파일 추가 . | git add - A, git commit -m , git push [원격레포별칭, 주로origin] [그 레포의 브랜치] . ❯ git add -A ❯ git commit -m &quot;ADD dog&quot; [main 15a73f6] ADD dog 1 file changed, 1 insertion(+) create mode 100644 dog ❯ git push origin main Counting objects: 3, done. Delta compression using up to 12 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 302 bytes | 302.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-github.git d33f3a8..15a73f6 main -&gt; main . | 올릴필요가 없거나(코드로 자동생성) 올려선 안되는 파일(DB계정 등)처리: .gitignore . 올릴 필요가 없는 파일 : 코드로 자동 빌드되는 파일들 그 때 그 때 실행해서 만들면 되므로 올릴 필요가 없다. 안드로이드나 스프링 등에서 처음부터 골격이 세팅된 체 시작하는 프로젝트들을 생성하면 .gitignore가 미리 만들어져있다!! | . | . | .gitignore에 등록하면 add + commit의 대상으로 안봄. 버전관리 안됨. | . | . 프로젝트폴더 최상위 공간안에 .gitignore파일 생성 . 숨김파일로 지정되니 참고해야함 | . | gitignore에 넣을 파일 secret-animal을 만들고, git status로 상황을 확인하자. . Untracked files(add해야할 목록)로서 아직 add안된 파일 2개를 알려준다. . Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) .gitignore secret-animal . | . | 이 상태에서 secret-animal 파일을 .gitignore에 적으면, git status상 add해야하는 파일에서 제외된다. . 아하~ 아예 add할 파일로조차 보지도 않음. | 내 프로젝트에 있어도 add + commit을 안하므로 push도 관리도 안됨. | . Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) .gitignore . | remote to com1,2 . 원격repo를 현재폴더에다가 가져오기: git clone [url] . . 1개 컴으로 연습하려면, 폴더 2개를 만들어서 해보면 된다. . . 일단 폴더 2개를 만든다 computer-1 | computer-2 | . | 참고) clone시 해당목적지 폴더로이동 &gt; git clone [url] [.] | 소스트리는 해당 목적지폴더 선택만 | . | . | . 컴퓨터1의 폴더를 vscode로 연 다음, 터미널도 켠다. . 윈도우탐색기 &gt; wt -d . &gt; code . &gt; ctrl + ~ + wsl로 repoen? 윈도우 통해서 들어가면.. vscode wsl원격버전이 안켜진다. | . | wt &gt; wsl &gt; 해당폴더로 이동 &gt; code . | . | 기존 작업하던 원격레포(git-github)의 url를 복사한 뒤, vscode 폴더 터미널에다가 git clone한다. . #git clone [url] [.] git clone https://github.com/is2js/git-github.git . . 만약, clone시 [.] 현재폴더 옵션을 안주면, 그 내부에 폴더를 새롭게 만들어버림 . 새로운 컴퓨터의 로컬폴더 컴퓨터-1에다가 원격repogit-github의 내용을 가져왔다. | . | . | 연결된 나의 원격repo가 아니라 아무 원격repo를 클론해오더라도 git log로 모든 작업내역을 볼 수 있다. . git log . | 이제 소스트리로 컴퓨터-2 로컬폴더로 clone해보자. . + (new) tab &gt; Clone &gt; . 소스경로/URL : 원격레포url | 목적지 경로: computer-2폴더 지정 git clone 시에는 [원격레포url] [.] 현재폴더로의 옵션을 붙혀줘야하지만, 소스트리에서는 안해주고 폴더만 선택해주면, 그 폴더로 다 clone | . | . . | 이제 컴퓨터-2도 vscode로 열자. . | . | 새로올린(뒤쳐진) 커밋 내역 자동 확인: git fetch + git status . 컴1작업 -&gt; 원격레포에 push -&gt; 컴-2에서 일일히 작업내역을 확인하지 않고, git fetch로 뒤쳐진 내역이 있는지 확인 컴퓨터1 | 컴퓨터2 | . | . 컴1에서 dog name을 수정하고, add, commit호 원격레포에 push까지 해보자. . local의 global계정이 내 계정이라서 그런가 바로 push된다. . ❯ git add -A ❯ git commit -m &quot;EDIT dog&quot; [main 1eaa722] EDIT dog 1 file changed, 1 insertion(+), 1 deletion(-) ❯ git push origin main . . | . | 이제 컴2에서 일일히 github에 새로 올라운 커밋내역을 확인하기 힘드니 git fetch로 뒤쳐진==새로올라온 커밋의 갯수를 확인한다. . ❯ git fetch ❯ git status On branch main Your branch is behind &#39;origin/main&#39; by 1 commit, and can be fast-forwarded. (use &quot;git pull&quot; to update your local branch) nothing to commit, working tree clean . 원격레포/main 브랜치에비해, 내 브랜치가 1개 커밋 뒤쳐져있다고 나온다. | . | 뒤쳐진 내용 받아오기: git pull [원격별칭] [브랜치명] . 컴2에서 뒤쳐진 1개의 커밋을 받아온다. . &gt; git pull origin main From https://github.com/is2js/git-github * branch main -&gt; FETCH_HEAD Updating 15a73f6..1eaa722 Fast-forward dog | 2 +- 1 file changed, 1 insertion(+), 1 deletion(- . . | 소스트리에서도 git pull을 하기위해 . 컴2에서 dog 이름 수정 . | 소스트리 컴2에서 커밋과 동시에 push . . | 소스트리에서 컴1 폴더를 add . | 컴1폴더에서 패치버튼 선택 &gt; 모든 원격저장소에서 가져오기 선택 . . | main 브랜치에 당겨올 것들이 있다고 메세지가 뜸 . | pull버튼으로 받아오기 . | . | 일단 작업전에 메세지 안떠도 pull부터 누르고 시작하자 . 나혼자 투컴협업 branch, conflict . 브랜치를 이용해서 투컴협업 . 브랜치 전환, 없으면 생성해서 : git checkout -b [브랜치명] . branch기본 생성 : git branch [이름] | 전환 : git checkout [이름] | . | 브랜치 생성과 동시에 전환 git checkout -b [이름] checkout은 커밋id, 브랜치, tag 다되므로.. -b옵션을 주면 브랜치전환인데, 없으면 생성까지 | . | . | . 컴1에서 my-idea 브랜치 생성 . git checkout -b my-idea . . git branch . | my-idea이라는 평행우주에서 파일을 수정하고 add commit까지 한 뒤 push할 준비를 해자. . mouse 삭제 . | dinosaur 추가 . ❯ git add -A ❯ git commit -m &quot;ADD dino&quot; [my-idea e43a292] ADD dino 2 files changed, 1 insertion(+), 1 deletion(-) create mode 100644 dinosaur delete mode 100644 mouse . | . | 새로운 브랜치(평행우주)를 push: git push [origin] [새로운 origin의 브랜치명] . my-idea 브랜치를 -&gt; origin의 특정브랜치로 생성해서 push할 수 있다. 하지만 보통은 원격레포에 로컬과 같은 브랜치명으로 생성해서 올린다. | . | . 컴1의 my-idea브랜치와 동일한 이름으로 원격레포의 브랜치를 생성해서 push까지 해보자. . ❯ git push origin my-idea Counting objects: 3, done. Delta compression using up to 12 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 304 bytes | 304.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) remote: remote: Create a pull request for &#39;my-idea&#39; on GitHub by visiting: remote: https://github.com/is2js/git-github/pull/new/my-idea remote: To https://github.com/is2js/git-github.git * [new branch] my-idea -&gt; my-idea . **new branch로서 [로컬my-idea] -&gt; [원격my-idea]으로 push했다고 나온다. ** 즉, 로컬의 평행우주를 push한다고 해서 1:1대응 되는 것이 아니라 원격의 원하는 이름의 평행우주를 만들어서 push하는 구나. | . | . | 원격레포에서 새로운 브랜치(평행우주)가 생성되었고, push도 되었으니 PR를 고려해보라고 메세지가 뜬다. . . my) PR는 push된 임의의, 새로운 평행우주를 기본branch로 합치겠습니까? 정도이다. | 브랜치를 바꿔서 들어가보면, **새로운 평행우주가 로컬-컴1의 my-idea그대로 ** 펼쳐진다. | . | 원격레포의 새로운브랜치를 받는 방법은 [브랜치 생성&amp;전환명령어] 응용: git fetch -&gt; git branch -a -&gt; git checkout -b [생성할 로컬 브랜치(결국엔 뒤에 기입한 원격브랜치를 받아올 브랜치)] [origin(별칭)/pull해올 원격 브랜치명] . git checkout -b [생성할브랜치(결국엔 뒤에 기입한 원격브랜치를 받아올 로컬 브랜치)] [origin(별칭)/pull해올 원격브랜치명] 브랜치 생성&amp;전환 명령어로 원격레포브랜치를 pull까지 해버린다. | git checkout -b : 생성과 동시에 전환 | [생성할 로컬 브랜치(결국엔 뒤에 기입한 원격브랜치를 받아올 로컬 브랜치)] : 아직 원격이 새 평행우주(branch)가 없는 로컬에서, 받아줄 브랜치(평행우주)를 지정한다. | [origin/pull해올 원격브랜치명] : 원격레포 속 받고 싶은 평행우주 | . | 컴2에서 원격레포의 새로운브랜치(평행우주)를 받아보자. 굳이 main에 합쳐진 것이 아니어도 받아서 사용해도 된다. | . | . 컴2에서 로컬용 git branch에 -a옵션까지 더해서 원격 브랜치도 확인한다 . git branch -a * main remotes/origin/HEAD -&gt; origin/main remotes/origin/main . 원격branch는 github의 소식을 업데이트를 해줘야한다 | . git fetch git branch -a * main remotes/origin/HEAD -&gt; origin/main remotes/origin/main remotes/origin/my-idea . 원격레포의 (HEAD, default 작업장소)가 보는 곳은 아니지만 밑에 새로운 평행우주가 추가되었음 | . | 원격레포의 새로운 평행우주(my-idea)를 컴2의 my-dea로 받아와 보자. . 브랜치 생성&amp;전환명령어로 원격레포브랜치를 pull까지 해버린다. | . #git checkout -b [로컬브랜치명] [origin/원격브랜치명] ❯ git checkout -b my-idea origin/my-idea Branch &#39;my-idea&#39; set up to track remote branch &#39;my-idea&#39; from &#39;origin&#39;. Switched to a new branch &#39;my-idea&#39; . git branch로 확인해보자. . main * my-idea . | . | 소스트리로 컴2:new브랜치생성 to 원격 to 컴1으로 넘겨보기 . 이번엔 소스트리로 컴-2에서 브랜치를 생성후 원격레포에 생성과 동시에 PUSH . 브랜치 탭 &gt; 새 브랜치 : my-another-idea . | cat이름을 nyang으로 변경 . | 커밋과 동시에 origin푸쉬 by 소스트리 . . 만약 소스트리가 아니라면? . ❯ git add -A ❯ git commit -m &quot;EDIT cat name&quot; ❯ git push origin my-another-idea . push origin은 없으면 해당 브랜치 생성해서 push한다. | . | . | 깃허브에서 branch 생성 확인 . . | . | 컴-1의 소스트리에서 컴2-new브랜치(my-anther-idea)받아보기 . **컴1의 소스트리 &gt; 원격 탭 클릭 &gt; 원격의 새 브랜치 더블클릭 &gt; 새 브랜치로 체크아웃 ** . . | **원격 브랜치의 체크아웃만으로 로컬의 새브랜치를 생성 및 가져온다. ** . 따로 pull의 과정이 없는 것이 cli 든 소스트리든 마찬가지다 | . | . | my) 새 브랜치는 pull이 아닌 [checkout -b]만으로 로컬에 새 브랜치를 생성 및 내용을 가져온다. . 로컬 컴1-main에 브랜치들 merge(자동커밋)후 push -&gt; 컴2에서 fetch로 확인후 받아오기 . 컴1에서 브랜치병합후 원격레포에 push해보자. | . main(master)로 이동(받는놈) . | 주는놈인 my-another-idea 우클릭 &gt; 병합하기 . 현재 브랜치로 (주는놈) 병합 | . | push할 커밋수 확인해보기 . 병합전: main옆에 1은 push할 커밋수다. . . | 병합(자동커밋!)후: main2로 push할 커밋 1개 늘어남. . | . | 병합된 내역(커밋)까지 컴1 -&gt; 원격 레포에 소스트리로 push . push버튼 &gt; 병합된 내역 push | . | 이제 컴2의 소스트리에서 fetch로 원격상황 받아오기 . main브랜치에 pull받을 것들이 있다고 업데이트된다. . . | main으로 이동후 pull받아오기 . | . | ### . 충돌해결로 협업 . 한쪽에서 파일1을 수정해서 push했는데 . 다른쪽에서 파일1을 pull받지 않은 상태로 수정후 로컬커밋한 상태 . . | 다른쪽에서 pull받아야하는데, 같은파일이 수정된체 커밋된 상태면, conflict . . | . | . 직접 충돌내보기 . 컴1에서 dog파일 수정, 커밋, push . 한쪽 수정(bark: wang wang)이 push한 상태 . ❯ git add -A ❯ git commit -m &quot;EDIT dog bark wang&quot; ❯ git push . | . | 컴2에서 pull 받지도 않은 체 dog파일 수정후 커밋 . 다른 쪽이 pull안한체로 수정후 커밋한 상태 . ❯ git add -A ❯ git commit -m &quot;EDIT dog bark warl&quot; . ❯ git push To https://github.com/is2js/git-github.git ! [rejected] main -&gt; main (fetch first) error: failed to push some refs to &#39;https://github.com/is2js/git-github.git&#39; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., &#39;git pull ...&#39;) before pushing again. hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details. . pull할게 있으면 push가 안된다. | . | . | push가 안되면 . 원격에 누가 새 작업을 올렸구나. pull부터 받자라고 생각 . ❯ git pull . | . | pull받았는데 conflict나면 . 저쪽에서 같은 파일 수정했구나 ㅠㅠ라고 생각 . | git status로 더 자세한 상황을 보자. . ❯ git status #... both modified: dog #...저쪽과 나 모두 dog파일을 수정했네.. . | vscode에서 처리하기 . HEAD : 내가 작성한 부분 . | ===아래부분 : 저쪽이 작성한 부분 . . | . | . | conflict 후에는 git commit 을 -m 없이 커밋하여, 충돌 메세지를 그대로 저장하도록 한다. . git add -A git commit . git push해서 수정본을 원격레포로 보낸다. | . git push . | 브랜치삭제, 원격브랜치삭제: git branch -d vs git push -d [origin] [원격브랜치] . git branch 목록보기 . git branch -a . | 로컬 삭제 &amp; 원격 삭제 . 로컬 : git branch -d [브랜치명] | 원격 : git push -d origin [브랜치명] | . ❯ git branch -d my-idea Deleted branch my-idea (was e43a292). ❯ git push -d origin my-idea To https://github.com/is2js/git-github.git - [deleted] my-idea . | 소스트리로 충돌만들고 해결해보기 . 충돌일으키기 : pull받기 전, 같은 파일 수정후 로컬 커밋 push하면 충돌 발생 | 소스트리는 커밋과 동시에 push하므로 커밋당시에 발생 | . | 서로 다른브랜치(평행우주)라도 같은파일 수정상태면 conflict남 | . pull받기전에, 저쪽에서 수정한 파일을, 나도 수정한 뒤 소스트리로 커밋&amp;push를 눌러본다. 커밋은 성공했다고 따로 메세지 뜸. | . | push시 에러 -&gt; pull받자 -&gt; conflict뜨면? -&gt; 같은파일수정했네 pull을 했더니 소스트리에서 conflict를 알려준다. | . | **파일상태 탭으로 가보면, ** 충돌파일은 아직 add되지 않은 unstaged된 파일로서 존재 | 충돌파일 클릭시 충돌내용이 vscode처럼 나옴 | 충돌 커밋메세지는 자동 작성되어있음 cli라면 git commit만 하란 소리 | . | . | 직접 에디터(vscode)로 가서 수정해줘야한다. | 다시 소스트리로 와서 add후 커밋&amp;push | my) push에러 -&gt; pull받자 -&gt; conflict -&gt; 같은파일 수정했네. .",
            "url": "blog.chojaeseong.com/git/2021/10/16/%EA%B9%833_%EB%82%98%ED%98%BC%EC%9E%90%ED%88%AC%EC%BB%B4%ED%98%91%EC%97%85_branch_conflict.html",
            "relUrl": "/git/2021/10/16/%EA%B9%833_%EB%82%98%ED%98%BC%EC%9E%90%ED%88%AC%EC%BB%B4%ED%98%91%EC%97%85_branch_conflict.html",
            "date": " • Oct 16, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "기본2) vscode를 활용해서 git 심화내용 학습하기",
            "content": "Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . 깃 기본 with vscode . extension 2개 설치 . git extension pack | git extension pack 검색후 설치 | gitlens와 gitignore가 동시에 설치되어진다. | 왼쪽메뉴에 소스제어 를 클릭하면, gitlens가 통합되서 나온다. | 설정 &gt; git enable이 활성화 되어있는지 확인한다. . | gitlens layout 수정 . gitlens를 왼쪽메뉴에 따로 보이게 되었는데, 설명서를 읽으니 gitlens.setViewsLayout 검색 &gt; default로 클릭해야 source control탭에서 통합해서 볼 수 있다. | . | _git history는 팔레트에서 git log를 검색해서 사용 | . markdown all in one | markdown all in one검색 후 설치 . gitignore (팔레트커맨드) . add전에 설치된 gitignore를 사용하기 위해서ctrl+shift+p(모든 명령어, 팔레트)에서 gitignore를 검색하여, add ignore를 클릭 이후 python 을 검색해서 선택 -&gt; 파이썬을 제외시키는게 아니라 python관련 불필요 파일들이 등록이 된다. | create .gitignore가 생성되었다고 뜬다. | . | 소스제어에서, gitignore도 뜨는데, [파일열기]버튼이 따로 있다. . | python프로젝트를 선택하더라도 .vscode/폴더를 맨끝에 추가해준다. . .vscode로 달아도 되지만, 폴더라서 마지막에 슬래쉬도 넣어준다. | . . | . add remote(팔레트커맨드) . 빈repo를 생성 . readme파일만 체크해서 생성( 첨부터 push안되게 충돌내기 위함. ) | . | &gt; add remote 후 repo 선택 . 주의 [remote name]: origin으로 기본적으로 설정한다!!! . | 참고) add remote를 2개 했다면? git remote + remove [remote name] . | . | git config --list로 연결된 원격레포의 주소 확인하기 . | add, commit, and push in commits . U 파일들에서, +버튼을 눌러 add시키면, staging된 변경사항으로 이동한다. . | commit은 상단의 [소스제어]에서 체크버튼으로 staging된 변경사항을 한번에 다 commit시킨다. . | [commits] 탭 push를 클릭했다. . 해당 repo에서 push내역을 확인 | . . | . pull(명령어) 및 이질적인 프로젝트 병합 허용(–allow-unrelated-histories) . git pull origin main . 현재 remote가 빈 레포가 아니므로, push가 바로 안됨 . readme.md가 있기 때문에 pull당겨와서 충돌해결하고 해야함. . fatal: refusing to merge unrelated histories . | 이건 뭔짓을 하더라도 안됨. 따로 설정하면서 pull을 해줘야한다. . | . | . git pull origin main --allow-unrelated-histories . push . 갑자기 commits탭에서 사라져서.. 그냥 . vscode 작업표시줄을 클릭하여 push . | F1(팔레트)열고 git push검색해서 push . 해도 됨 . | . . | . [개념] branch (실무 많이) . main은 항상 deploy상태로 유지 | topic branch = 수정용 브랜치 = push해서 PR하는 브랜치 push를 자주해서 날라가는 것을 방지하자. | 검토후 merged(PR)후에 바로 삭제하는 브랜치 | . | develop branch는 삭제안한다. | main브랜치는 항상 최신으로 유지하므로 각 기능별 브랜치는 main에서 딴다. | [실습] branch(명령어) . . from-br없이 브랜치를 따면, 현재 브랜치에서 따는 것이므로 git branch명령어를 확인하고 따자. git branch new-br from-br | git branch git branch new-br | . | . | -로 직전브랜치를 checkout할 수 있다. . | checkout -b [new-br] [from-br]로 생성하면서 동시에 브랜치를 변경하게 되므로 가장 자주 쓴다. . git branch testbr main git branch * main testbr git checkout testbr Switched to branch &#39;testbr&#39; git branch main * testbr git checkout - Switched to branch &#39;main&#39; Your branch is up to date with &#39;origin/main&#39;. git branch * main testbr git checkout -b work main Switched to a new branch &#39;work&#39; git branch main testbr * work . | . git merge 와 fastforwad . 그림 출저 | . . merge commit은 서로 다른 상태의 브랜치를 병합해서 새로운 commit을 만드는 경우이고 . fast forward는 동일 내용이 포함되는 브랜치일 경우 브랜치 이동만으로 병합해서 따로 commit을 생성하지 않는 경우입니다. . | . topic branch(작업용브랜치) main에 merge후 삭제: git merge –no-ff / git branch -d . 현재 브런치 목록 . main testbr * work remotes/origin/main . | . work를 토픽브랜치라 가정하고 파일 work.py생성 후 커밋 . | main으로 돌아오면 당연히 파일이 없음. . | main에서 merge했다는 커밋을 남기면서(--no-ff) work브랜치를 받아오자. . 파일의 변화가 차이밖에 없는 경우. HEAD만 이동시키는 merge는 커밋이 발생안하고 앞으로 이동만 -&gt; fast forward가 발생하는데, 여기서는 직접 merge 메세지도 남긴다. | . ❯ git merge --no-ff work . | merge의 log확인을 git history라는 익스텐션으로 해보자. . 나는 git graph라는 익스텐션도 보인다. . . git history . | git graph . . | git log –oneline –graph 의 명령어 . . | . | . | merge확인후 topic branch삭제 . ❯ git branch -d work Deleted branch work (was cbf2765). . | git 탭에서 브랜치 변경후 개별커밋들 확인 . . 해당브랜치 화살표누르면 switch (checkout 됨) . | 왼쪽 화살표를 누르면, 각 브랜치마다 커밋 목록이 보인다. . 브랜치 생성이전 main브랜치 커밋이 그대로 보이는 듯함. | . . | testbr에서만 파일 생성후 커밋해보자. . testbr이 위로 올라왔다. branch 생성이후부터 달라진 커밋 차이가 난다. | . | . | [중요] topic branch에서 [다른topic이 merge된 main] 의 파일 1개만 받아오고 싶다면: git checkout -p . testbr에서 main속 work.py를 가져오고 싶다면 . git checkout -p [가져올브랜치명] [가져올파일명]을 이용한다. wsl2에서 안되서 windows 상태에서 하니깐 됬음. | . | . | . ​ 1. git checkout -p main work + y 로 main브랜치의 work.py를 가지고 온다. . ❯ git checkout -p main work.py diff --git b/work.py a/work.py new file mode 100644 index 0000000..e69de29 (1/1) Apply addition to index and worktree [y,n,q,a,d,?]? y . 현재 상태를 보면 add까진 된체 로 온다. add전후 살펴보는 git status로 봐도, 이미 Add는 되어있다. | . | work.py에 내용을 조금 넣어주고 commit하자. | 직전 commit의 메시지 변경: git commit –amend . git commit --amend를 치면, 직전 commit에 대한 메세지 수정사항이 editor 로 열린다. | git commit --amend . 메세지를 저장하면 자동으로 반영되어진다. . | 참고 . 마지막 커밋A에 일부만 빠졌다? 3을 빼고 1,2만 add 및 커밋한 상태 | 3을 git add한 뒤 git commit --amend | . | 그냥 커밋메세지만 변경 git commit --amend -m &quot;메세지&quot; | . | . | HEAD포함 n번째[에] commit 합치기or삭제 등 commit history 조절: git rebase -i HEAD~[숫자] -&gt; fixup or squash . HEAD~ = HEAD~1 HEAD포함 HEAD1개 전 ~1 = HEAD^ : 헤드의 부모, 헤드의 1개전 | . | . | rebase는 명령어로 하는게 더 빠르고 쉽다. | . . commit 1개당 1개의 의미를 가져야하나, 의미가 없는 커밋들을 하나로 합칠 때 , git rebase -i HEAD~ + [합칠 커밋갯수] 이후에 fixup: (귀찮아서) HEAD포함 n번째커밋에 커밋합치면서 n번째 커밋명으로 커밋합침 | squash: (새로운커밋명을 위해) HEAD포함 n번째커밋에 커밋합치면서 + 새로운 커밋명으로 합침 | 그외 reword(= amend), drop 등: 사용안한다. | . | . 커밋을 1111,222,3333333,4444,55555 5개를 새로 만들자 . | git rebase -i HEAD~[head포함 합칠 커밋갯수 &amp; head에서 뒤로 2칸 간 곳에서 합쳐짐.]을 커맨드로 입력한다. . ❯ git rebase -i HEAD~2 . . 여기서 커밋메시지 같은 git-rebase-todo 메세지에서 pick대신 fixup을 적어서 뭉개자. 최근커밋인 5555(HEAD)를 fixup으로 뭉개서 저장시키면 된다. | . | . 따로 뭔가 뜨지 않으면 .git &gt; rebase-merge &gt; git-rebase-todo를 클릭한다. . | 도착지(HEAD포함 n번째 커밋)는 선택지가 없다. . 최근 것이며 뭉개지는 HEAD는 선택지가 있다. . 여기서 fixup을 선택하면, 귀찮게 새로운 커밋메세지를 작성안하고 n번째 커밋명을 이용하게 된다. . . | start rebase를 해서 커밋을 합친다. . | . | . | 이제 444 -&gt;333으로 . git rebase -i . . 최근 것(아래 것)을 pick to squash로 변경해보자. . 과거커밋으로 합치는데 커밋메세지는 새로작성한다는 것이다. . . | 맨 위에 커밋메세지를 적으면 적용된다. . | . | 이미해버린 commit 취소는 직전HEAD로 돌아가면서 취소: git reset –hard HEAD~ . reset은 해당커밋까지가면서 자연스럽게 삭제한다. | . head의 부모로 가면서, head는 삭제 . ❯ git reset --hard HEAD~HEAD is now at 3460720 Merge branch &#39;testbr&#39; of https://github.com/is2js/git-ssac into testbr . . | add(staging) 취소는 아직commit안됬으므로 commit전 HEAD로 돌아가면서 취소: - or git reset HEAD . git extension으로 는 그냥 -버튼을 누르면 add가 취소됨 . | 명령어로는 git reset HEAD로서 . --hard없이 code를 살린체 최근HEAD로 돌아가면 -&gt; add취소가 자동으로 | . . git reset HEAD # HEAD 대문자여야함. . . | . 깃 심화1 with vscode . ### . git tag는 release의 의미를 가지므로 main에서 딴다. tag 혼자 = 커밋의 합 = 강의 n화 | 협업 = topic -&gt; main에서 merge후에 main에서 배포버전으로서 tag를 딴다. | . | . | . merge는 항상 명령어로 –no-ff를 붙여 커밋을 남기자 . --no-ff를 붙이면 fastfoward = 커밋없이 head위치만 바꾸는 것을 안하고 항상 merge커밋을 남긴다. conflict나면, Accept incoming후 git commit만 입력해주면 메세지 완성되어있음. | . | . main브랜치로 넘어가기 . | 명령어로 merge하기 . ❯ git merge --no-ff testbr Merge made by the &#39;recursive&#39; strategy. hello.py | 3 +++ testbr.py | 0 work.py | 1 + 3 files changed, 4 insertions(+) create mode 100644 testbr.py . | merge후 topic branch는 삭제: git branch -d . merge가 되었다면, topic 브랜치 삭제하기!! . git branch -d testbr Deleted branch testbr (was 74296bb). . 만약, fully merge가 안되었다고 뜨면? 대문자 -D로 강제 삭제해준다. . git branch -D testbr . | . | tag 확인 및 생성 in main브랜치:git tag [v0.0.1] . tag는 release될 main브랜치에서 작성한다. | tag는 release단위 = 배포단위로 생성한다. | tag는 소스코드를 push를 해놓은 상태에서 -&gt; tag를 local에서 따고 -&gt;tag를 push한다. | . ❯ git tag ❯ git tag v0.0.1 ❯ git tag v0.0.1 (END) . tag는 commit과 별개로 따로 push: git push origin [tag(=버전)] . git push origin [태그명=버전명] . ❯ git push origin v0.0.1 Total 0 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-ssac.git * [new tag] v0.0.1 -&gt; v0.0.1 . | git repo에, tag가 생긴 것을 우측사이드에서 확인가능 . | code수정 후 commit-&gt;push 끝난 뒤, 따로 tag 따고 -&gt; push . 파일(코드) 수정 . | local git commit . | local -&gt; origin(원격레포)로 push . ❯ git add -A ❯ git commit -m &quot;askldjflkasd&quot; ❯ git push . | commit의 push가 끝난 뒤, tag를 딴다. . ❯ git tag v0.0.2 ❯ git push origin v0.0.2 Total 0 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-ssac.git * [new tag] v0.0.2 -&gt; v0.0.2 . | tag는 과감하게 돌아가기: git reset –hard [태그] . git reset --hard [commit_hash]를 하면 해당 커밋까지 돌아가면서 자연스럽게 그 이후의 내용들은 삭제되었다. 하지만, 태그의 경우, code + commit은 돌아가나 tag는 삭제안되고 남아있다. | . | . ❯ git reset --hard v0.0.1 HEAD is now at bd4c018 Merge branch &#39;testbr&#39; into main ❯ git tag v0.0.1 v0.0.2 . 되돌아가도 tag는 남아있으니 직접 삭제해줘야한다. | . reset tag이후에도 local+remote tag 따로 삭제: git tag -d 태그 / git push origin -d 태그 . 로컬 tag를 삭제한다. . git tag -d v0.0.2 Deleted tag &#39;v0.0.2&#39; (was 476f70b) . | 원격에 남아있는 tag도 삭제한다. . git push origin -d v0.0.2 To https://github.com/is3js/py.git - [deleted] v0.0.2 . | 깃 심화2 with 개념위주 . 실수로 다른브랜치에 커밋or코드의존성때문에 다른사람 커밋이 필요할 때: git cherry-pick 으로 특정커밋만 똑! 가져올 때 . . 코드의존성 . 다른사람 커밋 위에서 일해야하는 경우 ex&gt; 다른사람이 버그고침 -&gt; 나는 그위에서 일을 해야할 때 | . | . | master branch의 cccccccc커밋만 -&gt; my branch로 . 커밋해쉬 앞 7글자 . git cherry-pick ccccccc . . | . | . git reset 총정리(add취소, commit취소) . ADD취소 2가지 . 옵션을 안주면 mixed | . . | 커밋취소 3가지 . HEAD뒤에 눈웃음 한개 ^ --soft : commit만 취소 + add + 내용물 그대로 | (mixed) : commt취소 + add취소 + 내용물만 그대로(unstaged) | --hard : commit취소 + add취소 + 내용물취소 | . | . . | . HEAD와 ^, ~숫자 . HEAD: 로컬 workingDir의 현재 작업중인 커밋 switch하면 작업폴더, 작업하는곳도 바뀌니 head도 바뀐다. | add만 했다면? 커밋이 아직 아니므로 HEAD가 보고 있진 않다. | . | HEAD^: 현재작업중 커밋의 부모커밋 ^^ : 부모의부모 | ~3 : ^^^쓰지말고, 3단계 전 커밋 | . | . 다시git reset HEAD 살펴보기with 돌아가서 자연스럽게 취소 . add 취소 . 커밋이 아니므로, HEAD는 아직 안보고 있다. . | 그래서 git reset HEAD를 하게 되면, HEAD커밋을 삭제하는게 아니라 git reset [여기] = [여기]로 돌아가겠다 = 해당커밋이후로 add는 커밋은 필요없다. 자연스럽게 add를 취소 . . | . | 커밋취소 . git reset HEAD^ 현재의 부모커밋으로 가고 싶다. . | 를 통해서 현재커밋을 취소 . . | . | 작업중에 다른작업요청시 commit도 reset도 애매한 임시저장: git stash . 로그인 브랜치에서 작업중인데, 갑자기 로그아웃 브랜치를 수정해달라고함. . 브랜치를 정리해야지만 브랜치변경이 가능함. 커밋한다음 reset을 해도되긴하겠지만,,, | . | 커밋하기엔 미완성, 작업물을 날릴순 없다. 임시저장으로 정리 | . | 현재 어느정도는 add된 상태 . unstage된 = add되지 않는 파일도 있음. . . | add, unstage 다 합쳐서 사진을 스태시! 하고 찍는다. . git stash . . 커밋이후의 상황들 전체가 stash 바구니에 담기게 됨. . . | . | 바구니에 담기면 사라진다. . | . | git stash pop을 통해 stash바구니에서 꺼내면 다시 적용된다. . . stack처럼 pop으로 나온다. | . | git stash, git stash pop 이외에 git stash list도 있다. . | . 마지막 커밋 변경(내용추가, 메세지변경): git commit –amend . . 마지막 커밋A에 일부만 빠졌다? 3을 빼고 1,2만 add 및 커밋한 상태 | 3을 git add한 뒤 git commit --amend | . | 그냥 커밋메세지만 변경 git commit --amend -m &quot;메세지&quot; | . | . merge말고 1줄로 합치는데, 상대주는놈branch 위에 올려서 합칠 때:git rebase . 내 브랜치들을 주는놈branch 위에서 적용시키고 싶을 때 . 최근브랜치가 내꺼가 되면서, 내가 주는놈 위에 적용됨. | . . . | 주의할점으로, 주는놈위에 쌓아올려질 때, 그대로 가는게 아니라 커밋해쉬가 달라짐 . | . merge vs rebase . . merge와 비교 장점: 커밋해쉬 유지 및 흐름 유지되어 돌아갈 수 있음 | 단점: merge라는 불필요커밋을 생성함. | . | rebase 장점: 주는놈위에 받는놈위주로 정리가 됨. 깨끗한 커밋 히스토리가 됨. | . | . 커밋 합침, 삭제 등 커밋 히스토리 조절: git rebase -i . . pull받은이후 rebase로 커밋해쉬가 바뀌었다면? 어쩔수 없이 git push –force . . remote branch2개를 잘 받아왔다. . | 이후 git rebase(주는놈위에 쌓아서 합침)로 내 커밋해쉬가 바뀌었다면? . . 이 상태에서 git push하면 reject된다. | . | 어쩔수 없이 git push --force로 덮어씌워야함. . | 협업중엔 조심해야한다. . 남자가 rebase후 푸쉬포스로 덮어씌워진다면,, . . | 같은 브랜치 협업중에는 미리 말안하는 이상 rebase 및 push force를 하면 안될듯 . | . | . alias . git push까지 . status diff add cache? commit log | . | git폴더에 . . | 내 환경설정에 . | 참고 . 히데쿠마 설정 . ## alias # git alias gst=&#39;git status&#39; alias gc=&#39;git commit&#39; alias gm=&#39;git merge&#39; alias gr=&#39;git reset&#39; alias ga=&#39;git add&#39; alias gaa=&#39;git add --all&#39; alias gloga=&#39;git log --oneline --decorate --color --graph --all&#39; alias glog=&#39;git log --oneline --decorate --color --graph&#39; alias gco=&#39;git checkout&#39; alias gb=&#39;git branch&#39; alias gcb=&#39;git branch | fzf -m | xargs git checkout&#39; alias gmb=&#39;git branch | fzf -m | xargs git merge&#39; alias gdb=&#39;git branch | fzf -m | xargs git branch -D&#39; alias gp=&#39;git push&#39; alias gf=&#39;git fetch&#39; alias gl=&#39;git pull&#39; alias gd=&#39;git diff&#39; alias ghf=&#39;git ls-files -v | grep &quot;^h&quot; | cut -c3-&#39; # dkr alias dkr=&#39;docker&#39; alias dkrp=&#39;docker-compose&#39; # for docker #sudo mount --bind /mnt/c /c sudo mount --bind /mnt/d /d export DOCKER_HOST=tcp://0.0.0.0:2375 # basic alias dotfiles=&#39;cd ~/dotfiles&#39; alias ll=&#39;ls -al&#39; alias l=&#39;clear &amp;&amp; ls -al&#39; #alias cdd=&#39;cd /d/&#39; alias ws=&#39;cd /d/workspace&#39; #alias solup=&#39;cd /d/workspace/solup&#39; alias echost=&#39;cd /d/workspace/solup/echost&#39; alias 12r=&#39;cd /d/workspace/solup/12r&#39; alias private=&#39;cd /d/workspace/private&#39; alias ..=&#39;cd ..&#39; alias ..2=&#39;.. &amp;&amp; ..&#39; alias ..3=&#39;..2 &amp;&amp; ..&#39; # some more ls aliases #alias ll=&#39;ls -alF&#39; alias la=&#39;ls -A&#39; #alias l=&#39;ls -CF&#39; # Add an &quot;alert&quot; alias for long running commands. Use like so: # sleep 10; alert alias alert=&#39;notify-send --urgency=low -i &quot;$([ $? = 0 ] &amp;&amp; echo terminal || echo error)&quot; &quot;$(history|tail -n1|sed -e &#39; &#39;&#39;s/^ s*[0-9] + s*//;s/[;&amp;|] s*alert$//&#39; &#39;&#39;)&quot;&#39; # for python alias python=&#39;python3&#39; alias pip=&#39;pip3&#39; export WORKON_HOME=~/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=&#39;/usr/bin/python3&#39; # Usage of python3 source ~/.local/bin/virtualenvwrapper.sh # for pyenv export PYENV_ROOT=&quot;$HOME/.pyenv&quot; export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot; export PYTHON_CONFIGURE_OPTS=&quot;--enable-shared&quot; export PYENV_VIRTUALENV_DISABLE_PROMPT=1 if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then eval &quot;$(pyenv init -)&quot; eval &quot;$(pyenv virtualenv-init -)&quot; fi . | . | .",
            "url": "blog.chojaeseong.com/git/2021/10/16/%EA%B9%832_%EA%B9%83%EA%B8%B0%EB%B3%B8(vscode)_%EA%B9%83%EC%8B%AC%ED%99%941(vscode)_%EA%B9%83%EC%8B%AC%ED%99%942(%EA%B0%9C%EB%85%90).html",
            "relUrl": "/git/2021/10/16/%EA%B9%832_%EA%B9%83%EA%B8%B0%EB%B3%B8(vscode)_%EA%B9%83%EC%8B%AC%ED%99%941(vscode)_%EA%B9%83%EC%8B%AC%ED%99%942(%EA%B0%9C%EB%85%90).html",
            "date": " • Oct 16, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "기본1) commit or Tag로 이동 + 돌아가기&되돌리기+ 브랜치 작업",
            "content": "타인repo를 clone후 commit, tag 코드 옮겨다니기 . 실습레포: /home/is2js/workspace/git-test | Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . commit_hash or tag로 점프: git checkout [hash or tag] . 환경변수를 파악하고 code . . | vscode로 리조지토리 초기화 . | vscode push 버튼으로 올리기 . . | git fetch는 해두는 게 좋다 . 내 repo에 누가 작업을 추가했는지 파악만 해주는 것 | . | 강의별로 commit을 한다면? . 커밋별로 tag를 추가로 만들어준다. . | 예를 들어 . 5화 작업 . 5화 커밋 git tag 5 | . | . | 6화 작업 . 6화 커밋 git tag 6 | . | . | push by vscode push버튼 . . | . | . | git checkout [git_id]으로 5화 이전의 4화로 점프띄어보자. . 4화 부분의 git id 복사 . | 해당 폴더의 vscode 터미널에서 git checkout [git_id] . git checkout fefc0cacbf262ae0794e64a632afa2da095b622a . 이때 brunch자체가 [git_id]로 변하면서 과거로 돌아간다 | . | 현재로 돌아오려면, 기존 branch(master)로 checkout한다 . git checkout master . | . | git checkout [tag명]으로 점프띄어보자 . 각 커밋마다 커밋후 쉬운 이름표인 tag를 만들어준다. . 아까 5화 작업 끝나고, git tag 5 . 5화 끝난후의 소스를 보고 싶을 땐 이렇게 이동한다 . #git checkout [tag명] git checkout 5 . . | . | . | 다 참조가 끝났다면, 다시 최근소스의 branch로 오면된다. . git checkout master . | . | tag는 대신 따로 push를 해줘야한다. . 커밋들을 push한거로는 tag까지 push가 안됨. | . git push --tags . 버튼으로는 잘 안보이고 팔레트 &gt; push 검색 &gt; git push tags를 선택해준다. . | 참고) . 맨첨 커밋에는 0.0.0의 tag를 만들어주고 . | 그 이후로는 1.0.0부터 쭉 만들면된다. . . | . | . | . 내 repo 돌아가기, 되돌리기 . 기본 세팅 . /home/is2js/workspace/git-practice | . 소스트리 설치 . vscode에서는 설정(ctrl+,)에서 exclude 검색후 .git을 삭제하여 보이게 하기 | . | 디렉토리에서 vscode열기 . vscode 터미널 열여서 git설정 저장하기 . git config --global user.name &quot;is2js&quot; git config --global user.name &quot;tingstyle1@gmail.com&quot; . | . | .git폴더를 삭제후 소스트리에서 해보기 . create를 통해 해당폴더를 선택해서 만들어준다. 이미 폴더가 있는데 이 내부에 .git생성할까 물어보면 OK | . | . | 2개의 파일을 만들고 이 상태를 저장하기 . cat | mouse | . | git status(gst)를 통해 아직 untracked 파일들 확인 후 add . git add -A . git status . | 메세지(-m)와 함께 묻기(commit 해주기) git commit -m &quot;First commit&quot; . | 묻은 것을 소스트리에서 확인해보기 . 터미널에서 히스토리 확인하기 git log --oneline . | 소스트리는 git status없이 묻을 파일을 자동으로 알려준다. . vscode도 extensiont쪽에 알려줌? | dog라는 파일을 만들고 소스트리에서 확인해서 add + 커밋까지해보자. | . | . | 파일 삭제 + 변경 + 생성을 한꺼번에 한 뒤 git status로 보자. 삭제+변경과 생성을 따로따로 알려주며 다 알려주긴 한다. | 소스트리도 아이콘으로 알려준다. | . | git log로 이때까지 묻은 캡슐들을 한꺼번에 볼 수 있음. 소스트리에서는 History탭에서 보면 된다. . . | 과감한 돌아가기: git reset [commit_hash] –hard . . 돌아갈때는 과감한방법과 신중한방법이 있다. . 과감한방법(--hard) : 복원이후시점은 완전히 지우겠다. . git log상의 commit_id 앞6글자만 복사후 . | git reset [commit_id] --hard . . | . | 다시 한번 cat삭제 + dog이름변경 + 펭귄추가를 해주고 commit한뒤 소스트리로 reset –hard해보자. . 이 커밋까지 현재브린치를 초기화 | Hard(버림) 선택 | . | . | 신중한방법(--soft): 시점만 돌아가고 + 그 이후는 커밋되지 않은 상태로 파일은 유지 . | . (반대동작으로 취소시켜, 돌아갈 미래를 남긴체) 되돌리기 : git revert . **[reset으로 돌아갈 수 있는 미래]를 남겨두기 위해, [반대동작으로 취소시켜] 되돌리기 ** . | 다시 3번째 커밋까지 만들어준다. | 이번에는 돌아갈시점 6자리 for reset이 아닌 취소할 시점 6자리 for revert를 git log에서 찾는다. 취소할 커밋을 revert(취소)했다는 커밋이 그대로 이어서 남는다. 소스트리를 통해 확인하면, 정확히 취소할 커밋이, 커밋시 수행한 동작을 정확히 반대로 수행하여 취소함. | 취소할커밋이 커밋기록으로 남아있으니, reset --hard(이 커밋까지 현재브런치를 초기화)을 통한 해당 커밋으로 과감하게 돌아갈 수도 있다. | . | . | **즉, [reset으로 돌아갈 수 있는 미래]를 남겨두는 [반대동작으로 취소시켜] 되돌리기 ** | . 가장 최근 것을 revert로 취소시켜보자. . git log . 제일 최근시점을 취소시키기 위해, 최근 커밋(현재커밋) 6글자 복붙 | . | git revert [취소시점6자리] + :wq . 커밋메세지 작성화면으로 들어온다. | 여기선 :wq로 나와야 해당 revert 커밋메세지가 전달된다. | . | 3번째 커밋이 취소된 것을 파일이 reset처럼 과거상태로 돌아감을 보면 알 수 있다. . | git log를 확인해보니, 돌아간시점이후로 가 삭제된 것(reset –hard, 과감한 돌아가기)가 아니라 새 커밋이 형성되었다. . 소스트리에서 보아도 3번째 커밋을 상쇄시키는 커밋이 추가로 발생함 | . . 자세히 보면, 소스트리를 통해 확인하면, 정확히 취소할 커밋이, 커밋시 수행한 동작을 정확히 반대로 수행하여 취소함 3번째 커밋(취소할 커밋) 때 한 동작들 | 4번째 커밋인 3번째 커밋을 취소함(revert)를 할때의 동작들 | . | . | revert를 통해 취소할커밋도 reset-hard와 다르게 기록으로 남아있으니 reset을 통해 취소하기 전의 3번째 커밋상태로 과감하게 돌아갈 수도 있다. . . | 소스트리를 통한 revert는 커밋 되돌리기다. . 역시.. (반대동작으로 취소시켜) 되돌리기 = revert . 커밋 되돌리기 == 반대동작을 통해 해당 커밋을 취소시킴 . . | . | . | 내repo branch(평행우주) 만들기 for 기존플젝에 새로운 도전 . 회사 프로젝트를 내가 함부로 수정할 수 없으니 현재 프로젝트에서 다른 시도를 해보고 싶을 때, branch를 만들어 평행우주로 넘어간다. | . | . 평행우주로 이동도:git checkout [브랜] or 더블클릭 in 소스트리 . 브랜치 생성 . 브랜치 : 현 시점에서 2개의 미래로 분기를 시작하겠다. 현 시점과 동일한 상태 그대로 가져가면서 분기함. | . | . #git branch [만들 브랜치명] git branch my-idea . . 확인은 git branch만 . . | . | 브랜치 이동도 git checkout . 과거로 점프갔다오기 : git checkout [commit_id or tag] . 과거로 돌아가기 : git reset –hard or git revert [commit_id] | . | 과거가 아닌 현재-&gt;다른평행우주(branch)로 이동도 git checkout + 브랜치명 . #git checktout [브랜치명]git checktout my-idea . . branch변경해도, 내 파일상태에는 변함이 없음. 현재 상태를 그대로 가지고 평행우주를 만들어서 | . | . | 데이터 변경 후 커밋하기 in my-idea브랜치 . mouse 삭제, dinosaur 추가 . 용이름 둘리 | . | 현 branch에서 커밋하기 . git add -Agit commit -m &quot;Add dino&quot; . . | . | 상사가 부를 땐, 원래 우주로 돌아간다. . 원래 브랜치는 master였다. . 이동 전 . | 이동 후 (파일이 원래대로 돌아옴) . git checkout master . . | . | git을 처음 배울때는 파일이 잘못될까바 불안해서 사용안할 수도 있는데, 앞으로 계속 사용해보자~ . | . | 소스트리에서 다시 해보자. 더블클릭으로도 우주를 왔다갔다 하며 확인할 수 있다. . 브랜치 부분에 my-idea가 추가됨. 여기서 각 브랜치를 더블클릭할 때마다, vscode의 파일도 같이 바뀌더라. | . | 브랜치에서 새 브랜치 따기 . my-idea로 checkout된 상태에서, 상단의 브랜치탭에서 새로 생성해보자. . 이 때, 새 브랜치로 체크아웃을 체크해주면, 자동으로 새 브랜치로 넘어가진 상태가 된다. | . . my-idea에서 파생된 브랜치라 그 상태를 그대로 가져갔다. | . | 브랜치의 브랜치 상태에서, 데이터를 변경후 커밋까지 . cat 이름을 변경:tom to nyang | . . | 연결된 3개의 평행우주에서 상황맞이 . 상사가 master의 내용을 바꾸길 원함. . . 요구 대로 바꿔고, commit한다. . git add -Agit commit -m &quot;EDIT dog name&quot; . . | . | 평행우주에서, 타 브랜치의 base가 되는 branch(여기선 maser)가 한발(commit) 나서게 되면, 분기된 branch가 나눠서 그려진다. . . | 다른 우주(의지를 이은 가장 바깥가지 브랜치)에서 변화 가져오기: [ 받을놈branch이동후] git merge [줄놈branch] . 현재 메인프로젝트 master의 변경내용과는 서로다른 평행우주끼리 다른파일 수정이라면, 브랜치의 브랜치라도 편하게 master로 merge되는 것을 권유할 수 있다. . 아래 내용을 상사에게 권해본다. . my-idea에서 mouse삭제 후 dino 추가했고 | my-idea - my-another-idea에서 cat이름을 변경했는데 이것들을 메인프로젝트에 적용해도될까요? Okay 승인 | . | . . | 2개의 평행우주에서 일어난 일을 master브랜치로 가져야가한다. . 이 때, 브랜치1의 브랜치2는 생성부터 브랜치1의 변화를 그대로 가져와서 생성되므로 브랜치2만 반영시키면 된다. . . | . | . | merge를 위해서는 . 먼저 받는놈 브랜치(master)로 이동(checkout)한 상태여야한다. . git merge [줄놈 브랜치명] | . git checkout mastergit merge my-another-idea . . | 변화를 보니 master의 상사지시 + 평행우주에서 한 것들이 모두 반영되어있다. . master에서의 dog name to 바꾼 것도 반영되어이있지만 | my-another-idea에서의 쥐삭제+용추가 한 것도 동시에 반영된 상태다. | . | . | 확인은 . 소스트리 | vscode git graph가 아니라면 | git log --graph --all --decorate로 확인하란다 git log --graph --oneline정도면 충분할듯? | . | . | reset –hard로 merge전으로 돌아간 후, 소스트리로 merge하기 . 소스트리로 실습하기 위해 merge전으로 돌아가보자. | . merge 직전의 받는놈 브랜치의 가장 마지막 커밋 == merge전 커밋으로 . git reset –hard . | 소스트리: 이 커밋까지 현재 브랜치를 초기화 . . | . | 소스트리로 merge하려면 더 간단한데 받는놈의 branch를 더블클릭해서 이동 | 주는놈 branch를 우클릭 &gt; 현재 브랜치(받는놈 더블클릭 상태)로 my-another-idea(주는놈, 우클리상태) 병합 | . | 나중에는.. 수많은 폴더와 파일을 다뤄야하기 때문에, 기존프로젝트에 새 도전을 하려면 반드시 git branch써야함. | . | 아름답지 않은 merge + conflict후에는 메세지없이 git commit . 원래 merge가 성공하면 git이 자동 add + commit까지 한다. | . bark-wang브랜치 생성후, dog 파일 수정 -&gt; commit . ❯ git branch bark-wang❯ git checkout bark-wangSwitched to branch &#39;bark-wang&#39;❯ git add -A❯ git commit -m &quot;EDIT dog file&quot; . . | 이제 받는놈인 master로 돌아와서 같은 dog파일 수정하자. . ❯ git checkout masterSwitched to branch &#39;master&#39;❯ git add -A❯ git commit -m &quot;EDIT dog file bar warlwarl&quot; . master가 한발짝 나가는 순간부터 분기가 갈라져 보인다. | . | 현재, master 와 bark-wang이 서로 같은 파일을 수정한 상태다. . 아까의 merge는 서로 다른파일이 수정된 상태라 merge가 쉽게 되었다. . | 한번 merge해보자 . ❯ git checkout masterAlready on &#39;master&#39;❯ git merge bark-wangAuto-merging dogCONFLICT (content): Merge conflict in dogAutomatic merge failed; fix conflicts and then commit the result. . . | . | merge시 conflict가 뜨는데 같은 파일을 여러 평행우주에서 수정했기 때문이다. conflic가 없었을 때의 merge는? merge를 자동으로 커밋까지 해주는 커밋메세지 확인이 떴었다. | . | terminal에 안내문이 뜬다 | 소스트리에서는 그래프가 회색으로 연결안되어있으면서 &quot;커밋하지 않은 변경사항&quot;의 상태로 뜬다. | vscode에서는 conflict된 부분을 나눠서 알려준다. | | conflict는 vscode에서 택1해서 지울건 지운 뒤, add후 git commit을 -m 없는 상태로 커밋을 날리면 자동으로 merge 메세지가 뜬다. . accept incoming ~ in vscode | . git add -Agit commit . . conflic후 commit은 메세지없이 git commit만 날리며 알아서 merge 메세지가 미리 작성되어있다. . . | . | 앞으로 다른 브랜치끼리는 같은파일을 수정안하도록 작업하면 merge가 편안해진다. | 다른우주도 1줄로 만들어 통합: git rebase(재배치) . 프로젝트의 성격에 따라 필요한 것을 선택해서 사용하면 된다. . . | 지금은 git log상 2갈래 정도만 나오지만 . 실제로는 엄청나게 많은 줄기가 생기게 된다. . . | . | 딱 1줄로 통합되도록 merge하는 방법이 git rebase다 . 소스트리상으로는 master(받는놈)에서 주는놈(bark-warl) 우클릭 &gt; 재배치(rebase)를 클릭한다. . . | 같은 파일을 건들인 상황이니 똑같이 conflict해결후 add+commit한다. . | 재배치가 끝나면 분기가1 줄로 나타난다. . 브랜치라도 합쳐지는 모양이 아니다. | . . | . | . 다 쓴 브랜치 삭제: git branch -D . rebase는 1줄로 받는놈(masetr)에 통합되어버린다. . 그럼 작업한 branch(주는놈)은 더이상 필요 없을 것이다. . | 대문자로 -D옵션을 준다 | 소스트리는 우클릭으로 바로 할 수 있다. | . ❯ git branch -D bark-wang Deleted branch bark-wang (was 5fefbe0). . ​ . | merge를 통해 분기가 합쳐졌던 branch들도 git branch -D로 삭제하였더니 . 분기 표기는 남아있는데, branch만 사라졌다. | . . | .",
            "url": "blog.chojaeseong.com/git/2021/10/16/%EA%B9%831_%EC%BB%A4%EB%B0%8B%ED%83%9C%EA%B7%B8%EC%9D%B4%EB%8F%99_%EB%8F%8C%EC%95%84%EA%B0%80%EA%B8%B0%EB%90%98%EB%8F%8C%EB%A6%AC%EA%B8%B0_%EB%B8%8C%EB%9E%9C%EC%B9%98.html",
            "relUrl": "/git/2021/10/16/%EA%B9%831_%EC%BB%A4%EB%B0%8B%ED%83%9C%EA%B7%B8%EC%9D%B4%EB%8F%99_%EB%8F%8C%EC%95%84%EA%B0%80%EA%B8%B0%EB%90%98%EB%8F%8C%EB%A6%AC%EA%B8%B0_%EB%B8%8C%EB%9E%9C%EC%B9%98.html",
            "date": " • Oct 16, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "win10에서 Terminal + vscode + Wsl2 + Pyenv작업환경 구성",
            "content": "chocolately로 초기 설치 . 관리자권한 powershell . 초코랫리 겟스타트 -&gt; 인스톨 코드 복붙 | 경고떠도됨. 관리자권한으로 다시 껐다 키기 | . | find pakage에서 terminal 검색후 설치 . choco install microsoft-windows-terminal . | python 3 검색후 3.9 설치 . choco install python3 . | vscode 설치 . choco install vscode . | git 설치 . choco install git . git config –global user.name “2js” . git config –global user.email “1@gmail” . | wsl2 설치 -&gt; 재부팅후 한번 더 실행 (-y -f ??) . choco install wsl2 -y -f . 참고사이트 . | 참고) 정식 가이드로 설치시 해주는 다운로드전 설정 . dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart # WSL 활성화 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart # VM platform 활성화 . | . | 관리자 권한으로 윈도우 가상화해주기 for wsl2 . Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All . bcdedit /set hypervisorlaunchtype auto . | AMD CPU SVM mode 설정 in Bios for ubuntu 실행 . del 로 bios 진입 . | advanced 진입(F7) . | OC(Overclock) 진입 . | advanced cpu configuration 진입 . | SVM node: Enable . 우측상단 X로 저장후 종료하기 | . | . | wsl2용 ubuntu1804 설치 -&gt; ms store에서 설치(choco는 update안된 버전이라고함) . msstore 사용시 ms계정 요구함 ~@hanmail.ent / ~54 | . | 설치 -&gt; 시작 | . | wsl명령어로 우분투 진입 default 계정 및 비번 설정 is2js / | ~213 | . | . | 항상 wsl접속으로 /mnt된 곳이 아니라 cd ~ (linux 홈폴더)를 한 상태에서 code ~/.zshrc 등의 설정을 하자. | Window Terminal 단축키 설정 . vscode와 비슷하게 추가 매핑해준다. . actions 부분에 추가해주면 된다. | . { &quot;command&quot;: &quot;find&quot;, // 검색키 매핑 // &quot;keys&quot;: &quot;ctrl+shift+f&quot;, &quot;keys&quot;: &quot;ctrl+shift+f&quot; }, // 수직분할 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;vertical&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+plus&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;vertical&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;ctrl+ &quot; }, // 수평분할 매핑(추가) //{ &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;horizontal&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+-&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;horizontal&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+0&quot; }, // 탭 끄기 매핑(추가) { &quot;command&quot;: &quot;closePane&quot;, &quot;keys&quot;: &quot;ctrl+w&quot; }, // 포커스key 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;down&quot; }, &quot;keys&quot;: &quot;alt+down&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;down&quot; }, &quot;keys&quot;: &quot;ctrl+alt+down&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;left&quot; }, &quot;keys&quot;: &quot;ctrl+alt+left&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;right&quot; }, &quot;keys&quot;: &quot;ctrl+alt+right&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;up&quot; }, &quot;keys&quot;: &quot;ctrl+alt+up&quot; }, // 창이동 단축키 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 0 }, &quot;keys&quot;: &quot;ctrl+alt+1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 0 }, &quot;keys&quot;: &quot;ctrl+1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 1 }, &quot;keys&quot;: &quot;ctrl+2&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 2 }, &quot;keys&quot;: &quot;ctrl+3&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 3 }, &quot;keys&quot;: &quot;ctrl+4&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 4 }, &quot;keys&quot;: &quot;ctrl+5&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 5 }, &quot;keys&quot;: &quot;ctrl+6&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 6 }, &quot;keys&quot;: &quot;ctrl+7&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 7 }, &quot;keys&quot;: &quot;ctrl+8&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 8 }, &quot;keys&quot;: &quot;ctrl+9&quot; }, // Rename a tab to &quot;Foo&quot; { &quot;command&quot;: { &quot;action&quot;: &quot;renameTab&quot;, &quot;title&quot;: &quot;server&quot; }, &quot;keys&quot;: &quot;f1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;renameTab&quot;, &quot;title&quot;: &quot;jupyter&quot; }, &quot;keys&quot;: &quot;f2&quot; }, . | . Window Terminal 및 wsl2 zsh 세팅 . 터미널에서 설정(ctrl+,) &gt; json파일열기 &gt; ubuntu이름을 wsl2로 바꾸고 . wsl2(ubuntu)의 guid를 복사해서 &gt; defaultProfile key에 넣어 기본 프로필로 설정 | . | Fira code설치후, WindowTerminal 및 vscode-editor + vscode terminal font 변경해주기 . 깃허브 &gt; zip파일 다운후 압축풀고 &gt; ttf 다 설치 . Terminal : 없던 defaults속 fontFace속성을 넣어서 폰트를 설정해준다. . | Vscode : font 검색후, 맨앞에 &quot;Fira code&quot; 추가 후 전체복사 . terminal font 검색 후 복붙 . “Fira code”, Consolas, ‘Courier New’, monospace . | . | . | . | zsh설치(zsh는 root로 설치) . sudo apt update &amp;&amp; upgrade . sudo apt install zsh . | oh my zsh(zsh) 설치 (ohmyzsh부터는 user로 설치?!) . github 들어가서 curl로 설치 명령어 날리기 . sh -c “$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)” . | . | ohmyzsh 플러그인 2개(자동완성, 하이라이팅) 설치 . zsh-syntax-highlighting . git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting . zsh-autosuggestions . git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions . .zshrc에 기입해주기 . code ~/.zshrc . plugin 검색 . plugins=(git) 에 공백으로 추가 해주기 . plugins=(git zsh-syntax-highlighting zsh-autosuggestions) . 나와서 . source ~/.zshrc . | . | p10k(ohmyzsh의 테마) 설치 . 깃허브 에서 ohmyzsh 클릭 후 ohmyzsh 하위폴더로 clone시켜주기 . git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k . | p10k를 zsh의 테마로 설정해주기 . code ~/.zshrc . theme검색후 ZSH_THEME=”robbyrussell”를 . ZSH_THEME=”powerlevel10k/powerlevel10k” . 로 변경 . source ~/.zshrc . | p10k configure 설정이 시작됨 . | . | ls -al 등이 파일명 배경색 직접 변경하기 . cd ~ . code ~/.zshrc . # change filname background color . LS_COLORS=”ow=01;36;40” &amp;&amp; export LS_COLORS . 위 내용 추가 . source ~/.zshrc . | Win-terminal 테마 생성 및 설정해주기 . terminalsplash.com에 들어가서 고른다. . VS code theme를 찾음. 아직 json내부에서 &quot;name&quot;이 없는 상태. | . | &quot;profiles&quot; 밑에 &quot;schemes&quot;에 **name을 추가해주면서 ** custom theme를 등록해야한다. . schemes 에 등록한 뒤, colorScheme로 사용된다 | . &quot;schemes&quot;: [ { &quot;name&quot; : &quot;VScode&quot;, &quot;background&quot; : &quot;#232323&quot;, &quot;black&quot; : &quot;#000000&quot;, &quot;blue&quot; : &quot;#579BD5&quot;, &quot;brightBlack&quot; : &quot;#797979&quot;, &quot;brightBlue&quot; : &quot;#9BDBFE&quot;, &quot;brightCyan&quot; : &quot;#2BC4E2&quot;, &quot;brightGreen&quot; : &quot;#1AD69C&quot;, &quot;brightPurple&quot; : &quot;#DF89DD&quot;, &quot;brightRed&quot; : &quot;#F6645D&quot;, &quot;brightWhite&quot; : &quot;#EAEAEA&quot;, &quot;brightYellow&quot; : &quot;#F6F353&quot;, &quot;cyan&quot; : &quot;#00B6D6&quot;, &quot;foreground&quot; : &quot;#D3D3D3&quot;, &quot;green&quot; : &quot;#3FC48A&quot;, &quot;purple&quot; : &quot;#CA5BC8&quot;, &quot;red&quot; : &quot;#D8473F&quot;, &quot;white&quot; : &quot;#EAEAEA&quot;, &quot;yellow&quot; : &quot;#D7BA7D&quot; }, ], . | wsl2(ubuntu)와 win-terminal or terminal 전에 colorScheme으로 지정해준다. . { &quot;guid&quot;: &quot;{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}&quot;, &quot;name&quot;: &quot;Wsl2&quot;, &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot;, &quot;colorScheme&quot; : &quot;VScode&quot;, }, { // Make changes here to the powershell.exe profile. &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;, &quot;name&quot;: &quot;Windows PowerShell&quot;, &quot;commandline&quot;: &quot;powershell.exe&quot;, &quot;hidden&quot;: false, &quot;colorScheme&quot; : &quot;VScode&quot;, }, . &quot;profiles&quot;: { &quot;defaults&quot;: { // Put settings here that you want to apply to all profiles. &quot;fontFace&quot; : &quot;Fira Code&quot;, &quot;colorScheme&quot; : &quot;VScode&quot;, }, . | . | wsl2 계정 및 폴더 설정 in win10 . 항상 특정유저로 wsl2 진입 . /etc/wsl.conf 없으면 생성 . sudo vi /etc/wsl.confg . [user] default=is2js . | . 윈도우 탐색기에 wsl2경로 네트워크로 만들기 . 윈도우( )탐색기 창에서는 wsl$ 로 우분투로 접속가능하다. config등 경로에서는 //wsl$의 슬래쉬로 사용된다. | 참고) 윈도우탐색기상 wt -d .을 통해, 현재경로에서 윈도우 터미널 열기 | . | . wsl 쉘 킨 상태로 연결유지 | 탐색기 &gt; 내PC 우클릭 &gt; 네트워크 위치 추가 사용자 지정 네트워크 위치 선택 | [인터넷 또는 네트워크주소] 부분에 wsl$입력후 찾아보기 | 원하는 경로선택하기 : 우분투/home/is2js/workspace/ | 원하는 이름 입력 : is2js_workspace | . | 여기서 들어간 뒤 wt -d .로 윈도우 터미널(wsl)을 열면 될듯? | wsl2 ubuntu 기본설정 . 루트 계정 비밀번호 초기화참고 블로그 | 유저계정을 root 화시키기 참고 블로그 usermod -aG sudo [계정명]으로만 주기 | . | . openssl 설치 . sudo apt install openssl . | root의 기본 비밀번호 초기화 . sudo passwd root . # : 관리자 | $ : 일반유저 | . | 유저계정에 root권한부여 (파일3개 수정) . root계정으로 권한설정파일에 유저계정-&gt; root권한부여 . su . vi /etc/sudoers . 아래 root쪽에 내 계정도 추가하기 . # User privilege specification root ALL=(ALL:ALL) ALL is2js ALL=(ALL:ALL) ALL . | . wq! (readonly떠서 강제로 저장후 종료) . | root계정으로 비밀번호설정파일에 유저계정-&gt; root권한부여 . root항목처럼, root:x:0:0:root:/~f로 시작하는 부분에서 앞쪽0 : uid | 뒤쪽0: gid 관리자라면 둘다 0임. | 나는 뒤쪽 그룹id만 0으로줌. | . | . | . vi /etc/passwd . wq! . #is2js:x:1002?:1002?:,,,:/home/is2js:/usr/bin/zsh is2js:x:1002?:0:,,,:/home/is2js:/usr/bin/zsh . | root계정으로 그룹설정파일에 유저계정-&gt; root권한부여 . root가 대장인 0그룹에 추가를 해주면됨 . vi /etc/group . wq! . #root:x:0: root:x:0:is2js . | . | zsh 권한 에러시 . sudo chown -R ${LOGNAME}:staff $HOME . | wsl2-ubuntu 시작계정 설정하기 . powershell 에서 . ubuntu[1804] config --default-user [is2js] . | . | wsl2-ubuntu 시작폴더 설정하기 in WindowTerminal . 터미널의 wsl프로필에다가 옵션을 추가해줌 . 출저 | . &quot;startingDirectory&quot;:&quot; wsl$ Ubuntu-[20.04] home [myskan]&quot; . &quot;guid&quot;: &quot;{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}&quot;, &quot;name&quot;: &quot;Wsl2&quot;, &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot;, &quot;colorScheme&quot; : &quot;VScode&quot;, &quot;startingDirectory&quot;:&quot; wsl$ Ubuntu-18.04 home is2js&quot;, . | 참고 . wsl$ : 탐색기에서 우분투 폴더라도 바로 가기 | . | . | python-&gt;python3 매핑 . 참고블로그 | 더 좋은 블로그 | . Alternatives는 기본 커맨드의 심볼릭 링크를 관리해주는 리눅스 프로그램입니다. 데비안 계열의 리눅스(우분투)에서는 update-alternatives가 제공됩니다. . | 우분투(Ubuntu)를 설치하면 python path가 2.7로 설정되어 있습니다. . 리눅스의 Alternatives를 이용하면 python 버전을 쉽게 변경하고 관리할 수 있습니다. | . ❯ which python /usr/bin/python . python은 /usr/bin/python의 링크인데 | . ❯ ls -al /usr/bin/ | grep python lrwxrwxrwx 1 root root 9 Apr 16 2018 python -&gt; python2.7 lrwxrwxrwx 1 root root 16 Apr 16 2018 python-config -&gt; python2.7-config lrwxrwxrwx 1 root root 9 Apr 16 2018 python2 -&gt; python2.7 lrwxrwxrwx 1 root root 16 Apr 16 2018 python2-config -&gt; python2.7-config -rwxr-xr-x 1 root root 3633000 Feb 28 2021 python2.7 lrwxrwxrwx 1 root root 33 Feb 28 2021 python2.7-config -&gt; x86_64-linux-gnu-python2.7-config lrwxrwxrwx 1 root root 9 Oct 25 2018 python3 -&gt; python3.6 . ❯ ls -al /usr/bin/python lrwxrwxrwx 1 root root 9 Apr 16 2018 /usr/bin/python -&gt; python2.7 . /usr/bin/python 역시 실행파일이 아닌 /usr/bin/python2.7의 링크이다. . | **즉 ** . /usr/bin/python2.7 -&gt; /usr/bin/python -&gt; python | . | . | --config python로 python에 걸려있는 링크를 확인한다. . sudo update-alternatives --config python [sudo] password for is2js: update-alternatives: error: no alternatives for python . alternatives가 없다고 뜨면, 설정을 해줘야한다. | . | --install [symbolic link path(버전을 제외한 공통 경로)] python [real path(버전명시 경로)] [우선순위number]로 여러버전을 등록한다. . #sudo update-alternatives --install /usr/bin/python(버전제외 공통 경로) python(명령어=링크) /usr/bin/python3(버전명시 경로) 10(우선순위) . python2.7 등록 . sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 2 . | python3.6 등록 . 3.6 한개만 등록하고 해당 버전을 선택안해도 python -&gt; python3.6이 걸리도록 하면 된다. | . sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.6 1 . | . | (만약 2개이상 버전 등록했다면) 다시 한번 --config python으로 등록된 버전 확인 및 선택 . sudo update-alternatives --config python There are 2 choices for the alternative python (providing /usr/bin/python). Selection Path Priority Status * 0 /usr/bin/python2.7 2 auto mode 1 /usr/bin/python2.7 2 manual mode 2 /usr/bin/python3.6 1 manual mode Press &lt;enter&gt; to keep the current choice[*], or type selection number: 2 . | **버전을 선택해주면, python의 링크가 특정버전으로 옮겨져있다. ** . ❯ python -V Python 3.6.9 . | pip도 설정해준다. . 1개만 등록하면 pip -&gt; pip3가 될 것이다. | . ❯ sudo update-alternatives --config pip update-alternatives: error: no alternatives for pip . ❯ sudo update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 1 update-alternatives: using /usr/bin/pip3 to provide /usr/bin/pip (pip) in auto mode update-alternatives: warning: not replacing /usr/bin/pip with a lin . ❯ pip -V pip 9.0.1 from /usr/lib/python3/dist-packages (python 3.6) . | 1개만 alternative를 등록해서 python, pip를 default로 3버전으로 지정해주자. | . # pip3 install sudo apt-get update sudo apt-get install -y python3-pip pip3 --version # python3, pip3 alternatives command sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10 sudo update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 1 . python 가상환경 설정 . pip3 &amp; pyenv(격리된 python) 설치 . python3-pip 설치 . sudo apt update &amp;&amp; upgrade sudo apt install python3-pip pip3 -V pip3 --version . | pyenv 설치 . curl https://pyenv.run | bash . WARNING: seems you still have not added &#39;pyenv&#39; to the load path. # See the README for instructions on how to set up # your shell environment for Pyenv. # Load pyenv-virtualenv automatically by adding # the following to ~/.bashrc: eval &quot;$(pyenv virtualenv-init -)&quot; . clone한 pyenv디렉토리를 zshrc에 환경변수(PYENV_ROOT)로 직접지정해줘야한다. . cd ~ # wsl로 정상적으로 열릴려면, /mnt/상태에서 vscode를 열면 안된다. code ~/.zshrc . source ~/.zshrc . | pyenv사용전, 에러를 일으키는 미설치 패키지 다 설치하기 . sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev . | . | pyenv 사용법 . # 설치가능한 python list 확인하기 pyenv install --list # 원하는 python 버전 설치 pyenv install [파이썬버전] # 설치된 파이썬 버전 확인 pyenv versions # 가상환경 만들기 pyenv virtualenvs [파이썬버전] [가상환경명] # 가상환경 시작하기 pyenv activate [가상환경명] # 가상환경 끝내기 pyenv deactivate # 가상환경 목록 확인 pyenv virtualenvs # 가상환경 삭제하기 pyenv uninstall [가상환경명] ### 실사용 pyenv versions pyenv install 3.8.6 pyenv global 3.8.6 # 3.8.6을 pyenv 기본 python으로 지정 . python 저장위치 root -&gt; /root 가 홈폴더 유저의 경우 -&gt; /home/유저명이 홈폴더 | . | ~/.pyenv/ 라는 곳에 versions/폴더에 설치된다. github다. | . | virtualenvwrapper에서도 ~/.pyenv/versions/3.8에서 자동완성후 /3.8.6/bin/python을 이용한다. | . | . | virtualenv &amp; pyenv-virtualenvwrapper(격리된 python으로 가상환경 생성) 설치 . pip3로 virtualenv virtualenvwrapper 2개 패키지 설치 . pip install virtualenv virtualenvwrapper pip3 install virtualenv virtualenvwrapper #에러나므로 --upgrade까지 pip install --upgrade virtualenvwrapper pip3 install --upgrade virtualenvwrapper . | virtualenvwrapper 설정 . # virtualenv 설정 export WORKON_HOME=~/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python # /usr/bin/python3 . | pyenv-virtualenvwrapper 설치 . git clone https://github.com/pyenv/pyenv-virtualenvwrapper.git $(pyenv root)/plugins/pyenv-virtualenvwrapper . pyenv설정 추가 수정 . # pyenv clone후 경로 직접 지정 export PYENV_ROOT=&quot;$HOME/.pyenv&quot; export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot; if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then eval &quot;$(pyenv init -)&quot; fi pyenv virtualenvwrapper_lazy #에러나서 주석처리했다가 다시 풀어줌 . source ~/.zshrc . | virtualenv 추가 설정 . # virtualenv 설정 export WORKON_HOME=~/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python #source /usr/local/bin/virtualenvwrapper.sh source ~/.local/bin/virtualenvwrapper.sh . | . | 실사용 . pyenv install 3.8.6 pyenv versions #~/.pyenv/versions/ 에 격리된 파이썬들 버전명의 폴더에 설치됨. pyenv global 3.8.6 pyenv versions mkvirtualenv goglekaap which python #/home/is2js/.virtualenvs/goglekaap/bin/python deactivate workon # goglegkaap rmvirtualenv goglekaap # pyenv로 만든 python버전을 지정해서 가상환경 생성 mkvirtualenv -p ~/.pyenv/versions/3.8.6/bin/python goglekaap lsvirtualenv # workon이랑 동일한 듯. . # pyenv pyenv install [version] # Python 버전 설치 pyenv versions # 현재 설치된 Python 버전 목록 pyenv global [version] # 전역 Python 버전 변경 #virtualenv wrapper mkvirtualenv [project name] # 프로젝트를 위해 virtualenv 생성 workon [project name] # virtualenv 활성화 deactivate # virtualenv 비활성화 setvirtualenvproject # 현재 디렉토리를 프로젝트의 Home 디렉토리로 설정하기 rmvirtualenv [project name] # virtualenv 삭제 lsvirtualenv # virtualenv 목록 mkvirtualenv [가상환경이름] mkvirtualenv [-p ~/.pyenv/versions/3.8.6/bin/python] [tester(가상환경이름)] #가상환경이름으로 가상환경을 만들어준다. mkvirtualenv test -p [python-path]로 python 버전을 지정해 줄 수 있다. rmvirtualenv [ 가상환경이름] #해당 가상환경을 지운다. workon [가상환경이름] #해당 가상환경으로 진입한다. setvirtualenvproject # &lt;가상환경 진입상태 by workon&gt;에서 프로젝트 디렉토리로 이동 후, 해당 커맨드를 치면 디렉토리&lt;--&gt; 가상환경이 맵핑된다. 그러면 workon커맨드를 치는것 만으로 해당 디렉토리에 이동까지 시켜준다. 아주좋다. cdproject #setvirtualenvproject를 했을 경우, 현재 어디에 있든 해당 커맨드로 프로젝트 디렉토리에 이동이 가능하다. # 예를 들어, 아무폴더에서 workon [가상환경] -&gt; cdproject deactivate #가상환경에서 빠져나온다. . | 참고) path 관련 확인해보기 . python 설치(PATH) 확인 . linux에서는 python + tab, python3 + tab을 통해 깔린 버전을 간접적으로 파악 가능 python3로 자동완성된다면.. python3만 깔린 것 앞으로 모든 명령어 앞에 python+3 | . | . | python3 --help -m [모듈명] : mod로서, library모듈을 script로 실행시키는 옵션 pip, flask, venv 등에서 쓰임. 물론 패키지가 깔린상태여야함. | python3 -m venv [가상환경명] | . | -V : 버전확인 | -c &quot; python코드 &quot; : python코드를 바로 커맨드라인에서 실행함 | . | . win10 환경변수 path로 설치확인 . win+s 에서 환경 변수검색 &gt; 시스템 환경 변수 편집 . | 고급탭 &gt; 환경변수N &gt; 사용자 변수 or 시스템 변수 . 나는 초콜렛리로 설치하였더니 시스템 변수탭에 Path에 설치됨. C: Python39 Scripts : 스크립트 폴더를 더블클릭해서 가보기 | C: Python39 | . | | . | win10 or wsl2 python os모듈로 확인 . import os . | os.environ (dict) . os.environ.get(‘SHELL’) for wsl2 . os.environ.get(&#39;SHELL&#39;) &#39;/usr/bin/zsh&#39; . | . | python path로 실행가능한 python script만들기(앞에 python3 안달아도됨) . which python3 후 경로를 복사해놓는다. . /usr/bin/python3 | . | python 파일의 가장 위에 #! + python경로를 입력한 뒤, python 코드를 작성하면된다. . code calculate.py . #!/usr/bin/python3 def add(x,y): return x+y print(add(2,3)) . 결과물은 print만 되도록한다.(bash실행이라서?) | . | sudo chmod +x calculate.py . | 실행시 calculate.py가 아니라 ./calculate.py로 실행시킨다. . ./calculate.py | 에러 뜨면 sed -i &#39;s/ r$//&#39; calculate.py 실행후 다시 실행 | . | . | .",
            "url": "blog.chojaeseong.com/configuration/2021/10/15/%EC%84%B8%ED%8C%851_%EC%9C%88%EB%8F%84%EC%9A%B0_choco_terminal_wsl2_python.html",
            "relUrl": "/configuration/2021/10/15/%EC%84%B8%ED%8C%851_%EC%9C%88%EB%8F%84%EC%9A%B0_choco_terminal_wsl2_python.html",
            "date": " • Oct 15, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "vscode) python 실행용 tasks.json 기록",
            "content": "VScode . tasks.json . ctrl+shift+B로 python파일 빠르게 출력하기 함. . | 한번 눌러보고 설정&gt;템플릿생성&gt;Others&gt;기록 . | . { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;Project Label&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;python&quot;, &quot;args&quot;: [ &quot;${file}&quot; ], &quot;presentation&quot;: { &quot;reveal&quot;: &quot;always&quot;, &quot;panel&quot;: &quot;new&quot; }, &quot;options&quot;: { &quot;env&quot;: { &quot;PYTHONIOENCODING&quot;: &quot;UTF-8&quot; } }, &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true } } ] } .",
            "url": "blog.chojaeseong.com/configuration/2021/08/24/tasks.html",
            "relUrl": "/configuration/2021/08/24/tasks.html",
            "date": " • Aug 24, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "PT내용 기록.",
            "content": "스트레칭 . 양손꽉지 -&gt; 어깨내리고, 엄지세우고 -&gt; 턱을 위로 당기기 10초 | 양속 뒤로 꽉지 -&gt; 고개 아래로 잡아당기기 10초 | 고개회전+굴곡으로 대각선 아래보기 -&gt; 귀와 후두부사이를 4손가락으로 잡아서 아래로 당겨 승모근 늘이기 | 삼각근 늘려주기 코끼리코자세로 팔꿈치위쪽을 쭈욱 당긴 뒤 | 양쪽 어깨 내리고 | 다시 쭈욱 당기기 | . | 삼두근 늘이기 한손을 머리뒤로 넘기고 | 반대손으로 팔꿈치를 꾹 눌러 잠근다음 | 안쪽으로 쭉 당겨주기 | . | 꽉지끼고 허리 굴곡시켜주기 | 꽉지끼고 허리 측굴 시키기 꽉찌 위로 껴서 몸을 조금 측굴 후 | 엉덩이를 반대편으로 밀어서 완전히 측굴 | . | 허리 돌리기 양쪽방향 | . | 손목, 발목 돌리기 반대손으로 손목을 잡은 상태에서, 손목+발목 10, 반대10초 돌리기 | . | 상완전완 . 2 트라이셉스(케이블)푸쉬 다운 p.26 . . . 25:28분 . 가슴 . 가슴운동하는 이유 : 중력에 의해 앞으로 쏠리는 게 편하여 생기는 라운드솔뎌의 단축된 가슴을 펴준다. . 가슴단축을 펴준다. | 프레임이 커진다. 등운동과 같이해서 크게한다. | 푸쉬업보다 벤치프레스가 가동범위가 크다. | . | . 1-1덤벨(벤치) 프레스 p.83 . . . 1주차, 2~4kg 허리 아픈 환자는 벤치위에 양발을 올린 상태해서 하면 편하다 | . | . 준비 : 허리아치 + 어깨 내림 + 견갑골 양간 잡아주기 bar로 하듯이 잡은 상태로 팔을 편 상태가 시작. | . | 아령은 앞으로 넘어갈 때의 전완에 힘이 들어오는 선에서 | 수직선으로 내려갔다가 그대로 올려줌(모으는 느낌X) 속도는 빠르게 | . | 1-2덤벨 플라이 p.84 . . 가슴을 이완시켜 가슴 안쪽을 채워주는 운동 여성분들의 벌어진 가슴을 모음 | 남성분들은 가슴 볼륨감을 높혀줌 | . | . 허리아치 + 어깨 내림 + 견갑골 양간 잡아주기 | 팔꿈치는 수직으로 내려가고 손등은 땅바닥을 보는 방향으로 내려간다 약간 손목을 틀어주면서 해야하므로 좀 어려웠다. | . | 중력을 이용해서 내려가며 + 덤벨을 몸에서 최대한 멀리 다 피지말고 덤벨을 잡을 수 있게 약간만 전완이 굽어진 상태 | . | 어깨 . 가슴~팔을 중간 근육 | 등 운동할때도 포함되는 중간 근육 등, 가슴 근육을 눌려주는시 가운데서 버티는 역할 | . | . 1-3시티드 덤벨 프레스 p.41 . 덤벨프레스는 허리에 과부하가 가므로 반드시 앉아서(시티드) + 약간은 뒤로 기울인 상태로 등/엉덩이가 닿은 상태로 시행하자. | . . 엉덩이, 등을 딱 붙이고, 가슴 내밀고, 어깨 내린 상태에서 팔을 든 상태에서 시작. 허리통증이 없는 사람도 생기게 되니 주의 | . | 수직으로 내려오되, 이마가 아니라 정수리 라인까지 내려오게 한다. 옆에 거울 보면서 수직으로 해야 어깨로 드는 것. | . | 1-4사이드 래터럴 레이즈(사래레) p. 48 . . . 전면 삼각을 운동시키기 위해, 팔을 약간 내회전한 상태에서 시작한다. | . 대각선으로 올라간다. | 올라갔다가 바로 내려온다. 버티기X s | 대퇴, 둔부 . 2스쿼트 . . . 어깨보다 한발씩 더 벌린 상태로 발 앞꿈치로 땅바닥을 잡는다 생각하여 엉덩이를 뛰로 빼더라도 안넘어지도록 한다. | . | 약간 무릎을 바깥쪽으로 뺀 상태로 만들어 엉덩이에 자극을 주고 내려가면서 무릎은 더 바깥쪽으로 벌어져서 둔부가 자극되도록 해야한다 | 무릎이 앞으로 안나온다는 생각으로 엉덩이를 최대한 뒤로 빼면서 내려간다. | . | 허리 아픈 사람은 더 엉덩이로 보강해야해서 중요함. . | 10개 3~4세트 | . 하체 . 2런지 . . . 발을 골반너비 정도만(스쿼트는 어깨넓이) | 한쪽발을 뒤로 한뼘 | 반대발을 앞으로 그만큼 | 뒷발의 뒤꿈치를 확 올리면 앞으로 넘어간다 -&gt; 그만큼 앞으로 이동 | 중심잡기 힘들면 앞발만 바깥쪽으로 조금 회전시켜줌 | 앞무릎 고정상태에서 뒤꿈치 편상태로 뒷무릎만 내려갔다 올라온다. | 10개 3~4세트 . 복근, 기립근 . 크런치 . 팔꿉치가 앞으로 뻣어나간다고 생각하고 시행 | . 플랭크 . 발을 약간 벌려 앞으로 세우기 | 손의 위치랑 입이랑 위치 바꾸기 | 엉덩이는 계속 들고 있기 | 20초 2~3세트 | 슈퍼맨 운동 . 기립근을 직접적으로 키운다. . 대자로 뻗은 뒤 | 고개는 들지말고 팔과 다리를 들어서 1~2초간 버티고 돌아온다. |",
            "url": "blog.chojaeseong.com/pt/%EC%9A%B4%EB%8F%99/2021/08/23/PT.html",
            "relUrl": "/pt/%EC%9A%B4%EB%8F%99/2021/08/23/PT.html",
            "date": " • Aug 23, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "프로필) github index, badge 등 생성하여 꾸미기",
            "content": "참고사이트 . 참고 사이트 https://velog.io/@woo0_hooo/Github-github-profile-%EA%B0%84%EC%A7%80%EB%82%98%EA%B2%8C-%EA%BE%B8%EB%AF%B8%EA%B8%B0 | https://butter-shower.tistory.com/142 | https://velog.io/@colorful-stars/Github-%ED%94%84%EB%A1%9C%ED%95%84-%EA%BE%B8%EB%AF%B8%EA%B8%B0 | http://blog.cowkite.com/blog/2102241544/ | . | . github_id 이름으로 repo 생성 . github ID와 동일한 이름으로 repo만들기 + add Readme . local에 clone하여 환경 세팅하자. C:/jupyter_blog/ + is2js . . | . | capsule-render로 header/footer 작성 . typora에서 미리보기를 활용하여 header footer를 작성한다. . 각 옵션 목록 : https://github.com/kyechan99/capsule-render . | default(변경하면됨) . ![header](https://capsule-render.vercel.app/api?type=waving&amp;color=f6ebe1&amp;height=150&amp;section=header&amp;text=Data Engineer and KMD&amp;fontSize=50&amp;fontColor=152447&amp;desc=데이터 엔지니어를 꿈꾸는 한의사, 조재성입니다.&amp;descAlignY=80) ![footer](https://capsule-render.vercel.app/api?type=rect&amp;color=152447&amp;height=20&amp;section=footer) . . | . | sheilds.io로 기술 스택 badge작성 . shields.io를 통해 기술스택, 연락처 등의 스택아이콘 가져온다. . a태그 &gt; img태그 . | a태그는 링크주소를 / img는 badge를 여기를 통해서 편하게 가져온다. . 각 뱃지 목록 : https://github.com/alexandresanlim/Badges4-README.md-Profile | . &lt;p align=&quot;center&quot;&gt; &lt;a href=&quot;mailto:tingstyle1@gmail.com&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Gmail-d14836?style=flat-square&amp;logo=Gmail&amp;logoColor=white&amp;link=tingstyle1@gmail.com&quot;/&gt;&lt;/a&gt;&amp;nbsp &lt;a href=&quot;https://www.facebook.com/tingstyle1&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Facebook-1877F2?style=flat-square&amp;logo=facebook&amp;logoColor=white&quot;/&gt;&lt;/a&gt;&amp;nbsp &lt;a href=&quot;https://www.github.com/is2js&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/GitHub-100000?style=flat-square&amp;logo=github&amp;logoColor=white&quot;/&gt;&lt;/a&gt;&amp;nbsp &lt;/p&gt; . | . productive-box로 커밋시각 통계(gist) 노출(pinned)하기 . 참고 : http://blog.cowkite.com/blog/2102241544/ | . gist.github.com에 public으로 신규 public으로 바꾼 gist를 생성 . . | github토큰 생성 페이지로 가서 repo, gist를 포함한 scope를 설정한 뒤, 발급받은 토큰을 잘 챙겨둔다. . QQQghp_ysd0aOZbgsOJ3rOTAhj4QQQw4su6rrfPp1oc7WrQQQ . | productive-box repository를 fork한다. . 우측 상단의 Fork 버튼을 누르면 된다. . | fork 된 나의 repository의 Actions 탭에서 enabled 버튼을 눌러 Action을 활성화한다 . | .github/workflow/Schedule.yml . 파일을 수정하여 환경변수를 작성해준다 . uses: is2js/productive-box@master : 내github아이디로 바꿔준다? . maxam2017 -&gt; 내 아이디로 | . | GIST_ID: 사전 작업의 1번 step에서 생성된 gist의 id (gist URL은 gist.github.com//로 생성되기 때문에 주소창을 보면 된다.) 042e89789d6054e9b372e755e75f09f5 | . | TIMEZONE: 타임존을 적어준다. Asia/Seoul 형식으로 적어주면 된다. cf) cron : 분시일월주 cron예제 : https://ponyozzang.tistory.com/402 | . | . | . | . | 해당레포 &gt; Settings 탭 &gt; Secrets에 접속한 뒤 New repository secret 버튼을 클릭하여 환경변수를 설정해준다. . GH_TOKEN: 사전 작업의 2번 step에서 발급받은 토큰 . 토큰은 github &gt; secrets &gt; 환경변수에서 설정해주면, workflows.config.yaml을 그것을 이용한다. | . env: GH_TOKEN: $ . | . . | gist를 내 프로필 pinn에 고정시킨다. . | 내 블로그에 embed시킨다. . 아래 코드에서 gist주소만 복사해서 gist_id.js를 넣어주면 됨. | . | 깃허브 프로필 뱃지 얻기 . Github Developer program . https://developer.github.com/program/ 사이트에서 등록한다. . 2가지만 추가로 채워주면 된다. . | Highlights부분에 뱃지 생김 . . | . | 학생 PRO . 유효한 date를 포함하는, 학생증 찍어서 증명하는 부분이 생겨 나는 포기함. | . https://education.github.com 접속후 Student Developer Pack 클릭 . | Get pack &gt; Get Student benefits &gt; 아래쪽 학교인증 . github에 학교계정으로 email을 등록하고 와야한다. . . | . | 마지막에 plan을 Github Pro로 적어주면 된다. . | 증명서를 내라고한다. 나는.. 졸업해서 그냥 생략.. . | 북극곰 2020.02월 . 나는 우연히 그 때 만들어뒀나보다. | .",
            "url": "blog.chojaeseong.com/git/github/2021/08/19/github-profile.html",
            "relUrl": "/git/github/2021/08/19/github-profile.html",
            "date": " • Aug 19, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "powershell_vs_bashshell명령어",
            "content": "개요 . 출저 : 유튜브-드림코딩 . | 참고 : 티스토리 리눅스 명령어모음 블로그 . | 나는 Windows Terminal을 다운 받은 뒤, powershell vs wsl에서 실습하였다. . window의 powershell은 alias를 제공하여 unix shell과 비슷한 명령어를 사용할 수 있다. . . | . | 아직 많은 개발자들이 window를 사용함 . . | . powershell 최신버전 설치 . 링크 : https://docs.microsoft.com/ko-kr/powershell/scripting/install/installing-powershell-core-on-windows?view=powershell-7.1 | . 기본 명령어 . man, clear . manual의 약자다. 잘 모를 때 참고하는 명령어 . man man . | Get-Help 명령어를 링크 해놓은 것이다. . | 청소해주는 명령어 . | . man clear clear . 파일 탐색 . pwd(경로 확인) . Print Woring Directory의 약자 | . explorer.exe .(경로상 탐색기열기) . mac에서는 open .을 사용한다. . | explorer가 아니라 explorer.exe .연다. . | . ls [하위폴더] (경로상 파일목록) . list의 약자 . | powershell에서는 mode까지 같이 나오는 반면, . powershell은 ls만 가능하다. ls -l등의 format활용은 X. 처음부터 다 보여준다. . | wsl/mac에서는 파일명만 나온다. . ls -al, ls -atl 등을 활용하면 mode까지 같이 출력된다. | . | . . | . ls . format for WSL2 . ls -l : long의 약자 . . | ls -a : all의 약자 . ui상에서는 보여주지 않는 숨겨진 폴더, 파일을 보여준다. | . . | ls -al : all(숨겨진) + long(mode까지) . . | . format for Powershell . powershell의 ls는 기본적으로 long모드로 보여주는 듯 했다. . | ls -name : 이름만 보고 싶을 때 . mac, wsl의 ls기본과 똑같다. | . | ls -force : 숨겨진 폴더, 파일을 보고 싶을 때 . . | . 폴더이동 . cd [./../-/~] . change directory의 약자 . . : 현재 경로. cd .는 제자리 이동. . | .. : 상위 경로 . | ~ : **현재설정된 사용자의 최상위 폴더 = home 디렉토리 ** . powershell에서도 cd ~를 하면, C: Users 사용자 | wsl에서 cd ~를 하면, root계정 : /root | 특정사용자 : /Users/사용자 | . | . . | - : 직전경로 . powershell은 cd -가 안된다. -&gt; 7.14버전으로 업데이트 해보는 중. . 7버전으로 업데이트하면 된다… . . | 대신, 직전경로 1번만 사용가능하며, 이후 C: 로 이동된다.. . | . | . | . | . 파일, 디렉토리 찾기 . find [경로] -type [f/d] -name “*.*” for shell . 입력한 경로부터 시작하여 하위까지 해당 파일or폴더를 찾는다. . 예시 . 나같은 경우 -type file , -type directory해도 안되길래, f, d로 약어로 넣으니 됬다. | permission denied나니까, 관리자 모드로 접속하자. | . find . -type d -name &quot;*flask*&quot; . find . -type f -name &quot;*.csv&quot; . | . | . get-childitem for powershell . powershell사실상 안된다고 보면 된다. get-childitem -File -Filter &quot;*.txt&quot; -Recurse | . | . 프로그램 설치/설정 위치 . which for shell . 프로그램의 실행경로를 확인한다. . which node which code . | . gcm for powershell . get-command의 약자인 gcd를 이용한다. . | 경로는 창을 키워야 보임 . gcm node gcm code . | . 파일 생성 및 관리 . touch [파일명] (파일생성) . 존재하지 않으면, 파일 생성 | . man touch touch new_file1.txt . 이후 new_file1.txt를 열어 파일 | . new-item [파일명] for powershell . touch의 생성은 powershell에 없다. 하지만 cat, echo는 존재함. | . new-item new_file4.txt cat new_file4.txt . cat [파일] [파일2] (파일내용확인) . touch와 달리, powershell에도 사용가능함(alias존재) . | touch로 생성한 파일의 내용을 빠르게 확인 . 여러 파일을 동시에 쓰면, 붙혀서 string으로 확인됨. | . | . touch new_file2.txt cat new_file2.txt second line# cat new_file1.txt new_file2.txt first line 텍스트 추가second line# . echo “문자열” &gt;(») [파일] (&gt;파일생성+컨텐츠입력/ » 컨텐츠 추가) . 기본사용은 작성한 문자열을 터미널에 출력한다. (터미널에 에코~) 거의 사용안한다. | powershell에서도 사용가능하다. | &gt; [파일명]을 통해 파일생성+해당문자열을 컨텐츠로 넣어줌(덮어쓰기) | . echo &quot;third line&quot; &gt; new_file3.txt cat new_file3.txt third line . echo &quot;third line&quot; &gt; new_file3.txt cat new_file3.txt third line . &gt;&gt; [파일명] : 파일생성+덮어쓰기가 아니라 기존파일에 컨텐츠 append개념이다. | . echo &quot;third line--&quot; &gt;&gt; new_file3.txt cat new_file3.txt third line third line-- . 디렉토리 생성 . mkdir -p [폴더/하위폴더/하하위폴더] . make directory의 약자, 폴더 = 경로를 생성하는 명령어 | powershell 공용 | . mkdir dir1 ls -al . -p 옵션을 주면서 하위폴더들을 /로 연결하여 줄줄이 생성할 수 있다. | . mkdir -p dir2/subdir1/subdir2 ls dir2 subdir1 ls dir2/subdir1 subdir2 . 파일관리 cp/mv/rm . 3가지 다 powershell에서 사용가능 | . cp [파일] [원하는 경로/]or[새파일명] . copy의 약자 | . mv [파일] [원하는 경로/]or[새파일명] (파일이동/이름변경) . 이름바꾸는 것도 mv로 하는구나. . mv new_file2.txt file2.txt ll . | . rm [삭제파일명] / rm -r [디렉토리명] . -r 이라는 recursive옵션을 주면 디렉토리삭제+하위경로도 삭제 2가지 역할을 해주게 된다. 파일삭제는 rm 파일명 | 디렉토리삭제는 rm -r 디렉토리명 | . | . rm new_file4.txt rm -r dir3 . rm [디렉토리] 후 선택 / rm [디렉토리] -Recurse . 이부분 만 shell과 다름. | 그냥 rm하면 경고창(wsl)없이 선택화면이 나온다. 디렉토리를 선택하면됨. | 디렉토리 빠르게 삭제는 -r 옵션을 중간에 주는게 아니라 마지막에 -Recurse powershell에서도 마지막에 -r 줘도 삭제되는 듯 싶다. | . | . Grep (select-string) . Global regular expression print 의약자. . | 파일에서 검색 or *를 활용한 프로젝트 전체폴더에서 검색 . | . grep “검색문자열” [파일명] . grep &quot;line&quot; *.txt file2.txt:second line new_file1.txt:first line new_file3.txt:third line new_file3.txt:third line-- . grep -n : 라인정보 같이출력 . 찾은 것이 몇번째 라인에 있는지까지도 같이 출력 | . grep -n &quot;line&quot; *.txt file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . grep -ni : 대소문자상관없이 검색후 라인정보출력 . -i : intensive 옵션을 주면 대소문자 상관없이 검색하라는 말이다. | . grep -ni &quot;LINE&quot; *.txt file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . grep -nir “문자열” . : 프로젝트최상경로에서 하위끝까지 전체를 검색 . grep -nir &quot;LINE&quot; . ./file2.txt:1:second line ./new_file1.txt:1:first line ./new_file3.txt:1:third line ./new_file3.txt:2:third line-- . select-string [파일명] -pattern “검색문자열” . default로 대소문자상관없이 + 라인정보도 같이 출력된다. . select-string *.txt -pattern &quot;LINE&quot; file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . | . select-string [*, */*] -pattern “검색문자열” . -ni는 자동이고, -r 옵션은 없어서 직접 *와 ,를 연결한 경로를 지정(경로패턴)해줘야 전체 프로젝트 검색이 된다. | . select-string *, */* -pattern &quot;LINE&quot; file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . 대소문자를 구분하고 싶다면, 맨 뒤에 -CaseSensitive옵션을 주면 된다. | . 환경변수 설정 . 모바일, 웹 개발시 환경변수를 설정함 | 내 컴퓨터에서 특정한 키워드가 어떤 일을 하거나 경로를 저장할 수 있게 만드는 것. | . env . 지정한 환경변수 목록을 본다. 사용시에는 앞에 $를 붙인다. . env . | . ls env: . powershell에서 보는 환경변수목록. 사용시에는 $env:를 앞에 붙인다. . ls env: . | . export [대문자_변수명]=”경로or문자열” (환경변수 설정) . 대문자를 사용하고 사이에는 _를 이용하여 구분한다. . mkdir dir1 env # 모든 환경 변수 확인 export MY_DIR=&quot;dir1&quot; . | . $env:[환경변수명] = “경로or문자열” for powershell . $env:MY_DIR = &quot;dir1&quot; . cd $환경변수명 (환경변수 사용) . 환경변수를 터미널 등에서 사용할 수 있다. . cd $MY_DIR pwd . | . cd $env:[환경변수명] for powershell . unset 환경변수명 (환경변수 삭제) . unset MY_DIR env . $env:[환경변수명] = “” . powershell에서 환경변수 삭제는 빈 문자열을 넣어서 없애준다. . $env:MY_DIR = &quot;&quot; ls env: . | .",
            "url": "blog.chojaeseong.com/shell/powershell/windowsterminal/windows/2021/08/18/powershell_and_bashshell.html",
            "relUrl": "/shell/powershell/windowsterminal/windows/2021/08/18/powershell_and_bashshell.html",
            "date": " • Aug 18, 2021"
        }
        
    
  
    
        ,"post13": {
            "title": "단축키) 윈도우 터미널(WindowsTerminal) 단축키 모음",
            "content": "단축키 . [ALT] + [SHIFT] + [+] : 가로 창 나누기 ![image-20210715145754288] | [ALT] + [SHIFT] + [-] : 세로 창 나누기 | [ALT] + [SHIFT] + [방향키] : 창 크기 조절 | [ALT] + [방향키] : 커서가 위치하는 창 전환 | [CTRL] + [L] : 클리어 | [CTRL] + [SHIFT] + [ W] : 창 닫기 | [ALT] + [SHIFT] + [D] : 쉘 복제 | [CTRL] + [+/-/마우스 휠] : 글자 크기 조절 | [CTRL] + [,] : 설정 | .",
            "url": "blog.chojaeseong.com/configuration/windows/windowsterminal/2021/08/18/WindowTerminal_shortcut.html",
            "relUrl": "/configuration/windows/windowsterminal/2021/08/18/WindowTerminal_shortcut.html",
            "date": " • Aug 18, 2021"
        }
        
    
  
    
        ,"post14": {
            "title": "알고리즘 문제 풀기용 array 연습 (python)",
            "content": "input array . 1&#52264;&#50896; list . 10 5 1 10 4 9 2 3 8 5 7 6 . a, b = map(int, input().split()) print(a, b) # 1개는 안된다. 튜플 언패킹시에만 따로 받아진다!! c = map(int, input().split()) print(c) . 10 5 &lt;map object at 0x000001F38F7937C0&gt; . arr = list( map(int, input().split()) ) arr . [1, 10, 4, 9, 2, 3, 8, 5, 7, 6] . 2&#52264;&#50896;(&#44396;&#48516;&#51088;O) . 9 0 0 0 1 1 1 -1 -1 -1 0 0 0 1 1 1 -1 -1 -1 0 0 0 1 1 1 -1 -1 -1 1 1 1 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 1 -1 0 1 -1 0 1 -1 0 -1 1 0 1 -1 0 1 -1 0 1 -1 1 0 -1 0 1 -1 . # - 행수만큼 list comp를 돌리고, # - 그 행의 내부요소들은 1줄을 split -&gt; map(int, ) -&gt; list 까지 만든다. N = int(input().strip()) # paper = [ for i in range(N)] paper = [ list(map(int, input().strip().split())) for i in range(N)] . paper . [[0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, -1, 0, 1, -1, 0, 1, -1], [0, -1, 1, 0, 1, -1, 0, 1, -1], [0, 1, -1, 1, 0, -1, 0, 1, -1]] . 2&#52264;&#50896; &#44396;&#48516;&#51088;X (&#49707;&#51088;&#47196; 1character&#50473;&#47564; &#52264;&#51648;) . 문자열(no split) -&gt; map(1글자를 1글자int로) -&gt; list(1글자들을 열로) | . 3 3 011 111 110 . list(&#39;1019&#39;) . [&#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;9&#39;] . list(map(int, &#39;1019&#39;)) . [1, 0, 1, 9] . # - split대신 list(&#39;문자열&#39;) -&gt; 1글자씩 list # - split대신 list( map(int, &#39;문자열&#39;)) -&gt; 숫자1개씩 list # -- map(int, &#39;문자열&#39;)은 문자열을 하나씩 쪼개받아서 int를씌운다. N, M = map(int, input().split()) # map은 튜플로 할당 받을 수 있다. but 1개 변수에 할당시는 맵객체다. # MIRO = [ for i in range(N) ] # 열은 갯수는 M대신 split이 아닌 문자열-&gt;map-&gt;list -&gt; list(map(())으로 쪼개서 받았다. MIRO = [ list(map(int, input())) for i in range(N) ] . MIRO . [[0, 1, 1], [1, 1, 1], [1, 1, 0]] . &#49440;&#50616; array . input으로 받아서 쪼개서 열을 만들지말고, 이번에는 직접 선언해보자. | numpy를 지원하지 않을 때, 리스트로 만드는 n차원 배열이다. | . INIT = -1 # 각 행렬 요소의 초기화 값이다. W = row = N H = column = M C = channel = 3 B = batch = 3 # 1차원 array : 초기화값이 요소 상태로 list comp D1 = [ INIT for _ in range(W)] # 1차원은 행길이만큼 list comp + [] X -&gt; 행길이만큼 요소롤 복제하도록 list comp + 요소 # D1 = [ INIT ] * N # 요소복제의 2번째 방법, list든 str든 곱하면 extend된다. # - but 내부 list comp 요소 + 외부 [] 그만큼 곱은 주의한다. id가 동일한놈들이 복사된다. # 2차원 array : 행[]들 먼저 행길이만큼 list comp돌고 , 내부 1row를 요소 list comp # D2 = [ [] for _ in range(H)] D2 = [ [ INIT for _ in range(W) ] for _ in range(H)] # 3차원 array : 2차원 밖에 [[]]행렬 갯수만큼 list comp 해줌. D3 = [[[ [ INIT for _ in range(W) ] for _ in range(H)]] for _ in range(C)] # 3차원 array : 2차원 밖에 [[]]행렬 갯수만큼 list comp 해줌. D4 = [[[[ [ INIT for _ in range(W) ] for _ in range(H)]] for _ in range(C)] for _ in range(B)] print(D1) print(D2) print(D3) print(D4) . [-1, -1, -1] [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]] [[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]] [[[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]], [[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]], [[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]]] . 2&#52264;&#50896; &#51025;&#50857; by range . INIT값이 아닌 1부터 순서대로 채운 N*N 행렬 range( , , 열길이)를 이용한다. N씩 건너뛰어서 가니까... | 시작은 1부터 n(n-1) + 2 로 1부터 n-1까지의 합으로 간다? | . | . 1&#48512;&#53552; &#49692;&#49436;&#45824;&#47196; &#52292;&#50868; (N,N)&#54665;&#47148; . 각행의 첫째항을 등차수열(column : N개) 를 이용해서 만들어준다. . 1부터 N의 등차수열 range(1, , N)과 끝값은 N번째항 뽑은 것 + 1 을 넣어준다 | An = a1 + (n-1)d = 1 + n(n-1) -&gt; range( , n*n-1 + 1, ) | . | 각 행렬의 첫째항부터 1씩 증가하여 N개를 채운 행list를 완성한다. . | # - 일단 1 ~ n*(n-1)/2 에서 마지막항의 의미는 그냥 찍어보면 모른다. n = 6 for i in range(1, n*(n-1)+2, n): print(i) print(n*(n-1)+2) . 1 7 13 19 25 31 32 . # - for문 안의 i가 1에서부터 **등차(k)수열**이 되어버림. # 1부터, 등차가 n이면, n열짜리 행1개를 건너띈 다음 행 첫째항이 된다. # 열의 갯수N을 등차로 하여 일반항을 잡고, 행 N개를 가야하므로 # An = 1 + (n-1)*d = n*(n-1) + 1 이 된다. # 등차수열 range(1, ,n)이 n번째항 까지는 가야하므로, n번째항+1을 넣어준 것이다. for i in range(1, n*(n-1)+2, n): print(i, &quot;&lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다.&quot;) . 1 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 7 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 13 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 19 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 25 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 31 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. . # 2중 list comp는 요소만 노출할 경우, 1차원 행렬밖에 # - list로 만들경우, 각 요소들이 list로.. # - 행단위로 묵어서는 못만든다 -&gt; result = [] for문 이용 n = 5 result = [] for i in range(1, n*(n-1)+2, n): # 첫째항 i, 등차1 의 수열을 1~n항까지 listcomp로 모으기 result.append([ i+(j-1)*1 for j in range(1, n+1)]) result . [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]] . # 행마다 돌면서 row에접근후 인덱싱.. [ row[4:6] for row in paper[4:7]] . [[0, 0], [0, 0], [1, -1]] . def check_valid(matrix): print(&quot;dict상태&gt;&gt;&gt;&quot;, count_dict) if len(matrix) == 1: print(&quot;1개짜리 돌입. matrix &gt;&gt;&gt;&quot;, matrix) # 1개짜리라면.. 넣고 +1 count_dict.setdefault(matrix[0][0], 0) count_dict[matrix[0][0]] +=1 return True paper_0_0 = matrix[0][0] flag = False for i in range(len(matrix)): for j in range(len(matrix)): if paper_0_0 != matrix[i][j]: flag = True break if flag: print(&quot;다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : &quot;,matrix ) N = len(matrix) # 3x3중 1x1 -&gt; 열 3구간 다 check_valid([ row[:N//3] for row in matrix[:N//3]]) check_valid([ row[N//3:(N//3)*2] for row in matrix[:N//3]]) check_valid([ row[(N//3)*2:] for row in matrix[:N//3]]) # 3x3중 2x2 check_valid([ row[:N//3] for row in matrix[N//3:(N//3)*2]]) check_valid([ row[N//3:(N//3)*2] for row in matrix[N//3:(N//3)*2]]) check_valid([ row[(N//3)*2:] for row in matrix[N//3:(N//3)*2]]) # 3x3중 3x3 check_valid([ row[:N//3] for row in matrix[(N//3)*2:]]) check_valid([ row[N//3:(N//3)*2] for row in matrix[(N//3)*2:]]) check_valid([ row[(N//3)*2:] for row in matrix[(N//3)*2:]]) else: print(&quot;다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix:&quot;, matrix) count_dict.setdefault(paper_0_0, 0) count_dict[paper_0_0] += 1 return True count_dict = {} check_valid(paper) . dict상태&gt;&gt;&gt; {} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, -1, 0, 1, -1, 0, 1, -1], [0, -1, 1, 0, 1, -1, 0, 1, -1], [0, 1, -1, 1, 0, -1, 0, 1, -1]] dict상태&gt;&gt;&gt; {} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] dict상태&gt;&gt;&gt; {0: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[1, 1, 1], [1, 1, 1], [1, 1, 1]] dict상태&gt;&gt;&gt; {0: 1, 1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]] dict상태&gt;&gt;&gt; {0: 1, 1: 1, -1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[1, 1, 1], [1, 1, 1], [1, 1, 1]] dict상태&gt;&gt;&gt; {0: 1, 1: 2, -1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] dict상태&gt;&gt;&gt; {0: 2, 1: 2, -1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] dict상태&gt;&gt;&gt; {0: 3, 1: 2, -1: 1} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 1, -1], [0, -1, 1], [0, 1, -1]] dict상태&gt;&gt;&gt; {0: 3, 1: 2, -1: 1} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 4, 1: 2, -1: 1} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 4, 1: 3, -1: 1} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 4, 1: 3, -1: 2} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 5, 1: 3, -1: 2} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 5, 1: 3, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 5, 1: 4, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 6, 1: 4, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 6, 1: 5, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 6, 1: 5, -1: 4} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 1, -1], [0, 1, -1], [1, 0, -1]] dict상태&gt;&gt;&gt; {0: 6, 1: 5, -1: 4} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 7, 1: 5, -1: 4} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 7, 1: 6, -1: 4} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 7, 1: 6, -1: 5} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 8, 1: 6, -1: 5} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 8, 1: 7, -1: 5} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 8, 1: 7, -1: 6} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 8, 1: 8, -1: 6} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 9, 1: 8, -1: 6} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 9, 1: 8, -1: 7} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 1, -1], [0, 1, -1], [0, 1, -1]] dict상태&gt;&gt;&gt; {0: 9, 1: 8, -1: 7} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 10, 1: 8, -1: 7} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 10, 1: 9, -1: 7} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 10, 1: 9, -1: 8} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 11, 1: 9, -1: 8} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 11, 1: 10, -1: 8} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 11, 1: 10, -1: 9} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 12, 1: 10, -1: 9} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 12, 1: 11, -1: 9} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] . print(*map(lambda x:x[1], sorted(count_dict.items(), key=lambda x:x[0]))) . 10 12 11 .",
            "url": "blog.chojaeseong.com/boj/python/array/2021/08/12/python_%EB%B0%B0%EC%97%B4_%EC%97%B0%EC%8A%B5.html",
            "relUrl": "/boj/python/array/2021/08/12/python_%EB%B0%B0%EC%97%B4_%EC%97%B0%EC%8A%B5.html",
            "date": " • Aug 12, 2021"
        }
        
    
  
    
        ,"post15": {
            "title": "파이썬을 파이썬답게 노트정리",
            "content": "&#52636;&#51200; . 파이썬을 파이썬답게 실습강의를 듣고 느낀점과 함께 풀어낸 노트입니다. | . &#44277;&#48512; &#51060;&#50976; . 정수를 담은 이차원 리스트, mylist 가 solution 함수의 파라미터로 주어집니다. mylist에 들은 각 원소의 길이를 담은 리스트를 리턴하도록 solution 함수를 작성해주세요. . 제한 조건 | mylist의 길이는 100 이하인 자연수입니다. | mylist 각 원소의 길이는 100 이하인 자연수입니다. | . | 위 문제를 아래와 같이 짰다면, 수강해야한다. 나는 list comp로 짬 . | . 아래와 같은 풀이는 c언어 or 자바 풀이임. . | 이것과 같이 짜야함 . | . 용어 설명 iterable: 자신의 멤버를 한 번에 하나씩 리턴할 수 있는 객체입니다. list, str, tuple, dict 등이 여기에 속합니다. | sequence: int 타입 인덱스를 통해, 원소에 접근할 수 있는 iterable 입니다. iterable의 하위 카테고리라고 생각하시면 됩니다. | list, str, tuple이 여기 속합니다. ( dictionary는 다양한 타입을 통해 원소에 접근할 수 있기 때문에 sequence에 속하지 않습니다.) | . | unpacking: 적절한 번역을 찾고 있습니다. | . | . &#51221;&#49688; (2) . &#47787;&#44284; &#45208;&#47672;&#51648; . 문제 설명 숫자 a, b가 주어졌을 때 a를 b로 나눈 몫과 a를 b로 나눈 나머지를 공백으로 구분해 출력해보세요. 입력 설명 입력으로는 공백으로 구분된 숫자가 두 개 주어집니다. 첫 번째 숫자는 a를 나타내며, 두 번째 숫자는 b를 나타냅니다. 출력 설명 a를 b로 나눈 몫과 a를 b로 나눈 나머지를 공백으로 구분해 출력하세요. 제한 조건 a와 b는 자연수입니다. . &#45236;&#54400;&#51060;(list comp) . input_ = &#39;5 3&#39; num_ = input_.strip().split(&#39; &#39;) a, b = [int(x) for x in num_] str(a//b) + &#39; &#39; + str(a%b) . &#39;1 2&#39; . &#45712;&#45184;&#51216; (divmod + unpacking) . divmod는 한번에 목과 나머지를 구한다. //, %보단 느리지만, 갯수가 많을 땐 더 빨라진다고 한다. | 데이터 변환을 list comp전에 map(str, ) map(int, )도 활용해보자. | tuple을 unpacking(콤마할당)을 하면, iterable객체(tuple)이 알아서 나뉜다. | . a, b = map(int, input_.strip().split(&#39; &#39;)) . a . 5 . b . 3 . divmod(a, b) # 순서대로 몫, 나머지를 반환함. . (1, 2) . print(*divmod(a, b)) #unpakcking을 print하면, 각각을 공백으로 나누어서 프린트해준다. . 1 2 . (&#52428;) n&#51652;&#48277;&#51004;&#47196; &#54364;&#44592;&#46108; string&#51012; 10&#51652;&#48277; &#49707;&#51088;&#47196; &#48320;&#54872;&#54616;&#44592; . 문제 설명 base 진법으로 표기된 숫자를 10진법 숫자 출력해보세요. 입력 설명 입력으로는 공백으로 구분된 숫자가 두 개 주어집니다. 첫 번째 숫자는 num을 나타내며, 두 번째 숫자는 base를 나타냅니다. 출력 설명 base 진법으로 표기된 num을 10진법 숫자로 출력해보세요. 제한 조건 base는 10 이하인 자연수입니다. num은 3000 이하인 자연수입니다. 예시 input output 12 3 5 444 5 124 입출력 예 설명 입출력 예 1 3진법으로 표기된 12는 10진법으로 표현하면 5입니다. ( 1*3 + 2 ) 입출력 예 2 5진법으로 표기된 444는 10진법으로 표현하면 124입니다. ( 455 + 4*5 + 4 ) . &#45236;&#54400;&#51060; . num, base = map(int, input().strip().split(&#39; &#39;)) div_sum = 0 for n in sorted(range(0, len(str(num))), reverse=True): k, num = divmod(num, 10**(n)) div_sum += k * (base**(n)) print(div_sum) . &#51221;&#45813; . n진법으로 표기된 string을 10진법 숫자로 변환하기 - int 함수 . 진법 변환 문제는 알고리즘 문제나 숙제로 자주 나오는 유형이지요. 이번 시간에는 n 진법으로 표기된 문자열을 10진법 숫자로 변환하는 방법을 배워봅시다. . 예시) 5진법으로 적힌 문자열 &#39;3212&#39;를 10진법으로 바꾸기 . 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통 사람들은 for 문을 이용해 숫자를 곱해가며 문제를 풉니다. . num = &#39;3212&#39; base = 5 answer = 0 for idx, number in enumerate(num[::-1]): answer += int(number) * (base ** idx) . 파이썬에서는 파이썬의 int(x, base=10) 함수는 진법 변환을 지원합니다. 이 기본적인 함수를 잘 쓰면 코드를 짧게 쓸 수 있고, 또 시간을 절약할 수 있습니다. . num = &#39;3212&#39; base = 5 answer = int(num, base) . &#45712;&#45184;&#51216;(enumerate, int( , base), &#47928;&#51088;&#50676;&#46020; sequence, [::-1]) . 순서가 필요한 list나 문자열은 enumerate를 활용하자. ex&gt; 진법변환 계산 | 뒤에서부터 시작을 꼭 sorted( ,reverse=True)에 집착X iterable전용인 문자열, array, dataframe등을 생각할 때 [::-1]을 활용하자. 문자열도, list처럼 sequence이다. (flatcontainerimmutablemutable) -&gt; 인덱싱으로 꺼꾸로 시작하게 할 수 있다. | . | 파이썬에서는 진법변환함수를 int( , base)로 제공한다. 필요하다면 쓰자. 진법변환시 첫자리부터 하지말고, str()+ [::-1]을 활용해 일의 자리에서부터 풀자 | . | . num = &#39;432&#39; base = &#39;5&#39; # 일의 자리부터 풀어보자. + enumerate로 번호를 줘가면서 풀어보자. num[::-1] . &#39;234&#39; . answer = 0 for idx, number in enumerate(num[::-1]): answer += int(number) * ( int(base) ** (idx) ) answer . 117 . # base진법으로 표기된 string num을 -&gt; 10진법 숫자(int())변환 answer = int(num, base=int(base)) answer . 117 . &#47928;&#51088;&#50676; (2) . &#47928;&#51088;&#50676; &#51221;&#47148;&#54616;&#44592; . 문제 설명 문자열 s와 자연수 n이 입력으로 주어집니다. 문자열 s를 좌측 / 가운데 / 우측 정렬한 길이 n인 문자열을 한 줄씩 프린트해보세요. 제한조건 s의 길이는 n보다 작습니다. (n - s의 길이)는 짝수입니다. s는 알파벳과 숫자로만 이루어져 있으며, 공백 문자가 포함되어있지 않습니다. . &#45236;&#54400;&#51060; . s, n = input().strip().split(&#39; &#39;) n = int(n) space_num = n-len(s) print(s+&#39; &#39;*space_num) print(&#39; &#39;*(space_num//2)+s+&#39; &#39;*(space_num//2)) print(&#39; &#39;*space_num+s) . abc 7 abc abc abc . &#51221;&#45813; . # -&gt; answer =&#39;&#39; 빈 문자열에 공백의 갯수만큼 돌면서(반복작업용for) 누적합으로 공백을 채운다. s = &#39;가나다라&#39; n = 7 answer = &#39;&#39; for i in range(n-(len(s))): answer+=&#39; &#39; answer+=s answer . &#39; 가나다라&#39; . s = &#39;가나다라&#39; n = 7 s.ljust(7) . &#39;가나다라 &#39; . s.center(7) . &#39; 가나다라 &#39; . s.rjust(7) . &#39; 가나다라&#39; . &#45712;&#45184;&#51216;(ljust, center, rjust) . 문자열로 sequence로 빈리스트+for+append대신 빈문자열+for++=누적합작업을 생각하자 for문을 반복작업에 활용하자. | . | python은 문자열의 공백정렬을 위해 문자열+공백으로 n자리를 채워준다. | string.ljust(공백포함 왼쪽정렬될 n자리), string.center(n), string.rjust() | . &#50508;&#54028;&#48307; &#52636;&#47141;&#54616;&#44592; . 입력으로 0이 주어지면 영문 소문자 알파벳을, 입력으로 1이 주어지면 영문 대문자 알파벳을 사전 순으로 출력하는 코드를 짜세요. 예시 1 입력 0 출력 abcd...(중간생략)..xyz . &#45236;&#54400;&#51060; . ord(&#39;a&#39;) . 97 . chr(97) . &#39;a&#39; . chr(122) . str . chr(65), chr(90) . (&#39;A&#39;, &#39;Z&#39;) . answer = &#39;&#39; for i in range(65, 90+1): answer+=chr(i) print(answer) . ABCDEFGHIJKLMNOPQRSTUVWXYZ . num = int(input().strip()) answer = &quot;&quot; if num: # num이 0이면, 소문자로 # ord(&#39;a&#39;) = 97 -&gt; z -&gt;122 for i in range(65, 90+1): answer+=chr(i) else: for i in range(97, 122+1): answer+=chr(i) print(answer) . 1 ABCDEFGHIJKLMNOPQRSTUVWXYZ . &#51221;&#45813; . import string string.ascii_lowercase # 소문자 abcdefghijklmnopqrstuvwxyz string.ascii_uppercase # 대문자 ABCDEFGHIJKLMNOPQRSTUVWXYZ string.ascii_letters # 대소문자 모두 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ string.digits # 숫자 0123456789 . &#39;0123456789&#39; . num = int(input().strip()) # answer = &quot;&quot; if num: # num이 0이면, 소문자로 # ord(&#39;a&#39;) = 97 -&gt; z -&gt;122 #for i in range(65, 90+1): # answer+=chr(i) print(string.ascii_uppercase) else: #for i in range(97, 122+1): # answer+=chr(i) print(string.ascii_lowercase) # print(answer) . 1 ABCDEFGHIJKLMNOPQRSTUVWXYZ . &#45712;&#45184;&#51216;(str.lower(), upper() -&gt; string&#49345;&#49688;, string&#47784;&#46280;.ascii_ , string&#47784;&#46280;.digits, ) . string모듈이란 것이 따로 있고, 소문자모음, 대문자모음, 소-&gt;대문자모음, 숫자모음을 상수로 제공한다. string.ascii_lowercase # 소문자 abcdefghijklmnopqrstuvwxyz | string.ascii_uppercase # 대문자 ABCDEFGHIJKLMNOPQRSTUVWXYZ | string.ascii_letters # 대소문자 모두 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ | string.digits # 숫자 0123456789 | . | 다른 사람 풀이를 보고선 chr(), ord()를 안써도되고 | 소문자만 or 대문자만 작성해서 str.lower() / str.upper() 메소드도 활용하자. | . | . iterable &#45796;&#47336;&#44592; (4) . Iterable이란? 자신의 멤버를 한번에 리턴할 수 있는 객체입니다. ex) list, str, tuple, dictionary 등 | . &#50896;&#48376;&#51012; &#50976;&#51648;&#54620;&#52292;, &#51221;&#47148;&#46108; &#47532;&#49828;&#53944; &#44396;&#54616;&#44592; - sorted . 파이썬의 sort() 함수를 사용하면 리스트의 원소를 정렬할 수 있습니다. 이때, sort 함수는 원본의 멤버 순서를 변경하지요. 따라서 원본의 순서는 변경하지 않고, 정렬된 값을 구하려면 sort 함수를 사용할 수 없습니다. . 이런 경우는 어떻게 해야 할까요? . 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통 사람들은 deep copy와 sort 함수를 이용합니다. . list1 = [3, 2, 1] list2 = [i for i in list1] # 또는 copy.deepcopy를 사용 list2.sort() . 파이썬에서는 파이썬의 sorted를 사용해보세요. 반복문이나, deepcopy 함수를 사용하지 않아도 새로운 정렬된 리스트를 구할 수 있습니다. . list1 = [3, 2, 1] list2 = sorted(list1) . &#45712;&#45184;&#51216; - (copy.deepcopy() -&gt; sort() &#50752; sorted() ) . sort()함수는 객체 직접 변환을 하니, &lt;같은값 할당은 shallow copy지만&gt; copy.deepcopy()이후 sort()를 한다고 한다. | sorted()는 새로운 정렬 list를 바로 반환한다. 그 인자로는 reverse=True, key=len, key=str.lower, key=lambda 등 정렬기준을 만드는 함수를 인자로 넣을 수 도 있다. | . | . (&#52428;) 2&#52264;&#50896; &#47532;&#49828;&#53944; &#46244;&#51665;&#44592; ( transpose&#47928;&#51228;, &#50612;&#47140;&#50880; ) . 다음을 만족하는 함수, solution을 완성해주세요. solution 함수는 이차원 리스트, mylist를 인자로 받습니다 solution 함수는 mylist 원소의 행과 열을 뒤집은 한 값을 리턴해야합니다. 예를 들어 mylist [[1, 2, 3], [4, 5, 6], [7, 8, 9]]가 주어진 경우, solution 함수는 [[1, 4, 7], [2, 5, 8], [3, 6, 9]] 을 리턴하면 됩니다. 제한 조건 mylist의 원소의 길이는 모두 같습니다. mylist의 길이는 mylist[0]의 길이와 같습니다. 각 리스트의 길이는 100 이하인 자연수입니다. . &#54400;&#51060;2&#44032;&#51648;(&#51221;&#52376;&#44592;&#49885;i&gt;j, &#48712;_list [i]&#54665;&#44284; for j &#44592;&#51316;list[j][i]&#50676;&#51012; &#54620; &#49464;&#53944;&#47196; ) . mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] mylist[::-1] # 1x1 -&gt; 1 # 2x2 -&gt; 3 # 3x3 -&gt; 5 # nxn -&gt; 2n-1 line # 각 k in 2n-1 마다.. # k=1, -&gt; 길이 1 0.0 # k=2, -&gt; 길이 2 1.0 0.1 # k=3, -&gt; 길이 3 2.0 1.1 0.2 # k=4, -&gt; 길이 2 # k=5, -&gt; 길이 5 # gg . [[7, 8, 9], [4, 5, 6], [1, 2, 3]] . # 타 문제에서는 각 행마다 길이가 같다는 보장이 없기 때문??? 이번 강의에서는 zip 함수를 이용해 2차원 배열을 뒤집는 방법을 알아봅시다. 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통은 다음과 같이 2중 for 문을 이용해 리스트의 row와 column을 뒤집습니다. . [[]]*4 . [[], [], [], []] . [[]]*len(mylist) . [[], [], []] . &#45712;&#45184;&#51216;( &#51221;&#52376;&#44592;&#49885;, new_list&#51032; &#54665;i == mylist&#51032; &#50676;i&#47196; &#44256;&#51221;&#49884;&#53020;, j&#47484; &#46028;&#47536; &#49345;&#53468;) . 2중 for문으로 행렬을 뒤집으려면, 빈 list -&gt; 빈 list의 [i]행 고정상태에 append ( mylist [행을 j로 돌리면서] [열은 i열로 고정]시켜서 뽑아낸 것들 ) . 새 list의 i행과 기존 list의 i열을 동일시 하면서 기존 list의 i열 값들을 뽑아내기 위해 j를 돌리면서 append한다. | . | 정처기식으로, i, j가 돌아가는데, 행렬 중에 i&gt;j 부분만 찾아서 한쪽만 swap . | mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] new_list = [[], [], []] for i in range(len(mylist)): for j in range(len(mylist[i])): new_list[i].append(mylist[j][i]) new_list . [[1, 4, 7], [2, 5, 8], [3, 6, 9]] . mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # new_list = [[], [], []] # new_list = [[]]*3 # 주의! 안에 요소가 콤마로 붙는다고 해서 list바깥에서 *3 하지말 것. id똑같은놈들임. # new_list = [[] for x in range(len(mylist))] for i in range(len(mylist)): for j in range(len(mylist)): if i &gt; j: mylist[j][i], mylist[i][j] = mylist[i][j], mylist[j][i] mylist . [[1, 4, 7], [2, 5, 8], [3, 6, 9]] . (&#52428;) 2&#52264;&#50896; &#47532;&#49828;&#53944; &#46244;&#51665;&#44592; - &#11088;&#65039;zip&#11088;&#65039; . &#54400;&#51060; . mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] new_list = list(map(list, zip(*mylist))) . &#45712;&#45184;&#51216;( zip(*&#47588;&#54609; 2&#52264;&#50896; &#47532;&#49828;&#53944;) -&gt; &#44033; &#54665;&#46308;&#47560;&#45796; 1&#44060;&#50473; &#48977;&#50500; tuple&#47196; ) . 행렬(2차원리스트)를 *매핑해서 zip()에 던져주면, 각 행들을 zip(a,b,c,...,n_rows)로 판단해서 나눠쓴다. 즉, for문으로 받을 때는 각 행마다 0열요소들 / 1열 요소들 / ... 들이 튜플로 모여서 들어온다. | . | 번역 : zip(*iterables)는 각 iterables 의 요소들을 모으는 이터레이터를 만듭니다. 튜플의 이터레이터를 돌려주는데, i 번째 튜플은 각 인자로 전달된 시퀀스나 이터러블의 i 번째 요소를 포함합니다. | . | 즉, 각 iter들(*매핑리스트시 - 각행들)의 요소를 하나씩 빼와서 튜플형태로 반환한다. i번째 튜플은 각 데이터(행)의 i번째열들의 모아아두었다. | 길이가 다르면, 짧은 데이터를 기준으로 끝난다. | 원래 집은 **zip으로 튜플들을 반환한다. 꼭 튜플 리스트가 아니더라도 2개의 짝을 이룬 튜플요소들이 반환되면 dict로 반환 가능하다. for문에서는 zip이 반환하는 tuple을 언패킹하는 것일 뿐 | . | . print(mylist) #[[*1*, 2, 3], # [*4*, 5, 6], # [*7*, 8, 9]] zip(*mylist) . [[1, 2, 3], [4, 5, 6], [7, 8, 9]] . &lt;zip at 0x1ed8c381800&gt; . list(zip(*mylist)) # 각 행마다 같은 열들을 튜플로 묶어서, 마치 대각선으로 transpose된다. . [(1, 4, 7), (2, 5, 8), (3, 6, 9)] . list(map(list, zip(*mylist))) # zip으로 만들어진 transpose 튜플 리스트를 map으로 각 요소 list로 변환한다. . [[1, 4, 7], [2, 5, 8], [3, 6, 9]] . print(&#39;mylist&#39;, mylist) print(&#39;*mylist&#39;, *mylist) # 함수에 튜플이나 리스트를 매핑해주면, 알아서 나눠서 쓴다는 의미다. # 인자로 대입한다면, 콤마로 나눠서 넣어줘야한다. (튜플, 리스트로 인자대입X) list(zip(*mylist)) . mylist [[1, 2, 3], [4, 5, 6], [7, 8, 9]] *mylist [1, 2, 3] [4, 5, 6] [7, 8, 9] . [(1, 4, 7), (2, 5, 8), (3, 6, 9)] . list1 = [1, 2, 3, 4, 5] list2 = [100, 120, 30, 300] list3 = [392, 2, 33] answer = [] for number1, number2, number3 in zip(list1, list2, list3): print(number1 + number2 + number3) . 493 124 66 . # 짝을 이룬 튜플리스트는 dict로 변환가능하다! animals = [&#39;cat&#39;, &#39;dog&#39;, &#39;lion&#39;] sounds = [&#39;meow&#39;, &#39;woof&#39;, &#39;roar&#39;] # print(list(zip(animals, sounds))) dict(zip(animals, sounds)) . [(&#39;cat&#39;, &#39;meow&#39;), (&#39;dog&#39;, &#39;woof&#39;), (&#39;lion&#39;, &#39;roar&#39;)] . {&#39;cat&#39;: &#39;meow&#39;, &#39;dog&#39;: &#39;woof&#39;, &#39;lion&#39;: &#39;roar&#39;} . (&#52428;) i&#48264;&#51704; &#50896;&#49548;&#50752; i+1&#48264;&#51704; &#50896;&#49548; - zip . 숫자를 담은 리스트 mylist가 solution 함수의 파라미터로 주어집니다. solution 함수가 mylist의 i번째 원소와 i+1번째 원소의 차를 담은 일차원 리스트에 차례로 담아 리턴하도록 코드를 작성해주세요. 단, 마지막에 있는 원소는 (마지막+1)번째의 원소와의 차를 구할 수 없으니, 이 값은 구하지 않습니다. 제한 조건 mylist의 길이는 1 이상 100 이하인 자연수입니다. mylist의 원소는 1 이상 100 이하인 자연수입니다. 예시 mylist output [83, 48, 13, 4, 71, 11] [35, 35, 9, 67, 60] 설명: 83과 48의 차는 35입니다. 48과 13의 차는 35입니다. 13과 4의 차는 9입니다. 4와 71의 차는 67입니다. 71과 11의 차는 60입니다. 따라서 [35, 35, 9, 67, 60]를 리턴합니다. . &#54400;&#51060; . def solution(mylist): return [abs(mylist[i] - mylist[i+1]) for i in range(len(mylist)-1)] . &#51221;&#45813; &#48143; &#45712;&#45184;&#51216; (zip( list, list[1:]) -&gt; &#51064;&#45937;&#49905; i&#50752; i+1&#51032; value&#47484; &#46041;&#49884;&#51217;&#44540; ) . 원래는 for i in n-1까지만 돌기 -&gt; [i], [i+1] | zip( list, 1개 모자란 list[1:] ) -&gt; 2개 요소 value 바로 접근 zip은 짧은 것 까지니까 자동으로 (0,1) &gt; (n-1,n) (n, ) | . | def solution(mylist): answer = [] for number1, number2 in zip(mylist, mylist[1:]): answer.append(abs(number1 - number2)) return answer . &#47784;&#46304; &#47716;&#48260;&#51032; type &#48320;&#54872;&#54616;&#44592; . 문제 설명 문자열 리스트 mylist를 입력받아, 이 리스트를 정수형 리스트로 바꾼 값을 리턴하는 함수, solution을 만들어주세요. 예를 들어 mylist가 [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] 인 경우, solution 함수는 [1, 100, 33] 을 리턴하면 됩니다. 제한조건 mylist의 길이는 100 이하인 자연수입니다. mylist의 원소는 10진수 숫자로 표현할 수 있는 문자열입니다. 즉, &#39;as2&#39; 와 같은 문자열은 들어있지 않습니다. 예시 input output [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] [1, 100, 33] . def solution(mylist): return [ int(x) for x in mylist ] . &#45712;&#45184;&#51216;(map -&gt; &#54632;&#49688;&#47484; &#51064;&#51088;&#47196; or lambda ) . list comp도 되지만, list(map(각 요소에 적용함수, 데이터)) 로 데이터 변형 가능 map( 내장함수 or 실행부없는 함수 or lambda, 데이터) | . | . list1 = [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] list2 = list(map(len, list1)) list2 . [1, 3, 2] . map &#54632;&#49688; &#51025;&#50857;&#54616;&#44592; . 문제 설명 정수를 담은 이차원 리스트, mylist 가 solution 함수의 파라미터로 주어집니다. solution 함수가 mylist 각 원소의 길이를 담은 리스트를 리턴하도록 빈칸을 완성해보세요. hint) 이전 강의에서 배운 map 함수를 활용해보세요 제한 조건 mylist의 길이는 100 이하인 자연수입니다. mylist 각 원소의 길이는 100 이하인 자연수입니다. 예시 input output [[1], [2]] [1, 1] [[1, 2], [3, 4], [5]] [2, 2, 1] . def solution(mylist): answer = list(map(len, mylist)) return answer . Sequence Types &#45796;&#47336;&#44592; (2) . sequence &#47716;&#48260;&#47484; &#54616;&#45208;&#47196; &#51060;&#50612;&#48537;&#51060;&#44592; - join . 문자열 리스트 mylist를 입력받아, 이 리스트의 원소를 모두 이어붙인 문자열을 리턴하는 함수, solution을 만들어주세요. 예를 들어 mylist가 [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] 인 경우, solution 함수는 &#39;110033&#39;을 리턴하면 됩니다. 제한 조건 mylist의 길이는 100 이하인 자연수입니다. mylist의 원소의 길이는 100 이하인 자연수입니다. . my_list = [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] answer = &#39;&#39; for value in my_list: answer += value . my_list = [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] answer = &#39;&#39;.join(my_list) . &#45712;&#45184;&#51216;( &#39;&#39;.join(sequence) &#44284; &#48712;&#47928;&#51088;&#50676; +=&#45572;&#51201;&#54633; append ) . 빈_문자열 = &#39;&#39; for in 빈문자열 += string(빈 문자열의 누적합 append) -&gt; python join | . &#49340;&#44033;&#54805; &#48324;&#52237;&#44592; - sequence&#51032; *&#50672;&#49328; . 문제 설명 이 문제에는 표준 입력으로 정수 n이 주어집니다. 별(*) 문자를 이용해 높이가 n인 삼각형을 출력해보세요. 제한 조건 n은 100 이하인 자연수입니다. 예시 입력 3 출력 * ** *** . n = int(input().strip()) for i in range(1,n+1): print((&#39;*&#39;*i).ljust(n)) . 5 * ** *** **** ***** . n = int(input().strip()) for i in range(1,n+1): print((&#39;*&#39;*i).center(n)) . 10 * ** *** **** ***** ****** ******* ******** ********* ********** . &#54400;&#51060; . 이번 강의에서는 곱셈 연산 *를 통해 문자열을 반복하는 방법을 배웁니다. | . 예시) . &#39;abc&#39;, &#39;abcabc&#39;, &#39;abcabcabc&#39;, &#39;abcabcabcabc ...&#39; 과 같이 . &#39;abc&#39;가 n번 반복되는 문자열 만들기 (my) 일정길이 문자열의 누적합 반복 -&gt; *) | . | [123, 456, 123, 456, 123, ...] 과같이 123, 456이 n번 반복되는 리스트 만들기 (my) 리스트 안에 요소들전체 의 append 반복 -&gt; *) | . | . answer = &#39;&#39; n = 5 for _ in range(n): answer += &#39;abc&#39; print(answer) . abcabcabcabcabc . # - sequence라 * 연산을 희한하게 한다. answer = &#39;abc&#39; * n answer . &#39;abcabcabcabcabc&#39; . n = 3 answer= [123, 456] * n print(answer) . [123, 456, 123, 456, 123, 456] . answer[3]=3 answer . [123, 456, 123, 3, 123, 456] . &#45712;&#45184;&#51216; (sequence * -&gt; string*, list*) . 문자열 * n : 문자열을 누적합해서 += 한 것처럼 반복된다. | list * n : 기존요소들전체 append | . Itertools / Collections &#47784;&#46280; (4) . (&#52428;) &#44273;&#51665;&#54633;(Cartesian product) &#44396;&#54616;&#44592; - product . 이번 강의에서는 iterable으로 곱집합을 구하는 방법을 알아봅니다. | 예시) 두 스트링 &#39;ABCD&#39;, &#39;xy&#39; 의 곱집합은 Ax Ay Bx By Cx Cy Dx Dy 입니다. | . iterable1 = &#39;ABCD&#39; iterable2 = &#39;xy&#39; iterable3 = &#39;1234&#39; for value1 in iterable1: for value2 in iterable2: for value3 in iterable3: print(value1, value2, value3) . A x 1 A x 2 A x 3 A x 4 A y 1 A y 2 A y 3 A y 4 B x 1 B x 2 B x 3 B x 4 B y 1 B y 2 B y 3 B y 4 C x 1 C x 2 C x 3 C x 4 C y 1 C y 2 C y 3 C y 4 D x 1 D x 2 D x 3 D x 4 D y 1 D y 2 D y 3 D y 4 . # itertools.product를 이용하면, for 문을 사용하지 않고도 곱집합을 구할 수 있습니다. import itertools iterable1 = &#39;ABCD&#39; iterable2 = &#39;xy&#39; iterable3 = &#39;1234&#39; print(list(itertools.product(iterable1, iterable2, iterable3))) . [(&#39;A&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;A&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;A&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;A&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;4&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;4&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;4&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;4&#39;)] . itertools.product(iterable1, iterable2, iterable3) . &lt;itertools.product at 0x1ed8c4750c0&gt; . import itertools iter1 = list(&#39;ABCD&#39;) iter2 = &#39;조재성 조재경 조아라&#39;.split(&#39; &#39;) iter3 = &#39;1234&#39; print(itertools.product(iter1)) # 1개의 iter도 받으며, list()로 변환해야 보인다. print(list(itertools.product(iter1))) # 1개의 iter도 받으며, list()로 변환해야 보인다. print(list(itertools.product(iter1, iter2))) # 2개의 iterable객체를 넣은 순간부터, 곱집합 튜플들의 리스트가 나온다. # 2중 for문을 도는 효과다. [ a + b + c for a,b,c in itertools.product(iter1, iter2, iter3)][:5] . &lt;itertools.product object at 0x000001ED8C58A940&gt; [(&#39;A&#39;,), (&#39;B&#39;,), (&#39;C&#39;,), (&#39;D&#39;,)] [(&#39;A&#39;, &#39;조재성&#39;), (&#39;A&#39;, &#39;조재경&#39;), (&#39;A&#39;, &#39;조아라&#39;), (&#39;B&#39;, &#39;조재성&#39;), (&#39;B&#39;, &#39;조재경&#39;), (&#39;B&#39;, &#39;조아라&#39;), (&#39;C&#39;, &#39;조재성&#39;), (&#39;C&#39;, &#39;조재경&#39;), (&#39;C&#39;, &#39;조아라&#39;), (&#39;D&#39;, &#39;조재성&#39;), (&#39;D&#39;, &#39;조재경&#39;), (&#39;D&#39;, &#39;조아라&#39;)] . [&#39;A조재성1&#39;, &#39;A조재성2&#39;, &#39;A조재성3&#39;, &#39;A조재성4&#39;, &#39;A조재경1&#39;] . &#45712;&#45184;&#51216;( itertools.product(iter1, 2, 3) -&gt; &#51473;&#52393;for &#48152;&#48373;&#51012; &#51228;&#44144; + &#49692;&#49436;&#45824;&#44032; &#51221;&#54644;&#51652; &#51312;&#54633;&#51060;&#45796;.) . itertools.product의 결과물은 list()를 씌워야 튜플 리스트로 들어온다. 1개의iter를 넣어도 (a, ) (b, )의 튜플형태로 받는다. | . | zip은 i, i+1, 같은 위상의 iter들을 동시에 받거나 *2차원리스트 등을 받아서 -&gt; 1차원으로 동시에 처리 itertools.product는 for iter1, for iter2처럼, 누적해서 곱집합을 처리한다. | . | 문자열도 iter로 인식하여 한 문자씩 돌아간다. | . (&#52428;) 2&#52264;&#50896; &#47532;&#49828;&#53944;&#47484; 1&#52264;&#50896; &#47532;&#49828;&#53944;&#47196; &#47564;&#46308;&#44592; - from_iterable . &#45236;&#54400;&#51060;(no pythonic) . def solution(mylist): answer = [] for list_ in mylist: for li in list_: answer.append(li) return answer . my_list = [[1, 2], [3, 4], [5, 6]] [ li for list_ in my_list for li in list_ ] . [1, 2, 3, 4, 5, 6] . &#51221;&#45813; . # 빈리스트[]에 +로 &lt;&lt;괄호떼고&gt;&gt;누적합으로 이어붙이기 . my_list = [[1, 2], [3, 4], [5, 6]] answer = [] for element in my_list: answer += element answer . [1, 2, 3, 4, 5, 6] . sum(my_list, []) . [1, 2, 3, 4, 5, 6] . print(itertools.chain.from_iterable( my_list ) ) list(itertools.chain.from_iterable( my_list ) ) . &lt;itertools.chain object at 0x000001ED8C79CE20&gt; . [1, 2, 3, 4, 5, 6] . # itertools.chain()은 여러 1차 iterable(1글자씩조합-문자열 or list 등)을 분해해서 # -&gt; 통합한 1차 iterable을 만든다. list(itertools.chain(&#39;ABC&#39;, [&#39;abc&#39;,2,3], &#39;F&#39;)) . [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;abc&#39;, 2, 3, &#39;F&#39;] . list(itertools.chain(my_list)) list(itertools.chain(*my_list)) . [1, 2, 3, 4, 5, 6] . 파이썬 * 의 사용 (https://mingrammer.com/understanding-the-asterisk-of-python/) 곱셈 및 거듭제곱 연산으로 사용할 때 | 리스트형 컨테이너 타입의 데이터를 반복 확장하고자 할 때 | 가변인자 (Variadic Arguments)를 사용하고자 할 때 -&gt; 인자시 패킹(내부에서는 *떼고 묶어서 써줘) | 컨테이너 타입의 데이터를 Unpacking 할 때 -&gt; 사용시언패킹(알아서 쪼개줘) | . | . from functools import reduce primes = [2, 3, 5, 7, 11, 13] def product(*numbers): p = reduce(lambda x, y: x * y, numbers) return p product(*primes) # product() 함수가 &lt;이미 내부에서&gt; 가변인자를 받고 있기 때문에, # 실제 입력시에는 콤마로 언패킹상태로 리스트의 데이터를 모두 unpacking하여 함수에 전달해야한다. # -&gt; 인자가 패킹하고있다면, 실제 대입은 콤마, , ,로 나눠서 주던지 *iterable로 알아서 처리하라고 넘겨주면 된다. # 30030 product(primes) # XXXXXXXXXX -&gt; 콤마로 줘야할 곳을 list로 주고 있다. *list로 하면 콤마로 알아서 입력해줘다. # [2, 3, 5, 7, 11, 13] . [2, 3, 5, 7, 11, 13] . list(itertools.chain.from_iterable( my_list )) . [1, 2, 3, 4, 5, 6] . from functools import reduce reduce(lambda x, y: x+y, my_list) from operator import add reduce(add, my_list) . [1, 2, 3, 4, 5, 6] . &#45712;&#45184;&#51216;( 2&#52264;&#50896; : [ ] for += &#44292;&#46524;&#51060;&#50612;&#48537;&#51060;&#44592; / sum( , start =[ ]) / &#54620;&#44732;&#54400; : itertools.chain(*)&#44284; &#51088;&#46041; 2&#44732;&#54400;: chain.from_iterable() / reduce(lambda x,y:x(list)+(new_list), &lt;--2&#52264;&#50896;&#47532;&#49828;&#53944;) . 가장 단순하게 2중 for문 or 2중 list comp로 element까지 가는 것 | 비 파이썬이라도 빈_list[ ]에 for문 1개의 list element에서 append가 아닌 빈_list += 괄호떼고 이어붙이기 | 내장sum(iter)함수에 , start=값을 default 0이 아닌 빈 []에다가 iter각 요소(2차원-&gt;1차원 리스트들)누적되도록 ! sum(iter , start = [] ) | itertools.chain( 1차원or문자열 iterable1 , iter2, ... ) -&gt; 문자열은 1개씩 풀어서, list는 element단위로 풀어서 1차원 iterable로 통합 itertools.chain()은 여러 1차 iterable들을 각각 분해하여 각각 한꺼풀만 벗겨, 통합한 1차 iterable을 만든다. | 2차원을 넣으면 그대로 2차원 반환됨. 한 꺼풀만 벗겨서 다시 통합하므로 -&gt; chain(*2차원)으로 사용시언패킹 시켜주자 | . | %timeit 결과를 보면 sum()함수만 끔찍하게 느리고 나머지 셋은 고만고만함을 알 수 있다. 성능과 가독성 중 무엇을 중시하냐의 차이지만 개인적으로 itertools.chain() 자체도 가독성이 나쁘다고 볼 수 없기에 sum()보다는 chain()을 쓰지 않을까 싶다. | . reduce도 각 데이터 요소들이 와서 연산하는데 lambda로 +연산 or operator.add를 사용해서 list들이 += 누적합이 되도록 해주면 된다. | from itertools import permutations sorted(list(permutations([2, 1,3], 2))) . [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] . (&#52428;) &#49692;&#50676;&#44284; &#51312;&#54633; - combinations, permutations . 문제 설명 숫자를 담은 일차원 리스트, mylist에 대해 mylist의 원소로 이루어진 모든 순열을 사전순으로 리턴하는 함수 solution을 완성해주세요. 제한 조건 mylist 의 길이는 1 이상 100 이하인 자연수입니다. 예시 mylist output [2, 1] [[1, 2], [2, 1]] [1, 2, 3] [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] . from itertools import permutations sorted(list(permutations([2, 1,3],2))) . [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] . &#54056;&#53412;&#51648; &#50630;&#51060; &#49692;&#50676; &#44396;&#54788;( &#54532;&#47196;&#44536;&#47000;&#47672;&#49828; while. &#50612;&#47140;&#50880;) . # # - 자기자신의 index와 value가 같아지는 순간까지만 반복되다가, 다음 index로 넘어가서 반복된다. # # - index가 더크면, 값+1 index 초기화후 # # - 값이 더크거나 같으면, &lt;인덱스+1&gt; 값 초기화 # # my) 값을 인덱스랑 같아질때까지 늘려주는데, 값 증가시 그때마다 i=0부터 시작.. -&gt; 같아지면 index+1 값은 0 # # my) index가 n-1까지 = arr갯수까지만 시행. # # - 그럼, 0` [0`,0] -&gt; `1 [0,`0] -&gt; `0 [`0,1] -&gt; `1 [0, `1] -&gt; 2 [0, 0] -&gt; 조건위배 while중지 # def permute_first(arr): # result = [arr[:]] # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c, arr, result) # # 1. i번째 데이터가 자기 순서(i)보다 값이 작다? 1증가시키고, 처음부터 돌려라. # if c[i] &lt; i : # c[i] +=1 # 값을 +1 # i = 0 # index를 0부터 다시 시작. # # 2. i번째 데이터가 자기 순서(i)보다 크거나 같다? 값을 초기화시키고, 다음 index순서로 넘어가라 # else: # c[i] = 0 # i+=1 # permute_first([0,0]) . # # my) 값을 인덱스랑 같아질때까지 늘려주는데, 값 증가시 그때마다 i=0부터 시작.. -&gt; 같아지면 index+1 값은 0 # # my) index가 n-1까지 = arr갯수까지만 시행. # # - 그럼, 0` [0`,0] -&gt; `1 [0,`0] -&gt; `0 [`0,1] -&gt; `1 [0, `1] -&gt; 2 [0, 0] -&gt; 조건위배 while중지 # # 3. 인덱스가 짝수면, arr[0]번째 값과 해당 index값 arr[i] swap한다. # def permute_two(arr): # result = [arr[:]] # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c[i], c, arr) # if c[i] &lt; i : # # 3. 인덱스가 짝수면, 원본 0번째 값 현재(짝수번째) 값을 교환. # if i % 2 ==0: # arr[0], arr[i] = arr[i], arr[0] # c[i] +=1 # i = 0 # else: # c[i] = 0 # i+=1 # permute_two([0,1,4]) . # result = [arr[:]] # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c[i], c, arr) # if c[i] &lt; i : # # 3. 인덱스가 짝수면, 0번째 값과, 짝수번째 값을 교환. # if i % 2 ==0: # arr[0], arr[i] = arr[i], arr[0] # # 4. 인덱스가 홀수면, [c list의 i번째 값]을 index로 넣고, 데이터 홀수번재 값을 교환 # else: # arr[c[i]], arr[i] = arr[i], arr[c[i]] # c[i] +=1 # i = 0 # else: # c[i] = 0 # i+=1 # permute_three([0,1,4]) . # # - 값이 index랑 같아지는 부분은 횟수를 늘리는 용도일 뿐이라는 말이다. # def permute_four(arr): # result = [arr[:]] # 2차원에 1번째 행을 원본을 넣어놓는다. # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c[i], c, arr) # if c[i] &lt; i : # # 3. 인덱스가 짝수면, 0번째 값과, 짝수번째 값을 교환. # if i % 2 ==0: # arr[0], arr[i] = arr[i], arr[0] # # 4. 인덱스가 홀수면, [c list의 i번째 값]을 index로 넣고, 데이터 홀수번재 값을 교환 # else: # arr[c[i]], arr[i] = arr[i], arr[c[i]] # # 5. arr결과를 result 2차원 리스트(원본을 1행에 가지고 있던 놈)에 append한다. # # - c[i]가 0에서부터 불들어오는 순간부터 교환후 들어올리네. # result.append(arr[:]) # c[i] +=1 # i = 0 # else: # c[i] = 0 # i+=1 # # 6. result 2차원 리스트를 반환한다. # return result # permute_four([1,2,3]) . def permute(arr): result = [arr[:]] c = [0] * len(arr) i = 0 while i &lt; len(arr): if c[i] &lt; i: if i % 2 == 0: arr[0], arr[i] = arr[i], arr[0] else: arr[c[i]], arr[i] = arr[i], arr[c[i]] result.append(arr[:]) c[i] += 1 i = 0 else: c[i] = 0 i += 1 return result . &#48264;&#50808;) python&#51004;&#47196;&#49692;&#50676; &#44396;&#54788;1 (&#48660;&#47196;&#44536;1, &#51116;&#44480;+&#48520;&#53356;&#44256;&#45124;&#44592; ) . https://shoark7.github.io/programming/algorithm/Permutations-and-Combinations | https://programmers.co.kr/learn/courses/4008/lessons/12836 | . arr = [0,1,2,3] r = 2 # def permutation(arr, r): # 1. used(list) : 해당index의 원소 사용 여부 : arr의 길이만큼 빈 [0] * n를 만들자. # - used(list)에는 해당index의 값이 사용됬는지 안됬는지 체크여부. # - 누적합이 아니라도 여부 등은 0 default에서 1 왔다갔다 하면, if문에 False, True로 걸린다. # used = [0] * len(arr) used = [0 for _ in range(len(arr))] # 2. generate( chosen, used ): 함수로 만들어야 -&gt; 내부에서 같은 로직을 한번 더 호출할 수 있다. # - 일단, 빈 list를 던져주고, 사용여부에 따라 append한 다음, 길이가 원하는 순열길이(r)과 같아졌다면 함수를 끝내는 return해준다. # generate([], used) 형태로 사용된다. def generate(chosen, used): # 2-1) default [] chosen이 원하는 길이를 만족했으면 -&gt; 탈출 -&gt; 그전까지는 내부함수 호출로 반복됨. if len(chosen) == r: print(chosen) # 결과값 저장대신 각각 만들어진 경우를 print한다. return # 2-2) arr길이만큼 반복 -&gt; used의 길이랑 arr이랑 같으며, 같이 움직이니까. # arr와 같은 길이의 used는 arr[i]의 사용여부체크시 used[i]를 사용하는 위에 떠있는 데이터 for i in range(len(arr)): # i번째 원소가 아직 사용이 안됬다? print(&#39;used&#39;, used) if not used[i]: # 사용후 -&gt; 사용표시 1 # - 일단 사용안된 i번째 요소를 chosen에 넣고, 사용했다는 표기를 한다. print(&#39;chosen&#39;, chosen) chosen.append(arr[i]) used[i]=1 # i번재 데이터가 담기고 + 사용되었다는 표시와함께 다시 호출하면 # - 재귀적? 반복적으로... i를 제외하고 사용안된 i를 =1,2,3,4에서부터 찾기..전에... generate(chosen, used) # 내부에서, 길이 못채웠고 &amp; 사용된것 넘어가면서 사용안된 것을 j를 0에서부터 찾는다. # 내부에서, 0은 used[0]이 이미 담겨있으니, 1을 chosen에 넣고, 0,1,을 넣은 상태에다. # 내부에서 또 내부함수가 호출되지만, 초기검사에서 r==2를 만족시켜 반환되며 # 내부j에서는, used[j] = 0을 넣고, 안썼다고 표시 + 데이터도 뺀 체로, j=1이 된다. # i=0는 고정상태에서 j=0을 쓴 뒤, j=1을 쓰고, r==2가 만족되면 j=2로 간다... # i 고정 -&gt; j를 돌면서 -&gt; k에서 갯수가 맞추다가,, j를 다돌면, i가 도나보다... used[i] = 0 chosen.pop() # 재귀를 써서 구하는데 # base case가 chosen == r(input)을 맞추면 끝난다... # 이 함수의 핵심이다. 모든 순열은 arr 의 0부터 i-1 번째 값으로 시작하기에 for 문으로 다 만들어야 한다. # recusive case는 nPr = 시작자리에 arr[i] 가 들어갔다고 치면(for를 n번) = N * n-1Pr 이다. # permutation([0,1,2,3], 2) = # ([0],permutation([1,2,3], 1)) + ([1],permutation([0,2,3], 1)) + ([2],permutation([0,1,3], 1))+ ([3],permutation([0,1,2], 1)) # combination([0,1,2,3], 2) = ([0],combination([1,2,3], 1)) + ([1],combination([2,3], 1)) + ([2],combination([3], 1))) # https://cotak.tistory.com/70 . used [0, 0, 0, 0] chosen [] used [1, 0, 0, 0] used [1, 0, 0, 0] chosen [0] [0, 1] used [1, 0, 0, 0] chosen [0] [0, 2] used [1, 0, 0, 0] chosen [0] [0, 3] used [0, 0, 0, 0] chosen [] used [0, 1, 0, 0] chosen [1] [1, 0] used [0, 1, 0, 0] used [0, 1, 0, 0] chosen [1] [1, 2] used [0, 1, 0, 0] chosen [1] [1, 3] used [0, 0, 0, 0] chosen [] used [0, 0, 1, 0] chosen [2] [2, 0] used [0, 0, 1, 0] chosen [2] [2, 1] used [0, 0, 1, 0] used [0, 0, 1, 0] chosen [2] [2, 3] used [0, 0, 0, 0] chosen [] used [0, 0, 0, 1] chosen [3] [3, 0] used [0, 0, 0, 1] chosen [3] [3, 1] used [0, 0, 0, 1] chosen [3] [3, 2] used [0, 0, 0, 1] . def permutation(arr, r): # 1. arr = sorted(arr) # 해당원소가 사용되고 있는 상태인지 arr와 같은길이의 0과 1로 구성될 list 생성 # - 재귀로 내부에서 함수가 또 불려질텐데, 내부함수가 밖에서 어떤 원소가 고정된 상탠지 알려주기 위해 # - 함수 입장에서 전역변수로 만들어준다. used = [0 for _ in range(len(arr))] def generate(chosen, used): # 2.재귀에서 탈출부이다. chosen이 원하는 갯수 r개가 되면 base case로 print하고 해당함수는 끝난다. # - 내부함수들이 끝나는 것이기에... 어느것이 끝나는지는... if len(chosen) == r: print(chosen) return # 3.i번째를 고정시킨 상태에서, # - i에 불이 안들어와있는 상태다 = 가장 바깥은 필요없지만.. 내부함수들은 바깥에서 고정된 것이기에 피해야한다. for i in range(len(arr)): # 사용했다는 불이 안들어온 상태다. 내부함수가 인식하도록, 내부함수호출직전에 켜주고, 직후에 꺼준다. # 맨바깥은 for로 알아서 i가 돌아가고 있기 때문에 노상관. 내부에서 i불들어온 것 제끼고 r-1개 맞추라는 신호임. if not used[i]: # 4. 내부함수가 i원소를 채운 상태로 재귀호출하도록 넣어주고, 불을 켜준다. chosen.append(arr[i]) used[i] = 1 generate(chosen, used) # 재귀상태로, 1개를 채운상태에서 r-1를 채우려고 호출된다. # 5. i고정상태에서 r-1개를 다채워 r개를 완성했다는 뜻이니, 불을 꺼주고, 빼준다. used[i] = 0 chosen.pop() # 6. 자동으로 다음 i가 고정되서 시작한다. generate([], used) permutation(&#39;ABCD&#39;, 2) . [&#39;A&#39;, &#39;B&#39;] [&#39;A&#39;, &#39;C&#39;] [&#39;A&#39;, &#39;D&#39;] [&#39;B&#39;, &#39;A&#39;] [&#39;B&#39;, &#39;C&#39;] [&#39;B&#39;, &#39;D&#39;] [&#39;C&#39;, &#39;A&#39;] [&#39;C&#39;, &#39;B&#39;] [&#39;C&#39;, &#39;D&#39;] [&#39;D&#39;, &#39;A&#39;] [&#39;D&#39;, &#39;B&#39;] [&#39;D&#39;, &#39;C&#39;] . &#48264;&#50808;2 ) python&#51004;&#47196;&#49692;&#50676; &#44396;&#54788;2 (&#48660;&#47196;&#44536;2, full &#51116;&#44480;&#54632;&#49688;&#47196; &#52376;&#47532;. &#45796;&#49884; &#48380; &#44163;) . # 출처: https://cotak.tistory.com/70 [Pool&#39;s Taek] def gen_permutations(arr, n): result = [] if n == 0: return [[]] for i, elem in enumerate(arr): # i번재 원소만 빼고, 대신 n-1개만 나머지로 순열 부분문제 정복상태 -&gt; 각 요소들P for P in gen_permutations(arr[:i] + arr[i+1:], n-1): # i번째 원소를 맨마지막에 extend해서 붙임. # [[2]] # [[1, 2]] # [[0, 1, 2]] # [[0, 1, 2]] # 순열도 제일 마지막에 첨가하면, 조합처럼 n-1개 완성 + 1개요소(n가지)가 된다? result += [[elem]+P] print(result) break return result arr = [0, 1, 2, 3, 4, 5] print(gen_permutations(arr, 3)) . [[2]] [[1, 2]] [[0, 1, 2]] [[0, 1, 2]] . &#51221;&#45813; . # itertools.permutation를 이용하면, for문을 사용하지 않고도 순열을 구할 수 있습니다. import itertools # pool = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] pool = &#39;ABC&#39; print(list(map(&#39;&#39;.join, itertools.permutations(pool)))) # 3개의 원소로 수열 만들기 print(list(map(&#39;&#39;.join, itertools.permutations(pool, 2)))) # 2개의 원소로 수열 만들기 . [&#39;ABC&#39;, &#39;ACB&#39;, &#39;BAC&#39;, &#39;BCA&#39;, &#39;CAB&#39;, &#39;CBA&#39;] [&#39;AB&#39;, &#39;AC&#39;, &#39;BA&#39;, &#39;BC&#39;, &#39;CA&#39;, &#39;CB&#39;] . &#45712;&#45184;&#51216;(itertools.permutations , combinations) . 문자열로 1글자씩으로 구성된 iter라 순열 또는 조합을 구할 수 있다. 리스트는 튜플 조합 리스트로 / 문자열을 문자열그대로의 리스트로 반환됨. | . | 원하는 구성원소갯수를 지정할 수 있다. | . (&#52428;)&#44032;&#51109; &#47566;&#51060; &#46321;&#51109;&#54616;&#45716; &#50508;&#54028;&#48307; &#52286;&#44592; - Counter . 문제 설명 이 문제에는 표준 입력으로 문자열, mystr이 주어집니다. mystr에서 가장 많이 등장하는 알파벳만을 사전 순으로 출력하는 코드를 작성해주세요. 제한 조건 mystr의 원소는 알파벳 소문자로만 주어집니다. mystr의 길이는 1 이상 100 이하입니다. 예시 input output &#39;aab&#39; &#39;a&#39; &#39;dfdefdgf&#39; &#39;df&#39; &#39;bbaa&#39; &#39;ab&#39; . &#45236;&#54400;&#51060; . dict에 단어마다 count 저장함 | dict를 sorted( , reverse=True, key=lambda x:x[1])로 밸류순으로 역순으로 정렬 -&gt; 가장 첫밸류값이 가장 최대값 | 첫, 두번째 밸류 동점일 수 있으니, value만 뽑은 뒤.. dict.items()를 돌면서 value가 같은 것을 출력함. | . my_str = input().strip() counter_dict = {} for key in my_str: counter_dict.setdefault(key, 0) counter_dict[key]+=1 max_value = sorted(counter_dict.items(), key=lambda x:x[1],reverse=True)[0][1] answer_list = [] for k,v in counter_dict.items(): if v == max_value: answer_list.append(k) print(&#39;&#39;.join(sorted(answer_list))) . aab a . &#51221;&#45813; . # 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통 사람들은 반복문을 이용해 수를 셉니다. my_list = [1, 2, 3, 4, 5, 6, 7, 8, 7, 9, 1, 2, 3, 3, 5, 2, 6, 8, 9, 0, 1, 1, 4, 7, 0] answer = {} for number in my_list: try: answer[number] += 1 except KeyError: answer[number] = 1 print(answer[1]) # = 4 print(answer[3]) # = 3 print(answer[100]) # = raise KeyError . import collections my_str = input().strip() answer = collections.Counter(my_str) print(answer) # dict형태로 출력됨. #Counter객체는 .most_common() 으로 key, count의 튜플리스트가 나옴. answer.most_common() # . asdklfjaskdfekekjek Counter({&#39;k&#39;: 5, &#39;e&#39;: 3, &#39;a&#39;: 2, &#39;s&#39;: 2, &#39;d&#39;: 2, &#39;f&#39;: 2, &#39;j&#39;: 2, &#39;l&#39;: 1}) . [(&#39;k&#39;, 5), (&#39;e&#39;, 3), (&#39;a&#39;, 2), (&#39;s&#39;, 2), (&#39;d&#39;, 2), (&#39;f&#39;, 2), (&#39;j&#39;, 2), (&#39;l&#39;, 1)] . dict_ = {&#39;k&#39;: 5, &#39;e&#39;: 3, &#39;a&#39;: 2, &#39;s&#39;: 2, &#39;d&#39;: 2, &#39;f&#39;: 2, &#39;j&#39;: 2, &#39;l&#39;: 1} dict_.values() # dict_.keys(), dict_.items() max(answer.values()) . 5 . # -&gt; values로 max값 바로 찾을 수 있다. # -&gt; max값을 알 때, for문을 돌면서, key값들을 누적할 수 있다? # -&gt; max값이 여러개일 수 있으니, 미리구한 최대값 == count 하면서 돌아야한다. my_list = input() max_count = max(collections.Counter(my_list).values()) [ word for word, count in collections.Counter(my_list).items() if count == max_count] . aaadddwqierie . [&#39;a&#39;, &#39;d&#39;] . &#45712;&#45184;&#51216; ( collections.Counter - dict + .most_common() ) . 비 파이썬이라도 dict에 저장하는 것은 똑같았다. | collections.Counter() -&gt; dict와 유사하니, Counter.values()로 max()를 구하고 | list comp로 Counter.items()를 k,v를 받아서 필터링하자 | . | 빈도순으로 튜플리스트를 반환하는 것은 .most_common()이다. | &#44592;&#53440; (7) . for &#47928;&#44284; if&#47928;&#51012; &#54620;&#48264;&#50640; - List comprehension&#51032; if &#47928; . 문제 설명 정수를 담은 리스트 mylist를 입력받아, 이 리스트의 원소 중 짝수인 값만을 제곱해 담은 새 리스트를 리턴하는 solution함수를 완성해주세요. 예를 들어, [3, 2, 6, 7]이 주어진 경우 3은 홀수이므로 무시합니다. 2는 짝수이므로 제곱합니다. 6은 짝수이므로 제곱합니다. 7은 홀수이므로 무시합니다. 따라서 2의 제곱과 6의 제곱을 담은 리스트인 [4, 36]을 리턴해야합니다. 제한 조건 mylist는 길이가 100이하인 배열입니다. mylist의 원소는 1이상 100 이하인 정수입니다. . mylist = [3, 2, 6, 7] answer = [number**2 for number in mylist if number % 2 == 0] answer . [4, 36] . &#45712;&#45184;&#51216;( X ) . mylist = [3, 2, 6, 7] answer = [] for number in mylist: if number % 2 == 0: answer.append(number**2) # 들여쓰기를 두 번 함 # 파이썬의 list comprehension을 사용하면 한 줄 안에 for 문과 if 문을 한 번에 처리할 수 있습니다. mylist = [3, 2, 6, 7] answer = [number**2 for number in mylist if number % 2 == 0] . (&#52428;) flag&#48320;&#49688; &#45824;&#49888; for-else &#49324;&#50857;&#54616;&#44592; . 문제 설명 본 문제에서는 자연수 5개가 주어집니다. 숫자를 차례로 곱해 나온 수가 제곱수가 되면 found를 출력하고 모든 수를 곱해도 제곱수가 나오지 않았다면 not found를 출력하는 코드를 작성해주세요. 예시 1 입력 2 4 2 5 1 출력 found 설명 수를 곱해나가면 2, 8, 16, 80, 80 이 나옵니다. 16은 4를 제곱해 나온 수이므로 이 수는 제곱수입니다. 따라서 found를 출력합니다. 예시 2 입력 5 1 2 3 1 출력 not found 설명 수를 곱해나가면 5, 5, 10, 30, 30 이 나옵니다. 이중 어떤 수도 제곱 수가 아니므로 not found를 출력합니다. . data = [ int(input()) for _ in range(5)] import math product = 1 check=False for n in data: product*=n if math.sqrt(product) == int(math.sqrt(product)) : print(&#39;found&#39;) check=True break if check == False: print(&#39;not found&#39;) . 2 4 2 5 1 2 1.4142135623730951 8 2.8284271247461903 16 4.0 found 2 not found . &#51221;&#45813; . # https://harryp.tistory.com/317 [Park&#39;s Life] import math data = [ int(input()) for _ in range(5)] product = 1 # check=False # 1. for내부에 if로 끊김을 나타내는 flag변수를 안쓴다. for n in data: product*=n if math.sqrt(product) == int(math.sqrt(product)) : print(&#39;found&#39;) #check=True break # if check == False: # 2. for가 안끊기고 다 돌았다면, else문 실행시킨다. else: print(&#39;not found&#39;) . 2 4 2 5 1 found . &#45712;&#45184;&#51216;( flag&#48320;&#49688; &#45824;&#49888; for-else&#47928; -&gt; for if &#52286;&#50520;&#51004;&#47732; flag break &#45824;&#49888; for if &#52286;&#50520;&#51004;&#47732;&#52376;&#47532; else&#47803;&#52286;&#50520;&#45796;&#52376;&#47532; + &#51228;&#44273;&#49688; + &#49548;&#49688;&#51216;.0&#51032; int&#54869;&#51064;) . for_if 조건: break -&gt; 만약 다 돌았는데도 if brea에 안걸린 not found == for 다돈 경우 else 조건X시 처리 . 원래는.. for문 내부에서 if 걸렸다? -&gt; break하고 for문 뒤에는 실행 X 를 for문 밖 flag=True/False 변수에 전달해줬다. | 이제는 for문 if 걸려서 flag = True + break -&gt; if flag: 처리는 하지 말자. for문 if 걸려서 break -&gt; 만약 안걸리고 다돌면 처리를 else문에서 | . | . | 제곱수의 판단 : math.sqrt()를 씌웠을 때 int여야한다. . 하지만 sqrt()씌우는 순간 int라도 2.0 3.0 이 되어버린다. | 정수.0의 int 판단방법 int()변환값 == 현재값 ( 전환된 값의 비교로 판단 ) | . | cf) 정수 판단 방법 isinstance( , int) | type( v ) == int | . | . | . &#46160; &#48320;&#49688;&#51032; &#44050; &#48148;&#44984;&#44592; - swap . # 비 파이썬은 덮어쓰기 당할 변수값을 temp에 넣어놓고 덮어쓰기 -&gt; 다른쪽 덮어쓰기 a = 3 b = &#39;abc&#39; temp = a a = b b = temp . 파이썬에서는 다음과 같이 한 줄로 두 값을 바꿔치기할 수 있음. . a = 3 b = &#39;abc&#39; a, b = b, a . (&#52428;) &#51060;&#51652; &#53456;&#49353;&#54616;&#44592; - bisect &#47784;&#46280; . 알고리즘 문제를 풀다 보면 이진 탐색을 써야할 때가 많습니다. 이런 문제를 풀 때마다 이진 탐색 알고리즘을 작성하는 건 비효율적이지요. 이번 시간엔 Python의 이진 탐색 모듈, bisect를 알아봅시다. | . # - while문에 if 탈출(break or def-return)이 없다? -&gt; 다돌고 &lt;조건문 직후 상태&gt;로 빠져나와서 최종 처리한다는 뜻 # ex&gt; while low &lt; high -&gt; low &gt;= high순간에 빠져나옴. 주로 직후인 low==high에서 빠져나와 마지막 처리 def bisect(a, x, lo=0, hi=None): if lo &lt; 0: raise ValueError(&#39;lo must be non-negative&#39;) if hi is None: hi = len(a) while lo &lt; hi: mid = (lo + hi) // 2 if a[mid] &lt; x: lo = mid + 1 else: hi = mid return lo mylist = [1, 2, 3, 7, 9, 11, 33] print(bisect(mylist, 5)) # ??? 없는 것도 나온다? . 3 . # 실제 list index의 +1을 반환하는 것 같다. # ** 해당 숫자 n을 어디에 insert해야하는지의 위치를 보여준다.** # 1) 같은게 있으면? 그 index +1 자리에 넣어라 # 2) 같은게 없으면? 오름차순으로 넣어야할 자리는 여기다. import bisect mylist = [1, 2, 3, 7, 9, 11, 33] print(bisect.bisect(mylist, 9)) # 같은게 4에 있으니 5번째 들어가야한다. print(bisect.bisect(mylist, 33)) # 같은게 6에 있으니 7에 들어가야한다. print(bisect.bisect(mylist, 5)) # 없는데 &lt;&lt;오름차순&gt;&gt; 4-&gt;value 3 뒤의 5자리에 들어가야한다. . 5 7 3 . # index 함수는 이진 탐색이 아닌 선형 탐색 함수입니다. # (물론 주어진 input에 대해서 index 함수를 쓰면 정확한 output 값을 얻을 수 있긴 합니다.) # 이진탐색의 시간복잡도는 O(logN) 이나, # index 함수는 선형탐색을 하므로 시간복잡도가 O(N)이라 시간이 오래 걸립니다. # bisect.bisect(mylist, n)의 n은 mylist에서 찾고자하는 값입니다. # bisect.bisect(mylist, n)이 리턴하는 값, x는 mylist에서 n이 위치한 index의 오른쪽 값을 나타냅니다. # insertion point를 리턴합니다. 즉, 3의 인덱스는 2이므로 이 다음에 있는 insertion point는 2+1 = 3이 되는 것이지요. # 말씀하신대로 bisect는 key 가 없으면 key가 들어갈 위치를 반환합니다. . # - 내뱉은 point가 .. 직전에 같은값이 있어서 그 바로 뒤라면? i-1 반환 # - 내뱉은 point가.. 직전에 같은값은 없으나.. 순서라서 줬다면? 그냥 탐색 실패-&gt; -1반환 import bisect def b_s(ary,key): i= bisect.bisect(ary,key) return i-1 if ary[i-1]==key else -1 . &#45712;&#45184;&#51216;(bisect.bisect( list, value) &gt; return or insert point, &#48148;&#47196;&#50526;&#50640; &#51080;&#44144;&#45208; &#47803;&#52286;&#50520;&#51648;&#47564; &#51221;&#47148;&#49345; &#44536;&#51088;&#47532;) . 정렬된 list라면, 이진탐색을 bisect.bisect로 할 수 있다. return된 값이. 실제 있떤 값이면 i + 1 = return값이다. -&gt; return값 - 1을 하자 | return된 값이. 없으나 정렬상 그자리에 들어가라고 return한 값이다 -&gt; ??? 직전과 값이 같앗 뱉은 건지 확인해야한다. if number == list[return value - 1] -&gt;returnvalue -1 else None.. | . | . | . &#53364;&#47000;&#49828; &#51064;&#49828;&#53556;&#49828; &#52636;&#47141;&#54616;&#44592; - class&#51032; &#51088;&#46041; string casting . 이번 강의에서는 인스턴스 출력 형식을 지정하는 방법을 배워봅시다. . 예) 2차원 평면 위의 점을 나타내는 Coord 클래스의 인스턴스를 (x 값, y 값)으로 출력하기 . class Coord(object): def __init__(self, x, y): self.x, self.y = x, y point = Coord(1, 2) print( &#39;({}, {})&#39;.format(point.x, point.y) ) # 또는 def print_coord(coord): print( &#39;({}, {})&#39;.format(coord.x, coord.y) ) print_coord(point) . # __str__ 메소드를 사용해 class 내부에서 **출력 format**을 지정할 수 있습니다. class Coord(object): def __init__ (self, x, y): self.x, self.y = x, y def __str__ (self): return &#39;({}, {})&#39;.format(self.x, self.y) point = Coord(1, 2) print(point) point . (1, 2) . &lt;__main__.Coord at 0x1ed8d397e80&gt; . &#45712;&#45184;&#51216; ( str&#50724;&#48260;&#46972;&#51060;&#46377; ) . print + interpret에 출력까지 될라면 repr를 오버라이딩한다. | 객체정보를 직접 찍어보지말자! 메소드 정의(비파이썬) 나 메소드 오버라이딩으로 확인하자.! | (&#52428;) &#44032;&#51109; &#53360; &#49688;, inf . 코딩 테스트 문제 등을 풀다 보면, 최솟값을 저장하는 변수에 아주 큰 값을 할당해야 할 때가 있습니다. 이번 시간에는 이때에 사용하기 좋은 inf에 대해 알아봅시다. . 이 기능을 모르시는 분은 본인이 생각하는 임의의 큰 수(99999등)를 할당합니다. . # 비파이썬에서, 최소값을 구할려구 미리 큰값을 넣어올 때, min_val = 99999 min_val &gt; 100000000 # ? . # 파이썬에서, 최소값을 구할려구 미리 큰값을 넣어올 때, # 파이썬이 제공하는 inf 를 사용. inf는 어떤 숫자와 비교해도 무조건 크다고 판정 min_val = float(&#39;inf&#39;) min_val &gt; 10000000000 . inf에는 음수 기호를 붙이는 것도 가능합니다. . max_val = float(&#39;-inf&#39;) . &#45712;&#45184;&#51216; - float(&#39;inf&#39;), float(&#39;-inf&#39;) . 최대값을 찾을 때, 일단 작은값을 변수에 넣어놓고 돈다. 가장 작은 값은 float(&#39;-inf&#39;) / 가장 큰 값은 float(&#39;inf&#39;) 로 초기값을 넣고 해결하자! | . | float(&#39;inf&#39;) . inf . float(&#39;-inf&#39;) . -inf . &#54028;&#51068; &#51077;&#52636;&#47141; &#44036;&#45800;&#54616;&#44172; &#54616;&#44592; - with open as f for line in f.readlines() . 이번 강의에서는 파일 입출력 코드를 간결하게 짜는 법을 알아봅시다. . &#39;myfile.txt&#39;라는 이름의 파일을 읽는 코드를 짜보세요 . # 1. open -&gt; 2. 반복문 while -&gt; 3.line = readlins() + if not line: break + line처리 -&gt; 4. close f = open(&#39;myfile.txt&#39;, &#39;r&#39;) while True: line = f.readline() if not line: break raw = line.split() print(raw) f.close() . FileNotFoundError Traceback (most recent call last) &lt;ipython-input-467-4f9a0ee2adde&gt; in &lt;module&gt; 1 # 비파이썬 2 # 1. open -&gt; 2. 반복문 while -&gt; 3.line = readlins() + if not line: break + line처리 -&gt; 4. close -&gt; 3 f = open(&#39;myfile.txt&#39;, &#39;r&#39;) 4 while True: 5 line = f.readline() FileNotFoundError: [Errno 2] No such file or directory: &#39;myfile.txt&#39; . # with - as 구문을 이용하면 코드를 더 간결하게 짤 수 있습니다. 코드를 아래와 같이 쓰면 다음과 같은 장점이 있습니다. # 1. 파일을 close 하지 않아도 됩니다: with - as 블록이 종료되면 파일이 자동으로 close 됩니다. # 2. readlines가 EOF까지만 읽으므로, while 문 안에서 EOF를 체크할 필요가 없습니다. # my) python은 readlines()가 EOF를 알아서 인식하니 -&gt; 반복문 in 자리에 넣으면 된다. -&gt; EOF 체크 필요없음. with open(&#39;myfile.txt&#39;) as file: for line in file.readlines(): print(line.strip().split(&#39; t&#39;)) . FileNotFoundError Traceback (most recent call last) &lt;ipython-input-468-1cec8ae34904&gt; in &lt;module&gt; 5 6 # my) python은 readlines()가 EOF를 알아서 인식하니 -&gt; 반복문 in 자리에 넣으면 된다. -&gt; EOF 체크 필요없음. -&gt; 7 with open(&#39;myfile.txt&#39;) as file: 8 for line in file.readlines(): 9 print(line.strip().split(&#39; t&#39;)) FileNotFoundError: [Errno 2] No such file or directory: &#39;myfile.txt&#39; . &#45712;&#45184;&#51216; - with as &#50752; python readlines() . with as f -&gt; close 안해도됨 + f.readlines()시 EOF 체크 자동으로 되니 반복문에 바로 삽입 | boj input() 등 f.readlines()와 달리 언제 EOF인지는 모를 땐, try except EOFError로 break해주자. | &#52280;&#44256;) &#51077;&#47141;&#51032; &#45149;(EOF) &#54869;&#51064; by except EOFError: break . f.readlines()는 알아서 EOF(end of file)을 체크하지만, boj등 input()이 언제 EOF인지는 모르니까, try except EOFError로 break해주자. | . | . while 1: try: ins=input() ans = fun(ins) if ans == -1: break; else: print(ans) except EOFError: break .",
            "url": "blog.chojaeseong.com/algorithm/2021/08/11/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_python_pythonic.html",
            "relUrl": "/algorithm/2021/08/11/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_python_pythonic.html",
            "date": " • Aug 11, 2021"
        }
        
    
  
    
        ,"post16": {
            "title": "알고리즘 문제 풀기용 input 코드 모음(python)",
            "content": "&#52280;&#44256; . 블로그 | 그외 백준 공식 레퍼런스 | . input.txt&#47484; &#51060;&#50857;&#54620; local &#54400;&#51060; &#44396;&#51312; . 폴더 input.txt | xxx.py | . | . import sys sys.stdin = open(&quot;./input.txt&quot;, &quot;rt&quot;) # jupyter notebook시 필수 input = sys.stdin.readline # 콘솔에선 미리 안해도되며, 속도향상 필요시만 해준다. / ###################################################### N = int(input()) # print(N) data = list(map(int, input().split())) # print(data) . &#44277;&#48177; &#44592;&#51456; &#45936;&#51060;&#53552; &#51077;&#47141;&#48155;&#44592;(map, int, input.split ) . map객체를 이용해 str -&gt; int 변환했지만, sequence는 아니라 인덱싱을 못한다. a, b = map : 인덱싱은 못해도 할당시 나눠받을 수 있다. | list_ = list(map) : 할당시 나눠받기가 불가능할 정도로 많으면, list()로 sequence로 변환시켜 받아야한다. | . | . # - 1개는 map쓰지말자~! n = int(input().strip()) # 2개 - int a, b= map(int, input().split()) # for문으로 n번 2개씩 n = int(input().strip()) for _ in range(n): a, b= map(int, input().split()) # 3개이상의 - list data = list(map(int, input().split())) # for문으로 n번 3개이상시 n = int(input().strip()) for _ in range(n): data = list(map(int, input().split())) . &#49884;&#44036;&#51012; &#45908; &#48736;&#47476;&#44172; &#45936;&#51060;&#53552; &#51077;&#47141;&#48155;&#44592;(sys &#47784;&#46280;) . sys.stdin.readline() 사용 | 단, 입력 후 엔터가 사용되므로 rstrip() 를 함께 사용 | . import sys str = sys.stdin.readline().rstrip() # 1개 - int import sys n = sys.stdin.readline() # 2개 int import sys N, M = map(int, sys.stdin.readline().split()) # 2차원 리스트 입력 받기 # - 행의 수 N을 입력받고, 각 행의 데이터들을 한번에 받아서 split()해서 열로 들어간다. import sys N = sys.stdin.readline() board = [list(map(int,sys.stdin.readline().split())) for _ in range(N)] . ValueError Traceback (most recent call last) &lt;ipython-input-11-198e9d917b91&gt; in &lt;module&gt; 9 # 2개 int 10 import sys &gt; 11 N, M = map(int, sys.stdin.readline().split()) 12 13 ValueError: not enough values to unpack (expected 2, got 0) . &#44277;&#48177;&#44592;&#51456; &#52636;&#47141;&#49884; *(&#49324;&#50857;&#49884;&#50616;&#54056;&#53433;)&#51004;&#47196; . result = [1, 2, 3] # 기본적인 리스트 출력시 print(result) # [1,2,3] # for loop으로 원소를 하나씩 출력 for i in range(len(result)): print(result[i], end=&#39; &#39;) # 1 2 3 # 리스트의 원소를 언패킹 시켜서 출력 print(*result) # 1 2 3 . [1, 2, 3] 1 2 3 1 2 3 . N x M &#53356;&#44592;&#51032; &#51060;&#52264;&#50896; &#47532;&#49828;&#53944; &#52488;&#44592;&#54868; &#48143; &#51077;&#47141;&#48155;&#44592; . 시뮬레이션 문제에서 주어지는 입력 중 가장 많은 형태의 입력을 list comprehension 으로 받을 수 있다. . n, m = map(int, input().split()) board = [list(map(int, input().split())) for _ in range(n)] visited = [[False]*m for _ in range(n)] print(visited) print(board) # 입력(행 열 -&gt; 열의 갯수만큼 False==0으로 채워진 행x열의 visited 2차원 리스트) # 5 9 # 0 0 0 0 0 0 0 0 0 # 0 0 0 1 1 0 0 0 0 # 0 0 0 1 1 0 1 1 0 # 0 0 1 1 1 1 1 1 0 # 0 0 1 1 1 1 1 0 0 . [[False, False, False, False, False], [False, False, False, False, False], [False, False, False, False, False]] [[3], [3], [3]] . &#51116;&#44480;&#54632;&#49688;&#50640;&#49436; &#53084;&#49828;&#53469; &#51228;&#54620;(&#51116;&#44480;&#54620;&#46020;) &#54400;&#50612;&#51452;&#44592; . import sys; sys.setrecursionlimit(10000) .",
            "url": "blog.chojaeseong.com/algorithm/2021/08/10/boj_input_codes.html",
            "relUrl": "/algorithm/2021/08/10/boj_input_codes.html",
            "date": " • Aug 10, 2021"
        }
        
    
  
    
        ,"post17": {
            "title": "타이타닉 정리",
            "content": "import numpy as np import pandas as pd # %matplotlib nbagg %matplotlib inline import matplotlib.pyplot as plt import matplotlib import seaborn as sns sns.set(font_scale=1.5) sns.set_style(&#39;whitegrid&#39;) #whitegrid sns.set_palette(&#39;muted&#39;) # 한글사용가능하게하기 from matplotlib import font_manager font_name = font_manager.FontProperties(fname=&#39;C:/Windows/Fonts/malgun.ttf&#39;).get_name() matplotlib.rc(&#39;font&#39;, family=font_name) print (plt.rcParams[&#39;font.family&#39;] ) . [&#39;Malgun Gothic&#39;] . &#45936;&#51060;&#53552; &#47196;&#46377; . import pandas as pd train = pd.read_csv(&#39;data/titanic/train.csv&#39;) test = pd.read_csv(&#39;data/titanic/test.csv&#39;) . &#45936;&#51060;&#53552; &#54869;&#51064; . train과 test 비교후, test에 없는 칼럼이 종속변수 | head()와 info()를 비교하여 범주형과 숫자형의 type이 제대로 되었는지 확인하기 | . print(train.shape) print(train.columns) train.head() . (891, 12) Index([&#39;PassengerId&#39;, &#39;Survived&#39;, &#39;Pclass&#39;, &#39;Name&#39;, &#39;Sex&#39;, &#39;Age&#39;, &#39;SibSp&#39;, &#39;Parch&#39;, &#39;Ticket&#39;, &#39;Fare&#39;, &#39;Cabin&#39;, &#39;Embarked&#39;], dtype=&#39;object&#39;) . PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | male | 22.0 | 1 | 0 | A/5 21171 | 7.2500 | NaN | S | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | female | 38.0 | 1 | 0 | PC 17599 | 71.2833 | C85 | C | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | female | 26.0 | 0 | 0 | STON/O2. 3101282 | 7.9250 | NaN | S | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 | 1 | 0 | 113803 | 53.1000 | C123 | S | . 4 5 | 0 | 3 | Allen, Mr. William Henry | male | 35.0 | 0 | 0 | 373450 | 8.0500 | NaN | S | . train.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 891 entries, 0 to 890 Data columns (total 12 columns): PassengerId 891 non-null int64 Survived 891 non-null int64 Pclass 891 non-null int64 Name 891 non-null object Sex 891 non-null object Age 714 non-null float64 SibSp 891 non-null int64 Parch 891 non-null int64 Ticket 891 non-null object Fare 891 non-null float64 Cabin 204 non-null object Embarked 889 non-null object dtypes: float64(2), int64(5), object(5) memory usage: 83.6+ KB . print(test.shape) print(test.columns) test.head() . (418, 11) Index([&#39;PassengerId&#39;, &#39;Pclass&#39;, &#39;Name&#39;, &#39;Sex&#39;, &#39;Age&#39;, &#39;SibSp&#39;, &#39;Parch&#39;, &#39;Ticket&#39;, &#39;Fare&#39;, &#39;Cabin&#39;, &#39;Embarked&#39;], dtype=&#39;object&#39;) . PassengerId Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked . 0 892 | 3 | Kelly, Mr. James | male | 34.5 | 0 | 0 | 330911 | 7.8292 | NaN | Q | . 1 893 | 3 | Wilkes, Mrs. James (Ellen Needs) | female | 47.0 | 1 | 0 | 363272 | 7.0000 | NaN | S | . 2 894 | 2 | Myles, Mr. Thomas Francis | male | 62.0 | 0 | 0 | 240276 | 9.6875 | NaN | Q | . 3 895 | 3 | Wirz, Mr. Albert | male | 27.0 | 0 | 0 | 315154 | 8.6625 | NaN | S | . 4 896 | 3 | Hirvonen, Mrs. Alexander (Helga E Lindqvist) | female | 22.0 | 1 | 1 | 3101298 | 12.2875 | NaN | S | . test.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 418 entries, 0 to 417 Data columns (total 11 columns): PassengerId 418 non-null int64 Pclass 418 non-null int64 Name 418 non-null object Sex 418 non-null object Age 332 non-null float64 SibSp 418 non-null int64 Parch 418 non-null int64 Ticket 418 non-null object Fare 417 non-null float64 Cabin 91 non-null object Embarked 418 non-null object dtypes: float64(2), int64(4), object(5) memory usage: 36.0+ KB . &#52860;&#47100;&#47749; &#49548;&#47928;&#51088;&#47196; &#51068;&#44292;&#48320;&#44221; . &#48169;&#48277;1 : &#46357;&#49492;&#45320;&#47532; &#54805;&#53468;&#47196; &#48320;&#44221;( &#51068;&#48512;&#48516;&#47564; &#44032;&#45733;) . train = train.rename( columns = { &#39;PassengerId&#39; : &#39;passengerid&#39;, &#39;Pclass&#39; : &#39;pclass&#39; , &#39;Name&#39; : &#39;name&#39;, &#39;Sex&#39; : &#39;sex&#39;, &#39;Age&#39; : &#39;age&#39;, &#39;SibSp&#39; : &#39;sibsp&#39;, &#39;Ticket&#39; : &#39;ticket&#39; , &#39;Fare&#39; : &#39;fare&#39;, &#39;Cabin&#39; : &#39;cabin&#39;, &#39;Embarked&#39; : &#39;embarked&#39;, &#39;Parch&#39; : &#39;Parch&#39;.lower() , &#39;Survived&#39; : &#39;survived&#39;, }) . test = test.rename( columns = { &#39;PassengerId&#39; : &#39;passengerid&#39;, &#39;Pclass&#39; : &#39;pclass&#39; , &#39;Name&#39; : &#39;name&#39;, &#39;Sex&#39; : &#39;sex&#39;, &#39;Age&#39; : &#39;age&#39;, &#39;SibSp&#39; : &#39;sibsp&#39;, &#39;Ticket&#39; : &#39;ticket&#39; , &#39;Fare&#39; : &#39;fare&#39;, &#39;Cabin&#39; : &#39;cabin&#39;, &#39;Embarked&#39; : &#39;embarked&#39;, &#39;Parch&#39; : &#39;Parch&#39;.lower() , # &#39;Survived&#39; : &#39;survived&#39;, }) . &#47532;&#49828;&#53944; &#52980;&#54532;&#47532;&#54760;&#49496;&#51012; &#53685;&#54620; &#54620;&#48264;&#50640; &#49548;&#47928;&#51088; &#52376;&#47532; . train.columns . Index([&#39;passengerid&#39;, &#39;survived&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;age&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;ticket&#39;, &#39;fare&#39;, &#39;cabin&#39;, &#39;embarked&#39;], dtype=&#39;object&#39;) . [col.lower() for col in train.columns] . [&#39;passengerid&#39;, &#39;survived&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;age&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;ticket&#39;, &#39;fare&#39;, &#39;cabin&#39;, &#39;embarked&#39;] . train.columns = [col.lower() for col in train.columns] train.head() . passengerid survived pclass name sex age sibsp parch ticket fare cabin embarked . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | male | 22.0 | 1 | 0 | A/5 21171 | 7.2500 | NaN | S | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | female | 38.0 | 1 | 0 | PC 17599 | 71.2833 | C85 | C | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | female | 26.0 | 0 | 0 | STON/O2. 3101282 | 7.9250 | NaN | S | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 | 1 | 0 | 113803 | 53.1000 | C123 | S | . 4 5 | 0 | 3 | Allen, Mr. William Henry | male | 35.0 | 0 | 0 | 373450 | 8.0500 | NaN | S | . &#48276;&#51452; &lt;-&gt; &#49707;&#51088; type &#51228;&#45824;&#47196; &#46104;&#50632;&#45716;&#51648; &#54869;&#51064; . Pclass 범주인데 숫자로 | Survived 범주인데 숫자로 | Parch 도 | Sipsp 도 | . train[&#39;survived&#39;] = train[&#39;survived&#39;].astype( object ) train[&#39;pclass&#39;] = train[&#39;pclass&#39;].astype( object ) train[&#39;parch&#39;] = train[&#39;parch&#39;].astype( object ) train[&#39;sibsp&#39;] = train[&#39;sibsp&#39;].astype( object ) . test[&#39;pclass&#39;] = test[&#39;pclass&#39;].astype( object ) train[&#39;parch&#39;] = train[&#39;parch&#39;].astype( object ) train[&#39;sibsp&#39;] = train[&#39;sibsp&#39;].astype( object ) . Null &#52404;&#53356; . train.isnull().sum() . passengerid 0 survived 0 pclass 0 name 0 sex 0 age 177 sibsp 0 parch 0 ticket 0 fare 0 cabin 687 embarked 2 dtype: int64 . train.isnull().sum().reset_index() . index 0 . 0 passengerid | 0 | . 1 survived | 0 | . 2 pclass | 0 | . 3 name | 0 | . 4 sex | 0 | . 5 age | 177 | . 6 sibsp | 0 | . 7 parch | 0 | . 8 ticket | 0 | . 9 fare | 0 | . 10 cabin | 687 | . 11 embarked | 2 | . missing_df = train.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df . columns count . 0 passengerid | 0 | . 1 survived | 0 | . 2 pclass | 0 | . 3 name | 0 | . 4 sex | 0 | . 5 age | 177 | . 6 sibsp | 0 | . 7 parch | 0 | . 8 ticket | 0 | . 9 fare | 0 | . 10 cabin | 687 | . 11 embarked | 2 | . missing_df = train.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df[&#39;missing_rate&#39;] = missing_df[&#39;count&#39;] / train.shape[0] # 미싱 갯수 / 전체데이터의 데이터수 - shape(row,col)의 첫번째!! missing_df . columns count missing_rate . 0 passengerid | 0 | 0.000000 | . 1 survived | 0 | 0.000000 | . 2 pclass | 0 | 0.000000 | . 3 name | 0 | 0.000000 | . 4 sex | 0 | 0.000000 | . 5 age | 177 | 0.198653 | . 6 sibsp | 0 | 0.000000 | . 7 parch | 0 | 0.000000 | . 8 ticket | 0 | 0.000000 | . 9 fare | 0 | 0.000000 | . 10 cabin | 687 | 0.771044 | . 11 embarked | 2 | 0.002245 | . train . missing_df = train.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df[&#39;missing_rate&#39;] = missing_df[&#39;count&#39;] / train.shape[0] # 미싱 갯수 / 전체데이터의 데이터수 - shape(row,col)의 첫번째!! missing_df.loc[ missing_df[&#39;missing_rate&#39;] != 0, :] # missing_Rate가 0이 아닌 것들만 가졍괴 . columns count missing_rate . 5 age | 177 | 0.198653 | . 10 cabin | 687 | 0.771044 | . 11 embarked | 2 | 0.002245 | . test . missing_df = test.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df[&#39;missing_rate&#39;] = missing_df[&#39;count&#39;] / test.shape[0] # 미싱 갯수 / 전체데이터의 데이터수 - shape(row,col)의 첫번째!! missing_df.loc[ missing_df[&#39;missing_rate&#39;] != 0, :] # missing_Rate가 0이 아닌 것들만 가졍괴 . columns count missing_rate . 4 age | 86 | 0.205742 | . 8 fare | 1 | 0.002392 | . 9 cabin | 327 | 0.782297 | . &#51333;&#49549;&#48320;&#49688; &#54869;&#51064; &#48143; &#51333;&#49549;&#48320;&#49688;&#50640; &#45824;&#54620; &#45796;&#47480;&#48320;&#49688;&#46308; &#44288;&#44228; &#52628;&#47200; . &#51333;&#49549;&#48320;&#49688;&#51032; &#48276;&#51452;&#48324; &#48712;&#46020; &#52404;&#53356; . matplotlib &#44592;&#48376; . train[&#39;survived&#39;].value_counts().plot(kind=&#39;bar&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x259dad8add8&gt; . sns . fig, ax = plt.subplots(1, 2, # 1x2 Pieplot + barplot figsize= (12,8)) # 1 X1 Pie plot train[&#39;survived&#39;].value_counts().plot.pie( explode = [0, 0.1], autopct = &#39;%1.1f%%&#39;, # 퍼센트는 소수점1자리까지 ax = ax[0], shadow = True ) ax[0].set_title(&#39;Pie plot&#39;) ax[0].set_ylabel(&#39;&#39;) # # 1 X 2 bar plot (sns.countplot) # train[&#39;survived&#39;].value_counts().plot( # kind= &#39;bar&#39;, # ax = ax[1], # ) sns.countplot( &#39;survived&#39;, #칼럼명 data = train, # df ax = ax[1] # 좌표평면 ) plt.tight_layout() . import relationship as r r.categorical_all(train, &#39;survived&#39;) . 0 549 1 342 Name: survived, dtype: int64 . &#45800;&#48320;&#49688; &#53456;&#49353;1 : &#48276;&#51452;&#54805; &#52860;&#47100;&#51032; &#48712;&#46020; . &#48276;&#51452;&#54805; &#52860;&#47100;&#47749;&#47564; &#44032;&#51256;&#50724;&#44592; &amp; id&#50752; &#51333;&#49549;&#48320;&#49688; &#51228;&#50808;&#49884;&#53412;&#44592; . train[&#39;survived&#39;].dtypes . train[&#39;survived&#39;].dtypes == &quot;object&quot; . category_feature = [ col for col in train.columns if train[col].dtypes == &quot;object&quot;] category_feature . [&#39;survived&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;ticket&#39;, &#39;cabin&#39;, &#39;embarked&#39;] . id&#52860;&#47100;&#44284; &#51333;&#49549;&#48320;&#49688;&#52860;&#47100; &#51228;&#50808;&#49884;&#53412;&#44592; by set . # set으로 마이너스 연산을 한 뒤, list()로 감싸서 다시 리스트로 만든다. categorical_feature = list( set(category_feature) - set( [&#39;passengerid&#39;, &#39;survived&#39;]) ) categorical_feature . [&#39;embarked&#39;, &#39;ticket&#39;, &#39;parch&#39;, &#39;cabin&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;sibsp&#39;] . &#48276;&#51452;&#52860;&#47100;&#47749; &#47532;&#49828;&#53944;&#47484; &#51060;&#50857;&#54620; &#48276;&#51452;&#52860;&#47100;&#46308; &#54620;&#44732;&#48264;&#50640; &#48712;&#46020; &#48372;&#44592; . for col in categorical_feature: f, ax = plt.subplots(1, 1, figsize=(10,7)) sns.countplot( col, #칼럼명 data = train, # df ) plt.title(col) plt.show() # 여러개 그림을 한셀에 띄울 때, plt.show()를 통해 하나씩 끊어주기! . &#54632;&#49688;&#54868;&#54616;&#44592; ( &#45800;&#48320;&#49688; &#48276;&#51452;&#54805; &#52860;&#47100;&#51032; &#48712;&#46020; ) with &#48276;&#51452;&#54805; &#52860;&#47100;&#47749; &#47532;&#49828;&#53944; . def categorical_all(df, categorical_feature): # 칼럼명 하나만 입력시 if type(categorical_feature) is str: sns.countplot( categorical_feature, #칼럼명 1개 data = df, # df ) plt.title(categorical_feature) #칼럼명 1개 plt.tight_layout() plt.show() # 여러개 그림을 한셀에 띄울 때, plt.show()를 통해 하나씩 끊어주기! else: # 범주형 칼럼명 리스트가 들어왔을 때 for col in categorical_feature: sns.countplot( col, #칼럼명 data = df, # df ) plt.title(col) plt.tight_layout() plt.show() # 여러개 그림을 한셀에 띄울 때, plt.show()를 통해 하나씩 끊어주기! . categorical_all(train, &#39;cabin&#39;) . categorical_all(train, categorical_feature) . &#45800;&#48320;&#49688; &#53456;&#49353;2 : &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252; . &#49707;&#51088;&#54805; &#52860;&#47100;&#47749; &#44032;&#51256;&#50724;&#44592; = &#51204;&#52404;&#52860;&#47100; - &#48276;&#51452;&#54805;&#52860;&#47100; - (id+&#51333;&#49549;&#48320;&#49688;) . train.head() . passengerid survived pclass name sex age sibsp parch ticket fare cabin embarked . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | male | 22.0 | 1 | 0 | A/5 21171 | 7.2500 | NaN | S | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | female | 38.0 | 1 | 0 | PC 17599 | 71.2833 | C85 | C | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | female | 26.0 | 0 | 0 | STON/O2. 3101282 | 7.9250 | NaN | S | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 | 1 | 0 | 113803 | 53.1000 | C123 | S | . 4 5 | 0 | 3 | Allen, Mr. William Henry | male | 35.0 | 0 | 0 | 373450 | 8.0500 | NaN | S | . numerical_feature = list( set(train.columns) - set(categorical_feature) - set([&#39;passengerid&#39;, &#39;survived&#39;]) ) numerical_feature . [&#39;age&#39;, &#39;fare&#39;] . np.sort(numerical_feature) . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . numerical_feature = list( set(train.columns) - set(categorical_feature) - set([&#39;passengerid&#39;, &#39;survived&#39;]) ) numerical_feature = np.sort(numerical_feature) numerical_feature . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252; sns.distplot &#54620;&#44732;&#48264;&#50640; &#44536;&#47532;&#44592; . for col in numerical_feature: print(train[col].describe()) sns.distplot( train.loc[train[col].notnull(), col] ) # 해당칼럼 중 NaN아닌것만 인덱싱한 칼럼만 그리기 plt.title(col) plt.show() . count 714.000000 mean 29.699118 std 14.526497 min 0.420000 25% 20.125000 50% 28.000000 75% 38.000000 max 80.000000 Name: age, dtype: float64 . count 891.000000 mean 32.204208 std 49.693429 min 0.000000 25% 7.910400 50% 14.454200 75% 31.000000 max 512.329200 Name: fare, dtype: float64 . &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252;2 boxplot . for col in numerical_feature: print(train[col].describe()) sns.boxplot( data=train.loc[train[col].notnull(), col] ) plt.title(col) plt.show() . count 714.000000 mean 29.699118 std 14.526497 min 0.420000 25% 20.125000 50% 28.000000 75% 38.000000 max 80.000000 Name: age, dtype: float64 . count 891.000000 mean 32.204208 std 49.693429 min 0.000000 25% 7.910400 50% 14.454200 75% 31.000000 max 512.329200 Name: fare, dtype: float64 . &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252;( hist(dist) + boxplot ) &#54620;&#48264;&#50640; &#44536;&#47532;&#44592; . for col in numerical_feature: # 숫자형 칼럼의 기술통계량 print(train[col].describe()) print(f&quot;Skewed : {train[col].skew():.2f}&quot;) f, ax = plt.subplots(1, 2, figsize=(18,9)) # dist sns.distplot( train.loc[train[col].notnull(), col], ax = ax[0] ) ax[0].set_title(col +&#39; &#39;s hist(dist) plot&#39; ) # boxplot sns.boxplot( data=train.loc[train[col].notnull(), col], ax = ax[1] ) ax[1].set_title(col +&#39; &#39;s boxplot&#39;) plt.tight_layout() plt.show() . count 714.000000 mean 29.699118 std 14.526497 min 0.420000 25% 20.125000 50% 28.000000 75% 38.000000 max 80.000000 Name: age, dtype: float64 Skewed : 0.39 . count 891.000000 mean 32.204208 std 49.693429 min 0.000000 25% 7.910400 50% 14.454200 75% 31.000000 max 512.329200 Name: fare, dtype: float64 Skewed : 4.79 . &#54632;&#49688;&#54868;&#54616;&#44592; ( &#45800;&#48320;&#49688; &#49707;&#51088;&#54805; &#48516;&#54252; dist+boxplot ) with &#49707;&#51088;&#54805; &#52860;&#47100;&#47749; &#47532;&#49828;&#53944; . def numerical_all(df, numerical_feature): for col in numerical_feature: # 숫자형 칼럼의 기술통계량 print(df[col].describe()) print(f&quot;Skewed : {train[col].skew():.2f}&quot;) f, ax = plt.subplots(1, 2, figsize=(18,9)) # dist sns.distplot( df.loc[train[col].notnull(), col], ax = ax[0] ) ax[0].set_title(col +&#39; &#39;s hist(dist) plot&#39; ) ax[0].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 # boxplot sns.boxplot( data=df.loc[df[col].notnull(), col], ax = ax[1] ) ax[1].set_title(col +&#39; &#39;s boxplot&#39;) ax[1].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 plt.tight_layout() plt.show() . &#51060;&#48320;&#49688; &#53456;&#49353;1 : &#51333;&#49549;&#48320;&#49688;(&#48276;&#51452;)&#48324; - &#48276;&#51452;&#54805; &#48320;&#49688; . &#48169;&#48277;1: &#53945;&#51221;(&#51333;&#49549;)&#48276;&#51452;&#48324; &#48276;&#51452;&#52860;&#47100; &#51064;&#45937;&#49905;&#54616;&#50668;&#49436; &#44033; &#48276;&#51452;&#48324; series&#47484; df&#47196; &#54633;&#52824;&#44592; . survived = train.loc[ train[&#39;survived&#39;] == 0,&#39;sex&#39; ].value_counts() survived.name = &#39;Survived&#39; dead = train.loc[ train[&#39;survived&#39;] == 1,&#39;sex&#39; ].value_counts() dead.name = &#39;Dead&#39; # 시리즈를 리스트형식으로 df합치기 df = pd.DataFrame( [ survived, dead] ) df.head() . male female . Survived 468 | 81 | . Dead 109 | 233 | . print(df) df.plot(kind=&#39;bar&#39;) . male female Survived 468 81 Dead 109 233 . &lt;matplotlib.axes._subplots.AxesSubplot at 0x2962005c550&gt; . &#48169;&#48277;2 : pd.crosstab &#51004;&#47196; &#44536;&#47532;&#44592; . &#48712;&#46020; . pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;]) . survived 0 1 . sex . female 81 | 233 | . male 468 | 109 | . pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;]).plot(kind=&#39;barh&#39;, stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x296212901d0&gt; . pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;], margins = True).style.background_gradient(cmap=&#39;summer_r&#39;) . survived 0 1 All . sex . female 81 | 233 | 314 | . male 468 | 109 | 577 | . All 549 | 342 | 891 | . &#48708;&#50984; . cross = pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;]) cross_ratio = cross / cross.sum() cross_ratio . survived 0 1 . sex . female 0.147541 | 0.681287 | . male 0.852459 | 0.318713 | . cross_ratio.plot(kind=&#39;bar&#39;, stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cfa31ef0&gt; . cross_ratio.transpose().plot(kind=&#39;bar&#39;, stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cfd34eb8&gt; . &#48169;&#48277;3 : groupby( &#48276;&#51452;) [ &#51333;&#49549;&#48320;&#49688;].&#51665;&#44228;.unstack() - &#48712;&#46020;+&#54217;&#44512;&#46020; &#44032;&#45733; + &#44032;&#49345;df&#47196;&#49436; apply()&#47196; &#48708;&#50984;&#44228;&#49328;&#44032;&#45733;&#54632; . &#48712;&#46020; . sex_to_survived = train.groupby(&#39;sex&#39;) [&#39;survived&#39;].value_counts().unstack() sex_to_survived . survived 0 1 . sex . female 81 | 233 | . male 468 | 109 | . sex_to_survived.plot(kind=&#39;bar&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cf4b85f8&gt; . &#48708;&#50984; : groupby( [&#39;&#48276;&#51452;&#39; ,&#39;&#51333;&#49549;&#39;]) [&#39;&#51333;&#49549;&#39;] &#51004;&#47196; &#48708;&#50984; &#44228;&#49328;&#54616;&#44592; . 비율을 계산하려면, 숫자칼럼 형태( 범주에서 counts() .unstack()도 먹인상태) | .count().unstack() : 범주별, 종속별, 종속의 범주마다 row단순 count -&gt; 칼럼으로 | .count().unstack() 한 것을 칼럼별로 계산하도록 df/df.sum() 으로 비율계산 | .transpose() 를 통해 index = x축에 종속변수가 가야 비율이 가득찬다 | . dict( list( train.groupby([&#39;sex&#39;, &#39;survived&#39;]) ) ).keys() . dict_keys([(&#39;female&#39;, 0), (&#39;female&#39;, 1), (&#39;male&#39;, 0), (&#39;male&#39;, 1)]) . dict( list( train.groupby([&#39;sex&#39;, &#39;survived&#39;]) ) )[&#39;female&#39;, 0].head() . passengerid survived pclass name sex age sibSp parch ticket fare cabin embarked . 14 15 | 0 | 3 | Vestrom, Miss. Hulda Amanda Adolfina | female | 14.0 | 0 | 0 | 350406 | 7.8542 | NaN | S | . 18 19 | 0 | 3 | Vander Planke, Mrs. Julius (Emelia Maria Vande... | female | 31.0 | 1 | 0 | 345763 | 18.0000 | NaN | S | . 24 25 | 0 | 3 | Palsson, Miss. Torborg Danira | female | 8.0 | 3 | 1 | 349909 | 21.0750 | NaN | S | . 38 39 | 0 | 3 | Vander Planke, Miss. Augusta Maria | female | 18.0 | 2 | 0 | 345764 | 18.0000 | NaN | S | . 40 41 | 0 | 3 | Ahlin, Mrs. Johan (Johanna Persdotter Larsson) | female | 40.0 | 1 | 0 | 7546 | 9.4750 | NaN | S | . train.groupby(&#39;sex&#39;)[&#39;survived&#39;].value_counts() . sex survived female 1 233 0 81 male 0 468 1 109 Name: survived, dtype: int64 . cross_df = train.groupby(&#39;sex&#39;) [&#39;survived&#39;].value_counts().unstack() cross_ratio = cross_df / cross_df.sum() cross_ratio . survived 0 1 . sex . female 0.147541 | 0.681287 | . male 0.852459 | 0.318713 | . cross_ratio.transpose().plot(kind=&#39;bar&#39;, stacked=True, figsize=(10,8)) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196d17e84a8&gt; . &#48169;&#48277;4 : sns.countplot( &#39;&#48276;&#51452;&#52860;&#47100;&#39; , hue= &#39;&#51333;&#49549;&#48320;&#49688;&#39; ) -&gt; &#48708;&#50984;&#51008; &#48380; &#49688; &#50630;&#45796; . sns.countplot(&#39;sex&#39;, data = train, hue=&#39;survived&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cfa68080&gt; . &#48276;&#51452;-&#51333;&#49549;(&#48276;&#51452;) &#51333;&#49549;&#48320;&#49688;&#48324; &#48276;&#51452;&#51032; &#48708;&#50984; &#54620;&#48264;&#50640; &#44536;&#47532;&#44592; . cross_df = train.groupby(&#39;pclass&#39;)[&#39;survived&#39;].value_counts().unstack() # 세로로 합하고, 칼럼별로 나누어 비율계산하기 print(pd.DataFrame(cross_df)) cross_ratio = cross_df/ cross_df.sum() # 세로방향기준으로 각 비율이 나눠져있는데, 그냥 그리면 row별로 x축에 틱이 찍힘 # 뒤집기 cross_ratio = cross_ratio.transpose() cross_ratio.plot(kind=&#39;bar&#39;, stacked=True, figsize=(10,5)) . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . &lt;matplotlib.axes._subplots.AxesSubplot at 0x1dd55006e48&gt; . &#51333;&#49549;-&#48276;&#51452;&#54805;&#48320;&#49688; &#44288;&#44228; &#54632;&#49688;&#51221;&#51032;&#54616;&#44592; . def cate_to_categorical(data,name_c, name_d ): # index 범주형 변수/ col 종속 변수 cross_df = data.groupby( name_c)[name_d].value_counts().unstack() # 세로로 합하고, 칼럼별로 나누어 비율계산하기 print(cross_df) cross_ratio = cross_df/ cross_df.sum() # 세로방향기준으로 각 비율이 나눠져있는데, 그냥 그리면 row별로 x축에 틱이 찍힘 # 뒤집기 cross_ratio = cross_ratio.transpose() f, ax = plt.subplots(1, 2, figsize=(18,9)) cross_df.plot(kind=&#39;bar&#39;, ax=ax[0]) ax[0].set_title(name_c +&#39; to &#39; +name_d ) ax[0].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 cross_ratio.plot(kind=&#39;bar&#39;, ax = ax[1], stacked=True) ax[1].set_title(name_d +&#39; to &#39;+name_c +&#39; ratio&#39; ) ax[1].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0)) # 범례 밖으로 빼기 plt.tight_layout() plt.show() # for문에 들어갈 것 대비 끝내기 . relationship_new.cate_to_categorical(train, &#39;survived&#39;, &#39;sex&#39;) . survived 0 1 sex female 81 233 male 468 109 . cate_to_categorical(train, &#39;survived&#39;, &#39;pclass&#39;) . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . import relationship_new relationship_new.cate_to_categorical(train, &#39;survived&#39;, &#39;pclass&#39;) . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . relationship_new.cate_to_categorical(train, &#39;survived&#39;, &#39;parch&#39;) . survived 0 1 parch 0 445.0 233.0 1 53.0 65.0 2 40.0 40.0 3 2.0 3.0 4 4.0 NaN 5 4.0 1.0 6 1.0 NaN . for+&#54632;&#49688;(&#48276;&#51452;-&#48276;&#51452;)&#47928;&#51012; &#53685;&#54644; &#47784;&#46304; &#51333;&#49549;&#52860;&#47100;&#50640; &#45824;&#54644; &#47784;&#46304; &#48276;&#51452;&#52860;&#47100;&#51032; &#48516;&#54252;&#50752; &#48708;&#50984; &#44536;&#47140;&#48372;&#44592; . 범주가 너무 많을때는 금지!! feature engineering | . for col in categorical_feature: relationship_new.cate_to_categorical(train, &#39;survived&#39;, col) . survived 0 1 embarked C 75 93 Q 47 30 S 427 217 . survived 0 1 sex female 81 233 male 468 109 . survived 0 1 name Abbing, Mr. Anthony 1.0 NaN Abbott, Mr. Rossmore Edward 1.0 NaN Abbott, Mrs. Stanton (Rosa Hunt) NaN 1.0 Abelson, Mr. Samuel 1.0 NaN Abelson, Mrs. Samuel (Hannah Wizosky) NaN 1.0 Adahl, Mr. Mauritz Nils Martin 1.0 NaN Adams, Mr. John 1.0 NaN Ahlin, Mrs. Johan (Johanna Persdotter Larsson) 1.0 NaN Aks, Mrs. Sam (Leah Rosen) NaN 1.0 Albimona, Mr. Nassef Cassem NaN 1.0 Alexander, Mr. William 1.0 NaN Alhomaki, Mr. Ilmari Rudolf 1.0 NaN Ali, Mr. Ahmed 1.0 NaN Ali, Mr. William 1.0 NaN Allen, Miss. Elisabeth Walton NaN 1.0 Allen, Mr. William Henry 1.0 NaN Allison, Master. Hudson Trevor NaN 1.0 Allison, Miss. Helen Loraine 1.0 NaN Allison, Mrs. Hudson J C (Bessie Waldo Daniels) 1.0 NaN Allum, Mr. Owen George 1.0 NaN Andersen-Jensen, Miss. Carla Christine Nielsine NaN 1.0 Anderson, Mr. Harry NaN 1.0 Andersson, Master. Sigvard Harald Elias 1.0 NaN Andersson, Miss. Ebba Iris Alfrida 1.0 NaN Andersson, Miss. Ellis Anna Maria 1.0 NaN Andersson, Miss. Erna Alexandra NaN 1.0 Andersson, Miss. Ingeborg Constanzia 1.0 NaN Andersson, Miss. Sigrid Elisabeth 1.0 NaN Andersson, Mr. Anders Johan 1.0 NaN Andersson, Mr. August Edvard (&#34;Wennerstrom&#34;) NaN 1.0 ... ... ... Widegren, Mr. Carl/Charles Peter 1.0 NaN Widener, Mr. Harry Elkins 1.0 NaN Wiklund, Mr. Jakob Alfred 1.0 NaN Wilhelms, Mr. Charles NaN 1.0 Willey, Mr. Edward 1.0 NaN Williams, Mr. Charles Duane 1.0 NaN Williams, Mr. Charles Eugene NaN 1.0 Williams, Mr. Howard Hugh &#34;Harry&#34; 1.0 NaN Williams, Mr. Leslie 1.0 NaN Williams-Lambert, Mr. Fletcher Fellows 1.0 NaN Windelov, Mr. Einar 1.0 NaN Wiseman, Mr. Phillippe 1.0 NaN Woolner, Mr. Hugh NaN 1.0 Wright, Mr. George 1.0 NaN Yasbeck, Mr. Antoni 1.0 NaN Yasbeck, Mrs. Antoni (Selini Alexander) NaN 1.0 Young, Miss. Marie Grice NaN 1.0 Youseff, Mr. Gerious 1.0 NaN Yousif, Mr. Wazli 1.0 NaN Yousseff, Mr. Gerious 1.0 NaN Yrois, Miss. Henriette (&#34;Mrs Harbeck&#34;) 1.0 NaN Zabour, Miss. Hileni 1.0 NaN Zabour, Miss. Thamine 1.0 NaN Zimmerman, Mr. Leo 1.0 NaN de Messemaeker, Mrs. Guillaume Joseph (Emma) NaN 1.0 de Mulder, Mr. Theodore NaN 1.0 de Pelsmaeker, Mr. Alfons 1.0 NaN del Carlo, Mr. Sebastiano 1.0 NaN van Billiard, Mr. Austin Blyler 1.0 NaN van Melkebeke, Mr. Philemon 1.0 NaN [891 rows x 2 columns] . C: Users is2js Anaconda3 lib site-packages matplotlib tight_layout.py:181: UserWarning: Tight layout not applied. The bottom and top margins cannot be made large enough to accommodate all axes decorations. warnings.warn(&#39;Tight layout not applied. &#39; . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . survived 0 1 cabin A10 1.0 NaN A14 1.0 NaN A16 NaN 1.0 A19 1.0 NaN A20 NaN 1.0 A23 NaN 1.0 A24 1.0 NaN A26 NaN 1.0 A31 NaN 1.0 A32 1.0 NaN A34 NaN 1.0 A36 1.0 NaN A5 1.0 NaN A6 NaN 1.0 A7 1.0 NaN B101 NaN 1.0 B102 1.0 NaN B18 NaN 2.0 B19 1.0 NaN B20 NaN 2.0 B22 1.0 1.0 B28 NaN 2.0 B3 NaN 1.0 B30 1.0 NaN B35 NaN 2.0 B37 1.0 NaN B38 1.0 NaN B39 NaN 1.0 B4 NaN 1.0 B41 NaN 1.0 ... ... ... E12 NaN 1.0 E121 NaN 2.0 E17 NaN 1.0 E24 NaN 2.0 E25 NaN 2.0 E31 1.0 NaN E33 NaN 2.0 E34 NaN 1.0 E36 NaN 1.0 E38 1.0 NaN E40 NaN 1.0 E44 1.0 1.0 E46 1.0 NaN E49 NaN 1.0 E50 NaN 1.0 E58 1.0 NaN E63 1.0 NaN E67 1.0 1.0 E68 NaN 1.0 E77 1.0 NaN E8 NaN 2.0 F E69 NaN 1.0 F G63 1.0 NaN F G73 2.0 NaN F2 1.0 2.0 F33 NaN 3.0 F38 1.0 NaN F4 NaN 2.0 G6 2.0 2.0 T 1.0 NaN [147 rows x 2 columns] . C: Users is2js Anaconda3 lib site-packages matplotlib tight_layout.py:181: UserWarning: Tight layout not applied. The bottom and top margins cannot be made large enough to accommodate all axes decorations. warnings.warn(&#39;Tight layout not applied. &#39; . survived 0 1 ticket 110152 NaN 3.0 110413 1.0 2.0 110465 2.0 NaN 110564 NaN 1.0 110813 NaN 1.0 111240 1.0 NaN 111320 1.0 NaN 111361 NaN 2.0 111369 NaN 1.0 111426 NaN 1.0 111427 NaN 1.0 111428 NaN 1.0 112050 1.0 NaN 112052 1.0 NaN 112053 NaN 1.0 112058 1.0 NaN 112059 1.0 NaN 112277 NaN 1.0 112379 1.0 NaN 113028 1.0 NaN 113043 1.0 NaN 113050 1.0 NaN 113051 1.0 NaN 113055 NaN 1.0 113056 1.0 NaN 113059 1.0 NaN 113501 1.0 NaN 113503 1.0 NaN 113505 NaN 2.0 113509 1.0 NaN ... ... ... SOTON/OQ 392082 1.0 NaN SOTON/OQ 392086 1.0 NaN SOTON/OQ 392089 NaN 1.0 SOTON/OQ 392090 1.0 NaN STON/O 2. 3101269 NaN 1.0 STON/O 2. 3101273 1.0 NaN STON/O 2. 3101274 1.0 NaN STON/O 2. 3101275 1.0 NaN STON/O 2. 3101280 1.0 NaN STON/O 2. 3101285 NaN 1.0 STON/O 2. 3101286 NaN 1.0 STON/O 2. 3101288 NaN 1.0 STON/O 2. 3101289 NaN 1.0 STON/O 2. 3101292 1.0 NaN STON/O 2. 3101293 1.0 NaN STON/O 2. 3101294 1.0 NaN STON/O2. 3101271 1.0 NaN STON/O2. 3101279 1.0 1.0 STON/O2. 3101282 NaN 1.0 STON/O2. 3101283 NaN 1.0 STON/O2. 3101290 1.0 NaN SW/PP 751 NaN 1.0 W./C. 14258 NaN 1.0 W./C. 14263 1.0 NaN W./C. 6607 2.0 NaN W./C. 6608 4.0 NaN W./C. 6609 1.0 NaN W.E.P. 5734 1.0 NaN W/C 14208 1.0 NaN WE/P 5735 1.0 1.0 [681 rows x 2 columns] . C: Users is2js Anaconda3 lib site-packages matplotlib tight_layout.py:181: UserWarning: Tight layout not applied. The bottom and top margins cannot be made large enough to accommodate all axes decorations. warnings.warn(&#39;Tight layout not applied. &#39; . &#51060;&#48320;&#49688; &#53456;&#49353;2 &#49707;&#51088;-&#49707;&#51088;&#54805;&#51032; &#49328;&#51216;&#46020;&#54665;&#47148; with &#51333;&#49549;&#48320;&#49688; . numerical_feature . array([&#39;age&#39;, &#39;fare&#39;, &#39;parch&#39;, &#39;sibsp&#39;], dtype=&#39;&lt;U5&#39;) . # list는 (-)연산은 안되도 (+) 연산은 된다. list(numerical_feature) + [&#39;survived&#39;] . [&#39;age&#39;, &#39;fare&#39;, &#39;parch&#39;, &#39;sibsp&#39;, &#39;survived&#39;] . sns.pairplot( train[ list(numerical_feature) + [&#39;survived&#39;] ], hue = &#39;survived&#39;, x_vars = numerical_feature, y_vars = numerical_feature) . C: Users is2js Anaconda3 lib site-packages statsmodels nonparametric kde.py:448: RuntimeWarning: invalid value encountered in greater X = X[np.logical_and(X &gt; clip[0], X &lt; clip[1])] # won&#39;t work for two columns. C: Users is2js Anaconda3 lib site-packages statsmodels nonparametric kde.py:448: RuntimeWarning: invalid value encountered in less X = X[np.logical_and(X &gt; clip[0], X &lt; clip[1])] # won&#39;t work for two columns. . &lt;seaborn.axisgrid.PairGrid at 0x296230e9828&gt; . &#54632;&#49688;&#54868;( &#49707;&#51088; - &#49707;&#51088;&#51032; &#49328;&#51216;&#46020; &#54665;&#47148; : pairplot) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) by &#49707;&#51088;&#54805;&#52860;&#47100;&#47749;&#47532;&#49828;&#53944; . type(numerical_feature) . numpy.ndarray . list().dtype . AttributeError Traceback (most recent call last) &lt;ipython-input-119-0901fc39190d&gt; in &lt;module&gt; -&gt; 1 list().dtype AttributeError: &#39;list&#39; object has no attribute &#39;dtype&#39; . numerical_feature . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . type(list(numerical_feature)) is list . True . len(numerical_feature) . 2 . def num_to_numerical(df, numerical_feature, name_d=None): # 종속변수 없을 때 if name_d == None: sns.pairplot( df[ list(numerical_feature) ] , # 숫자형칼럼들만 인덱싱 x_vars = numerical_feature, y_vars = numerical_feature ) plt.tight_layout() # 숫자 - 숫자 산점도 행렬 with 종속변수 범례 else: sns.pairplot( df[ list(numerical_feature) + [name_d]] , # 숫자형칼럼들 + 종속변수 인덱싱 hue = name_d, # 범례(색)으로 종속변수 추가 x_vars = numerical_feature, y_vars = numerical_feature ) plt.tight_layout() . num_to_numerical(train, {&#39;age&#39;, &#39;fare&#39;}, &#39;survived&#39;) . &#51060;&#48320;&#49688; &#53456;&#49353;3 : &#48276;&#51452;&#48324; - &#49707;&#51088;&#54805; &#52860;&#47100;(&#46308;)&#51032; &#48516;&#54252;(boxplot) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) by &#49707;&#51088;&#54805;&#52860;&#47100;&#47749;&#47532;&#49828;&#53944; . &#48276;&#51452;&#48324; &#49707;&#51088;&#52860;&#47100;1&#44060;&#51032; &#48516;&#54252;(boxplot) . print(train.groupby(&#39;sex&#39;)[&#39;age&#39;].describe()) plt.figure(figsize=(18,9)) sns.boxplot(x=&#39;sex&#39;, y=&#39;age&#39;, data=train.dropna()) plt.title(&quot;Sex - { }&quot;.format(&#39;age&#39;)) plt.show() . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . KeyError Traceback (most recent call last) &lt;ipython-input-277-1a8c01f185d7&gt; in &lt;module&gt; 2 plt.figure(figsize=(18,9)) 3 sns.boxplot(x=&#39;sex&#39;, y=&#39;age&#39;, data=train.dropna()) -&gt; 4 plt.title(&#34;Sex - { }&#34;.format(&#39;age&#39;)) 5 plt.show() KeyError: &#39; &#39; . &#54632;&#49688;&#54868;(&#48276;&#51452;&#48324; &#49707;&#51088;&#52860;&#47100;1&#44060;&#51032; &#48516;&#54252;(boxplot)) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) . def cate_to_num_box(df, name_c, name_n, name_d=None): # 범주별 기술통계량 if name_d != None: print(df.groupby([name_c, name_d])[name_n].describe()) else : print(df.groupby(name_c)[name_n].describe()) # 범주별 boxplot - 범례는 선택 plt.figure(figsize=(18,9)) sns.boxplot(x=name_c, y=name_n, data=df.dropna(), hue = name_d) plt.title(&quot;{} to {}&quot;.format(name_c, name_n)) plt.tight_layout() plt.show() . cate_to_num_box(train, &#39;sex&#39;, &#39;age&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . type(numerical_feature) . numpy.ndarray . type(&quot;age&quot;) . str . &#54632;&#49688;&#54868;( &#48276;&#51452;&#48324; - &#49707;&#51088;&#52860;&#47100;(&#46308;)&#51032; &#48516;&#54252;(boxplot)) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) . def cate_to_num_box(df, name_c, numerical_feature, name_d=None): # 숫자형 칼럼명 1개 ( 칼럼명 = 문자열 1개 직접 입력) if type(numerical_feature) is str: # 범주별 기술통계량 if name_d != None: print(df.groupby([name_c, name_d])[numerical_feature].describe()) else : print(df.groupby(name_c)[numerical_feature].describe()) # 범주별 boxplot - 범례는 선택 plt.figure(figsize=(18,9)) sns.boxplot(x=name_c, y=numerical_feature, data=df.dropna(), hue = name_d) plt.title(&quot;{} to {}&quot;.format(name_c, numerical_feature)) plt.tight_layout() plt.show() # 숫자형 칼럼명 리스트가 들어와서 for문을 돌면서 여러개 그릴 때 else : for col in numerical_feature: if name_d != None: print(df.groupby([name_c, name_d])[col].describe()) else : print(df.groupby(name_c)[col].describe()) plt.figure(figsize=(18,9)) sns.boxplot(x=name_c, # 범주칼럼명 y=col, # 숫자칼럼명 data=df.dropna() , # df hue = name_d ) # 종속칼럼명(선택) plt.title(&quot;{} to {}&quot;.format(name_c, col)) plt.tight_layout() plt.show() . cate_to_num_box(train, &#39;sex&#39;, &#39;age&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . cate_to_num_box(train, &#39;sex&#39;, &#39;age&#39;, &#39;pclass&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 count mean std min 25% 50% 75% max sex pclass female 1 85.0 34.611765 13.612052 2.00 23.000 35.0 44.00 63.0 2 74.0 28.722973 12.872702 2.00 22.250 28.0 36.00 57.0 3 102.0 21.750000 12.729964 0.75 14.125 21.5 29.75 63.0 male 1 101.0 41.281386 15.139570 0.92 30.000 40.0 51.00 80.0 2 99.0 30.740707 14.793894 0.67 23.000 30.0 36.75 70.0 3 253.0 26.507589 12.159514 0.42 20.000 25.0 33.00 74.0 . numerical_feature . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . cate_to_num_box(train, &#39;sex&#39;, numerical_feature, &#39;pclass&#39;) . count mean std min 25% 50% 75% max sex pclass female 1 85.0 34.611765 13.612052 2.00 23.000 35.0 44.00 63.0 2 74.0 28.722973 12.872702 2.00 22.250 28.0 36.00 57.0 3 102.0 21.750000 12.729964 0.75 14.125 21.5 29.75 63.0 male 1 101.0 41.281386 15.139570 0.92 30.000 40.0 51.00 80.0 2 99.0 30.740707 14.793894 0.67 23.000 30.0 36.75 70.0 3 253.0 26.507589 12.159514 0.42 20.000 25.0 33.00 74.0 . count mean std min 25% 50% sex pclass female 1 94.0 106.125798 74.259988 25.9292 57.24480 82.66455 2 76.0 21.970121 10.891796 10.5000 13.00000 22.00000 3 144.0 16.118810 11.690314 6.7500 7.85420 12.47500 male 1 122.0 67.226127 77.548021 0.0000 27.72810 41.26250 2 108.0 19.741782 14.922235 0.0000 12.33125 13.00000 3 347.0 12.661633 11.681696 0.0000 7.75000 7.92500 75% max sex pclass female 1 134.500000 512.3292 2 26.062500 65.0000 3 20.221875 69.5500 male 1 78.459375 512.3292 2 26.000000 73.5000 3 10.008300 69.5500 . &#51060;&#48320;&#49688; &#53456;&#49353;4 : &#48276;&#51452;&#48324; &#49707;&#51088;&#54805;&#52860;&#47100;&#51032; &#48276;&#50948;&#48324; kde&#48516;&#54252; &#53456;&#49353; . facet = sns.FacetGrid(train, hue = &#39;survived&#39;, height = 4.5,aspect=4) facet.map(sns.kdeplot, &#39;age&#39;, shade=True) facet.set(xlim = (0, train[&#39;age&#39;].max())) facet.add_legend() . &lt;seaborn.axisgrid.FacetGrid at 0x2241e1602b0&gt; . facet = sns.FacetGrid(train, hue = &#39;survived&#39;, aspect=4) facet.map(sns.kdeplot, &#39;age&#39;, shade=True) facet.set(xlim = (0, train[&#39;age&#39;].max())) facet.add_legend() plt.xlim([10,20]) . (10, 20) . &#54632;&#49688;&#54868; . # ( dataFrame, &#39;범주형 칼럼명&#39; , &#39;숫자형 칼럼명&#39; ) or # ( dataFrame, &#39;범주형 칼럼명&#39; , &#39;숫자형 칼럼명&#39; , xlim = [ a, b ] ) def cate_to_num_kde(df, name_c, name_n, xlim = None ): print(df.groupby(name_c)[name_n].describe()) facet = sns.FacetGrid(df.dropna(), hue = name_c, aspect=4) # df 및 범주형 변수 설정 및 가로길이(aspect) facet.map(sns.kdeplot, name_n, shade=True) # kdeplot 설정 및 숫자형변수 지정 facet.set(xlim = (df[name_n].min(), df[name_n].max())) # 숫자형 변수의 최소값부터 최대값까지 x범위 최초 지정 facet.add_legend() if xlim != None: print( &#39;범위지정 : {}&#39;.format(xlim)) plt.xlim(xlim) # xlim 지정시 그 범위만 출력 . cate_to_num_kde(train, &#39;sex&#39;, &#39;age&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . cate_to_num_kde(train, &#39;sex&#39;, &#39;age&#39;, xlim = [20, 30]) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 범위지정 : [20, 30] . &#49340;&#48320;&#49688; &#53456;&#49353;1 : &#48276;&#51452;2(&#48276;&#47168;)&#48324;&#47196;&#48372;&#45716; &#48276;&#51452;1(x&#52629;)&#48324; --&gt; &#50672;&#49549;(&#51333;&#49549;)&#48320;&#49688; &#51032; &#48708;&#50984; . 범주1이 종속변수에 끼는 영향에 대해 범주2(범례)의 영향이 있는지(크로스) 없는지(평행) 판단 | . # https://kaggle-kr.tistory.com/17?category=821486 sns.catplot(&#39;sex&#39;, &#39;survived&#39;, hue=&#39;pclass&#39;, data=train, kind=&#39;point&#39;, # default kind - factorplot height=6, aspect=1.5) . &lt;seaborn.axisgrid.FacetGrid at 0x1dd548ba160&gt; . &#54632;&#49688;&#54868; . def legend_to_cate_to_num(df, name_l, name_c, name_n): sns.catplot(name_c, name_n, hue=name_l, data=df, kind=&#39;point&#39;, # default kind - factorplot height=6, aspect=1.5) plt.tight_layout() plt.show() . legend_to_cate_to_num(train, &#39;sex&#39;, &#39;pclass&#39;, &#39;survived&#39;) . &#49340;&#48320;&#49688; &#53456;&#49353;2 : &#48276;&#47168;&#48324;(&#51333;&#49549;&#48320;&#49688;)&#48324;&#47196; &#48372;&#45716; &#48276;&#51452;&#48324;(x&#52629;) &#49707;&#51088;&#54805;(y&#52629;-&#48148;&#51060;&#50732;&#47536;)&#51032; &#48516;&#54252; . sns.violinplot(&quot;pclass&quot;,&quot;age&quot;, hue=&quot;survived&quot;, data=train, scale=&#39;count&#39;, split=True) plt.legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 plt.tight_layout() plt.show() # for문에 들어갈 것 대비 . &#54632;&#49688;&#54868;(&#48276;&#47168;&#48324;(&#51333;&#49549;&#48320;&#49688;)&#48324;&#47196; &#48372;&#45716; &#48276;&#51452;&#48324;(x&#52629;) &#49707;&#51088;&#54805;(y&#52629;-&#48148;&#51060;&#50732;&#47536;)&#51032; &#48516;&#54252;) . def legend_to_cate_to_num_violin(df,name_l, name_c, name_n): sns.violinplot(name_c,name_n, hue=name_l, data=df, scale=&#39;count&#39;, split=True) plt.legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 plt.tight_layout() plt.show() # for문에 들어갈 것 대비 . legend_to_cate_to_num_violin(train, &#39;survived&#39;, &#39;sex&#39;, &#39;age&#39;) . categorical_all(train, &#39;embarked&#39;) . cate_to_categorical(train, &#39;survived&#39;, &#39;embarked&#39;) . survived 0 1 embarked C 75 93 Q 47 30 S 427 217 .",
            "url": "blog.chojaeseong.com/data/2021/08/06/%EC%97%91%EC%85%80%EC%A0%95%EB%A6%AC-05-%EC%BA%90%EA%B8%80-1-%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89-%EB%B3%80%EC%88%98%EB%B3%84-EDA-+-%ED%95%A8%EC%88%98%EC%A0%95%EC%9D%98%EB%A1%9C-%EC%A0%95%EC%9D%98(upload).html",
            "relUrl": "/data/2021/08/06/%EC%97%91%EC%85%80%EC%A0%95%EB%A6%AC-05-%EC%BA%90%EA%B8%80-1-%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89-%EB%B3%80%EC%88%98%EB%B3%84-EDA-+-%ED%95%A8%EC%88%98%EC%A0%95%EC%9D%98%EB%A1%9C-%EC%A0%95%EC%9D%98(upload).html",
            "date": " • Aug 6, 2021"
        }
        
    
  
    
        ,"post18": {
            "title": "블로그) fastpages를 이용한 블로그 제작 정리",
            "content": "1 fastpages 만들기 . 클릭만으로 repo, actions key 생성/ 추가 merge | . google에서 fastpages검색후 &gt; 깃허브 &gt; setup instruction &gt; on this link (generating by link) . is2js(@naver.com) / 12!@ | . | 블로그 원본 내용이 들어갈 레포지토리 생성임.(github.io 아님) . is2js/blog_raw 이후 자동으로 https://is2js.github.io/blog_raw/ 로 생성된다. | . | . | 조금 기다리면, Pull Request가 자동으로 올라온다. . link클릭으로 create/clone repo + PR으로 설치까지 자동화된 것임. . | PR로 온 Initial Setup부분을 보자. merge전에 1,2,3번은 순서대로 직접 작동시켜야한다. . 1. ctrl+클릭으로 this uility를 클릭 &gt; RSA - 4096 클릭 &gt; 생성된 key 그대로 복사 . Private Key . --BEGIN RSA PRIVATE KEY-- . Publick key . ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCGIVY8FQf9x1Y52HUUJmpAyOfrzH96K4QtGb7 . | 2.도 컨트롤+클릭해서 1.에서 생성한 ssh key를 붙혀넣어 Action secret key를 만든다. . actions secrets 부분에 New repository secret을 클릭해서 붙혀넣음. Name : SSH_DEPLOY_KEY | Value : SSH RSA 4096 private key 복붙 | . | . | 3. 도 컨트롤+클릭해서 fastpages-blog의 Deploy (public) key를 생성해야한다. Add deploy key클릭 . 여기서는 생성한 ssh RSA 4096 key중에 밑에 있는 publick key를 사용한다. . Title : fastpages-blog | Key : SSH RSA 4096 public key 복붙 | [O] Allow write acess | . | . | . | . | PR 아래부분에 merge PR &gt; merge를 눌러준다. . Actions에 보면 Merge가 진행중인 것이 보인다. 2분 정도 걸림. | 다 되고나면, &lt;code&gt;탭으로 와서 맨 첫줄에 블로그 주소가 보이게 된다. | . | 2 설정해주기 . blog 타이틀 변경 . 깃헙을 다룰 줄 알면, 로컬에서 clone을 떠서 수정하면 된다. . push만 해주면, actions가 자동으로 돌아가면서 static 파일로 수정해준다. | 우리가 올린 파일 기준으로 static한 파일을 생성해준다. | . _config.yaml 수정 &gt; title 변경 &gt; commit | jupyter upload . fastpages가 만들어준 readme에 보면, writing blogs with jupyter가 있다. . 여기서는 .md or .ipynb의 파일이름 양식만 참고함. . YYYY-MM-DD-*.ipynb | . 2020-01-28-My-First-Post.ipynb 2012-09-12-how-to-write-a-blog.ipynb . | Front Matter : 내 블로그 첨에 작성된 ipynb글(Fastpages Notebook Blog Post)을 참고해서 가져다 쓴다.(공식은 너무 김) . 쥬피터 노트북 맨 위에 들어갈 markdown 양식이다. . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true - branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . | 올릴 쥬피터에 아래와 같이 작성한다. . | 노트북 이름을 바꾼다. . 2021-08-06-엑셀정리 05 캐글 1 타이타닉 - 변수별 EDA + 함수정의로 정의(upload).ipynb . | github의 _notebooks 폴더로 가서 add file &gt; 업로드 &gt; commit해보았음. . | . | . | markdown upload . 해당 폴더는 _posts다 . | 제목양식은 yyyy-mm-dd-제목.md다 . 실제로 표시되는 이름은 예제파일속 format의 title:이 실제로 포스트 제목이 된다. | _posts &gt; 예제파일.md &gt; raw를 클릭해서 내용을 복사후 &gt; add file &gt; create file | . toc: true layout: post description: A minimal example of using markdown with fastpages. categories: [markdown] title: An Example Markdown Post # Example Markdown Post ## Basic setup . | . 3. local에서 clone해와서 작업해보기 . C: jupyter_blog에 폴더를 만들고, 우클릭 &gt; 터미널 &gt; code . . | git clone https://github.com/is2js/blog_raw.git . C: jupyter_blog blog_raw에 파일 복사됨. . | vscode는 해당 폴더로 들어가야함. . cd blog_raw/ . | . | 블로그 계정(is2js)과, 컴퓨터 전체 git 계정(is3js)이 다르므로, --local로 깃 계정을 설정해준다. . 참고 | . git config --local user.name &quot;is2js&quot; git config --local user.email &quot;is2js@naver.com&quot; . vscode에서 github확장관리에서 로그인을 제공하고 있어서, 로그아웃후 is2js로 로그인했다. | . | 첫화면 수정 . index.html은 첫 화면에 대한 내용을 md형식으로 닮고 있다. | 내용을 수정하고 이미지가 필요하면, images폴더에 업로드후 사용한다. 작성글들은 이 페이지 아래 자동으로 모아진다. | . | 메뉴 추가 . . _pages/폴더에 들가면 각각의 메뉴가 md파일로 작성되어있다. . about은 md파일로 작성되어있으며, 추가 nav 메뉴는 다 md파일로 작성한다. . layout: page title: About Me permalink: /about/ . 파일명이 아니라 양식속 title이 nav메뉴에 뜨는 페이지명이 된다. | . | 404, search, tags는 html파일로 섞어서 작성되어있다. . | . | _pages/에서 파일을 하나 생성하여 메뉴를 추가한다. . about에 있는 양식을 사용한다. | 작성하고 commit해준다. | . | comment 추가 . utterances를 이용하여 깃허브로 댓글 달도록 함. | . 현재 아무 post에나 comment를 달면 is2js/blog_raw/폴더에 앱이 인스톨 안되어있다고 나옴. install_app을 클릭해서 어터런스 설치 | install을 all repo가 아니라 select해준다. 필요한 저장소마다 설치를 추가로 해주면 된다. | . | . | social comment . disqus를 이용하여 소셜 or 깃헙없이 댓글 달도록 함. | utterances설치시 생성된 _includes/utterances.html을 수정하여 스크립트로 disqus스크립트를 넣어준다. disqus는 url기준으로 댓글창을 열어준다. | url만 다르다면, 다른 댓글창이 열린다. | . | . 구글에서 disqus 검색 블로그 &gt; 로고클릭 &gt; com | . | 난 페북으로 로그인함. -&gt; get start | 선택 | i want to comment on sites | I want to install Disqus on my site | . site네임은 is2js_blog_raw로 함 . | basic버전을 subscribe now로 선택함 . | 우리는 스크립트로 넣을 거라 platform선택 없이 아래 i don&#39;t see my platform 선택 . 스크립트는 카피 해놓는다. . &lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt; &lt;script&gt; /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page&#39;s canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page&#39;s unique identifier variable }; */ (function() { // DON&#39;T EDIT BELOW THIS LINE var d = document, s = d.createElement(&#39;script&#39;); s.src = &#39;https://is2js-blog-raw.disqus.com/embed.js&#39;; s.setAttribute(&#39;data-timestamp&#39;, +new Date()); (d.head || d.body).appendChild(s); })(); &lt;/script&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;https://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; . | . | configure(next랑 똑같음) 클릭후 정보는 비워놓아도 된다. . | 4. 추가 커스텀 . 방문자 카운터 . 해당 프로젝트는 오픈소스라 작동이 안되거나 없어질 수 있음. | 키워드를 기억했다가 다른 것을 검색해서 | . 구글에서 github blog hits counter를 검색 . 최상단 hit-counter 깃허브 들어갔음. https://hits.seeyoufarm.com/ | . | . | 해당 내용을 채운다. . . | 3가지 타입으로 넣을 수 있다. 특히 embed로 넣을 수 있는 것은 노션으로도 넣을 수 있다는 말이 된다. . markdown . ![Hits](https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fis2js.github.io%2Fblog_raw&amp;count_bg=%239E9E9E&amp;title_bg=%2308445E&amp;icon=python.svg&amp;icon_color=%23E1DFDF&amp;title=%EB%B0%A9%EB%AC%B8%EC%9E%90+%EC%88%98&amp;edge_flat=false) . | html . &lt;a href=&quot;https://hits.seeyoufarm.com&quot;&gt;&lt;img src=&quot;https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fis2js.github.io%2Fblog_raw&amp;count_bg=%239E9E9E&amp;title_bg=%2308445E&amp;icon=python.svg&amp;icon_color=%23E1DFDF&amp;title=%EB%B0%A9%EB%AC%B8%EC%9E%90+%EC%88%98&amp;edge_flat=false&quot;/&gt;&lt;/a&gt; . | embed url . https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fis2js.github.io%2Fblog_raw&amp;count_bg=%239E9E9E&amp;title_bg=%2308445E&amp;icon=python.svg&amp;icon_color=%23E1DFDF&amp;title=%EB%B0%A9%EB%AC%B8%EC%9E%90+%EC%88%98&amp;edge_flat=false . | . | 이제 markdown을 index.html안에다 넣어주자. . | 5. 깃허브 잔디와 레포 페이지(git.html) 추가 . 잔디이미지는 솔루션을 통해 https://ghchart.rshah.org/is2js | . | 레포정보는 url로 접근하는 github api를 통해 레포들정보 : https://api.github.com/users/[is2js]/repos | 특정레포정보 : [https://api.github.com/repos/[is2js]/[레포명] | . | 참고자료(노션) | . 솔루션(https://ghchart.rshah.org )을 이용하여, 잔디정보를 이미지로 가져올 수 있다. . index.html에 유저이름만 적어준 이미지 url or MD을 붙혀넣어준다. . 이미지 주소 : https://ghchart.rshah.org/is2js . | 이미지태그 . &lt;img src=&quot;https://ghchart.rshah.org/is2js&quot;/&gt; or &lt;img src=&quot;https://ghchart.rshah.org/is2js&quot; /&gt;로 변경 . | 마크다운 주소 . ![잔디](https://ghchart.rshah.org/is2js &quot;https://github.com/is2js&quot;) . | . | index.html의 hits 아래에 넣고 확인해보자. . . | . | 새로운 페이지 /_pages/git.html을 만들자. . 노션에 미리 작성해둔 코드를 복붙하자. . js스크립트를 사용하기 위해 html양식으로 작성한다. github API를 script태그를 이용하여 github repo정보를 가져온 것이다. api -&gt; h2, p, a태그로 map으로 돌면서 정보출력. 원하면 태그를 바꾸면 된다. | . | is2js부분을 해당하는 githubID로 변경해서 사용하면된다. | . layout: default permalink: /gitInfo/ title: gitInfo search_exclude: true &lt;img src=&quot;https://ghchart.rshah.org/is2js&quot; alt=&quot;&quot; style=&quot;width: 660px; height: 100px;&quot;&gt; &lt;div id=&quot;repos&quot;&gt; &lt;script&gt; // 비동기 작업을 위해 async function 선언 const initRepo = async () =&gt;{ const _username = &#39;is2js&#39; // 추가할 dom선택 const repoUl = document.getElementById(&quot;repos&quot;) // headers 설명 : 깃허브에 요청할 형식 지정 let response = await fetch(&#39;https://api.github.com/users/is2js/repos&#39;, {headers:{ &#39;Accept&#39; : &#39;application/vnd.github.v3+json&#39; }}); const repoJson = await response.json() // repo받아온 내용 확인 // console.log(repoJson); // json내용을 map을 이용해 각 dom을 만들고 추가 repoJson.map((repos)=&gt;{ let h2Element = document.createElement(&quot;h2&quot;) h2Element.textContent = repos.name let pElementDesc = document.createElement(&quot;p&quot;) pElementDesc.textContent = &quot;레포설명 : &quot; + repos.description let aElementURL = document.createElement(&quot;a&quot;) aElementURL.href = repos.svn_url aElementURL.textContent = repos.svn_url //각 요소를 &lt;div id=&quot;repos&quot;&gt;에 추가 repoUl.append(h2Element) repoUl.append(pElementDesc) repoUl.append(aElementURL) repoUl.append(document.createElement(&quot;br&quot;)) }) } initRepo() &lt;/script&gt; . | . | 6. repo마다 언어 퍼센트 출력하도록 변경 . 특정 레포 : [https://api.github.com/repos/[is2js]/[레포명] . 특정레포에서 쏴주는 정보를 관찰해보기 : blog_raw . | 랭기쥐만 출력해서 보기 : blog_raw/languages . 각 언어의 line수가 출력된다. | 다 더한 뒤, 총합으로 나누고, 100을 곱해서 %를 만든다. | . { &quot;Jupyter Notebook&quot;: 12491591, &quot;HTML&quot;: 20989, &quot;JavaScript&quot;: 10532, &quot;SCSS&quot;: 9877, &quot;Shell&quot;: 5458, &quot;Python&quot;: 2772, &quot;Smarty&quot;: 1965, &quot;Ruby&quot;: 1945, &quot;Makefile&quot;: 1422, &quot;Dockerfile&quot;: 364 } . | . | . git.html의 script부분(단순정보나열)을 퍼센트까지 뿌려주도록 변경된 스크립트를 복붙해주면 된다. . 모든 line수(values)를 sumcodeline에 더해주고, 각각의 value에다 나눈 뒤, 100을 곱한다. | strong태그로 출력을 해서, h2 아래에 추가해준다. | count변수를 사용해서 불러올 repo를 5개로 지정해준다. 최대갯수는 100개다. | . // 사용한 언어를 return해주는 함수 const repoLanguage = async (repo) =&gt; { let response = await fetch( `https://api.github.com/repos/is2js/${repo}/languages`, { headers: { Accept: &#39;application/vnd.github.v3+json&#39;, }, } ); let resJson = await response.json(); let sumcodeline = Object.values(resJson).reduce((a, b) =&gt; a + b, 0); s = &#39;&#39;; for (const [key, value] of Object.entries(resJson)) { s += `${key} : ${((value / sumcodeline) * 100).toFixed(3)}% `; } return s; }; // 비동기 작업을 위해 async function 선언 const initRepo = async () =&gt; { // 추가할 dom선택 const repoUl = document.getElementById(&#39;repos&#39;); //갯수설정 const count = 5; // headers 설명 : 깃허브에 요청할 형식 지정 let response = await fetch( &#39;https://api.github.com/users/is2js/repos?&#39; + &#39;per_page=&#39; + count, { headers: { Accept: &#39;application/vnd.github.v3+json&#39;, }, } ); const repoJson = await response.json(); // repo받아온 내용 확인 // console.log(repoJson); // json내용을 map을 이용해 각 dom을 만들고 추가 // repoLanguage 함수의 비동기 작업을 위한 async function선언 repoJson.map(async (repos) =&gt; { let h2Element = document.createElement(&#39;h2&#39;); h2Element.textContent = repos.name; let pElementDesc = document.createElement(&#39;p&#39;); pElementDesc.textContent = &#39;레포설명 : &#39; + repos.description; let aElementURL = document.createElement(&#39;a&#39;); aElementURL.href = repos.svn_url; aElementURL.textContent = repos.svn_url; //사용한 언어 불러오기 let language = await repoLanguage(repos.name); let strongElementLang = document.createElement(&#39;strong&#39;); strongElementLang.textContent = &#39;사용언어 : &#39; + language.toString(); //각 요소를 &lt;div id=&quot;repos&quot;&gt;에 추가 repoUl.append(h2Element); //사용언어부분 추가 repoUl.append(strongElementLang); repoUl.append(pElementDesc); repoUl.append(aElementURL); repoUl.append(document.createElement(&#39;br&#39;)); }); }; initRepo(); . | latex 사용 on . _config.yml에서 LaTex 적용이 default가 true가 아니라서 아래와 같이 _config.yml 파일에 use_math 옵션을 true로 변경해주시면 됩니다. . use_math: true . | 구조 . ### . index.html : 첫 화면에 대한 내용을 md형식으로 닮고 있지만, html파일임. . ``/images/diagram.png “https://github.com/fastai/fastpages”) . . ``은 나중에 is2js.github.io/blog_raw/ 폴더(깃허브 블로그 원본 폴더)로 연결된다. | . | . | _pages/ : md or html의 nav메뉴들의 모음 . about.md, search.html 등 | 추가된 md파일의 양식속 title:[ ]이 nav메뉴에 뜨는 페이지명이 된다. resume.md | git.html | . | . | images/ . 사진, favicon | . | . 커스텀 . 커스텀 도메인을 붙이는 조건 . 내 블로그는 is2js.github.io는 아니지만, github의 네임서버가 is2js.github.io.가 작동하는 것 같았다. (뒤에 . 있음) 원래는 리눅스서버의 공인ip주소를 적어줘야한다. | 하지만, github는 따로 ip주소를 제공하지 않으므로, [git_id].github.io.를 적어두고 해당폴더에서 설정과정을 추가한다. | . | . 가비아 DNS관리 페이지로 간다 dns.gabia.com | . | blog라는 서브도메인에다가 CNAME &amp; [github_id].github.io.로 레코드를 추가한다. . | 해당 fastpage 깃폴더 -&gt; settings &gt; pages로 이동한다. custom domain 부분에 dns에 등록한 서브도메인 blog.chojaseong.com을 적어준다. | 어떠한 확인과정이 있는데, 여기서 dns에 적어둔 [git_id.github.io.]에다가 현재깃폴더 배포ip를 배정시켜주는 작업을 하는 듯 싶다 | . | 밑에 https도 되도록 체크해준다. . | LOCAL 블로그폴더의 root에 CNAME이라는 파일을 만들고, 내부에 커스텀 도메인의 url만 적어준다. . CNAME . blog.chojaeseong.com . | root폴더의 _config.yml속 url 과 baseurl을 수정한다. . url: &quot;https://is2js.github.io&quot; -&gt; &quot;blog.chojaeseong.com&quot; | baseurl: &quot;/blog_raw&quot; -&gt; &quot;&quot; 아~ fastpage가 git_id.github.io아름의 레포가 아닌데도 page로 배포된 이유는 url을 git_id.github.io | baseurl을 /레포명으로 가지고 있어서 기 때문이구나. | . | 하지만, 커스텀도메인에서는 레포명까지 풀로 포함되서 github가 해당 커스텀도메인에 배포해준다. 그로 인해 baseurl은 사라진다.(빈문자열) | . | . | . | . . | _action_files폴더 속 settings.ini파일에도 baseurl이 있으니 수정해준다. 지워서 빈칸 남겨놓기 | . | 커스텀도메인으로 접속하는 순간부터, search 결과의 link들이.. 상대주소화되어 있어서, 도메인/search + 도메인/풀/주소.html 형식으로 잇슈가 있음. . search.js에서 만들어주는 a태그의 주소에 https://를 붙혀서 절대주소화 시켜 뒤에 붙지않고 바로 접속되게 한다. | . search.js . var resultLink = document.createElement(&#39;a&#39;); resultLink.classList.add(&#39;search-result&#39;); // a태그에 http:// 등이 없어서, 상대주소로 걸려서 커스텀도메인 + 다시 또 풀경로가 상대주소처럼 붙음.. // -&gt; href에 https://를 명시해주면, 상대주소가 아니라 절대주소로 인식되어 그 주소로만 간다. resultLink.setAttribute(&#39;href&#39;, &quot;https://&quot; + doc.url); //resultLink.setAttribute(&#39;target&#39;, &quot;_blank&quot;); . . |",
            "url": "blog.chojaeseong.com/fastpages/2021/08/06/fastpages%EB%A1%9C_%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%A0%9C%EC%9E%91.html",
            "relUrl": "/fastpages/2021/08/06/fastpages%EB%A1%9C_%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%A0%9C%EC%9E%91.html",
            "date": " • Aug 6, 2021"
        }
        
    
  
    
        ,"post19": {
            "title": "markdown posting example(title)",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "blog.chojaeseong.com/example/2021/08/05/test.html",
            "relUrl": "/example/2021/08/05/test.html",
            "date": " • Aug 5, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": ". Hi! I’m Jaeseong Cho . 🌱 I’m currently learning about below in git, python3.8+, (pytest), pyenv on Wsl2 with VScode . Backend with flask (, fastapi) | (Pipeline and Infra with airflow, PySpark in) Docker on Ncloud or GCP (or AWS) | DataScience/DataAnalysis with Pandas, NLP by (TF2.0 and) Keras | SQL &lt;-&gt; SQLAlchemy with PostgreSQL, MySQL, SQLAlchemy on Docker (or Bigquery) | My blog https://blog.chojaeseong.com/ (opened) | https://nittaku.tistory.com (closed) | . | . 👨‍⚕️ I’m Korean Medicine Doctor . Worked at CY and Gangnam Mokhuri Oriental Hospitals as KMD | . ✒ My Git and Algorithm Problem Solving Tier(백준) . . 🏷 Certificates/Papers . Certificate 2022.02~ M.S. candidate (Statistics/Bioinformatics) | 2021.02 General training(일반수련의) | 2020.02 B.S. in Korean Oriental Medicine(한의사) | 2019.09 Engineer Information Processing(정보처리기사) | 2019.04 Sqld(SQL 개발자), Adsp(데이터분석 준 전문가) | . | Paper Identification of Toxic Herbs Using Deep Learning with Focus on the Sinomenium Acutum, Aristolochiae Manshuriensis Caulis, Akebiae Caulis Accepted: 2019. 12 🚴‍♂️ Experiences/Studies . | . | 2021.11 ~ 2022.11) 🪐 우테코 4기 백엔드 프리코스 후 선발 | 2021.09 ~ 11) 🦁 멋쟁이사자처럼 X Ncloud and Clova를 활용한 인공지능 서비스 과정-수료증 | 2019.07 ~ 09) Kdata(한국데이터산업진흥원) X 빅데이터 청년인재-빅데이터 기반의 지능정보 시스템 개발 과정-수료증 | 2019.02 ~ 03) 서울대학교 의과대학 SNU BioInformatics Lab Intern | 2018.03 ~ 2020.02) 한국지도자육성장학재단 장학생 선발(Kosffl Club) | 2018.12) 대한한의학회 한의대 미래인재육성 프로젝트 장학생 대상-기사 | 2011.08 ~ 2013.05) 💪 육군 병장 제대(작전병; Don’t need mouse to me) | . ✨ Awards . 동신대학교 한의학과 최우수 졸업(수석졸업) | 대한한의학회 한의대 미래인재육성 프로젝트 장학생(대상) | 빅데이터 청년인재 전체 장려상(고려대내 2위) | 동신대학교 창업동아리 경진대회 최우수상(1위) | . 👋 Contanct Me! . &amp;nbsp .",
          "url": "blog.chojaeseong.com/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "",
          "content": "공사중입니다(template).. 자세한 정보는 github.com/is2js . 데이터엔지니어로서의 역량 . Data Engineer란? . Data관련 직군 출저 : Youtube-indiflex | . 프로젝트 . python를 활용한 진료보조프로그램들 한방병원 진료기록부(ipywidget, panel) | 초진기록지(ipywidget) | 환자 티칭 프로그램(ipywidget) | 동료선생님들 거주지역 확진자수 알림(flask, GCP, jandi) | . | Class를 활용한 CLI blog (CRUD) | NLP 분석 Packages | . | 사람인 공고 수집 크롤링 프로젝트 - 크롤링 심화 프로젝트 | . | 데이터 분석 프로젝트 . 나만의 데이터분석 노트 gitbook(Updating~) | 나만의 데이터분석(EDA) 패키지 -Cho Package : numpy, pandas, matplotlib, seaborn . | 논문작성을 위한 한의학 박사들의 설문지 분석후 ROC커브 작성 [노트] | DL논문 작성을 위한 image전처리, DL, ROC커브 작성 [노트] | 관심기업 과제와 유사한 데이터 분석 프로젝트 [노트] 관심기업 과제 pandas to SQL | . | inflearn Pipeline . | 멋쟁이사자 X Naver 연계 프로그램 - clovar API이용 프로젝트 | | Flask 프로젝트 게시판 : Docker, MongoDB, Flask, JQuery | 질답앱 : | 대쉬보드 | like finterest 메모대쉬보드 | . | FastAPI 프로젝트 API : | . | Algorithm &amp; Pythonic . Pythonic Python 정리 및 회고 [노트, 출저-프로그래머스] | 알고리즘 패러다임 및 연습문제 풀이 [저장소], 출저-Codeit] | 알고리즘 자료구조 및 연습문제 풀이[노트, 출저-프로그래머스] | 알고리즘 고득점 kit 연습문제 풀이[노트, 출저-프로그래머스] | Python 고급 [저장소] | DataAnalyst . DS스쿨 - DL반 수료 | DS스쿨 - ML반 수료 | FastCampus - 논문작성을 위한 R 통계 수료 | DL(cnn)을 활용한 독성약재감별 논문작성 논문 | 논문 작성을 위한 설문지 분석후 ROC커브 작성 [노트] | 관련 프로젝트 in 고려대 [노트, 프로젝트] | . | penguin package를 활용한 통계분석 정리[노트] | 고려대 빅데이터 청년인재 수료 NLP | Vision | ML, DL | . | Data Engineer . DS스쿨 - Pandas 데이터분석반 수료 | FastCampus - 전처리CAMP 수료 | Udemy - The Complete Python &amp; PostgreSQL Developer Course 수료 | DataCamp - Data Engineering for Everyone 수료 | DB &amp; SQL . DAP자격대비 데이터 모델링 스터디[노트, 출저-데이터와사람들] | SQL 데이터 분석[노트, 출저-책] | SQL, Bigquery를 이용한 코호트 분석[노트, 출저-탈잉] | MySQL 심화[노트, 출저-SSAC] | Postgresql tutorial 4hour[노트, 출저-FreeCodeCamp] | Postgresql for DataEngineer[노트, 출저-itversity] | Postgrsql &amp;Python course[노트, 출저-udemy] | SQL vs Pandas 비교정리[노트, 출저-조재성] | mongoDB for 데이터수집[노트, 출저-멋쟁이사자처럼, 그외] | SQLAlchemy . 2.0과 이전버전 비교 및 튜토리얼[노트, 출저-Youtube] | SQLAlchemy - pandas 비교 튜토리얼[노트] | Infra . 운영체제 공부[ 노트, 출저 - 정보처리기사 및 유튜브 ] | PowerShell vs BashShell 다빈도 명렁어 정리[노트, | Docker 기본 문법[노트, 출저-Indiflex] | Docker &amp; Ncloud[노트, 출저-SSAC] | Linux 기본[노트, 출저-Indiflex] 출저-드림코딩] | git 기본 | git flow | Frontend . HTML, CSS, JAVASCRIPT로 모던 웹페이지 만들기[프로젝트] | Javasctip와 TypeScript 정리 | React | Vue |",
          "url": "blog.chojaeseong.com/_pages/edustudy.html",
          "relUrl": "/_pages/edustudy.html",
          "date": ""
      }
      
  

  

  

  
      ,"page5": {
          "title": "",
          "content": "공사중입니다…(template) 제시한 정보는 github.com/is2js . 기본정보 . Photo Future . | | . Name | 조재성 | . - Chinese | 趙在聖 | . - English | ChoJaeSeong | . Age | 1987 | . Birth Day | 1987.12.18 | . Email | tingstyle1@gmail.com | . Mobile | xxx-46xx-62xx | . 신상정보 . Profile Content . Address | 서울시 관악구 | . Married | 미혼 | . Family | 2남 1녀 | . Blood type | RH+ O | . Religion | 없음 | . 학력정보 . Level School Name Major Start End Status 최종학력 . University | DongShin University | Korean Medicine | YYYY.MM | YYYY.MM | graduated | 최종 | . High School | NamHae High School |   | YYYY.MM | YYYY.MM | graduated |   | . 직장이력 . Period Company Part &gt; Team . 2011.10 - 2013.4 | Company Inc | R&amp;D &gt; Mobile | . 2010.05 - 2011.9 | Company Corp | Big Data &gt; Visualize | . 2008.08 - 2010.3 | Venture | Web &gt; UI | . 2007.02 - 2008.8 | Company Name | Marketing 3 | . 오픈소스 프로젝트 (2012.03 ~ 현재) . 프로젝트 공식 명칭 . 소개 프로젝트에 대한 간략한 소개를 한다. . | 주요기능 주요 기능을 일일이 상세히 나열한다. | . | 사용기술 . 사용된 기술을 상세히 나열한다. | . | 개발기간 : 2013.2.3 을 시작으로 최근까지 xxx 커밋 | 공식 사이트 - http://rhiokim.github.io/resume | 소스 저장소 - https://github.com/rhiokim/resume | . | 마크다운 이력서 표준화 프로젝트 . 소개 . 이력서에 대한 몇가지 불편한 마음을 개선하고자 마크다운 이력서 표준화 프로젝트를 시작한다. . 개발자를 잘 표현할 이력서 양식이 없다. | 2,3 년에 한번씩 업데이트 해야하는 이력서 너무 힘들다. | 이력서 양식이 도구에 너무 의존적이다. | | 주요기능 . 마크다운으로 기술한다. | PDF, HTML, EPUB, Mobi 등 다양한 포맷으로 변환할 수 있다. | 개발자를 잘 표현할 수 있다. | . | 사용기술 마크다운. . | 개발기간 : 2012.3 을 시작으로 약 6개월에 걸쳐 500여 커밋 | 공헌자 : https://github.com/rhiokim/resume/contributors | 공식 사이트 - http://rhiokim.github.io/resume | 소스 저장소 - https://github.com/rhiokim/resume | . | . 기타 공개/비공개 프로젝트 . 프로젝트 명 추가 설명 : https://vimeo.com/51812784 | . | . 진행중인 프로젝트 (2013.04 ~ 현재) . 프로젝트 명 소개 모바일 앱으로 현재 3명의 멤버가 개발 진행 중 . | 사용기술 Node.js, Mongodb, APNS(Apple Notification), Gumby2 (Responsive CSS Framework) . | 역할 RESTful API 디자인, 시스템(Node.js, Mongodb, APNS) 엔지니어링, 웹 사이트 개발 . | . | . 참여한 프로젝트 이력 . 회사명 1 . 프로젝트 소개 프로젝트에 대한 간략한 소개를 한다. . | 역할 자기가 참여한 프로젝트에서 했던 역할에 대해서 기술한다. | . | 사용기술 Backbone.js, jQuery, require.js, grunt.js, twitter bootstrap, Node.js 등 | . | 개발기간: 12개월 | 공식 사이트: https://project.com | 소스 저장소: https://github.com/company/project | . | . 회사명 2 . 프로젝트 소개 프로젝트에 대한 간략한 소개를 한다. . | 역할 자기가 참여한 프로젝트에서 했던 역할에 대해서 기술한다. | . | 사용기술 Backbone.js, jQuery, require.js, grunt.js, twitter bootstrap, Node.js 등 | . | 개발기간: 6개월 | 공식 사이트: https://project.com | 소스 저장소: https://github.com/company/project | . | . 대외 활동 내역 . 커뮤니티 . 커뮤니티명 주제 관련 참고 자료 . 2010.05 | Title | http://slidesha.re/xxxxxx | . 2010.10 | Title | http://scr.bi/xxxxxxx | . 세미나 . 행사 / 모임 주제 규모 관련 참고 자료 . XX R&amp;D Campus | 1. subject 1 | 30 | http://bit.ly/xxxxxx | . 2. subject 2 |   | http://bit.ly/xxxxxx |   | . 컨퍼런스, 강연 . 행사 / 모임 주제 규모 관련 참고 자료 . Conference | Title | 250 | http://bit.ly/xxxxxx | . Conference | Title | 1,000 | http://bit.ly/xxxxxx | . 소셜 . Site URL . Github | https://github.com/{account} | . Twitter | https://twitter.com/{account} | . Facebook | https://facebook.com/{account} | . . 위의 사실은 GNU 정신에 의거하여 사실임을 증명하며, 만약 사실이 아닐 경우 MIT 라이센스로 공개해도 무방합니다. . YYYY년 MM월 DD일 {홍길동} .",
          "url": "blog.chojaeseong.com/_pages/resume.html",
          "relUrl": "/_pages/resume.html",
          "date": ""
      }
      
  

  
  

  

  
  

  

  
  

  
  

  

  

  

  
  

  
      ,"page16": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "blog.chojaeseong.com/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}