{
  
    
        "post0": {
            "title": "피드백) 1-2(로또) 코드리뷰",
            "content": "PR- 로또 미션 피드백(제이) . 참고 강의: 제이) 중간피드백 Service와 Controller . | PR1 . | PR2 . | . 구조 . Collections.unmodifiableList(issuedLotto); / issuedLotto인스턴스변수를 넘겨줌 . getter or 메서드 return으로 넘겨주는 list가issuedLotto라는걸 인스턴스변수로 사용한다면, 객체의 어떤 메서드로 issuedLotto를 조작하게되면 반환된 issuedLotto값이 바뀔거에요. 생성자에서 계산후 생성될 때부터 초기화되는 변수가 아니면 인스턴스 변수로 가지지 마라. 메서드에 의해 바뀐다 | my) Collections.unmodifiableList() 대신 List.of() 불변 복사 / new ArraysList&lt;&gt;()가변 변 복사를 사용하자. | . | . . | null처럼 아예 입력이 들어오지 않는 것은 view가 아니라 도메인에서 검증 . nullOrEmtpy와 format정도의 공통검증만 inputView로 옮기겠습니다! | . . | 일급의 getter에서는 외부에서 내부 포장변수 수정 못하도록 수정불가 타입으로 응답하기 . 방어적 복해서 넘기기 | . . . | 누적합 + 카운트는 stream으로 depth줄이기 . . | 도메인 내부에서 toDto 쓰지말 것 컨트롤러에서 from도메인 , to도메인 등을 써서 변환해야한다. | . | 서비스에서 필요에 의해 만들어진 특정 도메인을 관련 로직들은 결국 사용되는 변수를 포장하도록 클래스를 파고( 사용하는 스태틱 클래스를 파도 됨) 그 내부로 로직을 가져간다 . . | 로직의 결과로 나온 데이터가 추가 계산이 필요할 경우 클래스로 파서 포장하는 대신 그 생성과정은 생성자에 넣어라 . | 메인로직을 담당하는 service에서는 인스턴스변수를 두지말고 input -&gt; output의 스태틱 형태를 유지해라. 중요하지 않은 컨트롤러에서 도메인 변수를 생성후 -&gt; 서비스에 input으로 줘도 되니까 . | 컨트롤러에서는 outputView를 메인로직과 같이 묵지말고, 들어가는 input들이 서비스 메서드에 확실히 필요한 것들인지 한눈에 파악하게 작성 . . | Dto는 민감한 데이터, 불필요한 데이터를 짤라 넘기는 것인데, 작은 프로젝트들에서는 다 쓰인다. 넘겨도 된다~ dto를 항상 만들라고 하지말자~ | . | 빈 List가 가능한 자리에는 early return + Collections.emptyList() 활용 | . | 서비스가 비대해진다면, 도메인 로직을 포함하고 있는지 점검하기 . 도메인 로직은 도메인 (없으면 추출해서) 클래스에서 처리하기 | . | 다른 도메인과 추가 검증, 비교로직이 필요할 경우, 이미 포장된 도메인이라도 한번더 포장할 수 있다. . 입력받은 당첨Lotto + 보너스볼은 같이 다니며 + 검증도 요구된다 | . . 추가 로직 없이 단순히 같이 다니는 것들을 포장해서 2개의 상태값으로 보관할 수 있다.` 블랙잭에서 dealer + gamblers -&gt; Players -&gt; this.dealer + this.gamblers | 같이 다녀서 포장 -&gt; 필요할 땐, 각각 getter로 바로 줘도 된다. | . | . | 네이밍 . final priavate -&gt; 접근제한자 final 순으로… . | 상수 &lt;-&gt; 변수 개행 -&gt; class 생성후 개행도 해주기 . | 도메인Factory는 정펙매가 너무 커서 static클래스로 뺀 것 . | 다른 크루들 PR 참고 . 베루스 - 앨런 리차드 - 루피 케이 - 던 후니 - 엘런 . 구조 . Lotto내 상수 1_000이 Lottos, Money도 알아야한다? . public 상수로 ? (X) . | 여러 도메인이 아는 상수라도 각 도메인패키지내에 도메인상수들을 class로 관리하는 것도 좋은 방법이라고 생각해요 . 1_000원 이라는 것이 로또와 금액, Lottos가 모두 알아야 한다면 1_000원이라는 금액이 Lotto 에 있는 것이 맞는 것인가? 어쩔 수 없이 각 객체별로 공유해야하는 상수가 있다면 그 값은 누가 갖는게 맞는가? 에 대해서도 고민해보면 좋을 것 같아요. 지금처럼 로또가 같는 것도 방법이고, 도메인패키지내에 도메인상수들을 관리하는 것도 좋은 방법이라고 생각해요🙂 . | . | 포맷팅(변환)은 view(입력)에 따라 달라지니 중요하지 않은 controller에서! . convert를 도메인에서하면, 입력달라질 시 -&gt; 도메인도 같이 수정되어야한다. . | formating, convert는 자주 바뀌는 view에 따라 달라지니, 중요하지 않은 controller에서 . 포맷팅은 분명 현재 로또게임에서 중요한 로직이지만 입력과 도메인을 분리하기 위해서는 저는 Controller 패키지에서 담당하는 것이 맞다는 생각이 들어요🙂 추가로 DTO와 같은 객체들을 통해서 각 패키지나 레이어에서 필요로 하는 포맷을 재정의할 수도 있습니다. . | . | controller에서는 상태값을 가지지 말 것 . 다른 사용자는 다른 controller 인스턴스 객체를 가질 것이라고 생각해서 문제가 없다고 생각했어요. . 다른 사용자라도 여러 사용자가 같은 인스턴스 객체사용 가능 -&gt; 상태값 오염 가능 | . `synchronized`의 잠금을 통해 멀티쓰레드 환경에서 안정성을 보장할 수 있지만, 현재는 인스턴스변수를 가지지 않는 것으로 충분할 것 같아요. . | . | controller에서 도메인 객체(domain) 생성 메서드 &lt;-&gt; 출력(view)메서드을 1개 메소드로 묶지말 것 . controller에서 전체 로직에 대한 행위들이 프로그램 전체를 나눠서 설명할 수 있게 끔만 나눌 것 . controller전체를 너무 간결하게 나누지 말것 | 실행과 출력도 나눌 것 | . 비즈니스로직을 실행하는 행위와 출력하는 행위는 분리되는 것이 관심사가 분리되는 것이라 생각이 되어요. 두 가지의 역할이 하나의 메소드에 들어가는 것 보단, 각각 관리될 때 역할이 하나기 때문에 유지보수하기 용이한 코드가 아닐까 라는 생각을 하고 있습니다.🙂 . | . | 일급컬렉션도 컬렉션이라서 add 메서드 추가해도 된다! 가변 컬렉션, 불변 컬렉션 따로 있는 듯. | . | (베) . inputView에서 커스텀Exception을 쓰는 순간 -&gt; view에서 백엔드의 Exception을 의존하게 된다 -&gt; 쓰지말 것 . | List&lt;일급&gt;도 일급컬렉션으로 포장할 것 . | 뭔가 인스턴스 변수를 인자없이 기본생성자초기화해놓고 -&gt; FOR문돌면서 add의 가변값처럼 사용하지마라. -&gt; **일급 가변 생성을 정펙매를 통해 생성과 동시에 + 값할당기능을 제공할 수 있다. ** . // 잘못된 예 Statistic statistic = new Statistic(inputMoney); for (Lotto lotto : lottoes) { statistic.addRank(getRankBy(lotto)); } return statistic; . Statistic를 생성해놓고, 값을 추가하고있는데요. 객체가 가변값처럼 사용되고 있는 것 같아요. Statistic에서 정잭팩토리를 제공해서, 생성과 동시에 값을 할당하는형태로 만드는건 어떨까요? . | list를 합칠 때 -&gt; 빈 리스트(가변값)에 add를 대신하는 stream . 기존list.stream() + 새list.stream() -&gt; Stream.concat() -&gt; collect( collectingAndThen( toList(), 포장생성자::new ) . 2stream 을 1개 list로 변환해서 모으고 -&gt; 포장까지 할 수 있다.!! | . public Lottoes combine(Lottoes other) { List&lt;Lotto&gt; result = new ArrayList&lt;&gt;(); result.addAll(lottoes); result.addAll(other.lottoes); return new Lottoes(result); } // 변환후 public Lottoes combine(Lottoes other) { return Stream.concat(lottoes.stream(), other.lottoes.stream()) .collect(collectingAndThen(toList(), Lottoes::new)); } . | . | . | (리) . controller에서 input받을때의 안내문 -&gt; InputView.printException(exception); . | 미래를 예측해서 코드를 짤 필요 없다? (확장가능성을 미리 X) . | 콘솔 출력만 하는데 InputView 로 분류하신 이유가 있으실까요 ? . 사용자와 직접 커뮤니케이션 사용자의 요청을 컨트롤러로 전달 컨트롤러의 응답을 최종적으로 사용자에게 전달 콘솔 출력은 사용자에게 오류 메시지 혹은 결과를 전달하는 과정이기 때문에 View의 역할이라고 생각했습니다! 혹시 제가 조금 더 생각해봐야할 지점이 있을까요?! 😅 . | . | (후) . 컨트롤러의 코드는 시나리오로서 글처럼 읽을 수 있게 == input/output명확하게는 . 사용자 시나리오로 글처럼 읽을 수 있는 코드를 만들려고 노력하고있는데요. 이 부분은 돈을 생성하는게 아닌, 돈을 입력받는 부분이 아닐까요? . | 일급이 중복을 허용하지 않는다 -&gt; List대신 Set을 상태값으로 가져도 . 중복검사가 제거된다 -&gt; 갯수검사만 하면 됨. | LinkedHashSet을 쓰면 정렬도 | . | 도메인 검증은 도메인 기본 생성자에서 . 1~45의 숫자인게 도메인 규칙인데요. 이 부분이 &#39;생성하는 곳&#39;에서 검증되어야한다고 생각 . | inputview에서 반복해서 입력받기 가능. . 그러나 stream 작성하면 디버깅이 어려울 수도 있음. | . public static List&lt;List&lt;Integer&gt;&gt; inputManualLottos(final int counts) { System.out.println(INPUT_MANUAL_LOTTO_NUMBER); return IntStream.range(0, counts) .mapToObj(index -&gt; inputManualLotto()) .collect(Collectors.toList()); } . | (중복) 가변으로 list 추가로 받기 . 기존과 들어올 list 모두 stream으로 concat하여 불변형태로 합치기 | . | 스트림내 스트림은 가독성 -&gt; 메서드 분리 . | . | (후) . LottoNumber 정적메서드만 있는 static Factory 클래스로 싱글톤(service, cahce)를 대체하자. . 블로그 | . | LottoResult -&gt; Map을 초기화시켜놓고, 거기에 하나씩 put하는 형태인데요. 집계함수(groupingBy)도 고려해볼 수 있을 것 같아요. 🙂 . map을 put이 아니라 replace로? ㄴㄴ . //수정 전 final Map&lt;Rank, Integer&gt; rankResults = Rank.initResultMap(); for (Lotto lotto : lottos.getLottos()) { Rank rank = winLotto.matchResult(lotto); rankResults.replace(rank, rankResults.get(rank) + 1); } return new LottoResult(rankResults); . replace를 사용함으로써 initialize한 key값 외 예외적인 값이 들어올 상황을 방지 개인적으로 방어적인 코드보다, 빠른 피드백을 받을 수 있도록 예외를 던지는게 더 좋다고 생각하고있어요. 근본적으로 Rank.initResultMap();로 씨드를 만든 Map으로 put해주는 구조가 조금 특이하긴 하네요..🤔 . | . | map을 거꾸로 출력도 view에서!!해야함 - &gt; values().stream -&gt; view의 책임이라 inputView에서 . toReverseList 는 뷰에 의존적인 코드라고 생각해요. 거꾸로 순서가 필요한 건 뷰의 책임이라고 생각하는데, 뒤집어주는 건 뷰에서 처리하는게 좋을 것 같아요. . | toString()활용보다는 그냥 getter . | . | NEW_LINE = System.lineSeparator() 도 상수화 . | 역순으로 출력안하고 title만 하드코딩 + 개별요소만 get하는 sense . public class ResultView { public static void printResult(LottoResult lottoResult) { System.out.print(System.lineSeparator()); System.out.println(&quot;당첨 통계&quot;); System.out.println(&quot;&quot;); System.out.println(&quot;3개 일치 (5000원) - &quot; + lottoResult.getLottoResultByRank(FIFTH).getCount() + &quot;개&quot;); System.out.println(&quot;4개 일치 (50000원) - &quot; + lottoResult.getLottoResultByRank(FOURTH).getCount() + &quot;개&quot;); System.out.println(&quot;5개 일치 (1500000원) - &quot; + lottoResult.getLottoResultByRank(THIRD).getCount() + &quot;개&quot;); System.out.println(&quot;5개 일치 보너스 볼 일치(30000000원) - &quot; + lottoResult.getLottoResultByRank(SECOND).getCount() + &quot;개&quot;); System.out.println(&quot;6개 일치 (2000000000원) - &quot; + lottoResult.getLottoResultByRank(FIRST).getCount() + &quot;개&quot;); System.out.println( &quot;총 수익률은 &quot; + lottoResult.getRateOfReturn() + &quot;입니다.(기준이 1이기 때문에 결과적으로 &quot; + getWinOrLoseByLottoResultDto(lottoResult) + &quot;라는 의미임)&quot;); } private static String getWinOrLoseByLottoResultDto(LottoResult lottoResult) { if (lottoResult.getRateOfReturn() &gt; 1) { return &quot;이익&quot;; } return &quot;손해&quot;; } } . | 만약 역순 출력한다면? . map을 돌고 있으니, 각 요소들이 comparable 상속 중이면 .sorted(Comparator.reverseOrder()) . If your stream elements implements Comparable then the solution becomes simpler: ...stream() .sorted(Comparator.reverseOrder()) . | values()만 역순으로 하고 싶다면.. list로 바꿔서.. . List&lt;Rank&gt; ranks = Arrays.asList(Rank.values()); Collections.reverse(ranks); . | . | . docs . 어떠한 프로그램이다(요구사항), 혹은 실행결과 등도 같이 정의 . 문서에 이 프로그램이 그래서 어떠한 프로그램이다, 혹은 실행결과 등을 같이 보여준다면 프로그램을 훨씬 빠르게 이해할 수 있을 것 같아요. . 예시 . ## 요구 사항 가상으로 사용자가 로또를 구매하고 지난주 당첨 번호를 직접 입력하여 당첨이 얼마나 되는지 수익률이 몇인지 알 수 있는 프로그램입니다. - java로만 구현된 애플리케이션(jdk11버전) - 터미널에서 사용자가 구입금액, 지난주 당첨 번호를 입력하고 터미널에서 결과를 확인할 수 있다. - 로또는 1 ~ 45 중 랜덤으로 6개의 번호를 가진 로또를 발급한다. - 로또는 1장당 1000원이다. - 당첨기준은 실제 로또와 같다. ## 실행 결과 text 구입금액을 입력해 주세요.(1000원~20억원) 14000 . | ## 페어프로그래밍 컨벤션도 유지 . ## 페어 프로그래밍 컨벤션 - 10분 간격으로 역할을 바꾼다. - BDD 테스트 코드 작성 패턴으로 작성한다. - 테스트만 통과할 수 있을 정도로 TDD를 구현한다. - 커밋 단위를 README 기준으로 한다. . | . | . 네이밍 . 메서드 입력요구는 request (getMoney -&gt; requestMoney)?? 내부에서 print 로직을 포함하지 말 것 | print는 controller에서 뿌려주면 됨. | . | 상수는 재사용 뿐만 아니라 의미의 명확화의 관점도 포함된다. . 맞습니다. 깔끔하다면 계속 사용하셔도 됩니다! 다만 우리가 상수화를 할 때 단순히 재사용을 위해서 하는 것 뿐만아니라 의미를 알 수 없는 값에 이름을 부여해서 의미를 드러낸다라는 관점도 있다는 점을 알고 가시면 좋을 것 같아요! . | 사소하더라도 한 줄에는 . 1개 -&gt; stream은 한 줄씩 모두 띄워주는게 가독성이 좋은 것 같아요. 그 역할이 조금 더 뚜렷하게 보이는 것 같아서요. . public Lotto(List&lt;Integer&gt; numbers) { validateNumbers(numbers); this.numbers = numbers.stream().map(Number::new).collect(Collectors.toSet()); . 디미터의 법칙도 객체에게 메시지를 보내라!의 관점 . | 아래는 1줄에 . 1개이지만, 가독성을 위해 stream은 줄 띄우기 . map(Number::new).collect(Collectors.toSet()); . | . numbers.stream() // 스트림을 열고 .map(Number::new) // 가공하여 .collect(Collectors.toSet()); // 결과를 셋으로 만든다. . | Money가 VO가 아니라 검증이 추가되었다면 대명사 Money(X) -&gt; 로또에서만 사용되는 1_000단위의 금액 -&gt; LottoMoney로서 대명사 VO가 아니라 도메인임을 명시해줄 것 . 지금 Money는 로또를 구매하기 위한 금액이기 때문에 1000으로 나누어떨어져야한다는 제약사항이 있어요. 순수한 Money는 아니게 되는거죠. 그렇기때문에 개인적으로는 LottoMoney / PurchaseMoney 와 같이 이 금액은 구매를 위한 금액이고 제약사항이 있다라는 것을 명시할 수 있는 이름을 사용할 것 같아요. . | 특정 프로그램 패키지 안에 있더라도 클래스명에 명시 . 작은 프로그램이지만 앞으로 프로그램이 커질 때 각 클래스들의 패키지를 잘 안보게 되기도 하고, 코드 자체에서 드러나지 않기 때문에 놓치는 경우가 많더라구요. 이런 부분을 지양하고자 저는 후자를 선호합니다🙂 다만 네이밍이 길어지는 단점도 분명 존재하는 것 같습니다. . | 앞에 검증 등 포장되어있다면, 앞에 도메인명을 붙이자.! Number -&gt; LottoNumber | 포장되는 내부 인스턴스 변수를 클래스 그대로 따오지 말고 -&gt; value -&gt; getValue() . | 예외 던질때 메세지 피드백을 상세하게 어떤 값때문에 예외가 발생했는지 추가 | . | . 캐슁 . 캐슁 작업을 Lotto 생성자에서 해주다가 복잡해지니 정적 팩토리 메서드-&gt;클래스 LottoFactory로 뺐다. . 객체생성이 복잡한 경우 팩토리라는 키워드로 조금 더 공부해보시면 좋을 것 같아요. 맞습니다. 정적팩토리메소드를 통해 자동로또를 만들어낸다라는 의미를 잘 드러낼 수 있어요. 추후에 생성이 더 복잡해진다면 생성을 담당하는 LottoFactory와 같은 형태로 리팩토링하는 것도 방법인 것 같아요. . | 처음부터 미리 만들지말고, 생성할때마다 CACHE맵에서 검사후 없으면 반환 . private static final Map&lt;Integer, LottoNumber&gt; CACHE = new HashMap&lt;&gt;(); private final int number; private LottoNumber(int lottoNumber) { this.number = lottoNumber; } public static LottoNumber getInstance(int lottoNumber) { validateRange(lottoNumber); if (CACHE.containsKey(lottoNumber)) { return CACHE.get(lottoNumber); } LottoNumber newInstance = new LottoNumber(lottoNumber); CACHE.put(lottoNumber, newInstance); return newInstance; } private static void validateRange(int number) { if (isOutOfRange(number)) { throw new IllegalArgumentException(ERROR_MESSAGE_FOR_OUT_OF_RANGE_NUMBER); } } private static boolean isOutOfRange(int number) { return number &lt; MINIMUM_LOTTO_NUMBER || MAXIMUM_LOTTO_NUMBER &lt; number; } . | 캐슁은 맵을이용해라 IntStream -&gt; toMap( number -&gt; number, 그걸로 new 객체 생성자() ) . 이펙티브 자바, 아이템 28. 배열보다는 리스트를 사용하라를 한번 찾아보시는 것도 좋을 것 같네요 🙂 | . LOTTO_NUMBER_CACHE = IntStream.rangeClosed(MIN_LOTTO_NUMBER, MAX_LOTTO_NUMBER) .boxed() .collect(Collectors.toMap( number -&gt; number, LottoNumber::new) ); . 블로그 | . | . map . map 돌기: map.entrySet().stream().map( entry -&gt; entry.getKey(), entry.getValue() ) + getKey(enum)에 메서드 정의하여 추가로직 -&gt; sum() . public long getTotalProfit() { return result.entrySet() .stream() .mapToLong(entry -&gt; entry.getKey().multiply(entry.getValue())) .sum(); } . entry는 getKey()할 수 밖에 없으며, 하나의 맾핑된 key객체로서 .메서드( ) 로 메세지를 던진다. -&gt; .multiply( ) . 메서드를 어캐 정의했나 . public long multiply(int count) { return (long) price * count; } . public double getRateOfProfit(Money money) { long totalMoney = 0L; for (Map.Entry&lt;LottoRanking, Integer&gt; entry : result.entrySet()) { //요렇게도 사용할 수 있을 것 같네요🙂 public double getRateOfProfit(Money money) { long totalMoney = result.entrySet() .stream() .mapToLong(entry -&gt; entry.getKey().multiply(entry.getValue())) .sum(); return money.getRateOfProfit(totalMoney); } . | . | . | enumMap: HashMap보다 성능상에서 이점이 많은 것 같습니다. . Null값을 key로 가질 수 없다. | hashcode 충돌이 존재하지 않는다. | 단순 배열의 구조를 가진다. | Enum의 순서를 유지할 수 있다. | . 개인적으로 현재 EnumMap을 사용해서 위의 장점을 얻을 수 있다 라는 접근보단, 어떠한 코드를 구현하는데 있어서 조금 더 적절한 (그것을 위한 형태)가 있다면 사용해보는 것도 좋다라는 생각 . | findAny가 스트림이 직렬이면 findFirst와 동일하게 작동하는군요! . | (베) . 개인코드 -&gt; map초기화시 toMap() + Function.identity(), r-&gt;0이용 . private Map&lt;Rank, Integer&gt; emptyRankMap() { return Stream.of(Rank.values()) .collect(toMap(Function.identity(), r -&gt; 0)); } . | . | (리) . 비교 결과를 알아서 그룹별,갯수의 map에 담아주는 stream . private static Map&lt;Rank, LongSummaryStatistics&gt; getLottoResult(WinningLotto winningLotto, Lottos lottos) { Objects.requireNonNull(winningLotto, ERROR_MESSAGE_FOR_NULL_WINNING_LOTTO); Objects.requireNonNull(lottos, ERROR_MESSAGE_FOR_NULL_LOTTOS); return lottos.getLottos() .stream() .map(winningLotto::getRankByLotto) .collect(groupingBy(identity(), () -&gt; new EnumMap&lt;&gt;(Rank.class), summarizingLong(Rank::getPrize))); } . | map의 values()값만 sum by LongSummaryStatistics . private static long getTotalReturnByLottoResult(Map&lt;Rank, LongSummaryStatistics&gt; lottoResult) { return lottoResult.values() .stream() .mapToLong(LongSummaryStatistics::getSum) .sum(); } . | . | (후) . 누적합을 IntSream으로 변환해서 .sum() 하는게 &gt; reduce(0부터, 변환하면서 누적) 하는 것보다 깔끔하다. . IntStream 스트림을 사용하면 sum() 메서드 활용이 가능해서, 더 읽기좋을 것 같아요. 그리고 메서드체이닝(.)을 행 단위로 나눠주시면 더 읽기 좋습니다 👍 . //수정전 return rankResults.entrySet().stream().map(Entry::getValue).reduce(0, Integer::sum) * Lotto.LOTTO_PURCHASE_MONEY; //수정후 return rankResults.entrySet().stream() .mapToInt(Entry::getValue) .sum() * Lotto.LOTTO_PURCHASE_MONEY; . | . | . Factory . 개인적으로는 객체생성의 롤을 객체에게 전담하도록 하는 편이고, Lotto 와 같이 생성이 복잡한 일부분에 대해서만 팩토리를 사용하는 편이에요. 참고만 부탁드립니다 생성과 팩토리를 통한 생성 두가지가 모두 가능할 때, 이 코드를 유지보수하는 사람이 이 두가지를 적절하게 잘 이용하기 어렵다는 단점도 있을 것 같아요. 객체 생성에 대한 역할을 두 곳에서 관리하고 있기 때문에 | . | . | . test . Nested로 의미가 잘 드러나는 것 같아요🙂 . 여기서는 가독성이라는 측면이 더 중요한 것 같아요. 이 더 가독성이 좋다면 사용하시면 될 것 같습니다. | 똑같은 상태값 공유하는 것들만 다르게 setUp하는 용도로 쓰자. | . 저 개인적으로는 상태값을 공유하고 그 의미가 비슷한 것들은 @nested로 작성하고 이외에 독립적인 것들은 클래스내에 메소드로 작성하는 것 같아요🙂 - 페어와 팀원과 적절한 룰을 만들어가며 장단을 비교해가면 좋을 것 같습니다. . | . (베) . 테스트는 오히려 먼저 변수 선언 (or초기화)후 -&gt; 나중 할당하는 @beforeEach에서 초기화하기 위해 이용한 가변으로 선언 . //LottoesTest.java private static final Lotto[] LOTTOES = new Lotto[]{ Lotto.create(List.of(1,2,3,4,5,6)), Lotto.create(List.of(11,12,13,14,15,16)), Lotto.create(List.of(21,22,23,24,25,26)), Lotto.create(List.of(31,32,33,34,35,36)) }; 테스트 픽스쳐를 만들어주셨는데요. 지금은 큰 문제가 없지만 이 부분도 가변이 될 수 있어서요. 특정테스트에서 값이 변경되어 디버깅이 굉장히 어려워질 수 있습니다. 이 부분을 @BeforeEach로 빼보시는걸 추천해요🙂 . | . .copyOf() . (리) . 읽기전용을 의미하는 Collections.unmodifiableList()이라도, 원본이 바뀌면 따라 바뀐다. 할당받은 변수만 조작불가 -&gt; 원본과는 연결됨 . 생성자에서 검증에서 파라미터 원본값의 오염가능성 -&gt; 포장이 가진 내부 상태값은 연결고리를 끊고난 것을 주자. -&gt; this.value = List.copyOf() | . //수정 전 validateSize(lottoNumbers); validateDuplicate(lottoNumbers); this.lottoNumbers = Collections.unmodifiableList(lottoNumbers); //이 생성자를 사용하는 곳에서 생성자가 실행된 이후에 전달된 파라미터의 원본 값(지역변수이자 원본 값)에 list 를 조작한 뒤 디버깅을 해보시면 좋을 것 같아요 //수정 후 public Lotto(List&lt;LottoNumber&gt; lottoNumbers) { Objects.requireNonNull(lottoNumbers, ERROR_MESSAGE_FOR_NULL_LOTTO_NUMBERS); validateSize(lottoNumbers); validateDuplicate(lottoNumbers); this.lottoNumbers = List.copyOf(lottoNumbers); // 상태값에는 연결고리를 파라미터와 연결고리륵 } . unmodifiableList(anotherList) 로 선언한 참조변수, 즉 복사본 컬렉션에다가 요소를 추가거나 삭제하려고 할 경우, UnsupportedOperationException이 발생 . 그러나 원본 컬렉션에 요소를 추가 / 삭제할 경우, 복사본 컬렉션에서도 그대로 적용 . | 요약 . 원본 컬렉션과 주소값이 다르며 컬렉션 내부 요소들의 주소값은 동일하다. . | 원본 컬렉션에서 요소 추가, 삭제가 일어날 경우, 복사본 컬렉션에서도 적용된다. . | 복사본 컬렉션에서 요소 추가, 삭제를 시도할 경우 UOE 이 발생되며 실패한다. . | | . | List.copyOf(anotherList);를 통한 방어적 복사를 하려면 . 복사본 컬렉션에 대한 요소 추가 / 삭제 시도 시 UOE가 발생한다는 점은 unmodifiableList와 동일 | 그러나 원본 컬렉션에서 요소 추가 / 삭제 가 일어나도, 영향을 받지 않습니다 | 그럼에도 불구하고 copyOf()로 만들어낸 컬렉션이 완전한 불변이라고 볼 수는 없습니다. 왜냐하면 copyOf의 반환값으로 전달된 unmodifiable list에서 객체를 꺼내서, 그 객체 내부의 값을 변경할 경우, 아니면 외부에서 그 객체의 값을 변경할 경우에는 요소 까지 깊은 복사를 하지는 않았기 때문에 값이 변경됨. 원소들도 불변이여야지 완벽한 불변 | . | . | . new ArrayList&lt;&gt;(anotherList), new ArrayList&lt;&gt;() + addAll() 과 동일합니다. 컬렉션의 주소값은 달라지지만, 요소들의 주소값은 동일합니다. 따라서, 컬렉션 레벨의 요소 추가 / 삭제 는 공유되지 않지만, 요소 레벨의 요소 값 수정 등은 공유됩니다.new ArrayList&lt;&gt;(anotherList), new ArrayList&lt;&gt;() + addAll() 과 동일합니다. 컬렉션의 주소값은 달라지지만, 요소들의 주소값은 동일합니다. 따라서, 컬렉션 레벨의 요소 추가 / 삭제 는 공유되지 않지만, 요소 레벨의 요소 값 수정 등은 공유됩니다. . 공부용 코드 . package lotto; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; import org.junit.jupiter.api.Test; public class ListTest { @Test void modify_UOE() { String[] stringArray = {&quot;a&quot;, &quot;b&quot;}; // 배열 final List&lt;String&gt; stringList = Arrays.asList(stringArray); // 가변 스트링 final List&lt;String&gt; unmodifiableStringList = Collections.unmodifiableList(stringList); System.out.printf(&quot;unmodifiableStringList={}&quot;, unmodifiableStringList); // unmodifiableStringList.add(&quot;c&quot;); System.out.printf(&quot;unmodifiableStringList={}&quot;, unmodifiableStringList); } @Test void wrap_and_modify_original_and_get_unmodifiable() { String[] stringArray = {&quot;a&quot;, &quot;b&quot;}; // 배열 List&lt;String&gt; stringList = new ArrayList&lt;&gt;(Arrays.asList(stringArray)); // 가변 스트링 list //final List&lt;String&gt; unmodifiableStringList = Collections.unmodifiableList(stringList); //원본 List&lt;String&gt;을 포장해서 들고 있으면서, 반환만 Collections.unmodifiableList();시키면 UnmodifiableList unmodifiableList = new UnmodifiableList(stringList); List&lt;String&gt; returnedUnmodifiableList = unmodifiableList.getValue(); // a, b System.out.printf(&quot;returnedUnmodifiableList={ % s}%n&quot;, returnedUnmodifiableList.toString()); //add할때는 원본 list에 add -&gt; 이게 객체내부의 value에도 영향을 미칠까? stringList.add(&quot;c&quot;); // a, b, c -&gt; 원본을 고쳤는데, unmodifiableList만 못건들였지, 같이 수정됨. // -&gt; 쓰기불가지만, 컬렉션 주소를 공유 System.out.printf(&quot;returnedUnmodifiableList={ % s}%n&quot;, returnedUnmodifiableList.toString()); } @Test void wrap_and_modify_original_and_get_copyOf() { String[] stringArray = {&quot;a&quot;, &quot;b&quot;}; // 배열 List&lt;String&gt; stringList = new ArrayList&lt;&gt;(Arrays.asList(stringArray)); // 가변 스트링 list // 마찬가지로 원본을 들고 있으면서, 반환만 copyOf로 해주는 클래스 생성 final CopyOfList copyOfList = new CopyOfList(stringList); final List&lt;String&gt; returnedCopyOfList = copyOfList.getValue(); // a, b System.out.printf(&quot;returnedCopyOfList={ % s}%n&quot;, returnedCopyOfList.toString()); //add할때는 원본 list에 add -&gt; 이게 객체내부의 value에도 영향을 미칠까? stringList.add(&quot;c&quot;); // a, b -&gt; 원본을 고쳤는데도, 콜렉션주소가 공유되지 않아, returnedCopyOfList는 불변 System.out.printf(&quot;returnedCopyOfList={ % s}%n&quot;, returnedCopyOfList.toString()); } private class UnmodifiableList { private List&lt;String&gt; value; public UnmodifiableList(final List&lt;String&gt; value) { this.value = value; } public List&lt;String&gt; getValue() { return Collections.unmodifiableList(value); } } private class CopyOfList { private final List&lt;String&gt; value; public CopyOfList(final List&lt;String&gt; value) { this.value = value; } public List&lt;String&gt; getValue() { return List.copyOf(value); } } } . | . | . | . (후) . 페어 덕분에 copyOf에 대해 알게됐는데요, unmodifiable을 이용해서 반환하는 것만으로도 충분히 값 변환에 있어서 안정성을 보장할 수 있을 것 같은데 앨런은 Java 11에서 왜 Collections를 새로 생성해서 반환하는 copyOf를 만들었다고 생각하시나요? . copyOf도 unmodifiableList를 반환하지 않던가요? 😅 List.of()와 List.copyOf()에 어떤 차이가 있을까요? 둘다 불변을 보장하지만, 매개변수 받아주는 것 차이 - List.of 와 List.copyOf는 둘다 unmodifiableList를 반환하는 것은 같지만 전자는 리스트의 요소가되는 여러 매개변수를 받고 후자는 존재하는 리스트를 받아옵니다! copyOf를 사용하면 새로운 리스트를 만들어 unmodifiable로 반환 -&gt; 도메인에서 직접 unmodifiable을 사용하여 반환하는 것보다도 더 안전하게 리스트를 사용 코멘트 감사합니다! �업무에서 List.of()를 사용하고 있었는데, 조사해준덕분에 알게됐군요! copyOf를 활용 . | . for vs stream . 횟수가 적을 땐 for -&gt; 그 자체를 여러번 돌릴 땐 stream -&gt; 스레드 세이프라면 .parallel()도 선언해서..하면 더 빠르다. . | stream으로 전체 중 일부를 뽑는 랜덤을 구현 . 전체list -&gt; shuffle -&gt; stream + .limit()+ sorted() + 캐슁getInstance + tolist or .limit()대신 list상태에서 .subList() | . private static List&lt;LottoNumber&gt; getAutoLottoNumbers() { List&lt;Integer&gt; lottoNumbersForNewLotto = new ArrayList&lt;&gt;(lottoNumbers); Collections.shuffle(lottoNumbersForNewLotto); return lottoNumbersForNewLotto.stream() .limit(LOTTO_NUMBERS_SIZE) .sorted() .map(LottoNumber::getInstance) .collect(toList()); } . | .",
            "url": "blog.chojaeseong.com/java/feedback/review/%EB%A1%9C%EB%98%90/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/15/%ED%94%BC%EB%93%9C%EB%B0%B1)-1-2(%EB%A1%9C%EB%98%90)-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0.html",
            "relUrl": "/java/feedback/review/%EB%A1%9C%EB%98%90/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/15/%ED%94%BC%EB%93%9C%EB%B0%B1)-1-2(%EB%A1%9C%EB%98%90)-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0.html",
            "date": " • Mar 15, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "강의) 네오 3단계 피드백(블랙잭 상속)",
            "content": "스타버즈 커피전문점을 통한 상속 이해 . 요구사항 . Starbuzz 커피 전문점은 커피와 차를 판매한다. 커피와 차를 준비하는 과정은 각각 다음과 같다. . 커피(coffee) 물을 끓인다. | 필터를 활용해 커피를 내린다. | 컵에 붓는다. | 설탕과 우유를 추가한다. | . | 차(tea) 물을 끓인다. | 차 티백을 담근다. | 컵에 붓는다. | 레몬을 추가한다. | . | . | . 기본 클래스 2개 작성 . Coffee 클래스부터 작성한다 . 요구사항은 /* 로 시작하도록 옮겨놓는다. . . . | 테스트에서 각각의 메서드부터 작성한다. . my) 전체를 모아두는 메서드는… 각각 작성하고 통합호출시 묶어주는 것일 듯? | . . | 메서드들을 한눈에 볼 모든 메서드 호출 메서드 정의하기 . 같은 인스턴스메서드(객체 행위) 단위로서, 현재까지 만든 객체 메서드(행위들)을 모두 한번에 호출해주는 메서드도 Test에서 만든 뒤, 테스트에서의 코드를 잘라내서 내부로 가져가자 . . . | 같은 객체가 호출하던 메서드를 한꺼번에 호출할려고 가져가면, -&gt; 바깥에서 만든 객체로 호출 빨간줄 뜬다. 지워주자. 현재 class내부 = 현재 객체this가 호출하고 있는 중 . . | 모든 메서드들보다위에 위치하도록, 가장 위로 올려준다. . | 비슷한 클래스 Tea클래스도 복붙해서 작성해주자 . public class Coffee { void prepareRecipe() { boilWater(); brewCoffeeGrinds(); pourInCup(); addSugarAndMilk(); } public void boilWater() { System.out.println(&quot;물을 끓인다.&quot;); } public void brewCoffeeGrinds() { System.out.println(&quot;필터를 활용해 커피를 내린다.&quot;); } public void pourInCup() { System.out.println(&quot;컵에 붓는다.&quot;); } public void addSugarAndMilk() { System.out.println(&quot;설탕과 우유를 추가한다.&quot;); } } . public class Tea { void prepareRecipe() { boilWater(); steepTeaBag(); pourInCup(); addLemon(); } public void boilWater() { System.out.println(&quot;물을 끓인다.&quot;); } public void steepTeaBag() { System.out.println(&quot;티백을 담근다.&quot;); } public void pourInCup() { System.out.println(&quot;컵에 붓는다.&quot;); } public void addLemon() { System.out.println(&quot;레몬을 추가한다.&quot;); } } . 상속으로 중복코드제거 -&gt; 공통메서드를 부모클래스를 만들어 올려서 제거(super를 생략하고 쓰는 것) . . boilWater()와 pourInCup() 2개 메서드가 중복이다. | . 클래스 다이어그램을 통해 본 코드 중복(메서드 중복) . . 중복된 메서드만 빼내서 따로 클래스로 분리한다. | . . 01 중복메서드만을 메서드로 가지는 부모클래스 만들기 . 중복된 2 메서드를 + 각각의 클래스명을 보고 부모클래스를 만든다. . . | 중복된 메서드 2개를 복사해서 가져온다. . . package starbuzz; public class CaffeineBeverage { public void boilWater() { System.out.println(&quot;물을 끓인다.&quot;); } public void pourInCup() { System.out.println(&quot;컵에 붓는다.&quot;); } } . | 02 자식들은 상속한 뒤, 중복메서드 -&gt; 공통메서드로 올렸으니 자식에서 공메 정의부 제거 -&gt; 자식들은 자신만의 메서드만 가지고 있기 -&gt; 사용은 super.생략하고 자기것처럼 쓰기 . . 자식들이 만약 상속한 상태에서 부모가 가져간 공통메서드들을 제거해줘야한다. | 부모가 줄 공통메서드를 삭제해도 빨간줄이 뜨지 않는다. | . 03 부모한테 공통적으로 물려받아 쓰는것들에 대해서는 super.을 붙혀도 된다. . ctrl+ 클릭하면 부모로 타고 올라간다. . | 부모한테 물려받아 쓰는 것들은 super.를 앞에 달아서 부모클래스한테 물려받아 쓰고 있는 메서드라고 써도 된다. . . | . my) 추상클래스로 만든다면, 강제 각자구현용 추상메서드를 추가할 수도 있다. . 참고) 상속대신 주입하는 조합으로 중복제거 . cf) 조합을 적용하여 중복코드를 객체로 박기(정리용) . [공통(중복)메서드를 뽑은 클래스]를 뽑는후 [조합으로 중복제거] like 전략패턴 . 참고 01 공통/중복 메서드들을 잘라내기해서 뽑아낸 클래스를 따로 만든다(상속의 부모클래스) . 아래 메서드 중에 boilWater()과 pourInCup()은 다른 곳과도 중복이라 뽑아낼 준비한다. | . public class Coffee { public void prepareRecipe() { boilWater(); brewCoffeeGrinds(); pourInCup(); addSugarAndMilk(); } . public class CaffeineBeverage { public void boilWater() { System.out.println(&quot;물을 끓인다.&quot;); } public void pourInCup() { System.out.println(&quot;컵에 붓는다.&quot;); } } . 중복된 메서드들을 빨간줄 상태 | . 참고 02 중복제거하고 싶은 클래스(Coffee)를 복붙해서 클래스2(Coffee2)를 만들어 조합적용을 준비한다. . . . 참고 03 조합은, 객체 생성자로부터 외부에서 받은 전략객체같은 조합객체를 받아서 상태로 가지고 있는다 (생성자 -&gt; 상태 초기화) . 나는 CoffeeTest에서 Coffee2 생성자 자동생성을 위해 코드를 작성하고 있다. | 참고 04 조합객체.공통메서드() 들을 호출시켜 중복을 제거한다. . . public class Coffee2 { private final CaffeineBeverage caffeineBeverage; public Coffee2(final CaffeineBeverage caffeineBeverage) { this.caffeineBeverage = caffeineBeverage; } public void prepareRecipe() { caffeineBeverage.boilWater(); brewCoffeeGrinds(); caffeineBeverage.pourInCup(); addSugarAndMilk(); } public void brewCoffeeGrinds() { System.out.println(&quot;필터를 활용해 커피를 내린다.&quot;); } public void addSugarAndMilk() { System.out.println(&quot;설탕과 우유를 추가한다.&quot;); } } . my) 조합으로 중복제거란, 전략패턴 중 전략1개만 외부에서 받는 형태인 것 같다. . 추상화 . 04 공통(중복)메서드를 뽑아 extrends 일반상속으로 사용하고 있다면, 이것 부모클래스를 활용해 [나머지 개별메서들을 추상화]하는 데 활용 할 수 있다.(공통메서드 없어도 빈 공통 클래스로 뽑아만 놓는다면) -&gt; 추상화 후보들(추상메서드 후보들)을 추상화 -&gt; 뽑힌다면 추상클래스로 변경해야한다. . 공통(중복)메서드들은 100% 똑같아서 뽑아서 클래스를 만들고 -&gt; super 생략하고 니것처럼 갖다쓸 수 있게뽑은 클래스에서 정의해줬다. 공통메서드 빼기 -&gt; 상속하기 -&gt; 개별 메서드 추상화 살펴보기의 차례다 | . | 나머지 서로 다른 작업들은??? 이제 메서드 추상화 후보 -&gt; 부모클래스도 추상클래스 후보들일 확인해서 추상화 해야한다. | . | . . 중복이 아닌 메서드들을 추상화에 도전해봐야한다. | . CF) 추상클래스 되는 순간 -&gt; 객체생성X -&gt; Test코드는 에러가 난다 . 공통메서드 추출한 부모 클래스 -&gt; 객체 생성가능 . | 공통메서드 + 추상화 메서드 포함 부모클래스 -&gt; 객체 생성 불가능. 상속만 이용가능 . . | . 05 구현부는 다르지만 메서드이름만 추상화 시도 -&gt; 커피를내린다 + 티백을 담근다의 추상화 -&gt; abstract returnType 내린다() 로 추상화 in 상위클래스 . 2개 메서드를 추상화해서 추상메서드를 정의한다. . . public class CaffeineBeverage { abstract void brew(); public void boilWater() { System.out.println(&quot;물을 끓인다.&quot;); } public void pourInCup() { System.out.println(&quot;컵에 붓는다.&quot;); } } . | 06 추상메서드를 가지는 순간 -&gt; 추상클래스로 바꾼다. . 추상화한 astract 메서드를 명시한 순간부터 추상클래스로 바꿔줘야 에러가 사라진다. . . . | 나머지 메서드도 추상화해주자. . . . | . my) 추상클래스 -&gt; 공통메서드뽑은 일반부모에 + 구현부는 다르지만 메서드 이름만 추상화하여 -&gt; 자식은 extends -&gt; super생략한 체, 부모에서 정의한 공통메서드 갖다쓰기 + 추상메서드 개별구현은 override 강제하도록 하는 일부 구현강제된 부모클래스로 해석하자. . 07 추상화가 끝났다면, -&gt; 추상화전 메소드들 정의부가 아닌 사용(호출)처부터 추상화된 이름으로 변경하여 메소드 호출하도록 바꿔준다. . 추상화된 메서드들은 -&gt; 오버라이딩으로 다시 적용해야한다. 일단 둔다. | 추상화된 메서드들을의 사용처부터 이름을 바꿔준다. | . 추상화후보 메서드들이 주석처리 되서 회색상태였다. 추상화된 이름의 메서드로 호출해주자. | ​ . . 08 추상화된 메서드 정의부는 impl(오버라이딩을 impl로) -&gt; 내용 옮겨 주고 - 삭제의 과정을 가진다. . Generate -&gt; Override을 하면 너무 많은 메소드가 잡히니 implements method를 통해 추상메서드만 구현하여 오버라이딩해준다. | . 오버라이딩이 아니라 impl로 오버라이딩 . . | 기존 개별 구체메서드들의 내용을 옮겨준다 . . . | 기존 구체메서드들은 삭제한다. . . | 동일하게 다른 클래스(Tea)에서도 추메 호출부 이름바꿔주기 -&gt; 추메 정의부 impl로 내용옮겨주고 삭제하기 를 진행해준다. . public class Tea extends CaffeineBeverage{ void prepareRecipe() { boilWater(); brew(); pourInCup(); addCondiments(); } @Override void brew() { System.out.println(&quot;티백을 담근다.&quot;); } @Override void addCondiments() { System.out.println(&quot;레몬을 추가한다.&quot;); } } . public class Coffee extends CaffeineBeverage{ public void prepareRecipe() { boilWater(); brew(); pourInCup(); addCondiments(); } @Override void brew() { System.out.println(&quot;필터를 활용해 커피를 내린다.&quot;); } @Override void addCondiments() { System.out.println(&quot;설탕과 우유를 추가한다.&quot;); } } . | 09 추상화를 끝내고 -&gt; 추상화 호출부 이름변경(통일)로 인한 공통(중복)메서드가 추가로 생길 수 있다 -&gt; 다시 부모로 빼준다. . 추상화 IMPL 오버라이딩된 정의부는 서로 다르게 구현되므로 이름은 같지만 공통메서드로 볼수 없다 . | 추상화 사용처()는 이름이 자식들이 같아지므로, 공통메서드/중복메서드가 생길 수 있다 -&gt; 보이면 부모 클래스로 빼면 된다. . . . | 메서드 순서 맞춰주기(현재 추상메서드만 위에서 정의해놨을 듯..) . . | 10 extends -&gt; 정의도 안되어있는데 super생략한 체로 공통메서드를 실제 내부 or 외부에서 인스턴스가 사용 확인해보기 . 현재 Coffee클래스 . **extends로 상속하고 있다. ** super는 생략되어있지만 부모로 빼놨던 공통메서드를 내부에서 쓰고 있다 | . | . public class Coffee extends CaffeineBeverage{ @Override void brew() { System.out.println(&quot;필터를 활용해 커피를 내린다.&quot;); } @Override void addCondiments() { System.out.println(&quot;설탕과 우유를 추가한다.&quot;); } } . | **메인 메서드를 만들고 -&gt; 상속한 자식클래스 인스턴스를 만든 뒤 ** . Coffee 내부에는 정의되어있지 않지만, 부모에게 상속된 공통 메소드를 바로 호출할 수 있다. | . public class Application { public static void main(String[] args) { final Coffee coffee = new Coffee(); coffee.prepareRecipe(); // 정의 안된 메서드인데 extends 공통메서드라면 바로 사용 가능 } } . | 추상화부터 하는 방법도 있다. 정답은 없다. 처음부터 완벽하게 추상화 x -&gt; 공통처리부분이 발견될 시 처리하는게 좋다. . cf) 추상클래스 인스턴스화(=구체화) 안되는 이유: 구현부 없는 추상메서드 때문에 추상클래스가 됬으므로..ㅋ -&gt; 구현부정의와 같이 객체를 만들어줄 수도 있다. . 공통메서드를 추출한 부모클래스를 활용해서, 구현부는 다르지만 이름만 공통으로 추상화하였다 = 추상메서드 들고 있다 = 추상클래스가 부모다 &gt; 인스턴스화 안된다. . | 인스턴스화를 하려면 내부에 구현부 없이 이름만 추상화한 추상메서드를 인스턴스화 하면서, {}]중괄호 블럭로 자식클래스처럼 바로 클래스 구현하면 된다. . . | 중괄호{}로 클래스를 구현하는 것을 람다 와 동일하게 익명클래스라 부른다. . . 익명클래스를 자식클래스와 동일하게 작성하더라도, 별개의 익명클래스다 | . | . quiz) 추상클래스는 추메가 무조건 있어야할까? . 추메 없어도 된다. . | 추메 없으면 객체 생성해도될까? -&gt; 구현부없는 놈을 안가지고 있어도 객체생성은 안안된다. . 구현할 내용이 없어도 { } 중괄호 블럭 가진체로 만들어야한다. | . | . 추메를 안가지는데 추상클래스를 구현했다면 고민해봐야한다. . 추메 -&gt; 구현부는 다르지만 공메를 가진 부모클래스에서 구현부제외 이름만 추상화해놓은 것 추메가 없다? 그냥 부모가 가진 공통메서드만 super생략 갖다쓰는 일반 상속이면 된다. | | . | . 업캐스팅 vs 다운캐스팅 . 업캐스팅 = 다형성 = 추상체로 변수,파라미터,응답값 받기 . 변수/파라미터/응답Type은 추상체(up)로 받을 수 있다. 구상체들을 한번에 처리할 수 있다. . | List쓸 때 많이 쓰는 업캐스팅개념이다. . . public class Application { public static void main(String[] args) { //업캐스팅 final CaffeineBeverage caffeineBeverage = new Tea(); final List&lt;Tea&gt; list = new ArrayList&lt;&gt;(); } } . | . 다운캐스팅 = 추상체상태에서 -&gt; 구상체로 돌아가 구상체만의 메서드/상태 사용가능해진다. . 01 구상체 or 자식만의 메서드는 편하게 가질 수 있다. . Tea에 Tea만의 메서드(some_t())가 있다고 치자. . . | 02 문제는 추상체/부모형으로 업캐스팅 된 상태에서는, 개별구상체 본인이라도, 메서드를 호출이 안된다. . . 업캐스팅된 부모타입이라면, Type자체가 부모상태라 안된다. | . 03 추상체 상태의 구상체를 (다운캐스팅)하면, 자신만의 메서드를 사용할 수 있다. . . 변수를 캐스팅하려면 괄호가 2개가 필요하다. . final CaffeineBeverage beverage = new Tea(); // beverage.some_t(); //(Tea)beverage.some_t(); ((Tea) beverage).some_t(); . | . 04 문제는 엉뚱한 구상체를 다운캐스팅해도 호출()된다 == 컴파일 타임에 처리 못하는 에러 -&gt; 캐스팅에러가 무섭다. -&gt; 신중하게 써야한다. -&gt; 다운캐스팅은 instanceof + .class.cast()메서드와 함께 !! . new Coffee 인스턴스 -&gt; 추상체 -&gt; (Tea)로 다운캐스팅 해도 some_t()가 호출시 에러는 안난다 == 컴파일시 에러가 안난다. . . public class Application { public static void main(String[] args) { final CaffeineBeverage beverage = new Coffee(); ((Tea) beverage).some_t(); } } . | 하지만 돌려보면, 캐스팅 에러가 난다. . | 다운캐스팅후 자신만의 메서드호출 -&gt; 반드시 instanceof로 직접 확인하고 호출해줄 것 . public static void main(String[] args) { final CaffeineBeverage beverage = new Coffee(); if (beverage instanceof Tea) { ((Tea) beverage).some_t(); } } . | 괄호2개 캐스팅 말고 가독성을 위해 -&gt; 해당클래스.class.cast( )로 다운캐스팅해서 써도 된다. . if (beverage instanceof Tea) { Tea.class.cast(beverage).some_t(); } . | isinstanceof도 가독성을 위해 아래와 같이 수정할 수 있다. . if (Tea.class.isInstance(beverage)) { Tea.class.cast(beverage).some_t(); } . | .",
            "url": "blog.chojaeseong.com/java/%EC%83%81%EC%86%8D/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4/%EC%A1%B0%ED%95%A9/%EC%BA%90%EC%8A%A4%ED%8C%85/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/15/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EC%83%81%EC%86%8D,%EC%A1%B0%ED%95%A9,%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4,%EC%BA%90%EC%8A%A4%ED%8C%85.html",
            "relUrl": "/java/%EC%83%81%EC%86%8D/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4/%EC%A1%B0%ED%95%A9/%EC%BA%90%EC%8A%A4%ED%8C%85/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/15/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EC%83%81%EC%86%8D,%EC%A1%B0%ED%95%A9,%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4,%EC%BA%90%EC%8A%A4%ED%8C%85.html",
            "date": " • Mar 15, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "TDD 6 로또(캐슁,Factory,전략)",
            "content": "캐슁 . 19 싱글톤을 이용한 [단일객체 CACHE] 적용과 TDD . 싱글톤을 이용한 CACHE 생성 2가지 방법(정리용) . 싱글톤 생성 방법 . static final으로 클래스 CACHE변수; 선언 . 바로 옆에서 = 할당하며 초기화 or 길어서 static { 클래스변수 = } 블럭(final도 가능)에서 초기화 바로 초기화하든, static블럭에서 초기화하든 null이 아닌 상태의 캐쉬변수 | . | 이후 정팩메로만 생성된 CACHE객체 or 생성된 CACHE자료구조에서 1개만 get하여 제공 이후 기본생성자는 CACHE 최초 초기화하며 채울때만 사용됨 | . | . private static final Map&lt;Integer, LottoNumber&gt; LOTTO_NUMBER_CACHE; static { LOTTO_NUMBER_CACHE = IntStream.rangeClosed(LOTTO_NUMBER_MIN, LOTTO_NUMBER_MAX) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } private final int number; public LottoNumber(final int inputNumber) { this.number = inputNumber; } public static LottoNumber from(final String inputNumber) { final int number = Integer.parseInt(inputNumber); validateLottoNumberRange(number); return LOTTO_NUMBER_CACHE.get(number); } . | static으로 클래스 CACHE변수; 선언 (no final) . 이후 정팩메에 synchronized달아주고 . | 정펙매내부에서 초기화 한번도 안된 최초 if (CACHE == null) 상태의 캐쉬변수일 때만, 기본생성자로 CACHE변수 초기화 | 정펙매로만 생성된 CACHE객체 or 생성된 CACHE자료구조에서 1개만 get하여 제공 | . private static Map&lt;Integer, LottoNumber&gt; LOTTO_NUMBER_CACHE; private final int number; private LottoNumber(final int number) { checkNumberRightRange(number); this.number = number; } public synchronized static LottoNumber valueOf(final int number) { checkNumberRightRange(number); if (LOTTO_NUMBER_CACHE == null) { LOTTO_NUMBER_CACHE = IntStream.rangeClosed(MIN_LOTTO_NUMBER, MAX_LOTTO_NUMBER) .boxed() .collect(Collectors.toMap(lottoNumber -&gt; lottoNumber, LottoNumber::new)); } return LOTTO_NUMBER_CACHE.get(number); } . | | Test에서부터 빨간줄로 넘어가 -&gt; 캐쉬 적용하기 . 캐쉬로 받아먹으려면 싱글톤 받아주는 정펙매(getInstance())로만 가져와야한다. . 네이밍을 그렇게 했어도 기본 생성자에 넣어줄 파라미터도 받아야한다. | . | 싱글톤의 동시성 잇슈를 처리하기 위해 synchronized를 접근제한자 &lt;-&gt; static 사이에 넣어준다. . public synchronized static void getInstance(final int value) { } . | 앞으로 정펙매로만 제공되어야하므로 도메인 검증을 여기로 옮기자. . 기존 도메인테스트가 new 기본생성자()로 진행되어있으니, 그냥 두고 -&gt; 맨 나중에 도메인검증을 정팩메코드로 + 기본생성자는 private + 검증은 삭제하도록 수정하자.. | . | . public LottoNumber(final int value) { // 지금은 임시로 살려둔다. 테스트를 나중에 바꿀 때 private로 변경 + 검증삭제 validate(value); this.value = value; } public synchronized static void getInstance(final int value) { //2. 검증은 여기로 옮긴다. 왜냐면, 앞으로 CACHE정팩메로만 제공될 것이기 때문. // - 정적안에 들어가므로 검증메서드가 static으로 바뀐다. validate(value); } . | CACHE의 static변수 선언을 직접 안하고 빨간줄생성 하기 위해, . 빨간줄로 if ( == null )부터 static 초기화 를 작성해줬다. 기본생성자는 이제 여기 캐쉬생성에서만 이용되어야한다. 원래는 private으로 바꾸고, TEST다 처내야함. | . | . | static 메서드 내 자동 생성시 constant = static final이므로 그냥 field -&gt; static필드로 생성하자. | . . public class LottoNumber { private static final int MIN = 1; private static final int MAX = 45; // 자동 생성한 CACHE field (static) private static Map&lt;Integer, LottoNumber&gt; CACHE; private final int value; public synchronized static void getInstance(final int value) { validate(value); //3. 캐쉬로 제공될 static 변수; 만 선언하고 -&gt; if null일 때 = 최초에만 초기화 시켜준다. // - Map으로 만들거면 // - 중간에 .map( number -&gt; )없이 맨 나중에 toMap으로 만들면 된다. // - intStream은 Integer가 아니다. toMap에 들어가려면 .boxed() 먼저 해주고 들어가야한다. // - toMap의 2번쨰 인자는 method reference만 사용 가능하다. new LottoNumber(Number하니 안되더라) if (CACHE == null) { CACHE = IntStream.rangeClosed(MIN, MAX) //.map( number -&gt; ) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } } . | 정팩메에서 캐쉬객체 or 캐쉬 자료구조.get()한 것을 응답해준다. . public synchronized static LottoNumber getInstance(final int value) { validate(value); if (CACHE == null) { CACHE = IntStream.rangeClosed(MIN, MAX) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } // 제공은 이제 기본생성자가 아닌, CACHE에서 제공해준다. return CACHE.get(value); } . | 검증이 넘어간 캐쉬 정팩메로 생성 테스트로 마무리 . @Test void cache_create() { assertDoesNotThrow(() -&gt; LottoNumber.getInstance(6)); } . 갯수만큼 일급&lt;List&gt; 생성 -&gt; 메인로직이 도메인 생성이라 static 일급Factory 를 거치도록 기능 분리 . static Service는 재료를 받아 메인로직의 흐름을 호출 및 처리한다. **일급생성은 일급 생성자에서 하면 되지만, 일급List 생성 with Money만큼은 단순히 한번 더 포장하는 것보다 복잡하다. ** 도메인 생성 로직을 서비스가 아닌도메인Factory.메서드()를 거친 뒤 -&gt; 그 응답값(일급의 리스트)을 필요에 따라 포장하던지 해야한다. | . | 도메인 생성의 역할이므로 service로직이 아니라 도메인 로직쪽이라 서비스는 호출만 해준다. | . | 앞으로 생성의 방법이 여러갈래 (Manual/Auto)로 외부에서 주입될 가능성이 높아도 도메인Factory에서 외부 생성타입 주입을 받아주는 역할을 해준다. | . 20 Service에서 복잡한 도메인 생성( 갯수만큼 일급List 생성)을 호출한다면, service에서 호출해주는 정적Static한 도메인Facotry가 도메인로직으로서 생성을 담당한다. . Service에서 생성로직을 호출하되, 메서드는 Factory가 가져간다. 가장 정제된 원시Type을 인자로 받는다. . 사정상 여기선 정제된input으로 new LottoMonety(3000)의 포장도메인 대신 장제된 원시값인 3000(원)을 인자로 넣어준다. . **원래는 new LottoMoney(도메인)을 넣어줘야하는데, 도메인 클래스 포장은 나중에 하고 정제된 input을 가정하고 원시값으로 호출해서 점점 포장해나가므로 ** 가장 원시값을 [포장도메인VO 입력 -&gt; 도메인.getter를 내부에 호출하는] 대신 바로 쓸 수 있는 원시값을 파라미터로 일단 제공해서 생성한다. | . | . . @Test void issue_lotto_by_money() { LottoService.issueByMoney(3000); } . | . 실제 Serivce내 도메인 생성관련 모든 로직은 도메인내부or도메인Factory에 일임시킨다. . Service내에서 class부터 생성해야한다면 . class -&gt; classTest -&gt; classTest에서 메서드 빨간줄 생성 -&gt; 메서드생성 | . public static void issueByMoney(final int money) { // input으로 money -&gt; money에게 횟수로 치면 몇번이냐 물어볼 예정임. final int count = money / 1000; LottoFactory.issueByCount(count); } . | 메서드 생성이 [컨셉과 파라미터가 잡힌 경우]는 프로덕션 빨간줄로 생성하되 ClassTest 빨간줄까지 가서 메서드 생성 완료하기! . 메서드 생성을 프로덕션에서 해야할 경우, 컨셉과 파라미터가 잡힌 경우, Test에서 메서드 생성하기가 쉽지 않다. . 프로덕션에서 메서드의 컨셉과 파라미터가 잡힌 경우 -&gt; 프로덕션 빨간줄로 메서드 생성하되 ClassTest-&gt;해당 메서드호출까지 작성 완료한다. . . | 클래스 생성후 바로 ClassTest생성 -&gt; 생성 원하는 메서드 호출까지 완료한 뒤 로직 작성할 것 . . | . | . [갯수(raw숫자)만큼 반복로직]은 VO로 바뀔 것 대비 [틀을 잡아 while로 돌리기] . 차후 미래에 VO로 포장시 . public static void issueLottoByCount(final int count) { Count count = new Count(number); while (count.isNotFinished()) { count = count.decrease(); // 반복되는 단일로직 issueLotto } } . | 현재 . VO count를 0까지 허용하면서, 깍아내려가다가, 0일 때, 튕겨나가게 할 것이다. | 그전까진 내부에서 1개씩 깍으면서 반복하기 | . public static void issueLottoByCount(int count) { while (count != 0) { count-=1; // 반복되는 단일 로직 issueLotto } } . . | . 내부에서 정의될, [1개당 도메인 생성]로직도 도메인Factory내 메서드로 정의 . 프로덕션내 메서드 정의 해야한다면, 빨간줄 생성후 ClassTest에서 메서드 호출까지 완료해라고 했다. . . | 프로덕션빨간줄 생성이라면 -&gt; private이라도 public수정후 TestGenerate로 ClassTest 생성 -&gt; 메서드호출까지 완료 시키기 . 메서드의 접근제한자를 private -&gt; public으로 수정 . 나중에 다 public 메서드들 조사하면 될 듯 -&gt; 테스트에서만 사용시 삭제or Private화 시키면 될 듯 | . . | private -&gt; public 수정후에는 Test메서드로 자동생성 됨. . | 생성된 테메에서 메서드 호출까지 완료하자 . . . | 21 CACHE된 단일 객체는 -&gt; Static한 [도메인Factory]의 Static {} 블럭에서 미리 뽑아놓을 수 있다. . 재료가 되는 도메인은 의존/갖다써도/상수는 public으로 바꿔써도 된다. . . public class LottoFactory { static { //1. Factory는 재료도메인을 의존해서 사용해도 된다. // -&gt; 재료 도메인내 상수를 public으로 바꿔서 Facotry에서 같이 쓰자. //2. 캐쉬된 것들을 static 블록에 다 모아놓는다. (랜덤구현은 [메서드 호출시 shffle + subList] IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(it -&gt; LottoNumber.getInstance(it)) .collect(Collectors.toList()); } . suffle과 subList를 통한 랜덤구현을 위해 []미리CACHE된 재료만 다 static{}블럭]에서 준비한다. . 준비물들을 미리 뽑아놓고 -&gt; 상수 추출을 한다. . | split 선언 &lt;-&gt; 초기화시키면 알아서 static블럭에서 초기화시켜 미리 준비되도록 한다. . . public class LottoFactory { private static final List&lt;LottoNumber&gt; LOTTO_NUMBERS; static { LOTTO_NUMBERS = IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(it -&gt; LottoNumber.getInstance(it)) .collect(Collectors.toList()); } . | 21 정해진 갯수에서 일부 랜덤이다? -&gt; 정해진 갯수 셔플 + subList(or .limit)으로 랜덤을 구현 . CACHE(static 싱글톤)을 이용한 static {}블럭에 준비된 랜덤준비물들을 랜덤이 필요한곳에서 shuffle + subList or .limit으로 구현하기 . public static Lotto issueLotto() { //3. [랜덤한 6개 뽑기] 구현을 [미리 준비된 cache 들] -&gt; shuffle &amp;&amp; 일부뽑기로 구현한다. Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } . | random한 일급 테스트 -&gt; getter후 size + 제한된 범위(단일객체의 경계값) 검사 . @Test void issueLotto_count() { final Lotto lotto = LottoFactory.issueLotto(); assertThat(lotto.getValue().size()).isEqualTo(6); } @Test void issueLotto_range() { final Lotto lotto = LottoFactory.issueLotto(); final ListIterator&lt;LottoNumber&gt; lottoNumberIterator = lotto.getValue().listIterator(); while (lottoNumberIterator.hasNext()) { assertThat(lottoNumberIterator.next()) .isGreaterThanOrEqualTo(LottoNumber.getInstance(1)) .isLessThanOrEqualTo(LottoNumber.getInstance(45)); } } . 22 다시 [횟수만큼 반복되는 도메인생성] 메서드 처리 . 단일 생성의 테스트를 마쳤다. . public static void issueLottoByCount(int count) { while (count != 0) { count -= 1; LottoFactory.issueLotto(); } } . | . 2번 이상의 add라면, 지역변수 가변 new ArrayList에 add해서 반환 . count만큼 반복해서 로또 발급후 add해서 반환해야한다. . public static ArrayList&lt;Lotto&gt; issueLottoByCount(int count) { final ArrayList&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (count != 0) { count -= 1; lottos.add(LottoFactory.issueLotto()); } return lottos; } . | 테스트에서, 랜덤한 3개 로또 발급에 대해 갯수정도만 테스트한다. . 단일 생성 테스트보다 더 밑으로 테스트를 옮겨주자. | . @Test void issue_by_count() { LottoFactory.issueLottoByCount(3); } . @Test void issue_by_count() { final List&lt;Lotto&gt; lottos = LottoFactory.issueLottoByCount(3); assertThat(lottos.size()).isEqualTo(3); } . | . 23 다시 Service로 돌아와 응답값 만들고 -&gt; 메서드 퉁 테스트 . public static List&lt;Lotto&gt; issueByMoney(final int money) { // input으로 money -&gt; money에게 횟수로 치면 몇번이냐 물어볼 예정임. final int count = money / 1000; return LottoFactory.issueLottoByCount(count); } . @Test void issue_lotto_by_money() { final List&lt;Lotto&gt; lottos = LottoService.issueByMoney(3000); assertThat(lottos.size()).isEqualTo(3000 / 1000); } . 서비스의 메인로직 진행 중 추가 로직(비교&amp;검증)이 발생하는데, 도메인의 영역이라면? -&gt; 대상들을 포장에 포장이라도 새로운 도메인으로 . 24 Service메서드 [파라미터들의 검증로직에 의한 개별 포장] 끝났는데, 또 [추가 검증 로직]이 서비스에 늘날려고 한다? . 포장된 일급과 단일의 검증인데도 또 포장? . **당첨로또와 보너스볼 번호는 중복되면 안되며므로 추가 검증 로직이 필요하고, 항상 붙어다닌다 -&gt; 2개 상태값을 가진 포장체 ** Lotto인데 굳이 포장해야하나? -&gt; 추가 검증이 필요하므로 일급vs단일의 검증인데도 2개 인변가지는 도메인으로 새로 포장 해야한다. 안그러면 서비스 ( or 컨트롤러)에 로직이 늘어난다. | . | 포장하기 전, [ service 테매 복붙]하고 case반영한 테메이름 바꾸고 -&gt; 메서드 추가해주기 . 테메 복붙해서 case반영해서 이름 바꿔주기 . | 포장해서 만들어나간다. . | 포장 도메인 만들어놓고, 생성자만 처리해준다. . 일단 하나는 value + 하는 구체적인 이름으로 적었다. | . public class WinningLotto { private final Lotto value; private final LottoNumber bonusNumber; public WinningLotto(final Lotto value, final LottoNumber bonusNumber) { this.value = value; this.bonusNumber = bonusNumber; } } . | 새롭게 포장된 파라미터를 받는 (차후 새 기준이 될)메소드도 추가 -&gt; 가장 위로 올린다. . 메서드 이름은 같고… 파라미터만 다른게 쌓여나간다. . 이놈이 새로운 | . . | 새 기준이 될 메서드를 가장 위로 올려보자. . . | . 직전 기준 메소드의 내용을 복붙 -&gt; 포장된 파라미터에 맞추어 빨간줄을 없앤다. (주로 getter로 임시처리) . 직전의 파라미터명과 비교해서 맞춰준다. | . 포장전 객체앞에다가 새롭게 포장.getter()을 통해 에러를 없앨 수 있다. . . | 포장 + 포장파라미터메서드 생성 -&gt; 새 기준 메서드로 지정하기- &gt; 전 메소드는 전 파라미터 -&gt; 포장후 호출하도록 변경 . . . public class LottoService { public static Rank match(final Lotto userLotto, final WinningLotto winningLotto) { final int matchCount = userLotto.match(winningLotto.getValue()); final boolean matchBonus = userLotto.contains(winningLotto.getBonusNumber()); return Rank.of(matchCount, matchBonus); } public static Rank match(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { return match(userLotto, new WinningLotto(winningLotto, bonusNumber)); } . 포장에 원하던 [생성자에 검증 로직 추가]후 테스트하기 . public WinningLotto(final Lotto value, final LottoNumber bonusNumber) { if (value.contains(bonusNumber)) { throw new IllegalArgumentException(&quot;당첨 번호와 보너스볼은 중복될 수 없습니다.&quot;); } this.value = value; this.bonusNumber = bonusNumber; } . 서비스에서 | . 서비스로 퉁 치던 테스트를 [도메인Test] 생성시 [경계값Test]하기 . WinningLottoTest 만들어서 경계값 테스트하기 . @ParameterizedTest @CsvSource({&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;}) void duplicate(final int bonusNumber) { assertThatThrownBy(() -&gt; new WinningLotto( new Lotto(1, 2, 3, 4, 5, 6), new LottoNumber(bonusNumber))) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;중복&quot;); } @ParameterizedTest @CsvSource({&quot;7&quot;, &quot;8&quot;, &quot;45&quot;}) void valid(final int bonusNumber) { assertDoesNotThrow(() -&gt; new WinningLotto( new Lotto(1, 2, 3, 4, 5, 6), new LottoNumber(bonusNumber))); } . | 새 기준 메서드에 임시처리(포장.getValue) 부분 메세지로 보내기 (과정) . 기존 임시처리 . public static Rank match(final Lotto userLotto, final WinningLotto winningLotto) { final int matchCount = userLotto.match(winningLotto.getValue()); final boolean matchBonus = userLotto.contains(winningLotto.getBonusNumber()); return Rank.of(matchCount, matchBonus); } . | . getter()를 제거해서 빨간줄을 낸다. . . | 기존 사용처에 대해 바로 변경이 아니라 메서드 생성 -&gt; 내부 내용 복사를 통해 백업한 체로 진행한다. . 이 경우, 새로운 메서드를 정의해주고, 기존 메서드 바로 밑으로 가져와서 비교하며 처리한다. | . . . | 새로운 기준을 만들어 나가며, 완성대면 완전히 대체한다. . //public int match(final Lotto other) { // return (int) other.value.stream() // .filter(this::contains) // .count(); //} public int match(final WinningLotto winningLotto) { return (int) winningLotto.getValue().value.stream() .filter(this::contains) .count(); } . | 나머지도 . //public boolean contains(final LottoNumber number) { // return value.contains(number); //} public boolean contains(final WinningLotto winningLotto) { return value.contains(winningLotto.getBonusNumber()); } . | 새 기준 메서드로 바꿨음에도 [기존메서드]가 다른데서 사용중인지 보고 가서 처리한다. . . 못바꾸는 부분이 있다면 그대로 둔다. | . 단일 결과의 메인로직(도1 vs 도2)을 여러번 돌리며 [결과값을 모으는 자료구조]도 포장하는 로직 . match()를 내부에서 여러번 호출하여 발생하는 것들을 map에 모아서 controller 응답한다. . | 결과값 map에 대한 계산로직도 포함될 예정이므로 생성될 자료구조(map)을 생성자에서 생성후 -&gt; 변수 포장하도록 class로 뺀다. . | . 25 단일결과by메인로직(도메인1 vs 도메인2)을 바깥에서 여러번 호출해서 발생하는 결과값을 저장할 새로운 자료구조가 나온다. -&gt; [결과값 저장 로직]을 생성자로 넘겨 -&gt; [최종 결과값 자료구조를 시작 상태값]으로 가지면서 + 관련로직을 메서드로 가지는 도메인3(Result도메인) 만들기 . 단일결과 로직(도메인1 vs 도메인2)인 메인 메서드의 파라미터 포장까지 완료된 상태여야만 -&gt; 바깥에서 여러번 돌릴 때, 포장된 것을 받을 수 있음 . 내부 단일결과를 유발하는 메인로직 메서드의 파라미터가 이미 포장이 끝났다. -&gt; 바깥에서 개별 결과값을 모으는 메서드도 포장된 값을 받는다. . 단일 결과(Enum)을 응답하는 메서드는 파라미터를 포장된 것을 받는다. | 바깥에서 결과값들을 모을 메서드 -&gt; 포장된 것을 받아야 편하다. | . @Test void get_result() { //1. 메인로직(match)를 여러번 호출해서 결과값을 받을 Service.메서드 // -&gt; 메인로직에 필요한 파라미터(Lotto여러개 + WinningLotto)는 넘겨줘야한다. final List&lt;Lotto&gt; lottos = List.of( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1, 2, 3, 4, 5, 7), new Lotto(1, 2, 3, 4, 7, 8) ); //0. 내부 메인로직(도1vs도2)의 파라미터 포장까지 완료되었을 때, // -&gt; 바깥에서 복수의 포장을 받아, 여러번 돌려 -&gt; 결과값을 저장할 수 있다. LottoService.getResult(lottos, new WinningLotto( new Lotto(1, 2, 3, 4, 5, 7), new LottoNumber(6))); } . | . 일단은 Service.Method내부에서 [메인로직을 돌리기]를 정의를 하다가 -&gt; 필요에 의해 옮기고 포장하자. . 현재 Service.getResult( , )에서 자료를 받아서, 현재는 서비스에서 호출하고 있던 메인로직(도1vs도2 비교)를 호출도 한다. . public static void getResult(final List&lt;Lotto&gt; lottos, final WinningLotto winningLotto) { //2. 일단 service내부에 도메인 계산로직을 작성한다. final List&lt;Rank&gt; results = lottos.stream() // 3. Service를 통해 돌리다보니, 1:1 단일결과(메인로직)을 호출할 수 밖에 없는데 // -&gt; 돌리는 이것 역시 서비스에서 호출하는 메서드였다. // -&gt; 만약, 결과값 모으는 곳으로 간다면 바뀌어야할 것 같다. .map(lotto -&gt; match(lotto, winningLotto)) .collect(Collectors.toList()); } . | 26 [결과값을 모은 List를 카운팅하는 새로운 응답(자료구조)] 만들기 . 단일 결과값들을 돌아가며 호출결과값 List를 모은다. | . Enum List -&gt; EnumMap에 카운팅하기(정리용) . List&lt;객체&gt;의 갯수를 객체를 key로 하는 hashMap Map&lt;객체, Integer&gt; 에 세야한다. | . 빈 Map 선언 및 초기화 . 객체의 Count을 원한다면 **&lt;객체key, Integer&gt;로 Map을 선언한다. ** (cf) 원시적으로는 직접 0으로 초기화 한다.) . EnumMap이라면 ( )생성자에 안에 Enum클래스.class(클래스 자체)를 지정해준다. | . final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); . 참고) . (원시적) 모든 객체key들 stream화해서 돌면서 -&gt; forEach -&gt; map.put(객체key, 0)으로 초기화해준다. . private final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); { Arrays.stream(Rank.values()).forEach(rank -&gt; result.put(rank, 0)); } . | . | EnumMap는 넣고난 뒤, 자동정렬되어있지만 . 일반map넣고 난 뒤, key순으로 정렬되어야하면(순서가 중요하면) hashMap대신 -&gt; linkedHashMap을 사용한다. | . private final LinkedHashMap&lt;Rank, Integer&gt; value = new LinkedHashMap&lt;&gt;(); . | . | 일급vs단일 로직을 먼저 수행한 -&gt; 응답결과List를 카운팅하는 3가지 방법 . 이제 갯수를 셀 결과값List(Enum List or 객체 List)들을 돌면서 카운팅한다. . 결과List(객체List)를 먼저 계산 -&gt; 돌면서 -&gt; . 이미 0으로 초기화해놓고 넣어놨어야한다. | map.put( 객체Key, map.get( 객체key )의 value + 1 ) | . { Arrays.stream(Rank.values()).forEach(rank -&gt; result.put(rank, 0)); } . result.put(rankPrize, result.getOrDefault(rankPrize, 0) + 1); . | 결과List(객체List)를 먼저 계산 -&gt; 돌면서 -&gt; . 미리 0 초기화 없이 알아서 직전value(없으면 0부터) 누적해주는 -&gt; map.merge( 객체key, 누적해넣을값, Integer.sum()으로 기존value와 누적방법 Bifunction ) | . result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after)) . final List&lt;Rank&gt; results = lottos.stream() .map(lotto -&gt; match(lotto, winningLotto)) .collect(Collectors.toList()); final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); results .forEach(rank -&gt; result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after))); . 결과값을 찍어보니 merge로 카운팅이 1개씩 잘 된다. | . | | EnumMap은 아니지만, 일급vs단일 –stream–&gt; 단일vs단일 결과값(객체key)을 뽑아낼 로직 + 카운팅을 동시에 해주는 일급.stream().collect(Collectors.groupingBy( 객체key를 뽑아낼 로직 , summingInt( value -&gt; 1) ) . 결과값List를 뽑는 로직 조차 일급.stream -&gt; 단일vs단일로 객체Key뽑기로직이 내부에 포함됨 . 결과값List를 미리 뽑지 않는다. -&gt; Collectors.groupingBy( , )의 **첫번째 인자에 ** | . // (1)결과값 List를 미리 뽑는 과정 -&gt; 생략됨. //final List&lt;Rank&gt; results = lottos.stream() // .map(lotto -&gt; match(lotto, winningLotto)) // .collect(Collectors.toList()); // (2) map을 미리 선언해두기 -&gt; 생략됨 //final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); // (3) 결과값List를 돌면서 -&gt; merge로 1씩 카운팅 -&gt; 생략됨 //results.stream() // .forEach(rank -&gt; result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after))); // 일급을 돌면서 -&gt; groupingBy(단일vs단일의 [결과값 = 객체key]를 뽑는 로직 , 1씩 누적합하는 로직) return lottos.stream() .collect(Collectors.groupingBy( lotto -&gt; match(lotto, winningLotto), Collectors.summingInt(value -&gt; 1))); . | 27 결과값을 모은 List를 카운팅하는 새로운 응답(자료구조)을 포장하는데 그 생성 과정을 생성자에 넣어서 시작부터 상태값으로 가지자 . 현재 상황 . public static Map&lt;Rank, Integer&gt; getResult(final List&lt;Lotto&gt; lottos, final WinningLotto winningLotto) { return lottos.stream() .collect(Collectors.groupingBy( lotto -&gt; match(lotto, winningLotto), Collectors.summingInt(value -&gt; 1))); } . | . 응답값 포장하기 . returntype 빨간줄 수정 -&gt; 생성 | 결과산출 로직은 포장결과값 생성자로 가져가되, new 포장결과( ) 로 생성되도록 재료추출은 있어야함. . . 대박) 메서드추출로 new 포장( , ) 생성자 or 결과class 정펙매 생성자 호출과 동시에 재료 추출하기 . . . 밖으로 나가서 아무거나 타자치면 invalid해도 완성된다. . . | . 새로운 응답값 을 시작부터 상태 관리되도록 생성자에서 처리해주고 초기화하도록 잘라내서 가져가기 . 기존에 추출된 새로운 응답값 자료구조 추출 로직을 -&gt; 결과값 포장클래스의 생성자로 가져간다. . . | 가져와서 파라미터 부분 + 내용부분만 잘 가져다 생성자로 만든다. . . | 서비스 정의된 에서 단일vs단일 메인 결과값match 로직을 서비스에서 -&gt; 결과 도메인인 여기로 가져오자 . . . . | 이제 생성자에서 뽑아진 result를 상태값으로 가지기 . . . public class LottoResult { private final Map&lt;Rank, Integer&gt; value; public LottoResult(final List&lt;Lotto&gt; lottos, final WinningLotto winningLotto) { final Map&lt;Rank, Integer&gt; value = lottos.stream() .collect(Collectors.groupingBy( lotto -&gt; match(lotto, winningLotto), Collectors.summingInt(count -&gt; 1))); this.value = value; } public static Rank match(final Lotto userLotto, final WinningLotto winningLotto) { final int matchCount = userLotto.match(winningLotto); final boolean matchBonus = userLotto.contains(winningLotto); return Rank.of(matchCount, matchBonus); } . | . | 새 결과값 포장이 끝났으면, Serivce 메서드 테스트 다시 해보기 . @Test void get_result() { //1. 메인로직(match)를 여러번 호출해서 결과값을 받을 Service.메서드 // -&gt; 메인로직에 필요한 파라미터(Lotto여러개 + WinningLotto)는 넘겨줘야한다. final List&lt;Lotto&gt; lottos = List.of( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1, 2, 3, 4, 5, 7), new Lotto(1, 2, 3, 4, 7, 8), new Lotto(1, 2, 3, 4, 7, 8), new Lotto(1, 2, 3, 4, 7, 8) ); final LottoResult result = LottoService.getResult(lottos, new WinningLotto( new Lotto(1, 2, 3, 4, 5, 7), new LottoNumber(6))); System.out.println(result); System.out.println(); } . . 28 결과값 포장Result class의 자체 테스트 . [새로운 응답값 생성로직]이 담긴 [생성자 자체 테스트] with [view에서 쓰일 수도 있는? 삭제될? Count getter(객체key)개발] . 결과값 Map을 만들 재료 중 일부만 setup에 준비한다. 여러 재료라면 가변쉬운것을 테스트에서 -&gt; 많고 복잡한 것을 setup에 고정 . class LottoResultTest { List&lt;Lotto&gt; lottos; @BeforeEach void setUp() { //new LottoResult(lottos, winningLotto); //새로운 응답값 생성(결과값 포장 클래스 생성자)에 필요한 재료 먼저 선언 // -&gt; case별 변동이 쉬운 winningLotto는 놔두고, lottos를 미리 만들어놓자. lottos = List.of( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1, 2, 3, 4, 5, 7), new Lotto(1, 2, 3, 4, 7, 8), new Lotto(1, 2, 3, 7, 8, 9) ); } . | count Map이라면, 맘 편하게 .getCount( 객체key )를 맘편하게 만들자 . 뷰에서 쓸 일 있으면 쓰고, 없으면 삭제하면 된다. default를 0으로 해서 count인 value값을 가져오자. . public Integer getCountByRank(final Rank rank) { return value.getOrDefault(rank, 0); } . | . | 해당 key의 Count를 꺼내와서 정확한지 확인하기 . 할수 있다면, debug 활용해서 내부값 까보면서 같이하면 될 듯. | . @Test void create() { //given -&gt; 1등이 1개 있도록 가정인자를 만들어줌 final LottoResult lottoResult = new LottoResult(lottos, new WinningLotto( new Lotto(1, 2, 3, 4, 5, 6), new LottoNumber(7) )); // map이 세고 있던 객체key를 넣어주고 -&gt; Count를 반환하는 메서드 개발 //when final Integer actual = lottoResult.getCountByRank(Rank.RANK_1); //then assertThat(actual).isEqualTo(1); } } . | 29 새응답 결과값(map)에 계산 로직 더하기 . Service에서 controller로 반환되므로 자체 ResultTest에서 시작 . ServiceTest가 아니라 ResultTest 추가 로직 메서드 개발 시작 | countMap 처리 deafult : value.entrySet() .stream() .map() . CountMap을 돌 때, 기본적인 으로 작성해서 돌아보자 . public void getPrize() { value.entrySet() .stream() .map() } . | map( -&gt; ) 로직에서 getter등장으로 보내야한다면 -&gt; 옆에 값도 같이 보내자. enum.getter * count(it.getValue()) -&gt; enum.메세제( it.getValue() ) . map안에서 enum.getXXX() * count숫자 를 계산해야하는데, getter대신 메세지보낼 때, 같이 보내버리자. . . | 없던 Enum필드도 this.필드명을 바로써서 빨간줄로 바로 생성 . 아직 상금필드를 enum에 정의 안해뒀다. this.필드명을 기입해서 빨간줄로 생성해버리자. . . . . . | ​ ​ . it.getKey()의 enum으로 메세지 보내도록 작성완료 | 누적한다면, matToInt( ) .sum() 일까? map().reduce( )일까? . map()으로 반환받은 int(stream&lt;Int&gt;)는 .sum()이 안된다. . | matToInt()로 반환받은 IntStream만 .sum()의 누적함수 적용된다. . . | . reduce의 불편함과 초기값장점 . mapToType - sum()이 아닌 경우 -&gt; map의 returnType에 따라 reduce(누적)에 type에 맞는 합(누적할연산자)메서드를 직접 넣어준다. . . | 직접 메서드와 초기값을 지정해주지만, stream이 비었어도 에러가 안나고 defaul값이 나온다. . . | . mapToType -&gt; .sum()의 편리함과 불편성(?-&gt; 없다) -&gt; 편한 것 쓰면 될듯 . mapToInt를 써서, .sum()할 stream이 없을 때에도 0이 default로 전달된다. . . | . 30 countMap에 NONE객체 존재 + orElse(NONE)가 있어야하는 이유 -&gt; 전체 갯수도 셀 수 있다. . 당첨못함 : 14명 / 1등: 1명 / 2등: 2명 -&gt; 총 17명의 갯수.. 만약 당첨 못했다고 안셌으면.. ㅠ_ㅜ 전체 로또 갯수를 셀 수 없게 된다. | . | . NONE(여기선 OUT)객체는 존재해야하며, 다른 것이 해당 없을 때도 반환되어야한다. . public enum Rank { RANK_1(2000_000_000, ((matchCount, matchBonus) -&gt; matchCount == 6)), RANK_2(30_000_000, (matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; matchBonus), RANK_3(1_500_000, (matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; !matchBonus), RANK_4(50_000, (matchCount, matchBonus) -&gt; matchCount == 4), RANK_5(5_000, (matchCount, matchBonus) -&gt; matchCount == 3), OUT(0, (matchCount, matchBonus) -&gt; matchCount &lt; 3), // 1. ; //... public static Rank of(final int matchCount, final boolean matchBonus) { return Arrays.stream(values()) .filter(it -&gt; it.condition.test(matchCount, matchBonus)) .findAny() .orElse(OUT); // 2. } . | 로또 전체 갯수를, NONE객체 포함한 COUNTMAP을 통해 구할 수 있다. . values()에 모든 로직이 counting 포함되어있따. . . public long getPrize() { final long totalPrize = value.entrySet() .stream() .mapToLong(it -&gt; it.getKey().getPrize(it.getValue())) .sum(); // 전체 로또 구매수를 countMap의 NONE까지 같이 센다. // -&gt; enum처럼 map도 둘다 values().stream 자동완성으로 돌 수 있다. final int purchasePrice = value.values().stream() .mapToInt(it -&gt; it) .sum() * 1000; return totalPrize; } . | . | long / int라도 둘자 정수니 한쪽에 (double)만 씌우면 된다. . // long vs int 든, int vs int든 나누기가 들어가면 한쪽에 (double)을 씌우자. return totalPrize / (double) purchasePrice; . public double getPrize() { final long totalPrize = value.entrySet() .stream() .mapToLong(it -&gt; it.getKey().getPrize(it.getValue())) .sum(); final int purchasePrice = value.values().stream() .mapToInt(it -&gt; it) .sum() * 1000; return totalPrize / (double) purchasePrice; } . | 31 나눗셈(하나 double)의 Test return되는 것과 같이 구성해버리기 . 0.0을 넣어도 되긴 하지만 당첨금(long) 0L / (double) 구입금액(int) 4000 으로 똑같이 줘서 구성하면 된다. | . @Test void name() { // create 테스트에 쓰던 것 그대로 활용 final LottoResult lottoResult = new LottoResult(lottos, new WinningLotto( new Lotto(11, 12, 13, 14, 15, 16), new LottoNumber(7) )); final double prize = lottoResult.getPrize(); //숫자 비교도 return되는 타입이랑 동일하게 expected주기 // -&gt; totalPrize / (double) purchasePrice; assertThat(prize).isEqualTo(0L / (double) 4000); } . 단위가 정해져 있는 것의 포장( LottoMoney ) . (1) 단위보다 작은지 검사 -&gt; (2) % 단위로 나눈 나머지 !=0 검사 . private static void validate(final int value) { if (value &lt; DIVIDE_UNIT) { throw new LottoMoneyLessException(value); } if (value % DIVIDE_UNIT != 0) { throw new LottoMoneyDivideException(value); } } . 32 대상의 필요성 확인후 포장 시작 . 메서드 실행시 정제된 input으로 money가 왔다고 가정했다. -&gt; 근데 실제로 필요한 건 money / 단위로 산출되는 횟수가 필요하다. . @Test void issue_lotto_by_money() { // new Money(3000) 예약 final List&lt;Lotto&gt; lottos = LottoService.issueByMoney(3000); // money.메세지() 보내서 횟수를 반환받아 그만큼 반복할 예정 assertThat(lottos.size()).isEqualTo(3000 / 1000); } . count도 뽑아내야한다. count도 결국엔 포장해야할 듯. | . public class LottoService { public static List&lt;Lotto&gt; issueByMoney(final int money) { // input으로 money -&gt; money에게 횟수로 치면 몇번이냐 물어볼 예정임. final int count = money / 1000; return LottoFactory.issueLottoByCount(count); } . | . Test에서 포장 시작( 정정: Money -&gt; LottoMoney ) . Test에서 빨간줄로 시작하며 생성하기 . public class Money { private final int money; public Money(final int money) { this.money = money; } } . | 참고) 포장으로 파라미터 달라지는 메테(포장-&gt;자동생성-&gt;끌올-&gt; 내용복붙후 새기준) vs case늘릴려고 복사해서 만드는 테메+메서드2(테매 복-&gt;case반영-&gt;메서드2복 -&gt;메서드2수정-&gt;메서드2통과-&gt; 메서드1대체하여 삭제) 등..은 서로 다른 것 . 생성한 예비 새 기준메서드를 기존메서드 위로 위치를 올린 뒤, 내용 복붙 -&gt; 포장한 것으로 처리되도록 -&gt; 기존메서드는 포장용으로 변경 . 메서드 파라미터를 바꾸는게 아니라, 메서드2로 생성하고 새 기준 메서드가 되도록 포장 파라미터로 처리되도록 한다. . 생성한 예비 새 기준메서드를 기존메서드위로 위치를 이동 | . . . . | ​ . 새메서드의 내용을 포장된 것으로 바꿀 때, 기존값.getter()로 대체해도 되지만 -&gt; 바로 [기존값으로 연산] -&gt; 포장.메서드() -&gt; 포장 내부에서 [this.값으로 연산]하도록 처리해야한다. . 기존메서드의 내용을 복붙해온 뒤 -&gt; 포장파라미터에 맞게 수정해준다. 필요시 getter를 처리했었는데를 연산이 바로 보이는 곳에서는 .메서드()로 처리 해줘도 된다. . . . | ​ . ​ . 기존메서드는 내부에서 파라미터포장+ 새기준 호출만 -&gt; 기존내용은 다 삭제 - &gt; 회색으로 안쓰인다면 버려도 됨. . . 기존메서드가 테스트 등에서도 안쓰이니 삭제 | . 줄어드는 횟수Count VO의 포장(정리용) . 33 count(VO, hasNext패턴 가진 것) 포장 . 미리 원시값도 줄어들 때 hasNext패턴을 만들어두었다. . 내 패턴으로는 0을 허용하면서 더 큰 n부터 줄어들되 0이 아닐때까지, 즉, 1까지도는 것이다. | . public static List&lt;Lotto&gt; issueLottoByCount(int count) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (count != 0) { count -= 1; lottos.add(LottoFactory.issueLotto()); } return lottos; } . 메서드에서부터 파라미터로 전해지도록 Count 포장 (포장은 테매 인자에서부터~ ) . 이름은 도메인Count로 만들어야한다. 포장하는 순간, 대명사가 아니다. . . | . 포장하기 . public class LottoCount { private final int value; public LottoCount(final int value) { this.value = value; } } . | VO는 equals/hC부터 . . count VO는 0까지는 허용해주도록 검증을 만든다. (for while문에서 0까지 간 뒤 0에서 탈출시킴) . public LottoCount(final int value) { if (value &lt; 0) { throw new IllegalArgumentException(&quot;0보다 작을 수 없습니다.&quot;); } this.value = value; } . 새기준메서드 새로 만들어, 기존메서드 위로 위치이동후, 내용복붙후, 처리 . . . . . 값자리에는 포장.getter()를 -&gt; 연산이 할만하면 바로 메세지를 . . . . 값의 연산 -&gt; 포장 안으로 잘라들고가서 this.값으로 연산 . getter지우고 메세지보내기 만약, 지우고 빨간메서드가 남아있다면 그대로 정의해도 된다. | 여기선 연산!=0이 남아있으니, 그에 맞는 의미있는 메서드를 지어준다. 0=Finish가 != 아직 Not이냐 | 남은 연산을 잘라내서 -&gt; 메서드만들고 -&gt; 내부에서 this.값으로 잘라낸 연산 처리 | . | 값의 재할당 -&gt; VO에서는 연산만 들고 들어가면서 메서드를 만들고, 포장 = 는 그대로 둔다. -&gt; 내부에서는this.값으로 연산한 뒤 =에 대해 새VO로 응답하는 [메세지]로 작성한다. . -= 1을 포장 처리하려면 . -1 을 내부로 들고 들어가서 this.값 -1으로 연산 | =은 새 VO를 반환 | . . . | = 놓아두고, -1만 들고 들어가면서, 연산과 관련된 메서드명으로 메세지를 보낸다. . . . . . | 연산을 들고들어갔더라도 바깥에서는 포장변수 = 이 새 VO응답을 기다리고 있으므로 내부연산 결과를 포장해서 응답해준다. . . . final을 풀어 재할당 가능하게 해준다. | . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(LottoFactory.issueLotto()); } return lottos; } . 포장전 기존메서드가 사용중이면 찾아가서, 수정해준다. . . . count가 사용중인데, 일단 money.getCount()의 반환값도 원시count으로 바꿔준다. . public int getCount() { return this.money / 1000; } . . public LottoCount getCount() { return new LottoCount(this.money / 1000); } . public static List&lt;Lotto&gt; issueByMoney(final Money money) { final LottoCount count = money.getCount(); return LottoFactory.issueLottoByCount(count); } . | . 새 기준메서드 완성시, 포장검증을 메서드로 퉁치는 테스트(-1이하에서 에러) . . 자체 도메인Test생성후 Count VO 검사 . 0까지 허용하여 음수 생성자 에러 | . @Test void create() { assertAll( () -&gt; { assertDoesNotThrow(() -&gt; new LottoCount(1)); assertDoesNotThrow(() -&gt; new LottoCount(0)); assertThatThrownBy(() -&gt; new LottoCount(-1)); } ); } . 1개 뽑 + 감소된 것 뽑 -&gt; 감소된 로직후 동일한지 비교 | . @Test void decrease() { final LottoCount lottoCount = new LottoCount(1); final LottoCount expected = new LottoCount(0); // 감소된 것 미리 뽑기 final LottoCount actual = lottoCount.decrease(); assertThat(actual).isEqualTo(expected); } . 랜덤구현 -&gt; 전략패턴으로 수동 더하기(정리용) . 34 [랜덤 최소단위 메서드]를 전략메서드로 바꿔 [수동]도 가능하게 하기 . 전략부위가 만약, 메서드화 안되어있으면(ex&gt;조건식) 메서드화 (추출 등) . 메서드명을 랜덤+수동다 포함하는 일반화 + 목적어 뺌(전략인페+구현전략들에 명시됨)된 전략메서드로 바꿔주기 | . 랜덤 최소단위 메서드 정의부 -&gt; 호출()부 찾기 . 랜덤 메서드 정의부 찾기 . | 랜덤 메서드의 호출부 찾기 . | ##### 랜덤 메서드 호출부에서 랜덤 메서드명을 -&gt; 수동포함하는 일반화된 전략메서드명() + 목적어 제거으로 변경 -&gt; 전략인페를 상속한 new 랜덤전략구현체 객체(). 전략메서드() 인척 빨간줄 생성해주기 . 일반화된 메서드명 상태에서 -&gt; 빨간줄로 외부주입된 랜덤전략구현체 객체 + 전략메서드()호출해준다. . 기존상태( 메서드명을 랜덤+수동다 포함하는 일반화된 + 목적어빠진 전략메서드명으로 바꿔주기) . . 전략메서드에 목적어 넣지마라 | . . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(issue()); } return lottos; } public static Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } . | . | 외부주입된 new 랜덤전략객체에서 호출한 전략메서드()인척 해서 빨간줄로 생성하기 . . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(new RandomLottoIssuer().issue()); } return lottos; } . . | 전략메서드도 작성 . | 랜덤전략객체.전략메서드()로 &lt;- [ 기존 랜덤 메서드 ]에 있던 랜덤 로직 옮겨주기 . public class RandomLottoIssuer { static final List&lt;LottoNumber&gt; LOTTO_NUMBERS; static { LOTTO_NUMBERS = IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(LottoNumber::getInstance) .collect(Collectors.toList()); } public static Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } } . 외부주입 전략객체를 -&gt; 외부파라미터로 받기 위해서 -&gt; 실제 전략인페 정의해주기 . 앞에서 정의한 랜덤전략객체를 보고 전략인페를 생성한다. . RandomLottoIssuer -&gt; LottoIssuer -&gt; 앞으로 xxxxLottoIssuer 등 . | 전략인페명으로 패키지를 만들어서 다같이 넣어주면 좋다. . . | . | 전략메서드명은 다 통일이다. 목적어없이 동사만 . issue() . | 특정전략메서드의 반환타입을 참고해서 추상메서드를 정의해준다. . 랜덤전략의 메서드 반환타입 보고 . | 정의부 복붙해와서 반환타입 + 메서드명빼고 다 달리기 . . . public interface LottoIssuer { Lotto issue(); } . | . | . | ​ . new 외부전략객체() 생성하던 곳으로 돌아가서 -&gt; 변수/파라미터는 추상체로 외부주입 받아, 추상체.전략메서드()하도록 한다. . 기존: 외부주입없이 + 구상체로 사용 . . public class LottoFactory { public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(new RandomLottoIssuer().issue()); } return lottos; } } . | 호출부 중 전략객체만 선택해서 파라미터로 추출 . 전략메서드를 제외한 전략객체만 선택해서 추출하면 된다. . | 추상체 이름과, 파라미터 Type모두 추상체로 바꿔준다. . . public class LottoFactory { public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount, final LottoIssuer lottoIssuer) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(lottoIssuer.issue()); } return lottos; } } . | 처음에는 내부에서 특정 전략객체를 만들어썻찌만 -&gt; 파라미터 추출하면 알아서 외부에서 주입된다 . 그 장소가 service라도 괜찮다. spring에서는 알아서 service에서 외부주입 받는다. . . public class LottoService { public static List&lt;Lotto&gt; issueByMoney(final Money money) { final LottoCount count = money.getCount(); return LottoFactory.issueLottoByCount(count, new RandomLottoIssuer()); } . | . 이제 전략인페를 impl 수동 구현만 -&gt; TDD에서 수동메서드 완성해보자. . 수동 전략impl 구현체를 생성한다. . . | 관련 테스트(LottoFactoryTest)로 가서, 해당메서드를 완성해야한다. . test에서 외부전략객체생성 후 전략메서드()호출해도 아무도일도 안일어날 것이다. . . | . | 미리 작성된 RandomLottoIssuer를 띄워놓고(tabmover -&gt; ctrl+alt+shift+D)로 참고하면서 내용을 채워나가면 된다. . . | ​ . ​ . ​ . ​ . ​ . 대박) 전략메서드 준비물을 [메서드() 인자]가 아닌 -&gt; 각 전략별 [전략객체 생성자/정펙매]에서 받아 준비해두자 . 랜덤로직을 랜덤전략객체에 옮기고 나니 랜덤에 필요한 것들이 생성자나 변수에서 처리되고 있었다. . 각 전략별 전략메서드 실행시 필요한 준비물은 각 전략객체 생성자/정펙매에서 파라미터로 받자 | . . public class RandomLottoIssuer implements LottoIssuer { static final List&lt;LottoNumber&gt; LOTTO_NUMBERS; static { LOTTO_NUMBERS = IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(LottoNumber::getInstance) .collect(Collectors.toList()); } public Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } } . | . 수동로또준비물은 수동 입력된 번호 List일 것이다. . . @Test void manual_issue() { // 전략들의 준비물은 전략메서드()에서는 따로따로 못받는다. -&gt; 전략객체 만들때 미리 준비되어있어야한다. //1. 수동로또전략의 준비물은 [1,2,3, 수동입력]이 있어야 -&gt; issue()로 [1,2,3, 수동로또]를 발급할 수 있을 것이다. // -&gt; input은 나중에 처리하고, 정제된rawInput을 생성자에서 받아주자. //final Lotto lotto = new ManualLottoIssuer().issue(); final Lotto lotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); } . 일단 가변인자로 받도록 만들어놨으니… 저렇게 처리했음. | . | 전략객체 생성시부터 준비물 -&gt; 변수에 받아준비해두자 . public class ManualLottoIssuer implements LottoIssuer { private final Integer[] value; public ManualLottoIssuer(final Integer... value) { this.value = value; } @Override public Lotto issue() { throw new UnsupportedOperationException(&quot;ManualLottoIssuer#issue not implemented.&quot;); } } . | 전략메서드에서 준비물을 사용해서 처리해주자. . public class ManualLottoIssuer implements LottoIssuer { private final Integer[] value; public ManualLottoIssuer(final Integer... value) { this.value = value; } @Override public Lotto issue() { //throw new UnsupportedOperationException(&quot;ManualLottoIssuer#issue not implemented.&quot;); //2. 전략객체가 생성시 받아둔 준비물을 가지고 전략메서드로 반환하자. return new Lotto(value); } } . | 가장 기본적인 일급테스트인 size + contains만 테스트 해줬다. . @Test void manual_issue() { final Lotto manualLotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); assertThat(manualLotto.getValue().size()).isEqualTo(6); } . @Test void contains() { final Lotto manualLotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); assertThat(manualLotto.getValue()).containsExactly( new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6) ); } . | 초대박) 테스트용 람다 전략은 전략객체 대신이 아니라 내부 전략메서호출()될 응답까지를 미리 주는 것 -&gt; 테스트에서 내부랜덤결과(전략메서드 응답type)을 외부 객체주입시 넣어줄 수 있다 . 전략객체를 주입받는 메서드(전략메서드 호출()부를 감싸는 메서드)에 new 전략객체를 입력해서 . 내부에서 서로다른 전략메서드() 호출 -&gt; 전략마다 다른 응답값을 사용하는 것이 기본 패턴인데 | . . . | 람다전략은 new전략객체 대신 ` () -&gt; 전략메소드의 응답(Lotto)`까지 한번에 주입한다. . 예시1: 전략객체가 들어가던 boolean응답 전략메소드의 전략객체 주입 . js.move(new RandomMoveConditionStrategy()); js.printPosition(); . public void move() { if(isMovable()){ this.position++; } } . 전략객체 대신 람다 () -&gt; boolean응답까지 미리 지정해서 전략자리에 대입 | . jk.move( () -&gt; true); jk.printPosition(); . | | 로또에 적용해보면, 2번째 인자로 전략객체를 받아 -&gt; 그에 맞는 전략메서드()내부 호출하는 issueLottoByCount( , ) . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount, final LottoIssuer lottoIssuer) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(lottoIssuer.issue()); } return lottos; } . | 여기에 2번째 인자에 테스트용 람다전략으로서 전략메서드 응답값을 포함한 람다전략을 대입하자 . @Test void lambda() { final List&lt;Lotto&gt; lottos = LottoFactory.issueLottoByCount( new LottoCount(1), () -&gt; new Lotto(1, 2, 3, 4, 5, 7)); // 외부 전략객체가 들어와야하는데, 람다(내부전략메소드 호출후 응답갑까지 미리)를 대입 assertDoesNotThrow(() -&gt; lottos.get(0).contains(new LottoNumber(7))); } . | 요약: [전략객체 ]자리에 내부.전략메서드()호출 끝난 응답값까지 구현하여 전달하는 람다전략 . 횟수만큼 자동 로또 생성 -&gt; 횟수를 수동+자동 나누어서 로또 생성 . 35 수동 로또를 input이 왔다고 치고, 나눠서 수동 + 자동 생성하기 . 포장이 끝난 상태라면, [메서드 파라미터 추가]는 정제된 input보다는 [포장]된 것으로 추가해주자. . 자동로또 만들어 주는 메서드에 수동로또를 파라미터에 추가하자 . 이 때, 정제된 input인 List.of(1,2,3,4)가 아니라 포장 끝났으니 실제 포장된 new Lotto()를 넣어주자. | . @Test void issue_with_money_and_manual() { // final List&lt;Lotto&gt; lottos = LottoService.issueByMoney(new Money(3000)); //1. 돈만 받아서, 알아서 횟수만큼 자동로또 -&gt; 돈 과 수동로또input을 같이 받도록 변경 // -&gt; 파라미터 다른 메서드를 만들고 -&gt; 그 다음 이름변경하자. (기존 코드 돌아가야되니 복붙개념으로 가야됨) // -&gt; 수동이 여러개일 수 있다 -&gt; 만약 리스트라면, 6개숫자리스트의 리스트가 들어올 것이다. // -&gt; **서비스 메서드에는 controller에서 도메인으로 이미 포장으로 변수를 받아놓고 호출되었을 것이다. // --&gt; 포장작업은 이미 끝내놨으니, 파라미터를 포장으로 받아도 된다. // --&gt; 서비스 메서드(메인로직)에서 이미 포장끝났다면 rawInput보다는 포장된 것을 파라미터로 던지자! // LottoService.issueByMoney(new Money(3000), List.of(1,2,3,4,5,6)); final List&lt;Lotto&gt; totalLotto = LottoService.issueByMoney(new Money(3000), List.of(new Lotto(1, 2, 3, 4, 5, 6))); . | 파라미터 변경하지말고, 메서드를 새로 생성 -&gt; 기존메서드위로 가져와서 내용복붙후 처리 . //2. 기존메서드 위로 올린 뒤, 내용 복붙해와서 처리해보자. public static List&lt;Lotto&gt; issueByMoney(final Money money, final List&lt;Lotto&gt; lottos) { //3. 자동을 돌릴 갯수가 돈/1000이 아니라 수동로또수만큼 빼야한다. //final LottoCount count = money.getCount(); final LottoCount totalCount = money.getCount(); //4. VO 증감 메서드는 항상 응답받을 준비를 한다. final LottoCount autoCount = totalCount.decrease(lottos.size()); //5. 기존에는 자동로또가 전체로또였다. 이;번엔 수동로또 + 자동로또 합쳐서 건네애햐한다. // return LottoFactory.issueLottoByCount(count, new RandomLottoIssuer()); //6. 수동로또는 파라미터로 넘어올 것이다. 자동만 갯수만큼 -&gt; 수동은 input에 의해 controller에서 생산 final List&lt;Lotto&gt; totalLottos = Stream.concat( lottos.stream(), LottoFactory.issueLottoByCount(autoCount, new RandomLottoIssuer()).stream() ).collect(Collectors.toList()); return totalLottos; } . 새 기준 메더드 완성시, 기존메서드 사용처확인해서 삭제 -&gt; 메서드 이름 변경 . //포장된 로또 리스트를 받도록 수정했는데, // 받기전 기존메서드에 빈 list를 넣어서 돌아가는지 확인되면 //-&gt; 기존 메서드 삭제 final List&lt;Lotto&gt; lottos = LottoService.issueByMoney(new Money(3000), Collections.emptyList()); . //기존메서드 잘 삭제되면, 메서드 이름변경 public static List&lt;Lotto&gt; issueByMoneyAndManualLotto(final Money money, final List&lt;Lotto&gt; lottos) { final LottoCount totalCount = money.getCount(); final LottoCount autoCount = totalCount.decrease(lottos.size()); final List&lt;Lotto&gt; totalLottos = Stream.concat( lottos.stream(), LottoFactory.issueLottoByCount(autoCount, new RandomLottoIssuer()).stream() ).collect(Collectors.toList()); return totalLottos; } . 생성된 전체로또가 수동로또 포함하는지 테스트 하기 . @Test void issue_with_money_and_manual() { final List&lt;Lotto&gt; totalLotto = LottoService.issueByMoneyAndManualLotto(new Money(3000), List.of(new Lotto(1, 2, 3, 4, 5, 6))); assertThat(totalLotto.size()).isEqualTo(3); assertThat(totalLotto).contains(new Lotto(1, 2, 3, 4, 5, 6)); } .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%BA%90%EC%8A%81/factory/%EC%A0%84%EB%9E%B5/tdd/%EA%B0%95%EC%9D%98/2022/03/14/TDD-6-%EB%A1%9C%EB%98%90(%EC%BA%90%EC%8A%81,Factory,%EC%88%98%EB%8F%99%EC%B6%94%EA%B0%80%EB%A7%88%EB%AC%B4%EB%A6%AC).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%BA%90%EC%8A%81/factory/%EC%A0%84%EB%9E%B5/tdd/%EA%B0%95%EC%9D%98/2022/03/14/TDD-6-%EB%A1%9C%EB%98%90(%EC%BA%90%EC%8A%81,Factory,%EC%88%98%EB%8F%99%EC%B6%94%EA%B0%80%EB%A7%88%EB%AC%B4%EB%A6%AC).html",
            "date": " • Mar 14, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "전략패턴 2(자동로또->수동)",
            "content": "전략 패턴 적용하기 . [랜덤 최소단위 메서드]를 전략메서드로 바꿔 [수동]도 가능하게 하기 . 전략부위가 만약, 메서드화 안되어있으면(ex&gt;조건식) 메서드화 (추출 등) . 메서드명을 랜덤+수동다 포함하는 일반화 + 목적어 뺌(전략인페+구현전략들에 명시됨)된 전략메서드로 바꿔주기 | . 랜덤 최소단위 메서드 정의부 -&gt; 호출()부 찾기 . 랜덤 메서드 정의부 찾기 . | 랜덤 메서드의 호출부 찾기 . | ##### 랜덤 메서드 호출부에서 랜덤 메서드명을 -&gt; 수동포함하는 일반화된 전략메서드명() + 목적어 제거으로 변경 -&gt; 전략인페를 상속한 new 랜덤전략구현체 객체(). 전략메서드() 인척 빨간줄 생성해주기 . 일반화된 메서드명 상태에서 -&gt; 빨간줄로 외부주입된 랜덤전략구현체 객체 + 전략메서드()호출해준다. . 기존상태( 메서드명을 랜덤+수동다 포함하는 일반화된 + 목적어빠진 전략메서드명으로 바꿔주기) . . 전략메서드에 목적어 넣지마라 | . . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(issue()); } return lottos; } public static Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } . | . | 외부주입된 new 랜덤전략객체에서 호출한 전략메서드()인척 해서 빨간줄로 생성하기 . . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(new RandomLottoIssuer().issue()); } return lottos; } . . | 전략메서드도 작성 . | 랜덤전략객체.전략메서드()로 &lt;- [ 기존 랜덤 메서드 ]에 있던 랜덤 로직 옮겨주기 . public class RandomLottoIssuer { static final List&lt;LottoNumber&gt; LOTTO_NUMBERS; static { LOTTO_NUMBERS = IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(LottoNumber::getInstance) .collect(Collectors.toList()); } public static Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } } . 외부주입 전략객체를 -&gt; 외부파라미터로 받기 위해서 -&gt; 실제 전략인페 정의해주기 . 앞에서 정의한 랜덤전략객체를 보고 전략인페를 생성한다. . RandomLottoIssuer -&gt; LottoIssuer -&gt; 앞으로 xxxxLottoIssuer 등 . | 전략인페명으로 패키지를 만들어서 다같이 넣어주면 좋다. . . | . | 전략메서드명은 다 통일이다. 목적어없이 동사만 . issue() . | 특정전략메서드의 반환타입을 참고해서 추상메서드를 정의해준다. . 랜덤전략의 메서드 반환타입 보고 . | 정의부 복붙해와서 반환타입 + 메서드명빼고 다 달리기 . . . public interface LottoIssuer { Lotto issue(); } . | . | . | ​ . new 외부전략객체() 생성하던 곳으로 돌아가서 -&gt; 변수/파라미터는 추상체로 외부주입 받아, 추상체.전략메서드()하도록 한다. . 기존: 외부주입없이 + 구상체로 사용 . . public class LottoFactory { public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(new RandomLottoIssuer().issue()); } return lottos; } } . | 호출부 중 전략객체만 선택해서 파라미터로 추출 . 전략메서드를 제외한 전략객체만 선택해서 추출하면 된다. . | 추상체 이름과, 파라미터 Type모두 추상체로 바꿔준다. . . public class LottoFactory { public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount, final LottoIssuer lottoIssuer) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(lottoIssuer.issue()); } return lottos; } } . | 처음에는 내부에서 특정 전략객체를 만들어썻찌만 -&gt; 파라미터 추출하면 알아서 외부에서 주입된다 . 그 장소가 service라도 괜찮다. spring에서는 알아서 service에서 외부주입 받는다. . . public class LottoService { public static List&lt;Lotto&gt; issueByMoney(final Money money) { final LottoCount count = money.getCount(); return LottoFactory.issueLottoByCount(count, new RandomLottoIssuer()); } . | . 이제 전략인페를 impl 수동 구현만 -&gt; TDD에서 수동메서드 완성해보자. . 수동 전략impl 구현체를 생성한다. . . | 관련 테스트(LottoFactoryTest)로 가서, 해당메서드를 완성해야한다. . test에서 외부전략객체생성 후 전략메서드()호출해도 아무도일도 안일어날 것이다. . . | . | 미리 작성된 RandomLottoIssuer를 띄워놓고(tabmover -&gt; ctrl+alt+shift+D)로 참고하면서 내용을 채워나가면 된다. . . | ​ . ​ . ​ . ​ . ​ . 대박) 전략메서드 준비물을 [메서드() 인자]가 아닌 -&gt; 각 전략별 [전략객체 생성자/정펙매]에서 받아 준비해두자 . 랜덤로직을 랜덤전략객체에 옮기고 나니 랜덤에 필요한 것들이 생성자나 변수에서 처리되고 있었다. . 각 전략별 전략메서드 실행시 필요한 준비물은 각 전략객체 생성자/정펙매에서 파라미터로 받자 | . . public class RandomLottoIssuer implements LottoIssuer { static final List&lt;LottoNumber&gt; LOTTO_NUMBERS; static { LOTTO_NUMBERS = IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(LottoNumber::getInstance) .collect(Collectors.toList()); } public Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } } . | . 수동로또준비물은 수동 입력된 번호 List일 것이다. . . @Test void manual_issue() { // 전략들의 준비물은 전략메서드()에서는 따로따로 못받는다. -&gt; 전략객체 만들때 미리 준비되어있어야한다. //1. 수동로또전략의 준비물은 [1,2,3, 수동입력]이 있어야 -&gt; issue()로 [1,2,3, 수동로또]를 발급할 수 있을 것이다. // -&gt; input은 나중에 처리하고, 정제된rawInput을 생성자에서 받아주자. //final Lotto lotto = new ManualLottoIssuer().issue(); final Lotto lotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); } . 일단 가변인자로 받도록 만들어놨으니… 저렇게 처리했음. | . | 전략객체 생성시부터 준비물 -&gt; 변수에 받아준비해두자 . public class ManualLottoIssuer implements LottoIssuer { private final Integer[] value; public ManualLottoIssuer(final Integer... value) { this.value = value; } @Override public Lotto issue() { throw new UnsupportedOperationException(&quot;ManualLottoIssuer#issue not implemented.&quot;); } } . | 전략메서드에서 준비물을 사용해서 처리해주자. . public class ManualLottoIssuer implements LottoIssuer { private final Integer[] value; public ManualLottoIssuer(final Integer... value) { this.value = value; } @Override public Lotto issue() { //throw new UnsupportedOperationException(&quot;ManualLottoIssuer#issue not implemented.&quot;); //2. 전략객체가 생성시 받아둔 준비물을 가지고 전략메서드로 반환하자. return new Lotto(value); } } . | 가장 기본적인 일급테스트인 size + contains만 테스트 해줬다. . @Test void manual_issue() { final Lotto manualLotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); assertThat(manualLotto.getValue().size()).isEqualTo(6); } . @Test void contains() { final Lotto manualLotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); assertThat(manualLotto.getValue()).containsExactly( new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6) ); } . | 초대박) 테스트용 람다 전략은 전략객체 대신이 아니라 내부 전략메서호출()될 응답까지를 미리 주는 것 -&gt; 테스트에서 내부랜덤결과(전략메서드 응답type)을 외부 객체주입시 넣어줄 수 있다 . 전략객체를 주입받는 메서드(전략메서드 호출()부를 감싸는 메서드)에 new 전략객체를 입력해서 . 내부에서 서로다른 전략메서드() 호출 -&gt; 전략마다 다른 응답값을 사용하는 것이 기본 패턴인데 | . . . | 람다전략은 new전략객체 대신 ` () -&gt; 전략메소드의 응답(Lotto)`까지 한번에 주입한다. . 예시1: 전략객체가 들어가던 boolean응답 전략메소드의 전략객체 주입 . js.move(new RandomMoveConditionStrategy()); js.printPosition(); . public void move() { if(isMovable()){ this.position++; } } . 전략객체 대신 람다 () -&gt; boolean응답까지 미리 지정해서 전략자리에 대입 | . jk.move( () -&gt; true); jk.printPosition(); . | | 로또에 적용해보면, 2번째 인자로 전략객체를 받아 -&gt; 그에 맞는 전략메서드()내부 호출하는 issueLottoByCount( , ) . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount, final LottoIssuer lottoIssuer) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(lottoIssuer.issue()); } return lottos; } . | 여기에 2번째 인자에 테스트용 람다전략으로서 전략메서드 응답값을 포함한 람다전략을 대입하자 . @Test void lambda() { final List&lt;Lotto&gt; lottos = LottoFactory.issueLottoByCount( new LottoCount(1), () -&gt; new Lotto(1, 2, 3, 4, 5, 7)); // 외부 전략객체가 들어와야하는데, 람다(내부전략메소드 호출후 응답갑까지 미리)를 대입 assertDoesNotThrow(() -&gt; lottos.get(0).contains(new LottoNumber(7))); } . | 요약: [전략객체 ]자리에 내부.전략메서드()호출 끝난 응답값까지 구현하여 전달하는 람다전략 .",
            "url": "blog.chojaeseong.com/java/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/13/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4%EC%A0%81%EC%9A%A9(%EB%A1%9C%EB%98%90).html",
            "relUrl": "/java/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/13/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4%EC%A0%81%EC%9A%A9(%EB%A1%9C%EB%98%90).html",
            "date": " • Mar 13, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "01 임상연구 소개",
            "content": "&#51076;&#49345;&#50672;&#44396; . &#51076;&#49345;&#50672;&#44396;&#46976; . 임상연구: 사람의 질병을 이해, 예방, 치료하고 건강을 증진하기 위한 학문 사람의 질병에 대한 학문 | 사람이 아닌 동물실험 연구도 도움 될 수 있다. 실험실에서 세포, 분자단위 연구도 도움 될 수 있다. Labloratory Research와도 겹치게 된다. | . | 큰 인구집단에 적용한다고 하면, 예를들어, 특정 질병에 취약한 high risk 집단은 어떤 계층인가, 질병의 outcome을 향상시키기 위해서 어떤 의료시스템 변화를 implement해야할 것인가와 연결되어 있다. Population Research와도 겹치게 된다. | . | . | . &#51076;&#49345;&#50672;&#44396;&#51032; &#51333;&#47448; . 치료 | 예방 | 진단 | 스키리닝 | 삶의질 | 유전학 | (큰 인구집단) 역학 연구까지 종류가 다양하다 | &#44288;&#47144;&#48516;&#50556; . 기초과학(생물학, 화학, 유전학...) | 역학 | 통계학 | Psychometrics: 임상연구에서 쓰이는 각 변수들의 measurement들이 얼마나 신뢰도가 있느냐 관련 | Physiology of resarch( &#50672;&#44396; &#54644;&#48512;&#46020; ) . Designing Clinical Research 4판에 나오는 내용 | . . 알고 싶은 세계: truth in the universe . 그 중 알고 싶은 것 총 2가지 (0) research question | 어떤 집단에 대한 궁금증인가 (1) target population | 어떤 현상에 관심이 있나 (2) phenomena of interest | . | 알고 싶으니 연구계획을 세운다: study plan . 알고 싶은 target population의 전체를 연구하는 경우는 거의 없다 -&gt; 일부 의도된 샘플: intended sample | 관심 현상을 알기 위해선 변수를 관측: intended variables | . | 연구계획대로 되지 않은다: actual study . 의도한 샘플과 비슷할 수도 있거나 다를 수 있는, 실제 조사/관찰한 subject들 : actual subjects | 의도한 변수와 비슷할 수도 있거나 다를 수 있는, : actual measurements | . | . 실제로는 3가지 : 알고싶은 세계 -&gt; 의도한 연구 -&gt; (의도가)실제로 수행/관측된 것 3가지의 간극을 좁혀야한다. 각각은 얼마나 가까운가에 대한 것 : validity 알고싶은 세계 &lt;-&gt; 의도한 연구가 얼마나 가까운가 : External validity | 의도한 연구 &lt;-&gt; 실제 연구가 얼마나 가까운가 : internal validity | . | . | . &#51339;&#51008; &#51076;&#49345;&#50672;&#44396; . 좋은 연구는 이 2가지 validity가 최대화된 연구 -&gt; 어떻게 하면 맥시마이즈 할 수 있을까? | . &#50672;&#44396;&#44228;&#54925;&#49436; . 연구 구조가 적혀있는 설계도 | 연구비 심사나 IRB를 위해 작성하는 경우가 많다 | 그러나 근본적인 목적은 연구를 과학적/효율적으로 도와주는 도구가 된다. | . &#50672;&#44396;&#44228;&#54925;&#49436; &#44396;&#49457; . &#50672;&#44396;&#51656;&#47928;(Research question) . 연구를 통해 답하고자하는 질문 | 연구의 목적 연구 시작전 명시되어야하고, 구체적일 수록 좋다. | . | . 연구 해부도내에서는 truth in the universe에 해당하는 것 | 좋은 연구질문을 정하는 기준 FINER . Feasible(피져블): 실제 수행 가능한가? 실제 연구에 들어가는 비용과 시간을 감당할 수 있고,환자를 모집할 수 있는가 | 연구자의 능력/자원/경험치가 연구하기에 충분한가? 연구질문이 아무리 좋아도 피져블 하지 않으면 성공할 수가 없음. | . | . | Interesting: 연구자 본인에게 흥미로운 주제인가 더불어, 관련분야 연구자들의 흥미를 끌 만한 주제인가 | . | Novel(노블): 기준연구와 비교시 새로운점이 있나 기존연구와 다른점이 있는가 | 기존연구의 단점을 보완하는가 | 완전히 새로운 가설을 만들어 내는가 | . | Ethical(에띠컬): 윤리적인가 윤리적 연구 기본원칙에 충실한가 | IRB 규정을 준수하는가 | . | Relevant(렐러번트): 연구계획서에 significant에 해당하는 항목 . 얼마나 과학/환자 돌보는데 기여하는가 | 얼마나 새로운 지식을 창출하고, 미래연구를 촉진시키는 가 | . . . | | . &#50672;&#44396; &#48176;&#44221;&#44284; &#51473;&#50836;&#49457; . 이미 무엇이 알려져있는가 | 무엇이 안알려져있어서 이 연구질문이 중요한가 | 이 연구를 하면 어떤 종류의 지식을 | 이 연구가 어떤 prractical impact(실제 가이드라인, 보건정책에 영향)을 끼칠 것이가 | . &#50672;&#44396;&#46356;&#51088;&#51064; . 종류가 많고, 새로운 디자인이 개발되고 있어 정리될 순 없지만, 대략적으로 파악할 수 있는 그림이다. | . 크게 2가지 . Experimental(실험) : 내가 연구대상에 무엇인가를 가하거나 해서 -&gt; 연구대상을 따라가며 관찰 . 가하면서 연구대상을 따라가며 관찰하니 특성상 Prospective한 study일 수 밖에 없다. | intervention등을 가한 다음, 이후에 일을 관찰하니 Longitudinal study일 수 밖에 없다. | . | Observational(관찰): 가하지 않음 따라감 -&gt; prospective가 될 수도 retrospective가 될 수도 . prospective: 가하진 않지만 지금부터 따라가면서 살펴보는 Longitudinal: 지금부터 따라가면서 현재-&gt;미래 2시점 연결해관찰 = Cohort Study | . | retrospective: 가하진 않지만 지금부터 과거로 따라가면서 살펴보는 Longitudinal: 지금부터 과거로 따라가면서 현재-&gt;과거 2시점 연결해관찰 = Case-control study | . | cross-sectional: p/r관계없이, 시점을 2개이상 보지않고,딱 1시점만 보는 것 | . | | . 연구의 목적에 따라 좋은 디자인의 기준이 달라지지만 | 좋은 디자인: internal/external validity를 높이는 디자인 나쁜 디자인을 통계기법으로 극복해낼순 없다. -&gt; 처음부터 잘 골라서 연구설계해야한다. | . | . &#50672;&#44396;&#45824;&#49345;&#51088; . 알고 싶은 환자군 전체 Target population이 있고 | 그 전체를 알 수 없으니 일부를 뽑은 게 study sample(study subjects)이라 한다. 연구계획서는 study sample이 어떤 집단이 될 것인지 적어야한다. | 반드시 inclusion/exclusion criteria(크라이테리아)로 명시해줘야한다. | . | . inclusion criteria . 인구학적 특성: 성별/나이에 대한 것 | 임상적 특성: 내가 관심있는 질병에 따라 결정되어지는, 대상의 임상기준? | 지리학적 또는 행정적 특성: 내가 실제 연구 수행하는 장소와 시간 | 시간적 특성: 내가 실제 연구 수행하는 장소와 시간 | exclusion criteria . 연구대상자가 안되는 사람의 기준 | . . Follow Up 안될 가능성이 높은 사람은 제낀다. ex&gt; 알콜중독자, 이사갈 사람 | 양질 데이터 제공이 어려운 사람은 제낀다. ex&gt; 언어 문제, 지적장애인 | (drug study시) adverse effects를 겪을 가능성이 높은 사람은 제낀다 ex&gt; 암환자, 임산부 | 연구 해부도에서, 가운데 부분이 연구대상자 내가 알고 싶은 타켓파풀레이션 | 그 중 일부를 어떻게 뽑겠다 계획 | 실제 recruit되는 환자 간격을 줄여야한다. | . | . | . 예시 chd환자 전체(타겟 파퓰레이션)를 보고 싶지만 | 실제로는 recruit하게 되는(인텐디드 샘플) 내가 일하는 곳의 intended sample으로만 제한된다 타겟 파퓰레이션과 괴리가 생기게 된다. -&gt; 이 차이를 줄이기 위해, 모든병원 or 병원 갯수를 늘리는 식으로 노력하여 더 제네럴라이즈하게 시도할 수 있지만, 비용과 시간과 노력이 많이 들게 된다. | 즉 external validity를 맥시마이즈 하는 것이 중요하지만, 비용/시간/노력의 문제 때문에 적당한 타협점을 찾아야한다. | . | recruit하려고 했던 subjects들 중에 실제로 연구에 동의(액츄얼 스터디 샘플)해서 데이터를 제공한 환자들을 Actual Study sample이라고 한다. intended sample과 차이가 있을 수 있는데, 차이가 적을 수록 좋다 | 만약, recruite하려고 하는 사람들 중 매우 일부만 동의 등으로 차이가 커질 수록 internal validity가 해를 입게 된다. | . | . | . &#48320;&#49688; . outcome: 결과변수, 반응변수 관심 질병유무 /심각도/이벤트 유무/건강상태 | . | 설명변수: 독립변수 . outcome과 관련되는 여러가지 factor들 . . | . | &#53685;&#44228;&#51201; &#44256;&#47140;&#49324;&#54637; . 가설: 가장 중요한 것으로서, research question을 통계적으로 testable한 가설로 바꿔줘야한다. . 귀무가설과 대립과설이 무엇과 무엇인지 / 어떻게 검증할 것인지 나와야한다. | . | 통계분석 계획: 가설이 나오난 뒤에, 이 가설을 어떤 테스트로 검정할 것인지 정하는 것 . 가설 증명을 통한 r.q.에 답하기 위한 통계적 방법을 구체적으로 기술해야 됨. | . | 연구 대상자 수: 위에서 정해진 통계적 방법이, 가설을 증명하기 위해 필요한 샘플 사이즈 . 내가 보이려고 하기 위한 대립가설이 사실일 경우에, p밸류가 0.05보다 작게 나올 확률인 power가 80~90%로 확보되기 위해서 몇명의 환자를 조사해야하는지 | . | . &#51076;&#49345;&#50672;&#44396;&#51032; &#45800;&#44228; . &#45800;&#44228; . 딱 정해진 것은 없지만 3가지로 책에서 서술한다. | . . 디스크립티드 스터디: 관심있는 질병과 특성이 and/or 어떤 식의 분포로 나타나는지 기술하는 스터디 . 관심 질병= 미표기 or 관련 특성=한국 CHD환자의 일주일당 생선섭취량 | 이러한 현상이 있다. | . | 애널리틱 스터디: 관심 질병과 관련 특성의 상관관계/인과관계가 있는지 보는 연구 . 관심 질병= 심장발작여부와 - 관련 특성=한국 CHD환자의 일주일당 생선섭취량이 관련있는가? . | 상관 관계가 확인이 되면 (-&gt; 인과 관계가 먼저 완전히 확립되면 더 좋겠지만), 인과 관계를 확립을 확실히하기 위해 아래 다음단계인 클리니컬 트라이얼스로 넘어간다. . | . | 클리니컬 트라리얼스: 관심있는 intervention이 추가되어 그 효과를 확인하는 연구이다. . 특히, RCT를 하게되면 인과관계를 확실히 확인할 수 있다. | 한국 CHD환자 대상 - 인터벤션1:fish oil보충제 vs 플라시보 투약한 것에 비해 outcome이 좋은가?(심장발작 횟수가 줄어드는가?)를 진행한다. | . | 교수님 생각으로 전계되는 단계 | . 처음 내가 관심있는 현상에 대해서 디스크립션해야한다 | 그 다음에는 관심있는 특성과 관심있는 질병과의 어쏘시에션(상관관계)를 보게 된다. | 어쏘시에션을 확인한 상태에서 코잘리티(인과관계)를 보고 넘어가는 경우 vs 코잘리티를 못보고 넘어가는 경우가 있다 . 프리딕션 모델로 가는 경우 2가지 . 관심질병-관심인자(특성)과의 어쏘시에이션이 충분히 보였다 -&gt; 코잘리티를 굳이 보이지 않더라도, 상관관계 높은 인자를 이용한 예측모델을 만들 수 있다. association모델에서 바로 prediction모델로 갈 수 있다.! | . | 어쏘시에이션 -&gt; 여러 방법을 통해 코절하다고 결론이 나온 경우 -&gt; 프리딕션으로 넘어가기 | | 인터벤션 리서치로 넘어가는 경우 2가지 코잘리티를 확실하게 보이지 않더라도, 단지 상관관계만 보인 상태에서, 인과관계가 있을 것이라는 강한 믿음 or 근거를 가지고 intevention으로 넘어가기 | 어쏘시에이션 확인 후, 여러 통계기법 + 정황으로 코잘리티를 보인 상태에서, 인터벤션으로 넘어가기 | | | 인터벤션(주로 RCT로 함)의 효과가 확인되었다면, 같은 인터벤션에 대한 효과들을 모아 메타분석을 한다. 같은 인터벤션이지만, 다른 위치, 환자군 등을 모아봄 | . | 내가 연구하려는 주제가 있을 때, 어느 정도까지 연구되어있는지 임상연구의 단계를 찾아보고, 다음 단계에서 내가 해야할 것은 무엇인지를 확인하면 된다. 예를 들어, association이 밝혀지지 않은 주제 -&gt; 바로 RCT나 Prediction하도록 단계를 건너띄어선 안된다. | . | . &#49345;&#44288;&#44288;&#44228;&#50752; &#51064;&#44284;&#44288;&#44228; . &#49345;&#44288;&#44288;&#44228; vs &#51064;&#44284;&#44288;&#44228; &#50696;&#49884; . 어떤 자료 2개가 상관관계가 엄청 높았다 -&gt; 바로 인과로 가면 안된다. 우주기술에 투자할수록 -&gt; 자살률이 높다?? -&gt; 이렇게 결론 내리진 않는다. | 우연에 의한 것인지 확인? / 시간이라는 컨파운딩 팩터가 있어서 시간이 증가하면서 경제 발달 -&gt; 정부는 투자많이 / 인구늘어남 -&gt; 자살수 늘어남 | . | 컨파운더에 의한 상관관계로 결론 | . | . . 상관관계가 관측됨 이 상관관계가 진짜인가? /우연 or 잘못된 연구디자인 때문은 아닌가부터 의심한다 | . | 진짜 상관관계가 판단됨 a가 b를 일으키는 코잘리티인가? / [보이지 않지만, 실제 b를 일으키면서 &amp;&amp; 동시에 a에도 영향을 주고 있는 confounding factor]때문에 생겨난 서로간의 인과관계는 없지만 [보이는 상관관계]인지판단 해야한다 | . | &#49345;&#44288;&#44288;&#44228; &#48156;&#44204;&#49884;, &#53076;&#51096;vs&#52980;&#54028; &#50696;&#49884; . 연구했는데 커피 -&gt; 췌장암의 상관관계가 있는 것으로 관측되어었다(상관관계가 진짜이라고 가정) 커피섭취가 -&gt; 실제로 췌장암에 영향을 미치는 코절리티가 있는 경우 | 보이지 않는 컴파운딩 팩터 때문에, 인과없이, 보이기만 하는 상관관계인 경우 보이지 않는 흡연이라는 실제 췌장암의 증가원인 &amp;&amp; 커피 섭취의 증가원인인 컴파운딩 팩터가 있음 | 흡연하는 사람이 커피를 많이 마시는 경향도 있어서, a와 b 둘다 영향을 주기 때문에, 커피섭취가 -&gt; 췌장암에 영향을 주는 인과가 없더라도 해당 보이는 상관관계를 유발시킨다. 커피-&gt;췌장암 영향 있을 수도 없을 수도 있지만, 컨파운딩 때문에 이렇게 보이는 상관관계를 만드는게 아닌가 고민을 해봐야한다. | . | . | | . &#51064;&#44284;&#44288;&#44228; &#54032;&#45800; &#44032;&#51060;&#46300;&#46972;&#51064; . 인과관계 판단이 쉽지 않으므로, 담배-&gt;폐암 인과증명시 제시 된 것들이다. | 하지만, 칼같이 정해지는 것이 아니라 종합적으로 고려되어야한다. 시간이 지나면서 계속 수정되고 있다. | . 템포럴 릴레이션쉽: 선후관계가 명확해야한다. 원인이 선행해야한다. | . | 상관관계가 강해야한다. 약한 순간 인과관계이긴 어렵다 | . | 도스-리스폰스 릴레이션쉽: . 세부 섭취량(음식)/투약량(약)에 따라 outcome과 관련있어야한다 | 인과관계가 확실한 경우에도 나타나지 않는 경우도 있으니 100% 만족안해도 된다. ex&gt; 적은 양에는 효과X -&gt; 역치 넘으면 효과O 있는 경우, -&gt; 인과는 있는데 적은량에서는 dose가 무시됨 | . | . | 레플리케이션 오브 파인딩스: . 내 연구에서 상관관계-&gt;인과관계를 발견했어도, 바로 인과관계 있다고 말할 수 없다. 다른 연구/환자군/서브그룹에서도 일관된 상관관계가 나타날 때 -&gt; 인과관계 있다고 말할 수 있다. | . | 바이얼로직 플러져빌리티: 생물학적 그럴듯한 설명이 있어야한다. . | 컨시덜레이션 오브 얼터네이트 익플레내이션스: 다른 설명이 가능한지도 살펴봐야한다 . 인과관계가 아니라 사실은 다른 컨파운딩이 숨어있는 것은 아닐까? | 인과가 뒤바뀐 것은 아닐까? | . | 쎄세이션 오브 익스포져: 원인이 되는 exposure 중단시 -&gt; 결과도 중단 되어야한다. . 하지만, 도스-리스폰스 릴레이션쉽처럼, 인과관계일 때도 성립안하는 경우가 가끔 있다. 흡연이 -&gt; emphysema에 영향을 미치는 인과는 사실이나 | 흡연 중단 -&gt; emphysema 해결은 안된다. | . | . | 컨시스턴시 위드 아덜 날러지: 이 질병/환자군에 대해 알고 있는 다른 지식과 컨시스턴시 해야한다 . | 스페서피서티 오브 더 어소시에이션: . 원인이 일으키는 결과가 1개 여야한다. 다른 결과들도 일으키면 안된다. | 회색: 논의가 많이 되는 부분이다. ex&gt; 미국담배회사: 담배 -&gt; 폐암외 여러질병일으킴 -&gt; 스페서피서티 오브 더 어소시에이션를 만족하지 않으므로 인과관계 아니라고 주장함. | . | . | 다른 가이드라인이 많고, 절대적인 기준은 없다. | 우리 데이터가 가진 전체적인 패턴을, 다른 지식과 종합해서 인과관계인지 판별해해야한다. | . &#51221;&#47532;&#54616;&#44592; . 임상연구는 사람의 질병을 이해, 예방, 치료하고 건강을 증진하기 위한 학문이다. . 사람에 대한 학문이다. | . | 좋은 임상연구는 validity가 최대화된 연구이다. . Internal validity는 연구 내에서 일어난 일에 대해 올바른 결론을 내렸는가에 관한 것이고, | External validity는 연구 결과가 연구 밖 real world에 적용될 수 있는가에 관한 것이다. 두 validity를 최대한 연구가 좋은 연구이다 | . | . | 연구계획서는 연구의 구조가 적혀있는 설계도이다. 연구계획서는 . 연구질문(research question), | 연구 배경과 중요성, | 디자인, | 연구대상자, | 변수, | 통계적 고려사항으로 이루어진다. | . | 임상연구의 많은 부분은 상관관계를 확인하고 그로부터 인과관계에 대한 추론을 끌어내기 위한 노력이며, 경우에 따라 예측모델이나 중재연구(intervention study)의 단계로 이어진다. . | 상관관계로부터 인과관계를 성립시키기 위한 몇가지 기준이 있지만, 기계적으로 적용하여 인과관계가 있다고 결론내릴 수 있는 절대적인 기준은 없으며, 관측된 데이터의 전체적인 패턴을 종합적으로 고려하여 인과관계에 대한 결론을 내려야 한다. . | &#53300;&#51592;&#47784;&#51020; . . . .",
            "url": "blog.chojaeseong.com/r/%EC%9D%98%ED%95%99%EC%97%B0%EA%B5%AC%EB%B0%A9%EB%B2%95%EB%A1%A0/%ED%86%B5%EA%B3%84/2022/03/13/01-%EC%9E%84%EC%83%81%EC%97%B0%EA%B5%AC-%EC%86%8C%EA%B0%9C(%EC%99%84).html",
            "relUrl": "/r/%EC%9D%98%ED%95%99%EC%97%B0%EA%B5%AC%EB%B0%A9%EB%B2%95%EB%A1%A0/%ED%86%B5%EA%B3%84/2022/03/13/01-%EC%9E%84%EC%83%81%EC%97%B0%EA%B5%AC-%EC%86%8C%EA%B0%9C(%EC%99%84).html",
            "date": " • Mar 13, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "Count VO 포장 과정(로또)",
            "content": "Count VO 포장 . 줄어드는 횟수Count VO의 포장 . 미리 원시값도 줄어들 때 hasNext패턴을 만들어두었다. . 내 패턴으로는 0을 허용하면서 더 큰 n부터 줄어들되 0이 아닐때까지, 즉, 1까지도는 것이다. | . public static List&lt;Lotto&gt; issueLottoByCount(int count) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (count != 0) { count -= 1; lottos.add(LottoFactory.issueLotto()); } return lottos; } . 메서드에서부터 파라미터로 전해지도록 Count 포장 (포장은 테매 인자에서부터~ ) . 이름은 도메인Count로 만들어야한다. 포장하는 순간, 대명사가 아니다. . . | . 포장하기 . public class LottoCount { private final int value; public LottoCount(final int value) { this.value = value; } } . | VO는 equals/hC부터 . . count VO는 0까지는 허용해주도록 검증을 만든다. (for while문에서 0까지 간 뒤 0에서 탈출시킴) . public LottoCount(final int value) { if (value &lt; 0) { throw new IllegalArgumentException(&quot;0보다 작을 수 없습니다.&quot;); } this.value = value; } . 새기준메서드 새로 만들어, 기존메서드 위로 위치이동후, 내용복붙후, 처리 . . . . . 값자리에는 포장.getter()를 -&gt; 연산이 할만하면 바로 메세지를 . . . . 값의 연산 -&gt; 포장 안으로 잘라들고가서 this.값으로 연산 . getter지우고 메세지보내기 만약, 지우고 빨간메서드가 남아있다면 그대로 정의해도 된다. | 여기선 연산!=0이 남아있으니, 그에 맞는 의미있는 메서드를 지어준다. 0=Finish가 != 아직 Not이냐 | 남은 연산을 잘라내서 -&gt; 메서드만들고 -&gt; 내부에서 this.값으로 잘라낸 연산 처리 | . | 값의 재할당 -&gt; VO에서는 연산만 들고 들어가면서 메서드를 만들고, 포장 = 는 그대로 둔다. -&gt; 내부에서는this.값으로 연산한 뒤 =에 대해 새VO로 응답하는 [메세지]로 작성한다. . -= 1을 포장 처리하려면 . -1 을 내부로 들고 들어가서 this.값 -1으로 연산 | =은 새 VO를 반환 | . . . | = 놓아두고, -1만 들고 들어가면서, 연산과 관련된 메서드명으로 메세지를 보낸다. . . . . | 연산을 들고들어갔더라도 바깥에서는 포장변수 = 이 새 VO응답을 기다리고 있으므로 내부연산 결과를 포장해서 응답해준다. . . . final을 풀어 재할당 가능하게 해준다. | . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(LottoFactory.issueLotto()); } return lottos; } . 포장전 기존메서드가 사용중이면 찾아가서, 수정해준다. . . . count가 사용중인데, 일단 money.getCount()의 반환값도 원시count으로 바꿔준다. . public int getCount() { return this.money / 1000; } . . public LottoCount getCount() { return new LottoCount(this.money / 1000); } . public static List&lt;Lotto&gt; issueByMoney(final Money money) { final LottoCount count = money.getCount(); return LottoFactory.issueLottoByCount(count); } . | . 새 기준메서드 완성시, 포장검증을 메서드로 퉁치는 테스트(-1이하에서 에러) . . 자체 도메인Test생성후 Count VO 검사 . 0까지 허용하여 음수 생성자 에러 | . @Test void create() { assertAll( () -&gt; { assertDoesNotThrow(() -&gt; new LottoCount(1)); assertDoesNotThrow(() -&gt; new LottoCount(0)); assertThatThrownBy(() -&gt; new LottoCount(-1)); } ); } . 1개 뽑 + 감소된 것 뽑 -&gt; 감소된 로직후 동일한지 비교 | . @Test void decrease() { final LottoCount lottoCount = new LottoCount(1); final LottoCount expected = new LottoCount(0); // 감소된 것 미리 뽑기 final LottoCount actual = lottoCount.decrease(); assertThat(actual).isEqualTo(expected); } .",
            "url": "blog.chojaeseong.com/java/vo/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/12/Count-VO-%ED%8F%AC%EC%9E%A5.html",
            "relUrl": "/java/vo/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/12/Count-VO-%ED%8F%AC%EC%9E%A5.html",
            "date": " • Mar 12, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "00 데이터 클리닝 특강",
            "content": "강의 교재 사이트: https://rpubs.com/biostat81/DataPrep_CRM | 데이터셋 보유되어있음(data/특강/example_dataset.csv) | . &#46972;&#51060;&#48652;&#47084;&#47532; &#49444;&#52824; . install.packages(&#39;plyr&#39;) . package &#39;plyr&#39; successfully unpacked and MD5 sums checked The downloaded binary packages are in C: Users cho_desktop AppData Local Temp RtmpC2VGFd downloaded_packages . install.packages(&#39;dplyr&#39;) . also installing the dependencies &#39;ellipsis&#39;, &#39;fansi&#39;, &#39;pkgconfig&#39;, &#39;purrr&#39;, &#39;cli&#39;, &#39;utf8&#39;, &#39;generics&#39;, &#39;glue&#39;, &#39;lifecycle&#39;, &#39;magrittr&#39;, &#39;R6&#39;, &#39;rlang&#39;, &#39;tibble&#39;, &#39;tidyselect&#39;, &#39;vctrs&#39;, &#39;pillar&#39; . There are binary versions available but the source versions are later: binary source needs_compilation fansi 0.4.2 1.0.2 TRUE cli 2.5.0 3.2.0 TRUE utf8 1.2.1 1.2.2 TRUE generics 0.1.0 0.1.2 FALSE glue 1.4.2 1.6.2 TRUE lifecycle 1.0.0 1.0.1 FALSE magrittr 2.0.1 2.0.2 TRUE R6 2.5.0 2.5.1 FALSE rlang 0.4.11 1.0.2 TRUE tibble 3.1.1 3.1.6 TRUE tidyselect 1.1.1 1.1.2 TRUE pillar 1.6.0 1.7.0 FALSE dplyr 1.0.6 1.0.8 TRUE Binaries will be installed package &#39;ellipsis&#39; successfully unpacked and MD5 sums checked package &#39;fansi&#39; successfully unpacked and MD5 sums checked package &#39;pkgconfig&#39; successfully unpacked and MD5 sums checked package &#39;purrr&#39; successfully unpacked and MD5 sums checked package &#39;cli&#39; successfully unpacked and MD5 sums checked package &#39;utf8&#39; successfully unpacked and MD5 sums checked package &#39;glue&#39; successfully unpacked and MD5 sums checked package &#39;magrittr&#39; successfully unpacked and MD5 sums checked package &#39;rlang&#39; successfully unpacked and MD5 sums checked package &#39;tibble&#39; successfully unpacked and MD5 sums checked package &#39;tidyselect&#39; successfully unpacked and MD5 sums checked package &#39;vctrs&#39; successfully unpacked and MD5 sums checked package &#39;dplyr&#39; successfully unpacked and MD5 sums checked The downloaded binary packages are in C: Users cho_desktop AppData Local Temp RtmpC2VGFd downloaded_packages . installing the source packages &#39;generics&#39;, &#39;lifecycle&#39;, &#39;R6&#39;, &#39;pillar&#39; . install.packages(&#39;tableone&#39;) . also installing the dependencies &#39;bit&#39;, &#39;prettyunits&#39;, &#39;glue&#39;, &#39;bit64&#39;, &#39;withr&#39;, &#39;progress&#39;, &#39;cli&#39;, &#39;clipr&#39;, &#39;vroom&#39;, &#39;tzdb&#39;, &#39;DBI&#39;, &#39;gtools&#39;, &#39;forcats&#39;, &#39;hms&#39;, &#39;readr&#39;, &#39;cpp11&#39;, &#39;stringi&#39;, &#39;Matrix&#39;, &#39;survival&#39;, &#39;lattice&#39;, &#39;minqa&#39;, &#39;numDeriv&#39;, &#39;mitools&#39;, &#39;class&#39;, &#39;proxy&#39;, &#39;gdata&#39;, &#39;haven&#39;, &#39;stringr&#39;, &#39;tidyr&#39;, &#39;survey&#39;, &#39;MASS&#39;, &#39;e1071&#39;, &#39;zoo&#39;, &#39;gmodels&#39;, &#39;nlme&#39;, &#39;labelled&#39; . There are binary versions available but the source versions are later: binary source needs_compilation glue 1.4.2 1.6.2 TRUE withr 2.4.2 2.5.0 FALSE cli 2.5.0 3.2.0 TRUE clipr 0.7.1 0.8.0 FALSE vroom 1.4.0 1.5.7 TRUE tzdb 0.1.1 0.2.0 TRUE DBI 1.1.1 1.1.2 FALSE gtools 3.8.2 3.9.2 TRUE hms 1.0.0 1.1.1 FALSE readr 1.4.0 2.1.2 TRUE cpp11 0.2.7 0.4.2 FALSE stringi 1.6.1 1.7.6 TRUE Matrix 1.3-3 1.4-0 TRUE survival 3.2-11 3.3-1 TRUE lattice 0.20-44 0.20-45 TRUE class 7.3-19 7.3-20 TRUE proxy 0.4-25 0.4-26 TRUE haven 2.4.1 2.4.3 TRUE tidyr 1.1.3 1.2.0 TRUE survey 4.0 4.1-1 FALSE MASS 7.3-54 7.3-55 TRUE e1071 1.7-6 1.7-9 TRUE nlme 3.1-152 3.1-155 TRUE labelled 2.8.0 2.9.0 FALSE tableone 0.11.2 0.13.0 FALSE Binaries will be installed package &#39;bit&#39; successfully unpacked and MD5 sums checked package &#39;prettyunits&#39; successfully unpacked and MD5 sums checked package &#39;glue&#39; successfully unpacked and MD5 sums checked . Warning message: &#34;cannot remove prior installation of package &#39;glue&#39;&#34;Warning message in file.copy(savedcopy, lib, recursive = TRUE): &#34;C: Users cho_desktop anaconda3 Lib R library 00LOCK glue libs x64 glue.dll를 C: Users cho_desktop anaconda3 Lib R library glue libs x64 glue.dll로 복사하는데 문제가 발생했습니다: Permission denied&#34;Warning message: &#34;restored &#39;glue&#39;&#34; . package &#39;bit64&#39; successfully unpacked and MD5 sums checked package &#39;progress&#39; successfully unpacked and MD5 sums checked package &#39;cli&#39; successfully unpacked and MD5 sums checked package &#39;vroom&#39; successfully unpacked and MD5 sums checked package &#39;tzdb&#39; successfully unpacked and MD5 sums checked package &#39;gtools&#39; successfully unpacked and MD5 sums checked package &#39;forcats&#39; successfully unpacked and MD5 sums checked package &#39;readr&#39; successfully unpacked and MD5 sums checked package &#39;stringi&#39; successfully unpacked and MD5 sums checked package &#39;Matrix&#39; successfully unpacked and MD5 sums checked package &#39;survival&#39; successfully unpacked and MD5 sums checked package &#39;lattice&#39; successfully unpacked and MD5 sums checked package &#39;minqa&#39; successfully unpacked and MD5 sums checked package &#39;numDeriv&#39; successfully unpacked and MD5 sums checked package &#39;mitools&#39; successfully unpacked and MD5 sums checked package &#39;class&#39; successfully unpacked and MD5 sums checked package &#39;proxy&#39; successfully unpacked and MD5 sums checked package &#39;gdata&#39; successfully unpacked and MD5 sums checked package &#39;haven&#39; successfully unpacked and MD5 sums checked package &#39;stringr&#39; successfully unpacked and MD5 sums checked package &#39;tidyr&#39; successfully unpacked and MD5 sums checked package &#39;MASS&#39; successfully unpacked and MD5 sums checked package &#39;e1071&#39; successfully unpacked and MD5 sums checked package &#39;zoo&#39; successfully unpacked and MD5 sums checked package &#39;gmodels&#39; successfully unpacked and MD5 sums checked package &#39;nlme&#39; successfully unpacked and MD5 sums checked The downloaded binary packages are in C: Users cho_desktop AppData Local Temp RtmpC2VGFd downloaded_packages . installing the source packages &#39;withr&#39;, &#39;clipr&#39;, &#39;DBI&#39;, &#39;hms&#39;, &#39;cpp11&#39;, &#39;survey&#39;, &#39;labelled&#39;, &#39;tableone&#39; . library(plyr) library(dplyr) . Warning message: &#34;package &#39;plyr&#39; was built under R version 3.6.3&#34;Warning message: &#34;package &#39;dplyr&#39; was built under R version 3.6.3&#34; Attaching package: &#39;dplyr&#39; The following objects are masked from &#39;package:plyr&#39;: arrange, count, desc, failwith, id, mutate, rename, summarise, summarize The following objects are masked from &#39;package:stats&#39;: filter, lag The following objects are masked from &#39;package:base&#39;: intersect, setdiff, setequal, union . library(tableone) . Error in library(tableone): there is no package called &#39;tableone&#39; Traceback: 1. library(tableone) . &#44592;&#52488; &#53945;&#44053; . . aa &lt;- 1:5 # 벡터 bb &lt;- as.factor(aa) # 벡터 -&gt; factor cc &lt;- as.character(aa) # 벡터 -&gt; 케릭터 . bb # factor형 변수 # levels라는 한줄이 더 나온다. # 범주형변수 factor로 인식시켜줘야, 범주의 갯수와 종류를 print해준다. . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 4 | 5 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &#39;4&#39; | &#39;5&#39; | &lt;/ol&gt; cc # 문자형이라서 큰따옴표로 나온다 in R studio . &lt;ol class=list-inline&gt; &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &#39;4&#39; | &#39;5&#39; | &lt;/ol&gt; aa # numeric은 가감승제가 가능하다. . aa + 1 # 더하면 벡터 전체에 일괄 적용 된다. . &lt;ol class=list-inline&gt; 2 | 3 | 4 | 5 | 6 | &lt;/ol&gt; bb + 1 # 팩터형 변수에는 가감승제를 해줄 수 없다. . Warning message in Ops.factor(bb, 1): &#34;&#39;+&#39; not meaningful for factors&#34; . &lt;ol class=list-inline&gt; &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;/ol&gt; cc + 1 # 케릭터형 변수에는 가감승제를 할 수 없다. . Error in cc + 1: 이항연산자에 수치가 아닌 인수입니다 Traceback: . typeof(aa) . &#39;integer&#39; typeof(bb) # factor형은 내부에서 integer로 저장한다. . &#39;integer&#39; typeof(cc) . &#39;character&#39; . . dd &lt;- data.frame( aa, bb, cc) # 개별 벡터들을 넣어주면, 변수=&gt;칼럼이 된다. dd . aabbcc . 1 | 1 | 1 | . 2 | 2 | 2 | . 3 | 3 | 3 | . 4 | 4 | 4 | . 5 | 5 | 5 | . # data.frame은 type이 달라도 모아서 사용할 수 있다. . summary(dd) # aa: 연속형변수 -&gt; 기본? 통계가 잘 나온다 # bb: 각 범주에 갯수를 표시한 범주형 변수 -&gt; 도수분표표 # cc: 캐릭터변수 -&gt; 길이에다가 설명 # 데이터클리닝 최종목표 : summary에 넣었을 때 정상적으로 나와야함. . aa bb cc Min. :1 1:1 1:1 1st Qu.:2 2:1 2:1 Median :3 3:1 3:1 Mean :3 4:1 4:1 3rd Qu.:4 5:1 5:1 Max. :5 . . &#54056;&#53412;&#51648; &#49444;&#52824; &#48143; &#47196;&#46300; . dply r &#54056;&#53412;&#51648;&#51032; &#54028;&#51060;&#54532;&#46972;&#51064;&#47484; &#51060;&#50857;&#54620; &#45936;&#51060;&#53552;&#53364;&#47532;&#45789; . &#54028;&#51060;&#54532;&#46972;&#51064; &#49444;&#47749; . aa . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 4 | 5 | &lt;/ol&gt; log(aa) . &lt;ol class=list-inline&gt; 0 | 0.693147180559945 | 1.09861228866811 | 1.38629436111989 | 1.6094379124341 | &lt;/ol&gt; aa %&gt;% log() . &lt;ol class=list-inline&gt; 0 | 0.693147180559945 | 1.09861228866811 | 1.38629436111989 | 1.6094379124341 | &lt;/ol&gt; # 체이닝해서.. 여러가지 작업을 할 경우, 그 과정을 알 수 있다. round( sum( log(aa) ) ) . 5 # 왼쪽부터 읽는 것 &lt;-&gt; 호출 순서가 다른 것을 # 파이프라인으로 순서대로 읽고 실행되게 aa %&gt;% log() %&gt;% sum() %&gt;% round() . 5 &#51089;&#50629;&#50689;&#50669; &#51648;&#51221; &#46321; . &#45936;&#51060;&#53552;&#53364;&#47532;&#45789; . &#47196;&#46300; &#51204;, &#45936;&#51060;&#53552;&#47484; &#51069;&#44592;&#51204;&#50857;&#51004;&#47196; &#48708;&#45012;&#51452;&#44592; . . # 데이터를 객체에 저장 dat0 &lt;- read.csv(&#39;./data/특강//example_dataset.csv&#39;) # stringAsFactors = F) # R버전 4이하인 경우 수행해야함. . head(dat0) . idagesexRecur..1..Recur..0..Censored.OP_dateRecur_datelocal_6mCA19.9CEATNMCCIadc_decreaseadc_5_decreasevolume_changeapt_1_meanapt_1_95padc_1_meanadc_1_5p . 1 | 79 | 1 | 1 | 2014-07-07 | 2014-08-10 | 1 | 4490 | 8.7 | 5 | 1 | 8.83908844 | 1.8832245 | -2.357226849 | 5.167 | 2.840 | 89.37554932 | 53.85543 | . 2 | 54 | 0 | 0 | 2013-05-07 | 2018-07-07 | 1 | 37.8 | 2.5 | 4 | 1 | -2.473731995 | 6.4843369 | 140.736618 | 2.967 | 3.753 | 130.4454651 | 82.87475 | . 3 | 31 | 1 | 0 | 2016-05-06 | 2020-01-11 | 0 | 36.6 | 3.0 | 5 | 1 | 24.08946228 | 11.6069794 | 57.76787567 | 2.444 | 3.114 | 127.4504852 | 84.46223 | . 4 | 39 | 1 | 1 | 2015-11-25 | 2017-08-03 | 0 | 65 | 16.6 | 4 | 2 | 42.83881378 | 0.7782211 | 3.21591568 | 2.952 | 3.651 | 114.5146027 | 74.28822 | . 5 | 50 | 1 | 1 | 2015-02-09 | 2016-06-01 | 1 | 38.9 | 4.0 | 5 | 1 | 5.897392273 | 2.9760971 | -3.059473038 | 0.628 | 1.795 | 99.98454285 | 75.61291 | . 6 | 69 | 1 | 1 | 2015-06-22 | 2016-02-12 | 1 | 5.9 | 4.5 | 5 | 1 | na | 11.0519104 | 26.99385071 | 5.167 | 3.646 | 144.8905334 | 95.49654 | . view() &#48712; &#45936;&#51060;&#53552;&#44032; NA&#47196; &#51064;&#49885;&#46104;&#45716;&#51648; &#54869;&#51064;&#54616;&#44592; . view(dat0) # 엑셀 저장 실수로 빈 데이터가 NA로 차있다. -&gt; 50행까지만 읽자. . Error in view(dat0): 함수 &#34;view&#34;를 찾을 수 없습니다 Traceback: . # dat0 &lt;- read.csv(&#39;./data/특강//example_dataset.csv&#39;) # 빈 데이터는 제끼기 dat0 &lt;- read.csv(&#39;./data/특강//example_dataset.csv&#39;, nrow=50) . id&#44032; &#50976;&#45768;&#53356;&#54620;&#51648; (&#51473;&#48373;distinct.count) &#54869;&#51064; &#54616;&#44592; . head(dat0) . idagesexRecur..1..Recur..0..Censored.OP_dateRecur_datelocal_6mCA19.9CEATNMCCIadc_decreaseadc_5_decreasevolume_changeapt_1_meanapt_1_95padc_1_meanadc_1_5p . 1 | 79 | 1 | 1 | 2014-07-07 | 2014-08-10 | 1 | 4490 | 8.7 | 5 | 1 | 8.83908844 | 1.8832245 | -2.357226849 | 5.167 | 2.840 | 89.37554932 | 53.85543 | . 2 | 54 | 0 | 0 | 2013-05-07 | 2018-07-07 | 1 | 37.8 | 2.5 | 4 | 1 | -2.473731995 | 6.4843369 | 140.736618 | 2.967 | 3.753 | 130.4454651 | 82.87475 | . 3 | 31 | 1 | 0 | 2016-05-06 | 2020-01-11 | 0 | 36.6 | 3.0 | 5 | 1 | 24.08946228 | 11.6069794 | 57.76787567 | 2.444 | 3.114 | 127.4504852 | 84.46223 | . 4 | 39 | 1 | 1 | 2015-11-25 | 2017-08-03 | 0 | 65 | 16.6 | 4 | 2 | 42.83881378 | 0.7782211 | 3.21591568 | 2.952 | 3.651 | 114.5146027 | 74.28822 | . 5 | 50 | 1 | 1 | 2015-02-09 | 2016-06-01 | 1 | 38.9 | 4.0 | 5 | 1 | 5.897392273 | 2.9760971 | -3.059473038 | 0.628 | 1.795 | 99.98454285 | 75.61291 | . 6 | 69 | 1 | 1 | 2015-06-22 | 2016-02-12 | 1 | 5.9 | 4.5 | 5 | 1 | na | 11.0519104 | 26.99385071 | 5.167 | 3.646 | 144.8905334 | 95.49654 | . length(unique(dat0$id)) . 50 . &#47785;&#54364;&#51064; summary&#50640; &#45347;&#50612;&#48372;&#44592; . summary(dat0) . id age sex Recur..1..Recur..0..Censored. Min. : 1.00 Min. :25.00 Min. :0.00 Min. :0.00 1st Qu.:13.25 1st Qu.:49.25 1st Qu.:0.00 1st Qu.:0.00 Median :25.50 Median :58.50 Median :1.00 Median :0.00 Mean :25.50 Mean :56.44 Mean :0.66 Mean :0.44 3rd Qu.:37.75 3rd Qu.:65.75 3rd Qu.:1.00 3rd Qu.:1.00 Max. :50.00 Max. :79.00 Max. :1.00 Max. :1.00 OP_date Recur_date local_6m CA19.9 CEA 2011-12-29: 1 2018-07-07: 3 Min. :0.00 &lt;1.0 : 2 Min. : 0.630 2012-01-27: 1 2019-11-15: 2 1st Qu.:0.00 10.8 : 2 1st Qu.: 1.450 2012-03-13: 1 2019-11-19: 2 Median :0.00 5.9 : 2 Median : 2.500 2012-08-14: 1 2012-04-09: 1 Mean :0.46 10.7 : 1 Mean : 5.574 2012-09-20: 1 2012-08-29: 1 3rd Qu.:1.00 11.4 : 1 3rd Qu.: 4.150 2013-05-07: 1 2013-05-28: 1 Max. :1.00 12.1 : 1 Max. :115.900 (Other) :44 (Other) :40 (Other):41 TNM CCI adc_decrease adc_5_decrease Min. :1.00 Min. :0 42.83881378 : 9 Min. :-6.717 1st Qu.:3.00 1st Qu.:1 -2.473731995: 4 1st Qu.: 2.566 Median :4.00 Median :2 -1.790367126: 1 Median :11.329 Mean :3.56 Mean :2 . : 1 Mean :10.998 3rd Qu.:4.00 3rd Qu.:3 0.423 : 1 3rd Qu.:15.638 Max. :5.00 Max. :6 10.24687958 : 1 Max. :63.617 (Other) :33 volume_change apt_1_mean apt_1_95p adc_1_mean n/a : 2 Min. : 0.628 Min. :1.267 : 1 -12.57099533: 1 1st Qu.: 1.831 1st Qu.:2.517 100.3332748: 1 -14.51074219: 1 Median : 2.510 Median :3.034 100.7850723: 1 -2.133106232: 1 Mean : 3.129 Mean :3.065 101.1288986: 1 -2.357226849: 1 3rd Qu.: 3.100 3rd Qu.:3.650 106.94384 : 1 -20.45214844: 1 Max. :27.473 Max. :5.437 107.4796753: 1 (Other) :43 (Other) :44 adc_1_5p Min. : 53.86 1st Qu.: 75.78 Median : 85.10 Mean : 85.03 3rd Qu.: 92.43 Max. :116.59 . . # Recur -&gt; 변수명 짧게 # 날짜 -&gt; character로 인식함 #local_6m # ca19.9 -&gt; 케릭터로 인식됨. . &#48320;&#49688;&#47749; &#44596; &#44163;&#48512;&#53552; &#52376;&#47532; . dat0$Recur..1..Recur..0..Censored. . # 클리닝하명 dat1에 &lt;- . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) . &#45216;&#51676;&#54805;&#51004;&#47196; &#48148;&#45012;&#51452;&#44592; . dat0$OP_date . &lt;ol class=list-inline&gt; 2014-07-07 | 2013-05-07 | 2016-05-06 | 2015-11-25 | 2015-02-09 | 2015-06-22 | 2017-02-10 | 2012-09-20 | 2016-05-20 | 2017-05-19 | 2016-01-11 | 2015-11-24 | 2012-08-14 | 2016-07-13 | 2015-08-31 | 2015-12-16 | 2015-02-04 | 2015-07-23 | 2015-10-23 | 2011-12-29 | 2016-10-18 | 2012-01-27 | 2017-11-14 | 2017-07-27 | 2015-05-22 | 2015-02-26 | 2017-05-17 | 2016-03-14 | 2017-03-14 | 2016-09-20 | 2014-08-08 | 2016-10-12 | 2016-07-22 | 2016-01-26 | 2016-05-23 | 2017-06-29 | 2016-09-28 | 2017-09-05 | 2016-02-29 | 2013-12-20 | 2012-03-13 | 2015-09-10 | 2014-07-31 | 2015-01-27 | 2014-05-23 | 2017-08-21 | 2014-05-09 | 2015-07-21 | 2015-02-03 | 2015-09-07 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;2011-12-29&#39; | &#39;2012-01-27&#39; | &#39;2012-03-13&#39; | &#39;2012-08-14&#39; | &#39;2012-09-20&#39; | &#39;2013-05-07&#39; | &#39;2013-12-20&#39; | &#39;2014-05-09&#39; | &#39;2014-05-23&#39; | &#39;2014-07-07&#39; | &#39;2014-07-31&#39; | &#39;2014-08-08&#39; | &#39;2015-01-27&#39; | &#39;2015-02-03&#39; | &#39;2015-02-04&#39; | &#39;2015-02-09&#39; | &#39;2015-02-26&#39; | &#39;2015-05-22&#39; | &#39;2015-06-22&#39; | &#39;2015-07-21&#39; | &#39;2015-07-23&#39; | &#39;2015-08-31&#39; | &#39;2015-09-07&#39; | &#39;2015-09-10&#39; | &#39;2015-10-23&#39; | &#39;2015-11-24&#39; | &#39;2015-11-25&#39; | &#39;2015-12-16&#39; | &#39;2016-01-11&#39; | &#39;2016-01-26&#39; | &#39;2016-02-29&#39; | &#39;2016-03-14&#39; | &#39;2016-05-06&#39; | &#39;2016-05-20&#39; | &#39;2016-05-23&#39; | &#39;2016-07-13&#39; | &#39;2016-07-22&#39; | &#39;2016-09-20&#39; | &#39;2016-09-28&#39; | &#39;2016-10-12&#39; | &#39;2016-10-18&#39; | &#39;2017-02-10&#39; | &#39;2017-03-14&#39; | &#39;2017-05-17&#39; | &#39;2017-05-19&#39; | &#39;2017-06-29&#39; | &#39;2017-07-27&#39; | &#39;2017-08-21&#39; | &#39;2017-09-05&#39; | &#39;2017-11-14&#39; | &lt;/ol&gt; # 이것으로 확인한다. -&gt; 안되면 케릭터로 잘못 된 것임 dat0$OP_date + 1 . Warning message in Ops.factor(dat0$OP_date, 1): &#34;&#39;+&#39; not meaningful for factors&#34; . &lt;ol class=list-inline&gt; &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;/ol&gt; as.Date(dat0$OP_date, format = &quot;%Y-%m-%d&quot;) + 1 # 에러 안나면 성공임. . &lt;ol class=list-inline&gt; 2014-07-08 | 2013-05-08 | 2016-05-07 | 2015-11-26 | 2015-02-10 | 2015-06-23 | 2017-02-11 | 2012-09-21 | 2016-05-21 | 2017-05-20 | 2016-01-12 | 2015-11-25 | 2012-08-15 | 2016-07-14 | 2015-09-01 | 2015-12-17 | 2015-02-05 | 2015-07-24 | 2015-10-24 | 2011-12-30 | 2016-10-19 | 2012-01-28 | 2017-11-15 | 2017-07-28 | 2015-05-23 | 2015-02-27 | 2017-05-18 | 2016-03-15 | 2017-03-15 | 2016-09-21 | 2014-08-09 | 2016-10-13 | 2016-07-23 | 2016-01-27 | 2016-05-24 | 2017-06-30 | 2016-09-29 | 2017-09-06 | 2016-03-01 | 2013-12-21 | 2012-03-14 | 2015-09-11 | 2014-08-01 | 2015-01-28 | 2014-05-24 | 2017-08-22 | 2014-05-10 | 2015-07-22 | 2015-02-04 | 2015-09-08 | &lt;/ol&gt; &#54028;&#51060;&#54532;&#46972;&#51064;&#51004;&#47196; &#53364;&#47532;&#45789;&#44284;&#51221; &#52628;&#44032;&#54616;&#44592; . # mutate( = )덮어써주기 . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate(OP_date=as.Date(OP_date, format = &quot;%Y-%m-%d&quot;)) # + 1) . mutate() &#45824;&#49888; mutate_at( vars(&#44057;&#51008;&#51089;&#50629;&#54624;, &#52860;&#47084;&#46308;), list(~&#51201;&#50857;&#54632;&#49688;(.&#51004;&#47196; &#52860;&#47100;&#45824;&#52404;)) &#47196; &#50668;&#47084;&#52860;&#47100; &#54620;&#48264;&#50640; &#52376;&#47532;&#54616;&#44592; . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) . summary(dat1) . id age sex Recur Min. : 1.00 Min. :25.00 Min. :0.00 Min. :0.00 1st Qu.:13.25 1st Qu.:49.25 1st Qu.:0.00 1st Qu.:0.00 Median :25.50 Median :58.50 Median :1.00 Median :0.00 Mean :25.50 Mean :56.44 Mean :0.66 Mean :0.44 3rd Qu.:37.75 3rd Qu.:65.75 3rd Qu.:1.00 3rd Qu.:1.00 Max. :50.00 Max. :79.00 Max. :1.00 Max. :1.00 OP_date Recur_date local_6m CA19.9 Min. :2011-12-29 Min. :2012-04-09 Min. :0.00 &lt;1.0 : 2 1st Qu.:2015-01-28 1st Qu.:2016-06-25 1st Qu.:0.00 10.8 : 2 Median :2015-11-08 Median :2018-03-13 Median :0.00 5.9 : 2 Mean :2015-08-11 Mean :2017-09-21 Mean :0.46 10.7 : 1 3rd Qu.:2016-09-05 3rd Qu.:2019-10-12 3rd Qu.:1.00 11.4 : 1 Max. :2017-11-14 Max. :2020-01-11 Max. :1.00 12.1 : 1 (Other):41 CEA TNM CCI adc_decrease Min. : 0.630 Min. :1.00 Min. :0 42.83881378 : 9 1st Qu.: 1.450 1st Qu.:3.00 1st Qu.:1 -2.473731995: 4 Median : 2.500 Median :4.00 Median :2 -1.790367126: 1 Mean : 5.574 Mean :3.56 Mean :2 . : 1 3rd Qu.: 4.150 3rd Qu.:4.00 3rd Qu.:3 0.423 : 1 Max. :115.900 Max. :5.00 Max. :6 10.24687958 : 1 (Other) :33 adc_5_decrease volume_change apt_1_mean apt_1_95p Min. :-6.717 n/a : 2 Min. : 0.628 Min. :1.267 1st Qu.: 2.566 -12.57099533: 1 1st Qu.: 1.831 1st Qu.:2.517 Median :11.329 -14.51074219: 1 Median : 2.510 Median :3.034 Mean :10.998 -2.133106232: 1 Mean : 3.129 Mean :3.065 3rd Qu.:15.638 -2.357226849: 1 3rd Qu.: 3.100 3rd Qu.:3.650 Max. :63.617 -20.45214844: 1 Max. :27.473 Max. :5.437 (Other) :43 adc_1_mean adc_1_5p : 1 Min. : 53.86 100.3332748: 1 1st Qu.: 75.78 100.7850723: 1 Median : 85.10 101.1288986: 1 Mean : 85.03 106.94384 : 1 3rd Qu.: 92.43 107.4796753: 1 Max. :116.59 (Other) :44 . &#50672;&#49549;&#54805;&#51064;&#45936; character&#51064; &#50528;&#46308; . dat0$CA19.9 # 피검사 랩value # ~보다 작다(&lt;1)로 입력되는 경우가 많은데, 숫자가 아닌 . &lt;ol class=list-inline&gt; 4490 | 37.8 | 36.6 | 65 | 38.9 | 5.9 | 23.3 | 53.2 | 19.8 | 84.7 | 4860 | 50.2 | 15.9 | 18.9 | &lt;1.0 | 59.4 | 12.6 | 81.4 | 2500 | 6.6 | 71.1 | 4.3 | 68.7 | 11.4 | 10.8 | 10.8 | 5.9 | 3.3 | 14.4 | 47.9 | 25.6 | 134.1 | 10.7 | 472 | 160.6 | 23.2 | 20.4 | 3.4 | 55.3 | 9.2 | 5.1 | 12.1 | 2647 | 24.5 | 17.9 | 33.8 | 5.8 | 5.6 | &lt;1.0 | 99.3 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;&lt;1.0&#39; | &#39;10.7&#39; | &#39;10.8&#39; | &#39;11.4&#39; | &#39;12.1&#39; | &#39;12.6&#39; | &#39;134.1&#39; | &#39;14.4&#39; | &#39;15.9&#39; | &#39;160.6&#39; | &#39;17.9&#39; | &#39;18.9&#39; | &#39;19.8&#39; | &#39;20.4&#39; | &#39;23.2&#39; | &#39;23.3&#39; | &#39;24.5&#39; | &#39;25.6&#39; | &#39;2500&#39; | &#39;2647&#39; | &#39;3.3&#39; | &#39;3.4&#39; | &#39;33.8&#39; | &#39;36.6&#39; | &#39;37.8&#39; | &#39;38.9&#39; | &#39;4.3&#39; | &#39;4490&#39; | &#39;47.9&#39; | &#39;472&#39; | &#39;4860&#39; | &#39;5.1&#39; | &#39;5.6&#39; | &#39;5.8&#39; | &#39;5.9&#39; | &#39;50.2&#39; | &#39;53.2&#39; | &#39;55.3&#39; | &#39;59.4&#39; | &#39;6.6&#39; | &#39;65&#39; | &#39;68.7&#39; | &#39;71.1&#39; | &#39;81.4&#39; | &#39;84.7&#39; | &#39;9.2&#39; | &#39;99.3&#39; | &lt;/ol&gt; . replace&#47196; &#47928;&#51088;&#50676;&#49707;&#51088; -&gt; &#49707;&#51088;&#47196; &#48148;&#45012;&#51452;&#44592; . replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)#위치 #바꿀값 # 숫자로 바꿔졌찌만, 칼럼 전체가 케릭터(팩터)라 &quot;1&quot;로 들어갈 듯 # 칼럼 전체가 응답된다. . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . &lt;ol class=list-inline&gt; 4490 | 37.8 | 36.6 | 65 | 38.9 | 5.9 | 23.3 | 53.2 | 19.8 | 84.7 | 4860 | 50.2 | 15.9 | 18.9 | &lt;NA&gt; | 59.4 | 12.6 | 81.4 | 2500 | 6.6 | 71.1 | 4.3 | 68.7 | 11.4 | 10.8 | 10.8 | 5.9 | 3.3 | 14.4 | 47.9 | 25.6 | 134.1 | 10.7 | 472 | 160.6 | 23.2 | 20.4 | 3.4 | 55.3 | 9.2 | 5.1 | 12.1 | 2647 | 24.5 | 17.9 | 33.8 | 5.8 | 5.6 | &lt;NA&gt; | 99.3 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;&lt;1.0&#39; | &#39;10.7&#39; | &#39;10.8&#39; | &#39;11.4&#39; | &#39;12.1&#39; | &#39;12.6&#39; | &#39;134.1&#39; | &#39;14.4&#39; | &#39;15.9&#39; | &#39;160.6&#39; | &#39;17.9&#39; | &#39;18.9&#39; | &#39;19.8&#39; | &#39;20.4&#39; | &#39;23.2&#39; | &#39;23.3&#39; | &#39;24.5&#39; | &#39;25.6&#39; | &#39;2500&#39; | &#39;2647&#39; | &#39;3.3&#39; | &#39;3.4&#39; | &#39;33.8&#39; | &#39;36.6&#39; | &#39;37.8&#39; | &#39;38.9&#39; | &#39;4.3&#39; | &#39;4490&#39; | &#39;47.9&#39; | &#39;472&#39; | &#39;4860&#39; | &#39;5.1&#39; | &#39;5.6&#39; | &#39;5.8&#39; | &#39;5.9&#39; | &#39;50.2&#39; | &#39;53.2&#39; | &#39;55.3&#39; | &#39;59.4&#39; | &#39;6.6&#39; | &#39;65&#39; | &#39;68.7&#39; | &#39;71.1&#39; | &#39;81.4&#39; | &#39;84.7&#39; | &#39;9.2&#39; | &#39;99.3&#39; | &lt;/ol&gt; as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . &lt;ol class=list-inline&gt; 28 | 25 | 24 | 41 | 26 | 35 | 16 | 37 | 13 | 45 | 31 | 36 | 9 | 12 | &lt;NA&gt; | 39 | 6 | 44 | 19 | 40 | 43 | 27 | 42 | 4 | 3 | 3 | 35 | 21 | 8 | 29 | 18 | 7 | 2 | 30 | 10 | 15 | 14 | 22 | 38 | 46 | 32 | 5 | 20 | 17 | 11 | 23 | 34 | 33 | &lt;NA&gt; | 47 | &lt;/ol&gt; dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . summary(dat1) . id age sex Recur Min. : 1.00 Min. :25.00 Min. :0.00 Min. :0.00 1st Qu.:13.25 1st Qu.:49.25 1st Qu.:0.00 1st Qu.:0.00 Median :25.50 Median :58.50 Median :1.00 Median :0.00 Mean :25.50 Mean :56.44 Mean :0.66 Mean :0.44 3rd Qu.:37.75 3rd Qu.:65.75 3rd Qu.:1.00 3rd Qu.:1.00 Max. :50.00 Max. :79.00 Max. :1.00 Max. :1.00 OP_date Recur_date local_6m CA19.9 Min. :2011-12-29 Min. :2012-04-09 Min. :0.00 Min. : 2.00 1st Qu.:2015-01-28 1st Qu.:2016-06-25 1st Qu.:0.00 1st Qu.:12.75 Median :2015-11-08 Median :2018-03-13 Median :0.00 Median :24.50 Mean :2015-08-11 Mean :2017-09-21 Mean :0.46 Mean :24.27 3rd Qu.:2016-09-05 3rd Qu.:2019-10-12 3rd Qu.:1.00 3rd Qu.:35.25 Max. :2017-11-14 Max. :2020-01-11 Max. :1.00 Max. :47.00 NA&#39;s :2 CEA TNM CCI adc_decrease Min. : 0.630 Min. :1.00 Min. :0 42.83881378 : 9 1st Qu.: 1.450 1st Qu.:3.00 1st Qu.:1 -2.473731995: 4 Median : 2.500 Median :4.00 Median :2 -1.790367126: 1 Mean : 5.574 Mean :3.56 Mean :2 . : 1 3rd Qu.: 4.150 3rd Qu.:4.00 3rd Qu.:3 0.423 : 1 Max. :115.900 Max. :5.00 Max. :6 10.24687958 : 1 (Other) :33 adc_5_decrease volume_change apt_1_mean apt_1_95p Min. :-6.717 n/a : 2 Min. : 0.628 Min. :1.267 1st Qu.: 2.566 -12.57099533: 1 1st Qu.: 1.831 1st Qu.:2.517 Median :11.329 -14.51074219: 1 Median : 2.510 Median :3.034 Mean :10.998 -2.133106232: 1 Mean : 3.129 Mean :3.065 3rd Qu.:15.638 -2.357226849: 1 3rd Qu.: 3.100 3rd Qu.:3.650 Max. :63.617 -20.45214844: 1 Max. :27.473 Max. :5.437 (Other) :43 adc_1_mean adc_1_5p : 1 Min. : 53.86 100.3332748: 1 1st Qu.: 75.78 100.7850723: 1 Median : 85.10 101.1288986: 1 Mean : 85.03 106.94384 : 1 3rd Qu.: 92.43 107.4796753: 1 Max. :116.59 (Other) :44 . &#47928;&#51088;&#50676;&quot;.&quot;&#44284; &quot;na&quot;&#51060;&#44032; &#46308;&#50612;&#44032;&#51080;&#45716; &#49707;&#51088;&#54805; &#48320;&#49688; -&gt; &#44208;&#52769;(&#45824;&#47928;&#51088; &quot;NA&quot;)&#51004;&#47196; &#52376;&#47532;&#54644;&#48372;&#51088;. . dat0$adc_decrease . &lt;ol class=list-inline&gt; 8.83908844 | -2.473731995 | 24.08946228 | 42.83881378 | 5.897392273 | na | 12.79924774 | 42.83881378 | 10.24687958 | 16.47277069 | 3.877372742 | 17.01249695 | 4.098892212 | 42.83881378 | 30.9415741 | 11.229599 | 42.83881378 | 37.16684723 | 25.70823669 | -2.473731995 | 40.03754425 | 17.24663544 | 5.312309265 | 33.87471008 | 42.83881378 | 26.80117798 | 6.082252502 | 35.74214172 | 42.83881378 | 21.19241333 | 15.09790039 | 7.512702942 | 9.244918823 | 25.51950836 | 42.83881378 | . | 22.15099335 | 12.68886566 | 17.57089233 | 42.83881378 | 70.52548981 | 10.59333801 | -1.790367126 | 19.15110016 | -2.473731995 | 0.423 | 42.83881378 | 15.3989563 | -2.473731995 | 40.38618469 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;-1.790367126&#39; | &#39;-2.473731995&#39; | &#39;.&#39; | &#39;0.423&#39; | &#39;10.24687958&#39; | &#39;10.59333801&#39; | &#39;11.229599&#39; | &#39;12.68886566&#39; | &#39;12.79924774&#39; | &#39;15.09790039&#39; | &#39;15.3989563&#39; | &#39;16.47277069&#39; | &#39;17.01249695&#39; | &#39;17.24663544&#39; | &#39;17.57089233&#39; | &#39;19.15110016&#39; | &#39;21.19241333&#39; | &#39;22.15099335&#39; | &#39;24.08946228&#39; | &#39;25.51950836&#39; | &#39;25.70823669&#39; | &#39;26.80117798&#39; | &#39;3.877372742&#39; | &#39;30.9415741&#39; | &#39;33.87471008&#39; | &#39;35.74214172&#39; | &#39;37.16684723&#39; | &#39;4.098892212&#39; | &#39;40.03754425&#39; | &#39;40.38618469&#39; | &#39;42.83881378&#39; | &#39;5.312309265&#39; | &#39;5.897392273&#39; | &#39;6.082252502&#39; | &#39;7.512702942&#39; | &#39;70.52548981&#39; | &#39;8.83908844&#39; | &#39;9.244918823&#39; | &#39;na&#39; | &lt;/ol&gt; dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . summary(dat1) . id age sex Recur Min. : 1.00 Min. :25.00 Min. :0.00 Min. :0.00 1st Qu.:13.25 1st Qu.:49.25 1st Qu.:0.00 1st Qu.:0.00 Median :25.50 Median :58.50 Median :1.00 Median :0.00 Mean :25.50 Mean :56.44 Mean :0.66 Mean :0.44 3rd Qu.:37.75 3rd Qu.:65.75 3rd Qu.:1.00 3rd Qu.:1.00 Max. :50.00 Max. :79.00 Max. :1.00 Max. :1.00 OP_date Recur_date local_6m CA19.9 Min. :2011-12-29 Min. :2012-04-09 Min. :0.00 Min. : 2.00 1st Qu.:2015-01-28 1st Qu.:2016-06-25 1st Qu.:0.00 1st Qu.:12.75 Median :2015-11-08 Median :2018-03-13 Median :0.00 Median :24.50 Mean :2015-08-11 Mean :2017-09-21 Mean :0.46 Mean :24.27 3rd Qu.:2016-09-05 3rd Qu.:2019-10-12 3rd Qu.:1.00 3rd Qu.:35.25 Max. :2017-11-14 Max. :2020-01-11 Max. :1.00 Max. :47.00 NA&#39;s :2 CEA TNM CCI adc_decrease adc_5_decrease Min. : 0.630 Min. :1.00 Min. :0 Min. : 1.00 Min. :-6.717 1st Qu.: 1.450 1st Qu.:3.00 1st Qu.:1 1st Qu.:10.75 1st Qu.: 2.566 Median : 2.500 Median :4.00 Median :2 Median :22.50 Median :11.329 Mean : 5.574 Mean :3.56 Mean :2 Mean :20.67 Mean :10.998 3rd Qu.: 4.150 3rd Qu.:4.00 3rd Qu.:3 3rd Qu.:31.00 3rd Qu.:15.638 Max. :115.900 Max. :5.00 Max. :6 Max. :38.00 Max. :63.617 NA&#39;s :2 volume_change apt_1_mean apt_1_95p adc_1_mean n/a : 2 Min. : 0.628 Min. :1.267 : 1 -12.57099533: 1 1st Qu.: 1.831 1st Qu.:2.517 100.3332748: 1 -14.51074219: 1 Median : 2.510 Median :3.034 100.7850723: 1 -2.133106232: 1 Mean : 3.129 Mean :3.065 101.1288986: 1 -2.357226849: 1 3rd Qu.: 3.100 3rd Qu.:3.650 106.94384 : 1 -20.45214844: 1 Max. :27.473 Max. :5.437 107.4796753: 1 (Other) :43 (Other) :44 adc_1_5p Min. : 53.86 1st Qu.: 75.78 Median : 85.10 Mean : 85.03 3rd Qu.: 92.43 Max. :116.59 . &quot;n/a&quot; &#52376;&#47532; volume_change&#51032; &#47928;&#51228; . dat0$volume_change . &lt;ol class=list-inline&gt; -2.357226849 | 140.736618 | 57.76787567 | 3.21591568 | -3.059473038 | 26.99385071 | 15.75263786 | -14.51074219 | 35.89277363 | -23.29013634 | -24.1180644 | n/a | 14.30595779 | n/a | 61.12881088 | 80.11054611 | 29.39501953 | 80.77587891 | -42.23847198 | 68.45624542 | 64.41679382 | 116.6783257 | 8.413768768 | 14.72431612 | 7.143749237 | 1.901952744 | 33.4467752 | 118.6039994 | 119.1181564 | 3.223827362 | 80.79081726 | -28.04677582 | -6.659473419 | 39.32578278 | -2.133106232 | 71.6211853 | 88.36875153 | 23.59248352 | 4.665237427 | 21.60439301 | 51.39668274 | 40.27851391 | -12.57099533 | -5.537094116 | 91.3113327 | 24.23391724 | 12.77226639 | 34.60077667 | -20.45214844 | 125.2863274 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;-12.57099533&#39; | &#39;-14.51074219&#39; | &#39;-2.133106232&#39; | &#39;-2.357226849&#39; | &#39;-20.45214844&#39; | &#39;-23.29013634&#39; | &#39;-24.1180644&#39; | &#39;-28.04677582&#39; | &#39;-3.059473038&#39; | &#39;-42.23847198&#39; | &#39;-5.537094116&#39; | &#39;-6.659473419&#39; | &#39;1.901952744&#39; | &#39;116.6783257&#39; | &#39;118.6039994&#39; | &#39;119.1181564&#39; | &#39;12.77226639&#39; | &#39;125.2863274&#39; | &#39;14.30595779&#39; | &#39;14.72431612&#39; | &#39;140.736618&#39; | &#39;15.75263786&#39; | &#39;21.60439301&#39; | &#39;23.59248352&#39; | &#39;24.23391724&#39; | &#39;26.99385071&#39; | &#39;29.39501953&#39; | &#39;3.21591568&#39; | &#39;3.223827362&#39; | &#39;33.4467752&#39; | &#39;34.60077667&#39; | &#39;35.89277363&#39; | &#39;39.32578278&#39; | &#39;4.665237427&#39; | &#39;40.27851391&#39; | &#39;51.39668274&#39; | &#39;57.76787567&#39; | &#39;61.12881088&#39; | &#39;64.41679382&#39; | &#39;68.45624542&#39; | &#39;7.143749237&#39; | &#39;71.6211853&#39; | &#39;8.413768768&#39; | &#39;80.11054611&#39; | &#39;80.77587891&#39; | &#39;80.79081726&#39; | &#39;88.36875153&#39; | &#39;91.3113327&#39; | &#39;n/a&#39; | &lt;/ol&gt; dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), # 마지막엔 더블형변환해야하니 as.double부터 volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . &#48276;&#51452;&#54805;&#51064;&#45936;, &#50672;&#49549;&#54805;&#51004;&#47196; &#54364;&#44592;&#46104;&#50612;&#51080;&#45716; &#44057;&#51008;&#51089;&#50629;&#46308; -&gt; mutate_at&#51004;&#47196; &#52376;&#47532; . local_6m , sex? | . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), # 마지막엔 더블형변환해야하니 as.double부터 volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA))) %&gt;% mutate_at(vars(sex, Recur, local_6m, TNM, CCI), list(~as.factor(.))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . summary(dat1) . id age sex Recur OP_date Min. : 1.00 Min. :25.00 0:17 0:28 Min. :2011-12-29 1st Qu.:13.25 1st Qu.:49.25 1:33 1:22 1st Qu.:2015-01-28 Median :25.50 Median :58.50 Median :2015-11-08 Mean :25.50 Mean :56.44 Mean :2015-08-11 3rd Qu.:37.75 3rd Qu.:65.75 3rd Qu.:2016-09-05 Max. :50.00 Max. :79.00 Max. :2017-11-14 Recur_date local_6m CA19.9 CEA TNM CCI Min. :2012-04-09 0:27 Min. : 2.00 Min. : 0.630 1: 2 0: 3 1st Qu.:2016-06-25 1:23 1st Qu.:12.75 1st Qu.: 1.450 2: 5 1:16 Median :2018-03-13 Median :24.50 Median : 2.500 3:12 2:15 Mean :2017-09-21 Mean :24.27 Mean : 5.574 4:25 3:12 3rd Qu.:2019-10-12 3rd Qu.:35.25 3rd Qu.: 4.150 5: 6 4: 3 Max. :2020-01-11 Max. :47.00 Max. :115.900 6: 1 NA&#39;s :2 adc_decrease adc_5_decrease volume_change apt_1_mean Min. : 1.00 Min. :-6.717 Min. : 1.00 Min. : 0.628 1st Qu.:10.75 1st Qu.: 2.566 1st Qu.:12.75 1st Qu.: 1.831 Median :22.50 Median :11.329 Median :24.50 Median : 2.510 Mean :20.67 Mean :10.998 Mean :24.50 Mean : 3.129 3rd Qu.:31.00 3rd Qu.:15.638 3rd Qu.:36.25 3rd Qu.: 3.100 Max. :38.00 Max. :63.617 Max. :48.00 Max. :27.473 NA&#39;s :2 NA&#39;s :2 apt_1_95p adc_1_mean adc_1_5p Min. :1.267 : 1 Min. : 53.86 1st Qu.:2.517 100.3332748: 1 1st Qu.: 75.78 Median :3.034 100.7850723: 1 Median : 85.10 Mean :3.065 101.1288986: 1 Mean : 85.03 3rd Qu.:3.650 106.94384 : 1 3rd Qu.: 92.43 Max. :5.437 107.4796753: 1 Max. :116.59 (Other) :44 . &#53888;&#50612;&#45716; &#44050;&#46308;(LabValue&#46308;)&#51012; log&#48320;&#54872; . CA19.9 정상치는 거기서 거기인데, 이상인 경우 수천배로 팍 튀는 경우 -&gt; 데이터의 분포가 너무 길어져 원본으로는 다른변수와의 관계가 깨진다. | . hist&#47484; &#44536;&#47140;, &#44537;&#49548;&#49688;&#47564; &#50628;&#52397; &#53888;&#45716; &#44163;&#51012; &#54869;&#51064;&#54616;&#51088;. . hist(dat1$CA19.9) . &#12615;&#12615; . hist( log) . log.&#51012; &#48537;&#50668; &#49352;&#47196;&#50868; &#48320;&#49688;&#47196; &#52628;&#44032; . 0이 있으면 다른 값 or 1로 바꿔서 로그취해야함. | . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA)), # 여기(mutate)다 추가 log.CA19.9 = log(CA19.9), log.CEA=log(CEA) # 위에다 추가 ) %&gt;% mutate_at(vars(sex, Recur, local_6m, TNM, CCI), list(~as.factor(.))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . 36&#48516; &#48148;&#51060;&#45789; CA19 &#52628;&#44032; by ifelse -&gt; asfactor&#51089;&#50629;&#50640;&#46020; &#48320;&#49688; 1&#44060; &#52628;&#44032; . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA)), log.CA19.9 = log(CA19.9), log.CEA=log(CEA), CA19.9.group=ifelse(CA19.9&gt;37, 1, 0), # 칼럼 생성 ) %&gt;% mutate_at(vars(sex, Recur, local_6m, TNM, CCI, CA19.9 # factor화 추가 ), list(~as.factor(.))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . ply r &#51012; &#53685;&#54644; mapvalue (1,2&#47484; &#47926;&#50612; -&gt; TNM.b&#52860;&#47100;&#51004;&#47196;)&#50416;&#44592; . from 원래 카테고리 -&gt; to = 합칠거명 같은이름으로 순서대로 차례대로 카테고리 ) | 다시 범주형 만드는 곳에서 처리 | . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA)), log.CA19.9 = log(CA19.9), log.CEA=log(CEA), CA19.9.group=ifelse(CA19.9&gt;37, 1, 0), TNM.b = mapvalues(TNM, from=c(1,2,3,4,5), to=c(&quot;1or2&quot;, &quot;1or2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)), # 카테고리 합치기 ) %&gt;% mutate_at(vars(sex, Recur, local_6m, TNM, CCI, CA19.9, TNM.b # 추가 ), list(~as.factor(.))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA)), log.CA19.9 = log(CA19.9), log.CEA=log(CEA), CA19.9.group=ifelse(CA19.9&gt;37, 1, 0), TNM.b = mapvalues(TNM, from=c(1,2,3,4,5), to=c(&quot;1or2&quot;, &quot;1or2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)), CCI.b = mapvalues(CCI, from=c(0,1,2,3,4,6), to=c(&quot;0or1&quot;, &quot;0or1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;&gt;=4&quot;, &quot;&gt;=4&quot;)), ) %&gt;% mutate_at(vars(sex, Recur, local_6m, TNM, CCI, CA19.9, TNM.b # 추가 ), list(~as.factor(.))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . &#50668;&#44592;&#49436;&#48512;&#53552;&#45716; &#47803;&#46384;&#46972;&#44048; . # as.factor가 아닌 factor로 어떤 순서대로 카테고리를 하고싶은지 인식시켜준다 # 아래에서 as.factor부분에서 빼준다. . 45&#48516;&#48512;&#53552; &#47803;&#46384;&#46972;&#44048;.. . 48&#44620;&#51648; &#53364;&#47532;&#45789;&#51008; &#45149; . library(&quot;tableone&quot;) . tableone&#51004;&#47196; &#49789;&#44172; table&#47564;&#46308;&#44592; . var1&lt;-c(&quot;Recur&quot;, &quot;RFS&quot;, &quot;local_6m&quot;, &quot;age&quot;, &quot;sex&quot;, &quot;CA19.9&quot;, &quot;log.CA19.9&quot;, &quot;CA19.9.group&quot;, &quot;CEA&quot;, &quot;log.CEA&quot;, &quot;TNM&quot;, &quot;TNM.b&quot;, &quot;CCI&quot;, &quot;CCI.b&quot;, &quot;adc_decrease&quot;, &quot;adc_5_decrease&quot;, &quot;volume_change&quot;, &quot;apt_1_mean&quot;, &quot;apt_1_95p&quot;, &quot;adc_1_mean&quot;, &quot;adc_1_5p&quot;) . tobj&lt;-CreateTableOne(vars = var1, data=dat1) summary(tobj) . Warning message in ModuleReturnVarsExist(vars, data): &#34;The data frame does not have: RFS Dropped&#34; . ### Summary of continuous variables ### strata: Overall n miss p.miss mean sd median p25 p75 min max skew kurt age 50 0 0 56.4 12.6 58.5 49.2 66 25.0 79 -0.47 -0.3 log.CA19.9 50 2 4 2.9 0.8 3.2 2.5 4 0.7 4 -1.12 0.5 CA19.9.group 50 2 4 0.2 0.4 0.0 0.0 0 0.0 1 1.48 0.2 CEA 50 0 0 5.6 16.3 2.5 1.4 4 0.6 116 6.63 45.5 log.CEA 50 0 0 1.0 0.9 0.9 0.4 1 -0.5 5 1.81 5.8 adc_decrease 50 2 4 20.7 11.5 22.5 10.8 31 1.0 38 -0.31 -1.3 adc_5_decrease 50 0 0 11.0 12.2 11.3 2.6 16 -6.7 64 1.74 6.0 volume_change 50 2 4 24.5 14.0 24.5 12.8 36 1.0 48 0.00 -1.2 apt_1_mean 50 0 0 3.1 3.7 2.5 1.8 3 0.6 27 6.06 40.2 apt_1_95p 50 0 0 3.1 0.9 3.0 2.5 4 1.3 5 0.40 0.5 adc_1_5p 50 0 0 85.0 11.5 85.1 75.8 92 53.9 117 0.05 0.5 ======================================================================================= ### Summary of categorical variables ### strata: Overall var n miss p.miss level freq percent cum.percent Recur 50 0 0.0 0 28 56.0 56.0 1 22 44.0 100.0 local_6m 50 0 0.0 0 27 54.0 54.0 1 23 46.0 100.0 sex 50 0 0.0 0 17 34.0 34.0 1 33 66.0 100.0 CA19.9 50 2 4.0 2 1 2.1 2.1 3 2 4.2 6.2 4 1 2.1 8.3 5 1 2.1 10.4 6 1 2.1 12.5 7 1 2.1 14.6 8 1 2.1 16.7 9 1 2.1 18.8 10 1 2.1 20.8 11 1 2.1 22.9 12 1 2.1 25.0 13 1 2.1 27.1 14 1 2.1 29.2 15 1 2.1 31.2 16 1 2.1 33.3 17 1 2.1 35.4 18 1 2.1 37.5 19 1 2.1 39.6 20 1 2.1 41.7 21 1 2.1 43.8 22 1 2.1 45.8 23 1 2.1 47.9 24 1 2.1 50.0 25 1 2.1 52.1 26 1 2.1 54.2 27 1 2.1 56.2 28 1 2.1 58.3 29 1 2.1 60.4 30 1 2.1 62.5 31 1 2.1 64.6 32 1 2.1 66.7 33 1 2.1 68.8 34 1 2.1 70.8 35 2 4.2 75.0 36 1 2.1 77.1 37 1 2.1 79.2 38 1 2.1 81.2 39 1 2.1 83.3 40 1 2.1 85.4 41 1 2.1 87.5 42 1 2.1 89.6 43 1 2.1 91.7 44 1 2.1 93.8 45 1 2.1 95.8 46 1 2.1 97.9 47 1 2.1 100.0 TNM 50 0 0.0 1 2 4.0 4.0 2 5 10.0 14.0 3 12 24.0 38.0 4 25 50.0 88.0 5 6 12.0 100.0 TNM.b 50 0 0.0 1or2 7 14.0 14.0 3 12 24.0 38.0 4 25 50.0 88.0 5 6 12.0 100.0 CCI 50 0 0.0 0 3 6.0 6.0 1 16 32.0 38.0 2 15 30.0 68.0 3 12 24.0 92.0 4 3 6.0 98.0 6 1 2.0 100.0 CCI.b 50 0 0.0 &gt;=4 4 8.0 8.0 0or1 19 38.0 46.0 2 15 30.0 76.0 3 12 24.0 100.0 adc_1_mean 50 0 0.0 1 2.0 2.0 100.3332748 1 2.0 4.0 100.7850723 1 2.0 6.0 101.1288986 1 2.0 8.0 106.94384 1 2.0 10.0 107.4796753 1 2.0 12.0 108.1219025 1 2.0 14.0 108.4807739 1 2.0 16.0 109.8269577 1 2.0 18.0 110.6593323 1 2.0 20.0 112.250946 1 2.0 22.0 112.6311264 1 2.0 24.0 113.6343842 1 2.0 26.0 114.5146027 1 2.0 28.0 116.6255951 1 2.0 30.0 116.9603348 1 2.0 32.0 119.7995605 1 2.0 34.0 121.1716843 1 2.0 36.0 123.4509964 1 2.0 38.0 123.5778046 1 2.0 40.0 125.6047516 1 2.0 42.0 125.8717575 1 2.0 44.0 127.4504852 1 2.0 46.0 128.1634064 1 2.0 48.0 128.2574005 1 2.0 50.0 128.8485718 1 2.0 52.0 129.5490875 1 2.0 54.0 129.7754059 1 2.0 56.0 130.4454651 1 2.0 58.0 131.0157623 1 2.0 60.0 131.2865448 1 2.0 62.0 133.0798645 1 2.0 64.0 134.7369385 1 2.0 66.0 137.2429199 1 2.0 68.0 137.4812317 1 2.0 70.0 138.7712097 1 2.0 72.0 139.8694763 1 2.0 74.0 140.6768646 1 2.0 76.0 142.7576294 1 2.0 78.0 144.4676361 1 2.0 80.0 144.8905334 1 2.0 82.0 146.3157654 1 2.0 84.0 149.0292358 1 2.0 86.0 152.9427185 1 2.0 88.0 154.0635529 1 2.0 90.0 154.9950104 1 2.0 92.0 82.6672821 1 2.0 94.0 89.37554932 1 2.0 96.0 99.98454285 1 2.0 98.0 n/a 1 2.0 100.0 . . # 범주형 변수들의 요약통계량이 나온다. 갯수와 % . print(tobj) . Overall n 50 Recur = 1 (%) 22 (44.0) local_6m = 1 (%) 23 (46.0) age (mean (SD)) 56.44 (12.60) sex = 1 (%) 33 (66.0) CA19.9 (%) 2 1 ( 2.1) 3 2 ( 4.2) 4 1 ( 2.1) 5 1 ( 2.1) 6 1 ( 2.1) 7 1 ( 2.1) 8 1 ( 2.1) 9 1 ( 2.1) 10 1 ( 2.1) 11 1 ( 2.1) 12 1 ( 2.1) 13 1 ( 2.1) 14 1 ( 2.1) 15 1 ( 2.1) 16 1 ( 2.1) 17 1 ( 2.1) 18 1 ( 2.1) 19 1 ( 2.1) 20 1 ( 2.1) 21 1 ( 2.1) 22 1 ( 2.1) 23 1 ( 2.1) 24 1 ( 2.1) 25 1 ( 2.1) 26 1 ( 2.1) 27 1 ( 2.1) 28 1 ( 2.1) 29 1 ( 2.1) 30 1 ( 2.1) 31 1 ( 2.1) 32 1 ( 2.1) 33 1 ( 2.1) 34 1 ( 2.1) 35 2 ( 4.2) 36 1 ( 2.1) 37 1 ( 2.1) 38 1 ( 2.1) 39 1 ( 2.1) 40 1 ( 2.1) 41 1 ( 2.1) 42 1 ( 2.1) 43 1 ( 2.1) 44 1 ( 2.1) 45 1 ( 2.1) 46 1 ( 2.1) 47 1 ( 2.1) log.CA19.9 (mean (SD)) 2.95 (0.81) CA19.9.group (mean (SD)) 0.21 (0.41) CEA (mean (SD)) 5.57 (16.28) log.CEA (mean (SD)) 0.99 (0.89) TNM (%) 1 2 ( 4.0) 2 5 (10.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) TNM.b (%) 1or2 7 (14.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) CCI (%) 0 3 ( 6.0) 1 16 (32.0) 2 15 (30.0) 3 12 (24.0) 4 3 ( 6.0) 6 1 ( 2.0) CCI.b (%) &gt;=4 4 ( 8.0) 0or1 19 (38.0) 2 15 (30.0) 3 12 (24.0) adc_decrease (mean (SD)) 20.67 (11.49) adc_5_decrease (mean (SD)) 11.00 (12.19) volume_change (mean (SD)) 24.50 (14.00) apt_1_mean (mean (SD)) 3.13 (3.70) apt_1_95p (mean (SD)) 3.07 (0.88) adc_1_mean (%) 1 ( 2.0) 100.3332748 1 ( 2.0) 100.7850723 1 ( 2.0) 101.1288986 1 ( 2.0) 106.94384 1 ( 2.0) 107.4796753 1 ( 2.0) 108.1219025 1 ( 2.0) 108.4807739 1 ( 2.0) 109.8269577 1 ( 2.0) 110.6593323 1 ( 2.0) 112.250946 1 ( 2.0) 112.6311264 1 ( 2.0) 113.6343842 1 ( 2.0) 114.5146027 1 ( 2.0) 116.6255951 1 ( 2.0) 116.9603348 1 ( 2.0) 119.7995605 1 ( 2.0) 121.1716843 1 ( 2.0) 123.4509964 1 ( 2.0) 123.5778046 1 ( 2.0) 125.6047516 1 ( 2.0) 125.8717575 1 ( 2.0) 127.4504852 1 ( 2.0) 128.1634064 1 ( 2.0) 128.2574005 1 ( 2.0) 128.8485718 1 ( 2.0) 129.5490875 1 ( 2.0) 129.7754059 1 ( 2.0) 130.4454651 1 ( 2.0) 131.0157623 1 ( 2.0) 131.2865448 1 ( 2.0) 133.0798645 1 ( 2.0) 134.7369385 1 ( 2.0) 137.2429199 1 ( 2.0) 137.4812317 1 ( 2.0) 138.7712097 1 ( 2.0) 139.8694763 1 ( 2.0) 140.6768646 1 ( 2.0) 142.7576294 1 ( 2.0) 144.4676361 1 ( 2.0) 144.8905334 1 ( 2.0) 146.3157654 1 ( 2.0) 149.0292358 1 ( 2.0) 152.9427185 1 ( 2.0) 154.0635529 1 ( 2.0) 154.9950104 1 ( 2.0) 82.6672821 1 ( 2.0) 89.37554932 1 ( 2.0) 99.98454285 1 ( 2.0) n/a 1 ( 2.0) adc_1_5p (mean (SD)) 85.03 (11.48) . print(tobj, showAllLevels = T) . level Overall n 50 Recur (%) 0 28 (56.0) 1 22 (44.0) local_6m (%) 0 27 (54.0) 1 23 (46.0) age (mean (SD)) 56.44 (12.60) sex (%) 0 17 (34.0) 1 33 (66.0) CA19.9 (%) 2 1 ( 2.1) 3 2 ( 4.2) 4 1 ( 2.1) 5 1 ( 2.1) 6 1 ( 2.1) 7 1 ( 2.1) 8 1 ( 2.1) 9 1 ( 2.1) 10 1 ( 2.1) 11 1 ( 2.1) 12 1 ( 2.1) 13 1 ( 2.1) 14 1 ( 2.1) 15 1 ( 2.1) 16 1 ( 2.1) 17 1 ( 2.1) 18 1 ( 2.1) 19 1 ( 2.1) 20 1 ( 2.1) 21 1 ( 2.1) 22 1 ( 2.1) 23 1 ( 2.1) 24 1 ( 2.1) 25 1 ( 2.1) 26 1 ( 2.1) 27 1 ( 2.1) 28 1 ( 2.1) 29 1 ( 2.1) 30 1 ( 2.1) 31 1 ( 2.1) 32 1 ( 2.1) 33 1 ( 2.1) 34 1 ( 2.1) 35 2 ( 4.2) 36 1 ( 2.1) 37 1 ( 2.1) 38 1 ( 2.1) 39 1 ( 2.1) 40 1 ( 2.1) 41 1 ( 2.1) 42 1 ( 2.1) 43 1 ( 2.1) 44 1 ( 2.1) 45 1 ( 2.1) 46 1 ( 2.1) 47 1 ( 2.1) log.CA19.9 (mean (SD)) 2.95 (0.81) CA19.9.group (mean (SD)) 0.21 (0.41) CEA (mean (SD)) 5.57 (16.28) log.CEA (mean (SD)) 0.99 (0.89) TNM (%) 1 2 ( 4.0) 2 5 (10.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) TNM.b (%) 1or2 7 (14.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) CCI (%) 0 3 ( 6.0) 1 16 (32.0) 2 15 (30.0) 3 12 (24.0) 4 3 ( 6.0) 6 1 ( 2.0) CCI.b (%) &gt;=4 4 ( 8.0) 0or1 19 (38.0) 2 15 (30.0) 3 12 (24.0) adc_decrease (mean (SD)) 20.67 (11.49) adc_5_decrease (mean (SD)) 11.00 (12.19) volume_change (mean (SD)) 24.50 (14.00) apt_1_mean (mean (SD)) 3.13 (3.70) apt_1_95p (mean (SD)) 3.07 (0.88) adc_1_mean (%) 1 ( 2.0) 100.3332748 1 ( 2.0) 100.7850723 1 ( 2.0) 101.1288986 1 ( 2.0) 106.94384 1 ( 2.0) 107.4796753 1 ( 2.0) 108.1219025 1 ( 2.0) 108.4807739 1 ( 2.0) 109.8269577 1 ( 2.0) 110.6593323 1 ( 2.0) 112.250946 1 ( 2.0) 112.6311264 1 ( 2.0) 113.6343842 1 ( 2.0) 114.5146027 1 ( 2.0) 116.6255951 1 ( 2.0) 116.9603348 1 ( 2.0) 119.7995605 1 ( 2.0) 121.1716843 1 ( 2.0) 123.4509964 1 ( 2.0) 123.5778046 1 ( 2.0) 125.6047516 1 ( 2.0) 125.8717575 1 ( 2.0) 127.4504852 1 ( 2.0) 128.1634064 1 ( 2.0) 128.2574005 1 ( 2.0) 128.8485718 1 ( 2.0) 129.5490875 1 ( 2.0) 129.7754059 1 ( 2.0) 130.4454651 1 ( 2.0) 131.0157623 1 ( 2.0) 131.2865448 1 ( 2.0) 133.0798645 1 ( 2.0) 134.7369385 1 ( 2.0) 137.2429199 1 ( 2.0) 137.4812317 1 ( 2.0) 138.7712097 1 ( 2.0) 139.8694763 1 ( 2.0) 140.6768646 1 ( 2.0) 142.7576294 1 ( 2.0) 144.4676361 1 ( 2.0) 144.8905334 1 ( 2.0) 146.3157654 1 ( 2.0) 149.0292358 1 ( 2.0) 152.9427185 1 ( 2.0) 154.0635529 1 ( 2.0) 154.9950104 1 ( 2.0) 82.6672821 1 ( 2.0) 89.37554932 1 ( 2.0) 99.98454285 1 ( 2.0) n/a 1 ( 2.0) adc_1_5p (mean (SD)) 85.03 (11.48) . # 하지만 치우친 [기울어진 분포]의 연속형변수는 [ median, IQR ]를 뽑아야한다. print(tobj, showAllLevels = T, nonnormal = c(&quot;CA19.9&quot;, &quot;CEA&quot;)) . level Overall n 50 Recur (%) 0 28 (56.0) 1 22 (44.0) local_6m (%) 0 27 (54.0) 1 23 (46.0) age (mean (SD)) 56.44 (12.60) sex (%) 0 17 (34.0) 1 33 (66.0) CA19.9 (%) 2 1 ( 2.1) 3 2 ( 4.2) 4 1 ( 2.1) 5 1 ( 2.1) 6 1 ( 2.1) 7 1 ( 2.1) 8 1 ( 2.1) 9 1 ( 2.1) 10 1 ( 2.1) 11 1 ( 2.1) 12 1 ( 2.1) 13 1 ( 2.1) 14 1 ( 2.1) 15 1 ( 2.1) 16 1 ( 2.1) 17 1 ( 2.1) 18 1 ( 2.1) 19 1 ( 2.1) 20 1 ( 2.1) 21 1 ( 2.1) 22 1 ( 2.1) 23 1 ( 2.1) 24 1 ( 2.1) 25 1 ( 2.1) 26 1 ( 2.1) 27 1 ( 2.1) 28 1 ( 2.1) 29 1 ( 2.1) 30 1 ( 2.1) 31 1 ( 2.1) 32 1 ( 2.1) 33 1 ( 2.1) 34 1 ( 2.1) 35 2 ( 4.2) 36 1 ( 2.1) 37 1 ( 2.1) 38 1 ( 2.1) 39 1 ( 2.1) 40 1 ( 2.1) 41 1 ( 2.1) 42 1 ( 2.1) 43 1 ( 2.1) 44 1 ( 2.1) 45 1 ( 2.1) 46 1 ( 2.1) 47 1 ( 2.1) log.CA19.9 (mean (SD)) 2.95 (0.81) CA19.9.group (mean (SD)) 0.21 (0.41) CEA (median [IQR]) 2.50 [1.45, 4.15] log.CEA (mean (SD)) 0.99 (0.89) TNM (%) 1 2 ( 4.0) 2 5 (10.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) TNM.b (%) 1or2 7 (14.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) CCI (%) 0 3 ( 6.0) 1 16 (32.0) 2 15 (30.0) 3 12 (24.0) 4 3 ( 6.0) 6 1 ( 2.0) CCI.b (%) &gt;=4 4 ( 8.0) 0or1 19 (38.0) 2 15 (30.0) 3 12 (24.0) adc_decrease (mean (SD)) 20.67 (11.49) adc_5_decrease (mean (SD)) 11.00 (12.19) volume_change (mean (SD)) 24.50 (14.00) apt_1_mean (mean (SD)) 3.13 (3.70) apt_1_95p (mean (SD)) 3.07 (0.88) adc_1_mean (%) 1 ( 2.0) 100.3332748 1 ( 2.0) 100.7850723 1 ( 2.0) 101.1288986 1 ( 2.0) 106.94384 1 ( 2.0) 107.4796753 1 ( 2.0) 108.1219025 1 ( 2.0) 108.4807739 1 ( 2.0) 109.8269577 1 ( 2.0) 110.6593323 1 ( 2.0) 112.250946 1 ( 2.0) 112.6311264 1 ( 2.0) 113.6343842 1 ( 2.0) 114.5146027 1 ( 2.0) 116.6255951 1 ( 2.0) 116.9603348 1 ( 2.0) 119.7995605 1 ( 2.0) 121.1716843 1 ( 2.0) 123.4509964 1 ( 2.0) 123.5778046 1 ( 2.0) 125.6047516 1 ( 2.0) 125.8717575 1 ( 2.0) 127.4504852 1 ( 2.0) 128.1634064 1 ( 2.0) 128.2574005 1 ( 2.0) 128.8485718 1 ( 2.0) 129.5490875 1 ( 2.0) 129.7754059 1 ( 2.0) 130.4454651 1 ( 2.0) 131.0157623 1 ( 2.0) 131.2865448 1 ( 2.0) 133.0798645 1 ( 2.0) 134.7369385 1 ( 2.0) 137.2429199 1 ( 2.0) 137.4812317 1 ( 2.0) 138.7712097 1 ( 2.0) 139.8694763 1 ( 2.0) 140.6768646 1 ( 2.0) 142.7576294 1 ( 2.0) 144.4676361 1 ( 2.0) 144.8905334 1 ( 2.0) 146.3157654 1 ( 2.0) 149.0292358 1 ( 2.0) 152.9427185 1 ( 2.0) 154.0635529 1 ( 2.0) 154.9950104 1 ( 2.0) 82.6672821 1 ( 2.0) 89.37554932 1 ( 2.0) 99.98454285 1 ( 2.0) n/a 1 ( 2.0) adc_1_5p (mean (SD)) 85.03 (11.48) . ?CreateTableOne . # createtableone에서 strata에 그룹을 나눈 칼럼명 options(width = 300) tobj2&lt;-CreateTableOne(vars = var1, data=dat1, strata=&quot;CA19.9.group&quot;) print(tobj2) . Warning message in ModuleReturnVarsExist(vars, data): &#34;The data frame does not have: RFS Dropped&#34; . Stratified by CA19.9.group 0 1 p test n 38 10 Recur = 1 (%) 15 (39.5) 7 (70.0) 0.172 local_6m = 1 (%) 20 (52.6) 3 (30.0) 0.358 age (mean (SD)) 56.34 (12.56) 58.80 (13.62) 0.591 sex = 1 (%) 24 (63.2) 9 (90.0) 0.213 CA19.9 (%) 0.352 2 1 ( 2.6) 0 ( 0.0) 3 2 ( 5.3) 0 ( 0.0) 4 1 ( 2.6) 0 ( 0.0) 5 1 ( 2.6) 0 ( 0.0) 6 1 ( 2.6) 0 ( 0.0) 7 1 ( 2.6) 0 ( 0.0) 8 1 ( 2.6) 0 ( 0.0) 9 1 ( 2.6) 0 ( 0.0) 10 1 ( 2.6) 0 ( 0.0) 11 1 ( 2.6) 0 ( 0.0) 12 1 ( 2.6) 0 ( 0.0) 13 1 ( 2.6) 0 ( 0.0) 14 1 ( 2.6) 0 ( 0.0) 15 1 ( 2.6) 0 ( 0.0) 16 1 ( 2.6) 0 ( 0.0) 17 1 ( 2.6) 0 ( 0.0) 18 1 ( 2.6) 0 ( 0.0) 19 1 ( 2.6) 0 ( 0.0) 20 1 ( 2.6) 0 ( 0.0) 21 1 ( 2.6) 0 ( 0.0) 22 1 ( 2.6) 0 ( 0.0) 23 1 ( 2.6) 0 ( 0.0) 24 1 ( 2.6) 0 ( 0.0) 25 1 ( 2.6) 0 ( 0.0) 26 1 ( 2.6) 0 ( 0.0) 27 1 ( 2.6) 0 ( 0.0) 28 1 ( 2.6) 0 ( 0.0) 29 1 ( 2.6) 0 ( 0.0) 30 1 ( 2.6) 0 ( 0.0) 31 1 ( 2.6) 0 ( 0.0) 32 1 ( 2.6) 0 ( 0.0) 33 1 ( 2.6) 0 ( 0.0) 34 1 ( 2.6) 0 ( 0.0) 35 2 ( 5.3) 0 ( 0.0) 36 1 ( 2.6) 0 ( 0.0) 37 1 ( 2.6) 0 ( 0.0) 38 0 ( 0.0) 1 (10.0) 39 0 ( 0.0) 1 (10.0) 40 0 ( 0.0) 1 (10.0) 41 0 ( 0.0) 1 (10.0) 42 0 ( 0.0) 1 (10.0) 43 0 ( 0.0) 1 (10.0) 44 0 ( 0.0) 1 (10.0) 45 0 ( 0.0) 1 (10.0) 46 0 ( 0.0) 1 (10.0) 47 0 ( 0.0) 1 (10.0) log.CA19.9 (mean (SD)) 2.74 (0.79) 3.75 (0.07) &lt;0.001 CA19.9.group (mean (SD)) 0.00 (0.00) 1.00 (0.00) &lt;0.001 CEA (mean (SD)) 6.13 (18.55) 4.15 (4.59) 0.740 log.CEA (mean (SD)) 0.99 (0.90) 1.03 (0.93) 0.926 TNM (%) 0.308 1 1 ( 2.6) 1 (10.0) 2 3 ( 7.9) 1 (10.0) 3 11 (28.9) 1 (10.0) 4 17 (44.7) 7 (70.0) 5 6 (15.8) 0 ( 0.0) TNM.b (%) 0.231 1or2 4 (10.5) 2 (20.0) 3 11 (28.9) 1 (10.0) 4 17 (44.7) 7 (70.0) 5 6 (15.8) 0 ( 0.0) CCI (%) 0.304 0 1 ( 2.6) 2 (20.0) 1 13 (34.2) 2 (20.0) 2 10 (26.3) 4 (40.0) 3 10 (26.3) 2 (20.0) 4 3 ( 7.9) 0 ( 0.0) 6 1 ( 2.6) 0 ( 0.0) CCI.b (%) 0.635 &gt;=4 4 (10.5) 0 ( 0.0) 0or1 14 (36.8) 4 (40.0) 2 10 (26.3) 4 (40.0) 3 10 (26.3) 2 (20.0) adc_decrease (mean (SD)) 20.83 (11.55) 21.60 (11.41) 0.853 adc_5_decrease (mean (SD)) 11.24 (11.82) 10.80 (14.62) 0.922 volume_change (mean (SD)) 22.58 (13.56) 32.00 (13.00) 0.056 apt_1_mean (mean (SD)) 3.19 (4.20) 3.08 (1.23) 0.935 apt_1_95p (mean (SD)) 2.96 (0.75) 3.54 (1.25) 0.064 adc_1_mean (%) NaN 1 ( 2.6) 0 ( 0.0) 100.3332748 1 ( 2.6) 0 ( 0.0) 100.7850723 1 ( 2.6) 0 ( 0.0) 101.1288986 1 ( 2.6) 0 ( 0.0) 106.94384 0 ( 0.0) 1 (10.0) 107.4796753 1 ( 2.6) 0 ( 0.0) 108.1219025 0 ( 0.0) 1 (10.0) 108.4807739 1 ( 2.6) 0 ( 0.0) 109.8269577 0 ( 0.0) 0 ( 0.0) 110.6593323 1 ( 2.6) 0 ( 0.0) 112.250946 0 ( 0.0) 1 (10.0) 112.6311264 1 ( 2.6) 0 ( 0.0) 113.6343842 1 ( 2.6) 0 ( 0.0) 114.5146027 0 ( 0.0) 1 (10.0) 116.6255951 1 ( 2.6) 0 ( 0.0) 116.9603348 1 ( 2.6) 0 ( 0.0) 119.7995605 1 ( 2.6) 0 ( 0.0) 121.1716843 1 ( 2.6) 0 ( 0.0) 123.4509964 1 ( 2.6) 0 ( 0.0) 123.5778046 1 ( 2.6) 0 ( 0.0) 125.6047516 1 ( 2.6) 0 ( 0.0) 125.8717575 1 ( 2.6) 0 ( 0.0) 127.4504852 1 ( 2.6) 0 ( 0.0) 128.1634064 1 ( 2.6) 0 ( 0.0) 128.2574005 0 ( 0.0) 1 (10.0) 128.8485718 0 ( 0.0) 0 ( 0.0) 129.5490875 1 ( 2.6) 0 ( 0.0) 129.7754059 1 ( 2.6) 0 ( 0.0) 130.4454651 1 ( 2.6) 0 ( 0.0) 131.0157623 1 ( 2.6) 0 ( 0.0) 131.2865448 1 ( 2.6) 0 ( 0.0) 133.0798645 1 ( 2.6) 0 ( 0.0) 134.7369385 1 ( 2.6) 0 ( 0.0) 137.2429199 1 ( 2.6) 0 ( 0.0) 137.4812317 1 ( 2.6) 0 ( 0.0) 138.7712097 1 ( 2.6) 0 ( 0.0) 139.8694763 0 ( 0.0) 1 (10.0) 140.6768646 1 ( 2.6) 0 ( 0.0) 142.7576294 1 ( 2.6) 0 ( 0.0) 144.4676361 0 ( 0.0) 1 (10.0) 144.8905334 1 ( 2.6) 0 ( 0.0) 146.3157654 0 ( 0.0) 1 (10.0) 149.0292358 0 ( 0.0) 1 (10.0) 152.9427185 1 ( 2.6) 0 ( 0.0) 154.0635529 1 ( 2.6) 0 ( 0.0) 154.9950104 0 ( 0.0) 1 (10.0) 82.6672821 1 ( 2.6) 0 ( 0.0) 89.37554932 1 ( 2.6) 0 ( 0.0) 99.98454285 1 ( 2.6) 0 ( 0.0) n/a 1 ( 2.6) 0 ( 0.0) adc_1_5p (mean (SD)) 84.85 (11.42) 84.70 (12.29) 0.972 .",
            "url": "blog.chojaeseong.com/r/%EC%9D%98%ED%95%99%EC%97%B0%EA%B5%AC%EB%B0%A9%EB%B2%95%EB%A1%A0/%ED%86%B5%EA%B3%84/2022/03/12/00-%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%81%B4%EB%A6%AC%EB%8B%9D,-tableone-%ED%8A%B9%EA%B0%95-(22-03-05)(%EC%99%84).html",
            "relUrl": "/r/%EC%9D%98%ED%95%99%EC%97%B0%EA%B5%AC%EB%B0%A9%EB%B2%95%EB%A1%A0/%ED%86%B5%EA%B3%84/2022/03/12/00-%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%81%B4%EB%A6%AC%EB%8B%9D,-tableone-%ED%8A%B9%EA%B0%95-(22-03-05)(%EC%99%84).html",
            "date": " • Mar 12, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "EnumMap으로 카운팅(로또결과)",
            "content": "EnumMap . Enum List -&gt; EnumMap에 카운팅 . List&lt;객체&gt;의 갯수를 객체를 key로 하는 hashMap Map&lt;객체, Integer&gt; 에 세야한다. | . 빈 Map 선언 및 초기화 . 객체의 Count을 원한다면 **&lt;객체key, Integer&gt;로 Map을 선언한다. ** (cf) 원시적으로는 직접 0으로 초기화 한다.) . EnumMap이라면 ( )생성자에 안에 Enum클래스.class(클래스 자체)를 지정해준다. | . final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); . 참고) . (원시적) 모든 객체key들 stream화해서 돌면서 -&gt; forEach -&gt; map.put(객체key, 0)으로 초기화해준다. . private final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); { Arrays.stream(Rank.values()).forEach(rank -&gt; result.put(rank, 0)); } . | . | EnumMap는 넣고난 뒤, 자동정렬되어있지만 . 일반map넣고 난 뒤, key순으로 정렬되어야하면(순서가 중요하면) hashMap대신 -&gt; linkedHashMap을 사용한다. | . private final LinkedHashMap&lt;Rank, Integer&gt; value = new LinkedHashMap&lt;&gt;(); . | . | 일급vs단일 로직을 먼저 수행한 -&gt; 응답결과List를 카운팅하는 3가지 방법 . 이제 갯수를 셀 결과값List(Enum List or 객체 List)들을 돌면서 카운팅한다. . 결과List(객체List)를 먼저 계산 -&gt; 돌면서 -&gt; . 이미 0으로 초기화해놓고 넣어놨어야한다. | map.put( 객체Key, map.get( 객체key )의 value + 1 ) | . { Arrays.stream(Rank.values()).forEach(rank -&gt; result.put(rank, 0)); } . result.put(rankPrize, result.getOrDefault(rankPrize, 0) + 1); . | 결과List(객체List)를 먼저 계산 -&gt; 돌면서 -&gt; . 미리 0 초기화 없이 알아서 직전value(없으면 0부터) 누적해주는 -&gt; map.merge( 객체key, 누적해넣을값, Integer.sum()으로 기존value와 누적방법 Bifunction ) | . result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after)) . final List&lt;Rank&gt; results = lottos.stream() .map(lotto -&gt; match(lotto, winningLotto)) .collect(Collectors.toList()); final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); results .forEach(rank -&gt; result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after))); . 결과값을 찍어보니 merge로 카운팅이 1개씩 잘 된다. | . | | EnumMap은 아니지만, 일급vs단일 –stream–&gt; 단일vs단일 결과값(객체key)을 뽑아낼 로직 + 카운팅을 동시에 해주는 일급.stream().collect(Collectors.groupingBy( 객체key를 뽑아낼 로직 , summingInt( value -&gt; 1) ) . 결과값List를 뽑는 로직 조차 일급.stream -&gt; 단일vs단일로 객체Key뽑기로직이 내부에 포함됨 . 결과값List를 미리 뽑지 않는다. -&gt; Collectors.groupingBy( , )의 **첫번째 인자에 ** | . // (1)결과값 List를 미리 뽑는 과정 -&gt; 생략됨. //final List&lt;Rank&gt; results = lottos.stream() // .map(lotto -&gt; match(lotto, winningLotto)) // .collect(Collectors.toList()); // (2) map을 미리 선언해두기 -&gt; 생략됨 //final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); // (3) 결과값List를 돌면서 -&gt; merge로 1씩 카운팅 -&gt; 생략됨 //results.stream() // .forEach(rank -&gt; result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after))); // 일급을 돌면서 -&gt; groupingBy(단일vs단일의 [결과값 = 객체key]를 뽑는 로직 , 1씩 누적합하는 로직) return lottos.stream() .collect(Collectors.groupingBy( lotto -&gt; match(lotto, winningLotto), Collectors.summingInt(value -&gt; 1))); . | groupingBy의 가운데 인자에 EnumMap.class를 줄 수 있다. . final EnumMap&lt;GameResult, Integer&gt; dealerResult = gamblers.stream() .collect(Collectors.groupingBy( gambler -&gt; getResultPlayer(dealer, gamblerResult, gambler), () -&gt; new EnumMap&lt;&gt;(GameResult.class), // Map타입 가운데서 지정 Collectors.summingInt(count -&gt; 1) )); .",
            "url": "blog.chojaeseong.com/java/enummap/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/11/EnumMap.html",
            "relUrl": "/java/enummap/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/11/EnumMap.html",
            "date": " • Mar 11, 2022"
        }
        
    
  
    
        ,"post8": {
            "title": "01-Basics and R environment",
            "content": "강의주소:https://lms.knou.ac.kr/dks/user/home/initUSTHomeIndex_GRSC.do?stLeftMenuId=0 | 선배블로그: https://insb.tistory.com/9?category=967351 작년 김성수 교수 강의로 진행 | . | . &#44592;&#48376; . R &#49548;&#44060; . 무료 | 대화형 프로그램 언어 | 객체지향 시스템 데이터, 변수, 행렬 등은 모두 객체 | 생성은 = or &lt;-로 생성 | . | . . x = 2:10 x . &lt;ol class=list-inline&gt; 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | &lt;/ol&gt; y &lt;- 3*x + 5 y . &lt;ol class=list-inline&gt; 11 | 14 | 17 | 20 | 23 | 26 | 29 | 32 | 35 | &lt;/ol&gt; a &lt;- 3:9 b &lt;- 3*a + 5 plot(a, b) . plot(a, b, pch=18) . R&#51032; &#50669;&#49324; . . 1980년대 S 언어 탄생 by AT&amp;T Bell Lab(c언어 개발한 연구소)에서 통계언어 S를 구현함 . 1998 ACM S/W 상을 John Chambers가 탐 &quot;Forever altered how people analyze, visualize and manipulate data 사람들이 어떻게 데이터 분석, 시각화, 다루는지를 영원히 바꾼 언어다 | . | . | 오클란드 대학의 Ross and Robert 교수 2명이 S 축소버전인 R &amp; R을 만듦 . | 1995년 Martin Maechler(마틴 매흘러)가 R&amp;R(이하카, 젠틀만)을 설득하여, linux처럼 오픈소스(GPL)로 쓰게 한 것인 R source code 발표 . | 1997년 8월 R core team 결성. 2000년 02월 29일 R version 1.0.0 발표 . 12월 R version 3.2.3 | | . | R &#45796;&#50868;&#48155;&#44592; . . base버전으로 다운 받기 | . &#51089;&#50629;&#50689;&#50669; &#51648;&#51221; . . getwd() . &#39;C:/Users/cho_desktop/2022_RProjects/대학원/1-01 데이터분석방법론 1&#39; setwd(&quot;.&quot;) . setwd( choose.dir() ) . Error in setwd(choose.dir()): missing value is invalid Traceback: 1. setwd(choose.dir()) . R studio &#49548;&#44060; . rsutdio.com | . R Commander &#49548;&#44060; . 메뉴 방식으로 처리된 R 패키지/ John fox가 개발 | . . &#44368;&#51116; . First step . install.packages(&quot;ISwR&quot;) . package &#39;ISwR&#39; successfully unpacked and MD5 sums checked The downloaded binary packages are in C: Users cho_desktop AppData Local Temp Rtmpo5uUeT downloaded_packages . library(ISwR) . Warning message: &#34;package &#39;ISwR&#39; was built under R version 3.6.3&#34; . plot( rnorm(1000), pch = 19) . 1.1.3 &#48289;&#53552;&#50672;&#49328; . weight &lt;- c(60, 72, 57, 90, 95, 72) height &lt;- c(1.75, 1.80, 1.65, 1.90, 1.74, 1.91) bmi &lt;- weight/height^2 . bmi . &lt;ol class=list-inline&gt; 19.5918367346939 | 22.2222222222222 | 20.9366391184573 | 24.9307479224377 | 31.3779891663364 | 19.7363010882377 | &lt;/ol&gt; . # 벡터c의 갯수 -&gt; length( ) xbar &lt;- sum(weight) / length(weight) xbar . 74.3333333333333 mean(weight) . 74.3333333333333 sqrt(sum((weight-xbar)^2) / (length(weight) - 1)) . 15.4229266569827 sd(weight) . 15.4229266569827 1.1.4 standard procedures . bmi . &lt;ol class=list-inline&gt; 19.5918367346939 | 22.2222222222222 | 20.9366391184573 | 24.9307479224377 | 31.3779891663364 | 19.7363010882377 | &lt;/ol&gt; t.test(bmi, mu=22.5) # H0: mu=22.5 / H1: mu!=22.5 # t값 , 자유도, p값 . One Sample t-test data: bmi t = 0.34488, df = 5, p-value = 0.7442 alternative hypothesis: true mean is not equal to 22.5 95 percent confidence interval: 18.41734 27.84791 sample estimates: mean of x 23.13262 . 1.1.5 Graph . . # color=&quot;대or소문자&quot; 대신 col=2번호를 줘도 된다. like pch=숫자 plot(height, weight, pch=2, col=&quot;RED&quot;) . # c벡터객체 1개 만들고 hh &lt;- c(1.65, 1.70, 1.75, 1.80, 1.85, 1.90) # lines로 선 그리기 lines(hh, 22.5*hh^2, col=&quot;BLUE&quot;, lty=2) # lty = line type -&gt; 2번은 점점점 타입 . Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet Traceback: 1. lines(hh, 22.5 * hh^2, col = &#34;BLUE&#34;, lty = 2) 2. lines.default(hh, 22.5 * hh^2, col = &#34;BLUE&#34;, lty = 2) 3. plot.xy(xy.coords(x, y), type = type, ...) . plot(height, weight, pch=2, col=&quot;RED&quot;) hh &lt;- c(1.65, 1.70, 1.75, 1.80, 1.85, 1.90) lines(hh, 22.5*hh^2, col=&quot;BLUE&quot;, lty=2) . 1.2 R languange essentials . # - 작따-&gt;큰따로 변환되서 표기된다. # - 여기선 큰따-&gt; 작따로 표기되네..like python c(&quot;Huey&quot;, &quot;Dewey&quot;, &quot;Louie&quot;) . &lt;ol class=list-inline&gt; &#39;Huey&#39; | &#39;Dewey&#39; | &#39;Louie&#39; | &lt;/ol&gt; c(&#39;Huey&#39;, &#39;Dewey&#39;, &#39;Louie&#39;) . &lt;ol class=list-inline&gt; &#39;Huey&#39; | &#39;Dewey&#39; | &#39;Louie&#39; | &lt;/ol&gt; c(T, T, F, T) . &lt;ol class=list-inline&gt; TRUE | TRUE | FALSE | TRUE | &lt;/ol&gt; bmi . &lt;ol class=list-inline&gt; 19.5918367346939 | 22.2222222222222 | 20.9366391184573 | 24.9307479224377 | 31.3779891663364 | 19.7363010882377 | &lt;/ol&gt; # 벡터 + 조건식 -&gt; 마스크가 된다. bmi &gt; 25 . &lt;ol class=list-inline&gt; FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | &lt;/ol&gt; cat( c(&quot;Huey&quot;, &quot;Dewey&quot;, &quot;Louie&quot;) ) . Huey Dewey Louie . cat( c(&quot;Huey&quot;, &quot;Dewey&quot;, &quot;Louie&quot;, &quot; n&quot;) ) . Huey Dewey Louie . . cat(&quot;What is &quot;R &quot;? n&quot;) . What is &#34;R&#34;? . &#50696;&#51228; &#52280;&#44256;&#51088;&#47308; &#49324;&#51060;&#53944; . 예제 파일을 들고 있는 블로그: https://booolean.tistory.com/913?category=807312 | . 1.2.5 Missing Value . R에서는 결측치를 NA로 표시한다. | . . wd &lt;- read.table(&quot;./data//01/wd.txt&quot;, sep = &quot; t&quot;, header=T) # &quot;./따옴표경로&quot; , sep=&quot;구분자&quot; , header=T (첫줄이 타이틀) wd . M1M2M3M4M5Y . 0.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 0.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 0.606 | 0.1273 | 0.494 | 0.522 | 0.920 | 0.570 | . 0.437 | 0.1591 | 0.446 | 0.423 | 0.992 | 0.450 | . 0.547 | 0.1135 | 0.531 | 0.519 | 0.915 | 0.548 | . 0.444 | 0.1628 | 0.429 | 0.411 | 0.984 | 0.431 | . 0.489 | 0.1231 | 0.562 | 0.455 | 0.824 | 0.401 | . 0.536 | 0.1473 | 0.410 | 0.430 | 0.978 | 0.423 | . 0.413 | 0.1182 | 0.592 | 0.464 | 0.854 | 0.475 | . 0.685 | 0.1564 | 0.631 | 0.564 | 0.914 | 0.486 | . 0.664 | 0.1588 | 0.506 | 0.481 | 0.867 | 0.554 | . 0.703 | 0.1335 | 0.519 | 0.484 | 0.812 | 0.519 | . 0.653 | 0.1395 | 0.625 | 0.519 | 0.892 | 0.492 | . 0.586 | 0.1114 | 0.505 | 0.565 | 0.889 | 0.517 | . 0.534 | 0.1143 | 0.521 | 0.571 | 0.889 | 0.502 | . 0.523 | 0.1320 | 0.508 | 0.412 | 0.919 | 0.508 | . 0.580 | 0.1249 | 0.546 | 0.608 | 0.954 | 0.520 | . 0.448 | 0.1028 | 0.522 | 0.534 | 0.918 | 0.506 | . 0.417 | 0.1684 | 0.405 | 0.415 | 0.981 | 0.401 | . 0.528 | 0.1057 | 0.424 | 0.566 | 0.909 | 0.568 | . nwd = wd nwd . M1M2M3M4M5Y . 0.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 0.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 0.606 | 0.1273 | 0.494 | 0.522 | 0.920 | 0.570 | . 0.437 | 0.1591 | 0.446 | 0.423 | 0.992 | 0.450 | . 0.547 | 0.1135 | 0.531 | 0.519 | 0.915 | 0.548 | . 0.444 | 0.1628 | 0.429 | 0.411 | 0.984 | 0.431 | . 0.489 | 0.1231 | 0.562 | 0.455 | 0.824 | 0.401 | . 0.536 | 0.1473 | 0.410 | 0.430 | 0.978 | 0.423 | . 0.413 | 0.1182 | 0.592 | 0.464 | 0.854 | 0.475 | . 0.685 | 0.1564 | 0.631 | 0.564 | 0.914 | 0.486 | . 0.664 | 0.1588 | 0.506 | 0.481 | 0.867 | 0.554 | . 0.703 | 0.1335 | 0.519 | 0.484 | 0.812 | 0.519 | . 0.653 | 0.1395 | 0.625 | 0.519 | 0.892 | 0.492 | . 0.586 | 0.1114 | 0.505 | 0.565 | 0.889 | 0.517 | . 0.534 | 0.1143 | 0.521 | 0.571 | 0.889 | 0.502 | . 0.523 | 0.1320 | 0.508 | 0.412 | 0.919 | 0.508 | . 0.580 | 0.1249 | 0.546 | 0.608 | 0.954 | 0.520 | . 0.448 | 0.1028 | 0.522 | 0.534 | 0.918 | 0.506 | . 0.417 | 0.1684 | 0.405 | 0.415 | 0.981 | 0.401 | . 0.528 | 0.1057 | 0.424 | 0.566 | 0.909 | 0.568 | . nwd[ nwd &gt; 0.9 ] = 99 . head(nwd) . M1M2M3M4M5Y . 0.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 0.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 0.606 | 0.1273 | 0.494 | 0.522 | 99.000 | 0.570 | . 0.437 | 0.1591 | 0.446 | 0.423 | 99.000 | 0.450 | . 0.547 | 0.1135 | 0.531 | 0.519 | 99.000 | 0.548 | . 0.444 | 0.1628 | 0.429 | 0.411 | 99.000 | 0.431 | . nwd[nwd == 99] = NA head(nwd) . M1M2M3M4M5Y . 0.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 0.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 0.606 | 0.1273 | 0.494 | 0.522 | NA | 0.570 | . 0.437 | 0.1591 | 0.446 | 0.423 | NA | 0.450 | . 0.547 | 0.1135 | 0.531 | 0.519 | NA | 0.548 | . 0.444 | 0.1628 | 0.429 | 0.411 | NA | 0.431 | . # is.na()는 데이터객체 전체에 대한 boolean mask(logical character)를 만든다. -&gt; 행렬mask -&gt; 행 or 열별로 접근해줘야한다. is.na(nwd) . M1M2M3M4M5Y . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . rowSums( is.na(nwd) ) . &lt;ol class=list-inline&gt; 0 | 0 | 1 | 1 | 1 | 1 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | &lt;/ol&gt; colSums( is.na(nwd) ) . &lt;dl class=dl-horizontal&gt; M1 0 M2 0 M3 0 M4 0 M5 11 Y 0 &lt;/dl&gt; # -&gt; 행별로 제거하는 듯 싶다. # -&gt; na.omit()의 결과 &lt;기존 행번호&gt;가 같이 찍히니 확인하면 된다. na.omit(nwd) . M1M2M3M4M5Y . 10.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 20.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 70.489 | 0.1231 | 0.562 | 0.455 | 0.824 | 0.401 | . 90.413 | 0.1182 | 0.592 | 0.464 | 0.854 | 0.475 | . 110.664 | 0.1588 | 0.506 | 0.481 | 0.867 | 0.554 | . 120.703 | 0.1335 | 0.519 | 0.484 | 0.812 | 0.519 | . 130.653 | 0.1395 | 0.625 | 0.519 | 0.892 | 0.492 | . 140.586 | 0.1114 | 0.505 | 0.565 | 0.889 | 0.517 | . 150.534 | 0.1143 | 0.521 | 0.571 | 0.889 | 0.502 | . nwd . M1M2M3M4M5Y . 0.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 0.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 0.606 | 0.1273 | 0.494 | 0.522 | NA | 0.570 | . 0.437 | 0.1591 | 0.446 | 0.423 | NA | 0.450 | . 0.547 | 0.1135 | 0.531 | 0.519 | NA | 0.548 | . 0.444 | 0.1628 | 0.429 | 0.411 | NA | 0.431 | . 0.489 | 0.1231 | 0.562 | 0.455 | 0.824 | 0.401 | . 0.536 | 0.1473 | 0.410 | 0.430 | NA | 0.423 | . 0.413 | 0.1182 | 0.592 | 0.464 | 0.854 | 0.475 | . 0.685 | 0.1564 | 0.631 | 0.564 | NA | 0.486 | . 0.664 | 0.1588 | 0.506 | 0.481 | 0.867 | 0.554 | . 0.703 | 0.1335 | 0.519 | 0.484 | 0.812 | 0.519 | . 0.653 | 0.1395 | 0.625 | 0.519 | 0.892 | 0.492 | . 0.586 | 0.1114 | 0.505 | 0.565 | 0.889 | 0.517 | . 0.534 | 0.1143 | 0.521 | 0.571 | 0.889 | 0.502 | . 0.523 | 0.1320 | 0.508 | 0.412 | NA | 0.508 | . 0.580 | 0.1249 | 0.546 | 0.608 | NA | 0.520 | . 0.448 | 0.1028 | 0.522 | 0.534 | NA | 0.506 | . 0.417 | 0.1684 | 0.405 | 0.415 | NA | 0.401 | . 0.528 | 0.1057 | 0.424 | 0.566 | NA | 0.568 | . 1.2.6 Functions that create vectors . x &lt;- c(1,2,3) y &lt;- c(10, 20) c(x, y, 5) # 벡터객체와 값이 동등하게 1차원으로 연결된다. . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 10 | 20 | 5 | &lt;/ol&gt; # boolean + 숫자 -&gt; 숫자로 type 0/1로 바뀌어서 type통일 c(FALSE, 3) . &lt;ol class=list-inline&gt; 0 | 3 | &lt;/ol&gt; c(FALSE, &quot;abc&quot;) . &lt;ol class=list-inline&gt; &#39;FALSE&#39; | &#39;abc&#39; | &lt;/ol&gt; c(pi, &quot;abc&quot;) . &lt;ol class=list-inline&gt; &#39;3.14159265358979&#39; | &#39;abc&#39; | &lt;/ol&gt; seq(4, 9) . &lt;ol class=list-inline&gt; 4 | 5 | 6 | 7 | 8 | 9 | &lt;/ol&gt; oops &lt;- c(7, 9, 13) . rep(oops, 3) . &lt;ol class=list-inline&gt; 7 | 9 | 13 | 7 | 9 | 13 | 7 | 9 | 13 | &lt;/ol&gt; # - index순서대로 1번, 2번, 3번 반복복사 # - index별 반복회수도 벡터로 제공하면 된다. rep(oops, c(1,2,3)) . &lt;ol class=list-inline&gt; 7 | 9 | 9 | 13 | 13 | 13 | &lt;/ol&gt; rep(oops, 1:3) . &lt;ol class=list-inline&gt; 7 | 9 | 9 | 13 | 13 | 13 | &lt;/ol&gt; rep(1:2, c(10, 15)) . &lt;ol class=list-inline&gt; 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | &lt;/ol&gt; 1.2.7 Matrices and arrays . x &lt;- 1:12 x . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | &lt;/ol&gt; # 행렬이 된다. dim(x) = c(3, 4) x # 보이진 않지만, 1, 2, 3, 행 ,1 ,2 ,3 ,4 렬이 된다. . 1 | 4 | 7 | 10 | . 2 | 5 | 8 | 11 | . 3 | 6 | 9 | 12 | . # - 특히 byrow=를 T루로 주면, ncol없이 알아서 된다. matrix(1:12, nrow=3, byrow=T) . 1 | 2 | 3 | 4 | . 5 | 6 | 7 | 8 | . 9 | 10 | 11 | 12 | . LETTERS[1:3] . &lt;ol class=list-inline&gt; &#39;A&#39; | &#39;B&#39; | &#39;C&#39; | &lt;/ol&gt; rownames(x) &lt;- LETTERS[1:3] . x . A1 | 4 | 7 | 10 | . B2 | 5 | 8 | 11 | . C3 | 6 | 9 | 12 | . t(x) . ABC . 1 | 2 | 3 | . 4 | 5 | 6 | . 7 | 8 | 9 | . 10 | 11 | 12 | . # 1차원들을 -&gt; 눕혀서 행으로 더하는 rbind cbind(A = 1:4) . A . 1 | . 2 | . 3 | . 4 | . cbind(A = 1:4, B = 5:6, C = 9:12) . ABC . 1 | 5 | 9 | . 2 | 6 | 10 | . 3 | 5 | 11 | . 4 | 6 | 12 | . rbind(A=1:4,B=5:8,C=9:12) . A1 | 2 | 3 | 4 | . B5 | 6 | 7 | 8 | . C9 | 10 | 11 | 12 | . aa &lt;- cbind(A=1:4,B=5:8,C=9:12) aa . ABC . 1 | 5 | 9 | . 2 | 6 | 10 | . 3 | 7 | 11 | . 4 | 8 | 12 | . # - 좌or우 똑같은 크기의 상수를 붙이려면 상수로 bind하면 된다. cbind(1, aa) . ABC . 1 | 1 | 5 | 9 | . 1 | 2 | 6 | 10 | . 1 | 3 | 7 | 11 | . 1 | 4 | 8 | 12 | . factors(&#48276;&#51452;&#54805; &#51088;&#47308;) . 카테고리칼 변수는 인자로 만들어주는게 중요하다. 그 때 쓰는 것이 factor() | . pain &lt;- c(0, 3, 2, 2, 1) . # -&gt; levels=에는 [요인들과 동일한 값]으로 레벨을 정해서 매칭해놓는다. # -&gt; 연속적인 숫자벡터를 줬어도 &#39;0&#39;~&#39;3&#39;의 문자열로 정해진다. # -&gt; 매칭된 요인-레벨에 대해서, 레벨이름levels을 바꿔주면 요인들도 따라 바뀐다. fpain &lt;- factor(pain, levels = 0:3) fpain . &lt;ol class=list-inline&gt; 0 | 3 | 2 | 2 | 1 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;0&#39; | &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &lt;/ol&gt; # -&gt; 원본 값들이 레벨에 따른 해당 [라벨]로 바껴버린다. levels(fpain) &lt;- c(&quot;none&quot;, &quot;mild&quot;, &quot;medium&quot;, &quot;severe&quot;) fpain . &lt;ol class=list-inline&gt; none | severe | medium | medium | mild | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;none&#39; | &#39;mild&#39; | &#39;medium&#39; | &#39;severe&#39; | &lt;/ol&gt; &#49707;&#51088; -&gt; &#46972;&#48296; by&#50836;&#51064;&#45934; &#48148;&#44984;&#44592; . 변수 job, edu를 숫자 -&gt; 라벨(요인)으로 바꿔보자. . insurance = read.table(&quot;./data/01//insurance.txt&quot;, sep = &quot; t&quot;, header=T) . head(insurance) . idsexjobreligioneduamountsalary . 1 | m | 1 | 1 | 3 | 7.0 | 110 | . 2 | m | 2 | 1 | 4 | 12.0 | 135 | . 3 | f | 2 | 3 | 5 | 8.5 | 127 | . 4 | f | 3 | 3 | 5 | 5.0 | 150 | . 5 | m | 1 | 3 | 3 | 4.5 | 113 | . 6 | m | 2 | 1 | 2 | 3.5 | 95 | . insurance$job . &lt;ol class=list-inline&gt; 1 | 2 | 2 | 3 | 1 | 2 | 3 | 3 | 2 | 1 | 1 | 2 | 3 | 3 | -9 | 1 | 1 | 2 | 2 | 3 | 3 | 3 | &lt;/ol&gt; insurance = read.table(&quot;./data/01//insurance.txt&quot;, sep = &quot; t&quot;, header=T, na.strings = &quot;-9&quot;) . insurance$job . &lt;ol class=list-inline&gt; 1 | 2 | 2 | 3 | 1 | 2 | 3 | 3 | 2 | 1 | 1 | 2 | 3 | 3 | &lt;NA&gt; | 1 | 1 | 2 | 2 | 3 | 3 | 3 | &lt;/ol&gt; # (3) 덮어쓸 labels도 순서대로 동시에 준다. insurance$job &lt;- factor(insurance$job, levels = 1:3, labels = c(&quot;근로자&quot;, &quot;사무직&quot;, &quot;전문가&quot;) ) . insurance$job . &lt;ol class=list-inline&gt; 근로자 | 사무직 | 사무직 | 전문가 | 근로자 | 사무직 | 전문가 | 전문가 | 사무직 | 근로자 | 근로자 | 사무직 | 전문가 | 전문가 | &lt;NA&gt; | 근로자 | 근로자 | 사무직 | 사무직 | 전문가 | 전문가 | 전문가 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;근로자&#39; | &#39;사무직&#39; | &#39;전문가&#39; | &lt;/ol&gt; head(insurance) . idsexjobreligioneduamountsalary . 1 | m | 근로자 | 1 | 3 | 7.0 | 110 | . 2 | m | 사무직 | 1 | 4 | 12.0 | 135 | . 3 | f | 사무직 | 3 | 5 | 8.5 | 127 | . 4 | f | 전문가 | 3 | 5 | 5.0 | 150 | . 5 | m | 근로자 | 3 | 3 | 4.5 | 113 | . 6 | m | 사무직 | 1 | 2 | 3.5 | 95 | . insurance$edu2 &lt;- factor(insurance$edu, levels = 1:5, labels = c(&quot;무학&quot;, &quot;국졸&quot;, &quot;중졸&quot;, &quot;고졸&quot;, &quot;대졸&quot;) ) . insurance . idsexjobreligioneduamountsalaryedu2 . 1 | m | 근로자 | 1 | 3 | 7.0 | 110 | 중졸 | . 2 | m | 사무직 | 1 | 4 | 12.0 | 135 | 고졸 | . 3 | f | 사무직 | 3 | 5 | 8.5 | 127 | 대졸 | . 4 | f | 전문가 | 3 | 5 | 5.0 | 150 | 대졸 | . 5 | m | 근로자 | 3 | 3 | 4.5 | 113 | 중졸 | . 6 | m | 사무직 | 1 | 2 | 3.5 | 95 | 국졸 | . 7 | m | 전문가 | 2 | 4 | 4.0 | 102 | 고졸 | . 8 | f | 전문가 | 2 | 4 | 4.0 | 122 | 고졸 | . 9 | f | 사무직 | 3 | 4 | 4.5 | 140 | 고졸 | . 10 | m | 근로자 | 3 | 5 | 17.0 | 100 | 대졸 | . 11 | f | 근로자 | 1 | 3 | 22.0 | NA | 중졸 | . 12 | m | 사무직 | 1 | 2 | 5.5 | 106 | 국졸 | . 13 | m | 전문가 | 2 | 1 | 4.5 | 130 | 무학 | . 14 | m | 전문가 | 2 | 5 | 7.0 | 150 | 대졸 | . 15 | m | NA | 3 | 4 | 6.0 | 110 | 고졸 | . 16 | f | 근로자 | 3 | NA | 7.0 | 88 | NA | . 17 | m | 근로자 | 1 | 4 | 6.0 | 138 | 고졸 | . 18 | f | 사무직 | 1 | 5 | 5.0 | 110 | 대졸 | . 19 | m | 사무직 | 3 | 3 | 7.0 | 85 | 중졸 | . 20 | m | 전문가 | 3 | 4 | 9.5 | 110 | 고졸 | . 21 | m | 전문가 | 1 | 4 | 10.0 | 95 | 고졸 | . 22 | m | 전문가 | 2 | 3 | 12.0 | 88 | 중졸 | . 1.2.9 list . 객체들을 복합 오브젝트로 만들어준다. | . intake.pre &lt;- c(5260, 5470, 5640, 6180, 6390) intake.post &lt;- c(3910, 4220, 3885, 5160, 5645) . mylist &lt;- list(before=intake.pre, after=intake.post) mylist # df의 칼럼처럼 뽑아쓸 수 있게 모아준다. . $before &lt;ol class=list-inline&gt; 5260 | 5470 | 5640 | 6180 | 6390 | &lt;/ol&gt; $after &lt;ol class=list-inline&gt; 3910 | 4220 | 3885 | 5160 | 5645 | &lt;/ol&gt; mylist$before . &lt;ol class=list-inline&gt; 5260 | 5470 | 5640 | 6180 | 6390 | &lt;/ol&gt; dataframe . 복합 오브젝트 중에 행렬을 만든다. | text파일을 읽을 땐, 거의 df의 행렬로 만든다고 생각하면 된다. | . d &lt;- data.frame(intake.pre, intake.post) d . intake.preintake.post . 5260 | 3910 | . 5470 | 4220 | . 5640 | 3885 | . 6180 | 5160 | . 6390 | 5645 | . d$intake.pre . &lt;ol class=list-inline&gt; 5260 | 5470 | 5640 | 6180 | 6390 | &lt;/ol&gt; 1.2.11 indexing &#44592;&#45733; . 순서대로, 혹은 일부만 벡터/list/df의 특정index(또는 열)을 여러개 뽑아쓰는 기능 | . intake.pre[c(1,5)] . &lt;ol class=list-inline&gt; 5260 | 6390 | &lt;/ol&gt; intake.pre[- c(1,5)] . &lt;ol class=list-inline&gt; 5470 | 5640 | 6180 | &lt;/ol&gt; 1.2.12 Conditional selection . 인덱싱 처럼 대괄호를 쓰며, 인덱싱 명시 자리에 조건식을 넣는다. 데이터 순서를 (환자)id로 공유하는 list 데이터라면, 서로 다른 list &amp;&amp; 상관없어 보이는 데이터를 통해 만들기 가능한` boolean 벡터를 만들어서 대괄호에 넣는다. | . | . intake.post . &lt;ol class=list-inline&gt; 3910 | 4220 | 3885 | 5160 | 5645 | &lt;/ol&gt; intake.pre . &lt;ol class=list-inline&gt; 5260 | 5470 | 5640 | 6180 | 6390 | &lt;/ol&gt; # 1) [pre가 6000보다 컸]던 id의 환자들에 대해 # 2) post 수치는? intake.post[ intake.pre &gt; 6000 ] . &lt;ol class=list-inline&gt; 5160 | 5645 | &lt;/ol&gt; intake.post[ intake.pre &gt; 5500 &amp; intake.pre &lt;= 6200 ] . &lt;ol class=list-inline&gt; 3885 | 5160 | &lt;/ol&gt; # - 비운 행or렬 = 전체 d [ d$intake.pre &gt; 6000, ] . intake.preintake.post . 46180 | 5160 | . 56390 | 5645 | . 1.2.15 implicit loops . 내장된 반복을 가진 기능들 | . library(&quot;ISwR&quot;) . data(thuesen) . head(thuesen, 3) # 2개의 변수가 있는 데이터 투센 . blood.glucoseshort.velocity . 15.3 | 1.76 | . 10.8 | 1.34 | . 8.1 | 1.27 | . # - l을 붙이면, 각 변수들이 변수명을 가진 list()로 합쳐진다. like before=,after= lapply( thuesen, mean) . $blood.glucose 10.3 $short.velocity &lt;NA&gt; # - na.rm = T : 미싱밸류를.제거한 lapply( thuesen, mean, na.rm = T) . $blood.glucose 10.3 $short.velocity 1.32565217391304 # - 그냥 벡터형식으로 풀어진다. sapply(thuesen, mean, na.rm = T) . &lt;dl class=dl-horizontal&gt; blood.glucose 10.3 short.velocity 1.32565217391304 &lt;/dl&gt; # - 데이터를 바로 넣으면 안해준다. # - (데이터변수 , 그룹변수, 집계)순으로 지정해줘야한다. tapply(thuesen, mean, na.rm = T) . Error in unique.default(x, nmax = nmax): unique()는 오로지 벡터들에만 적용됩니다 Traceback: 1. tapply(thuesen, mean, na.rm = T) 2. lapply(INDEX, as.factor) 3. FUN(X[[i]], ...) 4. factor(x) 5. unique(x, nmax = nmax) 6. unique.default(x, nmax = nmax) . tapply(thuesen$blood.glucose, thuesen$short.velocity, mean, na.rm = T) . &lt;dl class=dl-horizontal&gt; 1.03 4.9 1.05 16.1 1.09 11.1 1.12 6.5 1.18 7.5 1.19 8.85 1.22 12.2 1.25 6.7 1.27 7.65 1.28 15.1 1.31 9.3 1.32 13.3 1.34 10.8 1.37 10.3 1.47 19.5 1.49 5.3 1.52 6.7 1.7 9.5 1.76 15.3 1.95 19 &lt;/dl&gt; data(energy) . energy . expendstature . 9.21 | obese | . 7.53 | lean | . 7.48 | lean | . 8.08 | lean | . 8.09 | lean | . 10.15 | lean | . 8.40 | lean | . 10.88 | lean | . 6.13 | lean | . 7.90 | lean | . 11.51 | obese | . 12.79 | obese | . 7.05 | lean | . 11.85 | obese | . 9.97 | obese | . 7.48 | lean | . 8.79 | obese | . 9.69 | obese | . 9.68 | obese | . 7.58 | lean | . 9.19 | obese | . 8.11 | lean | . tapply(energy$expend, energy$stature, mean, na.rm = T) . &lt;dl class=dl-horizontal&gt; lean 8.06615384615385 obese 10.2977777777778 &lt;/dl&gt; # - 1=row별 가로집계 / 2=col별 세로집계 m = matrix(rnorm(12), 4) # 2번째인자가 row수만 지정해주는 듯 m . 0.9182174 | -0.7425004 | 1.0621464 | . -1.0513366 | 0.8554100 | -0.2472357 | . -0.9116358 | -1.6340607 | -0.4725558 | . -0.1975745 | -0.1045159 | 1.0616053 | . # - 칼럼별 최소값 apply(m, 2, min) . &lt;ol class=list-inline&gt; -1.05133658709921 | -1.63406066310988 | -0.472555766861294 | &lt;/ol&gt; Sorting . 특정 변수에 대한 order객체를 만든 뒤 -&gt; boolean mask자리에 order mask를 인덱싱 자리에 넣어줘야한다. | . intake . prepost . 5260 | 3910 | . 5470 | 4220 | . 5640 | 3885 | . 6180 | 5160 | . 6390 | 5645 | . 6515 | 4680 | . 6805 | 5265 | . 7515 | 5975 | . 7515 | 6790 | . 8230 | 6900 | . 8770 | 7335 | . typeof(intake$post) . &#39;double&#39; o1 &lt;- order(intake$post) o1 . &lt;ol class=list-inline&gt; 3 | 1 | 2 | 6 | 4 | 7 | 5 | 8 | 9 | 10 | 11 | &lt;/ol&gt; typeof(o1) . &#39;integer&#39; intake$post . &lt;ol class=list-inline&gt; 3910 | 4220 | 3885 | 5160 | 5645 | 4680 | 5265 | 5975 | 6790 | 6900 | 7335 | &lt;/ol&gt; # -&gt; 해당칼럼에 대한 오름차순 order객체로 정렬 intake$post[o1] . &lt;ol class=list-inline&gt; 3885 | 3910 | 4220 | 4680 | 5160 | 5265 | 5645 | 5975 | 6790 | 6900 | 7335 | &lt;/ol&gt; intake$pre . &lt;ol class=list-inline&gt; 5260 | 5470 | 5640 | 6180 | 6390 | 6515 | 6805 | 7515 | 7515 | 8230 | 8770 | &lt;/ol&gt; intake$pre[o1] . &lt;ol class=list-inline&gt; 5640 | 5260 | 5470 | 6515 | 6180 | 6805 | 6390 | 7515 | 7515 | 8230 | 8770 | &lt;/ol&gt; R environment . Session management . ls(): 내 워크스페이스에 존재하는 모든 객체 | rm(): 데이터 객체 삭제 | . ls() . &lt;ol class=list-inline&gt; &#39;a&#39; | &#39;aa&#39; | &#39;b&#39; | &#39;bmi&#39; | &#39;d&#39; | &#39;energy&#39; | &#39;fpain&#39; | &#39;height&#39; | &#39;hh&#39; | &#39;insurance&#39; | &#39;intake.post&#39; | &#39;intake.pre&#39; | &#39;m&#39; | &#39;mylist&#39; | &#39;nwd&#39; | &#39;o1&#39; | &#39;oops&#39; | &#39;pain&#39; | &#39;thuesen&#39; | &#39;wd&#39; | &#39;weight&#39; | &#39;x&#39; | &#39;xbar&#39; | &#39;y&#39; | &lt;/ol&gt; rm(aa, b) # rm으로 데이터객체 삭제 -&gt; 콤마로 한번에 여러개 가능 . ls() . &lt;ol class=list-inline&gt; &#39;a&#39; | &#39;bmi&#39; | &#39;d&#39; | &#39;energy&#39; | &#39;fpain&#39; | &#39;height&#39; | &#39;hh&#39; | &#39;insurance&#39; | &#39;intake.post&#39; | &#39;intake.pre&#39; | &#39;m&#39; | &#39;mylist&#39; | &#39;nwd&#39; | &#39;o1&#39; | &#39;oops&#39; | &#39;pain&#39; | &#39;thuesen&#39; | &#39;wd&#39; | &#39;weight&#39; | &#39;x&#39; | &#39;xbar&#39; | &#39;y&#39; | &lt;/ol&gt; # df객체 속 변수를 바로 쓰는 방법은? # -&gt; session에 df자체를 attach해버리는 것 -&gt; 가진 칼럼들이 다 변수로 붙어진다? # --&gt; 함수들의 인자로 넣기 쉽게 하기 위함인듯? . head(thuesen, 3) . blood.glucoseshort.velocity . 15.3 | 1.76 | . 10.8 | 1.34 | . 8.1 | 1.27 | . attach(thuesen) . ls() . &lt;ol class=list-inline&gt; &#39;a&#39; | &#39;bmi&#39; | &#39;d&#39; | &#39;energy&#39; | &#39;fpain&#39; | &#39;height&#39; | &#39;hh&#39; | &#39;insurance&#39; | &#39;intake.post&#39; | &#39;intake.pre&#39; | &#39;m&#39; | &#39;mylist&#39; | &#39;nwd&#39; | &#39;o1&#39; | &#39;oops&#39; | &#39;pain&#39; | &#39;thuesen&#39; | &#39;wd&#39; | &#39;weight&#39; | &#39;x&#39; | &#39;xbar&#39; | &#39;y&#39; | &lt;/ol&gt; blood.glucose . &lt;ol class=list-inline&gt; 15.3 | 10.8 | 8.1 | 19.5 | 7.2 | 5.3 | 9.3 | 11.1 | 7.5 | 12.2 | 6.7 | 5.2 | 19 | 15.1 | 6.7 | 8.6 | 4.2 | 10.3 | 12.5 | 16.1 | 13.3 | 4.9 | 8.8 | 9.5 | &lt;/ol&gt; # - 인덱싱과 마찬가진데, 함수를 쓴다.?! thue2 &lt;- subset(thuesen, blood.glucose &lt; 7) thue2 . blood.glucoseshort.velocity . 65.3 | 1.49 | . 116.7 | 1.25 | . 125.2 | 1.19 | . 156.7 | 1.52 | . 174.2 | 1.12 | . 224.9 | 1.03 | . # - 로그값을 씌운 변수를 함수로 생성하여 반환 thue3 &lt;- transform(thuesen, log.gluc = log(blood.glucose)) head(thue3, 4) . blood.glucoseshort.velocitylog.gluc . 15.3 | 1.76 | 2.727853 | . 10.8 | 1.34 | 2.379546 | . 8.1 | 1.27 | 2.091864 | . 19.5 | 1.47 | 2.970414 | . # -&gt; 중괄호{}를 이용하여, 입력된 df내에서 변수생성/조작/중간변수 삭제가 가능하다. thue4 &lt;- within(thuesen, { log.gluc &lt;- log(blood.glucose) # + log씌운 칼럼 생성 m &lt;- mean(log.gluc) # 평균값 계산(중간변수) centered.log.gluc &lt;- log.gluc - m # 중간변수를 이용해 새로운 칼럼 추가 생성 rm(m) }) head(thue4) . blood.glucoseshort.velocitycentered.log.gluclog.gluc . 15.3 | 1.76 | 0.4818798 | 2.727853 | . 10.8 | 1.34 | 0.1335731 | 2.379546 | . 8.1 | 1.27 | -0.1541090 | 2.091864 | . 19.5 | 1.47 | 0.7244414 | 2.970414 | . 7.2 | 1.27 | -0.2718920 | 1.974081 | . 5.3 | 1.49 | -0.5782662 | 1.667707 | . The graphics system . 2.2.1 plot layout . x &lt;- runif(50,0,2) y &lt;- runif(50, 0,2) . plot( x, y, main=&quot;Main title&quot;, sub=&quot;subtitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;, ) . # -&gt; x, y좌표에 텍스트를 넣어준다. text(0.6, 0.6, &quot;text at (0.6, 0.6)&quot;) . Error in text.default(0.6, 0.6, &#34;text at (0.6, 0.6)&#34;): plot.new has not been called yet Traceback: 1. text(0.6, 0.6, &#34;text at (0.6, 0.6)&#34;) 2. text.default(0.6, 0.6, &#34;text at (0.6, 0.6)&#34;) . plot( x, y, main=&quot;Main title&quot;, sub=&quot;subtitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;, ) text(0.6, 0.6, &quot;text at (0.6, 0.6)&quot;) . abline(h=.6, v=.6, lty=2) . Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet Traceback: 1. abline(h = 0.6, v = 0.6, lty = 2) 2. int_abline(a = a, b = b, h = h, v = v, untf = untf, ...) . plot( x, y, main=&quot;Main title&quot;, sub=&quot;subtitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;, ) text(0.6, 0.6, &quot;text at (0.6, 0.6)&quot;) abline(h=.6, v=.6, lty=2) . # -&gt; -1부터 4숫자를, 각 side에 , 0.7크기로, -1~4의 위치에 적기 for (side in 1:4) mtext(-1:4, side=side, at=.7, line=-1:4) . Error in mtext(-1:4, side = side, at = 0.7, line = -1:4): plot.new has not been called yet Traceback: 1. mtext(-1:4, side = side, at = 0.7, line = -1:4) . plot( x, y, main=&quot;Main title&quot;, sub=&quot;subtitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;, ) text(0.6, 0.6, &quot;text at (0.6, 0.6)&quot;) abline(h=.6, v=.6, lty=2) for (side in 1:4) # -1부터 4숫자를, 각 side에 , 0.7크기로, -1~4의 위치에 적기 mtext(-1:4, side=side, at=.7, line=-1:4) . c(1:4) . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 4 | &lt;/ol&gt; 1:4 . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 4 | &lt;/ol&gt; mtext(paste(&quot;side&quot;, 1:4), side=c(1:4), line=-1, font=2) . Error in mtext(paste(&#34;side&#34;, 1:4), side = c(1:4), line = -1, font = 2): plot.new has not been called yet Traceback: 1. mtext(paste(&#34;side&#34;, 1:4), side = c(1:4), line = -1, font = 2) . plot( x, y, main=&quot;Main title&quot;, sub=&quot;subtitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;, ) text(0.6, 0.6, &quot;text at (0.6, 0.6)&quot;) abline(h=.6, v=.6, lty=2) for (side in 1:4) mtext(-1:4, side=side, at=.7, line=-1:4) mtext(paste(&quot;side&quot;, 1:4), side=c(1:4), line=-1, font=2) . 2.2.2 Building a plot from pieces . 각 축에 라벨 주기 | . plot(x, y) . # -&gt; 흰색으로 표시만 지우고 도화지만 그려놓는다는 의미 # 라벨도 &quot;&quot;로 다 지우고 # axes= F -&gt; 축도 그리지 말고 있어라. plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F ) . plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F) points(x, y) . # 2) axis(1) -&gt; 1번 축(x축)만 그려라 plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F) points(x, y) axis(1) . # 2) axis(1) -&gt; 1번 축(x축)만 그려라 # 3) axis(2, at= ) -&gt; 2번 축(좌 y축)에는 점을 직접 찍어준다. plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F) points(x, y) axis(1) axis(2, at=seq(0.2, 1.8, 0.2)) . # 2) axis(1) -&gt; 1번 축(x축)만 그려라 # 3) axis(2, at= ) -&gt; 2번 축(좌 y축)에는 점을 직접 찍어준다. # 4) box() -&gt; 4방향 축이 사각형으로 모두 그려진다. plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F) points(x, y) axis(1) axis(2, at=seq(0.2, 1.8, 0.2)) box() . # 2) axis(1) -&gt; 1번 축(x축)만 그려라 # 3) axis(2, at= ) -&gt; 2번 축(좌 y축)에는 점을 직접 찍어준다. # 4) box() -&gt; 4방향 축이 사각형으로 모두 그려진다. # 5) title() -&gt; main(위) sub(아래) xlab, ylab -&gt; 2개 축 라벨 plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F) points(x, y) axis(1) axis(2, at=seq(0.2, 1.8, 0.2)) box() title(main=&quot;Main title&quot;, sub = &quot;subttitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;) . 2.2.3 Using par . 그래프 그릴 때 유용한 par문 | . ?par . par(mfrow=c(2,2)) # 한 화면을 2x2 로 나눠서 그린다. . par(mfrow=c(1,1)) . 2.2.4 Combinin plots . 그래프를 합치는(겹쳐그리는) 방법: 2번째 그래프에 add=T옵션 주기 정규분포 변수 -&gt; rnorm(갯수) | 정규분포 함수 -&gt; dnorm(변수) | . | hist그램 그린 후 -&gt; 정규분포를 겹쳐그려서 -&gt; 정규분포를 따르는지 확인 | . # - 안주면 각각의 그림이 2개로 나눠서 각각 그려진다. x &lt;- rnorm(100) # 정규분포(r norm)를 따르는 놈 100개 hist(x, freq=F) # 히스토그램: freq=F 를 주면 빈도대신 비율(밀도)가 y축을 차지한다. curve(dnorm(x), add=T) # 정규분포 함수dnorm(x) 를 curve로 그리는데, 겹쳐서 그려라 add=T # my) 정규분포 변수 -&gt; rnorm(갯수) # my) 정규분포 함수 -&gt; dnorm(변수) . # 다시 그리고 -&gt; add=T로 2번째 그림 그리고 h &lt;- hist(x, plot=F) h . $breaks [1] -3 -2 -1 0 1 2 3 4 $counts [1] 4 9 39 28 17 2 1 $density [1] 0.04 0.09 0.39 0.28 0.17 0.02 0.01 $mids [1] -2.5 -1.5 -0.5 0.5 1.5 2.5 3.5 $xname [1] &#34;x&#34; $equidist [1] TRUE attr(,&#34;class&#34;) [1] &#34;histogram&#34; . h &lt;- hist(x, plot=F) # 기존 hist plot 객체에서 y축 정보만 가져와 -&gt; 조작후 객체로 만든다. ylim &lt;- range(0, h$density, dnorm(0)) # 조작된 ylim으로 새로운 hist를 그린다. hist(x, freq=F, ylim=ylim) curve(dnorm(x), add=T) . 2.3 R programming . 함수를 정의하고 -&gt; .r 파일로 저장후 -&gt; source() 문으로 로딩한 뒤 -&gt; 사용 | . # -&gt; 이후 파일로 저장하기 위해 스트링으로 바꿈 func_string &lt;- &quot;hist.with.normal &lt;- function(x) { hist &lt;- hist(x, plot=F) s &lt;- sd(x) m &lt;- mean(x) ylim &lt;- range(0, h$dentisy, dnorm(0, sd=s)) hist(x, freq=F, ylim=ylim) curve(dnorm(x, m, s), add=T) }&quot; . filename &lt;- &quot;./01_p44.r&quot; fileConn &lt;- file(filename) writeLines(func_string, fileConn) close(fileConn) . source(filename) . ls() . &lt;ol class=list-inline&gt; &#39;a&#39; | &#39;bmi&#39; | &#39;d&#39; | &#39;energy&#39; | &#39;fileConn&#39; | &#39;filename&#39; | &#39;fpain&#39; | &#39;func_string&#39; | &#39;h&#39; | &#39;height&#39; | &#39;hh&#39; | &#39;hist.with.normal&#39; | &#39;insurance&#39; | &#39;intake.post&#39; | &#39;intake.pre&#39; | &#39;m&#39; | &#39;mylist&#39; | &#39;nwd&#39; | &#39;o1&#39; | &#39;oops&#39; | &#39;pain&#39; | &#39;side&#39; | &#39;thue2&#39; | &#39;thue3&#39; | &#39;thue4&#39; | &#39;thuesen&#39; | &#39;wd&#39; | &#39;weight&#39; | &#39;x&#39; | &#39;xbar&#39; | &#39;y&#39; | &#39;ylim&#39; | &lt;/ol&gt; x &lt;- rnorm(100) hist.with.normal(x) . 2.3.1 Flow control . R의 반복문 중 3가지 while 문 -&gt; 반복될 조건문 | repeat 문 -&gt; 탈출할 조건문 -&gt; while의 반대 | for 문 -&gt; 뿌려줄 벡터 -&gt; 그걸로 그림그리기 | | . y &lt;- 12345 # 1. while (조건) 식 으로 구하는 root x &lt;- y/2 while (abs(x*x-y) &gt; 1e-10 ) x &lt;- (x + y/x)/2 x . 111.108055513541 x^2 . 12345 # 1. while (조건) 식 으로 구하는 root # 2. repeat { 식 if 탈출조건 break} repeat{ x &lt;- (x + y/x)/2 if (abs(x*x-y) &lt; 1e-10) break } x . 111.108055513541 x &lt;- seq(0, 1, 0.5) plot(x, x, ylab=&quot;y&quot;, type=&quot;l&quot;) for ( j in 2:8 ) lines(x, x^j) . 2.4 Data entry . 김성수 2015 강의교안 저장된페이지 | 01 2015자료 데이터시각화.pdf에 코드 검색됨 | . text file: read.table, read.csv | excel file : read.xlsx ( package: xlsx) | install.packages(&quot;xlsx“) library(xlsx) drug.data = read.xlsx(&quot;c:/Rfolder/data/drug.xlsx&quot;, 1) # 1은 default인데, sheet번호다. edit(drug.data) # R전용 데이터에디터에 가져와서 조작하고 싶을 때 . &#48320;&#49688;&#44049; &#48320;&#54872;(recode) Method1 : &#51064;&#45937;&#49905; . (범위별 매핑 -&gt; ) recode = 변수 값 변환이라고 한다. | . 새 변수를 만들고 (할당으로 복사) | 인덱싱을 이용해서 범위별로 값 변환 | &#48320;&#49688;&#44049; &#48320;&#54872;(recode) Method2 : car&#54056;&#53412;&#51648;&#51032; recode()&#54632;&#49688; . 새 변수 만들어놓는 것은 똑같고 | recode()함수를 이용하여 범위를 간단하게 표현할 수 있다. . &quot; lo:40=1; 40:60=2;60:hi=3 &quot; | . | 1,2,3 범주형 자료이면서 순서형 변수 순서를 ordered()를 이용해서 factor-라벨로 준다. . 라벨을 주면 그래프에서도 나온다. | . | &#44050; &#46972;&#48296;(Value labels): &#49707;&#51088; -&gt; &#46972;&#48296;&#47196; &#48148;&#44984;&#44592; . 명목형 변수 -&gt; 순서 없는 일반 범주factor()를 이용해서 바꾼다. | 순서형 변수 -&gt; 순서를 가진 범주ordered()를 이용해서 바꾼다. |",
            "url": "blog.chojaeseong.com/r/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EB%B0%A9%EB%B2%95%EB%A1%A01/%ED%86%B5%EA%B3%84/2022/03/11/01-Basics-and-R-environment(%EC%99%84).html",
            "relUrl": "/r/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EB%B0%A9%EB%B2%95%EB%A1%A01/%ED%86%B5%EA%B3%84/2022/03/11/01-Basics-and-R-environment(%EC%99%84).html",
            "date": " • Mar 11, 2022"
        }
        
    
  
    
        ,"post9": {
            "title": "싱글톤으로 캐싱(로또번호)",
            "content": "싱글톤과 캐싱 . 싱글톤을 이용한 [단일객체 CACHE] 적용과 TDD . 싱글톤을 이용한 CACHE 생성 2가지 방법(정리용) . static final으로 클래스 CACHE변수; 선언 . 바로 옆에서 = 할당하며 초기화 or 길어서 static { 클래스변수 = } 블럭(final도 가능)에서 초기화 바로 초기화하든, static블럭에서 초기화하든 null이 아닌 상태의 캐쉬변수 | . | 이후 정팩메로만 생성된 CACHE객체 or 생성된 CACHE자료구조에서 1개만 get하여 제공 이후 기본생성자는 CACHE 최초 초기화하며 채울때만 사용됨 | . | . private static final Map&lt;Integer, LottoNumber&gt; LOTTO_NUMBER_CACHE; static { LOTTO_NUMBER_CACHE = IntStream.rangeClosed(LOTTO_NUMBER_MIN, LOTTO_NUMBER_MAX) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } private final int number; public LottoNumber(final int inputNumber) { this.number = inputNumber; } public static LottoNumber from(final String inputNumber) { final int number = Integer.parseInt(inputNumber); validateLottoNumberRange(number); return LOTTO_NUMBER_CACHE.get(number); } . | static으로 클래스 CACHE변수; 선언 (no final) . 이후 정팩메에 synchronized달아주고 . | 정펙매내부에서 초기화 한번도 안된 최초 if (CACHE == null) 상태의 캐쉬변수일 때만, 기본생성자로 CACHE변수 초기화 | 정펙매로만 생성된 CACHE객체 or 생성된 CACHE자료구조에서 1개만 get하여 제공 | . private static Map&lt;Integer, LottoNumber&gt; LOTTO_NUMBER_CACHE; private final int number; private LottoNumber(final int number) { checkNumberRightRange(number); this.number = number; } public synchronized static LottoNumber valueOf(final int number) { checkNumberRightRange(number); if (LOTTO_NUMBER_CACHE == null) { LOTTO_NUMBER_CACHE = IntStream.rangeClosed(MIN_LOTTO_NUMBER, MAX_LOTTO_NUMBER) .boxed() .collect(Collectors.toMap(lottoNumber -&gt; lottoNumber, LottoNumber::new)); } return LOTTO_NUMBER_CACHE.get(number); } . | Test에서부터 빨간줄로 넘어가 -&gt; 캐쉬 적용하기 . 캐쉬로 받아먹으려면 싱글톤 받아주는 정펙매(getInstance())로만 가져와야한다. . 네이밍을 그렇게 했어도 기본 생성자에 넣어줄 파라미터도 받아야한다. | . | 싱글톤의 동시성 잇슈를 처리하기 위해 synchronized를 접근제한자 &lt;-&gt; static 사이에 넣어준다. . public synchronized static void getInstance(final int value) { } . | 앞으로 정펙매로만 제공되어야하므로 도메인 검증을 여기로 옮기자. . 기존 도메인테스트가 new 기본생성자()로 진행되어있으니, 그냥 두고 -&gt; 맨 나중에 도메인검증을 정팩메코드로 + 기본생성자는 private + 검증은 삭제하도록 수정하자.. | . | . public LottoNumber(final int value) { // 지금은 임시로 살려둔다. 테스트를 나중에 바꿀 때 private로 변경 + 검증삭제 validate(value); this.value = value; } public synchronized static void getInstance(final int value) { //2. 검증은 여기로 옮긴다. 왜냐면, 앞으로 CACHE정팩메로만 제공될 것이기 때문. // - 정적안에 들어가므로 검증메서드가 static으로 바뀐다. validate(value); } . | CACHE의 static변수 선언을 직접 안하고 빨간줄생성 하기 위해, . 빨간줄로 if ( == null )부터 static 초기화 를 작성해줬다. 기본생성자는 이제 여기 캐쉬생성에서만 이용되어야한다. 원래는 private으로 바꾸고, TEST다 처내야함. | . | . | static 메서드 내 자동 생성시 constant = static final이므로 그냥 field -&gt; static필드로 생성하자. | . . public class LottoNumber { private static final int MIN = 1; private static final int MAX = 45; // 자동 생성한 CACHE field (static) private static Map&lt;Integer, LottoNumber&gt; CACHE; private final int value; public synchronized static void getInstance(final int value) { validate(value); //3. 캐쉬로 제공될 static 변수; 만 선언하고 -&gt; if null일 때 = 최초에만 초기화 시켜준다. // - Map으로 만들거면 // - 중간에 .map( number -&gt; )없이 맨 나중에 toMap으로 만들면 된다. // - intStream은 Integer가 아니다. toMap에 들어가려면 .boxed() 먼저 해주고 들어가야한다. // - toMap의 2번쨰 인자는 method reference만 사용 가능하다. new LottoNumber(Number하니 안되더라) if (CACHE == null) { CACHE = IntStream.rangeClosed(MIN, MAX) //.map( number -&gt; ) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } } . | 정팩메에서 캐쉬객체 or 캐쉬 자료구조.get()한 것을 응답해준다. . public synchronized static LottoNumber getInstance(final int value) { validate(value); if (CACHE == null) { CACHE = IntStream.rangeClosed(MIN, MAX) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } // 제공은 이제 기본생성자가 아닌, CACHE에서 제공해준다. return CACHE.get(value); } . | 검증이 넘어간 캐쉬 정팩메로 생성 테스트로 마무리 . @Test void cache_create() { assertDoesNotThrow(() -&gt; LottoNumber.getInstance(6)); } .",
            "url": "blog.chojaeseong.com/java/%EC%8B%B1%EA%B8%80%ED%86%A4/%EC%BA%90%EC%8B%B1/cache/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/10/%EC%8B%B1%EA%B8%80%ED%86%A4%EA%B3%BC-%EC%BA%90%EC%89%AC(%EB%A1%9C%EB%98%90%EB%B2%88%ED%98%B8).html",
            "relUrl": "/java/%EC%8B%B1%EA%B8%80%ED%86%A4/%EC%BA%90%EC%8B%B1/cache/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/10/%EC%8B%B1%EA%B8%80%ED%86%A4%EA%B3%BC-%EC%BA%90%EC%89%AC(%EB%A1%9C%EB%98%90%EB%B2%88%ED%98%B8).html",
            "date": " • Mar 10, 2022"
        }
        
    
  
    
        ,"post10": {
            "title": "일급컬렉션관련 가,불변 List",
            "content": "01 Test코드 등 add/remove 허용 가변List는 new ArrayList&lt;&gt;()로 생성 . 테스트코드에서 .add()해야하는데 Arrays.asList(전체단위만 가변ex&gt;set, replace) 나 List.of(아예 조작 불가)로 초기화 하면 UOE 예외가 발생한다. . add 등 조작이 당장 필요한 List는 new ArraysList&lt;&gt;( );로 초기화할 것 | . @Test void 일급컬렉션_생성자가_파라미터로_list를_받는경우_방어적복사_테스트() { //1. 외부에서 일급컬렉션의 포장변수(List&lt;객체&gt;)로 넘겨줄 [add가능한 가변List]를 생성 // - List.of()는 add/remove 등을 제공하지 않으니 Arrays.List()로 생성했다가 UOE 뜸. 역시 불변 //List&lt;LottoNumber&gt; lottoNumbers = List.of(new LottoNumber(1), //List&lt;LottoNumber&gt; lottoNumbers = Arrays.asList(new LottoNumber(1), // -&gt; 테스트에 add 등 조작하는 가변List는 new ArraysList()&lt;&gt;;로 초기화해서 사용할 것 List&lt;LottoNumber&gt; lottoNumbers = new ArrayList&lt;&gt;(); lottoNumbers.addAll( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6) )); } . | . 02 input 가정인자(검증후 완료된 인자) 등 add/remove 불허 불변List(List.of()) . 참고 블로그 | TDD할 때, input으로 넘어온다고 가정한 인자로서 List를 받을 때 Arrays.asList(1,2,3)이 아니라 List.of(1,2,3)을 쓰더라 | . | . 결론 . List.of() , List.copyof( list )는 add/remove등 **조작시 ** UnsupportedOperationException발생시키는 불변List | 모든 가변 조작(add/remove, set/replace) 불허 | null도 불허 | . | 반면 Arrays.asList는 add/remove만 안되는 전체는 가변List를 제공 통채로 add하는 set, replace 가능) | null허용 + | . | 둘다 add안되니.. 테스트용 가변 객체리스트 생성시에도.. add하면서 테스트하면 안될 듯. | . returnType . List.of()는 10개까진 가변인자 없이 하나하나 받아서 -&gt; ImmutableCollections.ListN()을 반환한다. . add(), remove(), set(), replace()처럼 삽입, 삭제, 변경작업을 하게 될시 UnsupportedOperationException예외가 발생는 불변 자료구조 = 이름 그대로 Immutable한 Collection을 반환해준다. | . static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6) { return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6); } . java9부터 제공한다. . | 인자의 갯수( 0개 / 1~2개 / 3개이상N/ List )에 따라서 다른방식 메서드를 반환한다. . . . | . | 반면에 Arrays.asList()는 가변인자를 받으며 -&gt; new ArraysList&lt;&gt;()를 반환한다. . public static &lt;T&gt; List&lt;T&gt; asList(T... a) { return new ArrayList&lt;&gt;(a); } . 가변인자는 내부 배열로 관리됨 | 추상메서드 AbstractList&lt;E&gt;를 extends하지만, add+remove만 메서드 오버라이딩 하지 않는다. AbstractList의 add()와 remove() 메서드를 확인해본 결과 서브클래스에서 해당 메서드를 오버라이딩 하지 않았다면, UnsupportedOperationException예외가 발생된다. Arrays.asList()의 리턴되는 ArrayList는 삽입, 삭제로 이뤄지는 구조적인 변경을 허용하지 않고 내부 원소들의 값을 변경하는건 허용하는걸 알 수 있다. | . | set() setter메서드만 오버라이딩함. | . | . | . 03 일급컬렉션의 List&lt;객체&gt; 파라미터를 받는 생성자 or 컬렉션을 return하는 getter의 return문에서의 방어적 복사 -&gt; 불변List.copyOf( list ) or add 등 가변 new ArraysList&lt;&gt;( list ) . 만약, 생성자가 파라미터 List&lt;객체&gt;를 받으면, 외부 원본 list의 메모리주소가 들어오니 끊고 재생성해라. . list를 내부 포장할 때, 만약 생성자 파라미터로 내부 포장하는 변수와 동일한 형태의 List&lt;객체&gt;가 들어오면, 외부에서 온 List의 메모리주소로서, 끊고 재생성해줘야 오염이 안된다. list는 callByReference 로서 파라미터에 지역변수로 선언되어도 외부의 메모리주소를 가지고 있다. | this.value = 파라미터로 온 list는 메모리 주소만 대입하여 포장되어있지만, 외부 변화에 오염된다. | . @Test void 일급컬렉션_생성자가_파라미터로_list를_받는경우_방어적복사_테스트() { //1. add될 가변 &amp;&amp; 방어적복사로인한 메모리주소 끊음(재발급)안하면 일급컬렉션 내부 변수도 오염시키는 // -&gt; &lt;외부 원본 List&gt; List&lt;LottoNumber&gt; lottoNumbers = new ArrayList&lt;&gt;(); lottoNumbers.addAll( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6) )); //2. 일급은 외부list를 생성자로 넘겨받아 --방어적복사없이 --&gt; this.value에 넣은 상태다. final Lotto lotto = new Lotto(lottoNumbers); //3. 일급컬렉션말고, 원본에 1개를 더한다. lottoNumbers.add(new LottoNumber(7)); //4. getter로 내부 상태값의 길이를 가져와보자. 6개여야하는데... 7개가 되어있을 것이다. final int size = lotto.getSize(); //5. 7하니까 통과 ... -&gt; 외부list를 add했는데 -&gt; 일급컬렉 포장변수가 가변으로 변해버렸다. assertThat(size).isEqualTo(7); } . | 파라미터로 오는 외부List의 메모리주소를 끊는 방법 2가지 불변 일급 : List.copyOf( otherList ) | 가변 일급: new ArraysList&lt;&gt;( ohterList )로 반환받아서 this.value에 넣어주자. | public Lotto(final List&lt;LottoNumber&gt; value) { if (value.size() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개여야 합니다.&quot;); } if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 중복해서 입력할 수 없습니다.&quot;); } //this.value = value; // 불변하는 일급컬렉션으로 -&gt; 1번째 방어적 복사 적용 this.value = List.copyOf(value); } . // 외부 add에도 6개라고 에러났다. org.opentest4j.AssertionFailedError: expected: 7 but was: 6 Expected :7 Actual :6 &lt;Click to see difference&gt; . | . 참고) 포장(VO or 일급컬렉션) 변수명: value, 상수 MIN/MAX . 값의 포장은 앵간하면 value를 인스턴스 변수(상태값)으로 쓴다. 그래야 getter시 LottoNumber.getValue() 형태로 잘 빠진다. | 만약, LottoNumber.getLottoNumber()가 될 수 도.. | . | 상수도 마찬가지로 도메인Class.이 앞에 붙는다고 생각하고 도메인내에서 편하게 짓자 LottoNumber.LOTTO_NUMBER_MIN이 될 수도.. | LottoNumber.MIN으로 MIN, MAX 편하게 쓰자. | . | . public class LottoNumber { private static final int MIN = 1; private static final int MAX = 45; private final int value; //LottoNumber.getValue()가 맞다.(o) -&gt; LottoNumber.getLottoNumber() (X) public LottoNumber(final int value) { validate(value); this.value = value; } //LottoNumber.MIN 이 맞다.(o) -&gt; LottoNumber.LOTTO_NUMBER_MIN (X) //Integer.MAX_VALUE (o) private void validate(final int value) { if (value &lt; MIN || value &gt; MAX) { throw new IllegalArgumentException(&quot;로또 번호의 범위가 아닙니다.&quot;); } . 일급이 중복 허용 안한다면 단일List가 대신 단일Set으로 정의해도 된다. . List&lt;단일&gt;의 value를 Set&lt;단일&gt;로 바꾼다. . | 테스트에서 생성도 Set.of( 단일1, 단일2 )형식으로 사용한다. . . | Set에 들어가므로 해쉬코드로 비교하는 자료구조용 단일객체는 equals/hashCode 오버라이딩이 되어있어야한다. . VO뿐만 아니라 단일값 포장객체는 그냥 다 오버라이딩 해주자. | . |",
            "url": "blog.chojaeseong.com/java/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%EB%B0%A9%EC%96%B4%EC%A0%81%EB%B3%B5%EC%82%AC/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/08/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98%EA%B4%80%EB%A0%A8-List-%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/java/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%EB%B0%A9%EC%96%B4%EC%A0%81%EB%B3%B5%EC%82%AC/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/08/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98%EA%B4%80%EB%A0%A8-List-%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Mar 8, 2022"
        }
        
    
  
    
        ,"post11": {
            "title": "TDD 5 로또(Method부터 시작)",
            "content": "메서드의 파라미터(값-&gt;일급) 및 응답값(제한된 종류의 분기 응답) 포장시 TDD . 메서드의 파라미터(값-&gt;일급) 및 응답값 포장시 TDD [메서드 내부 포장후 -&gt;새 기준메서드 호출] 및 [Client 배려 by 메서드 파라미터 포장 완성된 후 client일급생성 내부(List.of)부터 가변인자 생성자 추가] . 01 메변1) 검증 등 필요에 의한 값 포장시, [메서드복붙]후 [파라미터 수정] -&gt; 에러해결 -&gt; client 인자 변경 . 기존 테스트들이 인자를 안바꿔도 유지되도록 전체 복사후 인자만 바꾼 새 기준 메서드를 만들고 에러 해결후 포장 객체로 메서드 호출 변경 . 기존 테스트는 유지한 체 값List를 받다가 . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { . | 새 테스트에서 검증 등 필요에 의해 값을 1개 포장 . final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, new LottoNumber(100)) . | 포장 Class, ClassTest생성 . public class LottoNumber { private final int value; public LottoNumber(final int value) { this.value = value; } } . class LottoNumberTest { } . | 객체비교를 위해, equals,hC 오버라이딩 . | 메서드 복붙 -&gt; 파라미터 정의 변경 . public static int start(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { . | 검증 요구 새 테스트에 한해, 복붙한 새 메서드 인자를 포장시키도도록 노가다 . @Test void over() { assertThatThrownBy(() -&gt; LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(100)), List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(7)), new LottoNumber(6) )).isInstanceOf(IllegalArgumentException.class); } . | 검증, 필요에 의한 포장 테스트 -&gt; thr 나야 통과하는 테스트 . 포장 생성자에 검증을 안 넣어준 상태므로 테스트를 통과못한다. | 원래 포장 객체 생성자 1개로만 테스트를 해야하는데, 여기서는 메서드 전체 호출로 퉁친다. | . | 02 도메인 속 검증 등 포장에 의해 thr나는 메서드() 테스트 작성 . 생성자 쪽에서 validate해준다. . public LottoNumber(final int value) { validate(value); this.value = value; } private void validate(final int value) { if (value &lt; 1 || value &gt; 45) { throw new IllegalArgumentException(&quot;로또 번호의 범위가 아닙니다.&quot;); } } . | 테스트해서 thr나게 된다. . @Test void over() { assertThatThrownBy(() -&gt; LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(100)), List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(7)), new LottoNumber(6) )).isInstanceOf(IllegalArgumentException.class); } . | 03 (필요에 의해 포장이 발생된) 메서드 테스트를 넘어서서 도메인 전용Test에서 경계값들 테스트 . class LottoNumberTest { @ParameterizedTest @ValueSource(ints = {0, 46, -1, 100}) void range(final int value) { assertThatThrownBy(() -&gt; new LottoNumber(value)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;범위&quot;); } } . 04 메변2) [기존 rawInput메서드]는 [파라미터만 유지]한체 내부에서 포장 -&gt; 새 기준 메서드 호출 하는 [포장후 호출메서드]로 변경 . rawInput을 받는 곳의 파라미터명에 raw를 달아 -&gt; 원래 네이밍은 포장후 변수로 받아줄 준비를 한다 . public static int match(final List&lt;Integer&gt; rawUserLotto, final List&lt;Integer&gt; rawWinningLotto, final int rawBonusNumber) { . | 내용물에 대해선 포장된 것으로 처리되는 메서드가 남아있으니, rawInput은 받아서 stream().map(포장생성자).collect()의 List&lt;포장&gt;만해서 그쪽으로 넘겨주기만 한다. . public static int match(final List&lt;Integer&gt; rawUserLotto, final List&lt;Integer&gt; rawWinningLotto, final int rawBonusNumber) { final List&lt;LottoNumber&gt; userLotto = rawUserLotto.stream() .map(LottoNumber::new) .collect(Collectors.toList()); final List&lt;LottoNumber&gt; winningLotto = rawWinningLotto.stream() .map(LottoNumber::new) .collect(Collectors.toList()); return match(userLotto, winningLotto, new LottoNumber(rawBonusNumber)); } . | 요약: 값을 단일객체 포장한다면, 메서드복붙후 포장인자 -&gt; 에러처리 -&gt; rawInput메서드는 내부포장용으로 변경 . 05 메변3) 객체간 검증(갯수, 중복) 등 필요에 의해 List.of앞에 [new 일급()]으로 포장 . [메서드 수정]은 포장후 기준호출해주는 메서드가 아니라 포장인자를 받는 기준 메서드로 . 기준메서드에 List.of( 단일, 객체, 들) -&gt; 갯수 초과 유발(필요에 의한 검증) . rawInput을 받아 포장후 기준메서드 호출해주기도 하지만, 제깍적인 수정을 위해서 포장된 인자를 직접 받아서 내부에서 바로 처리하는 메서드를 수정해줘야한다. . 하나하나 다 쏴줘야, 메서드는 그렇게 오는지 알 수 있다(노가다) | . @Test void lotto7() { assertThatThrownBy(() -&gt; LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6), new LottoNumber(7)), // 갯수 초과 . 갯수를 초과해서 넣었다. 에러가 나야 통과인데, 현재는 에러가 안날 것이다. 포장해야한다. | . | 파라미터의 갯수 검증은, 받는 메서드 내부에서도 해줘도 될 것 같지만.. [검증은 다 쏴서 포장한 도메인 생성자에서] . 관련 로직도 아닌데, if가 계속 쌓이게 될 것이다. 메서드 내 파라미터를 받아 검증하는 것을 지양하자. | 검증이 필요하면, 포장 -&gt; 도메인 분리 -&gt; 도메인 생성자에서 | . | . 복수개 검증을 위해 List.of( ) 앞에 new 일급() 생성자를 씌워서 포장 시작 . 객체List인 List.of()를 new일급() 생성자를 씌워 일급객체를 만든다. . @Test void lotto7() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(2), . | 일급객체도 상태가 1개 라면, value로 네이밍 -&gt; 나중에 .getValue()로 getter를 쓸 생각 . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final List&lt;LottoNumber&gt; value) { this.value = value; } } . | 검증의 순서는 중복검사보다는 갯수가 있다면 갯수가 먼저다 . public Lotto(final List&lt;LottoNumber&gt; value) { // 중복검사(distinct.count != )보다 갯수검사(size != )가 선행되어야 한다. // (1) 일단 6개가 들어오고 -&gt; 거기서 중복검사 해야한다. // (2) 7개가 들어왔는데 -&gt; 중복검사 해봤자 의미 없다. if (value.size() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개여야 합니다.&quot;); } if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 중복해서 입력할 수 없습니다.&quot;); } this.value = value; } . | 또다시 기존 메서드 유지되도록 전체복사후 인자만 바꾼(list-&gt;포장) 새 기준메서드만들고 -&gt; 에러해결(.getValue()) -&gt; client 호출 변경 . 복붙후 파라미터 변경 . public static int start(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { . | **내용물들은 일단 list에 난 빨간줄을 .getValue()를 붙여서 해결한다. ** . 나중에 도메인 로직으로 들어갈 후보들이다. . 도메인에 넣으면 getter없이 바로 value를 쓰게 된다. | . . | 앞에 getter를 붙이면 빨간줄이 사라진다. . . | . List.of(단일, 객체, 들)을 모두 new일급() 다싼 뒤 -&gt; List&lt;단일&gt;메서드의 파라미터 . | 06 새 기준(일급) 메서드 에러 제거(getValue()) 후, 도메인(일급)에 [필요에 의한 검증(갯수)]시 에러나도록 도메인 검증 작성 -&gt; 메서드 테스트로 퉁치기(일급자체 테스트는 client배려로 test도 배려되면) . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), new Lotto(List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6))), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class) } . 아직!) 일급자체Test List.of() 제거된 가변인자 등의 client 배려(내려가며 생성자 추가) 끝나고 일급 도메인 테스트 하자! . 07 새 기준 메서드(일급이 파라미터, 수정 등 적용 대상) 완성 -&gt; 기존 메서드의 내부에서 포장해서 새기준을 호출하도록 변경 . 변경 전: 파라미터는 포장 전인데, 모든 로직이 다 있는 상태 . | 변경 후: 일급을 파라미터로 받는 이후 수정 등이 적용될new 기준 메서드을 내부에서 호출하도록, 파라미터만 유지해서 기존 테스트코드들 유지 . public static Rank match(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { // 이제 로직은 새 기준메서드에 양보됨. // 새 기준 메서드(포장객체)를 내부에서 호출만 해줌. return match(new Lotto(userLotto), new Lotto(winningLotto), bonusNumber); } . | . 08 client배려1) 메서드 이전 [단일... 가변인자 일급 생성자를 추가]하는데, client List.of ()입력 제거 -&gt; List&lt;단일&gt; to 단일... 파라미터 -&gt; 내부에서 list포장후 기본생성자 호출 . 현재 client 호출 . LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), . | . 일급의 기본 생성자는 그대로 단일List + 검증로직을 보유하고 있는다. . 기존 일급 기본 생성자: 단일List + 검증 로직이 모여있다. 계속 유지되어서 호출되어야한다. . public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . | . client배려 1번은 호출시 clinet가List을 제거하고 -&gt; 파라미터에 가변인자를 받도록 한 뒤 -&gt; 내부에서는 가변인자(배열)을 List로 포장해서 this()로 호출하도록 일급 생성자 추가 . . 추가된 일급의 가변인자 생성자 . public class Lotto { private final List&lt;LottoNumber&gt; value; //단일객체를 가변인자로 받도록 생성자 추가 public Lotto(final LottoNumber... value) { this(Arrays.stream(value).collect(Collectors.toList())); } public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . | . 요약: 기본생성자(단일객체List + 검증) 외에 가변인자(단일객체...) 생성자를 만들어 client의 List.of()호출부터 제거하자. . 가변인자로 내부에서 List화 -&gt; client List.of()가 제거된 모습 . LottoService.start( new Lotto(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), . | . 09 client배려 2) 단일... 가변인자 일급생성자 직후 바로 값... 가변인자 일급생성자를 추가한다. . new 일급( List.of( 단일, 객체) ) new 일급( 단일, 객체 ) : by 단일... 가변인자 + stream List포장 후 this기본생성자 호출 new 일급( 값1, 값2 ) by 값.. 가변인자(int라면 Integer…) + stream map단일객체생성 -&gt; List포장후 this기본생성자 호출 | . | . | 단일… 가변인자 -&gt; 단일객체stream -&gt; 단일객체List가운데 단일객체stream을 값... 가변-&gt; 값 stream + map으로 만들수 있으니 값… 가변 생성자도 추가 . public class Lotto { private final List&lt;LottoNumber&gt; value; //2. new Lotto( 원시값, 가변으로) -&gt; List.Of() + new단일()생성자 제거 public Lotto(final Integer... value) { this(Arrays.stream(value).map(LottoNumber::new).collect(Collectors.toList())); } //1. new Lotto( 단일객체, 가변으로) -&gt; List.Of제거 public Lotto(final LottoNumber... value) { this(Arrays.stream(value).collect(Collectors.toList())); } public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . | . . stream에서 mapToObj가 뜨는 이유는 integer가 아닌 int -&gt; 객체로 가기 때문 -&gt; 애초에 파라미터로 들어오는 원시값들을 int… 대신 Integer...로 box된 타입으로 받을 수 있다. . . 이제 원시값으로 일급을 만들 수 있게 된다. . . 요약: 값... 가변-&gt; 값 stream + map으로 단일... -&gt; 단일객체stream을 만들수 있으니 값.. 가변인자 생성자 추가해서 clinet의 단일...가변입력도 값... 입력으로 대체하자 . 메서드 테스트로 퉁 | . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1,2,3,4,5,6), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class); } . 요약2: 메서드 파라미터 포장이 끝난 직후부터, client배려1 List.of 제거 by 단일... -&gt; client 배려2 new단일() 제거 by 값... . 10 일급자체(경계값)Test는 client배려1,2가 끝난 뒤 -&gt; new 일급 ( 값 가변인자) 로 하면 편하다 . 개수(count) 검사 -&gt; 중복(duplicate) 검사 순으로 . @Test void count_valid() { assertDoesNotThrow(() -&gt; new Lotto(1, 2, 3, 4, 5, 6)); } @Test void count_under() { assertThatThrownBy(() -&gt; new Lotto(1, 2, 3, 4, 5)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } @Test void count_over() { assertThatThrownBy(() -&gt; new Lotto(1, 2, 3, 4, 5, 6, 7)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } @Test void duplicate() { assertThatThrownBy(() -&gt; new Lotto(1, 1, 3, 4, 5, 6)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } . 11 메서드 내부 일급.getValue()는 메서드화하여 도메인내부 로직으로 옮겨갈 후보들 . 일급.메서드( 객체 )로 메세지를 던질 때, 일급을 좌항(메서드 호출하는 놈) 우항에는 내부 찢어질 일급 or 단일(파라미터)을 배치하여 value.list메서드()를 사용하며, 재활용 가능성을 생각하자. . 일급.getter vs 일급 or 일급.getter vs 단일 로직이면 메서드화해서 도메인 로직으로 옮겨가는데, 일급vs일급부터 처리한다. . 일급.메서드( 찢일 or 단일) -&gt; value(일급내부 list).입장에서 넘어온or넘어와돌고있는 단일을 List(value)의 메서드로 컨트롤할 수 있다. | . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { //일급내부list. list메서드 ( 단일 ) if (value.contains(lottoNumber)) { matchCount += 1; } } return matchCount; } . | 일급.getter() vs단일이 외부에 존재했다면 메서드화 하면 . value. list메서드( 단일 )로 내부정의 되므로 일급vs일급 중 value.list메서드( 돌고있는 단일)로 메서드가 재활용 될 가능성이 있으니 잘 확인해서 대체해주면 된다. | . public boolean contains(final LottoNumber number) { return value.contains(number); } . | . 일급.list메서드( 단일 )의 메서드가 추가된다면, -&gt; 내부 상태(value)를 사용하는 내부 정의 메서드인 객체없이 호출되는 메서드가 value.list메서드( 단일 )을 대체한다. . value.contains( lottoNumber ) -&gt; contains(lottoNumber) . 객체없이 호출되는 메서드가 있다면 내부에서 정의된, 내부 상태(value)를 이용하는 메서드로 생각하자. (this.)value가 쓰이는 메서드구나 | . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { //if (value.contains(lottoNumber)) { // 객체없이 호출된다? 내부상태가 쓰이는 내부 정의 메서드구나~! if (contains(lottoNumber)) { matchCount += 1; } } return matchCount; } . | . 응답값 포장 . 12 응답값도 포장할 수 있다. 만약, 제한된 종류 + if분기마다 달라지는 응답값라면 ENUM응답 포장후 응답에 필요한 input들로 정펙매 를 호출한 뒤 내부로 분기 옮겨 응답한다. 이후 if분기를 처리해줄 &lt; input-&gt;필드들 - 응답값&gt;을 매핑한다. . int를 포장한 뒤 -&gt; 관련된 if분기 로직을 포장한 도메인으로 넘기면, 메서드 if문이 사라진다., | . . 제한된 종류의 응답 값포장은 Enum을 활용한다. 메서드 응답을 빨간줄로 바꿔 생성하자. . 만약, 제한되지 않았다면? class Rank로, 현재는 제한된 종류의 값 응답이므로 Enum으로 매핑해서 if를 대신하게 해보자. . . | 연속된 상수라면, Enum명_ 순서를 활용하면 된다. . 1,2,3,4,5등 -&gt; 등을 Enum으로 만들고 등_1,2,3,4,5; 로 선언해보자. | . package lotto; public enum Rank { RANK_1, RANK_2, RANK_3, RANK_4, RANK_5; } . | . 13 응답에 대한 분기로직을 어떻게 응답class/응답Enum으로 넘길까? . . 메서드 응답부에서 원하는 포장된 응답값인 Enum객체을 뽑아 응답해주는 return Enum.정펙매of (,)완성하기 . 결과적으로 정펙매인 Enum.from() or Enum.of( , , )로 Enum객체를 응답해야한다. . 원하는 Enum객체가 응답될 수 있도록 필요한 인자들을 생각해서 받아들인다. | 실제로 입력값이 될 것들을 가지고 있는 사용부인 메서드 응답부에서 부터 시작 | . | . 응답부에서 Enum.정팩메로 해당하는 포장응답값을 return해 줄 예정이다. . 필요한 input들이 뭐가 있는지 살펴본다. | 메서드호출의 결과값이 있다면, input이 명확하도록 따로 변수로 뽑아주자. | . . 정팩메로는 Enum이라는 포장된 응답값을 가져올 것이기 때문에 return과 같이 작성한다. | . . | 값 응답 로직을 -&gt; 포장응답값 정펙매로 잘라내서 처리하기 . 이제 값 응답로직을 그대로 잘라붙혀넣기 한다. . 이동후 | . . | 14 정팩메 내부로 옮긴 분기에 대해, 응답[값]들을 [Enum객체]로 수정해주기 -&gt; 없는 값(0, None)에 대해서도 OUT,NONE객체 만들어서 응답해주기 . 아직 바꾸기 전 응답로직 . if (matchCount == 6) { return 1; } if (matchCount == 5 &amp;&amp; matchBonus) { return 2; } if (matchCount == 5) { return 3; } if (matchCount == 4) { return 4; } if (matchCount == 3) { return 5; } return 0; . | 수정 + NONE객체 추가후 . package lotto; public enum Rank { RANK_1, RANK_2, RANK_3, RANK_4, RANK_5, OUT; public static Rank of(final int matchCount, final boolean matchBonus) { if (matchCount == 6) { return RANK_1; } if (matchCount == 5 &amp;&amp; matchBonus) { return RANK_2; } if (matchCount == 5) { return RANK_3; } if (matchCount == 4) { return RANK_4; } if (matchCount == 3) { return RANK_5; } return OUT; } } . public static Rank match(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { final int matchCount = userLotto.match(winningLotto); final boolean matchBonus = userLotto.contains(bonusNumber); return Rank.of(matchCount, matchBonus); } . | . 15 메서드 [포장된 응답] 테스트 작성하기 . 여러분기므로 1case에 대한 -&gt; 1예상값 마다 테매를 작성해야한다. . @Test void match_1() { //given, when final Rank rank = LottoService.match( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1, 2, 3, 4, 5, 6), new LottoNumber(7) ); //then assertThat(rank).isEqualTo(Rank.RANK_1); } . 16 if분기를 enum정팩매 내부 values().stream+filter( 정펙매input vs 매핑값과 비교 조건식)으로 제거하기 . 정팩메 input으로 들어올 데이터들 中 1개를 골라 (매핑 예정인) Enum객체의 필드로 넣어준다. . 정펙매로 여러 데이터가 들어와 사용가 들어오지만 of( matchCount, matchBonus) . . 매핑에 사용될 쉬운 변수 1개만 선택하여, 정펙매 내부 values().stream.filter 분기에서 비교할 것이다. Enum객체가 필드로 가지고 있으면 되며, 그 필드 기준으로 매핑값도 차후 배정된다. | . | . 쉽게 Enum의 필드에 넣기 위해서는 일단 ENUM(1) 객체 옆에 빨간줄로 원시형 예제작성해준다. . . | 생성자를 생성해주면서 input과 똑같이 네이밍후 빨간줄 this.필드명 = 필드; 초기화를 이용해서 필드를 생성한다. . . . . | 나머지 객체도 데이터를 넣어준다. . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0); private final int matchCount; Rank(final int matchCount) { this.matchCount = matchCount; } public static Rank of(final int matchCount, final boolean matchBonus) { if (matchCount == 6) { return RANK_1; } . | Enum정팩메 내 [제한된종류의 모든 if분기]를 values().stream + filter with input vs 매핑field로 분기 없애기 . 특수한 경우, 정팩매에서 ENUM매핑값 뽑기도 전에, early return해준다. . 특수한 경우로서 2등과 3등을 먼저 필드는 안됬지만 사용해야하는 변수 matchBonus로 홀로 true인 2등을 early return한다. . public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } . | . Enum내에서 values()는 Enum객체배열을 응답하며 거기에 배열.stream자동완성 사용하여 EnumStream 만들어 객체전체를 돌리기 . . . . 제한된 종류의 if분기를 values().stream (for) + filter(it -&gt; input vs 매핑field 비교) 대체하기 . public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); . 기존 if분기들 이제 삭제 | . enum sense: 각 enum객체끝은 마지막도 콤마(,) 그 다음라인(;) + .findAny()후 .orElse( NONE객체 ) . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0), ; . return Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); . 17 Bi(비.아이.) Predicate&lt; , &gt;로 input된 2개 값을 다 사용하는 1개의 람다식필드 &amp;&amp; filter속 예비 조건식(.test(a,b)로 실행)을 만들어 -&gt; [enum의 1 필드 매핑]에 사용되는 Type을 함수형인터페이스로 사용하여 -&gt; 정펙매 내부 들어오는 2개값 모두 사용하는 enum 만들기 . BiPredicate Type은 1개 함수를 가진 인터페이스 = 함수형 인터페이스 중 2개 인자를 받아 실행대기 중인 조건식을 제공해주고 -&gt; .test( a, b)를 통해 외부인자를 받아서 조건식을 실행한다. .test(a, b)에 정팩메로 들어온 input2개를 넣어주면 된다. | . | . 아직 BiPredicate 적용안한 기존 코드 (상금도 매핑 안된 상태) . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0), ; private final int matchCount; Rank(final int matchCount) { this.matchCount = matchCount; } public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } return Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); } } . Enum필드에 2인자 람다식인 BiPredicate를 넣어서 생성하기 . 이번엔 Enum()객체안에 input 중 1개 6,5,4.. 대신에 input 2필드 다 써서 1개 람다식을 만들어 예제로 넣어주자. 이왕이면 다중커서로 한번에 다 입력해주자. | . | 아쉽게도 BiPredicate는 직접 필드입력 -&gt; private final 필드 변수 생성 -&gt; 생산자 자동완성로 가야한다. (원래는 예제 -&gt; 생산자 -&gt; 빨간줄 this.필드 생성) . 원래 객체( 원시값 등 쉬운 Type)을 빨간줄 필드로 넣으면, 생성자에 파라미터 공짜 -&gt; this.로 필드 공짜 생성 | . BiPredicate 작성 . 받은 인자 2개는 if분기에 쓰였던 input값 2개다. -&gt; 원래 Enum의 매핑 쉬운 상수 응답값 6, 5, 4...와 비교해야한다. | . public enum Rank { RANK_1(((matchCount, matchBonus) -&gt; matchCount == 6)), RANK_2((matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; matchBonus), RANK_3((matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; !matchBonus), RANK_4((matchCount, matchBonus) -&gt; matchCount == 4), RANK_5((matchCount, matchBonus) -&gt; matchCount == 3), OUT((matchCount, matchBonus) -&gt; matchCount &lt; 3), ; . | 필드 직접 입력 private final . 제네릭 타입은 들어올 인자들의 Type(정팩메로 들어올 Type)을 Boxing한 타입 + 네이밍은 condition으로 실행될 조건식임을 인지시킴 | . private final BiPredicate&lt;Integer, Boolean&gt; condition; . . | 생성자 자동완성 . | values().stream + filter분기에서 .test( , )로 정펙매 인자를 받아 조건식 실행 . public static Rank of(final int matchCount, final boolean matchBonus) { return Arrays.stream(values()) .filter(it -&gt; it.condition.test(matchCount, matchBonus)) .findAny() .orElse(OUT); } . 18 응답값의 포장(리팩토링)이 다 끝났으면, 자체 도메인Test(Enum은 정펙매 테스트) . @Test void rank_1() { final Rank rank = Rank.of(6, false); assertThat(rank).isEqualTo(Rank.RANK_1); } @Test void rank_2() { final Rank rank = Rank.of(5, true); assertThat(rank).isEqualTo(Rank.RANK_2); } @ParameterizedTest @CsvSource({&quot;5,false,RANK_3&quot;, &quot;4, false, RANK_4&quot;, &quot;3, false, RANK_5&quot;}) void rank_3_5(final int matchCount, final boolean matchBonus, final Rank expected) { final Rank rank = Rank.of(matchCount, matchBonus); assertThat(rank).isEqualTo(expected); } .",
            "url": "blog.chojaeseong.com/java/enum/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/07/TDD-5-%EB%A1%9C%EB%98%90(Service.method%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91).html",
            "relUrl": "/java/enum/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/07/TDD-5-%EB%A1%9C%EB%98%90(Service.method%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91).html",
            "date": " • Mar 7, 2022"
        }
        
    
  
    
        ,"post12": {
            "title": "강의) 네오 2단계 로또 피드백",
            "content": "세팅 . 패키지 생성 (각종 설정 후) . 프로젝트 생성 했다면 . main&gt;java와 | test&gt;java 밑에 패키지 생성(lotto)부터 해주기 | . | 시작점 고르기 (game, service) . 시작점 찾기 로또번호부터 구현할 수 있느냐? | 로또부터? | 정제된 rawInput을 받은 Game, Service부터 구현해서 객체/도메인도출을 천천히 처음부터 객체 도출은 어려울 수 있다. | . | . | Service method TDD . run()테메에서 static한 Service.start()메서드로 메인흐름 시작하기 . LottoServiceTest를 만들고 . | 테스트 메소드명도 편하게 run() . | Service클래스의 static메소드명도 run() start()로 만들면서 시작한다. . . | 요구사항에 따른 [정제 rawInput]을 Controller내 service가 가정 인자로 사용하여 -&gt; Service 흐름 시작하기 . 테스트해야하므로 메인흐름을 가진 메서드는 controller로 응답까지 해줘야한다. . service는 상태를 안가지므로 객체 - 예상객체 비교X, 응답값 - 예상값으로 비교해야한다. | . public class LottoServiceTest { @Test void run() { //사용자의 로또번호 //당첨번호 // 보너스번호 // -&gt; 당첨 등수 응답 LottoService.start(); } } . 로직에 필요한 인자(정제된 input)를 가상으로 넣어주기 | . LottoService.start( List.of(1, 2, 3, 4, 5, 6), List.of(1, 2, 3, 4, 5, 6), 7 ); . 로직결과로 응답까지 해줘야 테스트가 된다. | . | . 가정인자에 따른 1 case만 1응답하도록 짠 뒤 테스트 . 가정인자( 6개 일치) = 1case를 넣어줬으니 -&gt; 1응답을 반환하도록 일단 1 case만 짠다. . 테스트할 메서드는 처음에는 무조건 응답되도록 void를 수정한다. 어떤 형으로 응답할지를 생각해서 정의시 기입한다. . . | 3개이상의 긴 인자는 콤마 다음부터 내려서 이쁘게 정리해주자. . public class LottoService { public static int start(final List&lt;Integer&gt; integers, final List&lt;Integer&gt; integers1, final int i) { } } . public class LottoService { public static int start(final List&lt;Integer&gt; integers, final List&lt;Integer&gt; integers1, final int i) { } } . | 메서드 파라미터 이름을 바꿔준다. . | 아직 도메인을 몰라서 클래스로 분리 못하겠다면, 메인 로직을 rawInput 가지고 짠다. . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { } } . | 1case에 대한 1응답을 해주는 로직을 완성한다. . if가 포함된 1응답이라면, return 0; 같은 default 응답도 넣어준다. | . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { // 몇개 일치하는지 돌면서 누적시켜야한다 // - 돌아가야하는 놈을 우측 파라미터+for문에 // - 전체를 가지고 contains 확인해야하는 놈을 좌변에 int matchCount = 0; for (Integer lotto : userLotto) { if (winningLotto. contains(lotto)) { matchCount += 1; } } // 일단 가정 인자에 따른 1 case통과 코드만 짠다. // 나중에는 matchCount 갯수에 따라 싹다 분기해서 응답해야한다.(리팩 대상) if (matchCount == 6) { return 1; } return 0; // 1case 응답인데, if를 포함해서 응답했다. -&gt; 1외 default return 0;도 해주자. } . | 1응답이 나오는지 test한다. . public class LottoServiceTest { @Test void run() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, 6), List.of(1, 2, 3, 4, 5, 6), 7 ); assertThat(rank).isEqualTo(1); } } . | [테메] 복붙후 2case에 맞게 가정인자+예상값 바꾼 테스트 메서드 만들기 . 복붙 전, 각 case로 테메명 바꿔주고 난 뒤 복붙하기 . 현재 run()으로 되어있는 테스트메서드명을 case를 반영해서 바꿔주고 난 뒤 복붙 . 복붙하는 이유: 기존 테스트가 계속 돌아가도록 하기 위함. | . @Test //void run() { void rank1() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, 6), List.of(1, 2, 3, 4, 5, 6), 7 ); assertThat(rank).isEqualTo(1); } . | . 복붙후 가정인자+예상값을 2case에 맡게 수정 . 1등 반환case 1개 이후에는 -&gt; 복붙후 가정인자를 바꾼 case변경을 하면서 새로 짜야한다. . 테스트메서드 명을 case에 맡게 복사해준다. | 가정인자 및 예상값을 -&gt; 2case에 맞게 수정해준다. | @Test void rank2() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, 6), List.of(1, 2, 3, 4, 5, 7), // 2등에 맞게 가정인자 수정 6 // 2등에 맞게 가정인자 수정 ); assertThat(rank).isEqualTo(2); // 2등에 맞게 예상값 수정 } . | [메서드 복붙]후 2case 예상값을 응답하도록 메서드2를 수정 . 메서드2로 복붙한다. . 단축키 shift + alt + → 및 ↓를 활용해서 복사하고 | 단축니 shift + alt + F로 정렬해서 | . public static int start2(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { . | 메서드2가 case2예상값을 만들도록 짠다. . public static int start2(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { int matchCount = 0; for (Integer lotto : userLotto) { if (winningLotto.contains(lotto)) { matchCount += 1; } } if (matchCount == 6) { return 1; } if (matchCount == 5 &amp;&amp; userLotto.contains(bonusNumber)) { return 2; } return 0; } . | 테메2가 메서드2를 사용하도록 수정한 뒤 테스트한다. . @Test void rank2() { final int rank = LottoService.start2( . | [기존 테메]도 [메서드2]로 돌아가는지 확인한다. . @Test void rank1() { final int rank = LottoService.start2( . [메서드2]를 [메서드]로 완전히 대체한다. . 기존 메서드 회색 비활성화된 메서드를 안전삭제(alt+del)한다. | 메서드2 -&gt; 메서드(F2 2번)로 이름을 바꿔서 완전히 대체한다. | [2case이후 테메]는 복붙후 한번에 처리해보자. . [다case]테메명 + @ParaemeterizedTest를 통해 가정인자+ 예상값들을 변경시키며, 그에 맞는 응답을 하도록 [메서드 원본]을 수정해서 통과되도록 만들자. . 가정인자가 2개, 예상값 1개, 총 3개 인자가 case에 따라 바뀐다. . List.of() | bonusNumber . | expected | @CsvSource 혹은 @MethodSource를 통해 여러 파라미터를 받아야한다. . @ParameterizedTest @MethodSource(&quot;provideWinningLottoAndExpected&quot;) void rank3_to_5(){ . public static Stream&lt;Arguments&gt; provideWinningLottoAndExpected() { return Stream.of( Arguments.of(List.of(1, 2, 3, 4, 5, 7), 8, 3), // 3등 Arguments.of(List.of(1, 2, 3, 4, 7, 8), 9, 4) , // 4등 Arguments.of(List.of(1, 2, 3, 7, 8, 9), 10, 5) // 5등 ); } . @ParameterizedTest @MethodSource(&quot;provideWinningLottoAndExpected&quot;) void rank3_to_5(final List&lt;Integer&gt; winningLotto, final int bonusNumber, final int expected) { // 파라미터 추가 + 가정인자/예상값 다 변경 -&gt; 테스트시 에러나야 정상 final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, 6), winningLotto, bonusNumber ); assertThat(rank).isEqualTo(expected); } . | 바뀐 가정인자 + 예상값에 대응하도록 원본 메서드를 1,2case에 비추어 수정 . if (matchCount == 6) { return 1; } if (matchCount == 5 &amp;&amp; userLotto.contains(bonusNumber)) { return 2; } if (matchCount == 5) { return 3; } if (matchCount == 4) { return 4; } if (matchCount == 3) { return 5; } . | service 메서드 완성후 회고 . 여기까지 통과시키고 난 뒤, 가정인자로 들어오는 놈들에 대해 도메인 지식이 쌓였을 것이다. 가정인자로 들어오는 List에 대해 개별Integer는 개별 객체 LottoNumber라는 객체로도메인 분리할 수 있겠다. | LottoNumber List 6개를 모아서 Lotto라는 객체로 도메인 분리모아볼 수 있겠다. | . | . 구현된 Service method의 가정인자 리팩토링 . 도메인 지식을 높이기 위해서, 가정하고 넣어주는 인자가 rawInput인체로 빨리 돌아가기만 하는 코드를 짠 상태다. . | 유지보수, 계속 봐야하는 코드라면 리팩토링해야한다. . | . 입력인자 예외처리에 의한 도메인 추출 인지 . 테스트코드가 가정인자+예상값의 변화 없이 개별 도메인 생성자 호출자체에서 문제이기 때문에, 개별도메인으로 가서 테스트 된다. | . [입력인자] [가장 작은 단위]의 숫자(로또번호)가 범위를 벗어나는 경우 . 기존 rank1~5 테스트라도 복붙해서 메서드명을 over로 바꿔고 범위를 벗어나는 경우에 대한 가정인자 + 예상값이 아니라 user입력인자를 바꿔서 만들어주자. . 사용자 입력에 대한 예외에 대한 테스트의 경우, service메서드의 가정인자 변화가 문제가 아니라 입력인자에 실수가 반영된 것이기 때문에 객체로 도메인 분리해서 도메인 검증해야한다. | . @Test void over() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, 100), // 사용자 입력인자만 예외인자로 변화 -&gt; 100 입력 List.of(1, 2, 3, 4, 5, 7), // 가정인자 변화X 6 ); assertThat(rank).isEqualTo(2); // 예상값 변화X } . | [입력인자] 가장 작은 단위가 상호작용한 [일급]에서 중복 문제 . 테메 복붙후 이름변경duplicate . | 입력인자에서 중복이 되도록 입력 . 예외 테스트 는 가정인자 + 예상값의 변화가 없는 상태임. | . @Test void duplicate() { final int rank = LottoService.start( List.of(1,1,1,1,1,1), // 사용자 입력인자만 예외인자로 변화 -&gt; 1이 list내 중복 됨. List.of(1, 2, 3, 4, 5, 7), // 가정인자 변화X 6 ); assertThat(rank).isEqualTo(2); // 예상값 변화X } . | Service.메서드() 사용시 발견된 값들의 예외처리 -&gt; 개별 도메인에서 테스트하면서 처리되어야함. . 도메인을 풍부하게 -&gt; 도메인으로 추출 분리후 도메인 내에서 검증 . | 서비스메서드 사용하면서, 그 service(메인로직) 흐름내에서 if로 하지말자. 자기 도메인내에서 if없이 개별로 처리되어야한다. . 잘못된 예(service에서 인자로 넘어온 도메인들의 예외처리) | . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { if (userLotto.get() &gt; 45) { throw new IllegalArgumentException(&quot;범위 초과&quot;); } . | . 메서드인자 리팩토링1) 최소단위 값 검증 때문에 포장하도록 Service.메서드() 수정 . Service.메서드() [최소단위 값] 1개만 new 생성자()로 싸서, Class와 ClassTest를 정의 . Service.메서드() 로직을 사용하던 곳에서 예외발생 상황을 가정했던 곳에서 new 생성자()를 씌워서 Class -&gt; ClassTest까지 만들어보자. . @Test void over() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, new LottoNumber(100)), // 검증이 필요한 곳 -&gt; class로 도메인분리 -&gt; 생성자부터 씌워서 만들어나가기 . | 값을 1개만 포장하는 경우, 변수명을 value로 잡아서 getValue()등 이름을 어색하지 않게 하자. . 생성자로 클래스 생성후, 상태값 직접 지정해줘야한다. | . package lotto; public class LottoNumber { public LottoNumber(final int value) { } } . public class LottoNumber { private final int value; public LottoNumber(final int value) { this.value = value; } } . | classTest도 바로 만들기 . class LottoNumberTest { } . | Service.method()의 [포장]된 [입력인자]버전의 메소드를 만들기 위해 메소드1복붙 . 기존테스트를 통과하는 메소드2의 개발이 아니라 인자가 달라지는 동일명의 메소드를 개발하는 것이므로 메소드명 동일하게 복붙한다. . 기존 포장안한 테스트가 그대로 통과한 상태를 유지할 수 있다. | 포장이 실패할시 바로 돌아갈 수 있다. | 메소드2로 지어도 상관없을 것 같긴하다. | . . | . 메소드 파라미터 정의를 원시형 -&gt; 포장형으로 바꿔주기 . 메소드의 파라미터 정의부를 원시형을 모두 포장 형으로 바꿔준다. . int, Integer -&gt; LottoNumber | . public static int start(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { . | 내부도 다 타입을 바꿔준다. . 에러가 안나는 듯 하지만, 포장class에서도 기본 제공되는 contains()는 비교/포함여부 되려면 equals/hashCode가 오버라이딩 되어있어야 에러가 안난다. | 최소단위 포장은 equals/hashCode생각 | . public class LottoService { public static int start(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { int matchCount = 0; for (LottoNumber lotto : userLotto) { if (winningLotto.contains(lotto)) { matchCount += 1; } } . | 포장용 Service메소드에서 사용되는 값들 모두 포장해서 전달해주기 . 현재 생성을 위해 1개만 포장된 상태다. 수동으로 다 포장해줘야한다. . @Test void over() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, new LottoNumber(100)), // 사용자 입력인자만 예외인자로 변화 -&gt; 100입니다. List.of(1, 2, 3, 4, 5, 7), // 가정인자 변화X 6 ); assertThat(rank).isEqualTo(2); // 예상값 변화X } . 포장 후 | . @Test void over() { final int rank = LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5),new LottoNumber(100)), List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5),new LottoNumber(7)), new LottoNumber(6) ); assertThat(rank).isEqualTo(2); // 예상값 변화X } . | Exception 나는 것을 의도하여 포장했다면 에러가 나야한다 assertThat -&gt; assertThatThrownBy()의 테스트 코드 바꾸기 . 응답 vs 예상값비교 구조에서 () -&gt; exception발생구조로 테스트메서드를 바꿔주자. . @Test void over() { assertThatThrownBy(() -&gt; LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(100)), List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(7)), new LottoNumber(6) )).isInstanceOf(IllegalArgumentException.class); } . | 포장한 도메인 생성자에 예외처리 검증 넣어주기 . 예외 발생 안했다 -&gt; 예외발생시키는 검증을 도메인에 넣어준다. . public LottoNumber(final int value) { validate(value); this.value = value; } private void validate(final int value) { if (value &lt; 1 || value &gt; 45) { throw new IllegalArgumentException(&quot;로또 번호의 범위가 아닙니다.&quot;); } } . | [Service.method()에서의 검증]이 끝났으면 [단일 도메인에서 본격 검증]하러 classTest로 직접가서 [경계값 테스트]하기 . 시간 관계상 Service.method()에서 통채로 테스트하지만, 포장ClassTest에서 직접 경계값 주위로 테스트해야한다. | . class LottoNumberTest { @ParameterizedTest @ValueSource(ints = {0, 46, -1, 100}) void range(final int value) { assertThatThrownBy(() -&gt; new LottoNumber(value)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;범위&quot;); } } . 예외 발생을 위한 포장 회고 . Service.메서드()에서 테스트했지만, LottoNumber로는 더이상 over되는 번호는 오지않겠구나. 심리적 안정감을 얻었다. | . | . 포장 입력인자 메소드 사용시 애로사항 . Service.메서드() 사용시 모든 원시값을 new 포장( )으로 일일히 감싸줘야한다. . LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(100)), List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(7)), new LottoNumber(6) )); . | 포장된 입력인자가 아니라 -원시값 입력인자를 그대로 사용하되, 메소드 내부에서 한꺼번에 포장객체로 변환시키자 . | . [정제된 rawInput을 받던 테매들이 사용하던 service.method()] 내부 개조로 한번에 포장해서 포장인자 메서드 호출해주기 . 기존에 작성된[ 정제된 rawInput을 받던 메소드]의 내용물은 삭제 . 기존 테스트를 위해 정제된 원시값을 받던 메소드 . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { int matchCount = 0; for (Integer lotto : userLotto) { if (winningLotto.contains(lotto)) { matchCount += 1; } } . | . 원시값 인자 네이밍 -&gt; 내부stream으로 한번에 포장 -&gt; return 포장 인자 메서드() 호출 . **기존 내용물은 삭제(포장된 것으로 처리되도록 통일해야됨) ** . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { } . | **원시값 인자 +raw네이밍 붙이기 ** . 각 원시인자 기존 네이밍 -&gt; 포장인자로 갈 때 기존 네이밍으로 받아줘야 -&gt; ``포장메서드 호출시 기존 네이밍으로 가기 때문에 **원시 인자 네이밍 앞에 raw`를 붙혀준다** | . public static int start(final List&lt;Integer&gt; rawUserLotto, final List&lt;Integer&gt; rawWinningLotto, final int rawBonusNumber) { } . return 포장된 인자를 받는 새 메소드()호출 응답은 그대로 나가야하므로 return 유지 | . | . public static int start(final List&lt;Integer&gt; rawUserLotto, final List&lt;Integer&gt; rawWinningLotto, final int rawBonusNumber) { final List&lt;LottoNumber&gt; userLotto = rawUserLotto.stream() .map(LottoNumber::new) .collect(Collectors.toList()); final List&lt;LottoNumber&gt; winningLotto = rawWinningLotto.stream() .map(LottoNumber::new) .collect(Collectors.toList()); return start(userLotto, winningLotto, new LottoNumber(rawBonusNumber)); } . | . 의의: Service를 사용하는 client를 편안하게 해줘야한다.(내부로 가기전에 포장해서 호출해주는 놈이 있다면) = client는 원시값도 입력받아 도메인은 모르게 해주는게 낫다 . client쪽, view쪽, 중요하지 않은쪽, 잘변하는 쪽은 도메인, 포장값 사용없이 원시값으로만 service.메서드()를 호출하고, 내부에서 포장 좋다. 포장을 서비스내에서 한번 거쳐서 하는 방법을 여기선 안내해줬다. | 원래 중요하지 않은쪽이 -&gt; 중요한 것을 생성/사용/리턴하는 방향은 허용된다. | . | 생각이 다를 수 있다. 외부에서 무조건 감싸서 로직에 보내줘야한다라고 생각할 수도 있다. | but 사용하는 client입장에서는.. 내부포장으로 편안한게 좋다 | . | my) controller에서 도메인 사용해도 되지만 내부 포장만 해주는 로직이 따로 존재한다면, 원시값을 넘겨도 될 듯? | . | . 메서드 인자 리팩토링2) 최소단위 [묶음]의 예외 처리 -&gt; 일급 포장하여 검증 . 초과된 [포장 최소단위의 갯수 문제] -&gt; [포장인자 메소드]를 가진 [테매]를 복붙하여 Exception 발생시키기 . 현상황에서 포장인자를 받던 메소드를 복붙하여 포장객체의 갯수 문제를 발생시켜보자. . 아무래도.. 최소단위객체의 범위문제에서 작성된 메소드를 복붙해서 고쳐야함… | . @Test void lotto7() { assertThatThrownBy(() -&gt; LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6), new LottoNumber(7)), // 갯수 초과 List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6)), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class); } . | 갯수를 초과했음에도 불구하고 아직 묶음에 대한 검증이 안되기 때문에 예외발생이 안된다. . . | 앞에서도 그렇고, 예외처리를 Service.method() 내부에서 if로 편하게 해주고 싶은데, 여기서 하면 모든 인자들에 대한 예외처리가 if로 한곳에 쌓일 것이다. . **각 검증은 도메인 추출된 class를 만들어서 그곳에서 한다. ** | . public static int start(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { // 여기서 갯수처리를 해주고 싶으나.. if (userLotto.size() != 6) { throw new 예외 } // 2번째 인자도 예외처리를 로직실행 메서드 내부에서 인자를 받아서 처리하고 싶으나.. if (winningLotto.size() != 6) { throw new 예외 } // 인자들마다 모든 검증들이 if로 여기(사용메서드)에 쌓여갈 것이다. 따른 검증 역시 여기서 해야한다. . | . [객체의 갯수or중복 등 복수 검증]을 위한 List&lt;도메인&gt;을 포장하는 일급포장의 시작 . 복수검증 문제가 발생하는 곳에가서 new 일급()부터 시작 . Service.method()에서 원시값 List -&gt; 단일객체 List가 인자로 들어가는 곳에서 **new 일급( ) ** -&gt; Class -&gt; ClassTest까지 생성해준다. . @Test void lotto7() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(2), . | 생성자로 들어오는 이름도value로 네이밍하여 생성자에서 초기화 . ClassName. 가 PREFIX인 것 및 .getValue() 생각하기 | . public class Lotto { public Lotto(final List&lt;LottoNumber&gt; lottoNumbers) { } } . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final List&lt;LottoNumber&gt; value) { this.value = value; } } . | 나머지도 List -&gt; 일급으로 들어가도록 service.method수정 . . | 들어오는 포장인자(List&lt;단일&gt;) 메서드 복붙 백업후 -&gt; 일급인자로 받도록 method 파라미터 정의부 개조 . 기존 List&lt;단일&gt;으로 들어오던 메서드 전체를 복붙한다. 기존 테스트 유지?를 위해, 일급으로 바꾸기전 List도 들어올 수 있도록 백업해둔다. ![image-20220305003021893](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220305003021893.png) | . | 기존 List&lt;단일&gt;으로 들어오던 메서드의 파라미터 정의부만 정의해준 일급들어오도록 수정한다. . public class LottoService { public static int start(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { . 수정후 | . public static int start(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { . | 내부 빨간줄 수정 ( 단일List -&gt; 일급으로 인한 -&gt; 기본적으로 앞에 .getValue()의 getter가 요구됨.) . 일단 getter로 다 처리해놓자. 리팩토링 요구됨. 객체 메세지 던져서 통신. . | 상태값을 value로 네이밍해줬어도, .getValue()의 빨간줄을 리팩토링으로 생성 후 return this.value;까지 직접 입력해줘야된다. . . | 앞에 getter를 붙이면 빨간줄이 사라진다. . . | . | 일급용 메서드가 완성되었으면 | [일급 인자를 받는 Service.method()]가 완성되었으면, [일급이라는 도메인 내부 생성자에 단일List간 복수검증]을 넣어준다. . 일급 도메인인 Lotto의 생성자에서 상태값 초기화 전에 검증을 넣어준다. . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final List&lt;LottoNumber&gt; value) { this.value = value; } . 도메인 검증 추가 | . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . | 도메인 생성자에 넣어준 검증(중복) 을, Service.method()의 인자검증으로 통채로 . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), new Lotto(List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6))), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class) } . | 포장(단일)에 포장(일급) 후 client가 너무 불편? -&gt; Client를 배려해줘라. . 일급 생성자가 받는 new일급(List&lt;단일&gt;)의 인자를 -&gt; 단일... 가변인자로 받고 내부에서 List.Of대신 모아주는 포장용 생성자 추가 . 현재 일급까지 포장해야하는 Service메서드 테매 . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), new Lotto(List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6))), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class) } . 인자 1개만 떼서 보기 | . new Lotto(List.of(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), . | [Client] 일급 생성자에 들어가는 List.of() 혹은 Set.of() 제거해주는 -&gt; [메서드내부] 가변인자(알아서 배열) -&gt; this + Arrays.stream().collect(Collectors.toList or toSet ())) ) . client에서 List.of(단일,객체)나 Set.of(단일, 객체)대신 단일객체를 콤마로 나열만 해서 넘겨주면, 알아서 List or Set으로 내부에서 모아주는 . 내부에서 포장해준 뒤, 포장 인자용 메서드를 다시 한번 호출해주는 메서드 파라미터 -&gt; 인자만 복사해서 껍데기 메서드 생성 -&gt; 내부에서 포장후 호출 다시 포장인자메서드를 재호출 | 일급 생성자 -&gt; List.Of, Set.of를 제거하여 생성자를 추가 생성 -&gt; 가변인자를 받도록 정의 -&gt; 배열을 stream collect로 List나 set으로 포장만해서 this( , )로 미리 정의해둔 &amp;&amp; 뒤에 존재하는 포장인자용 생성자 호출 | . | . . . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final LottoNumber... value) { this(Arrays.stream(value).collect(Collectors.toList())); } public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . 이제 new Lotto() 일급의 생성자에서 2가지 다 받을 수 있게 된다. List.of( , ,, ) 대신 -&gt;그냥 , , ,의 가변인자를 넣어줘도 알아서 List로 포장하게 된다. | . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1)), new Lotto(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6)), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class); } . | 가변인자(List.of제거) + 단일객체생성자 제거의 일급 내부에 2번의 포장 생성자도 추가해서 client를 편하게 해주자. . new 일급( ) 생성자에 client에서 List.Of() 제거하고 가변인자만 받도록 내부에서 포장해주는 생성자를 추가해줬었다. . //1. new Lotto( 단일객체, 가변으로) -&gt; List.Of제거 public Lotto(final LottoNumber... value) { this(Arrays.stream(value).collect(Collectors.toList())); } . | 이번에는 client 단일객체 생성자 제거하고 단일객체 생성에 필요한 raw원시값을 가변인자로만 받도록 수정해보자. . stream에서 mapToObj가 뜨는 이유는 integer가 아닌 int -&gt; 객체로 가기 때문 -&gt; 애초에 파라미터로 들어오는 원시값들을 int… 대신 Integer...로 box된 타입으로 받을 수 있다. | . public class Lotto { private final List&lt;LottoNumber&gt; value; //2. new Lotto( 원시값, 가변으로) -&gt; List.Of() + new단일()생성자 제거 public Lotto(final Integer... value) { this(Arrays.stream(value).map(LottoNumber::new).collect(Collectors.toList())); } //1. new Lotto( 단일객체, 가변으로) -&gt; List.Of제거 public Lotto(final LottoNumber... value) { this(Arrays.stream(value).collect(Collectors.toList())); } public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . | 이제 단계별로 생성자를 만들어서, 기존 테스트의 인자들이 모두 돌아가게 만들었다. . 이제 원시값으로 일급을 만들 수 있게 된다. | . . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1,2,3,4,5,6), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class); } . | client입장에서 코드를 사용하게 엄청 편해진다. | . my) 메서드의 [인자만 포장후 호출용 메서드] or 일급 등의 생성자를 [인자만 다르게 정의하고 내부는 포장해서] client를 편하게 만들어줬다. . 가변인자 사용시 주의해야한다. . 가변인자는 배열을 내부적으로 만들어서 사용하기 때문에, 메모리 잇슈가 있을 수 있다. . | 그래서 .of()메서드들은 11개부터 가변인자를 사용하고 10개까지는 인자를 하드코딩으로 받는다. . | . | . 일급 테스트는 Service.Method()에서 완성된 [가변인자생성자] 시리즈가 완성된 후에 해주자. . [Service.method()에서의 단일/일급 퉁치는 검증] + [일급의 포장용 가변인자 생성자] 끝났으면 [단일 도메인Test]에서 본격 [경계값 테스트]하기 . Lotto라는 일급도메인 테스트를 만든다. . . | Service.method()에서 퉁치며 만들던 갯수/중복 테스트를 case별로 테매명에 반영하면서 만들어본다. . 가변인자는 parameter로 내려보내질 못하네 | 갯수먼저 검사 -&gt; 중복 검사 중복부터하면? distinct.count() != 6에서 list의 size검사도 같이 일어나 중복에 걸리게 된다. | . | . @Test void count_valid() { assertDoesNotThrow(() -&gt; new Lotto(1, 2, 3, 4, 5, 6)); } @Test void count_under() { assertThatThrownBy(() -&gt; new Lotto(1, 2, 3, 4, 5)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } @Test void count_over() { assertThatThrownBy(() -&gt; new Lotto(1, 2, 3, 4, 5, 6, 7)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } @Test void duplicate() { assertThatThrownBy(() -&gt; new Lotto(1, 1, 3, 4, 5, 6)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } . | Service.메서드의 이름 수정 . start -&gt; match | . 일급으로 바꿨더니, 서비스 메서드 내부에 도메인 로직이? -&gt; 메서드 분리로 역할 분리 . getter가 있으면 도메인내부로직임을 의심한다. | . 일급vs일급 or 일급vs단일의 로직(도메인 로직-특히 getter써놓은부분)이 Service.method()내부에 있는지 확인한다. getter가 있으면 의심해본다. . Lotto와 Lotto를 비교하는 로직이 보인다. 같은 도메인끼리의 비교를 서비스내에서 할 필요가 없다. 같은 놈끼리는 더더욱 메세지를 보내서 getter의 존재없이 비교되도록 + 도메인을 풍부하게 해준다. . 비교로직을 도메인으로 넣고, matchCount만 받아오자. | . public class LottoService { public static int start(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { int matchCount = 0; for (LottoNumber lotto : userLotto.getValue()) { if (winningLotto.getValue().contains(lotto)) { matchCount += 1; } } . | matchCount는 서비스가 가지고 있어야하는데, 비교해서 누적하는 부분만 도메인 로직이다. . | 서비스내 도메인 로직을 도메인 내부 메서드로 옮긴다. . getter로 꺼내서 억지로 하던 것이, 파라미터로 서로를 비교해도 바로 상태값을 갖다 쓸 수 있다. 일단 옮길 도메인내 메서드부터 만든다. . 서비스에서 갖다쓸 예정이니 서비스에서 빨간줄로 만들어도 될듯? | . . 같은 것끼리의 비교는 other로 파라미터를 네이밍해주자 파라미터 other(일급)이 other.value(같은도메인 getter)로 list가 되면서 찢어진다. | . | . . 돌면서 누적하는 것은 초기화 후 누적하는 폼의 가변변수를 쓸 수 밖에 없다? | . . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lotto : other.value) { if (value.contains(lotto)) { matchCount += 1; } } return matchCount; } . | 포장과정에서 빠르게 처리하여 생긴 포장.getter.메서드()가 서비스메서드내 보인다면, 도메인로직으로 (내부 value.메서드()가 되도록)넘겨준다. . . 서비스메서드내 포장(도메인).getter가 보인다. . 넘겨줄 수 없을까? | getter()를 지워 getValue().메서드를 포장.메서드()로 빨간줄을 생성하여 대체한다. | . . . 파라미터(매개변수) 이름으로 bonusNumbe는 너무 구체적이다. 팀원입장에서 시그니쳐보고 쓸건데, 좀더 추상적이면서, 넓게… 메서드 입장에서는 구체적인 bonus라는 것을 모른다. LottoNumber 역시 클래스랑 완전 동일해서.. value를 일급이 이미썼으니 -&gt; number로 네이밍 해준다. | . . 바깥에서 포장.getValue().contains로 사용됬던 것을 -&gt; 포장.contains메서드 -&gt; 도메인 내부에서 getter없이 value.contains로 사용하도록 만든다. | . . | 서비스로직에 geValue()를 달고 있는 것ㅇ 도메인 로직으로 옮겨가며되면, 포장(도메인).getValue()가 비활성화 되며 -&gt; alt+del로 안전삭제 해준다. . | 일급과 단일의 메서드가 정의됬다면 -&gt; 일급vs일급에서도 사용될 가능성이 있다. . 서비스 로직에 있던 일급.contains(단일)의 메서드가 정의되었다면 . 일급vs단일은 일급내에서 파라미터/우항이 찢어지는 일급vs일급 비교메서드에서 쓰일 가능성이 높다. | . . 정의했으면, 찾아서 대체해준다. | . | 객체없이 호출되는 메서드 -&gt; 순수묶음 or [내부 포장된 변수](현재는 일급을 get한 단일List)가 쓰이는 내부 메서드 . contains( xxx) | (현재 도메인의 포장하는 변수)가 생략된체로 cotains()하고 있구나 생각 | . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { //value:[일급] lotto:찢어진 일급이 돌고 있는 [단일] // [일급 내부] 메서드 contains는 // [일급의 getter(단일List)된 value가 내부에서 쓰이는] 메서드로서, // 들어오는 단일에 대해 [현재 일급의 단일List]가 &lt;파라미터 단일&gt;을 포함하는지 // my) 객체없는 메서드 -&gt; 순수묶음 or [내부 포장된 변수](현재는 일급을 get한 단일List)가 쓰이는 내부 메서드 // if (value.contains(lotto)) { // 객체없이 호출된다? 내부상태가 쓰이는 내부 정의 메서드구나~! if (contains(lottoNumber)) { matchCount += 1; } } return matchCount; } public boolean contains(final LottoNumber number) { return value.contains(number); } . | . 응답값도 포장할 수 있다. 만약, 제한된 종류 + if분기마다 달라지는 응답값라면 ENUM응답 포장후 응답에 필요한 input들로 정펙매 를 호출한 뒤 내부로 분기 옮겨 응답한다. 이후 if분기를 처리해줄 &lt; input-&gt;필드들 - 응답값&gt;을 매핑한다. . int를 포장한 뒤 -&gt; 관련된 if분기 로직을 포장한 도메인으로 넘기면, 메서드 if문이 사라진다., | . . 제한된 종류의 응답 값포장은 Enum을 활용한다. 메서드 응답을 빨간줄로 바꿔 생성하자. . 만약, 제한되지 않았다면? class Rank로, 현재는 제한된 종류의 값 응답이므로 Enum으로 매핑해서 if를 대신하게 해보자. . . | 연속된 상수라면, Enum명_ 순서를 활용하면 된다. . 1,2,3,4,5등 -&gt; 등을 Enum으로 만들고 등_1,2,3,4,5; 로 선언해보자. | . package lotto; public enum Rank { RANK_1, RANK_2, RANK_3, RANK_4, RANK_5; } . | . 응답에 대한 분기로직을 어떻게 응답class/응답Enum으로 넘길까? . . 메서드 응답부에서 원하는 포장된 응답값인 Enum객체을 뽑아 응답해주는 return Enum.정펙매of (,)완성하기 . 결과적으로 정펙매인 Enum.from() or Enum.of( , , )로 Enum객체를 응답해야한다. . 원하는 Enum객체가 응답될 수 있도록 필요한 인자들을 생각해서 받아들인다. | 실제로 입력값이 될 것들을 가지고 있는 사용부인 메서드 응답부에서 부터 시작 | . | . 응답부에서 Enum.정팩메로 해당하는 포장응답값을 return해 줄 예정이다. . 필요한 input들이 뭐가 있는지 살펴본다. | 메서드호출의 결과값이 있다면, input이 명확하도록 따로 변수로 뽑아주자. | . . 정팩메로는 Enum이라는 포장된 응답값을 가져올 것이기 때문에 return과 같이 작성한다. | . . | 값 응답 로직을 -&gt; 포장응답값 정펙매로 잘라내서 처리하기 . 이제 값 응답로직을 그대로 잘라붙혀넣기 한다. . 이동후 | . . | 정팩메 내부로 옮긴 분기에 대해, 응답[값]들을 [Enum객체]로 수정해주기 -&gt; 없는 값(0, None)에 대해서도 OUT,NONE객체 만들어서 응답해주기 . 아직 바꾸기 전 응답로직 . if (matchCount == 6) { return 1; } if (matchCount == 5 &amp;&amp; matchBonus) { return 2; } if (matchCount == 5) { return 3; } if (matchCount == 4) { return 4; } if (matchCount == 3) { return 5; } return 0; . | 수정 + NONE객체 추가후 . package lotto; public enum Rank { RANK_1, RANK_2, RANK_3, RANK_4, RANK_5, OUT; public static Rank of(final int matchCount, final boolean matchBonus) { if (matchCount == 6) { return RANK_1; } if (matchCount == 5 &amp;&amp; matchBonus) { return RANK_2; } if (matchCount == 5) { return RANK_3; } if (matchCount == 4) { return RANK_4; } if (matchCount == 3) { return RANK_5; } return OUT; } } . public static Rank match(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { final int matchCount = userLotto.match(winningLotto); final boolean matchBonus = userLotto.contains(bonusNumber); return Rank.of(matchCount, matchBonus); } . | . 메서드 [포장된 응답] 테스트 작성하기 . 여러분기므로 1case에 대한 -&gt; 1예상값 마다 테매를 작성해야한다. . @Test void match_1() { //given, when final Rank rank = LottoService.match( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1, 2, 3, 4, 5, 6), new LottoNumber(7) ); //then assertThat(rank).isEqualTo(Rank.RANK_1); } . if분기를 enum 매핑으로 제거하기 . 정팩메 input으로 들어올 데이터들 中 1개를 골라 (매핑 예정인) Enum객체의 필드로 넣어준다. . 정펙매로 여러 데이터가 들어와 사용가 들어오지만 of( matchCount, matchBonus) . . 매핑에 사용될 쉬운 변수 1개만 선택하여, 정펙매 내부 values().stream.filter 분기에서 비교할 것이다. Enum객체가 필드로 가지고 있으면 되며, 그 필드 기준으로 매핑값도 차후 배정된다. | . | . 쉽게 Enum의 필드에 넣기 위해서는 일단 ENUM(1) 객체 옆에 빨간줄로 원시형 예제작성해준다. . . | 생성자를 생성해주면서 input과 똑같이 네이밍후 빨간줄 this.필드명 = 필드; 초기화를 이용해서 필드를 생성한다. . . . . | 나머지 객체도 데이터를 넣어준다. . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0); private final int matchCount; Rank(final int matchCount) { this.matchCount = matchCount; } public static Rank of(final int matchCount, final boolean matchBonus) { if (matchCount == 6) { return RANK_1; } . | Enum정팩메 내 [제한된종류의 모든 if분기]를 values().stream + filter with input vs 매핑field로 분기 없애기 . 특수한 경우, 정팩매에서 ENUM매핑값 뽑기도 전에, early return해준다. . 특수한 경우로서 2등과 3등을 먼저 필드는 안됬지만 사용해야하는 변수 matchBonus로 홀로 true인 2등을 early return한다. . public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } . | . Enum내에서 values()는 Enum객체배열을 응답하며 거기에 배열.stream자동완성 사용하여 EnumStream 만들어 객체전체를 돌리기 . . . . 제한된 종류의 if분기를 values().stream (for) + filter(it -&gt; input vs 매핑field 비교) 대체하기 . public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); . 기존 if분기들 이제 삭제 | . enum sense: 각 enum객체끝은 마지막도 콤마(,) 그 다음라인(;) + .findAny()후 .orElse( NONE객체 ) . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0), ; . return Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); . Bi(비.아이.) Predicate&lt; , &gt;로 input된 2개 값을 다 사용하는 1개의 람다식필드 &amp;&amp; filter속 예비 조건식(.test(a,b)로 실행)을 만들어 -&gt; [enum의 1 필드 매핑]에 사용되는 Type을 함수형인터페이스로 사용하여 -&gt; 정펙매 내부 들어오는 2개값 모두 사용하는 enum 만들기 . BiPredicate Type은 1개 함수를 가진 인터페이스 = 함수형 인터페이스 중 2개 인자를 받아 실행대기 중인 조건식을 제공해주고 -&gt; .test( a, b)를 통해 외부인자를 받아서 조건식을 실행한다. .test(a, b)에 정팩메로 들어온 input2개를 넣어주면 된다. | . | . 아직 BiPredicate 적용안한 기존 코드 (상금도 매핑 안된 상태) . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0), ; private final int matchCount; Rank(final int matchCount) { this.matchCount = matchCount; } public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } return Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); } } . Enum필드에 2인자 람다식인 BiPredicate를 넣어서 생성하기 . 이번엔 Enum()객체안에 input 중 1개 6,5,4.. 대신에 input 2필드 다 써서 1개 람다식을 만들어 예제로 넣어주자. 이왕이면 다중커서로 한번에 다 입력해주자. | . | 아쉽게도 BiPredicate는 직접 필드입력 -&gt; private final 필드 변수 생성 -&gt; 생산자 자동완성로 가야한다. (원래는 예제 -&gt; 생산자 -&gt; 빨간줄 this.필드 생성) . 원래 객체( 원시값 등 쉬운 Type)을 빨간줄 필드로 넣으면, 생성자에 파라미터 공짜 -&gt; this.로 필드 공짜 생성 | . BiPredicate 작성 . 받은 인자 2개는 if분기에 쓰였던 input값 2개다. -&gt; 원래 Enum의 매핑 쉬운 상수 응답값 6, 5, 4...와 비교해야한다. | . public enum Rank { RANK_1(((matchCount, matchBonus) -&gt; matchCount == 6)), RANK_2((matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; matchBonus), RANK_3((matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; !matchBonus), RANK_4((matchCount, matchBonus) -&gt; matchCount == 4), RANK_5((matchCount, matchBonus) -&gt; matchCount == 3), OUT((matchCount, matchBonus) -&gt; matchCount &lt; 3), ; . | 필드 직접 입력 private final . 제네릭 타입은 들어올 인자들의 Type(정팩메로 들어올 Type)을 Boxing한 타입 + 네이밍은 condition으로 실행될 조건식임을 인지시킴 | . private final BiPredicate&lt;Integer, Boolean&gt; condition; . . | 생성자 자동완성 . | values().stream + filter분기에서 .test( , )로 정펙매 인자를 받아 조건식 실행 . public static Rank of(final int matchCount, final boolean matchBonus) { return Arrays.stream(values()) .filter(it -&gt; it.condition.test(matchCount, matchBonus)) .findAny() .orElse(OUT); } . 응답값의 포장(리팩토링)이 다 끝났으면, 자체 도메인Test(Enum은 정펙매 테스트) . @Test void rank_1() { final Rank rank = Rank.of(6, false); assertThat(rank).isEqualTo(Rank.RANK_1); } @Test void rank_2() { final Rank rank = Rank.of(5, true); assertThat(rank).isEqualTo(Rank.RANK_2); } @ParameterizedTest @CsvSource({&quot;5,false,RANK_3&quot;, &quot;4, false, RANK_4&quot;, &quot;3, false, RANK_5&quot;}) void rank_3_5(final int matchCount, final boolean matchBonus, final Rank expected) { final Rank rank = Rank.of(matchCount, matchBonus); assertThat(rank).isEqualTo(expected); } . 리팩토링(가변변수 0에 조건만족시 갯수 누적) . 직전까지의합 0가변변수에 조건 만족시 add 1 -&gt; stream + filter + count . 변경 전: 0이라는 int 가변변수를 먼저 선언해놓고 -&gt; 돌면서 조건만족시 -&gt; 가변변수에 += 1;하는 행위 | . // 일급 Lotto public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { if (contains(lottoNumber)) { matchCount += 1; } } return matchCount; } . stream의 filter + count로 원하는 조건의 갯수를 누적된 상태로 바로 뽑을 수 있다. | . // 미리 가변 변수 int = 0;을 선언하지말고 조건만족시를 다 count()로 갯수만 반환받는다. // - long이 기본 타입이라.. 캐스팅 해야한다. public int match(final Lotto other) { // 우항, 파라미터를 찢는 놈이라고 했으니, other.value.stream()으로 찢었다. return (int) other.value.stream() .filter(it -&gt; contains(it)) .count(); } . stream없이 for+if 에서 if를 메서드분리 -&gt; 누적변수없이도 응답 가능=갯수니까 return 1 or 0; . 변경 전 . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { if (value.contains(lottoNumber)) { matchCount += 1; } } return matchCount; } . | . for문 내부 if는 메서드 추출로 통채로 빼기 -&gt; if가 바깥쪽 가변변수 조작한다면? return = 메서드추출()로 받아진다. . . 원래 if 내부에서 바깥의 가변변수를 건들였으니 if가 있던 자리 -&gt; 바깥 가변변수 = 메서드추출()로 return받도록 짜여졌다. . 메서드추출했는데 변수에 리턴받는다? -&gt; 내부에서 바깥의 가변변수를 건들였던 것을 뱉어준 것 | . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { matchCount = getMatchCount(matchCount, lottoNumber); } return matchCount; } private int getMatchCount(int matchCount, final LottoNumber lottoNumber) { if (value.contains(lottoNumber)) { matchCount += 1; } return matchCount; } . | . 메서드추출로 튀어나온 (내부에서 사용되던 바깥선언의) 가변변수는 무조건 가변 = 메서드()형태다 . 원래 if문 내부에서 가변변수++, 가변변수+=1를 해줬었는데… 추출된 것은 무조건 변수 = 메서드()형태인 이유는 . 추출된 메서드의 파라미터로 가변변수가 들어간다. . for (LottoNumber lottoNumber : other.value) { matchCount = getMatchCount(matchCount, lottoNumber); } . | 가변변수가 파라미터에서 선언되는 이름만 똑같은 지역변수가 되는데, 이름은 같아도 바깥 가변변수와는 전혀 다른 것이다. . . | . | . 갯수 증가의 가변++/가변+=1 은 메서드추출시 파라미터(=지역변수)로 안가도 return 1 or 0만 해주면 되므로 [추출메서드에서 파라미터 삭제] -&gt; 이후 가변 = 이 아닌 가변 += 으로 바꿔주면 된다. . 파라미터=지역변수를 없애고, 지역변수++자리를 return 1로 아니면 return 0;으로 대체하자. . private int getMatchCount(int matchCount, final LottoNumber lottoNumber) { if (value.contains(lottoNumber)) { matchCount++; } return matchCount; } . // 지역변수 지우고, 걸리면 갯수증가용 1 , 안걸리면 0 을 반환 private int getMatchCount(final LottoNumber lottoNumber) { if (value.contains(lottoNumber)) { //matchCount++; return 1; } return 0; } . | 메서드 추출 기능 자체의 문제가 가변+= 메서드리턴()이 안되서 -&gt; 가변을 파라미터로 받은 뒤, 지역변수++, 지역변수+= 후 return되는 문제였다. . 가변 = 메서드 추출()부분을 가변 += 메서드 추출()-1or0리턴;으로 바꿔주자. | . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { //matchCount = getMatchCount(matchCount, lottoNumber); //matchCount = getMatchCount(lottoNumber); matchCount += getMatchCount(lottoNumber); } return matchCount; } . | .",
            "url": "blog.chojaeseong.com/java/%EB%A1%9C%EB%98%90/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/06/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-2%EB%8B%A8%EA%B3%84-%EB%A1%9C%EB%98%90-%ED%94%BC%EB%93%9C%EB%B0%B1.html",
            "relUrl": "/java/%EB%A1%9C%EB%98%90/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/06/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-2%EB%8B%A8%EA%B3%84-%EB%A1%9C%EB%98%90-%ED%94%BC%EB%93%9C%EB%B0%B1.html",
            "date": " • Mar 6, 2022"
        }
        
    
  
    
        ,"post13": {
            "title": "강의) 네오 2단계 List + 제네릭",
            "content": "리스트 . 테스트부터 만든다. . test&gt;java에서 class를 앞에 패키지.를 붙혀 만들면 패키지 + class를 동시에 만들 수 있다. list.ListTest | . | . public class ListTest { @Test void name() { new ArrayList&lt;&gt;(); } } . | ArrayList vs LinkedList . ArrayList . arrayList는 내부에 단순 배열을 가지고 있다. 배열을 사용하기 좋게 감싼 일급컬렉션 . transient Object[] elementData; // non-private to simplify nested class access . 배열을 그냥 쓰면, 배열크기가 고정되어있지만, 일급으로 만들어서 크기를 유동적으로 증가 감소, 복사해서 대체해주기 등을 한다. | . private Object[] grow(int minCapacity) { return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); } . | LinkedList . 배열이 아니라 시작과 끝노드를 가지고 있으며 연결되어있다. . transient Node&lt;E&gt; first; /** * Pointer to last node. */ transient Node&lt;E&gt; last; . | 연결되어있으므로 배열 공간에 미리할당할 필요없이 하나씩 node를 추가하면 된다. . | 저장 -&gt; 접근 방식 . . 배열의 arrayList: 인덱스로 한번에 접근가능하다. 인덱스로 한번에 중간원소 접근가능 -&gt; 빠르다. 메모리 공간을 미리 할당해야하므로, 메모리 딸리는 상황에서는 데이터 추가시 느릴 수 있다. | . | 중간원소 삭제시 인덱스를 한칸식 다 땡겨줘야하므로 시간이 오래 걸린다. | 중복처리 방식 리스트 안에 리스트를 넣는방식 이용 | 크기가 커지면 리스트 안에 트리를 넣는 방식 이용 | 사이즈에 맞게 다르게 사용되어서.. api를 사용하는게 좋다. | . | . | 노드의 LinkedList: 통해서 가야하는 줄줄이 노드. 타고가야하는 줄줄이 노드는 중간원소 접근 -&gt; 느리다. | 중간원소 삭제시 편하게 삭제 | . | 하드디스크의 물리적으로 순차적인 접근 . 옛날 하드디스크 = 물리적으로 순차적으로 메모리 배열 -&gt; arraylist와 마찬가지 방식 -&gt; 유리했었음 요즘은 linkedList가 메모리 파편화된 node들의 집합이어도 별 상관없어졌다. | . | . 제네릭 . list처럼 다양한type을 관리하는 경우, 특정type으로 고정시킬 수 있다. 제네릭이 멀까? 컴파일 타임(핵심)에 처리가 되서, 그 때 버그를 잡아낼 수 있다. | 클래스를 변수로 만들기? | . | . | . 제네릭은 컴파일 타임에 처리된다. . 1을 arrayList에 넣고 출력하는 코드를 작성하고 실행시켜 컴파일 . @Test void name() { final ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); integers.add(1); System.out.println(integers); } . | out(build)부터 시작되는 컴파일코드로 가서 shift2번 &gt; show bytecode를 쳐서 내부적으로 실행된 코드를 확인해보자. . . // access flags 0x0 name()V @Lorg/junit/jupiter/api/Test;() L0 LINENUMBER 9 L0 NEW java/util/ArrayList DUP // ArrayList 생성할 때, 제네릭정보는 없다. INVOKESPECIAL java/util/ArrayList.&lt;init&gt; ()V ASTORE 1 L1 LINENUMBER 10 L1 ALOAD 1 ICONST_1 INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer; // integer가 들어갈 때, Object로 들어간다. -&gt; 컴파일 될 때 알아서 Type으로 떨어진다. 컴파일 타임까지만 Type실수하지않게 도와주는 것. 런타임 때는 안도와준다. INVOKEVIRTUAL java/util/ArrayList.add (Ljava/lang/Object;)Z POP L2 LINENUMBER 12 L2 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 1 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)V L3 LINENUMBER 13 L3 RETURN L4 LOCALVARIABLE this Lgeneric/GenericTest; L0 L4 0 LOCALVARIABLE integers Ljava/util/ArrayList; L1 L4 1 // signature Ljava/util/ArrayList&lt;Ljava/lang/Integer;&gt;; // declaration: integers extends java.util.ArrayList&lt;java.lang.Integer&gt; MAXSTACK = 2 MAXLOCALS = 2 . | 결과적으로 외부에서 타입을 지정할 수 있게하는 기술이다. . 생성시에는 타입없이 내부에서 생성 | 외부인 변수에 할당시 타입지정 | . ArrayList&lt;Integer&gt; integers = new ArrayList(); . 외부에서 타입을 맘대로(나 인티져 넣을거야, 나 스트링 넣을 거야~)지정해서 편하게 사용한다. | . final ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); final ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;(); . | 장점 . (사용시 특정타입으로 제한하여) 타입안정성을 얻을 수 있다. | 캐스팅해서 사용하던 것을 자동으로 처리되도록 됨. | my) [여러 타입가능한 자료구조]사용시 get하면 object로 내려와 (1) 타입확인 (2) 다운캐스팅 해서 사용했어야 했는데 사라지게 된다. . jdk 5부터 추가되었다. | 다른type, 다른형을 막아주기 때문에 특별한 이유가 없으면 여러타입가능 자료구조는 무조건 generic을 사용해라 | . @Test void name() { final List integersNoGeneric = new ArrayList(); integersNoGeneric.add(1); // 여러타입 가능한 것에 대해 제네릭으로 타입을 안정해준다면, // 1. &lt;받아올 때&gt; Object형으로 내려온다. -&gt; &lt;받아 사용하는 쪽에서&gt; 다운캐스팅 해야 쓸 수 있다. final Object o = integersNoGeneric.get(0); // -&gt; [넣은 것과 동일한 형으로 직접 다운 캐스팅]해야줘야 다시 해당 type으로 사용할 수 있다. final Integer integer = (Integer) integersNoGeneric.get(0); // 2. 다른 Type을 넣어버릴 수 도 있어서 type불안정하다. integersNoGeneric.add(&quot;1&quot;); // -&gt; &lt;사용하는 쪽, 타입까지 직접확인해줘야&gt;해서 -&gt; 사용할 때 [넣은 것과 동일한지 type확인도 미리] 다운캐스팅전에 해줬어야했다. final Object o1 = integersNoGeneric.get(0); if (o1 instanceof Integer) { final Integer o11 = (Integer) o1; } } . Type과 제네릭은 영역 좁히는게 반대다? . ArrayList는 구현체 List가 인터페이스(추상체) . type을 받아줄 변수는 인터페이스(추상체)로 받아야, 메서드들이 분기를 대신하는 구상체(전략객체)를 받을 수 있는 추상체(인터페이스) 파라미터로 정의되어있음을 인지해야한다. | . my) Type의 경우) 정의하는 변수와 파라미터는 전체 분기들을 내포되도록 추상체로 받고, 사용하는 할당과 메소드호출 인자에는 분기가 결정된 구상체를 넣어주자. . 파라미터를 분기결정된 구상체로 받는다면? . 다른 구상체들을 못받는다. | . void 파라미터를_분기결정된_구상체로_넣는경우(ArrayList&lt;Integer&gt; value) { System.out.println(value); } . // 1. default로 변수추출시 ArrayList 풀로 형이 정해지는데 final ArrayList&lt;Integer&gt; integersArrayList = new ArrayList&lt;&gt;(); // 2. vs 정의하는 변수와 파라미터는 전체분기들을 내포하는 추상체로 받아라 -&gt; 할당과 메소드호출인자에는 분기결정한 구상체를 넣어주자. final List&lt;Integer&gt; integersList = new ArrayList&lt;&gt;(); //3. 정의하는 메소드파라미터를 분기결정된 구상체 -&gt; 해당 구상체밖에 못들어온다. 파라미터를_분기결정된_구상체로_넣는경우(integersArrayList); // 에러안남. 파라미터를_분기결정된_구상체로_넣는경우(integersList); // 에러남 (구상체 정의 -&gt; 추상체를 넣음) } . | 파라미터를 분기내포하는 추상체(인터페이스)로 받는다면? . 파라미터를 추상체로 받는다? -&gt; 분기들을 내포하여 구상체들을 다 받을 수 있는 상황 | 인터페이스로 분리해서 내가 어떤이점을 얻고 있지? 잘활용하고 있나 고민할 것 전략패턴에서는, 파라미터를 전략인터페이스로 정의후 | 호출시점에 전략객체.전략메서드() 호출시켜서 실시간성 부여 | 사용하는 메인에서 메서드호출시 new 구상체를 던져 분기를 정해줌 | . | . void 파라미터를_분기내포하는_추상체로_넣는경우(List&lt;Integer&gt; value) { System.out.println(value); } . 파라미터를_분기내포하는_추상체로_넣는경우(integersArrayList); // 에러안남. 파라미터를_분기내포하는_추상체로_넣는경우(integersList); // 이것도 에러 안남. //메소드 호출시, 여러분기들의 구상체를 다 받을 수 있다. . | 정의시, 변수 생략된T &lt;&gt; 형 + 파라미터, 클래스 &lt;T&gt;형 -&gt; 제네릭에서의 추상체 &lt;-&gt; 구상체 &lt;특정형&gt; 변수 . 제네릭 추상체 &lt;T&gt;형으로 box클래스 정의하기 . 제네릭 추상체 &lt;T&gt;형 클래스 만들기 . class Box&lt;T&gt; { private final T value; // 1. T형 변수을 감싸는 클래스 box를 만든다. T형이란 미정이므로 -&gt; 2. 클래스 정의시 &lt;T&gt; 제네릭을 달아줘야한다. //3. T형변수를 변수를 생성자를 통해 초기화하고 public Box(final T value) { this.value = value; } //4. T형 변수를 getter로 응답한다. public T getValue() { return value; } } . | my) 제네릭은 Type과 반대로, 변수 및 생성자에서는 제네릭 구상체 인 &lt;특정형&gt; 변수에 , 할당(사용)시 생략된T형&lt;&gt;을 넣어줘, 변수와 생성자에서 좁힌다. . 제네릭 추상체 생략된T형 &lt;&gt;변수, 제네릭 구상체 &lt;특정형&gt; 변수 각각 생성자 대입해보기 . 변수가 제네릭 구상체이라면, 할당도 해당하는 형밖에 못넣는다. | . @Test void name2() { final Box&lt;String&gt; stringBox = new Box&lt;&gt;(&quot;&quot;); //final Box&lt;String&gt; stringBox = new Box&lt;&gt;(1); // 제네릭은 변수와 생성자에서 좁힌다. 할당시 제네릭추상체-생략된T&lt;&gt;형으로 넓게준다. } . | 할당(사용)시 생략된T형&lt;&gt;을 넣지만, 좁히는 변수와생성자 자리에 들어간&lt;특정형&gt; 변수가 추상체인 인터페이스라면, 넓히는 할당 자리에 &lt;특정형 인터페이스의 구상체형들&gt; 들도 할당가능하다 . 넓은 할당자리에 특정형을 집어넣으면 해당 클래스만 사용가능해진다. . 무엇이든 다 들어갈 수 있는 제네릭 추상체 Box&lt;T&gt;에 대해서 제네릭 구상체 Box&lt;특정형&gt;을 지정해줬지만, 그 특정형이 구상체들을 가진다면 우변에서 구상체들의 할당이 가능하다 . // 8.제네릭에서는 생략된T형인 Box&lt;&gt;에 비해 Box&lt;특정형&gt;은 제네릭구상체다. -&gt; 할당이 &lt;특정형&gt;의 자체 및 그 구상체들만 가능해진다. // -&gt; Animal이 제네릭 특정형으로 들어가 그 제네릭 구상체가 되었더라도, 그것의 구상체들인 Dog, Cat은 할당될 수 있다. new Box&lt;Animal&gt;(); final Box&lt;Animal&gt; animalBox = new Box&lt;Animal&gt;(); . | 좌항 좁히는 변수가 &lt;특정형&gt;의 제네릭구상체라면 -&gt; 마찬가지 좁히는 생성자에 들어갈 변수도 특정형으로 처리되어야함. 할당(사용, 특정분기)은 생략된T형(제네릭추상체)의 기본생성자 호출 불가 . 변수만 좁히고, 할당은 안좁혔을 때 -&gt; 기본 생성자에 인자가 들어간다면 넓은 할당형에 쓰던 것이 생성자로 들어갈 예정이니 에러가난다 -&gt; 인자를 안받는 생성자를 만들어줘서 생략된T형의 인자가 못들어가게 막아주자. . List(추상) = ArrayList(구상)는 내가 특정분기를 우항에서 할당하여 사용하는 것이다. . 하지만 현 상황에서는 제네릭 구상체인 Box&lt;Animal&gt; (구상) = new Box &lt;&gt; () (추상:생략된T형)을 넣는 것은 정반대로 주는 것 | **좌변 변수정의에서 구상체 특정형으로 제한되어있다면, 뭔짓을 한들 생략된 T형 = 제네릭추상체 사용시, 생성자에 건네주는 것으로 class내부 T형 변수를 초기화해줄 수 없기 때문이다. ** | . // 9. 좁히는 변수만 좁히고, 할당은 안좁혔을 때 -&gt; 기본 생성자에 인자가 들어간다면 넓은 할당형에 쓰던 것이 생성자로 들어갈 예정이니 에러가난다 final Box&lt;Animal&gt; animalBox = new Box&lt;&gt;(); // 생성자쪽에서 에러 // -&gt; 인자를 안받는 생성자를 만들어줘서 생략된T형의 인자가 못들어가게 막아주자. // -&gt; default생성자(파라미터T가 안되니, 파라미터를 아예 안받고, 내부 T형은 null로 초기화시켜주는)를 추가해주자. public Box() { this(null); } . final Box&lt;Animal&gt; animalBox = new Box&lt;&gt;(); . 마치 제네릭 구상체 변수에 제네릭추상체 할당이 가능해 보이지만, 생성자가 파라미터를 외부에서 아예 안받고 내부적으로 자체 처리해서 제네릭추상체를 감당하고 있기 때문에 그렇게 보이기만 할 뿐이다. 특수처리되어서 에러는 사라졌으나 사용은 불가하다.?! | . | . | . 할당시 제네릭구상체&lt;특정형&gt;을 지정해주면, 내부의 모든 것이 T-&gt;특정형으로 바뀐다. 할당은 변수보다 넓어야하니 변수는 더 좁은 특정형or특정형의 구상체들로 받아줘야할 것이다. . // 11. 이미 좁힌 제네릭변수가 있을 때, 할당은 생략된T형 &lt;&gt;으로 넓게 줄 수 있다. (넓은 형으로 들어갈 생성자만 잘 처리되면) final Box&lt;Animal&gt; animalBox2 = new Box&lt;&gt;(); // 12. 할당에서 특정형을 제네릭구상체로 지정해주면, 내부의 모든 로직이 해당 classType으로 바껴서 // 12-1. 동일형으로 좁힌 변수에는 잘들어간다. final Box&lt;Animal&gt; animalBox3 = new Box&lt;Animal&gt;(); // 12-2. 만약 넓은 할당쪽이 더 좁아졌다면? (좁힌 변수보다 더 좁은) Type과 다르게 안들어가진다. -&gt; 변수와 생성자가 더 좁아야한다. final Box&lt;Animal&gt; animalBox4 = new Box&lt;Dog&gt;(); // 에러 . 좁았던, 제네릭 변수정의 - 생성자 인자의 관계에선, Type처럼 변수-추상체라면, 생성자인자-구상체의 관계를 가진다. . //13. 할당시 생략된T형&lt;&gt; -&gt; 변수-생성자 인자 관계에서는, Type처럼 변수 추상체 - 생성자=메서드호출 구상체가 가능하다. //13-1. 할당시 생략된 T&lt;&gt;으로 내부가 T로 구성된 데이터에, 좁은 생성자 인자를 넣어줄 때, 추상체에 구상체가 들어가므로 괜춘하다. final Box&lt;Animal&gt; animalBox4 = new Box&lt;&gt;(new Dog()); //13-2. 할당이 넓은 상태라면, 변수-추상체 생성자-구상체로서 동일한 것도 생성자로 넣을 수 있다. final Box&lt;Dog&gt; animalBox5 = new Box&lt;&gt;(new Dog()); . 실사용 와일드카드 . 실사용은 좁은 변수제네릭에 와일드카드를 지정해주고 넓은 할당은 생략된T형이 기본인 상태에서, 넣어줄 생성자에 변수의 좁은제네릭에 들어있는 구상체or상속or와일드카드 범위의 객체를 넣어 사용해줘야한다. . //14. 넓은 제네릭할당에 대해 new Box&lt;&gt;(); //14-1. 좁은 변수의 제네릭에 와일드카드(upper bound) 적용주자. final Box&lt;? extends Animal&gt; extendsAnimalBox = new Box&lt;&gt;(); //14-1-1. 실사용은 변수에 대해 생성자에 넣어줄 놈은 더 구상체로 넣어주면 된다. final Box&lt;? extends Animal&gt; extendsAnimalBox2 = new Box&lt;&gt;(new Animal(){}); final Box&lt;? extends Animal&gt; extendsAnimalBox3 = new Box&lt;&gt;(new Dog()); . 상속자 자리에 와일드카드변수(제네릭추상체) 구현체를 상속한 것들도 넣어줄 수 있다. . //15. [Animal의 구현체인 Dog]를 상속한 것들도 제네릭 상속자 자리에 넣어줄 수 있다. // -&gt; 술을 먹어서 개가 된 돌범(상속) 정의 class Dolbum extends Dog { } . //15-2. 제네릭 변수-상속자의 관계는 구상체 자식들 하위단계를 다 넣어줄 수 있다. final Box&lt;? extends Animal&gt; extendsAnimalBox4 = new Box&lt;&gt;(new Dolbum()); . 넓은 할당쪽 제네릭은 사실, 생성자에 들어갈 객체의 범위가 default다. . 할당쪽 제네릭은 와일드카드 사용불가 | 특정형 사용시, 생성자도 그걸로 | 생성자를 넣어줄 시, 그거랑 동일한 것이 default | . 와일드카드에 대해, 상속자들어갈놈 -&gt; 할당제네릭의 default가 안정해줄 경우, 어떤 Type으로 잡힐까? . 제일 defaultType은 제일 상단이 나온다. Type입장에서는 열려있는 최고 부모를 변수type으로 받아줘야한다. | . | . //16. 와일드카드에 대해, 상속자들어갈놈 -&gt; 할당제네릭의 default가 안정해줄 경우, 어떤 Type으로 잡힐까? final Box&lt;? extends Animal&gt; extendsAnimalBox5 = new Box&lt;&gt;(); //16-1. upperbound를 가진 extends 와일드카드의 경우, 제일 상단인 Animal이 나오고 final Animal value = extendsAnimalBox5.getValue(); final Box&lt;? super Animal&gt; superAnimalBox5 = new Box&lt;&gt;(); //16-2. lowerbound를 가진 super의 경우, 제일 하단인 Animal이 나올 것 같지만, // -&gt; 역시 제일 상단인 Object가 나온다. // --&gt; 와일드카드의 default는 제일 위아래쪽 상관없이 상단 bound ~ Object까지 나오게 된다. final Object value2 = superAnimalBox5.getValue(); . 제네릭의 클변 메파 정의/ 좁 변수(와) + 메파 제한자(와X) -&gt; 생성자/ 넓 할당 . Type은 정의하는 변수, 메서드 파라미터에는 추상체를 / 사용하는 할당, 메소드호출에는 구상체를 넣어서 분기처리를 밖으로 제거해줄 수 있다. | . 제네릭은 정의(class 속 변수, method 파라미터)는 T(E)로 / 변수(와일드카드)와 method 파라미터는 &lt;T&gt; (&lt;E&gt;) 좁게 + 생성자(좁힌 것의 구현체&amp;자식들) + / 할당은 넓게(default로 두면 알아서 생성자에 사용되는 구현체에 맞게) . 메소드 파라미터는 제네릭E로 정의해주지만 (클래스 변수 타입 T형처럼) /히는 작업이 접근제한자와 응답사이에 좁은 꺽쇠&lt;E&gt;로 정의 (좁은 변수Type처럼) . //1. T는 클래스의 변수 정의하느라 썼으니 // -&gt; 파라미터는 E로 받지만, 제한자 쪽에다가 꺽쇠붙인 &lt;E&gt;로 좁혀준다. // -&gt; &lt;E&gt;는 별다르게 좁혀주지 않는 default 어느타입이든 가능임. public &lt;E&gt; void some(E e) { } . //2. 제네릭은 변수에 좁게 정의하고, 그 와일드카드에 해당 범위의 객체를 생성자에 넣어주니, 변수까지 정의해서 객체를 생성한다. new Box&lt;&gt;(); final Box&lt;? super Animal&gt; superAnimalBox6 = new Box&lt;&gt;(); final Object value1 = superAnimalBox.getValue(); // 와일드카드에 구상체 객체를 않넣어주면, T형의 인스턴스변수를 Object로 잡아 반환한다. final Box&lt;?&gt; value6 = superAnimalBox; //객체는 ? 와일드카드에 그냥 넣어줄 수 있다? value6.some(&quot;&quot;); // E는 기본적으로 Object부터 시작하여 -&gt; 메서드호출시 어떤Type이든지 호출 가능해진다. value6.some(1); // E는 기본적으로 Object부터 다 받을 수 있다. . 좁은 변수처럼, 메소드 파라미터는 제한자 쪽에서 좁힌 Type &lt;E&gt;에 와일드카드 or 직접 꺽쇠에 제한을 걸수 있다. . 잘보면 응답Type void보다 앞쪽에서, 파라미터에 대한 와일드카드 제한을 거는 것이다. | . //3. 메서드의 파라미터의 좁힘 제한은 응답Type앞쪽에서 꺽쇠&lt;E&gt;제네릭으로 걸 수 있다. public &lt;E extends String&gt; void some(E e) { } //4. value6.some(&quot;&quot;); // string 이하로 제한건 E에는.. string 및 string상속한 것만 들어간다. value6.some(1); // 에러 . 참고) E는 와일드카드 범위내에서 사용된 Type이 추론끝나면 컴파일 타임에서 해당Type으로 대체되어 사라진다. . 참고) 정의를 해주는 class옆 꺽쇠 + method파라미터용 앞쪽 꺽쇠에서는 와일드카드 사용이 안된다. 변수 제네릭에서만 와일드카드 가능 . // 와일드카드 사용 좁힘시 에러 public &lt;? extends String&gt; void some(E e) { } // 와일드카드 사용시 에러 class Box2&lt;? extends Animal&gt; { } . 추가 메서드 파라미터 E를 좁힐 땐, 와일드카드가 아닌 꺾쇠&lt;E extends &gt;로 좁히며, super불가 + 와이드카드 불가다.. . 메서드에서 class와 동일한 타입추론 변수를 사용해도 된다. but… . public &lt;T&gt; void some(T t) { } . 메서드 파라미터의 변수는 지역변수라 … class쪽과 다르다. . //2. class내부에서 동일한 타입추론 변수T를 사용한 메서드는.. 파라미터로 T가 추론된 Dog형만 사용가능할까? // -&gt; class정의시에서는 T로 똑같은게 사용된 것 같지만, 메서드 파라미터의 변수 -&gt; 지역변수 -&gt; class 제네릭 타입변수 T랑은 별개다. // -&gt; 타입추론한 Dog와 별개로, 제한안걸린 T로서 모든 타입이 다들어간다. dogBox.some(new Object()); dogBox.some(1); dogBox.some(&quot;1&quot;); . E로 바꿔도 똑같이 지역변수로 적용되므로… 개별적 처리가 된다. | 되도록이면 이름 중복 안되게 하는게 좋다. | . P-E C-S(제네릭와일드카드 사용처) . 생성관련된 메소드의 파라미터에 대해서는 extends 상속한 것들만 들어올 수 있게 ArrayList의 생성자 파라미터 정의시 | ArrayList의 add메서드들의 파라미터 정의시 | . | 소비하는 곳에서는 super를 써서 제네릭을 정의해라 | . ArrayList를 타고 들어가서 ? extends가 어디서 사용되는지 검색 해보자. . 생성자 파라미터에서 E의 상속한 자식들(extends)만 들어오도록 제한을 걸어준다. . . | add의 파라미터할때도 ? extends를 사용한다. . . | . ? super는 소비되는 곳에서 사용된다. . super는 어떤 값이든 들어와도 되며, 소비되는 곳에 사용된다. . 소비만 되므로, 실제 어떤 타입인지 중요하지 않다. | . . | action은 람다 학습시 필요하다. . 람다로 넘겨줄 때, Consumer, Predicate 사용시 많이 이용된다. | . public void forEachRemaining(Consumer&lt;? super E&gt; action) { . | .",
            "url": "blog.chojaeseong.com/java/list/%EC%A0%9C%EB%84%A4%EB%A6%AD/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/05/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-2%EB%8B%A8%EA%B3%84-list%EC%99%80-%EC%A0%9C%EB%84%A4%EB%A6%AD.html",
            "relUrl": "/java/list/%EC%A0%9C%EB%84%A4%EB%A6%AD/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/05/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-2%EB%8B%A8%EA%B3%84-list%EC%99%80-%EC%A0%9C%EB%84%A4%EB%A6%AD.html",
            "date": " • Mar 5, 2022"
        }
        
    
  
    
        ,"post14": {
            "title": "제이) 중간피드백 Service와 Controller",
            "content": "Service . 일반 코드로 작성하는 안티 패턴 싱글톤이 아닌 스프링에서는 전용 싱글톤으로 유지되어야한다. | 상태(인스턴스 변수)를 가지면 안된다. 스프링의 service는 유저별 객체생성하면 감당이 안되므로 싱글톤으로 관리 되는데, 수많은 유저가 -&gt; 1개 싱글톤의 상태를 오염시킬 것이 뻔하기 때문이다. | controller -&gt; 재료들을 service 메소드 파라미터로 받아서 지역 변수로 처리되어야한다. | . | 원래 service를 사용한다면? Controller -&gt; inputDto -&gt; 도메인을 return하는 toDomain -&gt; service는 domain을 받는다. 상태로 유지는 X -&gt; 레포지토리 dto를 service에 넘기는 것을 지양해야한다 dto -&gt; toDomain -&gt; service controller는 클라이언트 레이어쪽 &lt;—&gt; service는 도메인이 포함된 레이어 쪽 | . | 레포지토리는 지엽적인 구상체들이 다 올 수 있는 Interface로 쌓여있다. | 도메인 생성에 필요한 데이터를 가져다 주는 것이 레포지토리 인터페이스 | 도메인은 레포지토리에게 질의만(findByName, findById) | . | . | input -&gt; 도메인으로 받은 controller에서 service.흐름로직( 도메인1, 도메인2)로 service로 흐름을 가져가되, input/output 흐름이 잘 잡히도록 짜면 된다. . | 검증이 controller에 있어도 되긴 되지만, 최대한 controller에서의 로직은 걷어내서 Factory or 도메인 로직에 넣어준다. 도메인을 풍부하게 해주자 . | 서비스에서 전략객체 바로 생성사용 가능? spring -&gt; bean에서 언제든지 사용가능하게 관리해줄 것이므로 **주입없이 바로 사용해도 ** | . | Controller와 의존성 . 의존성 개념에 따르면 중요하지 않은 = 잘 변하는= view와 맞닿은 controller가 중요한 도메인을 생성-&gt;사용해도 된다. . 중요한 것 의존=생성/(인자로)사용/리턴 (X)&gt; 중요하지 않은 것(쉽게 변하는것) (X) - domain내부에서 dto를 return하는 toDto() 하면 안된다. - domain내부에서 view(String)과 관련된 메소드를 작성하면 안된다. 중요하지 않은 것 의존=생성/(인자로)사용/리턴(O)&gt; 중요한 것 - controller에서 도메인을 (인자로)생성후 사용해도 된다. - dto에서 도메인을 from인자로 사용해도 된다. - dto에서 도메인을 return하는 toDomain()해도 된다. . | controller에서 도메인을 생성/인자로사용해도 되며 -&gt; service에는 도메인or값으로 넘겨준다. . | Service to Controller . Controller는 중요하지 않은 것으로서 중요한 도메인을 받아 써도 된다. 프로젝트가 커지면 Dto로 반환해준다. jpa를 쓰게 되면, 영속성 관리 때문에, 도메인을 view단으로 보내면 안된다. | . | view에서는 도메인에 있는 정보를 짤라 일부만 써야하는데, 필드를 날릴 순 없으니 민감/불필요한 필드가 짤려진 dto로 보낸다. | 도메인의 정보가 다쓰인다면 도메인객체를 그대로 넘겨도 된다. view에 map을 넘겨줘도 된다. 알아서 변환되서 내려간다. | map을 각 key필드 + value필드로 쪼갠 뒤 -&gt; dto클래스를 만들어서 -&gt; 객체dto를 넘겨도 된다. | . | . | Method시 들어갈 때 필요한 것들 -&gt; 뭐가 나오는지 명확하게 . 나중에는 returnType -&gt; 메서드명 -&gt; 파라미터의 시그니쳐만 보고 메서드를 갖다쓰기 때문에, 잘 정의되어 있어야한다. . 안 좋은 예 -&gt; 잘못 메서드 추출한 예 . lottoService.calculateResult(inputView.getBonusNumber()); . 보너스를 넣으면 -&gt; 당첨 결과가 나온다? -&gt; (X) 결과는 산 로또 + 당첨번호 + 보너스가 들어가서 -&gt; 당첨결과가 나와야한다. | . | . final Money totalMoney = getMoney(); final List&lt;Lotto&gt; issuedManualLotto = buyManualLotto(totalMoney); final Result result = issueLotto(totalMoney, issuedManualLotto); . | . xxxxFactory . **xxxxFactory 는 판매원이자 xxxxMachine** Lotto를 용지로만 본다면, 복잡한 생성과정은 판매원/Machine인 Factory에게 | . | 생성로직이 복잡하고 중요하기 때문에 클래스로 분리한 것 . 간단하면 따로 Factory로 분리할 필요가 없다. | . . | .",
            "url": "blog.chojaeseong.com/java/%ED%94%BC%EB%93%9C%EB%B0%B1/mvc/dto/service/controller/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/04/%ED%94%BC%EB%93%9C%EB%B0%B1_2-1(%EB%A1%9C%EB%98%90-%EC%A4%91%EA%B0%84)_%EC%A0%9C%EC%9D%B4_service%EC%99%80-controller.html",
            "relUrl": "/java/%ED%94%BC%EB%93%9C%EB%B0%B1/mvc/dto/service/controller/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/04/%ED%94%BC%EB%93%9C%EB%B0%B1_2-1(%EB%A1%9C%EB%98%90-%EC%A4%91%EA%B0%84)_%EC%A0%9C%EC%9D%B4_service%EC%99%80-controller.html",
            "date": " • Mar 4, 2022"
        }
        
    
  
    
        ,"post15": {
            "title": "TDD 4 자경(controller~view~검증)",
            "content": "ControllerTest for 컨트롤러와 service 형태 결정 . (test)Controller는 InputView를 파라미터로 받는다. . Controller -&gt; ControllerTest에서 컨트롤러 생성 | . controller = new Controller(new InputView()); . (prod)Controller 생성자 내부 new Service( inputXX ) 초기화 . 01 모든 입력을 한번에 다 -&gt; new Service( InputView.getInputDto() ) . 개별 try/catch는 안될 것이다. 처음부터 재입력받는 로직이 필요하다면, 여기를 함수화하고 재귀 걸어주면 될듯 | . | . public Controller(final InputView inputView) { //1-1. 서비스 생성시 inputView에서 한꺼번에 inputDto로 받는 경우 racingService = new RacingService(inputView.getInputDto()); . 01-1 inputDto.of( 개별getInput() , 개별getInput()) 형태로 return . 개별input에서는 출력문 | 기본 scanner input받아서, 공통 NullOrEmpty + 숫자면포맷 | split(,-1)+trim or parseInt의 정제된 형으로 변환 | 원시값 return | | . public class InputView { private static Scanner SCANNER = new Scanner(System.in); //1-3. getINputDto내부에서 사용될 개별 getXXX는 getInput()스캐너에 의존한다. private String getInput() { return SCANNER.nextLine(); } //1-2. 모든 input들을 InputDto.of에 넣어서 InputDto로 반환해주는 작업. // -&gt; dto는 일단 of(모든 속성들을 원시값으로) 받아서 -&gt; new dto( 원시값, 들로 생성)해야한다. public InputDto getInputDto() { return InputDto.of(getNames(), getRound()); } //1-4. 개별 getInput들은 출력 + 공통input검증(nullOrEmpty/format)이 생성된다. // 개별 getInput들은 4단계가 있다고 했다 (1)출력 (2) nullOrEmypy 검증 (3) format검증후convert or split+trim 변환 (4) return public List&lt;String&gt; getNames() { System.out.println(&quot;이름을 입력해주세요&quot;); final String input = getInput(); Validators.checkNullOrEmpty(input); return Arrays.stream(input.split(&quot;,&quot;, -1)) .map(String::trim) .collect(Collectors.toList()); } public int getRound() { System.out.println(&quot;몇 회 진행하겠습니까?&quot;); final String input = getInput(); Validators.checkNullOrEmpty(input); Validators.checkValidFormat(input); return Integer.parseInt(input); } } . 01-2 InputDto는 of 정펙매 -&gt; 생성자 -&gt; 원시값필드 -&gt; getter순으로 정의 . public class InputDto { private final List&lt;String&gt; names; private final int round; public InputDto(final List&lt;String&gt; names, final int round) { this.names = names; this.round = round; } //1-5. of에서 개별input다 받았으면, 그걸로 new생성자 -&gt; 필드 -&gt; getter까지 다 만든다. public static InputDto of(final List&lt;String&gt; names, final int round) { return new InputDto(names, round); } public List&lt;String&gt; getNames() { return names; } public int getRound() { return round; } } . 02 순차적이라면 new Service( 첫input ) -&gt; 메서드파라미터 ( 담input ) . setter금지령으로 인해 -&gt; 메인로직에 필요한 데이터는 생성자에서 객체 생성시 받아 -&gt; 인변에 넣어줘야한다. Controller는 service를 관리하고 있으며, 생성시service 초기화해줘야한다. 그 service 초기화시 받을 input -&gt; 좀있다가 받을 input이 따로 있는 경우 | . | . | . 02-1 첫 입력만 일단 생성자에서 개별input()으로 받는다. . public Controller(final InputView inputView) { // 첫 입력만 일단 생성자에서 개별input()으로 받는다. racingService = new RacingService(inputView.getNames()); . 02-2 개별input() in InputView 정의 . public List&lt;String&gt; getNames() { System.out.println(&quot;이름을 입력해주세요&quot;); final String input = getInput(); Validators.checkNullOrEmpty(input); return Arrays.stream(input.split(&quot;,&quot;, -1)) .map(String::trim) .collect(Collectors.toList()); } . 02-3 그에 따라 Service의 생성자 정의 . public RacingService(final List&lt;String&gt; carNames) { this.cars = new Cars(carNames); } . 원래 service 생성자는.. 일급 및 VO 개발시, 다 받아주는 것으로 정했었다. 여기에 추가해준다. . public RacingService(final List&lt;String&gt; carNames, final int round) { this.cars = new Cars(carNames); this.round = new Round(round); } . | . 03 inputView 콘솔입력(공통검증)부터의 테스트 -&gt; new Controller + InputStream(null불가) . new Controller( new InputView )를 던지면 . Controller생성자에서 inputView.콘솔input() 이 호출된다. | 여러개 개별input()이 포함되어있다면, 그만큼 SequenceInputStream을 던져야한다. | . // 1. 콘솔의 개별input()호출 -&gt; 공통 검증 public Controller(final InputView inputView) { racingService = new RacingService(inputView.getNames()); // 2.정제된 input으로 -&gt; 도메인생성 -&gt; 내부에서 도메인 검증 public RacingService(final List&lt;String&gt; carNames, final int round) { this.cars = new Cars(carNames); . | **테스트는 inpustream에 null은 넣지못하므로 &quot;&quot;빈칸만 테스트한다. ** . 전체 다 맞는 것 + 개별input 갯수만큼 sequence를 만들어줘야하므로 끝나면 가장 마지막에 테스트할 예정으로 바꾼다. | . | . @Test void controller_input_test() { final String argument = &quot;&quot;; final InputStream input = new ByteArrayInputStream((argument + &quot; n&quot;).getBytes()); System.setIn(input); assertThatThrownBy(() -&gt; new Controller(new InputView())) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;빈칸&quot;); } . 재귀추가시 fail 뜨게 되므로 valid한 input을 다시 넣어두자. . @Test void input_null_or_empty_test() { final String argument1 = &quot;&quot;; // 틀 final String argument2 = &quot;재성, 재경&quot;; // 맞아서 재귀 통과 final InputStream input1 = new ByteArrayInputStream((argument1 + &quot; n&quot;).getBytes()); final InputStream input2 = new ByteArrayInputStream((argument2 + &quot; n&quot;).getBytes()); final SequenceInputStream sequenceInputStream = new SequenceInputStream(input1, input2); System.setIn(sequenceInputStream); assertThatThrownBy(() -&gt; new Controller(new InputView())).isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;빈칸&quot;); } . 04 null를 직접하고 싶다면 바로 메서드 유틸Validators.checkNullorEmtpy 자체를 테스트하자. . @Test void input_null_or_empty_in_validator() { assertThatThrownBy(() -&gt; Validators.checkNullOrEmpty(null)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;빈칸&quot;); } . ServiceTest again for 넘어온 정제된input으로 도메인 검증 . 도메인 검증은 controller 생성자에서 inpuView.개별input()에서 건너오는 정제된 input을 받아 관리 도메인으로 넣어주는 Service 생성자에서 한다 . //controller racingService = new RacingService(inputView.getNames()); //service public RacingService(final List&lt;String&gt; carNames) { this.cars = new Cars(carNames); } . | . new Service() -&gt; service.메서드()에서 받아주는 input 순서대로 도메인 검증하기 . new Service( inputView.개별input() )을 호출하면서 내부 ` this.cars = new Cars(carNames);` 도메인 생성자 호출되므로, | inputView.개별input() 자리에 원하는 인자로 테스트한다. | . | . 01 inputView.개별input() 자리에 valid 테스트 데이터 입력 . ServiceTest에서 inputView.개별input()을 받는 곳을 호출하되, 값만 임의로 넣어서 테스트한다. . @Test void valid_domain1_input_check() { //new RacingService(inputView.getNames()) //this.cars = new Cars(carNames); //given final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); //when,then assertDoesNotThrow(() -&gt; new RacingService(names)); } . | . 02 invalid한 테스트 작성하면서, 예외발생토록 도메인 검증 작성 . **invalid한 경우부터는 도메인 검증을 만들고, 예외를 발생시켜야한다. ** . | 도메인 만의 검증을 추가한다. . 복수/일급이라면 복수에 대한 것만 추가한다. | validate( 정제input ) -&gt; 모든 검증 나열하고 나중에, 메서드 추출하기 | . public Cars(final List&lt;String&gt; names) { // 2-5-2. 개별 도메인 검증 메서드 생성 validate(names); this.cars = names.stream() .map(name -&gt; new Car(name)) .collect(Collectors.toList()); } private void validate(final List&lt;String&gt; names) { long distinctCountOfNames = names.stream().distinct().count(); if (distinctCountOfNames != names.size()) { //2-5-3. thr 이후 해당 에외클래스() 생성 -&gt; 필요 예외 상속후 생성자만 메세지 파라미터 없이 정의 -&gt; 내부에서 super(&quot;message&quot;) throw new IllegalArgumentException(&quot;중복값을 입력할 수 없습니다.&quot;); //throw new DuplicateNameException(); } } . | . 03 커스텀 예외클래스 만들기 . thrw new 다음에 발생시킬 에러에 예외 클래스를 명시하고 . 상속할 기존 예외클래스를 extends한 뒤 | 부모예외클래스에서 필요했던 파라미터를 생성자로 받든지 or 내부에서 제공할 것으로, 파라미터 없는 생성자를 정의해주고 | 부모 생성자를 그대로 빌려 super() 내부에서 부모가 필요했던 상수를 생성자 내부에서 정의해주자. | . public class NameDuplicatedException extends IllegalArgumentException { public NameDuplicatedException() { super(&quot;이름이 중복될 수 없습니다.&quot;); } } . | . 04 invalid 테스트 . valid: 올바른_도메인이_들어올_경우를_확인한다 | invalid: 도메인이_중복된_경우_예외를_발생시킨다 | . @Test void invalid_domain2_input_exception_check() { //given final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재성&quot;); //when,then assertThatThrownBy(() -&gt; new RacingService(names)) .isInstanceOf(NameDuplicatedException.class) .hasMessageContaining(&quot;중복&quot;); } . 05 개별input~서비스객체 생성 -&gt; 재귀메서드화 in Controller생성자 . 에러시 재입력 받게 하기 위함. . public Controller(final InputView inputView) { //racingService = new RacingService(inputView.getNames()); getNames(inputView); } private void getNames(final InputView inputView) { try { racingService = new RacingService(inputView.getNames()); } catch (Exception e) { System.out.println(&quot;[ERROR] &quot; + e.getMessage()); getNames(inputView); } } . | . 재귀달린이후 테스트: 틀-&gt;맞으로 구성된 SequenceInputStream . 재귀 달린 순간부터 SequenceInputStream아니어서, 1번 틀리면 ControllerTest 안끝남. . @Test void input_null_or_empty_test() { // final String argument = &quot;&quot;; // final InputStream input = new ByteArrayInputStream((argument + &quot; n&quot;).getBytes()); // // System.setIn(input); final String argument1 = &quot;&quot;; // 틀 final String argument2 = &quot;재성, 재경&quot;; // 맞아서 재귀 통과 final InputStream input1 = new ByteArrayInputStream((argument1 + &quot; n&quot;).getBytes()); final InputStream input2 = new ByteArrayInputStream((argument2 + &quot; n&quot;).getBytes()); final SequenceInputStream sequenceInputStream = new SequenceInputStream(input1, input2); System.setIn(sequenceInputStream); assertThatThrownBy(() -&gt; new Controller(new InputView())).isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;빈칸&quot;); } . | 문제는.. 추가되는 재귀input -&gt; 기존꺼 계속 Sequnece 이어져야함 -&gt; 재귀는 가장 나중에 달던가 [TDD는 하지말자.] . | . 06 메서드 파라미터로 들어오는 개별input과 이미 생성[되었을] service객체 . 이미 controller생성자 위쪽에서, 서비스 생성과 동시에 받아주는 input으로 service객체를 생성한 상태이므로, valid한 앞쪽 개별input을 미리 만들어주고, service객체를 만들어서 테스트해줘야할 듯 싶다. . 먼저 개발된 valid_domain1_input으로 service객체를 먼저 만들면서 메서드 + domain2_input을 넣어주도록 한다. . | 그래야 메서드(initDomain2()) 개발이 된다. . | . @Test void valid_domain2_input_check() { //given final List&lt;String&gt; validNames = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); final int round = 4; //when,then assertDoesNotThrow(() -&gt; new RacingService(validNames).initiateRound(round)) } . | service의 생성자에서 못받은 개별input을, service관리 인변에 넣어주자. . public void initiateRound(final int round) { this.round = new Round(round); } . | 07 invalid case -&gt; 도메인 검증 추가 작업 반복 . @Test void invalid_domain2_input_range_exception() { //given final List&lt;String&gt; validNames = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); final int round = -1; //when,then assertThatThrownBy(() -&gt; new RacingService(validNames).initiateRound(round)) .isInstanceOf(RoundRangeException.class) .hasMessageContaining(&quot;0회 이상&quot;); } . 08 개별input 재귀화 -&gt; TDD는 하지말것 . getRound(inputView); private void getRound(final InputView inputView) { try { racingService.initRound(inputView.getRound()); } catch (Exception e) { System.out.println(&quot;[ERROR] &quot; + e.getMessage()); getRound(inputView); } } . ControllerTest (재귀 올 개발 후 ) . 01 재귀작성 완료후 [개별input ALL 맞-&gt;맞 ]으로 컨트롤러 생성자 테스트 . 재귀가 추가됨에 따라, controller생성시 추가 &amp;&amp; 맞는 것으로 맞춰줘야하는 input이 늘어나기 때문에, controller생성으로 인한 input테스트는 가장 나중에 해야할 것 같다. . 개별input개수만큼 SequenceInputStream으로 들어가게 해준다. | . @Test void controller_input_test() { final String argument1 = &quot;재성, 재경&quot;; // 틀 final String argument2 = &quot;5&quot;; // 맞아서 재귀 통과 final InputStream input1 = new ByteArrayInputStream((argument1 + &quot; n&quot;).getBytes()); final InputStream input2 = new ByteArrayInputStream((argument2 + &quot; n&quot;).getBytes()); SequenceInputStream sequenceInputStream = new SequenceInputStream(input1, input2); System.setIn(sequenceInputStream); assertDoesNotThrow(() -&gt; new Controller(new InputView())); } . | . 02 컨트롤러 생성자withInput 전체를 셋업 올리고 -&gt; Controller.run (new OuputView()) 개발 . Controller controller; @BeforeEach void setUp() { final String argument1 = &quot;재성, 재경&quot;; // 틀 final String argument2 = &quot;5&quot;; // 맞아서 재귀 통과 final InputStream input1 = new ByteArrayInputStream((argument1 + &quot; n&quot;).getBytes()); final InputStream input2 = new ByteArrayInputStream((argument2 + &quot; n&quot;).getBytes()); SequenceInputStream sequenceInputStream = new SequenceInputStream(input1, input2); System.setIn(sequenceInputStream); controller = new Controller(new InputView()); } @Test void controller_run() { controller.run(new OutputView); } . public class OutputView { } . //controller public void run(final OutputView outputView) { //outputView의 기본 프린터 기능 쓰면서 //메인로직 //메인로직이후 service에게서 결과받은 것 -&gt; ouputView가 인자로 받아서 처리 } . 03 controller.run()내부에 service로직 + OuputView처리 . public void run(final OutputView outputView) { outputView.printStartMessage(); while (racingService.isContinuable()) { racingService.race(new RandomNumberGenerator()); racingService.decreaseRound(); } outputView.printRoundResult(racingService.getCurrentCars()); outputView.printWinner(racingService.getWinners()); } . 04 OutputView 결과받아 출력 작성 with OutputView Test . setup . OutputStream output; @BeforeEach void setUp() { output = new ByteArrayOutputStream(); System.setOut(new PrintStream(output)); // output.toString() -&gt; actual 로서 print된 스트링을 받아올 수 있게 된다 } . output에 들어갈 결과(dto or dtoList)를 만들어서 output에 뿌려주기 . @Test void name() { //(1)outputView.printRoundResult(racingService.getCurrentCars()); // racingService.getCurrentCars() -&gt; List&lt;CarDto&gt; 만들어주기 //controller.run()에 사용되던 dto결과들을 단일dto.of() -&gt; dto list -&gt; dtos 까지 직접 만들어준다. final CarDto 재성 = CarDto.of(&quot;재성&quot;, 1); final CarDto 재경 = CarDto.of(&quot;재경&quot;, 2); final List&lt;CarDto&gt; cars = Arrays.asList(재성, 재경); //(2) outputView객체 만들어서 print뿌려주기( output에 박히게 됨 ) new OutputView().printRoundResult(cars); //(3) print뿌려진 output.toString()과 예상string을 비교하기 // -&gt; sout는 System.lineSeparator()로 줄바꿈한다. // -&gt; 내부string은 n로 작성되면 -&gt; n 잡으면 된다. assertThat(output.toString()).isEqualTo(&quot;재성 : - n재경 : -- n&quot; + System.lineSeparator()); } . @Test void name2() { final CarDto 재성 = CarDto.of(&quot;재성&quot;, 1); final CarDto 재경 = CarDto.of(&quot;재경&quot;, 0); final List&lt;CarDto&gt; cars = Arrays.asList(재성, 재경); final CarsDto carsDto = new CarsDto(cars); new OutputView().printRoundResult(cars); assertThat(output.toString()).isEqualTo(&quot;재성 : - n재경 : n&quot; + System.lineSeparator()); } . @Test void name3() { //outputView.printWinner(racingService.getWinners()); // racingService.getWinners() -&gt; CarsDto 만들어주기 final CarDto 재성 = CarDto.of(&quot;재성&quot;, 2); final List&lt;CarDto&gt; cars = Arrays.asList(재성); final CarsDto carsDto = new CarsDto(cars); new OutputView().printWinner(carsDto); assertThat(output.toString()).isEqualTo(&quot;재성&quot; + System.lineSeparator()); } . @Test void name4() { //outputView.printWinner(racingService.getWinners()); // racingService.getWinners() -&gt; CarsDto 만들어주기 final CarDto 재성 = CarDto.of(&quot;재성&quot;, 2); final CarDto 재경 = CarDto.of(&quot;재경&quot;, 2); final List&lt;CarDto&gt; cars = Arrays.asList(재성, 재경); final CarsDto carsDto = new CarsDto(cars); new OutputView().printWinner(carsDto); assertThat(output.toString()).isEqualTo(&quot;재성, 재경&quot; + System.lineSeparator()); } . Application으로 controller.run(new OutputView()) 실행 . import controller.Controller; import view.InputView; import view.OutputView; public class application { public static void main(final String[] args) { final Controller controller = new Controller(new InputView()); controller.run(new OutputView()); } } .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/28/TDD-4-controller~inputview~%EB%8F%84%EB%A9%94%EC%9D%B8%EA%B2%80%EC%A6%9D.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/28/TDD-4-controller~inputview~%EB%8F%84%EB%A9%94%EC%9D%B8%EA%B2%80%EC%A6%9D.html",
            "date": " • Feb 28, 2022"
        }
        
    
  
    
        ,"post16": {
            "title": "TDD 3 자경(단일Dto~Service)",
            "content": "Controller와 Service . Controller는 도메인Service 의존하며, 생성자에서 같이 초기화된다. . controller의 생성자에서 inputView와 outputView와 함께, 생성된 or 생성한 service객체를 받아준다. . public GameController(GameService gameService, InputView inputView, OutputView outputView) { //controller가 알고 있던 빈 service객체에 this.gameService = gameService; // 외부에서 받음 this.inputView = inputView; this.outputView = outputView; } . | 컨트롤러 생성시 inputView객체를 받고 . 받은 inputView를 생성자에서 이용하여 inputView.getDto() 등의 데이터를 인자로 받아 Service를 생성한다. | 한번에 input을 받을 수 있을 경우, input에서 getDto로 Service로 다 가져온다. | outputView는 controller 작동시 인자로 받아서 사용된다. | . public GameController(InputView inputView) { //controller가 알고 있던 빈 service객체에 //외부에서 받은 InputView를 이용하여 service를 생성하여 초기화 racingGame = new RacingGame(inputView.getInitDto()); } public void run(OutputView outputView) { playGame(outputView); endGame(outputView); } public static void main(String[] args) { GameController controller = new GameController(new InputView()); controller.run(new OutputView()); } . | 컨트롤러 생성시 컨트롤러 생성자에서 service도 데이터없이 먼저 생성한다. . service가 필요한 데이터는 메서드의 인자로 받아서 service에 set한다. | . public RacingController() { racingService = new RacingService(); } // 한꺼번에 input을 dto로 받는게 아니라면, 개별로 -&gt; 메서드를 통해 input을 따로 입력받는다. racingController.generateRacingCars(carNameInput()); public static void main(String[] args) { RacingController racingController = new RacingController(); racingController.generateRacingCars(carNameInput()); int round = roundInput(); RacingCarOutput.printRoundResultMessage(); race(racingController, round); racingController.checkWinners(); } . | Controller[생성]시 inputView 받 -&gt; Service는 input데이터 받는 안받든 초기화하여 생성. + [작동]시 결과가져 줄OuputView를 받아 전달 . inputView에서 재입력 or 나눠서 받아야하는 경우가 아니라면 new Service( inputView.getInitDto() ) 생성시 받아 생성 | 먼저 서비스부터 생성되고 이후 순서대로 데이터를 set해야하는 경우, 먼저 서비스를 생성 new Service() 이후, 메서드 사용하면서 초기화 | . 객체 -&gt; Service까지 TDD . 단일 객체 TDD . 참고: TDD2 자동차경주 블로그 / DTO 단계별 적용 + 테스트 . 인자 없는 생성자 new Car() + 응답하는 메서드 + 값으로 비교부터 시작해서, 블로그 글을 보고 완성한다. | when 객체 와 생성자로 만든 예상객체를 비교한다. | . @Test void car_move_1step() { final Car car = new Car(&quot;재성&quot;, 0); car.move(4); assertThat(car).isEqualTo(new Car(&quot;재성&quot;, 1)); } @Test void car_move_2step() { final Car car = new Car(&quot;재성&quot;, 0); car.move(4); car.move(4); assertThat(car).isEqualTo(new Car(&quot;재성&quot;, 2)); } @Test void car_move_stop() { final Car car = new Car(&quot;재성&quot;, 0); car.move(3); assertThat(car).isEqualTo(new Car(&quot;재성&quot;, 0)); } . | . 필요시 도메인 검증 테스트 . 단일 Dto TDD . 완성된 단일 객체 -&gt; 꽁꽁 싸멘 일급컬렉션으로 가기 전에, List&lt;단일Dto&gt;가 있어야 일급컬렉션 결과조회 by toDto()로 가능할 것 같다. | . 단일객체의 모든 인스턴스 변수(필드)을 원시값으로 받는 Dto.of( , )로 받도록 정팩매부터 설계하고, getter로 뽑는 확인만 해주자. . final CarDto 재성 = CarDto.of(&quot;재성&quot;, 1); // Car의 모든 필드을 원시값으로 받아 만든다. assertThat(재성.getName()).isEqualTo(&quot;재성&quot;); . private final String name; private final int position; public CarDto(final String name, final int position) { this.name = name; this.position = position; } public static CarDto of(final String name, final int position) { return new CarDto(name, position); } public String getName() { return name; } public int getPosition() { return position; } @Override public boolean equals(final Object object) { . | 일급 TDD . 단일객체들 생성 -&gt; list에 넣기 -&gt; 일급 or 서비스에 넣기 -&gt; 단일객체 조정 -&gt; 그대로 반영 | . 정제가상 재료로 셋업 . input으로 들어오는 List&lt;String&gt;으로 split 정제되어 들어온다고 가정하고 setUp에 세팅한다. . Cars cars; @BeforeEach void setUp() { final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); cars = new Cars(names); } . | 필요시 도메인 검증 테스트 . input에서부터 정제된 데이터(split, convert)가 들어왔을 때, 검증하자. | . 기능 결과 확인용 toDto() 부터 . 일급은 쌓여져있어서 확인이 힘들다. -&gt; toDto()로 List&lt;단일Dto&gt;로 가져와서 확인한다. . 개발1: .getCurrentCars()로서 List&lt;단일Dto&gt;를 가져온다. | . @Test void toDto() { //3-3. 일급의 기능개발 전, 확인이 될 수 있게 현재 객체들을 Dto List로 가져오는 기능 // -&gt; 내부에서 dto가 단일객체를 이용하도록 짤 것 final List&lt;CarDto&gt; currentCars = cars.getCurrentCars(); // assertThat(currentCars.get(0)).isEqualTo(CarDto.of(&quot;재성&quot;, 0)); // List의 검사는 contains, containsOnly로도 검사할 수있따. assertThat(currentCars).contains(CarDto.of(&quot;재경&quot;, 0)); } . | . 일급.toDto()를 통한 메서드 기능 테스트 . 각종 확인 방법 . 일급.toDto() contains ( 예상객체 by Dto.of) | 일급.toDto() containsOnly ( 예상객체1, 2 by Dto.of) isEqualTo ( Arrays.asList(예상객체1, 2 by Dto.of)) | . | 일급.toDto() .get( index) isEqualTo ( **예상객체 by Dto.of **) | 일급.메서드() -&gt; 객체 isEqualTo ( **예상객체 by Dto.of **) | 단일Dto.from( 객체 1개 ) 개발 .getter() isEqualTo ( 값 ) | . @Test void race_move_1step() { cars.race(5); assertThat(cars.getCurrentCars()).contains(CarDto.of(&quot;재성&quot;, 1)); } @Test void race_move_0step() { cars.race(3); assertThat(cars.getCurrentCars()).contains(CarDto.of(&quot;재성&quot;, 0)); } @Test void get_max_position_cars() { cars.race(4); final Car maxPositionCar = cars.getMaxPosition(); assertThat(CarDto.from(maxPositionCar).getPosition()).isEqualTo(1); } . | . 단일Dto.from( 응답객체 ) 개발 -&gt; (객체비교불가상황)응답 값 1개만 getter 추출 -&gt; 값 비교 테스트 . 현재 maxPosition인 Car객체 (List)를 뽑기 위해 중간, Car객체 1개 추출 로직을 테스트해야한다. . actual에서 단일객체 1개마 뽑히는 상황 -&gt; 단일객체1 to 단일Dto로 바로 가도록 단일Dto.from() 정펙매를 만들어줘야 -&gt; 값을 추출할 수 있다. | 필드 1개만 알고 있는 상황을 확인해야하므로, max인 값을 가진 Car를 뽑아내기 때문에, 임의로 CarDto.of( , , )로 만들 수 없는 상황 | . @Test void get_max_position_car() { cars.race(4); final Car maxPositionCar = cars.getMaxPosition(); // 이름은 모름, position만 1인 것을 아는 상황. -&gt; 값으로 비교해야함 -&gt; Dto에서 뽑아내야함. } . public static CarDto from(final Car car) { return new CarDto(car.getName(), car.getPosition()); } . @Test void get_max_position_car() { cars.race(4); final Car maxPositionCar = cars.getMaxPosition(); //my) &lt;일부 속성(이름제외된 숫자속성)만 변화되어, 객체==만든 예상객체&gt;의 비교가 불가능할 경우, // 실제 객체를 -&gt; dto변형 후 값을 뽑아내 -&gt; 값 대 값으로 확인할 수 도 있다. assertThat(CarDto.from(maxPositionCar).getPosition()).isEqualTo(1); } . | . 일급의 응답(List&lt;객체&gt;)는 -&gt; 한방에 DtoList or 복수Dto로 한방에 . 일급이 사용되는 serivce에게는 DtoList or 복수 Dto로 응답해야한다. . 어차피 응답은 객체List로 오니 -&gt; 복수Dto.from( List&lt;객체&gt;)로 한방에 돌리자. | 내부에서 이미 개발된 stream 단일객체 + 단일Dto.from( 단일객체) -&gt; list로만 만들어주면 된다. | 대신 dto용 getter에 이름을… get()로 단순화시키자. | . @Test void get_max_position_cars() { cars.getWinners(); } . //일급 응답이 객체리스트? -&gt; 한방에 복수Dto.from만들기 public List&lt;Car&gt; getWinners() { final Car maxPositionCar = getMaxPosition(); return this.cars.stream() .filter(car -&gt; car.isSamePosition(maxPositionCar)) .collect(Collectors.toList()); } . // 이미 단일Dto.from이 개발된 상황이라면, // 객체리스트 -&gt; 복수Dto 한방에 개발한다. return CarsDto.from(this.cars.stream() .filter(car -&gt; car.isSamePosition(maxPositionCar)) .collect(Collectors.toList())); . public static List&lt;CarDto&gt; from(final List&lt;Car&gt; cars) { // 단일Dto List로 일단 만든 뒤 -&gt; 생성자 호출 예정 return cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList()); } . return CarsDto.from(this.cars.stream() .filter(car -&gt; car.isSamePosition(maxPositionCar)) .collect(Collectors.toList())); . private final List&lt;CarDto&gt; carsDto; public CarsDto(final List&lt;CarDto&gt; carsDto) { this.carsDto = carsDto; } public static CarsDto from(final List&lt;Car&gt; cars) { return new CarsDto(cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList())); } //public List&lt;CarDto&gt; getCarsDto() { public List&lt;CarDto&gt; get() { return carsDto; } . dtoList .get() -&gt; Dto List -&gt; 1개 뽑아서 값 비교..(현재 이름모르고 1개 값만 아는 상태) | . @Test void get_max_position_cars() { cars.race(4); cars.race(4); cars.race(4); final CarsDto winnerCars = cars.getWinners(); //복수Dto.get() -&gt; List &lt;단일Dto&gt; assertThat(winnerCars.get().get(0).getPosition()).isEqualTo(3); } . | . Service 객체 TDD . inputView로부터 오는 도메인의 재료를 컨트롤러 내부에서 생성될 때, 생성자로 될 때 받을지 | 객체생성 후, generate로 | | input재료들 -&gt; 받아서 생성자를 통한 일급 or List단일로의 변환 생성도 서비스 안에서 이루어진다. 필요재료라 인스턴스 변수로 관리해야한다. | . | . 재료없이 service객체 셋업 (원래 미리 생성 in 컨트롤러) . 컨트롤러에서 사용한다고 생각하자. . | 일단 컨트롤러 생성자에서부터 미리 서비스를 미리 생성시킬 예정이다. . 재료가 한번에 오면 initDto -&gt; service미리 생성시킬 시 받아주면 되는데 . @BeforeEach void setup() { racingGame = new RacingGame(InitDto.of(&quot;juri,hunch&quot;, &quot;5&quot;)); } . | 그게 아니라면, service.generate일급()처럼, 원재료를 일급/List객체로 변환하는 작업도 service가 담당한다. . public RacingController() { racingService = new RacingService(); } . | . | 셋업에 서비스 미리 생성 . RacingService racingService; @BeforeEach void setUp() { racingService = new RacingService(); } . | . input재료들을 받는 service 생성자도 만들어, 셋업에서 관리변수 채워놓기. . input을 나중에 받더라도.. 미리 만들어져있어야하구나. 그래야 꺼내는 기능만을 확인할 수 있다. . | service안에 관리 변수에 뭐가 들어있어야… 확인이 된input원재료 -&gt; 관리 변수 (Cars cars)를 통채로 받아주는 놈을 임시로 만들자. . 검증은 각 도메인 내에서 할 것임. 변환생성해주는 서비스에서 하지말자. | . @BeforeEach void setUp() { final List&lt;String&gt; carNames = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;, &quot;아라&quot;); racingService = new RacingService(carNames); } . private Cars cars; public RacingService(final List&lt;String&gt; carNames) { this.cars = new Cars(carNames); } . | . 기능 결과 확인용 일급.toDto() 호출 함수부터 . 서비스는 내부에 인스턴스변수로 일급 (or 객체List)를 관리한다. . 일급이나 객체List를 확인하는 방법은 toDto로 미리 정의해놓았다. | 이것을 부르는 메서드(getCurrent일급())를 먼저 TDD한다. 이름만 get일급()이지, toDto한 List&lt;Dto&gt;를 가져온다. | . | . @Test void get_current_cars() { racingService.getCurrentCars(); } . public class RacingService { public void getCurrentCars() { this.cars.getCurrentCars(); } } . public class RacingService { private Cars cars; public List&lt;CarDto&gt; getCurrentCars() { return this.cars.getCurrentCars(); } } . java @Test void get_current_cars() { final List currentCars = racingService.getCurrentCars(); . assertThat(currentCars).contains(CarDto.of(&quot;재성&quot;, 0)); } . | . 미리 안넣어놓고, 차후 setter역할의 service.generate()로 input재료 -&gt; 해당도메인 객체(일급) 변환 생성 TDD . 서비스는 해당도메인의 기능을 모아둔 것이다. 일단 해당도메인으로 변환시킨다. . 서비스.해당도메인생성( input재료) -&gt; 내부 관리 인스턴스 변수(일급orList)에 set되는 것을 확인해야한다. | 그것을 빼쓰라고 만든게 일급.toDto()있으니, 서비스에서 일급DTO내놔 메서드를 호출해서 컨트롤러에 제공해준다. | . @Test void generate_cars() { //given: input에서 오는 원재료 final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); //when racingService.generateCars(names); } . public class RacingService { public void generateCars(final List&lt;String&gt; names) { this.cars = new Cars(names); } } . public class RacingService { private Cars cars; public void generateCars(final List&lt;String&gt; names) { this.cars = new Cars(names); } } . @Test void generate_cars() { //given: input에서 정제된 원재료 final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); racingService.generateCars(names); //when //then assertThat(racingService.getCurrentCars()).contains(CarDto.of(&quot;재성&quot;, 0)); } . | . 필요시 전략객체 service에서 생성하여, 메서드의 파라미터로 넣어주기 . 들어간 Service 변수(인스턴스 변수, 필요 변수)확인 테스트 . 관리(인스턴스) 변수 중 VO는 getDto없이 asssertThat().extracting으로 내부 인변 바로 뽑아 확인하기 . input정제 VO 원시값까지 받아주는 service 생성자 추가 생성 . @Test void get_round() { racingService = new RacingService(carNames, 5); } . VO 객체 개발 . //서비스 생성자 추가 public RacingService(final List&lt;String&gt; carNames, final int round) { this.cars = new Cars(carNames); this.round = new Round(round); } //VO 개발 public class Round { private final int round; public Round(final int round) { this.round = round; } @Override public boolean equals(final Object object) { . VO를 받아서 생성하는 service를 초기화 후, extracting으로 객체 뽑아서 1:1비교 . 기존 서비스는 노인자 -&gt; names(stringList-&gt;일급) -&gt; names 포함한 VO까지 받아서 처리 | . @Test void get_round() { racingService = new RacingService(carNames, 5); //when, then assertThat(racingService).extracting(&quot;round&quot;).isEqualTo(new Round(5)); } . 메인로직 TDD . 메인로직 실행 . 일급.메서드()를 실행시키는 단순로직 . 응답 값이 없는 실행 메서드다? 사용객체와 예상객체로 비교 | 랜덤값이 포함되어있으면, 그만큼 빼줘야한다… 하지만, 그냥 빼면… 일괄 적용되므로, 인터페이스로 빼고 -&gt; 필요한 곳에서 전략메서드 호출()하도록 뺀다. 테스트에선 전략객체 대신 최종 결과값만 넣어주면 됨. (여기선 생략) | . | . @Test void race() { racingService = new RacingService(carNames, 5); racingService.race(); racingService.race(); assertThat(racingService.getCurrentCars().get(0).getPosition()).isEqualTo(2); } . 전략 인페 + 전략메소드 정의 | 전략을 구현한 랜덤인페 + 메소드 정의 | 전략메소드 호출시점에만, 메소드 호출하여 랜덤 시행 + 그외에는 전략객체만 파라미터로 수정 | 테스트에선 람다식으로 인자 없이 랜덤한 return값을 직접 지정 () -&gt; return을 준다. | | . 메인로직 실행 횟수(VO)의 iterator TDD . service가 만들어질 때나, 만들어진 이후 가지고 set되어야할 VO는 service내부 관리 변수 확인 테스트에서 처음 등장했다. . @Test void get_round() { racingService = new RacingService(carNames, 5); assertThat(racingService).extracting(&quot;round&quot;).isEqualTo(new Round(5)); } . | 컨트롤러에서 service.메인로직()을 service.hasNext(VO)만큼 돌려야한다. . | . 01 service. isContinuable() -&gt; Vo.isNotFinish() -&gt; true/false를 테스트한다. . hasNext패턴의 while()문에 들어갈 조건부이다. . @Test void vo_is_continuable() { racingService = new RacingService(carNames, 5); final boolean isContinuable = racingService.isContinuable(); assertThat(isContinuable).isTrue(); } @Test void vo_is_not_continuable() { racingService = new RacingService(carNames, 0); final boolean isContinuable = racingService.isContinuable(); assertThat(isContinuable).isFalse(); } . //Service public boolean isContinuable() { return this.round.isNotFinish(); } //Round public boolean isNotFinish() { return this.round &gt; 0; } . | . 02 service.play메인로직() 내부에서 -&gt; 메인객체.메인로직() 와 동시에 돌아갈 + VO감소로직 VO.getNext(); 처리 . VO감소 -&gt; 감소된 VO반환하여 service관리 VO를 덮어쓰기 . 이 과정이 while문 true 내부 메인로직 돌아갈 때 같이 돌아가야한다. | . @Test void vo_can_decrease() { racingService = new RacingService(carNames, 4); //프로덕션코드에서는, 반복될 메인로직 실행부 메서드와 같이, race실행시 round감소를 같이시켜줘야한다. //racingService.play(); racingService.playWIthRoundDecrease(); } . //Service public void playWIthRoundDecrease() { //1. 메인(일급)객체.race() //2. decrease된 vo를 받아와야함 *값만 변화(round.decrease())하면 안됨 round = round.getNext(); } . //Round public Round getNext() { // 여기서는 0보다 커야한다는 검증이 있으면 0으로 갈때 에러가 나니 조심! // 검증은 hasNext패턴을 가지는 VO는 무조건 검증을 정팩메에 주자~ return new Round(this.round - 1); } . @Test void vo_can_decrease() { racingService = new RacingService(carNames, 4); //프로덕션코드에서는, 반복될 메인로직 실행부 메서드와 같이, race실행시 round감소를 같이시켜줘야한다. //racingService.play(); racingService.playWIthRoundDecrease(); //내부의 round값이 변화되기 때문에 -&gt; 응답 값이 아닌 사용객체 vs 예쌍객체로 비교해야한다. assertThat(racingService).extracting(&quot;round&quot;).isEqualTo(new Round(3)); } . | . 랜덤응답의 범위 TDD(단위테스트) . 랜덤을 생성하는 메서드를 학습하는 단위테스트 범위내로 들어오나? -&gt; isBetween(a, b) -&gt; a&lt; = &lt;= b의 검사 | . | . 값 1개의 랜덤: @RepeatedTest() + .isBetween . //사용할 객체 만들고 RandomNumberGenerator randomNumberGenerator; @BeforeEach void setUp() { randomNumberGenerator = new RandomNumberGenerator(); } //응답값의 범위 확인을 여러번 @RepeatedTest(100) void range_test() { assertThat(randomNumberGenerator.generate()).isBetween(0, 9); } . List의 랜덤: iterator의 hasNext패턴 -&gt; 객체비교 . @Test void Random_숫자범위_검사() { // 원래는 랜덤으로 차있는 list -&gt; iterator final ListIterator&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 44, 45).listIterator(); // 랜덤값들을 돌면서 검사 while (numbers.hasNext()) { assertThat(numbers.next()) .isGreaterThanOrEqualTo(1) .isLessThanOrEqualTo(45); } } .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/26/TDD-3-%EB%8B%A8%EC%9D%BCDto-~-Service.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/26/TDD-3-%EB%8B%A8%EC%9D%BCDto-~-Service.html",
            "date": " • Feb 26, 2022"
        }
        
    
  
    
        ,"post17": {
            "title": "TDD 2 자동차경주(객체Dto)",
            "content": "실패하는 코드를 짜는 이유? 통과하는 코드를 짜려고 하면, case단위가 아니라 다 짜야해서 너무 커진다. | case 만드는 것이 목적 -&gt; 실패 case부터 만든다. | . | 테스트코드도 복잡도를 낮춘다. | . 기능 요구사항 복붙후 정리 . 복붙 . 각 자동차에 이름을 부여할 수 있다. 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다. 자동차 이름은 쉼표(,)를 기준으로 구분한다. 자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한명 이상일 수 있다. . 제목(##) + 앞에 체크박스 만들기 . ## 요구사항 - [ ] 각 자동차에 이름을 부여할 수 있다. - [ ] 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다. - [ ] 자동차 이름은 쉼표(,)를 기준으로 구분한다. - [ ] 자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한명 이상일 수 있다. . 각 요구사항들을 테스트코드 DisplayName으로 작성하기도 한다. | . 키워드 뽑기 . ## 요구사항 - [ ] 각 자동차에 이름을 부여할 수 있다. - [ ] 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다. - [ ] 자동차 이름은 쉼표(,)를 기준으로 구분한다. - [ ] 자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한명 이상일 수 있다. - 자동차 - 이름 - 자동차 이름은 쉼표(,)를 기준 - 전진 - 게임 - 우승 - 우승자는 한명 이상 . 키워드 관계 재배치 . 객체인지 vs 메서드인지 vs 세부 요구사항인지 | 객체 중에 이름만 다르게 뽑을지 -&gt; 뽑는 것은 관리자 객체에서 우승한 자동차 -&gt; 자동차 중 뽑은 것 -&gt; 자동차 경주(관리자) | . | . - 자동차 - 전진: 자동차가 하는 것이니 객체가 아닌 메서드 - 우승한 자동차: 따른 객체인지 vs 자동차 중 뽑아서 이름만 다르게? - 우승자는 한명 이상: 세부 요구사항 - 이름 - 이름은 쉼표(,)를 기준: 세부 요구사항 - 자동차 게임: 자동차에서 우승한 자동차 뽑는 것은 이상하니, 게임이 관리하면서 뽑도록 - 우승한 자동차: 따른 객체인지 vs 자동차 중 뽑아서 이름만 다르게? - 우승자는 한명 이상: 세부 요구사항 . 시작점 고르기 . 자동차 게임 -&gt; 관리자부터 하기엔 잘 모름 | 자동차 -&gt; 핵심이자 간단한 단위 객체 진짜 잘 모르겠으면 이름부터 해도 된다. | . | . 출력, View에 대한 요구사항은 무시하고 객체 설계부터 시작 . UI, view를 맨나중에 붙이면, 객체다운 객체가 완성됨. | . TDD 시작 . 정의 없는 default생성자 사용 / 응답 하는 메서드부터 . TDD 시작점을 new Car();의 생성자에서 부터 시작하는 경우가 많다. . 보통은 Car car = new Car();의 생성자로 TDD를 시작한다. 여기서 시작해서 테스트 코드로 변하게 된다. | . | . @Test void 생성자_검사() { //방법1. 생성시 예외발생안함. assertDoesNotThrow(() -&gt; new Car(재성)); //방법2. 생성한 것이 null이 아님. final Car car = new Car(&quot;재성&quot;); assertThat(car).isNotNull(); } . | 여기서는 객체 생성자와 동시에 상수 먼저 응답하는 기능 메서드를 주 테스트로 시작한다 . 움직였을 때, 1칸 움직였다고 -&gt; 상수 1을 응답할거라 가정하고 작성한다. | . //1. 객체+Test로 테스트 class 작성 public class CarTest { @Test //2. (생성자 따로 검사하는게 아닌) 객체의 기능으로 메서드 명 먼저 작성 void move() { //3. 없어도 객체 생성자 호출 final Car car = new Car(); //4. 객체 기능을 호출하되, 테스트에 용이하도록 &lt;호출시 응답 결과값&gt;이 있을 거라 예상 -&gt; assertThat( actual )에 바로 값 넣어주기 //car.move() //5. 기대하는(나와야하는) 응답 값을 .isEqualTo( expected )에 넣어주기 assertThat(car.move()).isEqualTo(1); } } . | 컴파일 에러들을 잡는다. . 예상하는 응답값을 상수로 바로 나오도록 먼저 작성한다. | . public class Car { public int move() { return 1; } } . | 테스트를 돌려서, 상수 1로 응답하는지 확인한다. . | . case 추가(누적 -&gt; 응답 expected 변경 2) . 복붙으로 다른 Test case(메서드 맨끝_네임 수정)를 작성하며 안돌아가는 코드 구현 . 1칸 움직여서 1 반환하는 case도 있지만, 2번 움직이는 or 안 움직이는 케이스도 있음. . 메서드를 복붙해서 case를 나눈다 | . @Test void move_go() { final Car car = new Car(); assertThat(car.move()).isEqualTo(1); } @Test void move_go2() { final Car car = new Car(); //1. car.move(); //2. assertThat(car.move()).isEqualTo(2); // 2를 응답해줘야함. } . | . 기존 작성된 메서드를 메서드2로 복붙한 뒤 구현 . 기존 코드는 돌아가도록 하는 상태(move() 그대로 두기)에서 move() -&gt; move2()로 복붙한 뒤, 직전꺼도 포함해서 다 돌아가도록 구현 . package domain; public class Car { public int move() { return 1; } public int move2() { return 1; } } . 누적되려면, 저장할 변수가 필요해서 필드(인변)를 선언하여 거기다가 가지고 있도록 한다.. | . public int move2() { return position++; } . public class Car { private int position; public int move() { return 1; } public int move2() { return ++position; } } . | . 복붙 수정 메서드2를 사용해서 통과시켜본다. . 복붙new Test method 에서 복붙 method2()를 사용해서 통과시킨다. . @Test void move_go2() { final Car car = new Car(); //1. car.move2(); //2. assertThat(car.move2()).isEqualTo(2); } . | . 기존case도 수정 메서드2로 변경해보고 -&gt; 기존메서드()는 회색띄운 뒤 삭제 . 처음 테스트도 .move2()를 사용하게 한 뒤 테스트 . | 테스트 통과하면 기존 move()는 사용안되서 회색 떠있음 -&gt; alt + del로 안전삭제 . @Test void move_go() { final Car car = new Car(); assertThat(car.move2()).isEqualTo(1); } @Test void move_go2() { final Car car = new Car(); //1. car.move2(); //2. assertThat(car.move2()).isEqualTo(2); } . | . 최종 수정메서드2 -&gt; 매서드로 이름 변경 . .move2()가 -&gt; .move()를 대체하는 순간 . @Test void move_go() { final Car car = new Car(); assertThat(car.move()).isEqualTo(2); } @Test void move_go2() { final Car car = new Car(); //1. car.move(); //2. assertThat(car.move()).isEqualTo(2); } } . | . case 추가(조건 따라 stop -&gt; expected는 stop일때 나와야하는 값으로 미리 넣어두기 0) . 복붙 Test case 추가 ( 설계전 해당 case expected입력해서 error) . move_stop케이스 추가 -&gt; expected 0을 응답하도록 작성하기 . @Test void move_stop() { final Car car = new Car(); //1. 1번움직였는데 &gt; 0을 응답해야하는 경우도 처리 assertThat(car.move()).isEqualTo(0); } . | . 메서드2()로 복사해서 다시 처리 . 해당 조건일 때만 움직이게 해준다. . public int move2() { if (ThreadLocalRandom.current().nextInt(10) &gt;= 4) { position += 1; } return position; } } . | . 내부 랜덤 포함 메서드는 테스트 실행시마다 결과가 다르다. . 특정 테스트 바깥에 커서를 두고 전체 테스트 실행 랜덤이 껴있는 경우 돌릴 때 마다 다르게 결과 | . | . 랜덤은 가능한 구조로 바꿔주기 . 랜덤부분만 파라미터화시켜 밖으로 빼준다. . 기존 . public int move() { if (ThreadLocalRandom.current().nextInt(10) &gt;= 4) { position += 1; } return position; } . | 파라미터화시켜 밖으로 빼기 . 자동으로 사용중이던 부분(랜덤)이 –&gt;메소드 사용처로 이동된다. | . public int move(final int number) { if (number &gt;= 4) { position += 1; } return position; } . assertThat(car.move(ThreadLocalRandom.current().nextInt(10))).isEqualTo(0); . | . 사용처의 랜덤생성을 특정 상수로 바꾼다. . 랜덤은 프로덕션 코드에서만 사용되므로 추출되어 사용처로 옮겨간 랜덤부분을 테스트에서는 상수로 변경한다. . @Test void move_go2() { final Car car = new Car(); car.move(5); assertThat(car.move(5)).isEqualTo(2); } @Test void move_stop() { final Car car = new Car(); assertThat(car.move(3)).isEqualTo(0); } } . | . 랜덤 뿐만 아니라 랜덤포함조건자체를 객체의 역할로 . 객체가 테스트를 위한 랜덤부분 외부 파라미터로 추출 뿐만 아니라 . | if 조건에 따른 다른 역할을 하는 객체로 취급하고 싶다면 if조건 자체를 인터페이스로 추출할 수 있다. . 전략패턴은 대체가능한 다른전략을 넣는 부분을 인터페이스 -&gt; 전략메서드로 추출해놓는다. | . 바뀔 수 있는 부분을 잡아서 상태에 맞게 메소드로 추출해놓는다. . | 인터페이스 XXXXStrategy + 이름만 가진 추상메서드를 만든다. . | 특정Strategy의 이름을 정해서 impl구상클래스를 추출메소드를 복붙해서 구현한다. . | 특정전략의 메소드가 사용된 곳마다 —&gt; 다른전략을 허용하는 추상화된 인터페이스 객체를 인자로 받은 뒤 -&gt; 추상체.추출메소드()호출로 수정한다. . | 이제 에러난 부분을 타고가면서, *내부 매개변수 정의에 사용된 추상 인자를 호출하는 외부 인자 자리에 new 특정전략()를 넣워준다. . | 테스트에서 다른전략으로 조건부의 상수인 람다함수로 () -&gt; true를 대입하여 움직임을 확인한다. . | | . 확인을 위한 응답 값(조회)이 실제 필요한지 의심해봐야한다 . 내부 position만 바뀌면 되는데, 테스트를 위해 응답하고 있지는 않은지 의심하자. | . 응답하는 것도 1가지 일(조회)다. 위치변경(테스트할 기능) + 조회 2가지 일을 하는 move() . 포지션을 조회하고 싶다면 또다시 car.move()를 호출해서 확인해야하나? 변하면서 조회되므로 이상하다. . public int move(final int number) { if (number &gt;= 4) { position += 1; } return position; } . | 조회는.. 응답 말고도 다른 방법이 있다. 값으로 만드는 객체로 비교 . | . 조회 메서드가 아니라면, 테스트 끝난 후, 응답 값 제거리팩토링 . 메서드2() 복붙 생성하여, 응답이 제거된 메서드2 생성 . public int move(final int number) { if (number &gt;= 4) { position += 1; } return position; } public void move2(final int number) { if (number &gt;= 4) { position += 1; } } . | Test에서는 assertThat()에 응답 값을 넣어줘야하는데? . assertThat(car.move(3)).isEqualTo(0); . | . 응답 값 대신 [해당객체]를 / expected 예상값 대신 예상값으로 생성한 + equals옵라된 [예상객체]를 . 예상값으로 예상객체를 만들어줄 생성자를 추가한다. . | 기존에는 default 생성자로서, 인자 없이 만들었다. Select None으로 기존 것도 사용가능하게 빈 default 생성자를 따로 정의해주자. . . public Car() { } . | 생성된 객체로 비교하기 위해, equals, hashCode를 옵라이딩 . | 응답 없는 메소드2로 치환 후, 객체.메서드2호출 - assertThat(객체). (예상객체) 로 비교 . 이제 전부 응답없는 메소드2로 치환 -&gt; actual 응답 자리에서 빼주기 . @Test void move_go() { final Car car = new Car(); car.move2(4); // 1.actual에는 실제응답 대신, 객체를 assertThat(car).isEqualTo(new Car(1)); // 2. 예상값으로 만든 예상객체 } . | 기존 assertThat( 응답값 ) .isEqualsTo ( 예상값) . assertThat(car.move(4)).isEqualTo(0); . | assertThat( 사용객체 ) .isEqualsTo ( 예상객체) . ar.move2(4); assertThat(car).isEqualTo(new Car(1)); . | . 생성자도… 테스트를 위한 생성자인지 고민 -&gt; 그렇다면 .getPosition() 대신 .position()으로 마무리? . get이라는 네이밍을 빼서 내부에 position이 있는지 모르게 하는게 핵심 | . 외부추출랜덤은 상위 객체 테스트를 막는다 . 자동차.move()의 내부 랜덤 추출 -&gt; 자동차.move(랜덤사용) -&gt; 자동차.move(랜덤사용)을 호출하는 자동차경주가 내부 랜덤을 포함하게 됨. | . 상위 객체(관리자) Test -&gt; List&lt; 테스트끝난객체&gt; 를 받도록 생성 -&gt; 돌면서 시켜야함. . 단일 테스트가 끝난 단일객체에 대해서 일급 컬렉션 생성 전 LIst&lt;단일&gt;을 사용 == 세팅by생성자( List&lt;단일객체&gt; )하는 상위객체, 관리자객체를 Test서부터 만든다. . 필요한 것은 set을 생성자에서 받는다. | 다 못받으면, 필요기능의 메서드 파라미터로 | . @Test void name() { final List&lt;Car&gt; cars = Arrays.asList(new Car(), new Car()); final RacingGame racingGame = new RacingGame(cars); } . public class RacingGame { public RacingGame(final List&lt;Car&gt; cars) { } } . public class RacingGame { private final List&lt;Car&gt; cars; public RacingGame(final List&lt;Car&gt; cars) { this.cars = cars; } } . | 관리자=상위객체에서 메서드() -&gt; list를 돌며 단일객체 메서드 시키기 . public class RacingGame { private final List&lt;Car&gt; cars; public RacingGame(final List&lt;Car&gt; cars) { this.cars = cars; } public void start() { cars.forEach( car -&gt; car.move(ThreadLocalRandom.current().nextInt(10))); } } . | Car만 테스트는 가능하고, 그 상위객체인 RacingGame은 테스트가 불가능한 상태다. . 원한다면 다시 랜덤부분을 파라미터로 추출하면 된다. | 어디까지 테스트가능 구조로 할지는 자기가 선택하는 것 | 상위객체도 테스트 가능한 구조로 만들고 싶다면, 파라미터화시켜 외부로 빼면 된다. | . | 가장 끝단의 객체를 찾고, 테스트 불가 부분을 밖으로 뺀다. . . 한단계 더 올리면, RacingGame도 테스트가 가능해진다. . . | 랜덤, 특정 날짜에만 작동 등이 테스트하기 힘든 코드다. . 외부로 분리해서 주입한다. | . | . .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/24/TDD-2-%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/24/TDD-2-%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Feb 24, 2022"
        }
        
    
  
    
        ,"post18": {
            "title": "피드백) 1-1(자동차경주) 코드리뷰",
            "content": "자경 미션 피드백 . PR 1차 피드백 | PR 2차 피드백 리뷰어: 코니 | . | . 네이밍 . if절에 들어가는 메서드명은 is~, has~로 시작하자. | VO의 새객체 반환 메서드네이밍을 toNextRound()로 잡았다. to는 괜찮을까? toString, toDto 같이 형 변환시에만 사용하자.. 또 바꿔야겟넹.. getNextRound() | . | Util이라는 추상적인 이름 대신 Validator처럼 구체적인 이름으로 클래스 잡기 . | 조건문 전체가 아니라, 일부 값 비교에서도 네이밍을 변수로 추출하는게 좋다 . private static void checkDuplicated(List&lt;String&gt; carNames) { if (carNames.stream().distinct().count() != carNames.size()) { long distinctCountOfCarNames = carNames.stream().distinct().count(); if (distinctCountOfCarNames != carNames.size()) { . | 추출할 때, 메서드의 인자는 구체적으로X 좀더 추상적으로 정의해주기 | . 체크 . 메소드 사용 순서대로 배치후 commit -&gt; 커밋전 체크리스트화 structure(alt+7) | . | 불필요 공백 제거후 coimmit | 테스트 코드 돌리고 commit @parameterizedTest &lt;-&gt; @Test | . | intellij 상수, 변수추출을 private으로 최초 1번 옮겨주기 | 유틸이라도 해당 class에서만 사용된다면, private 으로 변경해줘야한다. . | static 유틸 클래스는 private생성자로 객체생성없음을 명시해주기 | 상수 &lt;-&gt; 멤버변수 개행 1줄 넣어주기 . | 전략메서드에는 인페/클래스명에 있는 목적어(number)를 repeat할 필요없다. 동사(generate)만 | . 검증 . 실수로 기입된 내부공백(Blank) 검사는 문자열숫자의 format검사가 있다면 안해도 된다. . | 부정조건문 없애자 . | . 생성자 . static 유틸 클래스는 private생성자로 객체생성없음을 명시해주기 . | 접근제한자 기본은 private으로 바꿔주기 . | 도메인은 input이외에 자체 검증 -&gt; input에서는 공통검증 / 도메인 자체검증 생성자 . | 생성자 로직 private 기본 생성자 | public from( 원본 List&lt; Car&gt;) + Cars검증로직(중복 등) | public fromNames or fromInput(List&lt; String &gt;) + Cars검증로직(중복 등) | . | 테스트에서 단일-&gt; 단일List 만든 뒤, 단일 조정 by메서드 -&gt; 단일List에 반영 -&gt; 반영된 단일List로 일급컬렉션 생성 | 불변을 위해 포인터의 포인터 사용을 막아야하는데, 테스트에서는 포포를 사용할 수 있게 inputString List가 아닌 단일객체List로부터 만드는 생성자(정펙매) 추가 | . | . 기본 . split은 2번재 인자를 줘야, ,, 를 안씹고 간다. -&gt; split( , -1) . String[] split = &quot;,,&quot;.split(&quot;,&quot;); // count 0 String[] split1 = &quot;,,a&quot;.split(&quot;,&quot;); // 3 String[] split2 = &quot;,a,&quot;.split(&quot;,&quot;); // 2 String[] split3 = &quot;a,,&quot;.split(&quot;,&quot;); // 1 . | split후 trim까지 해서 반환해야 a, a를 다른 것으로 인식한다. -&gt; split(,-1).map(String::trim) . return Arrays.stream(value.split(delimiter, -1)) .map(String::trim) .collect(Collectors.toList()); . | convert나 split관련 기본api가 충분하면, 유틸 메서드로 따로 빼지말고 그냥 사용하자. 지식만 늘어난다. . | 조건문의 전략객체(Functional interface)에는 () -&gt; 람다식으로 테스트한다. . | . VO, DTO . Dto는 controller에 일단 넣어준다. . | ROUND는 hasNext패턴으로 줄어가는데, 생성자 검증은 1이상 &lt;-&gt; 1씩 줄여가니 0까지는 감. 생성자에서 검증하되, 새객체 반환은 검증없는 private 기본생성자이용 | . | DTO는 VO나, 포장객체 없이 only 원시값들로 필드가 구성 -&gt; Dto사용을 위한 원본 getter에서는 VO-&gt;value까지 최종반환시킨 getter . | VO를 가진 단일객체의 compareTo에 원시값 비교 x -&gt; VO로 비교 -&gt; VO도 비교가능하게 . | 정펙매 생성자 중간에 VO가 등장할 경우, getter()를 써도 된다. . | VO는 검증/불변을 위해 래핑한 것이므로, 도입했다고 굳이 정펙매를 외부에 오픈안해도 된다 . private Cars getCars() { try { return Cars.fromNames(InputView.getCarNames()); //Cars.fromNames(Names.fromInput(InputView.getCarNames())); . 같은 context에서 사용될 일이 없는, 객체 생성 가운데 활용되는 객체들은 구현을 드러내지 않는 것이 좋을 것 같습니다! | . | . 테스트 . DTO의 테스트는 view처럼 자주 바뀌는 DTO에 대해 테스트를 생각해본다. . | DisplayName은 너무하다 싶을정도로 자세히 쓴다. . class NameTest { //@DisplayName(&quot;이름이 1자 미만, 5자 초과일 경우&quot;) //@DisplayName(&quot;자동차 이름이 1자 미만, 5자 초과하여 유효하지 않은 경우&quot;) @DisplayName(&quot;자동차 이름이 1자 미만, 5자 초과하여 유효하지 않은 경우 예외가 발생한다&quot;) . 이정도로 결과까지 명확하게 서술하면 더 좋습니다. | . | @ValueSource의 빈 문자열과 @EmptySource가 같은 값을 제공하지 않나요? . @EmptySource @ValueSource(strings = {&quot;&quot;, &quot;Wishoon&quot;, &quot;123456&quot;}) . | .",
            "url": "blog.chojaeseong.com/java/feedback/review/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/23/%ED%94%BC%EB%93%9C%EB%B0%B1)-1-1(%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC)-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0.html",
            "relUrl": "/java/feedback/review/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/23/%ED%94%BC%EB%93%9C%EB%B0%B1)-1-1(%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC)-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0.html",
            "date": " • Feb 23, 2022"
        }
        
    
  
    
        ,"post19": {
            "title": "강의) 네오 1단계 자경 피드백",
            "content": "final 키워드로 값의 변경을 막아라 . 값은 final로 재할당금지 -&gt; 재사용 금지 . . main 메소드 template 인 psvm의 인자에도 final을 붙혀준다. . . | 메서드 내부에서 코드 중간에서 가변 변수를 수정할 때, 위에 재할당 등의 수정이 되었었나 확인해야한다. final로 재할당(재사용)이 불가능한 불변 값사용하다가, 변수의 재사용이 필요할 경우 새 변수를 만들어서 쓰자. | . | 모든 지역변수, 인자에 final을 붙이자. . . | . final 객체의 내부 속성변화 메서드 -&gt; 변한 속성으로 만든 새 객체로 응답 . 객체의 경우는 final로는 완벽한 불변을 못만든다. . final 값와 달리 final 객체는 메소드 등에 의해 내부가 변할 수 있다.(포인터의 포인터에서 껍데기 포인터1) | . | 객체를 불변으로 만든 법상태변화를 일으키는 기능들은 새로운 객체를 반환하도록 정의하자. . 상태변화 시켰던 메서드의 void returnType에 해당 객체를 응답(return)하도록 수정 . public void move() { this.position++; } public Car move() { this.position++; } . | 변화된 상태로 new생성자()로 호출하여 -&gt; 새로운 객체를 반환시킨다. . public Car move() { return new Car(this.position + 1); } public Car(final int position) { this.position = position; } . | | . 객체, 컬렉션(껍데기포인터1)등은 응답시 copy해서 응답하라 . my) 포인터1의 포인터2에 의해 변경될 수 있으니, 껍데기 포인터1 자체를 copy해서 응답해라 . 컨밴션 중 하나가 된다. . final을 붙이는 것은 컨벤션이며 팀 안에서는 따르는게 좋을 수 도 있다. 내 생각에 타당하지 않으면 얘기를 꺼내서 바꿀 수 있다. | . | 컨벤션이라면, 비효율적이라도 그대로 가는 경우가 많다. 디자인 패턴 역시, 효율적이거나 좋은 코드라서 뿐만 아니라, 커뮤니케이션을 줄이는 컨밴션이기 때문에 좋기도 하다. | . | . 참고 글 . 후디 블로그 | . 객체를 객체스럽게 사용해라 . 아래와 같이 getter와 setter만 있는 객체를 구현하지 않는다. | setPosition()같은 setter 대신 move()의 역할로 분리해야한다. | getter()는 안쓰는게 좋은데, setter()는 100% 확정적으로 안쓰는게 좋다. setter() == 생성자 == pushed 로 외부에서 주입은 X | 특히 불변객체의 경우는 속성 변화 -&gt; 새 객체로 응답해야하니, setter란 개념이 없다. | . | view에서 사용하는 getter()는 필수적이다. view에서 getter()안쓰기 위해 toString() 쓰는 것은… 좀 아니다. | getter()쓰지마라라는 말은 도메인에서 getter() 쓰는 대신, 객체에 메세지를 던지면서 협력하라는 뜻이다. | 객체를 직접 사용하지말고, View에서는 dto로 값만 꺼내써라 | . | Q. view에서 cars.get(0).getPosition()은 가능한가요? . my) 디미터법칙 위반이다 -&gt; 책임을 2번째 놈에게 위임해야됌 . | index 0 은 무엇을 말하는지 모른다. . | 가져오려는 이유가 무엇인지 부터 물어보고 싶다. . 우승자를 구하려는 이유라면 메세지를 던지는 식으로 바꿔보자. cars.getWinners() | . | . | .get + .get이 이어지는 경우가 있는데 의심을 해봐야한다. . 점 1개로 줄이도록 해보자. . cars.getFirst().getPosition(); cars.getFirstPosition(); . | 첫번째 포지션 -&gt; 의미가 애매하다 -&gt; 위너로 바꾸자. . cars.getWinners(); . | . | . | . 객체.getXXX()대신 new XXX( 객체 )를 던지는 클래스로 만드는 방법도 . **getter()대신 객체를 생성자로 던져 class를 만들어볼까? ** . new Winner(cars); . | . 객체를 던졌어도, 객체.setter() 등의 주입 대신 역할위임을 하자. . public class Racing { ... public int run(Car car) { int num = random.nextInt(11); int position = car.getPosition(); if (num &gt;= 4) { position++; } car.setPosition(position); return position; } } . car.setPosition(position);대신에 car 내부로 역할이 위임되어서 내부에서 했으면 좋겠다. | . 인변의 접근제한자는 private으로 고정 -&gt; 객체상태에 대한 접근은 제한 . getter()도 지금 허용할까말깐데.. 인변에 접근은 절대 안시킨다. | . . 그렇다면 public, protected는 왜 있는 걸까? 과거에는 의도가 있어서 만들었는데, 요즘에는 필요없다고 느껴졌을 수 가 있음. | 과거에는 왜 여러 접근제한자를 만들었을까? | public으로 열여있으면, getter/setter 동시허용이나 마찬가지다. 어디서든 접근하면 -&gt; 불안해야 한다. | 이 역할만 하면 좋겠다. | 변수를 public으로 열어두면, 변했는지 안했는지 직접 보고 확인해야하는 비용이 든다. | 변수를 public으로 열어두지말고, method를 열어주어 캡슐화된 속성변화를 만들어내자. | . | . | . (내부)랜덤요소는 단위 테스트하기 힘들다. . 내부에 random은 테스트하기 힘들다. . . | . 밖에서 받아오는 메서드로 변경한다. . 테스트하기 힘든 내부 랜덤은 일단 밖에서 주어지는 파라미터로 변경 한다. . 파라미터 추출 단축키 ctrl+shit+P | . public void move() { if (getRandomNo() &gt;= 4) { this.position++; } } car.move(); . public void move(final int number) { if (number &gt;= 4) { this.position++; } } car.move(car.getRandomNo()); // 자동으로 메서드의 인자도 바뀐다. . | 문제점: 밖에서 받아오는 랜덤이 . 단일객체.move( 밖 ) | 일급컬렉션.move( 밖 ) cars.forEach( car -&gt; car.move( 밖 ) ) -&gt; .. | . | 일급컬렉을 사용하는 클래스에서도 ( 밖 ) | 어디 밖까지 빼서 받아올지가 끝이 없다 -&gt; 적절한 경계를 잡아준다. | . | 질문: . car.move ( 밖 )도 테스트 했는데, cars.move ( 밖 ) 도 테스트해야할까? 마음의 평화가 중요함. 자기가 생각해 봐야함. | . | 리뷰어에게는 설계가 담근 readme의 링크와 같이 보낸다. | . | 받아오는 인자를 전략메소드를 가진 인터페이스로 변경하여 -&gt; 랜덤외에 구상 전략객체들도 입력가능하게 만든다. . public interface MovableStrategy { boolean isMove(); } . 인변 수는 최소화한다. . 최대 2개 정도로… . | 기존 인변으로 만들어낼 수 있는 것은, 변수로 선언하지 않는다. . public class RacingGame { private List&lt;Car&gt; cars; private List&lt;String&gt; winners; . | my) 인변으로 둔다 -&gt; 바깥에서(or default값으로) 받아와 알고있고, 의존해야하는 것 . 그게 아니라면, 시간이 좀 걸리더라도, 기존 인변들도 만든다. | 관리포인트를 늘리면 좋은가? 그냥 그때그때 실시간으로 만드는게 좋은 것 같다. | 현대에는 메모리/컴퓨팅 비용성능 «&lt; 인력의 유지보수성 | DB를 이용하는 시점에서 변수 -&gt; 성능을 위한 캐싱을 하기도 한다. | . | . ### setter는 사용을 자제해라 -&gt; 생성자에서 초기화 후 더이상 변경안한다. . 인스턴스 변수는 생성자 초기화 후에 불변을 유지하기 위해 setter는 사용을 자제한다. | setter의 문제점은? 역할을 하지 못하게 된다. | 어디서든 변경되어 -&gt; 내 의도와 다르게 동작한다. | 유지보수성이 떨어진다. | . | . 비즈니스 로직과 UI 로직의 분리 . View관련 코드는 도메인에 넣지말라는 소리 . 90%는 도메인에 View관련 코드를 넣었었다. . public class Car { private int position; ... private void print(int position) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; position; i++) { sb.append(&quot;-&quot;); } System.out.println(sb.toString()); } } . | . | 리뷰를 받으면서 점점 분리한다. . | 왜 분리할까? 그냥 출력하도록 도메인에서 메서드 만들면 되는거 아닌가? . getter쓰지말라고 해서 -&gt; 객체.역할부여()로 출력역할 만들었더니 | 역할부여는 도메인 &amp;&amp; getter없이 하는게 맞지만, 변경이 자주 일어나는 view로직을 예외다. | . | View관련 로직 . 출력관련 역할부여(책임)를 도메인에서 안시킨다. 아예 정의하지말고 도메인은 객체만 넘겨라. . 출력 책임은 객체가 가지게 하지마라 | &lt;변경 빈번&gt; UI변경 -&gt; &lt;변경없어야할 소중한, 중요도가 높은&gt; 도메인에 여파를 일으키면 큰일이 나기 때문 | . | dto로 getter로 값만 꺼내쓰게 할 것이다 . | . | . Collection 활용 로직 처리 . Car 목록에서 최종 우승자를 구하는 로직이다. 이 코드를 Collection 기능을 사용해 어떻게 리팩터링할 것인가? . public class ResultView { private Cars cars = null; private String getTopRankedCar(List&lt;Car&gt; carList) { String topCarString = &quot;&quot;; cars = new Cars(carList); int maxPosition = getMaxPosition(carList); for (int i = 0; i &lt; carList.size(); i++) { if (cars.getPosition(i) == maxPosition) { topCarString += cars.getCarName(i) + &quot;, &quot;; } } return topCarString.substring(0, topCarString.length() - 2); } private int getMaxPosition(List&lt;Car&gt; carList) { int maxPosition = 0; cars = new Cars(carList); for (int i = 0; i &lt; carList.size(); i++) { if (maxPosition &lt; cars.getPosition(i)) { maxPosition = cars.getPosition(i); } } return maxPosition; } } . | . 기본 api를 이용해서 다짜지 말자 . Collection을 활용해 로직을 구현할 때 직접 구현하려 하지 말고 먼저 Collection API를 통해 해결할 수 있는 방법이 있는지 찾는다. 방법을 찾았는데 해결 방법을 찾지 못하는 경우만 직접 구현한다. . . 경계값을 테스트한다. . 다 하는게 아니라 경계값만 테스트 . 모든 테스트 X | . @Test public void 랜덤숫자가_4이상일때만_움직인다() { Car car = new Car(); assertFalse(car.shouldMove(0)); assertFalse(car.shouldMove(1)); assertFalse(car.shouldMove(2)); assertFalse(car.shouldMove(3)); assertTrue(car.shouldMove(4)); assertTrue(car.shouldMove(5)); assertTrue(car.shouldMove(6)); assertTrue(car.shouldMove(7)); assertTrue(car.shouldMove(8)); assertTrue(car.shouldMove(9)); } . | . 테스트 픽스처 생성 . 테스트를 반복적으로 수행할 수 있게 도와주고 매번 동일한 결과를 얻을 수 있게 도와주는 ‘기반이 되는 상태나 환경’을 의미한다. 여러 테스트에서 공용으로 사용할 수 있는 테스트 픽스처는 테스트의 인스턴스 변수 혹은 별도의 클래스에 모아 본다. . 중복제거를 위해 하면 된다. | junit의 @beforEach를 사용하면 된다. 테스트 픽스쳐의 일종이다. | . public class RacingGameTest { private final String[] testNames = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}; private final int testPosition = 5; private final String resultSamePositionString = &quot;, b&quot;; private final String resultWinnersString = &quot;a, b&quot;; RacingGame racingGame; private final Car firstWinner = new Car(testPosition, &quot;a&quot;); private Car secondWinner; private final List&lt;Car&gt; cars = new ArrayList&lt;Car&gt;(); ... } . | . 과정 실습 . 추후 미션이 진행 되면, 복잡해지고 객체가 많아질 경우, 코드를 분리해야됨. . @Test void move() { final Car car = new Car(&quot;재성&quot;); } . | 비슷한 환경의 테스트를 복사해서 case를 나눈다고 가정하자. . @Test void move_go() { final Car car = new Car(&quot;재성&quot;); } @Test void move_stop() { final Car car = new Car(&quot;재성&quot;); } . | 객체의 생성이 반복된다면, Generate &gt; Setup method를 선택해서 @BeforeEach를 생성하자. . @BeforeEach void setUp() { } @Test void move_go() { final Car car = new Car(&quot;재성&quot;); } @Test void move_stop() { final Car car = new Car(&quot;재성&quot;); } . | 공통되는 객체생성코드를 beforeEach로 뺀다 . @BeforeEach void setUp() { final Car car = new Car(&quot;재성&quot;); } @Test void move_go() { } @Test void move_stop() { } . | ctrl+.(show context action)을 눌러서 split declation and assignment를 통해 . 변수 선언은 변수재활용을 위해 클래스변수로 클래스변수에 넣고 매번 초기화한다 -&gt; 변수 재활용한다 -&gt; 변수 재할당한다 -&gt; final은 안된다. | . | 할당만 beforeEach에서 매 테스트마다 새로운 것으로 분리한다. | . @BeforeEach void setUp() { final Car car; car = new Car(&quot;재성&quot;); } . class ApplicationTest { //final Car car; // 매 테스트마다의 재활용 = 재할당 Car car; @BeforeEach void setUp() { car = new Car(&quot;재성&quot;); } . | 픽스쳐가 많아지면, 공통이 맞는지 확인한다. . | . 특정상태를 만들어주기 위한 반복코드 -&gt; 생성자로 상태 바로 만들기 . 과도하게 반복해서 만든다? . public class RacingGameResultTest { @Test public void check_ranking_if_correct() { List&lt;Car&gt; cars = new ArrayList&lt;&gt;(); Car car1 = new Car(&quot;pobi&quot;); Car car2 = new Car(&quot;crong&quot;); Car car3 = new Car(&quot;honux&quot;); car1.move(); car1.move(); car2.move(); car2.move(); car2.move(); car3.move(); cars.add(car1); cars.add(car2); cars.add(car3); ... } } . 단순반복의 경우, 반복문+메서드 호출로 해결할 수도 있지만, 그렇지 않은 경우가 많다. | 상태를 만들기 위해 복잡한 과정이 많은 경우, 상태를 바로 만들어주는 생성자를 만들 수 있다. 여기선, move()테스트가 아니라 우승자를 찾는게 목적이기 때문에, 목적 달성을 위해, 다른 것은 바로 상태를 만드는 생성자를 만들수 도 있음. | 현재는 move()호출방식에 따라 테스트가 의존하여, 변하면 테스트코드가 깨질 수 도 있다. | 테스트를 위해 생성자를 만들지만, 그게 진짜 테스트만을 위한 코드인지 생각해봐야한다. | . | . public Car(final String name, final int position) { this.name = name; this.position = position; } List&lt;Car&gt; cars = new ArrayList&lt;&gt;(); // Car car1 = new Car(&quot;pobi&quot;); // Car car2 = new Car(&quot;crong&quot;); // Car car3 = new Car(&quot;honux&quot;); Car car1 = new Car(&quot;pobi&quot;, 2); Car car2 = new Car(&quot;crong&quot;, 3); Car car3 = new Car(&quot;honux&quot;, 1); // car1.move(); // car1.move(); // car2.move(); // car2.move(); // car2.move(); // car3.move(); cars.add(car1); cars.add(car2); cars.add(car3); . 이 코드가 프로덕션 코드에서 사용되지 않더라도, 객체관점+객체역할에서 봤을 때, 테스트를 위한 기능이 아닐 수 있다. 객체 관점에서 자연스러우면 괜찮다. | position default값을 지정해주는 관점에서 괜찮다. | . | 테스트만을 위한 메서드추가는 문제가 더 큰데, 생성자는 객체를 만드는 방법일 뿐이므로 생성자는 많아도 괜찮다. 충분히 납득이 가능하다. | . | . | 생성자는 여러개 만들면, 인자 많은 것을 주생성자로 취급하고 인자 적은 생성자 -&gt; 위쪽에 위치하고 default값을 this에 넣어주는 부생성자 . // 부 생성자는 주 생성자(name, position)보다 더 앞에 위치하며, 뒤쪽의 주 생성자를 this( , )로 사용한다. public Car(final String name) { this(name, 0); } public Car(final String name, final int position) { this.name = name; this.position = position; } . | 생성자가 너무 많아지거나, 같은 시그니쳐 or 이름을 주고 싶을 때 -&gt; 정팩메로 분리 고려 . | . getter없이 구현 가능? . setter/getter 메서드를 사용하지 말라는 것은 핵심 비지니스 로직을 구현하는 도메인 객체를 의미한다. 도메인 Layer -&gt; View Layer, View Layer -&gt; 도메인 Layer로 데이터를 전달할 때 사용하는 DTO(data transfer object)의 경우 setter/getter를 허용한다. . | 아예 없이 toString으로 구현하는 분들도 있지만, 도메인 Layer에서 사용하는 getter를 만들지마라 == 비즈니스 로직를 위한 getter를 이용하지마라 . 도메인 대신 DTO 구현시 getter/setter는 허용한다. . | DTO라도 setter는 생성자에서 초기화하는 것으로 대신한다. | view에서는 열어야한다. | . | 접근제한자는 최소한으로 열고 시작한다. . | getter로 받아와서 하지말고, 역할을 부여해서 시키는 것 -&gt; 그래야 협력한다. . | . 객체안에서 toDTO를 만들지마라 . 내부에서 toDto()를 만든다? 모델에서 DTO를 알면 왜 안좋을까? | DTO는 뷰에 종속적인 객체 -&gt; view처럼 변경이 많다 -&gt; 도메인에 영향을 줌 | 객체 안에서 DTO를 생성하지마라 | 객체는 밥줄이라 아껴야하고, DTO는 막쓴다. | . | . 테스트를 위한 코드는 구현코드에 분리 . 테스트용 편의 메서드를 구현 코드에서 구현하지마라 | . 생성자로 주입하는 건 괜찮고, setter는 안좋냐? . 똑같은 내부 코드(행위)보다는 역할이나 시점을 봐야한다. | setter가 하나라도 존재하면 내부 상태변화 기능.move()을 따로 가지는 객체지만, 객체를 믿을 수 없게 된다. 기능으로 내부 변하는 것도 좀 그런데… 언제든지 변화시키는 믿을 수 없는 객체가 된다. | . | .",
            "url": "blog.chojaeseong.com/java/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/23/%EA%B0%95%EC%9D%98_%EB%A0%88%EB%B2%A81_1%EB%8B%A8%EA%B3%84_%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_%EB%84%A4%EC%98%A4_%EA%B0%95%EC%9D%98(%EC%99%84).html",
            "relUrl": "/java/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/23/%EA%B0%95%EC%9D%98_%EB%A0%88%EB%B2%A81_1%EB%8B%A8%EA%B3%84_%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_%EB%84%A4%EC%98%A4_%EA%B0%95%EC%9D%98(%EC%99%84).html",
            "date": " • Feb 23, 2022"
        }
        
    
  
    
        ,"post20": {
            "title": "Console 입력-검증-생성자 정리",
            "content": "콘솔 프로그램 입력/검증/생성자 . 자동차경주 1,2차 피드백(1단계 미션)후 콘솔입력 -&gt; 검증 -&gt; 개별 모델 생성자 구조를 생각해보았다. . | 아직 Dto - domain 의존은 해결되지 않은 상황 . 나중에 참고할 것: DTO를 의존 하는 domain 문제 PR | . | . InputView . 재활용 SCANNER . 스캐너를 사용하는 public static getInput() . private static final Scanner SCANNER = new Scanner(System.in); public static String getInput() { return SCANNER.nextLine(); } . | 4단계 InputView.getXXX() . 개별 모델input들을 의미하는 getXXX()는 4단계로 구성됨. . public static List&lt;String&gt; getCarNames() { OutputView.printRequestInstruction(REQUEST_CARS_NAME); List&lt;String&gt; carsName = Arrays.stream(getInput().split(SPLIT_DELIMITER, -1)) .map(String::trim) .collect(Collectors.toList()); Validator.validateCarNames(carsName); return carsName; } public static String getRound() { OutputView.printRequestInstruction(REQUEST_ROUND_VALUE); String inputRound = InputView.getInput(); Validator.validateInputNumber(inputRound); return inputRound; } . OuputView.print( 안내메세지 ) . | 스캐너를 사용해서 받은, 복수형이면 split(,-1) by Arrays.stream( ).map().collect() / 단수형이면 그냥 . List&lt;String&gt; or String | . | 복수형이면 실제이름XXXX를 붙이고 / 단수형이면 Input(String) or InputNumber(StringNumber)를 붙인 . Input루트의 공통검증: Validator.validate~ -&gt; 재료는 List&lt;String&gt; 아니면 String(Number)로 무조건 String타입을 검증대상으로 보게 정했다. . 복수형이면 check복수형(개별Empty, 중복) -&gt; for validateInput or validateInputNumber의 단수 공통검증 . private Validator() { // 유틸클래스는 따로 객체생성안한다는 private생성자로 표시 } public static void validateCarNames(List&lt;String&gt; carNames) { checkCarNamesEmpty(carNames); checkDuplicated(carNames); for (String carName : carNames) { validateInput(carName); } } . | 단수형이면 String이냐 StringNumber냐에 따라서 다르게 . String: NullOrEmpty + IncludeBlank | StringNumber: NullOrEmpty + Format(넣으면 IncludeBlank안넣어도 된다) | private static void validateInput(String carName) { checkNullOrEmpty(carName); checkIncludeBlank(carName); } public static void validateInputNumber(String inputRound) { checkNullOrEmpty(inputRound); checkValidFormat(inputRound); } . | | | return List&lt;String&gt; or String(2번) . | | Controller . try/catch . 입력받을 때, 입력 예외발생시 다시 입력받기 받으려면 **getXXXX()가 ** . 검증을 포함하는 부분시켜서 | 재귀호출하는 하도록 메서드화되어 있고 그부분을 try/catch로 쌓여있여있어야하는데, | . | getXXX() + 받아서 모델의 (정펙매)생성자 호출하는 과정까지 try/catch로 감싸면, 도메인 자체검증도 try/catch의 재귀에 걸려 도메인 자체검증 예외발생시에도 재입력받을 수 있게 된다. . 객체 생성로직( 자체 검증 -&gt; 객체 생성)까지 포함시켰으니, 해당 메서드는 try성공시 객체를 returnType으로 | . private Cars getCars() { try { return Cars.fromInput(InputView.getCarNames()); } catch (IllegalArgumentException e) { OutputView.printErrorMessage(e); return getCars(); } } private Round getRound() { try { return Round.fromInput(Integer.parseInt(InputView.getRound())); } catch (IllegalArgumentException e) { OutputView.printErrorMessage(e); return getRound(); } } . RacingGame racingGame = RacingGame.createRacingGame( getCars(), getRound(), new RandomNumberGeneratePolicy() ); . | . Controller getXXX(): InputView.getXXX() 응답 String -&gt; convert+생성자객체생성+try/catch . 대신, 중간에 필요한 객체의 생성자까진 노출할 필요는 없다. . public class RacingGameController { public void startRacing() { RacingGame racingGame = RacingGame.createRacingGame( getCars(), // InputView의 getXXX()는 무조건 String -&gt; 중간 객체(Name)도 다 노출... private Cars getCars() { try { return Cars.fromNames(Names.fromInput(InputView.getCarNames())); . 지금은 Cars를 만들기 위해 Names의 존재를 알아야 하는 상황인데요, 사실 Names는 Cars 안에서만 사용되고 있죠. 그렇다면 Names의 존재가 바깥에 노출될 필요가 있을까요? 구현을 드러내고 있는 건 아닐까요? 원시값 포장한 것은 굳이 생성자를 안드러내도 된다. | . | . private Cars getCars() { try { return Cars.fromInput(InputView.getCarNames()); public static Cars fromInput(List&lt;String&gt; InputNames) { Names names = Names.fromInput(InputNames); return new Cars(names.getNames( . | . 생성자 . 01 private 기본생성자 . 복수( List&lt;단일&gt;) ex&gt; Cars . private Cars(List&lt;Car&gt; cars) { this.cars = cars; } . 단일객체 (포장객체들, Name+Position ) ex&gt; Car . private Car(Name name) { this.name = name; this.position = Position.from(DEFAULT_POSITION_VALUE); } . 일급컬렉션 (List&lt;원시&gt;) ex&gt; Names . private Names(List&lt;Name&gt; names) { this.names = names; } . StringNumber (int ) ex&gt; Round . private Round(int roundNum) { this.roundNum = roundNum; } . String (String ) ex&gt; Name . private Name(String name) { this.name = name; } . 복수Dto (List&lt;CarDto&gt;) ex&gt; CarsDto . private CarsDto(final List&lt;CarDto&gt; carsDto) { this.carsDto = carsDto; } . 단일Dto (원시값들) ex&gt; CarDto . public CarDto(String name, int position) { this.name = name; this.position = position; } . 02 .fromInput ( only String or List&lt;String&gt; ) . inputView에서 기본검증을 거치고 난 뒤, 자체 검증만 필요한 친구들 만약, stream.map 단일객체생성자 등장시 -&gt; 단일객체로 검증이 옮겨짐 | . | . 복수( List&lt;단일&gt;) ex&gt; Cars . public static Cars fromInput(List&lt;String&gt; InputNames) { Names names = Names.fromInput(InputNames); return new Cars(names.getNames().stream() .map(Car::fromName) .collect(Collectors.toList())); } . 단일객체 (포장객체들, Name+Position ) ex&gt; Car . // . 일급컬렉션 (List&lt;원시&gt;) ex&gt; Names . 자체검증하는 대신, stream상에서 단일객체에서 검증이 옮겨짐. | . public static Names fromInput(List&lt;String&gt; names) { return new Names(names.stream() .map(Name::from) .collect(Collectors.toList())); } . StringNumber (int ) ex&gt; Round . public static Round fromInput(int inputRound) { validateRound(inputRound); return new Round(inputRound); } . String (String ) ex&gt; Name . // . 복수Dto (List&lt;CarDto&gt;) ex&gt; CarsDto . // . 단일Dto (원시값들) ex&gt; CarDto . // . 03 .from( 원본재료 ) . 복수 . input없이 프로덕션내부 or 테스트에서 사용된다. -&gt; 유틸화된 공통검증 + 자체 검증 만일, 원본재료가 포장된 객체라면, 자체검증은 포장객에게 갈 수 있다. | . | . public static Cars from(List&lt;Car&gt; cars) { return new Cars(cars); } . VO 는 .from(원본 1개만) . 정팩메 1개 -&gt; input이지만 .from + 유일 자체 검증 생성자 | . public static Position from(int position) { validatePosition(position); return new Position(position); } . 복수( List&lt;단일&gt;) ex&gt; Cars . test코드에서 Car -&gt; Cars로 바로 생성하기 위해 | . public static Cars from(List&lt;Car&gt; cars) { return new Cars(cars); } . 단일객체 (포장객체들, Name+Position ) ex&gt; Car . 일급컬렉션, 복수 쪽에서는 stream을 통해 원본 List -&gt; 단일객체 List -&gt; 일급으로순으로 가기도 한다. | . public static Car fromName(Name name) { return new Car(name); } . 일급컬렉션 (List&lt;원시&gt;) ex&gt; Names . test코드용 | . public static Names from(List&lt;Name&gt; names) { validateNames(names); return new Names(names); } . StringNumber (int ) ex&gt; Round . test를 안하고, controller에서 마지막에 convert시킬거라을 input원본 받을일이 없음. | . // . String (String ) ex&gt; Name . 복수, 일급컬렉션의 Names에서 stream으로 만들어지는 과정 | 테스트용 | . public static Name from(String name) { checkValidLengthOfName(name); return new Name(name); } . 복수Dto (List&lt;CarDto&gt;) ex&gt; CarsDto . 일급컬렉션 내부에서 toDto()호출시 ** List&lt;단일&gt; **유일 필드-&gt; List&lt;단일Dto&gt; 변환후 기본생성자로 복수Dto로 만들어줌 -&gt; from일급컬렉 | 공통적인 기본 private List&lt;단일Dto&gt;를 호출해줄 public -&gt; .from | public static CarsDto fromCars(final List&lt;Car&gt; cars) { //todo: 5. cars -&gt; carsdto의 정펙메( List&lt;Car&gt; ) -&gt; List&lt;CarDto&gt; -&gt; 일급 생성자 // carsDto의 생성자는 car list(cars)를 받아서 -&gt; cardto list -&gt; 일급 dto를 만드는 곳 final List&lt;CarDto&gt; carDtos = cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList()); return new CarsDto(carDtos); } public static CarsDto from(final List&lt;CarDto&gt; carsDto) { return new CarsDto(carsDto); } . 단일Dto (원시값들) ex&gt; CarDto . 복수or일급컬렉션에서 stream에서 Car -&gt; CarDto시 사용될 .from원본( 1:1원본) | OuputView 테스트에서 원시값 필드들로 생성하는단일Dto -&gt; 복수Dto | public CarDto(String name, int position) { this.name = name; this.position = position; } .",
            "url": "blog.chojaeseong.com/java/console/input/validation/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/22/%EC%BD%98%EC%86%94%EC%9E%85%EB%A0%A5_%EA%B2%80%EC%A6%9D_%EC%83%9D%EC%84%B1%EC%9E%90(%EC%99%84).html",
            "relUrl": "/java/console/input/validation/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/22/%EC%BD%98%EC%86%94%EC%9E%85%EB%A0%A5_%EA%B2%80%EC%A6%9D_%EC%83%9D%EC%84%B1%EC%9E%90(%EC%99%84).html",
            "date": " • Feb 22, 2022"
        }
        
    
  
    
        ,"post21": {
            "title": "DTO 단계별 적용(자동차경주)",
            "content": "단일DTO . 참고 DTO 쓴 PR | . 01 Controller의 OutputView.print( )에 List&lt;단일Dto&gt; 반환해주기 . OutputView.printResultEveryRound(racingGame.getCurrentCars()); . 관리자객체에서도 List&lt; 단일객체 &gt;나오는 일급에 들어가지 않았으므로 그대로 여기서 return될 타입이 List&lt; 단일Dto &gt;를 예상하자 | . public List&lt;CarDto&gt; getCurrentCars() { return this.cars.getCurrentCars(); } . 02 일급 속 List&lt;단일객체&gt;를 stream.map으로 List&lt;단일Dto&gt;로 변환 . public List&lt;CarDto&gt; getCurrentCars() { return this.cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList()); } . 03 Dto 변환 정펙메는 from(단일객체) -&gt; 모든 속성들 원시값까지 나눠서 get . 이 때, Car는 VO Name, Position이라도, Dto의 속성 및 getter()는 순수 원시값만 가지고 뱉어낸다. 예를 들어, car.getName()은 Name(VO) return이 아니라 this.name.getName()의 원시값을 return해야 CarDto가 생성자에서 개별속성들을 원시값으로 받아먹을 수 있다. | . | . public class CarDto { private final String name; private final int position; public CarDto(String name, int positiion) { this.name = name; this.position = positiion; } public static CarDto from(Car car) { return new CarDto(car.getName(), car.getPosition()); } public String getName() { return this.name; } public int getPosition() { return this.position; } } . 04 OutputView는 List&lt;단일Dto&gt;를 받아서 getter들로 출력 로직 작성 . public static void printResultEveryRound(List&lt;CarDto&gt; currentCars) { for (CarDto currentCar : currentCars) { System.out.println(currentCar.getName() + &quot; : &quot; + collectDash(currentCar.getPosition())); } System.out.println(); } . 일급Dto . 01 일급.toDto()를 통한 List&lt;단일Dto&gt;자리를 일급Dto로 교체 . 단일Dto는 List -&gt; steram -&gt; map 가운데만 등장했으나 | 일급Dto는 this.일급.toDto()의 책임이 주어진다. | . public CarsDto getCurrentCars() { //return this.cars.getCurrentCars(); return this.cars.toDto(); . 02 일급Dto 정펙매 공식 재료는 일급 내부에 있는 List&lt;단일객체&gt; (No List&lt;단일Dto&gt;) . 단일Dto는 Car가 모르고, 내부에서 이용안한다. Cars내부에서 List&lt;CarDto&gt; 만들 때 map에서 사용된다. | 일급Dto는 Cars가 알고 이용하여, 내부에서 변환환다. | 일급내부의 단일객체 List만 건네주면, 내부에서 단일Dto -&gt; 일급Dto 한번에 변환후 생성 다해준다. List&lt;단일Car&gt; —정팩메List&lt;단일Dto&gt;—&gt; CarsDto | . | . // todo: 4. Cars의 toDto()함수는 &lt;&lt;Cars내부지만 CarsDto를 알고, 의존하여&gt;&gt; [CarsDto의 정팩메]를 호출 Cars -&gt; CarsDto로 변환한다. // my) Cars는 CarsDto와 그 정팩메를 알고 있다! public CarsDto toDto() { return CarsDto.fromCars(cars); // from List&lt;단일객체CarDto&gt; vs from다른것 Cars } . 일급Dto 정펙매의 재료가 List&lt;단일Dto&gt;가 아니라 List&lt;단일객체&gt;만 있으면, 내부에서 단일Dto List -&gt; 일급Dto까지 간다. | . public static CarsDto fromCars(final List&lt;Car&gt; cars) { // 필요재료가 List&lt;단일Dto&gt;가 아니라 List&lt;단일객체&gt;만 있으면, 내부에서 단일Dto List -&gt; 일급Dto까지 간다. final List&lt;CarDto&gt; carDtos = cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList()); return new CarsDto(carDtos); } . 03 일급Dto의 getter 네이밍은 get()으로 줄여주자. . 안줄이면. XXXsDto.getXXXsDto() -&gt; get으로 네이밍 줄여주기 | 단일Dto는 개별속성 getter()가 목적이라 Dto.get속성() | . public List&lt;CarDto&gt; get() { return carsDto; } . 04 OutputView내부 List&lt;단일Dto&gt; 사용 -&gt; 일급Dto.get() . //public static void printRacingRecord(List&lt;CarDto&gt; cars) { // for (CarDto car : cars) { public static void printRacingRecord(CarsDto carsDto) { for (CarDto car : carsDto.get()) { . DTO테스트 . 01 Dto를 사용하는 OutputView의 Test로 테스트한다. . ByteArrayOutputStream 변수 + setOut에 설정하기 차후 print명령을 내놓고 -&gt; output.toString()에서 확인하기 | . | . private final ByteArrayOutputStream output = new ByteArrayOutputStream(); @BeforeEach public void setUp_streams() { System.setOut(new PrintStream(output)); } . 02 [원시속성들]로 단일Dto 만드는 깡통 [정펙매of ] 정의 . 메서드로만 변환되는 deafult값의 position필드도 다 받도록 한다. (Dto는 깡통) | 1개 이상의 속성들을 받아야하므로 .of()의 정펙매로 개발한다. | . public static CarDto of(final String name, final int position) { return new CarDto(name, position); } . 03 프로덕션에 없던, 일급Dto의 정펙매from ( List&lt;단일Dto&gt;) 정의 . 프로덕션에서는 일급내부 List&lt;단일&gt; —일급Dto정펙매–&gt; (List&lt;단일Dto변환 -&gt;) 일급Dto 테스트에선 단일Dto 출발 -&gt; List&lt;단일Dto&gt;를 받아 일급Dto 생성해줄 정펙매 필요함. | . | . public static CarsDto from(final List&lt;CarDto&gt; carsDto) { return new CarsDto(carsDto); } . 04 output.toString()은 변수로 못받는다. 바로 확인 . //given final CarsDto carsDto = CarsDto.from(Arrays.asList(CarDto.of(&quot;재성&quot;, 1), CarDto.of(&quot;재경&quot;, 1))); //when: output.toString을 이후 actual변수에 따로 못받음. OutputView.printRacingRecord(carsDto); //then assertThat(output.toString()).contains(&quot;재성 : -&quot; + System.lineSeparator() + &quot;재경 : -&quot;); . final CarsDto carsDto = CarsDto.from(Arrays.asList(CarDto.of(&quot;재성&quot;, 1), CarDto.of(&quot;재2&quot;, 1))); // 우승자가 2명인 상황이라 가정해야됨. &gt; Winner들만 모인 CarsDto를 넘겨받는다. OutputView.printRacingResult(carsDto); assertThat(outputStream.toString()).contains(&quot;재성, 재2가 최종 우승했습니다&quot;); .",
            "url": "blog.chojaeseong.com/java/dto/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/22/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_DTO_%EB%8B%A8%EA%B3%84%EB%B3%84-%EC%A0%81%EC%9A%A9(%EC%99%84).html",
            "relUrl": "/java/dto/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/22/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_DTO_%EB%8B%A8%EA%B3%84%EB%B3%84-%EC%A0%81%EC%9A%A9(%EC%99%84).html",
            "date": " • Feb 22, 2022"
        }
        
    
  
    
        ,"post22": {
            "title": "동일성vs동등성(equals, hashCode)",
            "content": "동일(ㅣ)성 = (I)dentity = 메모ㄹ(ㅣ)주소 . 반대로 동등성 = equality = 정해준 값이 같은지 . | equals는 equality가 아닌메모리 주소(identity) 비교가 default라서 오버라이딩 해야한다. . == = 메모리 주소로 비교 = default equals . public boolean equals(Object obj) { return (this == obj); } . | = = 값으로 비교 = 오버라이딩 equals . | . | . 세팅 . public class Car { private final String name; private int position; // 부 생성자는 주 생성자(name, position)보다 더 앞에 위치하며, 뒤쪽의 주 생성자를 this( , )로 사용한다. public Car(final String name) { this(name, 0); } public Car(final String name, final int position) { this.name = name; this.position = position; } } . 오버라이딩 전 default equals -&gt; 메모리비교 . @Test void before_overriding_equals_test() { //1. 오버라이딩 전 deafult equals : 같은 메모리 주소만 true final Car 재성 = new Car(&quot;차&quot;); final Car 석영 = new Car(&quot;차&quot;); assertThat(재성).isEqualTo(석영); //Expected :domain.Car@29647f75 //Actual :domain.Car@355ce81c // -&gt; 서로 다른 객체(메모리주소)를 가져서 deafult equals로는 같다고 할 수 없음. } . 오버라이딩후 equals -&gt; 지정한 값으로 비교 . final Car 재성 = new Car(&quot;차&quot;); final Car 석영 = new Car(&quot;차&quot;); assertThat(재성).isEqualTo(석영); // true . hashCode도 같이 오버라이딩 하는 이유? . hashCode메서드는 실제 메모리 주소 -&gt; 정수값으로 반환해주는 함수이다. 자료구조 등에 사용될 때, 이 hashCode기준으로 같냐/틀리냐를 판단한다. | . | 값 같으면 -&gt; 같은 객체를 만족시켜주기 위해서는 같다의 기준을 바꿔줬었다. 같다의 기준을 메모리 주소 비교 -&gt; 값 비교로 equals 오버라이딩으로 바꿔줘야했지만, | . | 이번엔 자료구조 등이 받아서 읽을해쉬코드 기준을 객체의 메모리주소정수 반환이 아닌 -&gt; 객체(Car)가 가진 값(name)의 메모리 주소 정수 반환로 바꿔준다. cf) 값의 메모리주소 -&gt; 같은 문자열이면 다 같다 | . | . 자료구조들도 같은 객체로 인식 . 쉽게 말해서, 반환되는 hashCode도 값 기준으로 바꿔서, 값 같다 -&gt; 객체의 해쉬코드 같다를 만들어버린다. . 그렇지 않으면, equals는 True로 나올지 몰라도, 자료구조는 다른 객체로 인식하는 상태가 된다. | . @Test void before_overriding_hashcode_test() { final Car 재성 = new Car(&quot;차&quot;); final Car 석영 = new Car(&quot;차&quot;); final HashSet&lt;Car&gt; set = new HashSet&lt;&gt;(); set.add(재성); set.add(석영); assertThat(set.size()).isEqualTo(1); //Expected :1 //Actual :2 // hashCode를 객체기준-&gt;값기준으로 정의해주지 않으면, 자료구조들은 다른 객체로 인식한다. } . hashCode오버라이딩 후 | . @Test void after_overriding_hashcode_test() { //2. final Car 재성 = new Car(&quot;차&quot;); final Car 석영 = new Car(&quot;차&quot;); final HashSet&lt;Car&gt; set = new HashSet&lt;&gt;(); set.add(재성); set.add(석영); assertThat(set.size()).isEqualTo(1); // true } .",
            "url": "blog.chojaeseong.com/java/equals/hashcode/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/%EB%8F%99%EC%9D%BC%EC%84%B1%EA%B3%BC-%EB%8F%99%EB%93%B1%EC%84%B1(%EC%99%84).html",
            "relUrl": "/java/equals/hashcode/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/%EB%8F%99%EC%9D%BC%EC%84%B1%EA%B3%BC-%EB%8F%99%EB%93%B1%EC%84%B1(%EC%99%84).html",
            "date": " • Feb 21, 2022"
        }
        
    
  
    
        ,"post23": {
            "title": "java final 세팅과 사용법",
            "content": "final 키워드로 값의 변경을 막아라 . final 세팅 in IDE, 지역 변수, 메소드 파라미터 . 지역변수, 파라미터 모두 final로 생성되도록 하자 설정 &gt; Editor &gt; Code style &gt; java &gt; Code generation &gt; Make ~ final 체크박스 2개 | . | main 메소드 template 인 psvm의 인자에도 final을 붙혀준다. . 설정 &gt; live template or psvm 검색 &gt; final 붙여주기 | . . | . final 값 -&gt; 재할당을 막아 불변 . 메서드 내부에서 코드 중간에서 가변 변수를 수정할 때, 위에 재할당 등의 수정이 되었었나 확인해야한다. final로 재할당(재사용)이 불가능한 불변 값사용하다가, 변수의 재사용이 필요할 경우 새 변수를 만들어서 쓰자. | . | 모든 지역변수, 인자에 final을 붙이자. . . | final로 값을 초기화(선언후 할당)하는 방법은 2가지다 . //1. final변수 선언과 동시에 &amp;&amp; 할당 -&gt; final은 재할당 불가 -&gt; 변수재사용시 새객체 반환할 것 final int i = 2; i = 4; // java: cannot assign a value to final variable i //2. final변수 먼저 선언 -&gt; 이후 할당 // 생성자 등에서 값을 외부에서 받아와 추가 로직(convert or default 대입 등 특수 case(if) 존재)이후 초기화 final int number; number = 5; . | . final 객체 -&gt; 메서드로 내부 변화 가능 -&gt; 메서드를 항상 새 객체로 응답 . 객체의 경우는 final로는 완벽한 불변을 못만든다. . final 값와 달리 final 객체는 메소드 등에 의해 내부가 변할 수 있다.(포인터의 포인터에서 껍데기 포인터1) | . | 객체를 불변으로 만든 법상태변화를 일으키는 기능들은 새로운 객체를 반환하도록 정의하자. . 상태변화 시켰던 메서드의 void returnType에 해당 객체를 응답(return)하도록 수정 . // 내부변화되는 final 객체 public void move() { this.position++; } // 1. 일단 응답을 동일 객체로 만들어주기 public Car move() { this.position++; } . | 변화된 상태로 new생성자()로 호출하여 -&gt; 새로운 객체를 반환시킨다. . //2. 응답 객체를, 변화된 값으로 새로 만들어서 응답 -&gt; 내부 값은 변화 없다. public Car move() { return new Car(this.position + 1); } //3. 생성자를 통해 응답할 객체를 만들어준다. 내부 값의 변화는 없게 한다. public Car(final int position) { this.position = position; } . | | . final 메서드, 클래스 -&gt; 자식이 못 쓰게 . package domain; final public class FinalParent { final void finalMethod() { final String asdfasdf = &quot;asdfasdf&quot;; } } . package domain; //2. final 클래스는 자식이 상속이 안된다. // java: cannot inherit from final domain.FinalParent public class FinalChild extends FinalParent { //1. final 메소드는 자식이 오버라이딩 못된다. -&gt; 코어 부분에서 변경을 원치 않는 메소드를 명시할 때 사용 //java: cannot find symbol, symbol: class FinalParent @Override protected void finalize() throws Throwable { super.finalize(); } } . final 컬렉션(내부 변경api를 제공하는 껍데기포인터1) 등은 응답시 copy(unmodifiable) 해서 응답하라 . my) 포인터1의 포인터2에 의해 변경될 수 있으니, 껍데기 포인터1 자체를 copy해서 응답해라 | 컬렉션을 반환할 때, 메모리주소가 공유되니, 어디서든 같은 컬렉션이 변경되는 위험이 있다. copy해서 전혀 다른 메모리의 컬렉션으로 응답하자. | . | . List&lt;String&gt; names = List.of(); // unmodifiableList names.add(&quot;텍스트&quot;) // 예외발생 . - 내가 만든 일급컬렉션이라면 불변(내부 변화 기능 제공 않함)이 되겠지만, **일반 컬렉션이라면, 반환시 메모리주소가 공유된다. -&gt; `unmodifiableList`로 copy된 메모리를 반환시켜 테스트 등 변화가 발생하게 하자.** . 컨밴션 중 하나가 된다. . final을 붙이는 것은 컨벤션이며 팀 안에서는 따르는게 좋을 수 도 있다. 내 생각에 타당하지 않으면 얘기를 꺼내서 바꿀 수 있다. | . | 컨벤션이라면, 비효율적이라도 그대로 가는 경우가 많다. 디자인 패턴 역시, 효율적이거나 좋은 코드라서 뿐만 아니라 커뮤니케이션을 줄이는 컨밴션이기 때문에 좋기도 하다. | . | . 참고 글 . 후디 블로그 | .",
            "url": "blog.chojaeseong.com/java/final/%EB%8B%A8%EC%B6%95%ED%82%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/final_%EC%84%B8%ED%8C%85%EA%B3%BC_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/java/final/%EB%8B%A8%EC%B6%95%ED%82%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/final_%EC%84%B8%ED%8C%85%EA%B3%BC_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Feb 21, 2022"
        }
        
    
  
    
        ,"post24": {
            "title": "comparable vs comparator",
            "content": "참고 블로그1 | 참고 블로그2 | . 세팅 . public class Car { private final String name; private int position; public Car(final String name, final int position) { this.name = name; this.position = position; } public String getName() { return name; } public int getPosition() { return position; } } . 기준없이 정렬 . 기준없이 문자열 리스트 정렬 . 문자열은 값이므로 알아서 기준 없이 알아서 정렬된다. . @DisplayName(&quot;정렬기준 없이 문자열 리스트 정렬&quot;) @Test void noStandard_stringList_sort() { final List&lt;String&gt; strings = Arrays.asList(&quot;acd&quot;, &quot;abc&quot;, &quot;dca&quot;); // Collections.sort() 와 .reverse() Collections.sort(strings); System.out.println(strings); // [abc, acd, dca] Collections.reverse(strings); System.out.println(strings); // [dca, acd, abc] } . | String은 이미 내부에서 Comparable을 구현 -&gt; compareTo 오버라이딩 하여 정렬기준을 제시하고 있기 때문 . public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { //... public int compareTo(String anotherString) { byte v1[] = value; byte v2[] = anotherString.value; if (coder() == anotherString.coder()) { return isLatin1() ? StringLatin1.compareTo(v1, v2) : StringUTF16.compareTo(v1, v2); } return isLatin1() ? StringLatin1.compareToUTF16(v1, v2) : StringUTF16.compareToLatin1(v1, v2); } . | . 기준없이 객체 리스트 정렬 . 객체를 넣은 List는 아예 정렬 대상이 안되고 컴파일 에러가 난다. . | 반드시 먼저 정렬기준을 정해줘야한다. . @DisplayName(&quot;정렬기준 없이 객체 리스트 정렬&quot;) @Test void noStandard_carList_sort() { final List&lt;Car&gt; cars = Arrays.asList( new Car(&quot;재성&quot;, 1), new Car(&quot;재경&quot;, 2), new Car(&quot;아라&quot;, 3) ); //2. // no suitable method found for sort(java.util.List&lt;domain.Car&gt;) // method java.util.Collections.&lt;T&gt;sort(java.util.List&lt;T&gt;,java.util.Comparator&lt;? super T&gt;) is not applicable Collections.sort(cars); System.out.println(cars); Collections.reverse(cars); System.out.println(cars); } } . | . 객체에 정렬 기준 주기 . 01 sort()에 안넣어줘도 되는 수동 기준 Comparable . 수동적인 내부 기준인 만큼, 까봐야알고, 수정할려면 다 도메인 내부를 다 바꿔야한다. | . 자기자신 Type의 Comparable을 구현한다. . public class Car implements Comparable&lt;Car&gt; { . | 비교할 원시값Type에 맞게 compareTo를 재정의한다. . int면 Integer.compare( this.xxxx , other.xxxx ) | string이면, 내부 자기가 구현한 this.compareTo(other)를 사용 | . @Override public int compareTo(final Car otherCar) { return this.name.compareTo(otherCar.name); } . | .sort()만 해서 오름/내림차순 확인해보기 . @DisplayName(&quot;comparable -&gt; name 기준으로 객체 리스트 정렬&quot;) @Test void noStandard_carList_sort() { final List&lt;Car&gt; cars = Arrays.asList( new Car(&quot;재성&quot;, 1), new Car(&quot;재경&quot;, 2), new Car(&quot;아라&quot;, 3) ); //3. Collections.sort(cars); System.out.println(cars); // [아라 3, 재경 2, 재성 1] Collections.reverse(cars); System.out.println(cars); // [아라 3, 재경 2, 재성 1] } . | compareTo . 참고 블로그 | . 숫자형 비교 . 기준 값과 비교대상이 동일한 값일 경우 0 . | 기준 값이 비교대상 보다 작은 경우 -1 . | 기준 값이 비교대상 보다 큰 경우 1 . Integer x = 3; Integer y = 4; Double z = 1.0; System.out.println( x.compareTo(y) ); // -1 System.out.println( x.compareTo(3) ); // 0 System.out.println( x.compareTo(2) ); // 1 System.out.println( z.compareTo(2.7) ); // -1 . | . | 숫자형 중 Int의 비교 . compareTo() 대신 Integer.compare(, ) 사용 . int x = 4; int y = 5; Integer.compare(x,y); . | . | 문자열 -&gt; String클래스가 이미 오버라이딩 해놓은 compareTo()이용 . (첫글자 같으면서) 비교대상이 기준에 포함되면 -&gt; 길이의 차이를 return한다. . | (첫글자가 다르면서) 비교대상이 기준에 포함되면 -&gt; 서로 다른 문자열이 시작되는 위치(첫위치)에서 아스키코드 값 차이 . | 포함이 안되는 문자열끼리 비교는 그냥 첫글자의 아스키코드 차이 . String str = &quot;abcd&quot;; // 1) 비교대상에 문자열이 포함되어있을 경우 System.out.println( str.compareTo(&quot;abcd&quot;) ); // 0 (같은 경우는 숫자나 문자나 0을 리턴) System.out.println( str.compareTo(&quot;ab&quot;) ); // 2 System.out.println( str.compareTo(&quot;a&quot;) ); // 3 System.out.println( str.compareTo(&quot;c&quot;) ); // -2 System.out.println( &quot;&quot;.compareTo(str) ); // -4 // 2) 비교대상과 전혀 다른 문자열인 경우 System.out.println( str.compareTo(&quot;zefd&quot;) ); // -25 System.out.println( str.compareTo(&quot;zEFd&quot;) ); // -25 System.out.println( str.compareTo(&quot;ABCD&quot;) ); // 32 . | . | in stream: .집계( ::compareTo) 기준으로 바로 사용 가능 . .집계( 기준이 되어줄 메서드 )로 집계기준으로 바로 사용할 수 있다. | . list.stream() .max(Car::compareTo) .collect(Collectors ... ); . 단점: 정렬기준 변화시 모두 수정 + 까봐야 앎 + 네이밍 . 다른 개발자들이 implements Comparable&lt;Car&gt; 만 보고도어떤 기준으로 정렬될지 모른다. -&gt; 지식으로서 compareTo를 다 까봐야한다. | 그리고 이 기준이 바뀌지 않을 거라 장담할 수 없다. 구현부 compareTo를 하나하나 수정해줘야한다. | 네이밍 수정을 못함. compareTo보다 더 직관적인 네이밍 필요 | . 02 .sort( , ) 2번째 인자에 넣어주는 능동적 기준 Comparator . list.sort()의 첫번째 인자 혹은 Arrays.sort(, )나 Collections.sort(, )의 두번째 파라미터로 comparator를 받는 메소드가 오버로딩 되어있다. 따라서 수동적 기준인 natural ordering 으로 정렬하기 원할 경우, compareTo만 정의해서 기준으로 넣어주면 되고 | 정렬 기준을 동적으로 할당하고 싶을 경우, .sort( , )1~2번째 파라미터로 Comparator를 정의해서 전달하자. | . | . comparator 직접 구현 for 네이밍 . new Comparator롤 작성한 뒤-&gt; &lt;Car&gt;의 클래스만 입력해주고 -&gt; implements메소드 -&gt; compare만 선택한다. . new Comparator&lt;Car&gt;() . | **getter()도.. 들어가서.. 불러와서.. 비교시킨다. ** . 문자열이면, compareTo() String클래스꺼 | 인트면, Integer.compare() | . java new Comparator() { @Override public int compare(final Car o1, final Car o2) { return o1.getName().compareTo(o2.getName()); } }; . | 변수로 받아서 정렬기준 객체의 네이밍을 완성한다. . final Comparator&lt;Car&gt; carNameComparator = new Comparator&lt;&gt;() { @Override public int compare(final Car o1, final Car o2) { return o1.getName().compareTo(o2.getName()); } }; final Comparator&lt;Car&gt; carPositionComparator = new Comparator&lt;&gt;() { @Override public int compare(final Car o1, final Car o2) { return Integer.compare(o1.getPosition(), o2.getPosition()); } }; . | .sort( , )의 2번째 인자에 능동적으로 기준을 넣어준다. . Collections.sort(cars, carNameComparator); System.out.println(cars); // [아라 3, 재경 2, 재성 1] Collections.sort(cars, carPositionComparator); System.out.println(cars); // [재성 1, 재경 2, 아라 3] . | Comparator.api + getter() for 가장편함. . 따로 impl하거나 new 구현할 필요 없이, sort()의 2번째 인자에 바로 넣어준다. | Comparator.comparing() .reversed()를 붙혀 역순 지정가능 | . Collections.sort(cars, Comparator.comparing(Car::getName)); System.out.println(cars); // [아라 3, 재경 2, 재성 1] Collections.sort(cars, Comparator.comparing(Car::getName) .reversed()); System.out.println(cars); // [재성 1, 재경 2, 아라 3] Collections.sort(cars, Comparator.comparing(Car::getPosition)); System.out.println(cars); // [재성 1, 재경 2, 아라 3] Collections.sort(cars, Comparator.comparing(Car::getPosition) .reversed()); System.out.println(cars); // [아라 3, 재경 2, 재성 1] . Comparator.api + getter() in stream . max ( Comparator.comparingInt ( 클래스::getter )) . 정리 . Comparable 보다는 Comparator를 사용하여 정렬 기준만큼은 도메인에서 제외시켜 외부에 위치시켜 변경에 유연하게 만든다. | 외부에서는 comparable -&gt; compareTo -&gt; .sort() 수동적 내부 기준으로 정렬시 밖에서 보면 무엇을 기준으로 정렬되는지 모른다. . | Comparator 는 도메인 클래스에 변경을 가하지 않고도 변경에 유연해진다. | 정렬 기준을 코드 자체로 나타내기 때문에 협업에도 더 좋은 것 같다. | . | .",
            "url": "blog.chojaeseong.com/java/comparable/comparator/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/comparable_vs_comparator(%EC%99%84).html",
            "relUrl": "/java/comparable/comparator/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/comparable_vs_comparator(%EC%99%84).html",
            "date": " • Feb 21, 2022"
        }
        
    
  
    
        ,"post25": {
            "title": "git강의(upstream, git객체)",
            "content": "준의 git 강의 . upstream . . 기본적으로 최초push에서는 local -&gt; origin의 연결에 local에 대한 상대적 상류(upstream) 를 -u로 명시해줘야한다. . | -u는 --set-upstream으로 상대적인 상류를 표기한 것이다. . | . | 일반적으로 origin에 대한 origin이 upstream이라고 별칭한다. 미션repo(upstream) -&gt; fork repo(origin) -&gt; clone repo(local) | . | 최초 명시해준 것처럼 upstream은 downstream에 대해 상대적인 것이다. | . | 깃허브 초기 메세지 박스를 보면 -u가 있는데 상대적 상-하 관계를 설정하는 upstream설정을 요약한 단어다 . 없으면 push가 안된다. | 내 local의 remote인 origin이라는 원천이라는 upstream으로 사용한다 보통은 원천(origin)보다 위쪽(stream)은 없다. | 하지만, fork로 가운데origin이 생기면서, 원본 repo를별칭stream을 사용하게 된다. | 우테코의 경우, 미션repo를 fork해해서 origin보다 더 상위단계가 생기므로 upstream | . | . . 여러개의 downstream이 존재함을 안보이더라도 생각해야한다. git clone시((origin &lt;-&gt; local)에는 origin을 알고 있기 때문에 자동으로 stream관계가 설정되어 push할 때 -u를 통한 upstream 설정은 안해도 된다. | . | . | . –help명령어와 git 객체 . 퀴즈1 . O . git help메세지들을 잘 보자. . .git안에 깃 저장소를 초기화 했습니다. | ls -al 숨긴 파일, 폴더 보면 .git이 깃 저장소(로컬 저장소)가 보인다. | . . tree .git/으로 로컬저장소의 구조를 보면 | . | 명령어 도움말은 명령어 + --help를 뒤에 달면된다. . | . | 퀴즈2 . blob은 파일으로 생각하자. . | 답은 5번 . branch는 commit객체에 대한 참조만 가지고 있다. | . . | commit . 커밋 = 작업 디렉토리 스냅샷 = 세이브 포인트 | 돌아가기 위한 포인트.. commit + push만 하지말자 | 돌아가기 위한 정보를 어떻게 담고 있을까 | . . | add시 생성객체, commit시 생성객체를 나누었다. . . add하면, git이 a.txt를 관리대상으로 인식한다. 아까는 없었던, index와 object가 추가 된다. | . | . . commit하면, tree(파일관련), commit(tree를 담고 있는)객체까지 만들어서 2개가 더 만들어진다. | . . | 퀴즈3 . . git은 변경사항만 저장한다? 흔한 오해 -&gt; 파일을 통채로 저장한다! | 엄청 뒤로 갈 때, 변경사항만으로 추적? -&gt; 연산 엄청 많아진다. 그냥 속도측면을 중요시해서 통채로 저장 = 객체로 관리 | 원본 파일마다 tree객체를 가지고 있다. 통채로 저장해놓고, 그것들을 관리하기 위한 커밋이 가진다. 마지막 commit상태의 blob을 본다. | 변경사항을 저장하는게 아니라서.. | . | . | . | . | .",
            "url": "blog.chojaeseong.com/git/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/17/%EC%A4%80)-upstream%EA%B3%BC-git%EA%B0%9D%EC%B2%B4-%EA%B0%95%EC%9D%98(%EC%99%84).html",
            "relUrl": "/git/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/17/%EC%A4%80)-upstream%EA%B3%BC-git%EA%B0%9D%EC%B2%B4-%EA%B0%95%EC%9D%98(%EC%99%84).html",
            "date": " • Feb 17, 2022"
        }
        
    
  
    
        ,"post26": {
            "title": "그림판으로 보는 git협업 미션",
            "content": "git-mission . https://github.com/woowacourse/retrospective/discussions/4 . 미션repo 관리자와 fork하는 페어1과 페어2가 있다. 관리자(upstream) - 페어1,2(origin) - 각 로컬(local) 형태로 구성할 예정 | . | . 관리자는 github에서 repo(git-mission)를 파고, readme.MD를 작성한다. . README.md # 백엔드팀 . . | pair1, pair2가 각각 관리자의 repo( 예정upstream) -&gt; fork(origin) -&gt; clone(local)한 뒤 . main만 있던 repo안에 작업용 각자의 {github_id}로 . | 미션repo(관리자repo)는 main만 일단 유지한다고 가정하며, . | 작업자들은 main fork -&gt; main clone -&gt; local main외 local {본인github_id}를 파서 작업하자. . git checkout -b is2js&lt;github_id&gt; . git branch -a . . 우테코와 같이 특수한 경우(관리자 repo가 main이외에 개별 br를 다 가지고 있는 경우) 작업자들은 학습사이트를 통해 생성된 main + 수많은 {본인github_id} fork -&gt; --single-branch하여 {본인github_id} clone ** -&gt; local {본인github_id} 외에 **step1 을 파서 작업한다. | . | . | . | pair1부터 readme.md를 수정 -&gt; pair2는 대기(파일 수정해도 됨) . 파일수정 . | add + commit . | (clone해왔지만, br바꿨기 때문에) push with origin과의 upstream 최초 설정 . git push --set-upstream origin is2js&lt;github_id&gt; . . | . | pair1은 [fork repo]의 main외 작업br{github_id} -&gt; [원본repo] main에 PR을 날릴 수 있다. . 보통 fork -&gt; clone -&gt; 작업br 파기 -&gt;(origin입장에서 new br인)작업br push -&gt; fork 작업br to 원본 main br로 PR in github | . | 관리자의 merge in github . | pair2가 conflict를 내기 위해 관리자 최신main from pair1 or pair1 최신을 가져오지 않고 . pair1이 작업끝내기 전에 같은 파일에 작업시작 | . . | pair2의 무지성 PR -&gt; conflict를 github가 알려준다. . 공통 작업자가 있다면, 같은 파일 수정 가능성이 있다면, PR전에 pair나 upstream의 pull부터 해야함. | github에서 PR을 만드려고 하면 conflict를 알려준다. | . | **pair2는 최신소스가 업데이트된 원본repo를 받아오기 위해 local &lt;-&gt; 원본repo upstream으로 등록하고, 받아와야한다. ** . pair1을 pair로 등록하고 받아와도 될 것 같은데, 중심은 원본repo에서 받아온다. . | 중간 다리인 fork는 주고/받을 때 별 영향이 없다. local과 원본repo가 연결되어야 최신소스를 받으니, upstream라는 별칭으로 원격저장소를 추가하여 연결한다. . . git remote -v # fork -&gt; clone으로 형성된 origin = fork레포만 연결되어있다. git remote add upstream&lt;원본레포 별칭&gt; &lt;원본레포 URL&gt; git remote -v git fetch upstream # fetch는 커밋내역만 가져오는데 [원격저장소별칭]만으로 가져올 수 있다. # 가져올 br이 있는지 확인한다. git branch -a git merge upstream/main # 가져올 [원격저장소별칭/br] 형태로 merge를 요청한다. . | . | 가져와서 conflict를 (vscode 등에서) 해결하고, 다시 fork(origin)으로 push -&gt; github에서 PR을 날리면 된다. . git push origin is2js{github_id} . . | 우테코의 코드리뷰는 더 복잡하다. . 원본repo의 관리자 -&gt; 리뷰어들이 merge를 담당한다 . | fork전, 우테코 학습사이트를 통해 원본repo에 main외 내 {github_id}로 하면서 PR의 최종merge가 각자의 {github_id}로 되도록 먼저 생성한다. . | fork하면, main + 모든 리뷰이들의 {github_id}들이 있다. -&gt; 내 {gihub_id}의 br만 로컬로 clone해와야한다. . git clone -b is2js&lt;내github_id&gt; --single-branch https://github.com/is2js/java- racingcar.git&lt;url&gt; . | clone후, 내입장에서의 main branch인 {github_id}에서 작업용=리뷰어br인 step1부터 파서 시작한다. . | 만약, 페어가 있다면 한 곳의 step1을 선택한 다음, 작업이 끝나면 찢어진 뒤 . pair라는 별칭으로 git remote add pair &lt;URL&gt;을 하고 | fetch -&gt; merge하여 작업된 pair의 코드를 가져온 뒤, 작업을 시작한다. | . | . . |",
            "url": "blog.chojaeseong.com/git/%ED%98%91%EC%97%85/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/17/git_%EA%B7%B8%EB%A6%BC%ED%8C%90%EC%9C%BC%EB%A1%9C_%EB%B3%B4%EB%8A%94_%ED%98%91%EC%97%85%EB%AF%B8%EC%85%98(%EC%99%84).html",
            "relUrl": "/git/%ED%98%91%EC%97%85/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/17/git_%EA%B7%B8%EB%A6%BC%ED%8C%90%EC%9C%BC%EB%A1%9C_%EB%B3%B4%EB%8A%94_%ED%98%91%EC%97%85%EB%AF%B8%EC%85%98(%EC%99%84).html",
            "date": " • Feb 17, 2022"
        }
        
    
  
    
        ,"post27": {
            "title": "코드리뷰 방법 2단계(step1 PR merge이후)",
            "content": "그 전 1단계 마무리 . local의 step1 브랜치에서 local commit만 한다. | 각종 검토후 push한 뒤, 최초PR을 날린다. (local step1 —&gt;) forkrepo step1 -&gt; 원본repo is2js | . | 최초PR이후, local commit만하다가, 2번쨰 push부터는 피드백 반영된다. | 리뷰어는 PR을 merge . **리뷰어는 ** . Push하여 피드백 반영된 fork-step1 —&gt; 원본-is2js의 PR을 merge시키는 권한이 있다. . 피드백 최종반영 fork step1 to 원본 is2js PR후 N번 피드백push . | 리뷰어의 PR을 merge . . | . | . | . 1단계완성br {github_id} -&gt; local 반영 . 참고문서: 코드리뷰 3단계 | . local 먼저 {github_id} checkout . . local branch를 일단 is2js{github_id}로 넘어온다. . . git checkout is2js&lt;github_id&gt; . | . 원본repo와 동기화 . 원본repo를 별칭upstream으로 remote add . . 현재 local에 달린 git remote 확인하기 . origin: fork레포 | (B라면, pair: A의 repo) | . git remote -v . 결과 . origin https://github.com/is2js/java-racingcar.git (fetch) origin https://github.com/is2js/java-racingcar.git (push) pair https://github.com/Wishoon/java-racingcar.git (fetch) pair https://github.com/Wishoon/java-racingcar.git (push) . | . | 원본(미션)repo를 upstream이라는 별칭으로 원격저장소 등록해주기 . git remote add upstream&lt;별칭&gt; https://github.com/woowacourse/java-racingcar.git&lt;원본(미션)repo&gt; . git remote add upstream https://github.com/woowacourse/java-racingcar.git . 결과 . git remote add upstream https://github.com/woowacourse/java-racingcar.git git remote -v origin https://github.com/is2js/java-racingcar.git (fetch) origin https://github.com/is2js/java-racingcar.git (push) pair https://github.com/Wishoon/java-racingcar.git (fetch) pair https://github.com/Wishoon/java-racingcar.git (push) upstream https://github.com/woowacourse/java-racingcar.git (fetch) upstream https://github.com/woowacourse/java-racingcar.git (push) . | . | . fetch로 원본repo상 merge된 내 br {github_id} -&gt; {remotes/별칭/내br}으로 가져오기 . . fetch로 원본repo상에 리뷰어에 의해 merge된 is2js를 -&gt; local is2js로 가져오기 . git fetch upstream&lt;별칭&gt; is2js&lt;가져올br명&gt; . 결과 . git fetch upstream is2js remote: Enumerating objects: 1, done. remote: Counting objects: 100% (1/1), done. remote: Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (1/1), 2.22 KiB | 759.00 KiB/s, done. From https://github.com/woowacourse/java-racingcar * branch is2js -&gt; FETCH_HEAD * [new branch] is2js -&gt; upstream/is2js . | . | git branch -a를 확인해보면 remotes/별칭/{merge된 내br=github_id}로 생성되었다. . git branch -a . 결과 . . | . | . rebase(1줄 이어붙merge)로 {fetch한 원격br}을 -&gt; {로컬br}과 동기화 . . 원격br -&gt; 로컬br에 끊어진 이후부터 &lt;merge와 달리 1줄&gt;로 이어붙이는 작업인 것 같다. . git rebase upstream/is2js . 결과: fetch한 remotes/upstream/is2js랑 local의 is2js랑 완전히 동일해졌다. . . | 참고로 rebase는 커밋 n개 합치기용(-i) or merge를 깨끗하게( . merge와 비교 장점: 커밋해쉬 유지 및 흐름 유지되어 돌아갈 수 있음 | 단점: merge라는 불필요커밋을 생성함. | . | rebase 장점: 주는놈위에 받는놈위주로 정리가 됨. 깨끗한 커밋 히스토리가 됨. | . | . | . | . 2단계 br 생성하기 . step2 br 생성과 동시에 checkout . 최신화(fetch -&gt; rebase)된 is2js{github_id}에서 받아와 생성되도록 한다. . git checkout -b step2 . | . 이후 step2에 작업후 add/commit/push-&gt;PR-&gt;push반복-&gt;merge . 나는 step1에 작업하던 것이 남아서 step2에서 merge받았다. . . | . step1 삭제 . 1단계 br은 이제 삭제한다. . git branch -d step1 . | .",
            "url": "blog.chojaeseong.com/git/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%ED%98%91%EC%97%85/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/16/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-2%EB%8B%A8%EA%B3%84(%EC%99%84).html",
            "relUrl": "/git/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%ED%98%91%EC%97%85/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/16/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-2%EB%8B%A8%EA%B3%84(%EC%99%84).html",
            "date": " • Feb 16, 2022"
        }
        
    
  
    
        ,"post28": {
            "title": "생성자와 일급컬렉션(사용이유, 테스트)",
            "content": "생성자 규칙 . 나만의 규칙 . 생성 루트가 여러개 ex&gt; List&lt;String&gt; or List&lt;Car&gt;인 일급컬렉션 private 필요속성(만) 받는 기본생성자 | public fromStrings( List&lt; String &gt; ) inputView에서 검증을 하고 오므로 검증없이 -&gt; List&lt;객체&gt;로 변환 -&gt; 생성자 | . | public from객체(List&lt; 객체 &gt;) test등에서 단일객체 -&gt; List add되어 들어오는데, 복수 검증(중복)을 추가후 -&gt; 생성자 | . | | VO, 단일객체라도 숫자형이라면 -&gt; inputView에서 형변환후, 해당형으로 검증되도록 inputView에서 따로 검증안한다면, public 생성자에서 검증까지 다 처리하면 될 듯함. inputView에서는 VO는 형변환하고나서 -&gt; 검증하자. | . | inputView 검증해야하는 상황이라면? -&gt; 형변환후 int만 검증 public 기본생성자(원본 타입) with 노검증(for inputView거친 뒤 controller or 숫자VO 연산) | public fromNumber(원본타입) with 검증(for 테스트 or int직접생성) | | | . 일급컬렉션 생성자와 사용이유 . 생성자 2+1개 . fromXXXX: InputView에서 검증된 List&lt; String &gt;를 받는 public 정적팩토리메서드 . InputView.getXXX() 에서 검증 후 들어오는 ** -&gt; **List&lt; String &gt;으로 들어올 것이기 때문에 .fromStrings( )형식으로 작성한다. . String List -&gt; 단일객체 List로 변환되어 -&gt; 기본 생성자를 부른다. | . public static Cars fromNames(List&lt;String&gt; values) { //input에서 검증하고 와서, 변환만 List&lt;Car&gt; cars = values.stream() .map(value -&gt; Car.from(value)) .collect(Collectors.toList()); return new Cars(cars); } . | . from: 테스트 등에서 List&lt; 단일객체 &gt;를 받는 public 정적팩토리메서드 . 기본생성자는 private하게 유지하기 위해, 테스트용 public 기본 생성자 from ( List&lt; 단일객체 &gt;로 생각하자. . 따로 개별 검증은 필요 없고(단일객체 생성시 이미 검증) -&gt; 중복검사 등만 필요 | . public static Cars from(List&lt;Car&gt; cars) { //중복 검증 등 return new Cars(cars); } . | . 기본생성자: private + List&lt; 단일객체 &gt; . inputView 검증-&gt; fromStrings . | test -&gt; from -&gt; 복수검증 . | 기본생성자는 일단 검증 없이 생성만 하는 역할을 하게 한다. . private Cars(List&lt;Car&gt; cars) { this.cars = cars; } . | . 쓰는 이유 4가지 . 참고 블로그 | . 01 검증 통과해야만 생성 가능한 자료구조(비지니스 종속 자료구조) . 흩어져있는 검증 기능들을 외울 수 없다. 신입사원이 와도 바로 작동하도록 하는 객체를 만들어야한다. . | 해당, util등에서 처리할게 아니라 검증 만족시 생성가능한 자료구조를 만들어 신입사원도 쓸 수 있게 해야한다. . public static Cars from(List&lt;Car&gt; cars) { Validator.validateCarsName(getCarNames(cars)); return new Cars(cars); } . | . 02 setter/add 등이 없는 불변구조 . List는 add, map은 put 등의 메서드를 제공하는데 . 일급컬렉션으로 감싸서 생성자와 getter류 기능만 제공하도록하고 setter 등을 제공하지 않음녀 불변구조가 된다. . | 자료구조에 final을 붙혀도 해당 context에서 재할당만 불가 -&gt; add, put 등은 가능함. . cf) 일급컬렉션에 변수는 1개이며, final이 붙어서 최초생성이후 변경할 수 없게 한다. | . private final List&lt;Car&gt; cars; . | . | . 03 상태(변수)와 행위(기능)을 자료구조와 함께 한 class에 다 모으기(냉무) . 05 이름을 가지는 자료구조가 됨.(냉무) . 일급컬렉션 테스트 . 단일객체 -&gt; 일급컬렉션 순서대로 생성 . 단일객체 -&gt; 일급컬렉션 순서대로 생성하도록 전역변수 -&gt; @BeforeEach에서 List&lt; Car &gt;를 받으면서 중복 등 다수검증하는 from으로 생성한다. | 단일 객체생성은 여기서는 다루지 않지만, 검증이 들어간 로직으로 해야할 듯. | . | . //1. 일급컬렉 Test: @BeforeEach에서 단일객체 개별생성 후(그래야 개별조작 가능 -&gt; 반영) List에 담아놓기 Car 코니; Car 재성; Cars cars; @BeforeEach void setUp() { 코니 = new Car(&quot;코니&quot;); 재성 = new Car(&quot;재성&quot;); cars = Cars.from(Arrays.asList(코니, 재성)); } . given자리에 단일객체 조작을! when에서는 일급컬렉 기능을! . given자리에 일급컬렉션과 공유된 개별 객체들을 조작후 -&gt; 테스트한다. . @Test void getMaxposition_method_test() { //given -&gt; 단일객체를 조작 코니.move(() -&gt; true); 재성.move(() -&gt; false); //when Car actualMaxPositionCar = getMaxPositionCar2(); //then assertThat(actualMaxPositionCar).isEqualTo(코니); } // private하며 메서드 내부의 메서드 -&gt; 복사하고, 인자를 바꿔주자. private Car getMaxPositionCar2() { Car maxPositionCar = Arrays.asList(코니, 재성).stream() .max(Car::compareTo) .orElseThrow(() -&gt; new IllegalArgumentException()); return maxPositionCar; } . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%ED%85%8C%EC%8A%A4%ED%8A%B8/%EC%83%9D%EC%84%B1%EC%9E%90/2022/02/15/%EC%83%9D%EC%84%B1%EC%9E%90_%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98_%EC%82%AC%EC%9A%A9%EC%9D%B4%EC%9C%A0_%ED%85%8C%EC%8A%A4%ED%8A%B8(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%ED%85%8C%EC%8A%A4%ED%8A%B8/%EC%83%9D%EC%84%B1%EC%9E%90/2022/02/15/%EC%83%9D%EC%84%B1%EC%9E%90_%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98_%EC%82%AC%EC%9A%A9%EC%9D%B4%EC%9C%A0_%ED%85%8C%EC%8A%A4%ED%8A%B8(%EC%99%84).html",
            "date": " • Feb 15, 2022"
        }
        
    
  
    
        ,"post29": {
            "title": "commit.template과 message양식",
            "content": "commit.template 활용하기 . template(.gitmessage.txt) 생성 . 이미 지정된 commit.template의 터미널에서 확인 . 없으면 원하는 경로에서 .gitmessage.txt를 생성하면 됨. | . git config --global commit.template . C: Users cho_desktop .gitmessage.txt에 지정 해놨었다. . cf) 적용 코드 . git config --global commit.template C: Users cho_desktop .gitmessage.txt . | . | . | 해당 경로(윈도우의 경우, 풀 경로)로 가서 커밋.템플릿을 생성/수정한다. . .gitmessage.txt . #commit전: 클-상-변개행/F8/pub메 테스트만/함수순서/불필요개행&amp;매직넘버/ 테스트돌리기 #fix | feat | build | chore | ci | docs | style | refactor | perf | test: ##### Subject 50 characters ## don&#39;t finish with . ##-&gt;| ######## 본문은 한 줄에 최대 72 글자까지만 입력 ########################### -&gt; | # 제목에서 한줄 띄고, 여러줄운 &quot;- 내용1 - 내용2&quot; , &quot;무엇을&quot; &quot;왜&quot; 기술 &gt;&gt; &quot;어떻게&quot; 72자 제한 ################################ # 꼬릿말은 아래에 작성: ex) #이슈 번호 # COMMIT END # &lt;타입&gt; 리스트 # feat : 기능 (새로운 기능) # fix : 버그 (버그 수정) # refactor: 리팩토링 # style : 스타일 (코드 형식, 세미콜론 추가: 비즈니스 로직에 변경 없음) # docs : 문서 (문서 추가, 수정, 삭제) # test : 테스트 (테스트 코드 추가, 수정, 삭제: 비즈니스 로직에 변경 없음) # chore : 기타 변경사항 (빌드 스크립트 수정 등) # # 제목 첫 글자 -&gt; 대문자 # 제목 명령문 # 제목 끝에 마침표(.) 금지 # 제목과 본문을 한 줄 띄워 분리하기 # 본문은 &quot;어떻게&quot; 보다 &quot;무엇을&quot;, &quot;왜&quot;를 설명한다. # 본문에 여러줄의 메시지를 작성할 땐 &quot;-&quot;로 구분 # . | . | . 생성 템플릿 적용하기 . global 설정 . 명령어를 통해 지정 . git config --global commit.template C: Users cho_desktop .gitmessage.txt . | .gitconfig의 [commit]블럭안에 template을 직접 수정 . [commit] template = C: Users cho_desktop .gitmessage.txt . | repository별 설정 . ~/.gitconfig를 사용하는 대신 해당 repository안에 있는 .git/config에 위에서 설명한 [commit]블락을 추가 . [commit] template = C: Users cho_desktop .gitmessage.txt . | .",
            "url": "blog.chojaeseong.com/git/%ED%98%91%EC%97%85/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/2022/02/15/commit.template%EA%B3%BC-%EC%96%91%EC%8B%9D-%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/git/%ED%98%91%EC%97%85/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/2022/02/15/commit.template%EA%B3%BC-%EC%96%91%EC%8B%9D-%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Feb 15, 2022"
        }
        
    
  
    
        ,"post30": {
            "title": "intellij 협업 세팅",
            "content": "인텔리제이 세팅 . buildType &amp; assertj라이브러리 . build Type: gradle -&gt; intellij . gradle검색후 build and run intellij로 바꿔주기 빌드 속도 및 | TestName표기 | . | new projects에서 세팅 안됨 | . 라이브러리에 assertj 추가 및 refresh . build.gradle의 dependency에 assertj 라이브러리 넣어주고 refresh 하기 . testImplementation &#39;org.assertj:assertj-core:3.22.0&#39; testImplementation &#39;org.junit.jupiter:junit-jupiter-params:5.4.2&#39; //@ParameterizedTest 안될 때 . | Ctrl+Shift+O 또는 우측상단에 떠있을 코끼리버튼을 클릭해줘야 반영이 된다. . 단축키는 keymap에서 덮어써줘야 작동됨. . | 그래도 잘 안되면, Test파일에 static import해놓고 reload from disk . import static org.assertj.core.api.Assertions.*; . | . | . gradle 정상 test . . shift 2번 or f1 -&gt; gradle task선택 gradle clean 수행 | gradle test 수행 | | 루틴 설정(1회성으로 보임) . ends with a line break . Editor &gt; General &gt; on Save 탭 &gt; ends with a line break에서 해당 박스를 체크한다. | . ​ . Code style(우테코) . 우테코javastyleXML, naverConventionXML 다운로드 프로젝트폴더 최상단에 넣어준다. | . | Editor &gt; code style &gt; Scheme &gt; 톱니바퀴 &gt; Import Scheme &gt; Intellij IDEA XML intellij-java-wooteco-style.xml 선택해주기 | . | 1회성 설정 . New Project setup . File &gt; New Projects Setup &gt; Settings for New projects&gt; . . | . Auto Import . Always -&gt; Ask로 변경(복붙후 library 선택) | Add unambiguous import on the fly 체크 . | Optimize imports on the fly (for current project) 체크 . . | . Save Actions (개행+imort최적화) . Plugins &gt; market &gt; save actions를 검색해서 설치한다. . import최적화(삭제) + 리포맷팅 자동 . | . file Encoding . 3가지 전부 UTF-8확인 | . tab (4space) . **Editor &gt; Code style &gt; java &gt; tabs and indents &gt; ** [ ] Use tab character 체크해제 | Continuation indent 8-&gt;4 | . | OS마다 tab의 크기가 다르므로 space를 사용하게 tab사용 체크해제하는 것 | . File and Code Templates &gt; method body template . 베루스 추천 . | settings &gt; File and Code Templates &gt; code 탭에서 . implemented + new + Overriden Method Body부분에 | . ##if ( $RETURN_TYPE != &quot;void&quot; )return $DEFAULT_RETURN_VALUE;#end throw new UnsupportedOperationException(&quot;${SIMPLE_CLASS_NAME}#${METHOD_NAME} not implemented.&quot;); . | . usages 표기 . preferences - editor - inlay hints - java - code vision usages 2가지체크 | . | . final 및 private . method의 파라미터 . Editor &gt; Code style &gt; java &gt; Code generation &gt; [x] make ~ final 체크박스 2개 | . 변수 추출 (최초 1회) . 추출할 때, ctrl + alt + v를 **2번 눌러서, ** Declare final체크 | . | . (private) 상수를 private로 추출(최초 1회) . 추출할 때, ctrl + alt + c를 **2번 눌러서, ** public -&gt; private로 옮겨놓기 | . | . Font . editor &gt; font &gt; jetbrain Mono -&gt; fira code + ligature 허용 | . 페어 컨벤션(링크) . 구글 스프레트 시트 링크로 매번 업데이트 된 것 활용하기 | . .editorConfig for windows에서도 LF로 저장 . 다양한 에디터들에게 공통적인 코드컨벤션을 적용시킨다. 적용시 windows에서도 LF로 저장되게 한다. | . | 루트에서 NEW &gt; EditorConfig 검색후 생성한다. . | 아래 내용을 복붙한다. . # top-most EditorConfig file root = true [*] # [encoding-utf8] charset = utf-8 # [newline-lf] end_of_line = lf # [newline-eof] insert_final_newline = true [*.bat] end_of_line = crlf [*.java] # [indentation-tab] indent_style = tab # [4-spaces-tab] indent_size = 4 tab_width = 4 # [no-trailing-spaces] trim_trailing_whitespace = true [line-length-120] max_line_length = 120 . | . checkstyle . 일단 LF로 push하기 위한 git 전역설정이 되어있어야한다. . 윈도우에서는 git commit시 CRLF로 새줄을 저장하지만, 위 설정을 통해 push시에는 LF로 올라가게 한다. . Git은 커밋할 때 자동으로 CRLF를 LF로 변환해주고 | windows로 clone하면 다시 LF가 CRLF가 됨 | . git config --global core.autocrlf true . | . | 없다면 플러그인 Plugins 에서 CheckStyle-IDEA검색 후부터 설치한다. . CheckStyle-IDEA 설치 | 프로젝트 최상단에 naver-checkstyle-rules.xml를 위치시키고 | Tools &gt; Checkstyle에서 버전을 8.24 이상으로, | Scan Scope를 All sources(including tests)로 맞추고 - 테스트 한글함수를 위해서 tests 포함안해도 될 듯? | +를 눌러, 위에서 편집해준 naver-checkstyle-rule를 추가해준다. | naver-checkstyle-rule을 선택해준다. | . | . | 네이버핵데이 컨벤션 및 CheckStyle 적용하기 . 요약 . Settings &gt; Editor &gt; Code style &gt; Java &gt; Scheme &gt; 톱니바퀴 &gt; import Scheme &gt; (ideaProject폴더에 다운받아놓은 )InteliJ ~ .xml 파일 찾아 적용 cf) code style&gt; java에서 use tab character를 풀어야 4스페이스가 된다. Tab 사용하도록 체크하자. | | 파일을 저장 할 때마다 포멧터 자동 적용설정 by Save Actions plugin을 활용하면 파일을 저장하는 순간 포멧터를 자동 적용할 수 있다. File &gt; Settings ( Ctrl + Alt + S ) &gt; Plugins 메뉴로 이동 | Marketplace 탭에서 ‘Save Actions’ 로 검색 | Save Actions&#39; plugin의 상세 설명 화면에서 [Install]` 버튼 클릭 | IntelliJ를 재시작 | File &gt; Settings &gt; Other Settions &gt; Save Actions 메뉴로 이동 | 아래 항목을 체크 Activate save actions on save | Optimize imoprts | Refomat file | . | | 플러그인 CheckStyle-IDEA 플러그인을 검색 후 설치 Tools &gt; CheckStyle에서 Checkstyle version을 8.24 이상, Scan Scope를 All sources (including tests) 로 설정 | Configuration file에 다운받고 수정한 XML 파일(ideaProject폴더에 다운받아놓은 naver~checkstyle rule.xml)을 추가 | 하단에 checkstyle 창(단축키 직접지정 alt+shift+k)로 코드짜고 확인하기 | | | . . . intellij용 xml파일 다운로드 | 설치가이드 https://naver.github.io/hackday-conventions-java/#intellij-formatter | 나는 지금 플러그인 : google-java-format&gt; android 버전을쓰고있는데.. 취소시킴 | . | checkStyle적용하기 . CheckStyle은 Java 코드를 작성 할 때 규칙(이 경우 코딩 컨벤션)들을 선언해두고 이를 어길 시 에러 또는 경고를 뿜어내어 개발자로 하여금 컨벤션을 강제로 지킬 수 있도록 도와주는 코딩 컨벤션 검사 도구다. 네이버 핵데이 Java 코딩 컨벤션을 적용할 시 다음을 제외한 나머지들에 대한 컨벤션을 검사할 수 있다. . 한국어 발음대로의 표기 금지 | 클래스 이름에 명사 사용 | 인터페이스 이름에 명사/형용사 사용 | 메서드 이름은 동사/전치사로 시작 | 테스트 클래스는 ‘Test’로 끝남 | 대괄호 뒤에 공백 삽입 | 주석문 기호 전후의 공백 삽입 | . | 적용방법 . Naver CheckStyle Rules XML 파일을 다운받는다. 나는 프로젝트 최상단($rootDir)에 이를 추가했다. . 내문서 &gt; IdeaProjects폴더에 저장함. | . | 우선 나는 다른 규칙을 덮어쓸 생각이 없어서 여기를 참고하여 XML 파일에서 다음을 삭제했다. 이를 삭제하지 않으면 다음 단계에서 suppressionFile 변수에 파일을 할당해야한다. . &lt;module name=&quot;SuppressionFilter&quot;&gt; ​&lt;property name=&quot;file&quot; value=&quot;${suppressionFile}&quot;/&gt; ​&lt;property name=&quot;optional&quot; value=&quot;false&quot;/&gt; &lt;/module&gt; . | . | ide에 적용하기 . File &gt; Settings &gt; Plugins 메뉴에서 CheckStyle-IDEA 플러그인을 검색 후 설치한다. | Tools &gt; CheckStyle에서 Checkstyle version을 8.24 이상, Scan Scope를 All sources (including tests) 로 설정한 후 Configuration file에 다운받고 수정한 XML 파일을 추가하자 | 이제 우리가 설정한 코딩 컨벤션을 어기는 코드를 작성하면 다음과 같이 경고 표시가 나타난다. | | . | .",
            "url": "blog.chojaeseong.com/intellij/%EC%9A%B0%ED%85%8C%EC%BD%94/%ED%98%91%EC%97%85/2022/02/13/intellij_%ED%98%91%EC%97%85%EC%84%B8%ED%8C%85(%EC%99%84).html",
            "relUrl": "/intellij/%EC%9A%B0%ED%85%8C%EC%BD%94/%ED%98%91%EC%97%85/2022/02/13/intellij_%ED%98%91%EC%97%85%EC%84%B8%ED%8C%85(%EC%99%84).html",
            "date": " • Feb 13, 2022"
        }
        
    
  
    
        ,"post31": {
            "title": "Intellij_단축키(완)",
            "content": "toc: true layout: post title: intellij 단축키 및 플러그인 description: 필수 플로그인 및 vscode keymap단축키 . categories: [intellij, 우테코, 단축키, 플러그인] image: “images/posts/wootech.png” . 인텔리제이 플러그인 및 단축키 . 플러그인 . vscode keymap검색 install . keymap탭 가서 VSCode로 바꾸기 | . | key Promoter X 설치 vscode keymap 바꾼것도 보여준다. | | Rainbow Brackets . | .ignore : 우클릭으로 ignore파일을 만들어주는데, . 우클릭 &gt; new &gt; ignore file &gt; .gitignore파일 &gt; 선택하면 됨. | 자동완성도 해줌. | . | cobalt2 theme . | translation . Plugin &gt; MarketPlace &gt; Translation검색 . | Tools 내부에 있음. 기본적인 세팅은 구글번역 . | 단축키 일부 재정의 . 공부용 영-&gt;한 번역기: ctrl+shift+ Y 아무것도 없는 곳에 두고 누르면 code with me 단축키 | . | 코딩작명용 한-&gt;영 즉시번역 : ctrl+shift+X Translate and Replace: 설정창에 묻혀서 단축키 재정의 (ctrl+shift+x)-&gt; 다른것 remove) | . | . | | Codota . 검색후 설치한 뒤, 자동완성시 % 보여주고 + snippet 검색 가능 . . . | . | prgoress bar검색후 마리오로 설치 . . | TabMover 설치후 . 파일 띄우기: ctrl+alt+shift+ D | 복사후 이미 떠있는 반대창에 종속시키키: ctrl+ 이후 ctrl+alt+shift + Up | . | 단축키(vscode keymap기준) . shift 2번 : 전체 검색(유지) vscode F1 | . | keymap 들어가서 move To opposite group검색후 ctrl+shift+ 오른화살표지정하기 ctrl + 이후 넘기기..왼쪽넘기기 기능 자체는 없나보다. | alt+shift+0으로 세로로 넘기기 가능 | . | alt+shift+F : reformat code -&gt; 한파일내 패키지 or 폴더 선택후 alft+shift+F | . | keymap 들어가서 back검색후 ctrl+u지정하기 | ctrl + .으로 메인메소드 내용을 extract method 호돌스에서 봄. | 메소드 분리 및 패키지명 작성하고 폴더이동시키기 | . | 신세계) alt+insert로 생성자를 만듬 | **신세계) 메서드사용을 위한 객체 만들 때(인스턴스화) 할 때, ** new 클래스명(); 기입후 ctrl+.으로 local변수 자동(선택후)생성하자. | 객체.메서드();기입후 ctrl+.으로 메서드결과값 받는 변수 자동(선택후)생성 | . | keymap -&gt; extend line selection -&gt; ctrl+L을 추가해서 사용하기 라인 선택하기 shift+alt+아래화살표로 복사할때,, 라인 선택해서해야.. 꼬임없을 듯 | . | . | shift+ alt+ F10: 실행할 class파일 선택해서 실행 ctrl+alt+F10은 바로 실행. | . | shift + alt + x: 현재 파일들 다 close | shift + alt + a : 긴글 주석? . | alt + ~ : git관련 명령어들 목록나옴 . | ctrl+F11 or ctrl+shift+{key}로 북마크 지정 -&gt; ctrl+해당번호로 이동 | keymap -&gt; show bookmaks검색후 -&gt; CTRL+SHIFT + F11 으로 지정함 | . | ctrl+f3 : 같은단어 이동가능한 검색한 상태로 만들기 == ctrl+f f3 : 같은 단어 다음으로 이동 | shift+f3 : 같은단어 이전 단어로 이동 | . | shift+F5 : 실행중인 작업 종료 ctrl+F5 : 실행 | shift+ alt + f10 : main함수 골라서 실행 | . | alt+7: 현재파일 Structure(메소드 등) 한눈에 보기 유틸메서드로 빼기, 상수 옮기기 : f6으로 편하게 | . | 리팩토링 alt+ctrl+c : 값을 상수로 등록해버리기 | alt+ctrl+m : 코드를 메서드화 시키기 2번 눌르면 창으로 하는 듯 | . | alt+ctrl+v: new 클래스()까지 입력후 참조변수 바로 생성 | alt+ctrl+p: 클래스내 변수/메서드 사용을 -&gt; 작성중인 메서드의 파라미터로 빼고 싶을 때 ex&gt; 테스트를 위해 내부랜덤요소를 파라미터로 받도록 설게 | . | . | 축약어 iter | fori 추가 | itar | ifn | inn | . | F8: 오류바로 찾아가기 | ctrl+f -&gt; F3 or shift + F3 : 검색항목 순서대로 찾아가기 . | alt + del : 메소드 등 안전하게 지우기 . | keymap -&gt; refresh gradle dependen~검색 후 -&gt; shift+ c+a + G로 추가해서 사용 gradle에 추가한 라이브러리 재갱신시킬 때!! | . | keymap -&gt; checkstyle -&gt; alt+shift+k로 지정함 naver checkstyle 적용해보기 위함임. | . | F3 -&gt; 함수단위로 건너띄기 검색후 F3 : 다음 검색결과로 넘어가기 shift는 이전으로 넘어가짐. | . | . | ctrl+Tab : 직전창 왔다갔다하기 shift 안눌러도됨. | 메인로직(controller) 옆에서, readme &lt;-&gt; 세부작업중 파일싱글톤관리자, 서브화면 왓따갔다 하면 좋음 | . | ctrl+shift+alt+ I 후 -&gt; unused desc 검색후 -&gt; test파일 제외 체크 -&gt; 사용하지 않는 험수들 손수 제거하기 safe delete하니까..ㅠㅠ 설정 꼬였음. . | File -&gt; invalidate cache 캐쉬삭제 &amp; restart 해서 처리.. . | . | 라이브 템플릿 추가하기 싱글톤용 -&gt; sgt으로 생성 외부에서 메인로직관리싱글톤Class.getInstance()로 작성후 | 클래스 생성 후 sgt으로 채워주기 | . | 검증하며 무한호출하는 재귀 getInput InputView.getInput()작성후 getMany or getOne | . | 랩핑클래스용 | 이넘용 | . | keymap에서 Toggle case검색후 vscode의 대문자(U), 소문자(L)에 해당하는 것 2개를 다 추가해주기 . ctrl+alt+U , ctrl+alt+L | . . | try/catch등 한방에 씌우기: ctrl+alt+t . | ctrl+alt+O : library 적용안될 때 refresh시키는 단축키 덮어주기 default 단축키로 지정되어있지만, 겹치는게 많아서 잘 적용이 안되더라. 다른거 remove하면서 덮어준다. | . | ctrl+F2 : 동일단어 한번에 전체 선택 . | ctrl+space x 2 : 기존 navigate error 역할인 F8이 너무 멀어서 추가함 keymap -&gt; navigate error검색후 add ctrl+space + second stroke ctrl+space 추가 -&gt; 기존 F8 leave | . | alt+2: 북마크창 ctrl+shift+숫자 지정후 -&gt; 바로 alt+2 띄우는 버릇 들이기 | . | 플러그인 translation설치후 ctrl+shift+x : 변수 번역하기 . | 플러그인 tabMover설치후 TabMover 파일 띄우기: ctrl+alt+shift+ D | 복사후 이미 떠있는 반대창에 종속시키키: ctrl+ 이후 ctrl+alt+shift + Up | . | .",
            "url": "blog.chojaeseong.com/2022/02/13/intellij_%EB%8B%A8%EC%B6%95%ED%82%A4(%EC%99%84).html",
            "relUrl": "/2022/02/13/intellij_%EB%8B%A8%EC%B6%95%ED%82%A4(%EC%99%84).html",
            "date": " • Feb 13, 2022"
        }
        
    
  
    
        ,"post32": {
            "title": "fastpages change index.html",
            "content": "참고블로그 및 깃허브 이분은 옛날 버전인 것 같으며, index.md로 paginationd이 작동한다. | 그러나 내 버전의 _config.yml은 md파일을 html파일로 수정하라고 명시하고 있다. | . | . index.md를 posts pagination을 제공 안함. . index.md를 사용하면, 아래 posts의 pagination이 안된다고 _config.yml에 명시되어있었다. 그래서 index.md로 빌드는 되니, 빌드후 html소스를 복붙해서 index.html로 옮기는 방식으로 꾸미려고 한다. | . | index.html을 삭제한 상태에서 main으로 빌드 되어 표기는 되더라. | . index.html -&gt; index_backup.html로 빼놓기 . root에 index.html이 존재하면, index.md이 반영이 안되어 백업해놓는다. | . index.md 생성 후 내용 채워 push . 나름의 시행착오 끝에 완성한 index.md(생성해야함.) | . layout: home search_exclude: true ![](/images/logo_github.png &quot;로고&quot;){: style=&quot;float: right; margin-left: 20px&quot; width=&quot;180&quot;} ## I&#39;m... 평범한 한의사 `돌아온범생`의 우아한 엔지니어 도전기를 기록합니다.&lt;br/&gt; &lt;br/&gt; 조재성 Jaeseong Cho | &lt;br/&gt; Doctor of Korean Medicine, Currently studying SW engineering and biostatistics&lt;br/&gt; [more...](/about) ## Posts . markdown에서 이미지를 float시키는 방법 참고해보자. . !()[]{: style=&quot;float: right; margin-left: 20px&quot; width=&quot;180&quot;} . | . . . 블로그 -&gt; 소스보기 -&gt; html코드로 복붙 . &lt;main class=&quot;page-content&quot; aria-label=&quot;Content&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;home&quot;&gt;&lt;p&gt;&lt;img src=&quot;/images/logo_github.png&quot; alt=&quot;&quot; title=&quot;로고&quot; style=&quot;float: right; margin-left: 25px&quot; width=&quot;200&quot; /&gt;&lt;/p&gt; &lt;h2 id=&quot;iam&quot;&gt;I’m…&lt;/h2&gt; &lt;p&gt;평범한 한의사 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;돌아온범생&lt;/code&gt;의 우아한 엔지니어 도전기를 기록합니다.&lt;br /&gt; &lt;br /&gt; 조재성 Jaeseong Cho | &lt;br /&gt; Doctor of Korean Medicine, Currently studying SW engineering and biostatistics&lt;br /&gt; &lt;a href=&quot;/about&quot;&gt;more…&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;posts&quot;&gt;Posts&lt;/h3&gt; . . index.html 부활시키기 + md는 삭제 . . . layout: home search_exclude: true image: images/logo_github.png &lt;main class=&quot;page-content&quot; aria-label=&quot;Content&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;home&quot;&gt;&lt;p&gt;&lt;img src=&quot;/images/logo_github.png&quot; alt=&quot;&quot; title=&quot;로고&quot; style=&quot;float: right; margin-left: 25px&quot; width=&quot;200&quot; /&gt;&lt;/p&gt; &lt;h2 id=&quot;iam&quot;&gt;I’m…&lt;/h2&gt; &lt;p&gt;평범한 한의사 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;돌아온범생&lt;/code&gt;의 우아한 엔지니어 도전기를 기록합니다.&lt;br /&gt; &lt;br /&gt; 조재성 Jaeseong Cho | &lt;br /&gt; Doctor of Korean Medicine, Currently studying SW engineering and biostatistics&lt;br /&gt; &lt;a href=&quot;/about&quot;&gt;more…&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;posts&quot;&gt;Posts&lt;/h2&gt; .",
            "url": "blog.chojaeseong.com/fastpages/2022/02/13/fastpages_%EB%A9%94%EC%9D%B8%ED%99%94%EB%A9%B4%EB%B0%94%EA%BE%B8%EA%B8%B0.html",
            "relUrl": "/fastpages/2022/02/13/fastpages_%EB%A9%94%EC%9D%B8%ED%99%94%EB%A9%B4%EB%B0%94%EA%BE%B8%EA%B8%B0.html",
            "date": " • Feb 13, 2022"
        }
        
    
  
    
        ,"post33": {
            "title": "TDD 1 문자열계산기",
            "content": "TDD . red -&gt; green -&gt; refactoring . 실패하는 코드(red)부터 짠다. . 테스트코드부터 짠다. | 프로덕션 코드를 생성하지 않은 체로 작성하면서 생성한다. | given(data), when(actual), then(assert문)의 순서로 짠다. | 최초 에러를 내기 위해 throw new IllegalStateException();를 활용한다. | | green을 만들 때는, 모든case 통과 풀 구현이 아니라, (현재까지의 테스트를 모두 만족시키는) 최소한의 최소한의 수정만 한다. . 예를 들어 expected 1을 만족시키는 코드를 짤 때 . return Integer.parseInt(&quot;1&quot;);이 아닌 return 1;으로 짜야한다. | . | 임의의 1개 case가 아닌 다양한 expected를 만족시켜야할 경우, assert문을 여러개 짜지말고, @Test메서드를 늘려서 2번째부터는 일반화시키는 풀구현을 하자. . @Test void splitAndSum_숫자하나() { final int actual = StringCalculator.splitAndSum(&quot;1&quot;); assertThat(actual).isEqualTo(1); //assertThat(actual).isEqualTo(2); } // assert문 추가가 아니라 테스트를 추가한다. @Test void splitAndSum_숫자하나_2() { final int actual = StringCalculator.splitAndSum(&quot;2&quot;); assertThat(actual).isEqualTo(2); //에러를 고치려면 어쩔 수 없이 2번째부터는 일반화된 풀 구현 } . | . | refactoring은 . 메서드 추출 시, 새롭게 추출된 메서드의 관점에서 인자를 수정할 수 도 있다. . 대상: indent를 늘리는 반복문을 포함한 부분 or 다른 일을 하는 곳 . 참고: method refactoring | . | 인자에 final을 달아서 엄청 긴 코드의 끝에서도 안심하고 사용할 수 있게 해보자. 요즘 언어들은 불변을 default로 한다고 한다. . | 매개변수의 이름도 바뀌어야한다 splitValues -&gt; values . //private static int sum(String[] splitValues) { private static int sum(String[] values) { int result = 0; for (String value : values) { result += Integer.parseInt(value); } return result; . | . | . | 복잡한 요구사항 -&gt; 쪼갠 학습테스트 활용 . 예를 들어, 문자열을 커스텀 문자열로 split -&gt; sum 을 구해야하는데, 일단 split부터 되도록 학습테스트를 작성한다. . 요구사항 . @Test void splitAndSum_custom_구분자() { final int actual = StringCalculator.splitAndSum(&quot;//; n1;2;3&quot;); assertThat(actual).isEqualTo(6); } . | 단계별 학습테스트 추가 1 . 쪼갰을 때 나와야하는 값을 expected로 생각하고 테스트하면 된다. | . @Test void split() { // given final String text = &quot;//; n1;2;3&quot;; // split해보고 -&gt; **내 기준에서 나와야하는 값(**이게 나와야한다**)을 &lt;expected&gt;자리에 넣고 테스트해본다.** // when String[] splitValues = text.split(&quot; n&quot;); assertThat(splitValues[0]).isEqualTo(&quot;//;&quot;); // 앞부분에서 나와야하는 값이 통과했다면, -&gt; 뒷부분도 테스트 코드를 추가해서 돌려본다. assertThat(splitValues[1]).isEqualTo(&quot;1;2;3&quot;); } . | 단계별 학습테스트 추가2 . 잘 쪼개졌어도, 구분자가 기존 코드와는 다른 경우이므로, if 검사 후 -&gt; ealry return 로직을 추가해야하는 상황이다. 특정 경우를 잘 골라내는지 boolean이 expected로 되는 학습테스트를 추가하자. | . | . @Test void startsWith() { //given // data -&gt; &quot;//&quot;로 시작하는지를 확인하는 학습테스트를 만든다. final String text = &quot;//; n1;2;3&quot;; //when // actual -&gt; 슬래쉬 2개로 시작하는 커스텀이냐? boolean isCustom = text.startsWith(&quot;//&quot;); //then // expected -&gt; 나와야하는 값 = true assertThat(isCustom).isTrue(); } . | 학습테스트 통과한 코드를 —&gt; 프로덕션 코드에 반영하자 . | . | . 일부분 수정(private함수or 코드) TDD -&gt; 영향받지 않게 복붙메서드 활용 . [private ] 특정함수 수정 TDD -&gt; Test에 [특정함수]만 복붙 . 요구사항: 음수 -&gt; 예외발생시키세요. -&gt; split한 리팩토링으로 splitAndSum 중 private sum()함수만 TDD해야한다. . Test클래스로 private함수를 복붙해온다. . 복붙을 한 순간, 기존 코드에 영향주지 않는 코드가 된다. | XXX.sum() -&gt; XXXTest.sum()으로 사용해서 테스트할 예정이다. | . | 전체 메서드(splitAndSum)중 일부분(sum())만 가져왔으므로 테스트 호출 메소드도 달라질 것이다. . 기존 전체메서드 테스트 가정 (나중에 완성될 테스트) . @Test void splitAndSum_negative() { assertThatThrownBy(() -&gt; StringCalculator.splitAndSum(&quot;-1,2,3&quot;)) .isInstanceOf(RuntimeException.class); } . | 일부분(전체에 비해 인자 달라짐) 메서드 테스트 ( Test로 복사해온 private함수라 XXXXTest.sum() ) . void sum_negative() { // sum(&quot;-1,2,3&quot;); // sum(&quot;-1,2,3&quot;.split()) // StringCalculatorTest.sum(&quot;-1,2,3&quot;.split(&quot;,&quot;)); assertThatThrownBy(() -&gt; StringCalculatorTest.sum(&quot;-1,2,3&quot;.split(&quot;,&quot;))) .isInstanceOf(RuntimeException.class); } . | Test코드로 복붙해온 일부분 메서드( 이놈을 수정해서 구현후 반영할 예정 ) . private static int sum(String[] values) throws RuntimeException { int result = 0; for (String value : values) { result += Integer.parseInt(value); } return result; } . | . | 예외처리 로직을 중간에 추가 by 변수 추출 . 좌항 = 우항 으로 우항이 할당되기 전 &lt;if 예외처리&gt;로직 추가를 위해서 변수 추출(Ctrl+Alt+V)을 활용한다. . result += Integer.parseInt(value); //우항이 넘어가기 전에 받아준다. int number = Integer.parseInt(value); result += number; int number = Integer.parseInt(value); // 우항이 넘어가기전에 받아 예외처리를 해준다. if (number &lt; 0) { throw new RuntimeException(); } result += number; . | . | 테스트통과시 복붙한 sum()메서드를 -&gt; 원본에 반영 + 원본 테스트함수 돌려보기 . 끝난 코드는 날리는게 맞다. | . | | . [public ] 특정[코드] TDD -&gt; 바로 밑에 [코드포함 222메서드 함수] 복붙 . 예를 들어, 어느정도 완성된 public splitAndSum() 메서드에서 text==null이외에 text.isEmpty() 검사를 추가하고 싶다. 하지만, 이미 다른 코드들과 섞여있는 일부분의 코드이므로 다른 코드에 영향주지 않게 테스트하려고 한다. . 코드를 포함한 메서드 복사 붙혀넣기를 통해 기존 코드 영향 받지 않는 메소드2를 새롭게 생성해서 테스트한다. . // 기존 메소드 public static int splitAndSum(final String text) { if (text == null) { return 0; } return sum(split(text)); } // if 조건에 .isEmpty()를 추가할 예정인데 -&gt; sum(split(text)))가 섞여있으므로 // 코드 수정시 영향이 갈 수 있다. // -&gt; 포함 메서드를 통째로 복붙한 메서드2로 테스트한다. // 대신 테스트할 메서드2 public static int splitAndSum2(final String text) { if (text == null || text.isEmpty()) { return 0; } return sum(split(text)); } . | 메서드2로 테스트하는 테스트메서드를 생성한다. . 기존 null테스트에서 인자 + expected(나와야할 값) + 복붙한 메서드2()로 이름 바꾸기 | . //splitAndSum2 를 테스트 @Test void splitAndSum_emtpy() { final int actual = StringCalculator.splitAndSum2(&quot;&quot;); assertThat(actual).isEqualTo(0); } . | 테스트가 완료되면 수정된 일부 코드만 기존함수에 반영하고, 222메서드랑 테스트는 날린다. . if (text == null || text.isEmpty()) . | . | . 그외 . assertThat()을 여러게 사용하지마라 -&gt; 테스트를 그만큼 만들다보면 일반화 혹온 @ParameterizedTest활용 | . | 테스트메서드는 영어로 대충 짓고 -&gt; @DisplayName()으로 한글을 제대로 적어주자. | private함수를 Test에 복붙해서 테스트하는 것외에 접근제어자를 지워 default로 만들어서 테스트할 수 도 있다. | 메서드명은 snake_Case를 써도 된다. | . 상수화 네이밍 . 검증시 if ~ thr로직 -&gt; checkXXXX . | index들 -&gt; CASE_CASE2_INDEX / 구분자 -&gt; CASE_CASE2_DELIMITER . if (text.startsWith(&quot;//&quot;)){ String[] splitValues = text.split(&quot; n&quot;); String delimiter = splitValues[0].substring(2); String customText = splitValues[1]; return customText.split(delimiter); } if (text.startsWith(CUSTOM_PREFIX)){ String[] splitValues = text.split(CUSTOM_DELIMITER); String delimiter = splitValues[CUSTOM_DELIMITER_INDEX].substring(CUSTOM_PREFIX.length()); String customText = splitValues[CUSTOM_TEXT_INDEX]; return customText.split(delimiter); } . | 특정문자열 다음에 나오는 문자열 추출 -&gt; substring( 특정문자열.length() ) . 예를 들어, “//;”에서 ;를 추출하고 싶다면? | ”//;”.substring( “//”.length()) text.substring( CUSTOM_DELIMITER_PREFIX.length() ) | . | . | assert문을 여러개하지말고, 테스트를 추가하다보면, 일반화할 수 밖에 없다. . | . 강타입 vs 약타입 . 강타입 : 자료형이 맞지 않을 시에 에러 발생, 암묵적 변환을 지원하지 않음 | 약타입 : 자료형이 맞지 않을 시에 암묵적으로 타입을 변환하는 언어 | . 정적타입 vs 동적타입 . 정적타입 언어 : 정적타입 언어는 컴파일 시에 변수의 타입이 결정되는 언어를 의미한다. | 동적타입 언어 : 동적타입 언어는 런타임 시 자료형이 결정되는 언어를 의미한다. | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/12/TDD-%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%84%EC%82%B0%EA%B8%B0_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/12/TDD-%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%84%EC%82%B0%EA%B8%B0_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Feb 12, 2022"
        }
        
    
  
    
        ,"post34": {
            "title": "전략,팩토리,싱글톤,hasNext,isEmpty",
            "content": "전략패턴 for 대체를 [테스트에서 상수]로 . 전략패턴은 전략을 사용자가 선택해서 상황에 맞는 행동을 하게 할때 주로 사용 필요시 다른 환율적용한 계산 반영 | 해쉬값 생성시 알고리즘을 다르게 적용 | 다른 적용 전략으로서 [랜덤값 포함 조건문] -&gt; [()- &gt; true] 테스트에 적용 여기서는 랜덤값을 -&gt; 테스트용 상수로 적용하기 위해서, 랜덤값 포함 조건문에 전략패턴을 건다 | . | 예시 코드 블로그(노션) | . | . 바뀔 수 있는 부분을 잡아서 상태에 맞게 메소드로 추출해놓는다. . 해당메소드는 인터페이스 impl 구상클래스로 갈 것이다. . public void move() { if( Util.generateRandomNumber() &gt;= 4 ){ this.position++; } } . public void move() { if(isMovable()){ this.position++; } } private boolean isMovable() { return Util.generateRandomNumber() &gt;= 4; } . | . | 인터페이스 XXXXStrategy + 이름만 가진 추상메서드를 만든다. . 랜덤한 조건문이 -&gt; 테스트용으로 대체될 예정이라면 -&gt; boolean등 반환형 + 추출한 메서드를 추상메서드로 이름만 정의한다 | . public interface MoveConditionStrategy { boolean isMovable(); } . | 특정Strategy의 이름을 정해서 impl구상클래스를 추출메소드를 복붙해서 구현한다. . public class RandomMoveConditionStrategy implements MoveConditionStrategy{ @Override public boolean isMovable() { return false; } } . public class RandomMoveConditionStrategy implements MoveConditionStrategy{ @Override public boolean isMovable() { return Util.generateRandomNumber() &gt;= 4; } } . | 특정전략의 메소드가 사용된 곳마다 —&gt; 다른전략을 허용하는 추상화된 인터페이스 객체를 인자로 받은 뒤 -&gt; 추상체.추출메소드()호출로 수정한다. . public void move() { if(isMovable()){ this.position++; } } . public void move(MoveConditionStrategy moveConditionStrategy) { if(moveConditionStrategy.isMovable()){ this.position++; } } . | 이제 에러난 부분을 타고가면서, 내부 매개변수 정의에 사용된 추상 인자를 호출하는 외부 인자 자리에 new 특정전략()를 넣워준다. . 여기서는 매 car마다 랜덤 전략이 각각 적용되어야하는 부분 -&gt; 특정전략을 인자로 넣어준다. | . public void move() { this.cars.forEach(car -&gt; car.move()); } . public void move() { this.cars.forEach(car -&gt; car.move(new RandomMoveConditionStrategy())); } . | 테스트에서 다른전략으로 조건부의 상수인 람다함수로 () -&gt; true를 대입하여 움직임을 확인한다. . 랜덤이 섞인 기능은 테스트하기 힘들다 -&gt; 전략자리로 바꿔서 항상 같은 값인 상수를 들어가게해서 다른 기능을 테스트한다. | . @Test void 자동차_움직임() { Car js = Car.of(&quot;js&quot;); // +1 움직임의 조건부를 &lt;다른전략 사용가능한 전략패턴&gt;으로 정의했으니 -&gt; 특정전략을 넘겨 결정한다. RandomMoveConditionStrategy randomMoveConditionStrategy = new RandomMoveConditionStrategy(); js.move(randomMoveConditionStrategy); js.move(randomMoveConditionStrategy); js.move(randomMoveConditionStrategy); js.printPosition(); // 전략자리-랜덤조건부 대신&gt; [다른전략으로서 람다함수 상수로서 true]로 줘버릴 수 있다. // -&gt; 테스트용으로 항상 움직임을 확인할 수 있다. Car jk = Car.of(&quot;jk&quot;); jk.move( () -&gt; true); jk.move( () -&gt; true); jk.move( () -&gt; true); jk.printPosition(); } js의 위치: 0 jk의 위치: 3 . | 정적 팩토리 메소드 네이밍 컨벤션 . from: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메소드 ex) Date d = Date.from(instant); | Of: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메소드 ex) Set faceCards = EnumSet.of(JACK, QUEEN, KING); | valueOf: from과 of의 더 자세한 버전 ex) BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);; | instance 혹은 getInstance: 매게변수를 받는다면 매게변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다. ex) StackWalker luke = StackWalker,getInstance(options); | create 혹은 newInstance: instance 혹은 getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장한다. . | 참고: 생성자내부에서만 this.필드 = 할당이 가능함. 팩토리 메서드는 변환or검증만 | . 싱글톤 패턴(관리자Machine, InputView스캐너) . //1. class내부에 default생성자로 static finale 객체를 미리 생성해놓는다 -&gt; for getInstance시 반환할 수 있게 미리 생성 private static final $CLASS_NAME$ $VALUE_NAME$ = new $CLASS_NAME$(); //2. 차후 입력시, 싱글톤이 받아서 [관리하는 데이터]를 쌓아둔다. //private Cars cars; //3. 싱글톤 private생성자는 미리 생성해야해서 매개변수 없이 default생성자로 만든다. private $CLASS_NAME$() { } //4. 관리자로서 [관리 데이터]를 매 구동시 초기화 할 수 있게 한다. public void init() { // this.cars = new ArrayList&lt;&gt;(); } //5. 싱글톤은 언제든지 부르면 나갈 수 있게 public static getInstance()메소드르 ㄹ정의한다. public static $CLASS_NAME$ getInstance() { return $VALUE_NAME$; } . //1. class 내부에 default? 생성자로 미리 static final 객체 생성 private static final Scanner scanner = new Scanner(System.in); //2. 싱글톤scanner(getInstance) + .nextLine() &gt; getInput()으로 싱글톤 + 메서드까지 사용 public static String getInput() { return scanner.nextLine(); } . 값객체.hasNext()패턴 . if 남은수 0보다 큰지 물어본다 0보다 크면 1빠진 값객체로 재할당받고 | true를 return해서 바깥 반복문이 계속 돌아가게 한다. | . | 남은수가 0보다 같거나 작으면 false를 return해서 바깥 반복문에 진입을 막는다. | . | public boolean hasNextGame() { if (this.gameCount.moreThanZero()){ this.gameCount = this.gameCount.next(); return true; } return false; } //... public boolean hasNextGame() { return count &gt; 0; } public Count next() { return new Count(this.count - 1); } . isEmpty &lt; isBlank . isEmpy: &quot;&quot;의 빈값 | isBlank: &quot;&quot;를 포함하여 &quot; &quot;까지 다 True되는 넓은 범위 | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/11/%EC%A0%84%EB%9E%B5,-%ED%8C%A9%ED%86%A0%EB%A6%AC,-%EC%8B%B1%EA%B8%80%ED%86%A4,-hasNext,isEmpty.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/11/%EC%A0%84%EB%9E%B5,-%ED%8C%A9%ED%86%A0%EB%A6%AC,-%EC%8B%B1%EA%B8%80%ED%86%A4,-hasNext,isEmpty.html",
            "date": " • Feb 11, 2022"
        }
        
    
  
    
        ,"post35": {
            "title": "DTO와 VO를 비교",
            "content": "DTO vs VO . 참고 사이트 테크톡1 | 테크톡2(인비) | 포모 블로그 | . | . 혼용 사례 . 특정 책 1판에 의해서 사람들이 잘못 인지하게 됨. 지금은 데이터 전달은 TO + Data -&gt; DTO로만 사용 | VO = 값 표현용 | . | . DTO(Data Transfer Object) . DTO는 프로세스 간에 데이터를 전달하는 객체 | 주로 비동기 처리를 해야할 때 사용 | 로직을 갖고 있지 않은 순수한 데이터 전달객체라 setter(보내는쪽)/getter(받는쪽)로만 구성되는데, DB에서 값을 받아오므로 setter가 없이. 생성자에서 값할당한 이후 끝. . | 정확히는 계층간 데이터 전달 객체 Controller(웹)와 Service(서비스)사이에 데이터 전달용으로 사용된다. | . | . 예시를 통한 DTO 학습(CrewDto) . . service layer에서 데이터를 보낼 때 (받는 쪽에서 사용하라고 정의만) . createXXX()메서드를 통해 DTO생성 + Dto에 정의한 setter()로 데이터 박아로 데이터전달`을 수행한다. | . | controllerlayer(웹 레이어)에서 데이터를 받을 땐 . **service에 정의해둔 createXXX()메서드를 통해 -&gt; ** 데이터박힌 DTO 생성 | DTO.getter로 데이터들 받기 | . | . | setter를 제거하고 생성자로만 데이터를 받아 생성된 불변의 DTO주도록 수정 . setter를 삭제한다 -&gt; VO처럼 불변객체가 됨 -&gt; 데이터 전달과정 시 불변성 보장 -&gt; 안정적 | . . | . Entity와 분리 . . View는 요구사항에 의해 자주 변경되는 부분이다. entity기준으로 테이블 생성/ 스키마변경하는 class -&gt; 요청/응닶값 전달 클래스로 사용하지 말 것 view변경시마다 entity도 매번 변경해야함. | 관련된 수많은 비지니스 로직(class)들이 영향을 끼치게 됨. | . | view변경에 따라 -&gt; 다른 class에 영향을 끼치지 않는 DTO class를 요청/응답값에 사용 join한 결과값 조회 -&gt; entity로는 다 표현X | . | . | . 예시(로또, Car 정의) . 예시 - 로또 . | 예시 - Car . class CarDTO { private String name; private int position; } . 생성이후 OutputView로 가공된 DTO 객체를 보내줄 수 있습니다. | . | . 특징 . 데이터 접근 메서드만 가진다. | 정렬과 직렬화 메서드는 가질 수 있다. | 데이터 캡슐화 -&gt; 유연하게 대응된다. 데이터 요청수 감소 효과 | . | VO(Value Object) . 값 객체 | VO의 핵심은 equals()와 hashcode()를 오버라이딩하하여 내부에 선언된 속성(필드)의 모든 값들이 같으면 &gt; 똑같은 객체라고 판단하게 한다 | 원시 값을 감싼다 -&gt; validation이 가장 큰 역할 중 하나 my) 식별자로 접근해야 데이터 변화에 대응한다 | . | . 예시를 통한 VO 학습(Money) . 고유번호 = 내부 값이 같으면 -&gt; 같은 객체 . | Money class . . VO는 값 자체 표현 = DTO처럼 불변 객체 DTO처럼, setter성격의 메소드 X 생성자로서만 초기화 | VO는 DTO와 달리 getter이외에 로직을 포함 ex&gt; getHalfValue | . | . | 일반적인 객체 -&gt; equals비교와 hashCode비교가 불일치로 나온다. . . | 완전한 VO를 위하여 . hashCode()의 return값 비교 -&gt; 같으면 equals()로 한번더 비교 . | 완전한 VO == 객체를 속성값으로만 비교하게 하기 위해 -&gt; 2개 메소드 오버라이딩 . 속성값인 value로만 비교할 수 있게 된다. | . . | . | . 예시(Car) . Car - 움직임이 있다면( 내부 속성이 변함) -&gt; new 새로운 객체로 반환하여 -&gt; 원래 자기가 가지던 값은 변하지 않고 -&gt; 변한 것은 다른 값 객체로 취급 . 내부속성 변화가 없다면 (움직이지않았다면) -&gt; 자기자신 반환 return this; | . public Car move(int randomNum) { if (randomNum &gt;= MOVE_POINT) { return new Car(this.name, position+1) } return this; } . | . 특징 . 값 자체로 의미를 가진다. . | 변하지 않는 값을 가진다 . 불변 보장(변하면 새객체)해서 안전성과 생산성 | . | 객체 비교시 ID를 사용하지 않음 . | 같은 객체로는 속성들의 값을 비교한다. . | DTO와 VO공통점과 차이점 . DTO: 레이어간 데이터 전달을 위함 객체 동등비교시, 속성값 같다고 같은 객체 아니다. | setter를 넣어준다면 가변, 보통 불변 | getter/setter외 로직X | . | VO: 값 자체 표현 객체 동등비교시, 속성값 같으면 같은 객체 by 오버라이딩 | setter없이 생성자로 초기화하는 불변 | getter/setter외 로직을 가질 수 있다. | . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/11/DTO-vs-VO(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/11/DTO-vs-VO(%EC%99%84).html",
            "date": " • Feb 11, 2022"
        }
        
    
  
    
        ,"post36": {
            "title": "method refactoring",
            "content": "메소드관련 리팩토링 . . . 01 메서드 추출로 [for indent] 제거 . . indent는 메서드 분리로 해결한다. . . | . 02 early return으로 [else] 제거 . else 제거 by early return . . | . . 03 메서드 분리 -&gt; [일을 1가지씩 순차적으로] . 1가지 일만하도록 메서드 분리 convert(문자열[]-&gt; 숫자[] ) + 누적합sum | . | . . . 보기 좋음 »&gt; 약간의 성능저하 | . 04 로컬변수 제거 -&gt; [ line 줄이기] . . . 05 compose method 패턴 -&gt; [조건문 보기 좋게] . 조건문에 적용: https://wooyaggo.tistory.com/34 | 심화: https://mygumi.tistory.com/343 | . . 조건문을 의도를 가진 메서드로 바꾼다 -&gt; 파라미터의 type이나 조건이 바뀔 때 사용된 조건문을 일괄해서 바꿀 수 있다. | . . 읽기좋게 레벨 맞추기 . . | 비교 . . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/10/method_refactoring(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/10/method_refactoring(%EC%99%84).html",
            "date": " • Feb 10, 2022"
        }
        
    
  
    
        ,"post37": {
            "title": "assertj 및 @annotation 모음",
            "content": "학습 테스트 with Junit5 . 학습테스트: 모듈 사용법 읽히기 -&gt; 다른사람이 만든 코드(api)를 검증 = 학습 테스트 | 단위테스트: 내가 짠 코드를 검증하기 위해 만드는 테스트 단위테스트부터 모든 코드를 설계하는 -&gt; TDD | . | . StringTest . dependency . build.gradle에 assertj추가 -&gt; depenecies run or 우측에 gradle &gt; Reload All Gradle Project . testImplementation &#39;org.assertj:assertj-core:3.22.0&#39; . assertThat()메서드 사용안될 시 . import static org.assertj.core.api.Assertions.*; . | . | assertThat . given(data) -&gt; when(actual값) -&gt; then(expected넣어서 비교) 나눠서 코드를 짠다. . 배열 Test: .contains( ) or .containsExactly() + 콤마로 개별원소 입력 | . @Test void 숫자2개_분리() { //given String data = &quot;1,2&quot;; //when String[] actual = data.split(&quot;,&quot;); //then // assertThat(actual).contains(&quot;1&quot;, &quot;2&quot;); assertThat(actual).containsExactly(&quot;1&quot;, &quot;2&quot;); } @Test void 숫자1개_분리() { //given String data = &quot;1&quot;; //when String[] actual = data.split(&quot;,&quot;); //then // assertThat(actual).contains(&quot;1&quot;, &quot;2&quot;); assertThat(actual).containsExactly(&quot;1&quot;); } @Test void 괄호제거() { String data = &quot;(1,2)&quot;; String actual = data.substring(1, 4); assertThat(actual).isEqualTo(&quot;1,2&quot;); } . | assertThatThrownBy . 지정한 에러가 나타나야 통과 . 에러 내는 테스트는 assertThatThrownBy( () -&gt; {} ).isinstanceof();에다가 예외이름.class를 인자로 줘서 해당 예외일때 통과된다. . **필요하다면, 해당에러 + 에러메세지까지 확인하기 위해 .hasMessageContaining( &quot;메세지&quot; );까지 체이닝한다. ** | . //원하는 에러을 안줬더니... 테스트 통과 못한다. @Test @DisplayName(&quot;문자열 인덱스 에러 테스트1&quot;) void 문자열_인덱스_테스트() { assertThatThrownBy(() -&gt; { &quot;abc&quot;.charAt(4); }).isInstanceOf(IllegalArgumentException.class); } // java.lang.AssertionError: // Expecting actual throwable to be an instance of: // java.lang.IllegalArgumentException // but was: // java.lang.StringIndexOutOfBoundsException: String index out of range: 4 @Test @DisplayName(&quot;문자열 인덱스 에러 테스트2&quot;) void 문자열_인덱스_테스트2() { assertThatThrownBy(() -&gt; { &quot;abc&quot;.charAt(4); }).isInstanceOf(StringIndexOutOfBoundsException.class); } . | assertThatThrownBy + hasMessageContaining . 해당 에러 + 해당 메세지까지 내어야 통과 . 도메인 생성자에 포함된 로직에서 메세지까지 같이 검사하자 | . @DisplayName(&quot;로또 번호가 유효하지 않는 경우 예외를 발생시킨다.&quot;) @ParameterizedTest @ValueSource(strings = {&quot;0&quot;, &quot;46&quot;, &quot;-1&quot;}) void input_lottoNumber_invalid(final String number) { assertThatThrownBy(() -&gt; new LottoNumber(number)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;로또 번호가 유효한 범위&quot;); } . | . 자동차경주 . assertDoesNotThrow . assertThatThrownBy와 달리 에러가 안나야 통과 . @ParameterizedTest @ValueSource(strings = {&quot;o&quot;, &quot;brown&quot;}) @DisplayName(&quot;1이상 5이하의 자동차 이름의 길이 확인&quot;) public void car_name_length_of_positive_name(String name) { assertDoesNotThrow(() -&gt; new Car(name)); } . | . assertThat().isNotNull(); . inputView에서 하는 null or Empty검사시 할 것 같다. | . final Car car = new Car(&quot;재성&quot;); assertThat(car).isNotNull(); . assertThat( service ).extracting(“내부 인스턴스 변수”) . service 내부에 존재하는 일급or객체List를 toDto로 가져오는 반면, VO나 단일 값 변수는 직접 가져와 객체-예상객체 / 값-예상값으로 비교할 수 있다. | . @Test void get_round() { racingService = new RacingService(carNames, 5); //when, then assertThat(racingService).extracting(&quot;round&quot;).isEqualTo(new Round(5)); } . 범위검사 . 값 1개: 랜던뽑기를 여러번 @RepeatedTest(100) + assertThat().isBetween(a,b) 랜덤응답의 범위 검사 . //사용할 객체 만들고 RandomNumberGenerator randomNumberGenerator; @BeforeEach void setUp() { randomNumberGenerator = new RandomNumberGenerator(); } //응답값의 범위 확인을 여러번 @RepeatedTest(100) void range_test() { assertThat(randomNumberGenerator.generate()).isBetween(0, 9); } . 랜덤값 List 원소들 : 매번범위 검사 : listIterator()를 만든 뒤, while( .hasNext() )동안 next()하면서, 체이닝으로 .크거나같(최소값 객체) .작거나같(최대값 객체) . @Test void Random_숫자범위_검사() { // 원래는 랜덤으로 차있는 list -&gt; iterator final ListIterator&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 44, 45).listIterator(); // 랜덤값들을 돌면서 검사 while (numbers.hasNext()) { assertThat(numbers.next()) .isGreaterThanOrEqualTo(1) .isLessThanOrEqualTo(20); } } . SetTest . @BeforeEach . 매번 초기화해야하는 변수는 Test안에서의 class &lt;빈&gt; 변수 + @BeforeEach로 정의한 setUp메소드에서 초기화 + 데이터삽입해준다. . public class SetTest { // [빈 변수] -&gt; 매 TEST마다 초기화+데이터 삽입을 반복해준다. private HashSet&lt;Integer&gt; numbers; @BeforeEach void setUp() { numbers = new HashSet&lt;&gt;(); numbers.add(1); numbers.add(1); numbers.add(2); numbers.add(3); } @Test void 사이즈_확인() { //given, when int size = numbers.size(); //then assertThat(size).isEqualTo(3); } } . | @ParameterizeedTest . @ValueSource . @ParameterizedTest로 중복해서 테스트할 필요없이, given으로 들어갈 메소드인자 or given + expected로 들어갈 메소드 인자들을 지정해서 여러 케이스를 테스트한다. . @ValueSource(ints = {1,2,3,4}) . 한가지 값만 뿌려줄 때 | . @ParameterizedTest @ValueSource(ints = {1,2,3,4}) public void set_contains(int number) { assertThat(numbers.contains(number)).isTrue(); } . | . @CsvSource . @CsvSource(value = {“1:true”, “2:true”, “3:true”, “4:false”}, delimiter = ‘:’) . 여러가지 값 -&gt; 여러개의 인자로 뿌려 줄 때 | delimiter 옵션을 안쓰려면, 그냥 ,콤마로 데이터들을 구분해주면 된다. @CsvSource({“1:,rue”, “2,true”, “3,true”, “4,false”}) | . | . @ParameterizedTest @CsvSource(value = {&quot;1:true&quot;, &quot;2:true&quot;, &quot;3:true&quot;, &quot;4:false&quot;}, delimiter = &#39;:&#39;) void set_contains2(int number, boolean expected) { assertEquals(numbers.contains(number), expected); } . | . @NullAndEmptySource . 테스트 메서드의 인자에다가 @어노테이션으로는 null을 넘길 수 없다. . @NullAndEmptySource를 달아주면, 인자에 1,2번째로 null과 emtpy가 전달된다. | 추가로 @ValueSouce를 주면 3번째 인자로 넘어간다. &quot;이 름&quot;를 주게 되면 blank까지 테스트가 된다. | . | . @ParameterizedTest @NullAndEmptySource @ValueSource(strings = {&quot;이 름&quot;}) void nullAndEmpty_or_blank(String name) { System.out.println(name); assertThatThrownBy(() -&gt; new Car(name)) .isInstanceOf(IllegalArgumentException.class); } . | . 그외 Assertj 메소드 모음 . isEqualTo(obj) obj 와 같다 . isNotEqualTo(obj) | obj 와 다르다 | . isEqualToIgnoringCase(str) | str 와 같다 (대소문자 무시) | . contains(str) | str 를 포함한다 | . containsIgnoringCase(str) | str 를 포함한다 (대소문자 무시) | . doesNotContain(str) | str 를 포함하지 않는다 | . startsWith(str) | str 로 시작한다 | . doesNotStartWith(str) | str 로 시작하지 않는다 | . endsWith(str) | str 로 끝난다 | . doesNotEndWith(str) | str 로 끝나지 않는다 | . matches(regex) | regex 정규식과 같다 | . doesNotMatch(regex) | regex 정규식과 같지 않다 | . isLowerCase(str) | str 은 소문자로 이루어져 있다 | . isUpperCase(str) | str 은 대문자로 이루어져 있다 | . isZero(n) | n 은 0 이다 | . isNotZero(n) | n 은 0 이 아니다 | . isOne(n) | n 은 1 이다 | . isPositive(n) | n 은 양수 이다 | . isNegative(n) | n 은 음수 이다 | . isNotPositive(n) | n 은 양수 또는 0 이다 | . isBetween(start, end) | start 와 end 사이의 값 이다 | . isStrictlyBetween(start, end) | start 와 end 사이의 값이 아니다 | . isCloseTo(n, within 또는 offset) | 주어진 within 또는 offset 에 가까운 값이다. | . isNotCloseTo(n, byLessThan 또는 offset) | 주어진 within 또는 offset 에 가까운 값이 아니다 | . isCloseTo(n, withinPercentage) | 주어진 백분율 내에서 주어진 숫자에 가깝다 | . isNotCloseTo(n, withinPercentage) | 주어진 백분율 내에서 주어진 숫자에 가깝지 않다 | . isTrue() | 참이다 | . isFalse() | 거짓이다 | . isNull() | null 값 이다 | . isNotNull() | null 값 아니다 | . isBlank() | 빈 값 이다 (공백 미포함) | . isNotBlank() | 빈 값 아니다 (공백 미포함) | . isEmpty() | 빈 값 이다 (공백 포함) | . isNotEmpty() | 빈 값 아니다 (공백 미포함) | . isNullOrEmpty() | null 값 이거나 빈 값 이다 (공백 포함) | . isLessThan(str) | str 보다 낮은 문자열 이다 (Ascii 코드) | . isIn(…obj) | 여러개의 obj 중 1개와 같다 | . isNotIn(…obj) | 여러개의 obj 와 모두 다르다 | . filteredOn(…) | list 필터 | . extracting(…) | list 프로퍼티 값 | . assertj string 예제 . assertThat(&quot;Hello, world! Nice to meet you.&quot;) // 주어진 &quot;Hello, world! Nice to meet you.&quot;라는 문자열은 .isNotEmpty() // 비어있지 않고 .contains(&quot;Nice&quot;) // &quot;Nice&quot;를 포함하고 .contains(&quot;world&quot;) // &quot;world&quot;도 포함하고 .doesNotContain(&quot;ZZZ&quot;) // &quot;ZZZ&quot;는 포함하지 않으며 .startsWith(&quot;Hell&quot;) // &quot;Hell&quot;로 시작하고 .endsWith(&quot;u.&quot;) // &quot;u.&quot;로 끝나며 .isEqualTo(&quot;Hello, world! Nice to meet you.&quot;); // &quot;Hello, world! Nice to meet you.&quot;과 일치합니다. . assertj number 예제 . assertThat(3.14d) // 주어진 3.14라는 숫자는 .isPositive() // 양수이고 .isGreaterThan(3) // 3보다 크며 .isLessThan(4) // 4보다 작습니다 .isEqualTo(3, offset(1d)) // 오프셋 1 기준으로 3과 같고 .isEqualTo(3.1, offset(0.1d)) // 오프셋 0.1 기준으로 3.1과 같으며 .isEqualTo(3.14); // 오프셋 없이는 3.14와 같습니다 .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%ED%85%8C%EC%8A%A4%ED%8A%B8/assertj/tdd/2022/02/10/assertj-%EB%B0%8F-annotation-%EB%AA%A8%EC%9D%8C.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%ED%85%8C%EC%8A%A4%ED%8A%B8/assertj/tdd/2022/02/10/assertj-%EB%B0%8F-annotation-%EB%AA%A8%EC%9D%8C.html",
            "date": " • Feb 10, 2022"
        }
        
    
  
    
        ,"post38": {
            "title": "코드리뷰 방법 1단계 및 피드백",
            "content": "개별 셋팅 . 관리자 짝 매칭 실시 . 관리자 매칭 실시 . | 피매칭자은 확인함. . | . 원본레포에 각 github_id br 생성 . lecture클릭후 미션시작 클릭시 -&gt; 자동으로 내 github_id로 —&gt; 미션repo에 브랜치생성 | 미션시작으로 내 브랜치를 생성하면, 리뷰어도 자동 배정된다. ) 동시성 잇슈가 있을 땐, 관리자가 리뷰어를 재배정한다. | . | 저장소로 와서 내 github_id로 생성된 branch가 정상 생성되었는지 미션repo에 branch 검색해서 확인한다 . . | 원본레포 각 fork . 강의홈페이지를 통해 branch가 생성되었으나 팀원X push권한 X -&gt; fork를 먼저 한다. 문서를 보면서 스텝바이스텝으로 한다. | 여기선 1단계까지만 한다. 코드리뷰 요청 1단계: 미션 진행 후 github에 올리는 단계 | 코드리뷰 요청 2단계: 코드리뷰 요청을 보내고, 피드백을 받은 후 피드백 반영 및 merge하는 단계 | 코드리뷰 요청 3단계: 다음 단계 미션을 위해 준비하는 단계 | . | 이렇게 권한은 없지만 [강의홈페이지를 통한 원본repo에 이름만 내 github_id branch]가 생성된 상태로 -&gt; fork한다. fork가 내 계정으로 잘되어있어야한다 | . | fork를 해도 기존 원본repo의 모든 branch들이 다 fork되어있다. 기본 main으로 되어있다. | . | github_id single-branch만 clone . fork는 모든 branch그대로 보유 —&gt; clone을 통해서 로컬로 가져올 때는 --single-branch만 가져오는 것이 가능하다. . 현업에서는 10개이내 branch이므로 git clone -b [branch명] --single-branch [fork한 레포명]가 필요가 없다 . | 내 이름의 branch가 main브랜치다. | . git clone -b {본인_아이디} --single-branch https://github.com/{본인_아이디}/{저장소 아이디} ex) git clone -b javajigi --single-branch https://github.com/javajigi/java-baseball.git . git clone -b is2js --single-branch https://github.com/is2js/java-racingcar.git intellij 터미널에서 작업하면 된다. | . | . PS C: Users cho_desktop IdeaProjects missions&gt; git clone -b is2js --single-branch https://github.com/is2js/java- racingcar.git . | ​ - . intellij에서 clone한 폴더를 open한다 내 이름의 싱글브랜치만 가져와지는지 확인한다. | . | step1 br(작업 br) 생성 . git checkout -b step1으로 첫번째 리뷰용 브랜치를 만든다. . –single-branch clone 한 입장에서 , 내 id_branch -&gt; main브랜치 | 작업할 branch -&gt; step1 -&gt; ... . | cf) **git alias는 집착해서 알아야한다.-&gt; ** . gco main = git command . | gba = git branch -a . # windows git alias git config --global alias.co checkout git config --global alias.ci commit git config --global alias.st status git config --global alias.br branch git config --global alias.hist &quot;log --pretty=format:&#39;%h %ad | %s%d [%an]&#39; --graph --date=short&quot; git config --global alias.type &#39;cat-file -t&#39; git config --global alias.dump &#39;cat-file -p&#39; # shell git alias alias gs=&#39;git status &#39; alias ga=&#39;git add &#39; alias gb=&#39;git branch &#39; alias gc=&#39;git commit&#39; alias gd=&#39;git diff&#39; alias gco=&#39;git checkout &#39; alias gk=&#39;gitk --all&amp;&#39; alias gx=&#39;gitx --all&#39; alias got=&#39;git &#39; alias get=&#39;git &#39; . | . | . . | 협업 시작 (A와 B) . 일단 github_id가 local에의 user.name과 동일한지 확인한다. . git config user.name . | . . 작업레포(local, A) 정하기 . 페어와 CodeWithMe등으로 작업할 local 레포 정하기 . 나의 경우, 네트워크 잇슈로 화면공유 + B를 colaborator 등록하여 B가 local에 step1만 --single-branch clone후 서로 push &amp;&amp; pull 해서 작성함. . git clone -b step1 --single-branch [git주소] [폴더명 or .] . | . | 작업을 완료한 뒤 push까지 끝낸다. . | . A fork레포(remote 2) -&gt; B local레포 . 협업해서 push된 [A 원격레포-step1]를 2번째 remote repo로 등록한다. . 1번째는 fork한 나(B)의 원격레포 . | 2번째는 fork한 A의 원격레포 . git remote add pair&lt;원격레포별칭&gt; &lt;Repo URL for pairs fork&gt; git remote -v . origin: 원격 저장소를 가리키는 일반적인 별칭 | pair: 내가 정한 추가 원격 레포의 별칭 | . | . | A 원격레포(remote pair)의 step1(협업했던br)의 내용만 fetch해온다. . A pair repo -&gt; B local repo 우리는 pull을 해버렸다. pull할때마다 merge로 표기되니 조심. | . | git fetch : 다른 사람의 branch의 내용을 가져와 확인한 뒤 (나중에) merge 하고 싶을때 fetch를 사용 | 아직 merge는 하지 않았기 때문에 인텔리제이에 가져온 코드들이 보이진 않을 것이다. | . git fetch pair step1 . 안되면 git fetch pair/step1 | . | fetch로 내역들을 확인했으면 merge한다. . git merge pair step1 . 안되면 git merge pair/step1 | . | A fork레포(remote2) -&gt; B fork레포(remote1) . 정보를 줄 pair(remote2)의 협업br(step1)로 HEAD 이동시켜놓기 . git checkout pair&lt;원격레포별칭&gt;/step1&lt;협업br&gt; . | 정보를 받을 origin(remote1)의 협업br(step1)으로 push하기 . A pair repo -&gt; B remote repo remote —&gt; remote로 commit내역을 넘기나보다. | fetch -&gt; merge로 local에 가져왔다면, 원격에서 원격으로 한번더 가져오나보다. | . | . git push --force origin step1 . | 사실… B local -&gt; B fork로 가는게 맞다? . 동기 크루 중 1분의 블로그 git remote add pair url | git fetch pair step1 | git merge pair step1 | git push origin step1 | . | . 코드리뷰 요청 . 페어 끊기 . 우테코 홈피 -&gt; 나의팀 -&gt; 피드백을 누르면 페어가 끊어진다. 페어가 끊어져야 리뷰요청이 활성화된다?! | . | forkRepo -&gt; 원본Repo PR (리뷰요청) . 내 fork 원격레포 의 step1 br로 이동한 뒤, 원본(미션)repo로 PR를 누른다. PR을 통한 코드리뷰는 fork레포- 작업br(step1)에서 PR을 걸어 -&gt; 원본레포의 나와관련된 br(is2js)에 요청하는 것 | fork레포의 관련br(is2js)가 아닌 것에 주의하자. | . | PR 받는 곳 원본레포: base repository - is2js(관련 br) | PR 보내는 곳 fork레포: head repository - step1(작업br) branch를 잘 선택해야한다. | . | . | PR메세지까지 다 작성해서 제출한다. | 홈피-&gt;slack에 리뷰요청 알림 . 우측 상단에 리뷰요청 . | slack으로 메세지 전달 . . | slack-&gt;피드백 알림 -&gt; 로컬수정 -&gt; PUSH로 피드백반영 -&gt; 홈피 리뷰요청2 . 슬랙으로 피드백 반영해달라고 알림이 온다 날렸던 PR에 그대로 코드리뷰가 반영되어있다. | . | local에서 step1 br로 수정한다. | local step1 -&gt; remote step1 PUSH 하는 순간 피드백 반영되므로 조심하자. 추가 PR은 필요 없다. | . | push로 피드백 반영이 끝났으면 우테코 학습 홈피 -&gt; 우측상단 리뷰요청 -&gt; 리뷰요청 -&gt; slack메세지 | 리뷰어가 피드백을 보고 merge해줄 것이다. 그럼 다음 단계로 진행하면 된다. |",
            "url": "blog.chojaeseong.com/git/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%ED%98%91%EC%97%85/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/09/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-1%EB%8B%A8%EA%B3%84-%EB%B0%8F-%ED%94%BC%EB%93%9C%EB%B0%B1(%EC%99%84).html",
            "relUrl": "/git/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%ED%98%91%EC%97%85/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/09/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-1%EB%8B%A8%EA%B3%84-%EB%B0%8F-%ED%94%BC%EB%93%9C%EB%B0%B1(%EC%99%84).html",
            "date": " • Feb 9, 2022"
        }
        
    
  
    
        ,"post39": {
            "title": "fastpages font & tag page change",
            "content": "font 바꾸기 . 참고: 한국 블로그 | . _includes폴더 &gt; head.html파일에서 웹 폰트 link태그 추가해주기 . &lt;!-- 폰트추가를 위한 link태그 삽입 --&gt; &lt;!-- 폰트1: 기본 spoqa 웹폰트 --&gt; &lt;!-- css에서 * {} 다 뒤집어씀. --&gt; &lt;link href=&#39;//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSansNeo.css&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&gt; &lt;!-- 폰트2: 블로그 제목들 sunflower 웹폰트 --&gt; &lt;!-- 쥬피터 등 포스트 내부 글자 h1, h2 제목은 sunflower체 도입 --&gt; &lt;link href=&quot;//fonts.googleapis.com/css?family=Sunflower:300,500,700&quot; rel=&quot;stylesheet&quot;&gt; . | 해당 폰트를 사용하기 위해 assets폴더 &gt; css폴더 &gt; styles.css를 수정한다 나의 경우, scss수정시 잘 안됬다. 모든 것을 여기서 설정해줬다. | font-family 검색해서 모두 font-family: &#39;Spoqa Han Sans Neo&#39;, normal;로 바꿔주기 | 전역으로 다 먹이기 + 제목들은 다른 글자체로 먹이기 /* 제목들은 먹히는데, 제목만쓰질 않으니.. */ /* test-&gt; 전체를 font-familty 덮어쓰기 */ *{ font-family:&#39;Spoqa Han Sans Neo&#39;, normal!important; } /* font2 제목 글자는 선플라워 */ h1, h2, h3, h4, h5, h6, tag-name { font-family:&quot;Sunflower&quot;, normal!important; color: #152447; } . | . | a태그 리셋시켜서 색 적용되게 하기 /** Links */ /** 폰트 색 (링크 색) -&gt; 이것만 바꾼다고 변경안됨.. */ /* 모든 a태그 프로퍼티들을 리셋 */ a { all: unset; } /* a태그의 가상클래스도 같이 리셋 */ a:link { text-decoration: none; color: #152447; } a:visited { text-decoration: none; color: #152447; } /* 누른상태 */ a:active { text-decoration: none; color: #152447; } /* 갖다덴 상태 */ a:hover { text-decoration: none; color: #152447; } a { color: #152447; text-decoration: none; } a:visited { color: #152447; } a:hover { color: #313266; text-decoration: underline; } . | 마크다운 강조색을 빨간색 글자로 변경 pre, code { font-family: &#39;Spoqa Han Sans Neo&#39;, &quot;Menlo&quot;, &quot;Inconsolata&quot;, &quot;Consolas&quot;, &quot;Roboto Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; font-size: 0.9375em; border: 1px solid #f9f2f4; border-radius: 3px; background-color: #f9f2f4; color:#E53A40;} . | tags.html 수정하기 . 예전 블로그의 css를 가져와 적용할 준비를 한다. style.css /** 예전 블로그에서 쓰던 tag모음 + 각 개별tag적용 css */ .entry-meta { font-size: 12px; font-size: 0.75rem; text-transform: uppercase; color: #152447; } .entry-meta a { color: #152447; } .entry-meta .vcard:before { content: &quot; by &quot;; } .entry-meta .tag { display: inline-block; margin: 4px; color: #fff; border-radius: 3px; background-color: rgba(162, 162, 162, 0.8); } /*my) 상단 태그들 모음 tag1 shap(#) */ .entry-meta .tag span { float: left; padding: 6px 6px; color: #152447; font-family: inherit; /* background-color: #ffffff; */ } /*my) 상단 태그들의 tag2 name(태그명) 색*/ .entry-meta .tag .tag-name { color: #ffffff; background-color: #152447; border-radius: 0 3px 3px 0; /*3px 이상 오그리면, 하이퍼링크랑 막 난리남.*/ } .entry-meta .tag:hover { background-color: rgba(136, 136, 136, 0.8); } .entry-meta .entry-reading-time { float: right; } .inline-list { list-style: none; margin-left: 0; padding-left: 0; } .inline-list li { list-style-type: none; display: inline; } /* 추가) 각 제목들도 tag 작은모양처럼*/ .eachtag { color: #ffffff; background-color: #152447; border-radius: 0 3px 3px 0; } . | tags.html코드를 수정한다. ul태그에 entry-meta inline-list 속성을 추가한다 | 그외 tag, tag-name, eachtag 등의 속성을 이용해서 꾸민다. | . &lt;ul class=&quot;entry-meta inline-list&quot;&gt; &lt;/ul&gt; . |",
            "url": "blog.chojaeseong.com/fastpages/2022/02/09/fastpages-font-&-tags-page-change.html",
            "relUrl": "/fastpages/2022/02/09/fastpages-font-&-tags-page-change.html",
            "date": " • Feb 9, 2022"
        }
        
    
  
    
        ,"post40": {
            "title": "fastpages post preview setting",
            "content": "fast pages 메인에서 preview image 보이게 하기 . 참고: 이미지를 표기하는 fastpages | . _config.yml에서 show_image: false -&gt; true로 변경 . | 미리캔버스를 검색해서 템플릿으로 생성할 이미지 만들기 참고 블로그 | 생성 목록 algo.png | blog.png | config.png | data.png | default.png | git.png | java.png | python.png | sql.png | wootech.png | . | . | 최상단 images폴더 &gt; posts폴더에 이미지들 넣어두기 . | post마다 image: &quot;images/posts/blog.png&quot;형식으로 preview 이미지 설정하기 메인 위쪽은 index.html | 메인 아래쪽 포스트 담당은 home.html이다 | . _config.yml에서 show.image: true일 경우 post_list.html(글만) -&gt; post_list_image_card.html로 바뀌어서 보인다. | . | . |",
            "url": "blog.chojaeseong.com/fastpages/2022/02/08/fastpages-post-preview-setting.html",
            "relUrl": "/fastpages/2022/02/08/fastpages-post-preview-setting.html",
            "date": " • Feb 8, 2022"
        }
        
    
  
    
        ,"post41": {
            "title": "TDD 기본 싸이클 작성",
            "content": "TDD 싸이클 . TDD 구현 싸이클 fail떨어지는 test코드 생성 case별로 메서드_이름을 표기하여 작성한다. | . | main(프로덕션)코드 작성 후 pass 2번째부터는 개별 pass -&gt; 전체pass 순으로 확인 | . | refactoring(rename부터 시작) | | . | . test에서 package &gt; XXXTest class를 먼저 만든다. . . generate(alt+insert)기능으로 @test로 생성 . | 메서드_명은 한글명으로 해도 되고, 단위테스트가 의미하는 바만 잘 나타내면된다. 여기선 여러 경우 중 1가지(구분자 없는) 경우로 시작을 한다. . | . . | 클래스명 + 메소드명을 먼저 사용하여 할당을 반환형 actual변수로 받은 뒤 given(값 -&gt; 변수 선언 등) -&gt; when(actual까지 로직) -&gt; then( asesertThat(actual).isEqualTo(expected)) . // given String data = &quot;(1,2)&quot;; // when String result = data.substring(1, data.length()-1); // then assertThat(result).isEqualTo(&quot;1,2&quot;); . | . | assertThat( actual ).isEqualTo( )에서 인자에 예상값(우리가 원하는 값)을 넣는다. . | SC 없는 클래스를 만들 되, 미리 main쪽에 package를 만들어 놓은 상태에서 -&gt; 생성경로를 main으로 바꿔준다. . test &gt; package &gt; XXXTest class | 내부 XXX클래스.메서드() —&gt; main &gt; package &gt; XXX class로 생성 | test에만 존재하는 package를 선택하면, main에 못만드니 미리 만들어놔야한다. | . | **클래스 생성 직후 바로 돌아와(Back기능 ctrl+u) method도 만들어준다 ** . 이 때, actual(1)을 반환하지 않는 불완전한 메소드를 수정없이 test실행부터해서 Error를 낸다 . . | . | test코드(SCTest)가 pass하도록 프로덕션코드(main코드, SC)를 수정한다. . . | pass한 프로덕션 메소드를 refactoring한다. . 파라미터 이름 바꾸는 것도 F2 = refactoring | @test 막 사용했던 class이름(XXX) 바꾸는 것도 F2 = refactoring 이 때, test class이름 XXXTest도 바꾸자고 권유한다. | . | . | 더이상 refactoring할게 없다면 -&gt; 새로운 단위테스트를 클래스.메소드()부터 만들어서 나아간다. . 직전에 만든 테코랑 비슷하다면, 복붙해서 시작한다. . | 테케는 가능한 가장 작은 단위를 만드는 경우며, 케이스 -&gt; if 상황별 새로운 메소드로 나누고 -&gt; 상황에 맞게 인자 변경 -&gt; expected . 구분자 없음 -&gt; “1” -&gt; 1 | 컴마 구분자 -&gt; “1,2” -&gt; 3 | . . | . | 다음 테케도 프로덕션 코드 수정없이 일단 돌려서 fail을 떨어뜨린 뒤-&gt; 에러보고 참고하여 찾아가서 수정 . | 해당 테케실행 -&gt; 전체 테케도 실행해서 전체 통과하는지 확인을 한다. . | pass후엔 refactoring하기 . for문으로 들어가는 indent -&gt; 메소드 추출 refactoring . return문까지 잡아서 추출해보기(alt+ctrl+m -&gt; 안되면 ctrl+.) . . | . | . | input/output이 명확한 쉬운 TDD였다. . 자동차 경주를 하려면, 너무 힘들 것 | 단위테스트만 만들어서 해볼 것 | fail하는 test생성 -&gt; 프로덕션수정으로 pass -&gt; refactoring | . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/08/TDD%EC%8B%B8%EC%9D%B4%ED%81%B4(%EB%8D%A7%EC%85%88%EA%B3%84%EC%82%B0%EA%B8%B0)(%EC%99%842).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/08/TDD%EC%8B%B8%EC%9D%B4%ED%81%B4(%EB%8D%A7%EC%85%88%EA%B3%84%EC%82%B0%EA%B8%B0)(%EC%99%842).html",
            "date": " • Feb 8, 2022"
        }
        
    
  
    
        ,"post42": {
            "title": "우테코 프리코스 3주간 요구사항들",
            "content": "요구사항 체크리스트 모음 . 1주차 . 자바의 버전이 8버전인가 | 자바 코드 컨벤션을 지키는가 | Randoms의 pickNumberInRange()를 사용했는가 (3주차) pickNumberInList()를 사용했는가 | . | Console의 readLine()을 사용했는가 | 3항 연산자를 쓰지 않는가 | indent depth가 2이하인가 | 하나의 함수가 한 가지 일만 하도록 하였는가 | (추가) 하드코딩 하진 않았는가 | (추가) style check 및 convention 적용 하였는가 | gradlew.bat clean test의 모든 테스트가 통과하는가 | 과제 제출시 우테코 플랫폼에서도 제출하였는가 | . 2주차(피드백 및 과제에서 추가) . 함수(또는 메소드)의 길이가 15라인을 넘어가지 않도록 구현한다. | else 예약어를 쓰지 않는다 . | 기능 목록을 업데이트하고 재검토 한다 | Class 구현순서( 상수-&gt;멤버 변수-&gt;생성자-&gt;메서드) 지키기 | . 3주차 . 기능 목록에 예외상황도 기록한다. | 일급컬랙션 및 단일변수도 포장한다. | 변수를 줄이려고 노력한다. | . 주차별 미션 수행 키포인트 정리 . 1주차 과제 수행시 키포인트 . 개발 시작전에 요구사항 충분히 파악하기 | 기본 프로젝트 구조 및 뼈대 코드 작성하고 시작하기 | 라이브러리 확인 및 컨벤션 포맷터 적용, 버전 확인 등 기본적인 협업환경 확인하기 | Application에 개발하지 않고 각 class에서 개발하여 구동하기 | scanner 등 input, outview은 static으로 작성해서 재활용하기 | 문자열type의 숫자입력시 검증 여러가지 해보기(길이-&gt; 포맷-&gt; 범위-&gt; 중복여부 등 기타) | else 안쓰고, 반복문안에 if는 method로 빼서 method내에서 하여 indent줄이기 | 무한반복시 조건변수를 결과로 업데이트 하면 됬으나, 재시작 등 추가분기가 필요한 경우, status변수 추가 도입하기 | 상수도 반복되니 따로 class로 빼기 | 중복확인은 list길이로 하는 데, stream으로 편하게 하기 list 중복확인 : list.stream().distinct().count() | 입력받은 문자열배열 -&gt; 정수 list변환 : Arrays.stream(). mapToint(Integer::parseInt).boxed().collect(Collectors.toList()); | . | . 2주차 과제 수행시 키포인트 . Live template을 활용함. 1주차와 반복되는 input코드 등을 미리 작성해둠. | . | fork한 repo를 clone후에 branch부터 바꾸자! 실수로 main브랜치에 commit and push하여 새로 작성하는 경우가 발생했었음. | . | 일급컬렉션 사용하여 객체List에 대한 검증 및 관련 로직을 모음. 쪼개어지는 Input을 받을 때 ex&gt; Names -&gt; Name 미리 names에서 검증을 다 해버리는 전략을 세움 | 쪼개어놓고 내부에서 검증할 시, 다시 입력받으러 가기가 쉽지가 않음. | . | 조건절에서 getter쓰지말고, 객체.부등호를메서드화() 시켜 메세지보낼 것. 비교시 필요한 값은 메서드의 파라미터로 | 입력 받은 int 변수를 포장한 래핑클래스를 만들고 countdown 메서드 구현해보기 | 학습했던 stream위주로 코드 짜보기 max( Comparator)를 쓰더라도 1번에 max값을 충족시키는 여러개의 객체를 구하기는 쉽지 않음. | mapToInt( ) 집계값 구한 뒤 -&gt; 일치하는 객체 List(우승자들) 구하는 방식 | 간단한 출력문은 toString()오버라이딩 해서 쉽게 출력되도록 이용 하기 | | 상수들 및 에러 메세지들의 리팩토링 IDE를 이용하면 정말 간단하게 해결할 수 있음을 깨닫게 됨. | . | . 3주차 과제 수행시 키포인트 . 객체의 각 필드에도 wrapping class를 적용함 원시변수 및 if문의 최소화 -&gt; 래핑변수 및 stream의 활용 | . | 정규식 패턴검사에 stream을 활용함 | List대신 Map 자료구조 래핑하여 DB처럼 사용함 상품 정보등은 List를 포장한 일급컬렉션으로 만들어놓고 정보조회시 사용함 | . | 싱글톤 객체를 활용하여 전체 로직을 운영함 controller 반복문의 조건변수도 싱글톤객체에 메세지를 보내니 상태에 따른 값을 얻어와서 구현하기 수월했음 | . | 자판기 작동 로직에 대해 고민하여 기능 구현 목록을 작성함 | .",
            "url": "blog.chojaeseong.com/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/2021/12/15/%EC%9A%B0%ED%85%8C%EC%BD%94%EA%B0%80_%EB%82%98%ED%95%9C%ED%85%8C_%EC%A4%80_%EC%84%A0%EB%AC%BC.html",
            "relUrl": "/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/2021/12/15/%EC%9A%B0%ED%85%8C%EC%BD%94%EA%B0%80_%EB%82%98%ED%95%9C%ED%85%8C_%EC%A4%80_%EC%84%A0%EB%AC%BC.html",
            "date": " • Dec 15, 2021"
        }
        
    
  
    
        ,"post43": {
            "title": "intelliJ 세팅(vscode keymap + 협업 세팅)",
            "content": "vscode keymap 관련 플러그인 설치 . 설정 &gt; Plugin &gt; vscode kemap검색 후 설치 | key Promoter X 설치 (해당 기능의 단축키를 우측하단에 띄워줌) | | . vscode keymap 기준 단축키 정리 . shift 2번 : 전체 검색(유지) vscode F1 | . | keymap 들어가서 move to opposite group검색후 ctrl+shift+ 오른화살표지정하기 ctrl + 이후 넘기기..왼쪽넘기기 기능 자체는 없나보다. | alt+shift+0으로 세로로 넘기기 가능 | . | alt+shift+F : reformat code -&gt; 한파일내 패키지 or 폴더 선택후 alft+shift+F | . | keymap 들어가서 back검색후 ctrl+u지정하기 . | ctrl + .으로 메인메소드 내용을 extract method 메소드 분리 및 패키지명 작성하고 폴더이동시키기 | . | 신세계) alt+insert로 생성자, getter 등 오버라이딩 . | **신세계) 메서드사용을 위한 객체 만들 때(인스턴스화) 할 때, ** new 클래스명(); 기입후 ctrl+.으로 local변수 자동(선택후)생성하자. | 객체.메서드();기입후 ctrl+.으로 메서드결과값 받는 변수 자동(선택후)생성 | . | keymap -&gt; extend line selection -&gt; ctrl+L을 추가해서 사용하기 라인 선택하기 shift+alt+아래화살표로 복사할때,, 라인 선택해서해야.. 꼬임없을 듯 | . | . | shift+ alt+ F10: 실행할 class파일 선택해서 실행 ctrl+alt+F10은 바로 실행. | . | shift + alt + x: 현재 파일들 다 close . | shift + alt + a : 긴글 주석? . | alt + ~ : git관련 명령어들 목록나옴 . | ctrl+F11 or ctrl+shift+{key}로 북마크 지정 -&gt; ctrl+해당번호로 이동 | keymap -&gt; show bookmaks검색후 -&gt; CTRL+SHIFT + F11 으로 지정함 | . | ctrl+f3 : 같은단어 이동가능한 검색한 상태로 만들기 == ctrl+f f3 : 같은 단어 다음으로 이동 | shift+f3 : 같은단어 이전 단어로 이동 | . | shift+F5 : 실행중인 작업 종료 ctrl+F5 : 실행 | shift+ alt + f10 : main함수 골라서 실행 | . | alt+7: 현재파일 Structure(메소드 등) 한눈에 보기 유틸메서드로 빼기, 상수 옮기기 : f6으로 편하게 | . | 리팩토링 alt+ctrl+c : 값을 상수로 등록해버리기 | alt+ctrl+m : 코드를 메서드화 시키기 2번 눌르면 창으로 하는 듯 | . | alt+ctrl+v: new 클래스()까지 입력후 참조변수 바로 생성 | . | 축약어 iter | fori 추가 | itar | ifn | inn | . | F8: 오류바로 찾아가기 | ctrl+f -&gt; F3 or shift + F3 : 검색항목 순서대로 찾아가기 | . 프리코스를 위한 java8 협업 세팅 요약본 . clone후 branch부터 생성후 바꾸기 . git checkout -b is2js . git CRLF -&gt; LF로 바꾸기 설정하기 . git config --global core.autocrlf true . utf 8 설정 . utf8, lf설정 되어있나 확인하기 . editor &gt; File Encodings &gt; 체크 3가지 모두 utf-8 shift 2번연속 클릭 (search everywhere) . vm검색 Edit Custom VM option 클릭 맨 마지막 줄에 -Dfile.encoding=UTF-8 추가 | . | . | . | . | . | build.gradle 설정 추가 . compileJava.options.encoding = &#39;UTF-8&#39; // UTF-8 설정 compileTestJava.options.encoding = &#39;UTF-8&#39; . | . code style 3가지 / Checkstyle / saveActions . code style에서 . scheme지정 | n으로 선택해주기 | detect하도록도 체크함.. | java탭으로 내려가서 &gt; scheme 지정확인 checkstyle에 안걸리게 됨. | . | | Tools &gt; CheckStyle . 8.24이상 버전 (default) . | scope를 All sources(테스트포함, 나는 테스ㅡㅌ제외)로 변경 . | 파일 선택(일부코드 삭제하여 수정한)하여 추가 -&gt; +로 추가 . . | 해당 스타일체크후 alt +shift + k혹은 하단 체크스타일에서 추가한 naver style선택하여두기 . | | 다 풀고 **맽밑 Other settings &gt; Save Actions &gt; 3가지 체크 ** . . | . java8로 통일하기 . 설정&gt; Build&gt; Build Tools &gt; Gradle &gt; intelliJ IDEA + Gradle JVM 1.8로 바꾸기 exception 및 디버깅용으로 gradle 변경하는 것 | . | 설정&gt; Build&gt; Build Tools &gt; Compiler &gt; Java Compiler &gt; javac의 1.8 바꾸기 | 프로젝트구조(c +s + a + s) &gt;Project &gt; Project SDK 및 language level 1.8, 8 선택 | 프로젝트구조(c +s + a + s) &gt; Modules &gt; 랭귀지레벨에서 8버전 맞나 확인하기 | 프로젝트구조(c +s + a + s) &gt; SDKs에서 1.8버전 확인하기 | window intellij에서 gradle clean, test 해보기 . . shift 2번 or f1 -&gt; gradle task선택 gradle clean 수행 | gradle test 수행 코드 다짜고나서 | | |",
            "url": "blog.chojaeseong.com/java/configuration/2021/12/14/java_intellij_keymap.html",
            "relUrl": "/java/configuration/2021/12/14/java_intellij_keymap.html",
            "date": " • Dec 14, 2021"
        }
        
    
  
    
        ,"post44": {
            "title": "코딩테스트용 라이브러리 정리",
            "content": "참고 벨로그 | justkode | . | . 표준라이브러리 6가지 . 내장함수 . sum, min, max, eval, sorted(key=, reverse=) . result = eval(&quot;(3 + 5) * 7&quot;) print(result) . | . itertools . 반복되는 형태의 데이터를 처리하는 기능을 제공, 순열과 조합 라이브러리르 제공 . permutations(r개의 데이터를 뽑아 나열하는 모든 경우(순열)) . | combinations(r개의 데이터를 뽑아 순서를 고려하지 않고 나열하는 모든 경우(조합)) . | products(r개의 데이터를 뽑아 일렬로 나열하는 모든 경우(순열)를 계산한다. 다만 원소를 중복하여 뽑는다.) . from itertools import product data = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] # 데이터 준비 result = list(product(data, repeat=2)) # 2개를 뽑는 모든 순열 구하기(중복 허용) print(result) # [(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;C&#39;)] . | . heapq . 힙을 활용한 우선순위 큐 기능을 구현할 때 사용되며, O(NlogN)에 오름차순 정렬을 제공한다. PriorityQueue 라이브러리가 따로 있지만, heapq가 더 빠르게 동작한다. . PriorityQueue를 리스트나 힙으로 구현할 수 있지만 리스트는 삽입 O(1) 삭제 O(N) 의 복잡도를 가지지만, | 힙은 삽입 O(logN) 삭제 O(logN) 의 복잡도를 가진다. 그래서 우선순위 큐는 보통 힙으로 구현하고, 시간복잡도도 힙으로 구현한 시간복잡도를 사용한다. | . | . | heapq.heappush() : 원소 삽입 | heapq.heappop() : 원소 꺼내기 | heapq.heapify() | . import heapq def heapsort(iterable): h = [] result = [] # 모든 원소를 차례대로 힙에 삽입 for value in iterable: heapq.heappush(h, value) # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기 for i in range(len(h)): result.append(heapq.heappop(h)) return result result = heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) print(result) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . 히피파이를 이용한 힙정렬 기존에 있는 list 객체로 힙 정렬 만들기 | . | . import heapq h = [3, 9, 1, 4, 2] heapq.heapify(h) # 파라미터로 list 객체를 받는다. for _ in range(6): print(-heapq.heappop(h)) # 작은 값부터 출력된다. . bisect . 이진 탐색을 쉽게 구현할 수 있도록 bisect 라이브러리를 제공함. ‘정렬된 배열’에서 특정한 원소를 찾아야 할 때 매우 효과적이다. O(logN)에 정렬된 배열에 맞는 위치를 찾아준다. | ‘정렬된 리스트’에서 특정 범위에 속하는 원소의 개수를 구하는데 효과적이다. bisect_left(a, x) : 정렬된 순서를 유지하면서 리스트 a에서 데이터 x를 삽입할 가장 왼쪽 인덱스를 찾는 메서드 | bisect_right(a, x) : 정렬된 순서를 유지하면서 리스트 a에서 데이터 x를 삽입할 가장 오른쪽 인덱스를 찾는 메서드 | . | bisect 모듈은 이미 정렬되어 있는 list의 정렬 상태를 유지하기 위해 사용되는 모듈입니다. 이를 이용해서, 기존에 있는 list의 정렬 상태를 유지 할 수 있고, 이를 응용해서 Binary Search 또한 구현할 수 있습니다. | . from bisect import bisect_left, bisect_right a = [1, 2, 4, 4, 8] x = 4 print(bisect_left(a, x)) # 2 print(bisect_right(a, x)) # 4 . 정렬된 리스트’에서 특정 범위(시작과 끝)에 속하는 원소의 개수를 구하는데 효과적이다. . left는 같아도 젤 왼쪽 index(포함), right는 같아도 젤 오른쪽index(미포함, 들어가야하는 자리)를 반환하므로 시작과 끝 index를 알 수 있다. | . from bisect import bisect_left, bisect_right # 값이 [left_value, right_value]인 데이터의 개수를 반환하는 함수 def count_by_range(a, left_value, right_value): right_index = bisect_right(a, right_value) left_index = bissect_left(a, left_value) return right_index - left_index # 리스트 선언 a = [1, 2, 3, 3, 3, 3, 4, 4, 8, 9] # 값이 4인 데이터 개수 출력 print(count_by_range(a, 4, 4)) # 2 # 값이 [-1, 3] 범위에 있는 데이터 개수 출력 print(count_by_range(a, -1, 3)) # 6 . lgN으로 정렬까지 해주는 bisect.insort( )도 있다. . | bisect 모듈은 이미 정렬되어 있는 list의 정렬 상태를 유지하기 위해 사용되는 모듈입니다. 이를 이용해서, 기존에 있는 list의 정렬 상태를 유지 할 수 있고, 이를 응용해서 Binary Search 또한 구현할 수 있습니다. . | . # 1. 삽입 되어야 하는 index 찾기 import bisect arr = [1, 2, 3, 3, 4, 5] print(bisect.bisect_left(arr, 6)) # 6이 들어가야 하는 Index인 6을 반환 print(bisect.bisect_right(arr, 6)) # arr에 6이 없기 때문에 위와 똑같은 값을 반환한다. print(bisect.bisect_left(arr, 3)) # 중복 되는 값 제일 왼쪽, 2를 반환한다. print(bisect.bisect_right(arr, 3)) # 중복 되는 값 제일 오른쪽 + 1, 4를 반환한다. bisect.insort_left(arr, 3) # 중복 되는 값 왼쪽에 삽입 bisect.insort_right(arr, 3) # 중복 되는 값 오른쪽에 삽입 print(arr) . #2. Binary Search 구현 from bisect import bisect_left arr = [1, 2, 3, 3, 4, 5] def bs(arr, x): i = bisect_left(arr, x) # 들어가야 하는 &#39;제일 왼쪽&#39; index 반환 if i != len(arr) and arr[i] == x: # 들어가야 하는 index가 return i # 마지막 index + 1 이라면, arr에 x가 없는 것 else: # arr[i] == x가 아니라면, arr에 x가 없는 것 return -1 a = [1, 2, 4, 4, 8] x = 4 res = bs(a, x) if res == -1: print(x, &quot;는 없습니다!&quot;) else: print(&quot;첫번째&quot;, x, &quot;가 등장한 위치는&quot;, res) . collections . 덱(deque), 카운터(Counter) 등의 유용한 자료구조를 포함하고 있는 라이브러리 . deque . 파이썬에서는 일반적으로 deque를 활용해 큐를 구현한다. | Queue 라이브러리 있지만 일반적인 큐 자료구조를 구현하는 라이브러리는 아니다. | 리스트와 다르게 인덱싱, 슬라이싱 등의 기능은 사용할 수 없다. | 데이터의 시작이나 끝부분에 데이터를 삽입하는데 효과적이다. | . . | Counter 등장 횟수를 세는 기능을 제공한다. iterable 객체가 주어졌을 때, 해당 객체 내부 원소가 몇 번 등장했는지 알려준다. . | . math . 수학적 기능을 제공하는 라이브러리 . 자주 사용되는 수학적인 기능을 포함하고 있는 라이브러리 팩토리얼, 제곱근, 최대공약수(GCD) 등을 계산해주는 기능을 포함 . 종류 math.factorial() : 팩토리얼 | math.sqrt() : 제곱근 | math.gcd() : 최대공약수 | math.pi : 파이 | math.e : 자연상수 | . | . import math print(math.factorial(5)) # 120 print(math.sqrt(7)) # 2.6457513110645907 print(math.gcd(21, 14)) # 7 print(math.pi) # 3.141592653589793 print(math.e) # 2.718281828459045 . . 그외 . map, split, sorted . 주의점 . input말고 . 뭐 어느정도로 더 빠르고 느리냐는, 코딩 테스트 문제푸는 수준에서 다룰만한 내용이 아니므로 넘어가도록 하고, 직관적으로만 느꼈던 것은, input() 으로 코드를 제출할 시, 시간초과가 뜨지만, sys.stdin.readline() 으로 제출할 시 정답이 뜨더라는 것이다. 이와 비슷한 이슈는 이미 이전부터 있었다. | . 한편, 나는 입출력을 지금까지 이런 방식으로 했다. . a = [int(x) for x in input().split()] # a = [1, 2, 3, 4 ,5] . 하지만, 이 방법보다 다음 방법이 더 권장된다. (위와 같은 이유로) . import sys a = list(map(int, sys.stdin.readline().split()))# a = [1, 2, 3, 4, 5] . 재귀풀기 . 이전에 문제풀다가 말한 적이 있는데, 특히 자주접하는 DFS, BFS 문제의 경우 그렇다. . 파이썬의 재귀 허용 깊이의 기본치가 c 보다 약한건지, c 로 짠 DFS, BFS의 경우 문제 없이 돌아가지만, 파이썬으로 돌리면 런타임 오류가 뜨는 경우가 있다. 그래서 다음과 같이 재귀 허용 깊이를 수동으로 늘려주는 코드를, 코드 상단에 적어줘야 한다. . import sys sys.setrecursionlimit(10**8) # 10^8 까지 늘림. . | . Pypy . PyPy 가 뭔지 찾아보니, 쉽게말해 파이썬 보다 몇 배 더 빠른 개선된 파이썬이라고 생각하면 된다. . 좀 더 자세히 말하면, Python3 는 내부적으로는 C로 짜여져있는데 (이 이유 때문에 Python2 보다 빠르다.), 이를 C가 아니라 Python으로 다시 짠 것이다. 당연히 느릴 것 같은데, 의외로 빠르단다. 자세한 내용은 나무위키 참고. . 때문에, 일반적으로 Python3 보다 PyPy로 제출해서 내는게 더 안전한 듯 하다. (빠르다는 의미에서) . 한편, PyPy에서는 sys.setrecursionlimit(10**8) 이 안먹는다. 즉 임의로 재귀 호출 깊이를 설정할 수 없다는 것에 주의해야 한다. . 파이썬으로 문제푸는 게 편한점도 많지만 아직 어색하고, 이런 자잘한 리스크가 많은 듯 하다. 이후 또 뭔가 발견하면 남겨놔야겠다. . | .",
            "url": "blog.chojaeseong.com/algorithm/2021/10/22/python_%EB%AA%A8%EB%93%88%EC%A0%95%EB%A6%AC.html",
            "relUrl": "/algorithm/2021/10/22/python_%EB%AA%A8%EB%93%88%EC%A0%95%EB%A6%AC.html",
            "date": " • Oct 22, 2021"
        }
        
    
  
    
        ,"post45": {
            "title": "협업2)오픈소스PR + 팀원PR + issue로 PR",
            "content": "여러가지 Pull Request 날려보기 . Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . 노팀원 fork PR(팀원-PR받기만/ 타인(나)-Fork후 수정용브랜치로 push하여 타인의 PR) . 앞에서 PR = 팀원1(주인):수정용브랜치 -&gt; 팀원2:collaborator이며 리뷰만 PR(주인-수정용브랜치 / 팀원-리뷰만) 실습 로컬 : git_seminar | 원격 : CS100_Git in is3js . 협동자: is3js | . | . | . | 소샬코딩의 PR . 오픈소스 레포(is3js) : py . 주인 혹은 collaborator임. | . | 기여하고 싶은사람(is2js, 나): py(fork) . 팀원이 아닌 이상 일단 fork한다 | 팀원이 아니더라도 clone후 로컬에서 topic branch를 따서 작업한다. | fork레포(내꺼)에 commit, push한다 | 팀원이 아니지만, fork레포 - topic branch의 변동사항을 push로 PR한다. | . . | . | . 팀원아니더라도 fork-clone-topic따서 작업한 뒤 -&gt; (merge하지않고) commit, push . 나는 오픈소스의 collaborator가 아니므로 오픈소스(py)를 fork한다. . | 작업을 하려면 일단 clone부터해서 local에 가지고 온다. . ❯ git clone https://github.com/is2js/py.git .❯ code . . git 설정을 한번 확인해준다. . ❯ git config --list . remote.origin.url=https://github.com/is2js/py.gitremote.origin.fetch=+refs/heads/*:refs/remotes/origin/*branch.main.remote=originbranch.main.merge=refs/heads/main . | . | fork를 해온 상태는 main브랜치이다. 새로운 topic 브랜치 work를 따서 작업 -&gt; commit -&gt; work를 push까지해보자. . 브랜치 클릭 -&gt; +새 분기 만들기 &gt; work . | main에 merge하는게 아니라 topic branch를 commit -&gt; push해야 팀원아닌데도 PR을 날릴 준비를 할 수 있다. . 명령어로 할 거면 . git push origin [topic branch명] . | . | . | fork한 내 레포라도 topic branch가 merge없이 push되었으면 PR로 인식된다. . 내 개인소스 수정: merge –no-ff -&gt; main commit -&gt; push PR : no merge -&gt; topic commit -&gt; topic push | . | 원본레포인 is3js/py는 미동도 없고, fork한 내 레포 is2js/py에만 PR이 들어온다. | . | topic push로 만든 Fork레포 PR클릭시 원본레포(baserepo) PR을 유도: 전제-main(master)는 변화없이 topicbr만 변화! cf) Fork레포(headrepo)로 merge도 가능함. . 일단 기본적으로 fork한 내 레포(head repo) : is2js/py에서 | 원본 레포(base repo) : is3js/py로 PR를 보내는 것을 기본적으로 수행하려 한다. | fork레포에서 PR버튼 눌렀는데, 이미 원본레포(is3js/py)로 이동되어있다. | . | . . base repo를 수정하면, fork-main &lt;- fork-topic 도 가능한가보다. . | Create pull request해보자. . 원본레포에다가 날리는 것이다. | 원본레포에서 보면 PR이 불들어와있다. | . . | fork레포는 PR에 아무 표시도 안된다. . | 원본레포 팀원은, 팀원X-Fork-topic-PR 날린 것을 commit을 직접 확인하여 request chagnge하거나 approve해준다. . PR 확인후 해당 topic branch의 커밋까지 찾아들어간다. . . | 코멘트를 날릴 땐, +드래그해서 많이 날릴 수 있음. . | 최종적으로는 우측 상단의 review changes &gt; approve까지 해야하지 merge된다. . . | 최종승인하면 원본의 기본branch인 main으로 알아서 merge된다. . | 팀원이 아니더라도 PR(merge)후 delete branch가 원칙: 로컬에서 로컬+fork 2개다 해줌. . 로컬에서 내 fork레포 및 내 로컬레포의 topic branch를 삭제해준다. . main으로 바꾸고, 삭제 | . ❯ git branch -a❯ git checkout main❯ git branch -d work . | . 로컬topic 삭제 -&gt; remote(fork레포)도 자동삭제 반영시키기: git remote update –prune . 로컬에 topic branch가 삭제된 상태에서 git remote update --prune을 사용하여 로컬에 맞춰서 branch삭제 시킨다. . | ❯ git remote update --prune . | 안되서 나는 git push origin :remote_br . git push origin :work . | 참고) origin과 upstream . 레퍼런스: https://pers0n4.io/github-remote-repository-and-upstream/ | . Upstream &amp; Downstream . GitHub에서 repo를 생성하고 나면 다들 origin이라는 용어를 보셨을 겁니다. clone했을 때는 origin이 자동으로 등록돼있고, init했을 때는 git remote add origin ...으로 origin을 직접 등록하라고 안내하죠. 여기서 말하는 origin이 깃허브에 존재하는 repository 즉, remote를 뜻하는 단어입니다. 다만 remote에 origin이라는 이름을 붙인 것뿐이랍니다. . upstream과 downstream은 상대적인 개념이라 origin과 local을 기준으로 생각하면 origin이 upstream, local이 downstream이 됩니다. 그 이유는 push와 pull을 기준으로 생각했을 때 origin으로부터 local로 흐르는 관계가 형성되기 때문입니다. . local에서 origin으로 push한다 | origin에서 local로 pull한다 | . 만약 CLI로 push를 해보셨다면 git push -u origin main3이라는 명령어를 입력했을 텐데, 여기서 -u 옵션이 --set-upstream 옵션의 줄임으로 upstream을 설정한다는 뜻입니다. upstream을 한 번 설정하고 나면 다음부터는 git push 또는 git pull이라고 명령어만 입력해도 자동으로 origin의 main 브랜치로부터 push와 pull을 진행하는 이유가 upstream 옵션을 통해 해당 브랜치에서 upstream과 downstream 관계가 설정됐기 때문이죠. . Fork . GitHub에서 오픈소스 프로젝트에 기여한다거나, 협업을 진행할 때 fork를 이용하게 됩니다. fork는 다른 사람의 repository를 내 소유의 repository로 복사하는 일이죠. 따라서 원래 소유자의 remote repository와 내가 fork한 remote repository 사이에도 upstream과 downstream이라는 관계가 형성된답니다. 그래서 보통 원래 소유자의 remote를 말할 때 upstream, 내가 포크한 remote를 말할 때 origin이라는 용어를 사용하곤 합니다. . 노팀원이지만 [원본repo(오픈소스)] -&gt; fork레포 및 local레포를 최신형으로 유지 by local에서 upstream으로 등록하여 upstream(원본레포) -&gt; origin(fork레포), upstream -&gt; local 통로뚫고 가져오기: git remote add upstream [url] -&gt; git fetch upstream -&gt;[fork레포 ]merge버튼 + [local]git merge upstream/main . 상황 . 갑자기 오픈소스 author가 원본repo -&gt; main을 변경했다면? . 나한테(fork레포, local레포)의 main도 수정된 내용이 들어와야한다. | . . | 기존 local repo에서 -&gt; fork repo를 origin 이라 별칭했음 . local repo에서 -&gt; 원본repo를 upstream으로 별칭 등록 및 원본repo - fork repo를 연결 | . | git fetch: origin to local . git fetch upstream: 원본repo(upstream) to fork repo(origin)으로 업데이트 내용 받아오기 | git merge upstream/main으로 원본repo(upstream) to local repo(local)로 업데이트 내용 받아오기 | . | . | my) 원본repo를 노팀원이 upstream으로 local에서 등록하면 . upstream -&gt; fork | upstream -&gt; local 업데이트가 가능하다. | . | . | 관련 명령어 . . | 참고) upstream 삭제 . 참고 블로그 . git remote -v git remote rm upstream git remote -v . | . | . local에서 원본repo를 upstream으로 등록한다. . ❯ git remote add upstream https://github.com/is3js/py.git . . | git fetch upstream명령어로 upstream의 최신정보를 origin이 받을 수 있도록 업데이트해온다.(아직 받진 X) . ❯ git fetch upstream remote: Enumerating objects: 8, done. remote: Counting objects: 100% (8/8), done. remote: Compressing objects: 100% (3/3), done. remote: Total 5 (delta 2), reused 4 (delta 2), pack-reused 0 Unpacking objects: 100% (5/5), done. From https://github.com/is3js/py * [new branch] main -&gt; upstream/main . origin(fork repo)에 가보면, Fetch해왔다고 뜬다. | . | fork repo에 들어가 git fetch upstream정보를 이용해 최종 merge시킨다. by Fetch upsteam&gt; Fetch and merge 버튼 . | local에서는 git merge upstream/main명령어를 이용해 upstream정보를 가져온다. . 왠지 origin을 pull해서 업데이트 해도될것같긴한데… 따로 upstream -&gt; local로 받는다? | . ❯ git merge upstream/main Updating 476f70b..f7dd8e8 Fast-forward .gitignore | 11 ++++++++++- rb.py | 3 +++ 2 files changed, 13 insertions(+), 1 deletion(-) . 참고) 만약 merge가 conflict나면 . git merge upstream/master --allow-unrelated-histories . | . | 앞으로 계속 . ❯ git fetch upstream # fork repo가서 merge 버튼 # local에서 merge ❯ git merge upstream/main . | 팀작업1: 내부팀원 (not 오픈소스) 초대 및 작업하기 . 내부 소스( not 오픈소스)라고 가정한다. | 관련 명령어 | . 팀리더(is3js)가 팀원(is2js)초대 : github-settings-manage acess-add people(invite collaborator) . 초대받은 사람은 등록 email로만 초대를 받음. push권한이 있다고 한다. = 글쓰기 기능이 있다. | . | . 팀원은 초대되었다면,fork(-&gt; clone -&gt; topic -&gt; PR)할 필요가 없이 clone(-&gt;push)or(-&gt;topic-&gt; review=팀원PR)만 한다. 팀원이라면 바로 local-&gt;팀repo에 바로 push가 가능 . 팀원은 초대되었다면,fork(-&gt; clone -&gt; topic -&gt; PR)할 필요가 없이 clone(-&gt;topic-&gt;push or review=팀원PR) . ❯ mkdir team_py❯ cd team_py❯ git clone https://github.com/is3js/py.git . . | 해당 폴더로 이동후 수정하고 commit -&gt; push까지해보자. . 원래는 topic -&gt; | . code .# main에서 바로 # 파일수정# add commit -&gt;push . | 팀원이라면, 팀repo에 바로 push가 된다. . | 팀작업2: 내부팀원의 clone (local)에서 topic push로 PR권유 -&gt; topic push한 사람만 PR요청 가능 -&gt; 타 팀원review받기 (review안받을거면 main push했음) . . topic push한 작업팀원만, 자신에게 PR권유를 확인 및 요청할 수 있다. . 팀원은 fork필요없이 local clone후 main push해도 되지만, review를 받기 위해 topic push로 PR한다 . user-login topic branch 생성 . git checkout -b user-login . | login.py 생성 후 작업 . | add, commit, (topic branch) push . | | **팀원repo에 들어가도 ** . topic branch를 보낸 사람이 아니면.. PR권유가 안뜬다. . is3js(타팀원) . PR권유는 topic br push한 사람 자신에게만 보인다. | . . branch로는 보여도, PR은 타팀원이 결정안함. | . . | is2js( topic br push한 작업 팀원) . . | . | . | topic br push를 pull request한다. . 메세지에 코드리뷰 부탁한다고 남기자. | . | 타팀원은 PR 불-&gt; commit 메세지-&gt; commit 클릭 -&gt; 코드 리뷰 . author가 아니더라도 모든 팀원들이 확인할 수 있게 ** **PR에 불이 들어와있다. . | Merge를 누르기 전에 메세지에 달려있는 커밋까지 직접들어가서 코드를 살펴보자. . . | code line에서 +를 드래그해서 코드 리뷰를 해준다. . | 거절을 의미하는 코드 리뷰를 해주자. 코드리뷰한 것 바로 밑에 Reply도 달 수 있으니 확인하면된다. | 코드 리뷰를 데면 우측에 Finish your review(1)가 뜬다. 클릭해서 리뷰를 끝내자. | . | 코드 리뷰를 달면, 자동으로 작업 팀원에게 email도 보내준다. | (topic push -&gt;PR했던) 작업 팀원은 확인해서 1) Reply + 2) local에서 추가작업 -&gt; 3) topic br PUSH -&gt; 4) 자동 PR timeline에 추가 . . 거절성 코드리뷰에 대해 대답을 해주고 . | PR 날렸던 topic br로 다시 돌아와서 . 추가 작업을 함. . ❯ git checkout user-login . | . | 다시 한번 topic br push하면, 추가 PR을 안날려도 자동으로 PR 타임라인에 추가된다. . | 타팀원의 2번째 review부터는 [작업팀원의 추가push]가 자동으로 PR timelien에 추가된다. . 타팀원 화면에서는 작업팀원의 추가작업한 커밋 위에 View changes가 떠있다. . 작업팀원이 커밋할 때 . . | 타팀원(리뷰팀원)화면 . | . | 승인은 LGTM(looks good to me) . 코드 리뷰를 다시 한번 남기고 | finish your review에서 approve를 선택해주면 끝난다. 이 때 멘트는 LGMT를 많이 쓴다. | approval이 떴다면, 작업팀원이 merge PR해도 된다. 아무나 팀원이면 다된다. merge후에는 delete (topic) branch -&gt; local code 최신화(git pull) -&gt; local의 topic branch는 직접 삭제() . approve 확인되면 | 작업한 팀원이라도 merge시킬 수 있다. . | 작업이 끝난 topic branch를 삭제하라고 뜬다. 삭제한다. . | 로컬의 main 코드를 최신화하기 위해 main branch로 와서 git pull로 코드 최신화한다. . ❯ git checkout main . | 로컬의 topic branch도 직접 삭제한다. . ❯ git branch -d user-login Deleted branch user-login (was b7bde3a). . | cf) 혹시 delete branch 안해서 서버에 남아있다면? . local branch 수동 삭제 . | remote 동기화로 삭제 . git remote update --prune . | 팀작업3: issue(개선기록) 와 PR(팀원1(주인)-수정용브랜치push PR / 팀원2-리뷰만) 실습 . 로컬 : git_seminar . | 원격 : CS100_Git in is2js . 협동자: is3js | . | . 로컬 readme생성후 -&gt; 원격 빈레포에 push로 시작. 1번째 가이드: …or create a new repository on the command line(init, readme push) . 로컬에서, 빈 레포 생성시 주어지는 가이드1 번째인 …or create a new repository on the command line를 따라치기 . echo &quot;# CS100_Git&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;first commit&quot; git branch -M main git remote add origin https://github.com/is2js/CS100_Git.git git push -u origin main . 아직 git init안한 상태에서 readme.md를 먼저 만들고,, 시작하네 | . | . | 원격레포에 issue생성: issue는 TODO list 역할이나 논의사항 정리용 . 원격레포의 issue 탭 &gt; new issue 클릭 . readme.md 파일을 좀 더 구체적으로 작성해주라고 issue 생성하기 | . | issue 오른쪽 사이드바에 보이는 Assignees를 클릭하여, issue해결자 10명 중 1명으로 나를 등록한다. . . | issue 해결 전에, collaborator 추가 (상대방은 메일로만 초대받음) . settings &gt; manage access &gt; add people . is2js(tingstyle1@gmail.com, 현재) -&gt; (시크릿창) is3js 계정 추가 . . is3js(is2js@naver.com)계정은 깃허브알림 없이 메일로만 초대장이 옴 | . | . | . 로컬에서 생성 후 파일 수정하기: git checkout -b [생성후전환될 브랜치] . 로컬(is2js)에서 feature/readMe 라는 파일 수정용 브랜치를 생성하자 . ❯ git checkout -b feature/readMeSwitched to a new branch &#39;feature/readMe&#39;&gt;glg # git log(HEAD -&gt; feature/readMe, origin/main, main) . branch 변경 후 git log를 확인하니 HEAD가 브랜치를 잘 따라오고 있다. | . | 파일 수정후에는 add전 gitt diff로 어느부분 수정되어있는지 확인 . ❯ git diffdiff --git a/README.md b/README.mdindex 1743ce5..a6cac92 100644 a/README.md+++ b/README.md@@ -1 +1,3 @@ # CS100_Git++This is CS100 No newline at end of file . | add - status - commit 단계를 거친다. . ❯ git add README.md❯ git status . | (PR날릴 브랜치는)순수 git commit후 메세지 작성되는 부분에 [- issue #번호] 삽입하여, 해당issue에 커밋 걸어주기 . git commit만 입력하기 . &gt; git commit . | commit 메세지 작성 에디터에서 - issue #1의 관련된 issue 번호를 기입해주기 . ADD more description in README- issue #1 . . | 나중에 저렇게 삽입한 커밋속 issue #1지정 부분은 PR속에서 issue를 연결해준다. . **즉, issue에 대한 하여 PR(팀원검토)시에는 `#번호`를 커밋메세지에 넣어두자.** . . | . | 원격레포에 없는 지만, push해주면 &lt;알아서생성+PR권유&gt; . 로컬에서 원격레포로 수정용 브랜치를 push . ❯ git push origin feature/readMeCounting objects: 3, done.Writing objects: 100% (3/3), 289 bytes | 289.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)remote: remote: Create a pull request for &#39;feature/readMe&#39; on GitHub by visiting:remote: https://github.com/is2js/CS100_Git/pull/new/feature/readMeremote: To https://github.com/is2js/CS100_Git.git * [new branch] feature/readMe -&gt; feature/readMe . | github에 가보면, . 새로운 브랜치 생성 확인: 로컬에서 수정용브랜치를 push해서 자동으로 생성한 것 . . | 현재는 main우주만 보여주고 있음. 수정한 평행우주는 브랜치를 선택해서 들어가야 보임 . | . | 혼자는merge지만, PR은 를 팀원(collaborator)들에게 확인요청이니 메세지 한번더! . 혼자 작업했다면, . 로컬에서 수정용브랜치 -&gt; main브랜치 merge하면 끝 | . | 여러명 작업시 merge대신 . 로컬에서 수정용 브랜치생성후 파일 수정 . | 원격레포에 push하여 수정용브랜치 생성 . | 합치기전에 PR과정을 전시하여 팀원들에게 확인받기 . | . | . Compare &amp; pull request 클릭 . . | PR은 팀원확인요청이다. 로컬 커밋메세지가 default로 적혀있는데, 커밋메세지에 PR메세지로서 추가로 적어준다. . . | 아래와 같이 커밋메세지 따로에, PR메세지가 덮어서 보인다. . | PR을 검수할 팀원에게 review요청하기(수정용브랜치를 merge해도될지) . PR메세지 우측에 Reviewers가 있다. 여길 선택해서, PR review를 요청하자. | . is3js(팀원)계정을 시크릿창으로 들어가보자. . 레포 &gt; Pull request &gt; 해당PR까지 클릭하고 가야지 Review요청한 것이 보인다. (호버해도 보이긴하네) . . | | . | 리뷰요청받은 뒤 Add your review는 lineByline으로 피드백 주는 것 . add your review 클릭 . | 플러스버튼으로 피드백을 주면되는데 드래그로 여러라인에 대한 피드백을 줄 수 도 있다. . | 리뷰요청시 피드백(라인별코멘트)과 별개로, 칼을 뽑아야함: Approve(merge) or Request changes(다시push해) . 코멘트를 다 남겼으면, 우측 상단에 Finish you review로 칼을 뽑아야한다. . 이 경우 수정이 좀 더 필요하다고 하여 승인거절한다.내용없이 Reqeust changes 클릭 | . | 내가 남긴 코멘트의 위치 및 승인거절=변화요구의 메세지를 확인한다. . | [로컬] review내용인 1) 라인별코멘트에 [대한 대답reply] &amp; 2) 변화요구에 대한 [에서 수정후 다시 push] . 라인별 코멘트에 대한 대답 . | 리뷰어에 의한 Changes requested는 feature/readMe에 푸싱함으로써 커밋을 추가하라고 뜬다. . reviewer에 의한 request changes는 &lt;수정용 브랜치로 추가 커밋하면 다시 검토&gt;를 말하는 것이다. | . 다시 로컬 해당 브랜치로 와서 . | 요구대로 새롭게 작성후 push까지 해준다. . # 파일 수정# add전 git gtatusgit status#git add 파일명git add README.mdgit commitgit loggit push origin feature/readMe . | | PR은 의 단위라서 아직 merge안됬다면, 해당브랜치는 이어지며 가서 확인한다. . git push origin feature/readMe를 통해 push했으면, 아직 해당 PR상황에서 커밋이 추가된다. . main에서는 추가 PR 안내가 없음. 수정용 브랜치에서는 평행우주의 내용은 변화되었음. | . | reviewer에 의해 request changes는 &lt;수정용브랜치로 추가 커밋하면 다시 검토&gt;를 말하는 것이다. 즉, 검토하고 있던 PR상황으로 다시 직접들어가보면, 추가 push를 확인할 수 있게 됨. | . | . . | **의 추가push후**에는 되면 **또다시 review 요청해야한다.** . . | 또다시 PR(수정용브랜치 merge검토)에 대한 review요청을 받음. -&gt; LGTM approve해주기 . 역시 해당 PR까지 클릭해서 들어와야 보인다. . add your review . 라인별 코멘트 -&gt; 생략 | LGTM(Loos Good To me)와 함께 Approve | . . | . | . review가 approve해야 드디어 merge가 뜬다. 동시에 . . . 우측의 Delete branch를 눌러 수정용브랜치를 삭제해주자. . | PR탭은 Merged로 해결됨. . | [issue탭]에서도 Merged가 뜸. -&gt; [PR-&gt;merged]의 해결된 issue를 닫기 . . issue작성 후 . 수정용브랜치 생성 | PR를 위해 커밋 커밋시 issue번호를 #번호형태로 커밋메세지 속에 남기면 issue탭에서도 표기가 된다. | . | . | 수정용브랜치 push -&gt; PR 생성 -&gt; review -&gt; merged로 해결되었으면 issue도 닫아야한다. . 메세지로 닫는다 알리기 . . | Close issue를 눌러서 해당 issue를 닫는다. . | | [로컬]에서 default [main]브랜치로 옮겨와, PR-&gt;merged된 프로젝트 정보를 git pull로 내려받아서, 로컬에서도 통합 및 브랜치삭제가 반영되도록 한다. . 삭제당한 feature/readme&lt;수정용브랜치&gt;가 아닌 default main브랜치로 옮겨와서 git pull받는다. | ❯ git checkout main ❯ git fetch ❯ git pull # git pull origin main 으로 정확하게 표시하면 upstream설정이 안뜬다. # 그러나 한번만 업스트림하면 되므로 그냥 해준다. ❯ git branch --set-upstream-to=origin/main main Branch &#39;main&#39; set up to track remote branch &#39;main&#39; from &#39;origin&#39;. ❯ git fetch ❯ git pull Updating 99ce761..1ed16b7 Fast-forward README.md | 4 ++++ 1 file changed, 4 insertions(+) .",
            "url": "blog.chojaeseong.com/git/2021/10/17/%EA%B9%834_PR%ED%8C%80%EC%9E%91%EC%97%85_1%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4_2%ED%8C%80%EC%9E%91%EC%97%85_3%EC%9E%87%EC%8A%88%EC%99%80%EB%A6%AC%EB%B7%B0%EC%9A%A9PR.html",
            "relUrl": "/git/2021/10/17/%EA%B9%834_PR%ED%8C%80%EC%9E%91%EC%97%85_1%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4_2%ED%8C%80%EC%9E%91%EC%97%85_3%EC%9E%87%EC%8A%88%EC%99%80%EB%A6%AC%EB%B7%B0%EC%9A%A9PR.html",
            "date": " • Oct 17, 2021"
        }
        
    
  
    
        ,"post46": {
            "title": "SKTacademy 코테 TIP과 자료구조",
            "content": "reference SKTacademy | | . 알고리즘 푸는 이유 . 구현: 생각하는 내용을 코드로 옮긴다. 연습안하면 안된다. 500문제 이상 풀어야함. 반복해야 언제 어떤 변수를 선언하고 언제 전처리 해야하는지 알 수 있게 된다. 빨라지고 나만의 코딩스타일이 생긴다. | 효율성: 계속 구현하다보면, 효율성을 챙기면서, 자주 사용하는 함수로 최적화 | 다른 사람들의 코드를 보면서, 효율적인 코드 작성 | . | 절차적 사고: 절차적인 사고에 익숙해짐. 언제 어떤 과정을 하고, 다음은 어떻게 해야하는지 | 적재적소한 알고리즘을 선택할 수 있게 된다. 그럴려면 자료구조, 알고리즘을 따로 공부해야한다. | . | . | 디버깅: 한번만에 맞는 경우는 거의 없다. 예외케이스 탐색을 많이 해야한다. 최저, 최대, 최악 경우를 넣어보면서 한다. | 코드(에러)를 읽는 능력 | . | . | 재미: 적은시간으로 연습 가능 | 프로젝트와 다르게 짧은 주기로 성취감 | . | 문제보고 감잡기 . 1초당 가능한 복잡도 간 미리 계산하기 . python으로 . 백만번(10^6) 반복문or덧셈곱셈 등… -&gt; 1초 안에 다 풀린다. | 천만번(10^7) -&gt; 1초 안에 대부분 풀린다. python으로 1초안에 천만~5천만(10^7 ~ 5* 10^7)까지 연산 가능하다 생각하자. | . | 1억(10^8) -&gt; 불가능 -&gt; 알고리즘 바꿔야함. | . | 다시 문제보기 . 시간제한부터 보기 . 1초 -&gt; 10&amp;7 안에 풀어야한다. | . | 입력 보고, 반복문 횟수 갸늠하기 . n = 10억 = 10^9 -&gt; 단순 반복문 O(N)으로 는 불가능하다. | 입력을 보고 O(N)이상 불가 -&gt; 루트(n) or lgN or O(1)으로 해야한다. | . | . | . | PS팁 . 입력과 초기화 . python의 input은 3가지 종류를 받는다. . 숫자1개 . python에서는 항상 string으로 들어온형변환부터 해준다. | . . | 문자열 . 일반 문장 | 쪼개면서, [i]번째 인덱싱도 하고 싶다 -&gt; list() immutable한 string 대신 list로 변환시켜줘야한다. | . | 다시 붙일려면 ”“.join사용 | . . | 숫자 배열 . map을 써서 형변환한다. | . . | . | **list(배열)의 초기화는 comprehension으로 ** . . | . | 에러메세지 확인하기 RE: 런타임에러 -&gt; zerodivision or indexError | TLE: 시간초과 -&gt; 잘짰는데 무한루프가 있거나, 알고리즘이 안 좋거나 | . | 추상화와 기능분리 . 맨 처음 반복문에 돌아가면서 기능을 해줄 or 테케마다 처리해줄 input()받기부터 시작하는 함수를 짜자. 대충 로직을 슈도코드 짜듯이 짜면서 반복문 - 체크 - 결과값 저장 등의 로직을 짠다. . | 코딩하는 2가지 방법 . 현재가 main함수라고 가정하고 while 문에서 다 돌리기 | process함수를 따로 만들어놓고, 테케를 process함수에서 받아 main에서 돌림 | . | 처음에는 다 while문에 넣고 돌린다. . | 하지만, main함수는 최소화 해서 가벼워야한다. 내용들은 다 함수로 보낸다. . 반복문을 돌되, 각 TestCase마다 따로 처리되도록 함수로, TC별 처리되도록 하는 함수를 만들어서 돌린다. | . . 일단 위에 스샷기준으로는.. 테케별 처리도되록 함수에서 input을 받고 -&gt; 리하고 -&gt; return 하고-&gt; main에서 for문 print(함수return값) | . | . | 예를 들어, 삼성기출-사다리조작문제를 보자. (풀이는 안함) . 삼성쪽은 문제가 되게 길다. 그림 위 수치 위주로 빠르게 한번 보자. . 일단 수치(숫자)를 먼저보고 &quot;아~ 사다리가 5줄, 6줄 되는 구나 &quot; . | 사다리를 중간에 넣을 수 있구나 . | 사다리를 진행해나가는 과정이 있구나 . . | . | 입력 양식(예제 입력)보기 . 첫줄의 숫자와, 나머지 아래 숫자가 같으니까 아 대충 아래쪽이 사다리를 의미하겠구나 | . | 문제를 자세히 읽기 시작하는데 출력 요구사항을 먼저 본다 . | 문제가 복잡해보인다. . **이 때, main함수를 간단하게 만들기 위해, 반복문 어떻게 돌릴지 판단 -&gt; 그안에서 사용될 기능 분리하여 일단 슈도코드로 함수들을 작성해 기능분리 시켜준다. ** . | 사다리를 최대3개까지 놓는데, . i에 놓을지 . j에 놓을지 . k에 놓을지 선택할 수 있게 3중for문을 만들어 탐색가능하게 함. . | 3개에 따라 가능한지 확인하는 check(i,j,k) 함수를 사용하고 슈도코드로 위에다 작성해둔다. . | 가능할 때, 그 i번째 사다리가 i로 내려오는지 체크해주는 함수result()도 슈도코드로 작성해둔다. . | . . | . | | . | 코드를 줄여 가독성을 높이는 조건문, 반복문, 함수 by python indent를 줄이기 . 반복문 eX&gt; N by N by N 3중 포문 . 똑같이 N**3 만큼 횟수는 동일하게 돌아가는데, 한번에 for num in range(N**3)으로 돌리면서 . i = num을 N^2으로 나눈 몫 = num // (N*N) | j = num을 N으로 나눈 몫을, 다시 N으로 나눈 나머지 = num//N % N | k = num을 N으로 나눈 나머지 = num % N | . | **내가 만든 2중 포문을 indent 1개로 ** . i = num을 N으로 나눈 몫 N*N을 통해, ` 0~N-1을 첫번째 구간으로해서 N개` 존재하는데, 0~N-1구간: 행을 0으로 간주해요 | N~2N-1 : 행을 1로 간주해요 | … | ~N^2-1 N개의 구간이 있어요 | . | . | j = num을 N으로 나눈 나머지 구간별로 0~N-1의 열을 담당해요. | . | . for num in range(N**2): i, j = num//N, num%N print(f&quot;({i},{j})&quot; , end = &quot; &quot;) . | 진법, 진수를 활용하면 더 쉬워진다고 한다. . | . | main 반복문 속 조건문을 if True:시 process()가 아니라 if not False시: continue로 아래 process() 건너띄기를 통해 indent를 챙길 수 있다. . . process()함수 위에다가 if not 조건문 :continue를 활용해서 탈락시 건너띄기하면, 반복문내 indent를 줄일 수 있다. | . | 함수안에 if : return 다음에는 else가 필요없다. . **if return / return도 return 삼항연산자로 줄일 수 있다. ** 가장 선호. flag도 이런식으로 할 수 있다. | . | . . | | 변수명은 snake_case로, 함수명은 cameCase로, Pascal은 시작부터 대문자인 Camel . | 적용해보기 주사위네개 . 나는 Counter를 활용했지만.. | . # 기존 내코드 N = int(input()) from collections import Counter max_money = float(&#39;-inf&#39;) # 같은 눈이 4개가 나오면 50,000원+(같은 눈)×5,000원의 상금을 받게 된다. # 같은 눈이 3개만 나오면 10,000원+(3개가 나온 눈)×1,000원의 상금을 받게 된다. # 같은 눈이 2개씩 두 쌍이 나오는 경우에는 2,000원+(2개가 나온 눈)×500원+(또 다른 2개가 나온 눈)×500원의 상금을 받게 된다. # 같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)×100원의 상금을 받게 된다. # 모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)×100원의 상금을 받게 된다. def calc_money(data): max_cnt = max(data.values()) val_lst = [ x[0] for x in data.items() if x[1]==max_cnt] if max_cnt == 4: return 50000 + (val_lst[0]*5000) elif max_cnt == 3: # val_lst = [ x[0] for x in data.items() if x[1]==max_cnt] return 10000 + (val_lst[0]*1000) elif max_cnt == 2: # val_lst = [ x[0] for x in data.items() if x[1]==max_cnt] if len(val_lst) == 2: return 2000+(val_lst[0]*500) + (val_lst[1]*500) else: return 1000 + (val_lst[0]*100) else: return max(data.keys())*100 for _ in range(N): data = list(map(int, input().split())) data = Counter(data) money = calc_money(data) max_money = max(max_money, money) print(max_money) . 수학을 이용하면서 . 기능분리 by 함수 | 입력과 초기화 by 튜플, 컴프리헨션 | 반복문, 조건문 줄이기 by 한번에돌기+ if reutrn후에는 no else noelif + 삼항연산자 | . . | . | 수학 . 반복문을 . range(min(a,b))로 길이를 줄이거나 | range(min(a,b),,-1)로 거꾸로 시작하거나 | range(,,n)으로 간격을 주는 것을 생각하자. | . | 유호제법은 코드로 외우자. . math.gcd써도될듯.. | . # a&gt;b def gcd(a,b): # 1) b가 a의 약수면.. 그냥 b가 최대 공약수 # 2) 그게 아니라면, 재귀로서 gcd(b, a%b)로 재귀로 빨리 구하자. return b if a%b==0 else:gcd(b, a%b) . | 소수판별과 에라토스테네스의 체 . 소수판별 isPrime은 . 이론상 소수=1과 자기자신만을 약수로 가짐 = 2~n-1까지 약수없음, 약수 나오면 탈락인데 . 약수와 배수의 관계에서 약수는 항상 짝을 이루어 존재하니 2~루트(n)까지만 검사한다. | . . | . | 에라토스테네스의 체 . 범위가 주어진다 1~n까지 중 소스의 갯수는? 1은 소수가 아니여서 지움 | 2부터 isPrime으로 소수판별 소수로 판별되면 -&gt; 소수의 배수들을 싹다 지움(어떤수의 배수는.. 소수가 아님 무조건 x2, x3들이 약수가 되니까 | . | . | . . 뭔가를 지울 때는 chk, ck배열에다가 index - T/F를 hashing하여 활용한다. 이미 범위가 정해져있으면 거의 이렇게 사용한다. count 정렬 | 에라토스 테네스의 체 | DFS BFS? | . | . . 그외 자세히 주석으로 달음 . def era(N): # 체크는 hasing용으로서, n index를 쓸 거기때문에 0부터 시작했더라도 range(N+1)까지 돌려준다. ck = [ False for _ in range(N+1) ] p = [] # 1은 소수가 아니므로 제끼고 2부터 체크한다. # 소수의 배수들을 True를 채워놓고, 다음에 올 때 건너뛰게 한다. # 과거에서 판단한 소수의 배수들에 안걸렸으면, 아직 False로 남아있는, 소수는 바로 append해 줘도 된다. # -&gt; 맨처음 2만, 최초이기 때문에 과거에서 True로 소수탈락시킨 경험이 없다. for i in range(2, N+1): # 아직 False인 것만 체크한다. # 아래에서, 미래원소들 중에 소수라고 판별내어놨으면 건너뛴다. # -&gt; check를 활용해서 건너뛰는 [ck 미래 -&gt; continue 로직]이다. if ck[i] == True: continue # False = 2의 배수부터 시작해서, 소수탈락(True)에 안걸렸다면, 소수라고 판단한다. p.append(i) # 현재 i는 소수라는 뜻인데, 소수-&gt; 소수의 배수를 True(소수탈락)로 지워야한다. # * i배수 조작-&gt; i배수는 range(시작수, 끝수, i)를 통해 +i씩 움직인다. # 이 때, i+i or i*2부터 +i씩 i*3, i*4를 지워나가는게 아니라 # * &lt; ixi &gt;부터 시작해서 i의 배수를 지워나간다 range(i*i, N+1, i) # -&gt; 왜냐하면, 이미 과거에서 지워났기 때문인데 # -&gt; 예를 들어, 6은.. 이미 2에서 지워놨음. 3에서 지울 필요X. # -&gt; 3은 뭐부터 지워나가야할까? -&gt; 앞에서 안나왔을, 3의배수로서만 존재하는, # -&gt; 3만을 약수로 가지는 = 9부터 지워나가면 된다. # -&gt; 2*i부터 지눠나가도 괜찮다. # for j in range(i*2, N+1, i): for j in range(i*i, N+1, i): ck[j] = True # 이제 리얼소수는 p 배열에, 체크여부는 ck(소수탈락시True?)로 반환한다. return ck, p print(era(10)) # ([False, False, False, False, True, False, True, False, True, True, True], [2, 3, 5, 7]) . | . | . | 하노이 = 분할정복 by 재귀 . n번째 자체처리를 잘 넣어주자. | 재귀가 꼭 return해줄 필요는 없다. return안한다면 꼭 + 등의 연산으로 연결해줄 필요가 없다. 갯수: return f(n-1) * 2 +1 | 출력: f(n-1) + print(n자체) + f(n-1) f(n-1)내부에서도 print가 호출됨. | . | BUT 재귀함수의 base case if는 반드시 return으로 종료시켜줘야한다!! | . | 변하는 것들을 인자로 잘 넣어주자. 숫자 명칭이 고정이라면, 합이 일정한 것도 이용하자. | . # 1-&gt;3def hanoi(st, ed, n): if n==1: return print(st,ed) # 1-&gt;2 n-1 # st-&gt;mid hanoi(st, 6-(st+ed), n-1) # 1-&gt;3 print(st, ed) # 2-&gt;3 n-1 # mid -&gt;ed hanoi(6-(st+ed), ed, n-1) . | 정렬 . 선택정렬(i+1~n-1와 비교 최소값 찾으면 swap, 매번 맨왼쪽 최소값 확정), 버블정렬( 매번 인접한수 비교후 크면 오른쪽으로 swap, 매번 맨오른쪽 최대값 확정)은 n, n-1, .. 1번 모두 탐색해야해서 시복 O( n(n+1)/2) = O(N^2)으로 너무 느리다. . | 퀵 소트 . 재귀로 구현. 1)p정하고 2) 작, 큰그룹나눠서 3)p자리 확정의 과정을 작은그룹에서 1번, 큰그룹에서 1번 다시 시행한다. . def quick_sort(array): # 리스트가 하나 이하의 원소만을 담고 있다면 종료 if len(array) &lt;= 1: return array pivot = array[0] # 피벗은 첫 번째 원소 tail = array[1:] # 피벗을 제외한 리스트 left_side = [x for x in tail if x &lt;= pivot] # 분할된 왼쪽 부분 right_side = [x for x in tail if x &gt; pivot] # 분할된 오른쪽 부분 return quick_sort(left_side) + [pivot] + quick_sort(right_side) . | . | 머지 소트 . 재귀시, divide후 conquer과정에 투포인터 개념으로 merge를 해야한다. . | 1)절반으로 나누고, 2) 각각을 투포인터개념으로 합친다. . # 합병정렬에서는 conquer과정이 복잡하다. # [divide] 는 그냥 반씩 쪼개면 되지만, # [conquer]된(정렬된 list2개) 것들을 [combine](2개 list 합하여 정렬)시 복잡하기 때문에 이 부분을 merge함수로 뺀다. def merge(list1, list2): merged_list = [] i = 0 j = 0 while i &lt; len(list1) and j &lt; len(list2): if list1[i] &lt; list2[j]: merged_list.append(list1[i]) i+=1 else: merged_list.append(list2[j]) j+=1 if i == len(list1): merged_list += list2[j:] elif j == len(list2): merged_list += list1[i:] return merged_list def merge_sort(my_list): # base case if len(my_list) &lt; 2: return my_list # divide and conquer left_half = my_list[:len(my_list)//2] right_half = my_list[len(my_list)//2:] # 부분문제는 원래함수(부분)을 한 상태가.. 정복된 상태다 조심! return merge(merge_sort(left_half), merge_sort(right_half)) print(merge_sort([12, 13, 11, 14, 10])) . 2개의 배열을 merge할 때, 4개짜리 배열을 미리 대기시켜놓고, 투포인터로 넣어줘야한다. | 즉, 메모리할당이 많아진다. | 머지 소트는 정렬 문제에서 메모리가 넉넉할 때 쓴다. | 퀵 소트는, 최악(역순정렬&amp;p를 맨첫값)의 경우 NN이 될 수도 있다. | . | python sort(), sorted()는 퀵소트, 머지소트보다 더 최적화된 정렬을 쓰니. 그냥 이걸 쓰자. . | . | 라딕스 소트(radix sort) = 카운팅정렬 -&gt; 이범정(10^6~10^7 이하)일 때 . **이미 최소~최대값의 범위가 정해져있을 때 **, 그 범위를 index로 hashing시킨 배열을 미리 만들어놓고 . | 카운팅한다. . | 카운팅수만큼 연속해서 나열� . | | 자료구조 . 쓰는이유: 효율성. 쓰는 의미가 있음. 사용처가 정해져있다. 메모리를 효율적으로 쓴다. ex&gt; stack: undo 마지막에 했던 작업을 되돌리기 위해. 직전꺼를 되돌리기 | . | 추상적: 코드가 정해져있지 않음. 개념이므로 라이브러리가 아니더라도 어느 언어라도 구현가능해야한다. | 재사용성: 계속 쓰기 위해 라이브러리를 제공함 python은 collections에 많음. | . | . | stack 접시닦고 다시 가져가는 것에 비유 많이함. undo | 넣고push 위에서부터 빼는pop 2가지가 핵심 | 배열과 다른점은, 맨 마지막이 빠져나가는 점 : LIFO | python에서는 따로 library없고 배열[]로 바로 사용한다. | 예제 : 괄호 -&gt; 여는괄호만 넣어서 쌓으며, 닫괄시.. 직전에 넣은 여괄 부터 꺼내 짝이 맞나 확인해야한다. | . | queue와 deque 왜쓸까? 배열이랑 달라보이지만, 불필요 메모리를 줄인다.메모리를 효율적으로사용하기 위해 배열로도 구현가능(pop한 앞부분으로 index를 한칸씩 당긴다.?) | 이미 pop한 것들을 붙잡을 이유가 없어서 그럴필요가 없음. | . | server에서 여러 queue를 써서, 여유로운 queue에 task를 넣어주는 형식(task분할) | python에서는 deque = stack + queue라서 queue문제는 deque | 예제: 요세푸스 돌면서 제거된 사람을 빼야하는 경우 -&gt; deque의 queue로 popleft + append를 rotate로 해결 | . | . | . 그래프와 Tree의 저장방법 . 그래프의 특이한 형태로서, 나가는 간선(outdegree)만 있으면 Tree . Tree도 2가지 저장방법이 있다. . 자식마다 부모는 only 1개씩, 자식배열에 저장 cycle없이 root node제외하고 다 부모가 1개씩 존재 | 밑에서부터 부모를 찾아 올라갈 수 있다. 4의 부모 2 -&gt; 2의부모 1 -&gt; 1의 부모 0 == root | . | . | 부모마다 여러개자식을, 자식list로 2차원배열에 저장 인접리스트 저장시, 아래로 내려가면서 순환을 돌기 좋다. 1의 자식2 -&gt; 2는 아래로 4,5,6을 볼 수 있으니 4번 부터 본다. -&gt; 4번은 비어서 leaf node로 끝났따 -&gt; 5번 보고 6번보고 하자. | . | . | . | Tree의 부모저장배열 -&gt; LCA찾기 예시가 촌수문제다. . 조상들 모을 default 0의 N+1개짜리 부모저장배열 생성 입력정보를 배열에 저장함. 부모 없으면 0 | . | 2개 node의 공통조상찾는다? 각각의 (조상, 촌수) 튜플이 담길 list를 선언 | 한번 타고올라갈때마다 거리를 더해줄 각각의 촌수변수 선언 | . | 각 node마다 부모가 없을 때까지 찾아가야한다. default 0이며, 안쓰는 p[0]에 0이 들어가있어 무한루프의 가능성이 있으니, 부모가 0되는 순간 빠져나와서, 아직 처리안된상태로 나와, 마지막에 한번더 처리해준다. | 나부터 시작, 거리0으로서 튜플로(조상,거리)를 모아준다. | 재귀적으로 한번 찾아갈때마다 B = p[B] 로서, 나를 부모로 업데이트해준다. 그러면 나의 부모의 부모를 찾아가도록 된다. | . | . N = int(input()) A, B = map(int, input().split()) # 1. 촌수는 Tree형태 그래프인데, 문제에서 부모(1개만) 저장하는 방식을 택했으니 # -&gt; 1차원 배열에 다가 받아준다. # -&gt; 자신의 부모를 모두 0으로 초기화 해놓는다. (1부터 시작하는 node -&gt; 0은 부모가 없다는 것을 표현함.) # cf) 자식들y는 여러개일 수 있어서 index에 놓고, 각 자식들에 대한 부모는 1명밖이다 -&gt; value로서 1개 p = [0 for _ in range(N+1)] # 2. 관계수를 for문에서 바로 받아, 각 관계 -&gt; 부모배열을 채운다. for _ in range(int(input())): x, y = map(int, input().split()) # * 3.우리는 1차원 배열에 [부모만!] 저장한다. # 1 2 중에 1이 부모니까 index 2에다가 1를 저장한다. # cf) 자식들y는 여러개일 수 있어서 index에 놓고, 각 자식들에 대한 부모는 1명밖이다 -&gt; value로서 1개 p[y] = x # 3. A와 B의 공통 조상을 찾기전에, # * A의 조상들을 모두 모은다, B의 조상들을 모은다 -&gt; 교집합? # ** 참고로, A조상을 모을 때는, A자신을 포함해서 A자신 정보, 촌수거리0 부터 시작해서 -&gt; 재귀적으로 (부모, 부모까지거리(+=1)의 정보를 호출해서 담는다. Aa, Ba =[], [] # Aa: A의 조상a, Ba : B의 조상a # * A의 조상들(부모, 부모의 부모.. ) 모으는 과정에서, A와의 촌수도 같이 튜플로 저장하기 위해 Ad, Bd = 0, 0 # 1) 자신x&lt;-부모p[x]로 업데이트하여, 부모의 부모도 다음번에 찾아가게함 # 2) 자신&lt;-부모 업데이트할 때, 거리도 +1 업데이트해서, 촌수도 올라가게 함. # 3) p[x] &gt; 0를 while if조건절에 놓아서, p[x]==0 부모가없는 지점까지 올라간다. while p[A]&gt;0: # 3-1) 제일처음에 들어가면, 나와의거리Ad=0인.. 나 자신을 0촌 조상으로 튜플로 넣어준다. (나, 나와의거리) Aa.append( (A, Ad)) # 3-2) 재귀적으로 내가 부모가 되도록 업데이트해서, # while p[updated A]부모의부모가 있다면 -&gt; (나 updated A=부모, 전보단 늘어난 거리updated Ad +1) # 을 조상으로서 재귀적으로 모아준다. Ad+=1 A = p[A] # 내가 내 부모가 된다. for 다음단계를 위한 업데이트 # * 부모가 없는 p[A]=0의 root node도 넣어줘야한다... root node가 공통조상이 될 확류은 높다. # - 현재 p[A]==0상태이며, 첫 0이라서.. 루트노드로 업데이트된 것 일 것이다.. 마지막에 한번만 넣어주자. Aa.append((A, Ad)) # 4. B도 마찬가지다. while p[B]&gt;0: Ba.append( (B, Bd)) Bd+=1 B = p[B] Ba.append((B, Bd)) # print(p) # * 5. 2개배열을, &lt;2중 포문&gt;으로 1:1매칭 해보면서, 튜플 (조상, 촌수) 중 조상이 같을 때를 찾늗나. # -&gt; 조상이 같은 순간에서 촌수를 더해버리면 된다. for i in Aa: for j in Ba: # 여기는 Aa, Ba 조상들의 1:1매칭 공간 if i[0] == j[0]: print(i[1]+j[1]) # 등장하면, 제일 빠른 것을 만난 순간 바로 프로그램을 종료하면 된다. exit() else: print(-1) . | . | 나가는 간선외 들어오는 간선(indegree)까지 있으면 Graph . 그래프는 2가지 저장방법이 있음 . 인접행렬 : 행: 출발점 -&gt; 열: 도착점을 나타내는 N by N행렬 . 인접행렬도 3가지가 있음. 노방향 | 방향 | 방향+가중치 | . | . | 인접 리스트 : 튜플로 갈수 있는 (가중치, 노드) list를 인접한 list에 저정함. . 1의 indegree는? 0 (들어오는게 없다) . | 1의 outdgree는? 3 (3개가 나간다.) . in, outdegree가 중요한 이유는 indegree가 0인 지점이 시작점 일 될 수도, 한붓그리기 는 짝수여야한다. 등의 규칙이 있음 | . . | . | 이렇게 그래프를 저장하면, 최단거리나 가중치를 고려한 최소비용 등을 계산할 수 있게 된다 . | . | . | . 규칙적용된 tree인 이진트리로 heap/bst . 이진트리: Tree구조 자체가 graph만큼 어려워서 규칙을 정했는데 Tree의 rootnode가 1부터가 시작 | 자식은 최대2개로 하여-&gt;왼쪽자식node == 부모node의 2배가 너넘버링된다. 나node//2 는 부모node | . | | heap: NlgN으로 정렬을 유지하면서 데이터 pop/push가 가능하다. 그림 출저 | . | bst: python에서는 set, dict의 key를 원소-&gt; hash값 -&gt; hash값들을 bst 구조로 만들어 내부에서 사용되어 중복안되고 bst로 검색해서 빠르다? | . 그래프, 일반Tree, 점, 격자판 다 탐색하는 DFS와 BFS . DFS 전수조사시 사용되하는데, 1-&gt;0 마지막 탐색지점에서 빽할 때, 직전 node가 필요한데, 직전node를 stack 선언후 쌓아두는게 아니라, 재귀를 이용해서 stack을 자동 사용한다. 재귀함수=함수=stack메모리에서 관리되어 stack처럼 쓰임 | . | . | BFS 시작좌표(시작점, root node)에서 시작하여 level별 = 최단거리별 기록하기 위해 queue(deque)을 사용한다. 목표좌표가 나타나는 최단거리(level)을 구하거나 | 해당 level이 끝났을 때 최단거리의 수? | . | level별로 좌-&gt;우순으로 검색한다. | queue에 시작좌표를 넣어놓고 빼고 -&gt; (목표좌푠지확인) -&gt; 자식들 탐색 -&gt; 검사 -&gt; 넣기전 자체처리 -&gt; queue에 넣기 -&gt; (level별 시행시 L+=1) | . | . | . | 2개의 사용차이 찾는 범위가 국한되어서 n번안에 찾아지는 것이 확신을 할 수 있을 경우 -&gt; BFS 숨바꼭질2 | . | 모든 범위를 찾아봐야 하는 경우(매 탐색마다 1-&gt;0 바뀌는 끝을 찍어야하는 경우?) -&gt; DFS 단지번호 붙이기 | . | | . 앞으로 공부하는 방법 . 많이풀기 삼성은 DFS, BFS 30문제정도 | 카카오는 Trie를 포함해서 30문제정도 | | 암기하기 이해로는 X 많이 쓰면서 암기하는 과정이 필요하다. | 자기만의 템플릿이 있어야 한다. | | 주기적 체크하기 대회? | 안내서 노션 | |",
            "url": "blog.chojaeseong.com/algorithm/2021/10/17/sktacademy_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_python_%EB%AC%B8%EB%B2%95TIP.html",
            "relUrl": "/algorithm/2021/10/17/sktacademy_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_python_%EB%AC%B8%EB%B2%95TIP.html",
            "date": " • Oct 17, 2021"
        }
        
    
  
    
        ,"post47": {
            "title": "협업1) 나혼자 투컴으로 협업",
            "content": "나혼자 투컴협업(local to remote to local2) . Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . local to remote . 이미 로컬에서 관리하던 프로젝트를 github로 . local에서 작업시작 . 폴더 생성: . /home/is2js/workspace/git-github . | git init . | 계정입력(이미 global로 했으면 안해도됨) . | 파일 생성 . cat | mouse | . | 커밋 . ❯ git add -A ❯ git commit -m &quot;FIRST COMMIT&quot; . | . | 혹시나 연결된 원격레포가 있는지 확인 . git remote 아무것도 안뜨면 없는 것 | . | . | 깃헙 레포 생성(git-github) for 로컬을 원격으로 . readmd 등 생성하지 말아야함! 이미 local에서 git으로 관리하고 있던 프로젝트를 올리는 것이므로 아무것도 없어야함. | 아무것도 코드가 없을 때 나타나는 화면이 나와야함 | 구성 : https://github.com/is2js/git-github.git githuburl + /유저명/레포명.git | . | . | . | git status로 현재까지의 상황이 다 커밋되어있는지 확인한다. . ❯ git status On branch master nothing to commit, working tree clean . 빠진게 있으면 전부 add -A해서 commit | . | 로컬내용을 빈 원격레포에: git remote 등록 git push 내용옮기기 . 원격레포에 코드가 없을 경우 뜨는 페이지에서 …or push an existing repository from the command line 란을 복사버튼을 눌러서 . 현존하는 로컬 깃관리 레포를, 원격레포에 push하도록 복사한 내용을 cli에 붙혀넣기 해준다. . 현재는 코드가 main브랜치를 만들고, main 브랜치로 push하도록 변경되어있다. . | 복붙후 내 로컬도 main브랜치로 바껴있다. . | 아예 master브랜치 -&gt; main브랜치로 브랜치이름변경하는 명령어 인가보다. . git branch -M main . With a -m or -M option, will be renamed to | . &gt; git branch * main (END) . | . &gt; git remote add origin https://github.com/is2js/git-github.git git branch -M main git push -u origin main Counting objects: 4, done. Delta compression using up to 12 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (4/4), 273 bytes | 273.00 KiB/s, done. Total 4 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-github.git * [new branch] main -&gt; main Branch &#39;main&#39; set up to track remote branch &#39;main&#39; from &#39;origin&#39;. . | 이 때, 명령어를 뜯어보면 . git remote add origin https://github.com/is2js/git-github.git . git remote add [원격레포의 별칭, default origin] [레포 url]로서 원격레포url의 원격레포를 별칭(origin)으로 등록 | . | git branch -M main . 브랜치명을 main으로 변경 | . | git push -u origin main . git push -u [등록된 원격레포별칭, default origin] [올릴 원격레포의 branch] | . | 이후 나오는 메세지 중 현재 main브랜치가 , 원격레포인 origin의 원격 브랜치main을 추적한다.고 메세지가 뜬다. . Branch &#39;main&#39; set up to track remote branch &#39;main&#39; from &#39;origin&#39;. . | . | git remote명령어로 실제로 연결이 잘되었는지 확인 . ❯ git remote origin . | . | 빈 원격레포에, 관리되던 로컬 프로젝트 내용이 올라갔다면, 레포의 기본페이지가 바뀐다. . 커밋내용은 로컬에서 커밋한 기록들이 다 뜬다. | . | 소스트리에서 해보기 . 소스트리로 해당 레포 열기 | 저장소탭 &gt; 원격 설정 클릭 현재 나는 이미 터미널로 연결된 상태라, 원격 저정소 경로에 하나가 추가 되어있다. | . | 추가 클릭 원격 이름: 원격url의 원격레포에 대한 별칭, default origin | URL/경로: 원격레포의 url 복붙 | 호스트 종류: github | 사용자명: github id 입력 | . | 원격 탭에서 원격레포의 별칭(주로 origin)으로 확인하기 . | push버튼 클릭 로컬 / 원격(리모트) 브랜치를 각각 선택해주고 push해주자. | . | 파일추가(수정) 후 commit까지 한 뒤 push: git push [원격레포별칭] [그 레포의 브랜치] . dog파일 추가 . | git add - A, git commit -m , git push [원격레포별칭, 주로origin] [그 레포의 브랜치] . ❯ git add -A ❯ git commit -m &quot;ADD dog&quot; [main 15a73f6] ADD dog 1 file changed, 1 insertion(+) create mode 100644 dog ❯ git push origin main Counting objects: 3, done. Delta compression using up to 12 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 302 bytes | 302.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-github.git d33f3a8..15a73f6 main -&gt; main . | 올릴필요가 없거나(코드로 자동생성) 올려선 안되는 파일(DB계정 등)처리: .gitignore . 올릴 필요가 없는 파일 : 코드로 자동 빌드되는 파일들 그 때 그 때 실행해서 만들면 되므로 올릴 필요가 없다. 안드로이드나 스프링 등에서 처음부터 골격이 세팅된 체 시작하는 프로젝트들을 생성하면 .gitignore가 미리 만들어져있다!! | . | . | .gitignore에 등록하면 add + commit의 대상으로 안봄. 버전관리 안됨. | . | . 프로젝트폴더 최상위 공간안에 .gitignore파일 생성 . 숨김파일로 지정되니 참고해야함 | . | gitignore에 넣을 파일 secret-animal을 만들고, git status로 상황을 확인하자. . Untracked files(add해야할 목록)로서 아직 add안된 파일 2개를 알려준다. . Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) .gitignore secret-animal . | . | 이 상태에서 secret-animal 파일을 .gitignore에 적으면, git status상 add해야하는 파일에서 제외된다. . 아하~ 아예 add할 파일로조차 보지도 않음. | 내 프로젝트에 있어도 add + commit을 안하므로 push도 관리도 안됨. | . Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) .gitignore . | remote to com1,2 . 원격repo를 현재폴더에다가 가져오기: git clone [url] . . 1개 컴으로 연습하려면, 폴더 2개를 만들어서 해보면 된다. . . 일단 폴더 2개를 만든다 computer-1 | computer-2 | . | 참고) clone시 해당목적지 폴더로이동 &gt; git clone [url] [.] | 소스트리는 해당 목적지폴더 선택만 | . | . | . 컴퓨터1의 폴더를 vscode로 연 다음, 터미널도 켠다. . 윈도우탐색기 &gt; wt -d . &gt; code . &gt; ctrl + ~ + wsl로 repoen? 윈도우 통해서 들어가면.. vscode wsl원격버전이 안켜진다. | . | wt &gt; wsl &gt; 해당폴더로 이동 &gt; code . | . | 기존 작업하던 원격레포(git-github)의 url를 복사한 뒤, vscode 폴더 터미널에다가 git clone한다. . #git clone [url] [.] git clone https://github.com/is2js/git-github.git . . 만약, clone시 [.] 현재폴더 옵션을 안주면, 그 내부에 폴더를 새롭게 만들어버림 . 새로운 컴퓨터의 로컬폴더 컴퓨터-1에다가 원격repogit-github의 내용을 가져왔다. | . | . | 연결된 나의 원격repo가 아니라 아무 원격repo를 클론해오더라도 git log로 모든 작업내역을 볼 수 있다. . git log . | 이제 소스트리로 컴퓨터-2 로컬폴더로 clone해보자. . + (new) tab &gt; Clone &gt; . 소스경로/URL : 원격레포url | 목적지 경로: computer-2폴더 지정 git clone 시에는 [원격레포url] [.] 현재폴더로의 옵션을 붙혀줘야하지만, 소스트리에서는 안해주고 폴더만 선택해주면, 그 폴더로 다 clone | . | . . | 이제 컴퓨터-2도 vscode로 열자. . | . | 새로올린(뒤쳐진) 커밋 내역 자동 확인: git fetch + git status . 컴1작업 -&gt; 원격레포에 push -&gt; 컴-2에서 일일히 작업내역을 확인하지 않고, git fetch로 뒤쳐진 내역이 있는지 확인 컴퓨터1 | 컴퓨터2 | . | . 컴1에서 dog name을 수정하고, add, commit호 원격레포에 push까지 해보자. . local의 global계정이 내 계정이라서 그런가 바로 push된다. . ❯ git add -A ❯ git commit -m &quot;EDIT dog&quot; [main 1eaa722] EDIT dog 1 file changed, 1 insertion(+), 1 deletion(-) ❯ git push origin main . . | . | 이제 컴2에서 일일히 github에 새로 올라운 커밋내역을 확인하기 힘드니 git fetch로 뒤쳐진==새로올라온 커밋의 갯수를 확인한다. . ❯ git fetch ❯ git status On branch main Your branch is behind &#39;origin/main&#39; by 1 commit, and can be fast-forwarded. (use &quot;git pull&quot; to update your local branch) nothing to commit, working tree clean . 원격레포/main 브랜치에비해, 내 브랜치가 1개 커밋 뒤쳐져있다고 나온다. | . | 뒤쳐진 내용 받아오기: git pull [원격별칭] [브랜치명] . 컴2에서 뒤쳐진 1개의 커밋을 받아온다. . &gt; git pull origin main From https://github.com/is2js/git-github * branch main -&gt; FETCH_HEAD Updating 15a73f6..1eaa722 Fast-forward dog | 2 +- 1 file changed, 1 insertion(+), 1 deletion(- . . | 소스트리에서도 git pull을 하기위해 . 컴2에서 dog 이름 수정 . | 소스트리 컴2에서 커밋과 동시에 push . . | 소스트리에서 컴1 폴더를 add . | 컴1폴더에서 패치버튼 선택 &gt; 모든 원격저장소에서 가져오기 선택 . . | main 브랜치에 당겨올 것들이 있다고 메세지가 뜸 . | pull버튼으로 받아오기 . | . | 일단 작업전에 메세지 안떠도 pull부터 누르고 시작하자 . 나혼자 투컴협업 branch, conflict . 브랜치를 이용해서 투컴협업 . 브랜치 전환, 없으면 생성해서 : git checkout -b [브랜치명] . branch기본 생성 : git branch [이름] | 전환 : git checkout [이름] | . | 브랜치 생성과 동시에 전환 git checkout -b [이름] checkout은 커밋id, 브랜치, tag 다되므로.. -b옵션을 주면 브랜치전환인데, 없으면 생성까지 | . | . | . 컴1에서 my-idea 브랜치 생성 . git checkout -b my-idea . . git branch . | my-idea이라는 평행우주에서 파일을 수정하고 add commit까지 한 뒤 push할 준비를 해자. . mouse 삭제 . | dinosaur 추가 . ❯ git add -A ❯ git commit -m &quot;ADD dino&quot; [my-idea e43a292] ADD dino 2 files changed, 1 insertion(+), 1 deletion(-) create mode 100644 dinosaur delete mode 100644 mouse . | . | 새로운 브랜치(평행우주)를 push: git push [origin] [새로운 origin의 브랜치명] . my-idea 브랜치를 -&gt; origin의 특정브랜치로 생성해서 push할 수 있다. 하지만 보통은 원격레포에 로컬과 같은 브랜치명으로 생성해서 올린다. | . | . 컴1의 my-idea브랜치와 동일한 이름으로 원격레포의 브랜치를 생성해서 push까지 해보자. . ❯ git push origin my-idea Counting objects: 3, done. Delta compression using up to 12 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 304 bytes | 304.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) remote: remote: Create a pull request for &#39;my-idea&#39; on GitHub by visiting: remote: https://github.com/is2js/git-github/pull/new/my-idea remote: To https://github.com/is2js/git-github.git * [new branch] my-idea -&gt; my-idea . **new branch로서 [로컬my-idea] -&gt; [원격my-idea]으로 push했다고 나온다. ** 즉, 로컬의 평행우주를 push한다고 해서 1:1대응 되는 것이 아니라 원격의 원하는 이름의 평행우주를 만들어서 push하는 구나. | . | . | 원격레포에서 새로운 브랜치(평행우주)가 생성되었고, push도 되었으니 PR를 고려해보라고 메세지가 뜬다. . . my) PR는 push된 임의의, 새로운 평행우주를 기본branch로 합치겠습니까? 정도이다. | 브랜치를 바꿔서 들어가보면, **새로운 평행우주가 로컬-컴1의 my-idea그대로 ** 펼쳐진다. | . | 원격레포의 새로운브랜치를 받는 방법은 [브랜치 생성&amp;전환명령어] 응용: git fetch -&gt; git branch -a -&gt; git checkout -b [생성할 로컬 브랜치(결국엔 뒤에 기입한 원격브랜치를 받아올 브랜치)] [origin(별칭)/pull해올 원격 브랜치명] . git checkout -b [생성할브랜치(결국엔 뒤에 기입한 원격브랜치를 받아올 로컬 브랜치)] [origin(별칭)/pull해올 원격브랜치명] 브랜치 생성&amp;전환 명령어로 원격레포브랜치를 pull까지 해버린다. | git checkout -b : 생성과 동시에 전환 | [생성할 로컬 브랜치(결국엔 뒤에 기입한 원격브랜치를 받아올 로컬 브랜치)] : 아직 원격이 새 평행우주(branch)가 없는 로컬에서, 받아줄 브랜치(평행우주)를 지정한다. | [origin/pull해올 원격브랜치명] : 원격레포 속 받고 싶은 평행우주 | . | 컴2에서 원격레포의 새로운브랜치(평행우주)를 받아보자. 굳이 main에 합쳐진 것이 아니어도 받아서 사용해도 된다. | . | . 컴2에서 로컬용 git branch에 -a옵션까지 더해서 원격 브랜치도 확인한다 . git branch -a * main remotes/origin/HEAD -&gt; origin/main remotes/origin/main . 원격branch는 github의 소식을 업데이트를 해줘야한다 | . git fetch git branch -a * main remotes/origin/HEAD -&gt; origin/main remotes/origin/main remotes/origin/my-idea . 원격레포의 (HEAD, default 작업장소)가 보는 곳은 아니지만 밑에 새로운 평행우주가 추가되었음 | . | 원격레포의 새로운 평행우주(my-idea)를 컴2의 my-dea로 받아와 보자. . 브랜치 생성&amp;전환명령어로 원격레포브랜치를 pull까지 해버린다. | . #git checkout -b [로컬브랜치명] [origin/원격브랜치명] ❯ git checkout -b my-idea origin/my-idea Branch &#39;my-idea&#39; set up to track remote branch &#39;my-idea&#39; from &#39;origin&#39;. Switched to a new branch &#39;my-idea&#39; . git branch로 확인해보자. . main * my-idea . | . | 소스트리로 컴2:new브랜치생성 to 원격 to 컴1으로 넘겨보기 . 이번엔 소스트리로 컴-2에서 브랜치를 생성후 원격레포에 생성과 동시에 PUSH . 브랜치 탭 &gt; 새 브랜치 : my-another-idea . | cat이름을 nyang으로 변경 . | 커밋과 동시에 origin푸쉬 by 소스트리 . . 만약 소스트리가 아니라면? . ❯ git add -A ❯ git commit -m &quot;EDIT cat name&quot; ❯ git push origin my-another-idea . push origin은 없으면 해당 브랜치 생성해서 push한다. | . | . | 깃허브에서 branch 생성 확인 . . | . | 컴-1의 소스트리에서 컴2-new브랜치(my-anther-idea)받아보기 . **컴1의 소스트리 &gt; 원격 탭 클릭 &gt; 원격의 새 브랜치 더블클릭 &gt; 새 브랜치로 체크아웃 ** . . | **원격 브랜치의 체크아웃만으로 로컬의 새브랜치를 생성 및 가져온다. ** . 따로 pull의 과정이 없는 것이 cli 든 소스트리든 마찬가지다 | . | . | my) 새 브랜치는 pull이 아닌 [checkout -b]만으로 로컬에 새 브랜치를 생성 및 내용을 가져온다. . 로컬 컴1-main에 브랜치들 merge(자동커밋)후 push -&gt; 컴2에서 fetch로 확인후 받아오기 . 컴1에서 브랜치병합후 원격레포에 push해보자. | . main(master)로 이동(받는놈) . | 주는놈인 my-another-idea 우클릭 &gt; 병합하기 . 현재 브랜치로 (주는놈) 병합 | . | push할 커밋수 확인해보기 . 병합전: main옆에 1은 push할 커밋수다. . . | 병합(자동커밋!)후: main2로 push할 커밋 1개 늘어남. . | . | 병합된 내역(커밋)까지 컴1 -&gt; 원격 레포에 소스트리로 push . push버튼 &gt; 병합된 내역 push | . | 이제 컴2의 소스트리에서 fetch로 원격상황 받아오기 . main브랜치에 pull받을 것들이 있다고 업데이트된다. . . | main으로 이동후 pull받아오기 . | . | ### . 충돌해결로 협업 . 한쪽에서 파일1을 수정해서 push했는데 . 다른쪽에서 파일1을 pull받지 않은 상태로 수정후 로컬커밋한 상태 . . | 다른쪽에서 pull받아야하는데, 같은파일이 수정된체 커밋된 상태면, conflict . . | . | . 직접 충돌내보기 . 컴1에서 dog파일 수정, 커밋, push . 한쪽 수정(bark: wang wang)이 push한 상태 . ❯ git add -A ❯ git commit -m &quot;EDIT dog bark wang&quot; ❯ git push . | . | 컴2에서 pull 받지도 않은 체 dog파일 수정후 커밋 . 다른 쪽이 pull안한체로 수정후 커밋한 상태 . ❯ git add -A ❯ git commit -m &quot;EDIT dog bark warl&quot; . ❯ git push To https://github.com/is2js/git-github.git ! [rejected] main -&gt; main (fetch first) error: failed to push some refs to &#39;https://github.com/is2js/git-github.git&#39; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., &#39;git pull ...&#39;) before pushing again. hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details. . pull할게 있으면 push가 안된다. | . | . | push가 안되면 . 원격에 누가 새 작업을 올렸구나. pull부터 받자라고 생각 . ❯ git pull . | . | pull받았는데 conflict나면 . 저쪽에서 같은 파일 수정했구나 ㅠㅠ라고 생각 . | git status로 더 자세한 상황을 보자. . ❯ git status #... both modified: dog #...저쪽과 나 모두 dog파일을 수정했네.. . | vscode에서 처리하기 . HEAD : 내가 작성한 부분 . | ===아래부분 : 저쪽이 작성한 부분 . . | . | . | conflict 후에는 git commit 을 -m 없이 커밋하여, 충돌 메세지를 그대로 저장하도록 한다. . git add -A git commit . git push해서 수정본을 원격레포로 보낸다. | . git push . | 브랜치삭제, 원격브랜치삭제: git branch -d vs git push -d [origin] [원격브랜치] . git branch 목록보기 . git branch -a . | 로컬 삭제 &amp; 원격 삭제 . 로컬 : git branch -d [브랜치명] | 원격 : git push -d origin [브랜치명] | . ❯ git branch -d my-idea Deleted branch my-idea (was e43a292). ❯ git push -d origin my-idea To https://github.com/is2js/git-github.git - [deleted] my-idea . | 소스트리로 충돌만들고 해결해보기 . 충돌일으키기 : pull받기 전, 같은 파일 수정후 로컬 커밋 push하면 충돌 발생 | 소스트리는 커밋과 동시에 push하므로 커밋당시에 발생 | . | 서로 다른브랜치(평행우주)라도 같은파일 수정상태면 conflict남 | . pull받기전에, 저쪽에서 수정한 파일을, 나도 수정한 뒤 소스트리로 커밋&amp;push를 눌러본다. 커밋은 성공했다고 따로 메세지 뜸. | . | push시 에러 -&gt; pull받자 -&gt; conflict뜨면? -&gt; 같은파일수정했네 pull을 했더니 소스트리에서 conflict를 알려준다. | . | **파일상태 탭으로 가보면, ** 충돌파일은 아직 add되지 않은 unstaged된 파일로서 존재 | 충돌파일 클릭시 충돌내용이 vscode처럼 나옴 | 충돌 커밋메세지는 자동 작성되어있음 cli라면 git commit만 하란 소리 | . | . | 직접 에디터(vscode)로 가서 수정해줘야한다. | 다시 소스트리로 와서 add후 커밋&amp;push | my) push에러 -&gt; pull받자 -&gt; conflict -&gt; 같은파일 수정했네. .",
            "url": "blog.chojaeseong.com/git/2021/10/16/%EA%B9%833_%EB%82%98%ED%98%BC%EC%9E%90%ED%88%AC%EC%BB%B4%ED%98%91%EC%97%85_branch_conflict.html",
            "relUrl": "/git/2021/10/16/%EA%B9%833_%EB%82%98%ED%98%BC%EC%9E%90%ED%88%AC%EC%BB%B4%ED%98%91%EC%97%85_branch_conflict.html",
            "date": " • Oct 16, 2021"
        }
        
    
  
    
        ,"post48": {
            "title": "심화) vscode로 git 심화 학습",
            "content": "Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . 깃 기본 with vscode . extension 2개 설치 . git extension pack | git extension pack 검색후 설치 | gitlens와 gitignore가 동시에 설치되어진다. | 왼쪽메뉴에 소스제어 를 클릭하면, gitlens가 통합되서 나온다. | 설정 &gt; git enable이 활성화 되어있는지 확인한다. . | gitlens layout 수정 . gitlens를 왼쪽메뉴에 따로 보이게 되었는데, 설명서를 읽으니 gitlens.setViewsLayout 검색 &gt; default로 클릭해야 source control탭에서 통합해서 볼 수 있다. | . | _git history는 팔레트에서 git log를 검색해서 사용 | . markdown all in one | markdown all in one검색 후 설치 . gitignore (팔레트커맨드) . add전에 설치된 gitignore를 사용하기 위해서ctrl+shift+p(모든 명령어, 팔레트)에서 gitignore를 검색하여, add ignore를 클릭 이후 python 을 검색해서 선택 -&gt; 파이썬을 제외시키는게 아니라 python관련 불필요 파일들이 등록이 된다. | create .gitignore가 생성되었다고 뜬다. | . | 소스제어에서, gitignore도 뜨는데, [파일열기]버튼이 따로 있다. . | python프로젝트를 선택하더라도 .vscode/폴더를 맨끝에 추가해준다. . .vscode로 달아도 되지만, 폴더라서 마지막에 슬래쉬도 넣어준다. | . . | . add remote(팔레트커맨드) . 빈repo를 생성 . readme파일만 체크해서 생성( 첨부터 push안되게 충돌내기 위함. ) | . | &gt; add remote 후 repo 선택 . 주의 [remote name]: origin으로 기본적으로 설정한다!!! . | 참고) add remote를 2개 했다면? git remote + remove [remote name] . | . | git config --list로 연결된 원격레포의 주소 확인하기 . | add, commit, and push in commits . U 파일들에서, +버튼을 눌러 add시키면, staging된 변경사항으로 이동한다. . | commit은 상단의 [소스제어]에서 체크버튼으로 staging된 변경사항을 한번에 다 commit시킨다. . | [commits] 탭 push를 클릭했다. . 해당 repo에서 push내역을 확인 | . . | . pull(명령어) 및 이질적인 프로젝트 병합 허용(–allow-unrelated-histories) . git pull origin main . 현재 remote가 빈 레포가 아니므로, push가 바로 안됨 . readme.md가 있기 때문에 pull당겨와서 충돌해결하고 해야함. . fatal: refusing to merge unrelated histories . | 이건 뭔짓을 하더라도 안됨. 따로 설정하면서 pull을 해줘야한다. . | . | . git pull origin main --allow-unrelated-histories . push . 갑자기 commits탭에서 사라져서.. 그냥 . vscode 작업표시줄을 클릭하여 push . | F1(팔레트)열고 git push검색해서 push . 해도 됨 . | . . | . [개념] branch (실무 많이) . main은 항상 deploy상태로 유지 | topic branch = 수정용 브랜치 = push해서 PR하는 브랜치 push를 자주해서 날라가는 것을 방지하자. | 검토후 merged(PR)후에 바로 삭제하는 브랜치 | . | develop branch는 삭제안한다. | main브랜치는 항상 최신으로 유지하므로 각 기능별 브랜치는 main에서 딴다. | [실습] branch(명령어) . . from-br없이 브랜치를 따면, 현재 브랜치에서 따는 것이므로 git branch명령어를 확인하고 따자. git branch new-br from-br | git branch git branch new-br | . | . | -로 직전브랜치를 checkout할 수 있다. . | checkout -b [new-br] [from-br]로 생성하면서 동시에 브랜치를 변경하게 되므로 가장 자주 쓴다. . git branch testbr main git branch * main testbr git checkout testbr Switched to branch &#39;testbr&#39; git branch main * testbr git checkout - Switched to branch &#39;main&#39; Your branch is up to date with &#39;origin/main&#39;. git branch * main testbr git checkout -b work main Switched to a new branch &#39;work&#39; git branch main testbr * work . | . git merge 와 fastforwad . 그림 출저 | . . merge commit은 서로 다른 상태의 브랜치를 병합해서 새로운 commit을 만드는 경우이고 . fast forward는 동일 내용이 포함되는 브랜치일 경우 브랜치 이동만으로 병합해서 따로 commit을 생성하지 않는 경우입니다. . | . topic branch(작업용브랜치) main에 merge후 삭제: git merge –no-ff / git branch -d . 현재 브런치 목록 . main testbr * work remotes/origin/main . | . work를 토픽브랜치라 가정하고 파일 work.py생성 후 커밋 . | main으로 돌아오면 당연히 파일이 없음. . | main에서 merge했다는 커밋을 남기면서(--no-ff) work브랜치를 받아오자. . 파일의 변화가 차이밖에 없는 경우. HEAD만 이동시키는 merge는 커밋이 발생안하고 앞으로 이동만 -&gt; fast forward가 발생하는데, 여기서는 직접 merge 메세지도 남긴다. | . ❯ git merge --no-ff work . | merge의 log확인을 git history라는 익스텐션으로 해보자. . 나는 git graph라는 익스텐션도 보인다. . . git history . | git graph . . | git log –oneline –graph 의 명령어 . . | . | . | merge확인후 topic branch삭제 . ❯ git branch -d work Deleted branch work (was cbf2765). . | git 탭에서 브랜치 변경후 개별커밋들 확인 . . 해당브랜치 화살표누르면 switch (checkout 됨) . | 왼쪽 화살표를 누르면, 각 브랜치마다 커밋 목록이 보인다. . 브랜치 생성이전 main브랜치 커밋이 그대로 보이는 듯함. | . . | testbr에서만 파일 생성후 커밋해보자. . testbr이 위로 올라왔다. branch 생성이후부터 달라진 커밋 차이가 난다. | . | . | [중요] topic branch에서 [다른topic이 merge된 main] 의 파일 1개만 받아오고 싶다면: git checkout -p . testbr에서 main속 work.py를 가져오고 싶다면 . git checkout -p [가져올브랜치명] [가져올파일명]을 이용한다. wsl2에서 안되서 windows 상태에서 하니깐 됬음. | . | . | . ​ 1. git checkout -p main work + y 로 main브랜치의 work.py를 가지고 온다. . ❯ git checkout -p main work.py diff --git b/work.py a/work.py new file mode 100644 index 0000000..e69de29 (1/1) Apply addition to index and worktree [y,n,q,a,d,?]? y . 현재 상태를 보면 add까진 된체 로 온다. add전후 살펴보는 git status로 봐도, 이미 Add는 되어있다. | . | work.py에 내용을 조금 넣어주고 commit하자. | 직전 commit의 메시지 변경: git commit –amend . git commit --amend를 치면, 직전 commit에 대한 메세지 수정사항이 editor 로 열린다. | git commit --amend . 메세지를 저장하면 자동으로 반영되어진다. . | 참고 . 마지막 커밋A에 일부만 빠졌다? 3을 빼고 1,2만 add 및 커밋한 상태 | 3을 git add한 뒤 git commit --amend | . | 그냥 커밋메세지만 변경 git commit --amend -m &quot;메세지&quot; | . | . | HEAD포함 n번째[에] commit 합치기or삭제 등 commit history 조절: git rebase -i HEAD~[숫자] -&gt; fixup or squash . HEAD~ = HEAD~1 HEAD포함 HEAD1개 전 ~1 = HEAD^ : 헤드의 부모, 헤드의 1개전 | . | . | rebase는 명령어로 하는게 더 빠르고 쉽다. | . . commit 1개당 1개의 의미를 가져야하나, 의미가 없는 커밋들을 하나로 합칠 때 , git rebase -i HEAD~ + [합칠 커밋갯수] 이후에 fixup: (귀찮아서) HEAD포함 n번째커밋에 커밋합치면서 n번째 커밋명으로 커밋합침 | squash: (새로운커밋명을 위해) HEAD포함 n번째커밋에 커밋합치면서 + 새로운 커밋명으로 합침 | 그외 reword(= amend), drop 등: 사용안한다. | . | . 커밋을 1111,222,3333333,4444,55555 5개를 새로 만들자 . | git rebase -i HEAD~[head포함 합칠 커밋갯수 &amp; head에서 뒤로 2칸 간 곳에서 합쳐짐.]을 커맨드로 입력한다. . ❯ git rebase -i HEAD~2 . . 여기서 커밋메시지 같은 git-rebase-todo 메세지에서 pick대신 fixup을 적어서 뭉개자. 최근커밋인 5555(HEAD)를 fixup으로 뭉개서 저장시키면 된다. | . | . 따로 뭔가 뜨지 않으면 .git &gt; rebase-merge &gt; git-rebase-todo를 클릭한다. . | 도착지(HEAD포함 n번째 커밋)는 선택지가 없다. . 최근 것이며 뭉개지는 HEAD는 선택지가 있다. . 여기서 fixup을 선택하면, 귀찮게 새로운 커밋메세지를 작성안하고 n번째 커밋명을 이용하게 된다. . . | start rebase를 해서 커밋을 합친다. . | . | . | 이제 444 -&gt;333으로 . git rebase -i . . 최근 것(아래 것)을 pick to squash로 변경해보자. . 과거커밋으로 합치는데 커밋메세지는 새로작성한다는 것이다. . . | 맨 위에 커밋메세지를 적으면 적용된다. . | . | 이미해버린 commit 취소는 직전HEAD로 돌아가면서 취소: git reset –hard HEAD~ . reset은 해당커밋까지가면서 자연스럽게 삭제한다. | . head의 부모로 가면서, head는 삭제 . ❯ git reset --hard HEAD~HEAD is now at 3460720 Merge branch &#39;testbr&#39; of https://github.com/is2js/git-ssac into testbr . . | add(staging) 취소는 아직commit안됬으므로 commit전 HEAD로 돌아가면서 취소: - or git reset HEAD . git extension으로 는 그냥 -버튼을 누르면 add가 취소됨 . | 명령어로는 git reset HEAD로서 . --hard없이 code를 살린체 최근HEAD로 돌아가면 -&gt; add취소가 자동으로 | . . git reset HEAD # HEAD 대문자여야함. . . | . 깃 심화1 with vscode . ### . git tag는 release의 의미를 가지므로 main에서 딴다. tag 혼자 = 커밋의 합 = 강의 n화 | 협업 = topic -&gt; main에서 merge후에 main에서 배포버전으로서 tag를 딴다. | . | . | . merge는 항상 명령어로 –no-ff를 붙여 커밋을 남기자 . --no-ff를 붙이면 fastfoward = 커밋없이 head위치만 바꾸는 것을 안하고 항상 merge커밋을 남긴다. conflict나면, Accept incoming후 git commit만 입력해주면 메세지 완성되어있음. | . | . main브랜치로 넘어가기 . | 명령어로 merge하기 . ❯ git merge --no-ff testbr Merge made by the &#39;recursive&#39; strategy. hello.py | 3 +++ testbr.py | 0 work.py | 1 + 3 files changed, 4 insertions(+) create mode 100644 testbr.py . | merge후 topic branch는 삭제: git branch -d . merge가 되었다면, topic 브랜치 삭제하기!! . git branch -d testbr Deleted branch testbr (was 74296bb). . 만약, fully merge가 안되었다고 뜨면? 대문자 -D로 강제 삭제해준다. . git branch -D testbr . | . | tag 확인 및 생성 in main브랜치:git tag [v0.0.1] . tag는 release될 main브랜치에서 작성한다. | tag는 release단위 = 배포단위로 생성한다. | tag는 소스코드를 push를 해놓은 상태에서 -&gt; tag를 local에서 따고 -&gt;tag를 push한다. | . ❯ git tag ❯ git tag v0.0.1 ❯ git tag v0.0.1 (END) . tag는 commit과 별개로 따로 push: git push origin [tag(=버전)] . git push origin [태그명=버전명] . ❯ git push origin v0.0.1 Total 0 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-ssac.git * [new tag] v0.0.1 -&gt; v0.0.1 . | git repo에, tag가 생긴 것을 우측사이드에서 확인가능 . | code수정 후 commit-&gt;push 끝난 뒤, 따로 tag 따고 -&gt; push . 파일(코드) 수정 . | local git commit . | local -&gt; origin(원격레포)로 push . ❯ git add -A ❯ git commit -m &quot;askldjflkasd&quot; ❯ git push . | commit의 push가 끝난 뒤, tag를 딴다. . ❯ git tag v0.0.2 ❯ git push origin v0.0.2 Total 0 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-ssac.git * [new tag] v0.0.2 -&gt; v0.0.2 . | tag는 과감하게 돌아가기: git reset –hard [태그] . git reset --hard [commit_hash]를 하면 해당 커밋까지 돌아가면서 자연스럽게 그 이후의 내용들은 삭제되었다. 하지만, 태그의 경우, code + commit은 돌아가나 tag는 삭제안되고 남아있다. | . | . ❯ git reset --hard v0.0.1 HEAD is now at bd4c018 Merge branch &#39;testbr&#39; into main ❯ git tag v0.0.1 v0.0.2 . 되돌아가도 tag는 남아있으니 직접 삭제해줘야한다. | . reset tag이후에도 local+remote tag 따로 삭제: git tag -d 태그 / git push origin -d 태그 . 로컬 tag를 삭제한다. . git tag -d v0.0.2 Deleted tag &#39;v0.0.2&#39; (was 476f70b) . | 원격에 남아있는 tag도 삭제한다. . git push origin -d v0.0.2 To https://github.com/is3js/py.git - [deleted] v0.0.2 . | 깃 심화2 with 개념위주 . 실수로 다른브랜치에 커밋or코드의존성때문에 다른사람 커밋이 필요할 때: git cherry-pick 으로 특정커밋만 똑! 가져올 때 . . 코드의존성 . 다른사람 커밋 위에서 일해야하는 경우 ex&gt; 다른사람이 버그고침 -&gt; 나는 그위에서 일을 해야할 때 | . | . | master branch의 cccccccc커밋만 -&gt; my branch로 . 커밋해쉬 앞 7글자 . git cherry-pick ccccccc . . | . | . git reset 총정리(add취소, commit취소) . ADD취소 2가지 . 옵션을 안주면 mixed | . . | 커밋취소 3가지 . HEAD뒤에 눈웃음 한개 ^ --soft : commit만 취소 + add + 내용물 그대로 | (mixed) : commt취소 + add취소 + 내용물만 그대로(unstaged) | --hard : commit취소 + add취소 + 내용물취소 | . | . . | . HEAD와 ^, ~숫자 . HEAD: 로컬 workingDir의 현재 작업중인 커밋 switch하면 작업폴더, 작업하는곳도 바뀌니 head도 바뀐다. | add만 했다면? 커밋이 아직 아니므로 HEAD가 보고 있진 않다. | . | HEAD^: 현재작업중 커밋의 부모커밋 ^^ : 부모의부모 | ~3 : ^^^쓰지말고, 3단계 전 커밋 | . | . 다시git reset HEAD 살펴보기with 돌아가서 자연스럽게 취소 . add 취소 . 커밋이 아니므로, HEAD는 아직 안보고 있다. . | 그래서 git reset HEAD를 하게 되면, HEAD커밋을 삭제하는게 아니라 git reset [여기] = [여기]로 돌아가겠다 = 해당커밋이후로 add는 커밋은 필요없다. 자연스럽게 add를 취소 . . | . | 커밋취소 . git reset HEAD^ 현재의 부모커밋으로 가고 싶다. . | 를 통해서 현재커밋을 취소 . . | . | 작업중에 다른작업요청시 commit도 reset도 애매한 임시저장: git stash . 로그인 브랜치에서 작업중인데, 갑자기 로그아웃 브랜치를 수정해달라고함. . 브랜치를 정리해야지만 브랜치변경이 가능함. 커밋한다음 reset을 해도되긴하겠지만,,, | . | 커밋하기엔 미완성, 작업물을 날릴순 없다. 임시저장으로 정리 | . | 현재 어느정도는 add된 상태 . unstage된 = add되지 않는 파일도 있음. . . | add, unstage 다 합쳐서 사진을 스태시! 하고 찍는다. . git stash . . 커밋이후의 상황들 전체가 stash 바구니에 담기게 됨. . . | . | 바구니에 담기면 사라진다. . | . | git stash pop을 통해 stash바구니에서 꺼내면 다시 적용된다. . . stack처럼 pop으로 나온다. | . | git stash, git stash pop 이외에 git stash list도 있다. . | . 마지막 커밋 변경(내용추가, 메세지변경): git commit –amend . . 마지막 커밋A에 일부만 빠졌다? 3을 빼고 1,2만 add 및 커밋한 상태 | 3을 git add한 뒤 git commit --amend | . | 그냥 커밋메세지만 변경 git commit --amend -m &quot;메세지&quot; | . | . merge말고 1줄로 합치는데, 상대주는놈branch 위에 올려서 합칠 때:git rebase . 내 브랜치들을 주는놈branch 위에서 적용시키고 싶을 때 . 최근브랜치가 내꺼가 되면서, 내가 주는놈 위에 적용됨. | . . . | 주의할점으로, 주는놈위에 쌓아올려질 때, 그대로 가는게 아니라 커밋해쉬가 달라짐 . | . merge vs rebase . . merge와 비교 장점: 커밋해쉬 유지 및 흐름 유지되어 돌아갈 수 있음 | 단점: merge라는 불필요커밋을 생성함. | . | rebase 장점: 주는놈위에 받는놈위주로 정리가 됨. 깨끗한 커밋 히스토리가 됨. | . | . 커밋 합침, 삭제 등 커밋 히스토리 조절: git rebase -i . . pull받은이후 rebase로 커밋해쉬가 바뀌었다면? 어쩔수 없이 git push –force . . remote branch2개를 잘 받아왔다. . | 이후 git rebase(주는놈위에 쌓아서 합침)로 내 커밋해쉬가 바뀌었다면? . . 이 상태에서 git push하면 reject된다. | . | 어쩔수 없이 git push --force로 덮어씌워야함. . | 협업중엔 조심해야한다. . 남자가 rebase후 푸쉬포스로 덮어씌워진다면,, . . | 같은 브랜치 협업중에는 미리 말안하는 이상 rebase 및 push force를 하면 안될듯 . | . | . alias . git push까지 . status diff add cache? commit log | . | git폴더에 . . | 내 환경설정에 . | 참고 . 히데쿠마 설정 . ## alias # git alias gst=&#39;git status&#39; alias gc=&#39;git commit&#39; alias gm=&#39;git merge&#39; alias gr=&#39;git reset&#39; alias ga=&#39;git add&#39; alias gaa=&#39;git add --all&#39; alias gloga=&#39;git log --oneline --decorate --color --graph --all&#39; alias glog=&#39;git log --oneline --decorate --color --graph&#39; alias gco=&#39;git checkout&#39; alias gb=&#39;git branch&#39; alias gcb=&#39;git branch | fzf -m | xargs git checkout&#39; alias gmb=&#39;git branch | fzf -m | xargs git merge&#39; alias gdb=&#39;git branch | fzf -m | xargs git branch -D&#39; alias gp=&#39;git push&#39; alias gf=&#39;git fetch&#39; alias gl=&#39;git pull&#39; alias gd=&#39;git diff&#39; alias ghf=&#39;git ls-files -v | grep &quot;^h&quot; | cut -c3-&#39; # dkr alias dkr=&#39;docker&#39; alias dkrp=&#39;docker-compose&#39; # for docker #sudo mount --bind /mnt/c /c sudo mount --bind /mnt/d /d export DOCKER_HOST=tcp://0.0.0.0:2375 # basic alias dotfiles=&#39;cd ~/dotfiles&#39; alias ll=&#39;ls -al&#39; alias l=&#39;clear &amp;&amp; ls -al&#39; #alias cdd=&#39;cd /d/&#39; alias ws=&#39;cd /d/workspace&#39; #alias solup=&#39;cd /d/workspace/solup&#39; alias echost=&#39;cd /d/workspace/solup/echost&#39; alias 12r=&#39;cd /d/workspace/solup/12r&#39; alias private=&#39;cd /d/workspace/private&#39; alias ..=&#39;cd ..&#39; alias ..2=&#39;.. &amp;&amp; ..&#39; alias ..3=&#39;..2 &amp;&amp; ..&#39; # some more ls aliases #alias ll=&#39;ls -alF&#39; alias la=&#39;ls -A&#39; #alias l=&#39;ls -CF&#39; # Add an &quot;alert&quot; alias for long running commands. Use like so: # sleep 10; alert alias alert=&#39;notify-send --urgency=low -i &quot;$([ $? = 0 ] &amp;&amp; echo terminal || echo error)&quot; &quot;$(history|tail -n1|sed -e &#39; &#39;&#39;s/^ s*[0-9] + s*//;s/[;&amp;|] s*alert$//&#39; &#39;&#39;)&quot;&#39; # for python alias python=&#39;python3&#39; alias pip=&#39;pip3&#39; export WORKON_HOME=~/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=&#39;/usr/bin/python3&#39; # Usage of python3 source ~/.local/bin/virtualenvwrapper.sh # for pyenv export PYENV_ROOT=&quot;$HOME/.pyenv&quot; export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot; export PYTHON_CONFIGURE_OPTS=&quot;--enable-shared&quot; export PYENV_VIRTUALENV_DISABLE_PROMPT=1 if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then eval &quot;$(pyenv init -)&quot; eval &quot;$(pyenv virtualenv-init -)&quot; fi . | . | .",
            "url": "blog.chojaeseong.com/git/2021/10/15/%EA%B9%832_%EA%B9%83%EA%B8%B0%EB%B3%B8(vscode)_%EA%B9%83%EC%8B%AC%ED%99%941(vscode)_%EA%B9%83%EC%8B%AC%ED%99%942(%EA%B0%9C%EB%85%90).html",
            "relUrl": "/git/2021/10/15/%EA%B9%832_%EA%B9%83%EA%B8%B0%EB%B3%B8(vscode)_%EA%B9%83%EC%8B%AC%ED%99%941(vscode)_%EA%B9%83%EC%8B%AC%ED%99%942(%EA%B0%9C%EB%85%90).html",
            "date": " • Oct 15, 2021"
        }
        
    
  
    
        ,"post49": {
            "title": "기본) commit&tag/revert&reset/branch",
            "content": "타인repo를 clone후 commit, tag 코드 옮겨다니기 . 실습레포: /home/is2js/workspace/git-test | Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . commit_hash or tag로 점프: git checkout [hash or tag] . 환경변수를 파악하고 code . . | vscode로 리조지토리 초기화 . | vscode push 버튼으로 올리기 . . | git fetch는 해두는 게 좋다 . 내 repo에 누가 작업을 추가했는지 파악만 해주는 것 | . | 강의별로 commit을 한다면? . 커밋별로 tag를 추가로 만들어준다. . | 예를 들어 . 5화 작업 . 5화 커밋 git tag 5 | . | . | 6화 작업 . 6화 커밋 git tag 6 | . | . | push by vscode push버튼 . . | . | . | git checkout [git_id]으로 5화 이전의 4화로 점프띄어보자. . 4화 부분의 git id 복사 . | 해당 폴더의 vscode 터미널에서 git checkout [git_id] . git checkout fefc0cacbf262ae0794e64a632afa2da095b622a . 이때 brunch자체가 [git_id]로 변하면서 과거로 돌아간다 | . | 현재로 돌아오려면, 기존 branch(master)로 checkout한다 . git checkout master . | . | git checkout [tag명]으로 점프띄어보자 . 각 커밋마다 커밋후 쉬운 이름표인 tag를 만들어준다. . 아까 5화 작업 끝나고, git tag 5 . 5화 끝난후의 소스를 보고 싶을 땐 이렇게 이동한다 . #git checkout [tag명] git checkout 5 . . | . | . | 다 참조가 끝났다면, 다시 최근소스의 branch로 오면된다. . git checkout master . | . | tag는 대신 따로 push를 해줘야한다. . 커밋들을 push한거로는 tag까지 push가 안됨. | . git push --tags . 버튼으로는 잘 안보이고 팔레트 &gt; push 검색 &gt; git push tags를 선택해준다. . | 참고) . 맨첨 커밋에는 0.0.0의 tag를 만들어주고 . | 그 이후로는 1.0.0부터 쭉 만들면된다. . . | . | . | . 내 repo 돌아가기, 되돌리기 . 기본 세팅 . /home/is2js/workspace/git-practice | . 소스트리 설치 . vscode에서는 설정(ctrl+,)에서 exclude 검색후 .git을 삭제하여 보이게 하기 | . | 디렉토리에서 vscode열기 . vscode 터미널 열여서 git설정 저장하기 . git config --global user.name &quot;is2js&quot; git config --global user.name &quot;tingstyle1@gmail.com&quot; . | . | .git폴더를 삭제후 소스트리에서 해보기 . create를 통해 해당폴더를 선택해서 만들어준다. 이미 폴더가 있는데 이 내부에 .git생성할까 물어보면 OK | . | . | 2개의 파일을 만들고 이 상태를 저장하기 . cat | mouse | . | git status(gst)를 통해 아직 untracked 파일들 확인 후 add . git add -A . git status . | 메세지(-m)와 함께 묻기(commit 해주기) git commit -m &quot;First commit&quot; . | 묻은 것을 소스트리에서 확인해보기 . 터미널에서 히스토리 확인하기 git log --oneline . | 소스트리는 git status없이 묻을 파일을 자동으로 알려준다. . vscode도 extensiont쪽에 알려줌? | dog라는 파일을 만들고 소스트리에서 확인해서 add + 커밋까지해보자. | . | . | 파일 삭제 + 변경 + 생성을 한꺼번에 한 뒤 git status로 보자. 삭제+변경과 생성을 따로따로 알려주며 다 알려주긴 한다. | 소스트리도 아이콘으로 알려준다. | . | git log로 이때까지 묻은 캡슐들을 한꺼번에 볼 수 있음. 소스트리에서는 History탭에서 보면 된다. . . | 과감한 돌아가기: git reset [commit_hash] –hard . . 돌아갈때는 과감한방법과 신중한방법이 있다. . 과감한방법(--hard) : 복원이후시점은 완전히 지우겠다. . git log상의 commit_id 앞6글자만 복사후 . | git reset [commit_id] --hard . . | . | 다시 한번 cat삭제 + dog이름변경 + 펭귄추가를 해주고 commit한뒤 소스트리로 reset –hard해보자. . 이 커밋까지 현재브린치를 초기화 | Hard(버림) 선택 | . | . | 신중한방법(--soft): 시점만 돌아가고 + 그 이후는 커밋되지 않은 상태로 파일은 유지 . | . (반대동작으로 취소시켜, 돌아갈 미래를 남긴체) 되돌리기 : git revert . **[reset으로 돌아갈 수 있는 미래]를 남겨두기 위해, [반대동작으로 취소시켜] 되돌리기 ** . | 다시 3번째 커밋까지 만들어준다. | 이번에는 돌아갈시점 6자리 for reset이 아닌 취소할 시점 6자리 for revert를 git log에서 찾는다. 취소할 커밋을 revert(취소)했다는 커밋이 그대로 이어서 남는다. 소스트리를 통해 확인하면, 정확히 취소할 커밋이, 커밋시 수행한 동작을 정확히 반대로 수행하여 취소함. | 취소할커밋이 커밋기록으로 남아있으니, reset --hard(이 커밋까지 현재브런치를 초기화)을 통한 해당 커밋으로 과감하게 돌아갈 수도 있다. | . | . | **즉, [reset으로 돌아갈 수 있는 미래]를 남겨두는 [반대동작으로 취소시켜] 되돌리기 ** | . 가장 최근 것을 revert로 취소시켜보자. . git log . 제일 최근시점을 취소시키기 위해, 최근 커밋(현재커밋) 6글자 복붙 | . | git revert [취소시점6자리] + :wq . 커밋메세지 작성화면으로 들어온다. | 여기선 :wq로 나와야 해당 revert 커밋메세지가 전달된다. | . | 3번째 커밋이 취소된 것을 파일이 reset처럼 과거상태로 돌아감을 보면 알 수 있다. . | git log를 확인해보니, 돌아간시점이후로 가 삭제된 것(reset –hard, 과감한 돌아가기)가 아니라 새 커밋이 형성되었다. . 소스트리에서 보아도 3번째 커밋을 상쇄시키는 커밋이 추가로 발생함 | . . 자세히 보면, 소스트리를 통해 확인하면, 정확히 취소할 커밋이, 커밋시 수행한 동작을 정확히 반대로 수행하여 취소함 3번째 커밋(취소할 커밋) 때 한 동작들 | 4번째 커밋인 3번째 커밋을 취소함(revert)를 할때의 동작들 | . | . | revert를 통해 취소할커밋도 reset-hard와 다르게 기록으로 남아있으니 reset을 통해 취소하기 전의 3번째 커밋상태로 과감하게 돌아갈 수도 있다. . . | 소스트리를 통한 revert는 커밋 되돌리기다. . 역시.. (반대동작으로 취소시켜) 되돌리기 = revert . 커밋 되돌리기 == 반대동작을 통해 해당 커밋을 취소시킴 . . | . | . | 내repo branch(평행우주) 만들기 for 기존플젝에 새로운 도전 . 회사 프로젝트를 내가 함부로 수정할 수 없으니 현재 프로젝트에서 다른 시도를 해보고 싶을 때, branch를 만들어 평행우주로 넘어간다. | . | . 평행우주로 이동도:git checkout [브랜] or 더블클릭 in 소스트리 . 브랜치 생성 . 브랜치 : 현 시점에서 2개의 미래로 분기를 시작하겠다. 현 시점과 동일한 상태 그대로 가져가면서 분기함. | . | . #git branch [만들 브랜치명] git branch my-idea . . 확인은 git branch만 . . | . | 브랜치 이동도 git checkout . 과거로 점프갔다오기 : git checkout [commit_id or tag] . 과거로 돌아가기 : git reset –hard or git revert [commit_id] | . | 과거가 아닌 현재-&gt;다른평행우주(branch)로 이동도 git checkout + 브랜치명 . #git checktout [브랜치명]git checktout my-idea . . branch변경해도, 내 파일상태에는 변함이 없음. 현재 상태를 그대로 가지고 평행우주를 만들어서 | . | . | 데이터 변경 후 커밋하기 in my-idea브랜치 . mouse 삭제, dinosaur 추가 . 용이름 둘리 | . | 현 branch에서 커밋하기 . git add -Agit commit -m &quot;Add dino&quot; . . | . | 상사가 부를 땐, 원래 우주로 돌아간다. . 원래 브랜치는 master였다. . 이동 전 . | 이동 후 (파일이 원래대로 돌아옴) . git checkout master . . | . | git을 처음 배울때는 파일이 잘못될까바 불안해서 사용안할 수도 있는데, 앞으로 계속 사용해보자~ . | . | 소스트리에서 다시 해보자. 더블클릭으로도 우주를 왔다갔다 하며 확인할 수 있다. . 브랜치 부분에 my-idea가 추가됨. 여기서 각 브랜치를 더블클릭할 때마다, vscode의 파일도 같이 바뀌더라. | . | 브랜치에서 새 브랜치 따기 . my-idea로 checkout된 상태에서, 상단의 브랜치탭에서 새로 생성해보자. . 이 때, 새 브랜치로 체크아웃을 체크해주면, 자동으로 새 브랜치로 넘어가진 상태가 된다. | . . my-idea에서 파생된 브랜치라 그 상태를 그대로 가져갔다. | . | 브랜치의 브랜치 상태에서, 데이터를 변경후 커밋까지 . cat 이름을 변경:tom to nyang | . . | 연결된 3개의 평행우주에서 상황맞이 . 상사가 master의 내용을 바꾸길 원함. . . 요구 대로 바꿔고, commit한다. . git add -Agit commit -m &quot;EDIT dog name&quot; . . | . | 평행우주에서, 타 브랜치의 base가 되는 branch(여기선 maser)가 한발(commit) 나서게 되면, 분기된 branch가 나눠서 그려진다. . . | 다른 우주(의지를 이은 가장 바깥가지 브랜치)에서 변화 가져오기: [ 받을놈branch이동후] git merge [줄놈branch] . 현재 메인프로젝트 master의 변경내용과는 서로다른 평행우주끼리 다른파일 수정이라면, 브랜치의 브랜치라도 편하게 master로 merge되는 것을 권유할 수 있다. . 아래 내용을 상사에게 권해본다. . my-idea에서 mouse삭제 후 dino 추가했고 | my-idea - my-another-idea에서 cat이름을 변경했는데 이것들을 메인프로젝트에 적용해도될까요? Okay 승인 | . | . . | 2개의 평행우주에서 일어난 일을 master브랜치로 가져야가한다. . 이 때, 브랜치1의 브랜치2는 생성부터 브랜치1의 변화를 그대로 가져와서 생성되므로 브랜치2만 반영시키면 된다. . . | . | . | merge를 위해서는 . 먼저 받는놈 브랜치(master)로 이동(checkout)한 상태여야한다. . git merge [줄놈 브랜치명] | . git checkout mastergit merge my-another-idea . . | 변화를 보니 master의 상사지시 + 평행우주에서 한 것들이 모두 반영되어있다. . master에서의 dog name to 바꾼 것도 반영되어이있지만 | my-another-idea에서의 쥐삭제+용추가 한 것도 동시에 반영된 상태다. | . | . | 확인은 . 소스트리 | vscode git graph가 아니라면 | git log --graph --all --decorate로 확인하란다 git log --graph --oneline정도면 충분할듯? | . | . | reset –hard로 merge전으로 돌아간 후, 소스트리로 merge하기 . 소스트리로 실습하기 위해 merge전으로 돌아가보자. | . merge 직전의 받는놈 브랜치의 가장 마지막 커밋 == merge전 커밋으로 . git reset –hard . | 소스트리: 이 커밋까지 현재 브랜치를 초기화 . . | . | 소스트리로 merge하려면 더 간단한데 받는놈의 branch를 더블클릭해서 이동 | 주는놈 branch를 우클릭 &gt; 현재 브랜치(받는놈 더블클릭 상태)로 my-another-idea(주는놈, 우클리상태) 병합 | . | 나중에는.. 수많은 폴더와 파일을 다뤄야하기 때문에, 기존프로젝트에 새 도전을 하려면 반드시 git branch써야함. | . | 아름답지 않은 merge + conflict후에는 메세지없이 git commit . 원래 merge가 성공하면 git이 자동 add + commit까지 한다. | . bark-wang브랜치 생성후, dog 파일 수정 -&gt; commit . ❯ git branch bark-wang❯ git checkout bark-wangSwitched to branch &#39;bark-wang&#39;❯ git add -A❯ git commit -m &quot;EDIT dog file&quot; . . | 이제 받는놈인 master로 돌아와서 같은 dog파일 수정하자. . ❯ git checkout masterSwitched to branch &#39;master&#39;❯ git add -A❯ git commit -m &quot;EDIT dog file bar warlwarl&quot; . master가 한발짝 나가는 순간부터 분기가 갈라져 보인다. | . | 현재, master 와 bark-wang이 서로 같은 파일을 수정한 상태다. . 아까의 merge는 서로 다른파일이 수정된 상태라 merge가 쉽게 되었다. . | 한번 merge해보자 . ❯ git checkout masterAlready on &#39;master&#39;❯ git merge bark-wangAuto-merging dogCONFLICT (content): Merge conflict in dogAutomatic merge failed; fix conflicts and then commit the result. . . | . | merge시 conflict가 뜨는데 같은 파일을 여러 평행우주에서 수정했기 때문이다. conflic가 없었을 때의 merge는? merge를 자동으로 커밋까지 해주는 커밋메세지 확인이 떴었다. | . | terminal에 안내문이 뜬다 | 소스트리에서는 그래프가 회색으로 연결안되어있으면서 &quot;커밋하지 않은 변경사항&quot;의 상태로 뜬다. | vscode에서는 conflict된 부분을 나눠서 알려준다. | | conflict는 vscode에서 택1해서 지울건 지운 뒤, add후 git commit을 -m 없는 상태로 커밋을 날리면 자동으로 merge 메세지가 뜬다. . accept incoming ~ in vscode | . git add -Agit commit . . conflic후 commit은 메세지없이 git commit만 날리며 알아서 merge 메세지가 미리 작성되어있다. . . | . | 앞으로 다른 브랜치끼리는 같은파일을 수정안하도록 작업하면 merge가 편안해진다. | 다른우주도 1줄로 만들어 통합: git rebase(재배치) . 프로젝트의 성격에 따라 필요한 것을 선택해서 사용하면 된다. . . | 지금은 git log상 2갈래 정도만 나오지만 . 실제로는 엄청나게 많은 줄기가 생기게 된다. . . | . | 딱 1줄로 통합되도록 merge하는 방법이 git rebase다 . 소스트리상으로는 master(받는놈)에서 주는놈(bark-warl) 우클릭 &gt; 재배치(rebase)를 클릭한다. . . | 같은 파일을 건들인 상황이니 똑같이 conflict해결후 add+commit한다. . | 재배치가 끝나면 분기가1 줄로 나타난다. . 브랜치라도 합쳐지는 모양이 아니다. | . . | . | . 다 쓴 브랜치 삭제: git branch -D . rebase는 1줄로 받는놈(masetr)에 통합되어버린다. . 그럼 작업한 branch(주는놈)은 더이상 필요 없을 것이다. . | 대문자로 -D옵션을 준다 | 소스트리는 우클릭으로 바로 할 수 있다. | . ❯ git branch -D bark-wang Deleted branch bark-wang (was 5fefbe0). . ​ . | merge를 통해 분기가 합쳐졌던 branch들도 git branch -D로 삭제하였더니 . 분기 표기는 남아있는데, branch만 사라졌다. | . . | .",
            "url": "blog.chojaeseong.com/git/2021/10/14/%EA%B9%831_%EC%BB%A4%EB%B0%8B%ED%83%9C%EA%B7%B8%EC%9D%B4%EB%8F%99_%EB%8F%8C%EC%95%84%EA%B0%80%EA%B8%B0%EB%90%98%EB%8F%8C%EB%A6%AC%EA%B8%B0_%EB%B8%8C%EB%9E%9C%EC%B9%98.html",
            "relUrl": "/git/2021/10/14/%EA%B9%831_%EC%BB%A4%EB%B0%8B%ED%83%9C%EA%B7%B8%EC%9D%B4%EB%8F%99_%EB%8F%8C%EC%95%84%EA%B0%80%EA%B8%B0%EB%90%98%EB%8F%8C%EB%A6%AC%EA%B8%B0_%EB%B8%8C%EB%9E%9C%EC%B9%98.html",
            "date": " • Oct 14, 2021"
        }
        
    
  
    
        ,"post50": {
            "title": "winTerminal + Pyenv in Wsl2",
            "content": "chocolately로 초기 설치 . 관리자권한 powershell . 초코랫리 겟스타트 -&gt; 인스톨 코드 복붙 | 경고떠도됨. 관리자권한으로 다시 껐다 키기 | . | find pakage에서 terminal 검색후 설치 . choco install microsoft-windows-terminal . | python 3 검색후 3.9 설치 . choco install python3 . | vscode 설치 . choco install vscode . | git 설치 . choco install git . git config –global user.name “2js” . git config –global user.email “1@gmail” . | wsl2 설치 -&gt; 재부팅후 한번 더 실행 (-y -f ??) . choco install wsl2 -y -f . 참고사이트 . | 참고) 정식 가이드로 설치시 해주는 다운로드전 설정 . dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart # WSL 활성화 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart # VM platform 활성화 . | . | 관리자 권한으로 윈도우 가상화해주기 for wsl2 . Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All . bcdedit /set hypervisorlaunchtype auto . | AMD CPU SVM mode 설정 in Bios for ubuntu 실행 . del 로 bios 진입 . | advanced 진입(F7) . | OC(Overclock) 진입 . | advanced cpu configuration 진입 . | SVM node: Enable . 우측상단 X로 저장후 종료하기 | . | . | wsl2용 ubuntu1804 설치 -&gt; ms store에서 설치(choco는 update안된 버전이라고함) . msstore 사용시 ms계정 요구함 ~@hanmail.ent / ~54 | . | 설치 -&gt; 시작 | . | wsl명령어로 우분투 진입 default 계정 및 비번 설정 is2js / | ~213 | . | . | 항상 wsl접속으로 /mnt된 곳이 아니라 cd ~ (linux 홈폴더)를 한 상태에서 code ~/.zshrc 등의 설정을 하자. | Window Terminal 단축키 설정 . vscode와 비슷하게 추가 매핑해준다. . actions 부분에 추가해주면 된다. | . { &quot;command&quot;: &quot;find&quot;, // 검색키 매핑 // &quot;keys&quot;: &quot;ctrl+shift+f&quot;, &quot;keys&quot;: &quot;ctrl+shift+f&quot; }, // 수직분할 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;vertical&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+plus&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;vertical&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;ctrl+ &quot; }, // 수평분할 매핑(추가) //{ &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;horizontal&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+-&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;horizontal&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+0&quot; }, // 탭 끄기 매핑(추가) { &quot;command&quot;: &quot;closePane&quot;, &quot;keys&quot;: &quot;ctrl+w&quot; }, // 포커스key 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;down&quot; }, &quot;keys&quot;: &quot;alt+down&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;down&quot; }, &quot;keys&quot;: &quot;ctrl+alt+down&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;left&quot; }, &quot;keys&quot;: &quot;ctrl+alt+left&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;right&quot; }, &quot;keys&quot;: &quot;ctrl+alt+right&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;up&quot; }, &quot;keys&quot;: &quot;ctrl+alt+up&quot; }, // 창이동 단축키 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 0 }, &quot;keys&quot;: &quot;ctrl+alt+1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 0 }, &quot;keys&quot;: &quot;ctrl+1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 1 }, &quot;keys&quot;: &quot;ctrl+2&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 2 }, &quot;keys&quot;: &quot;ctrl+3&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 3 }, &quot;keys&quot;: &quot;ctrl+4&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 4 }, &quot;keys&quot;: &quot;ctrl+5&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 5 }, &quot;keys&quot;: &quot;ctrl+6&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 6 }, &quot;keys&quot;: &quot;ctrl+7&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 7 }, &quot;keys&quot;: &quot;ctrl+8&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 8 }, &quot;keys&quot;: &quot;ctrl+9&quot; }, // Rename a tab to &quot;Foo&quot; { &quot;command&quot;: { &quot;action&quot;: &quot;renameTab&quot;, &quot;title&quot;: &quot;server&quot; }, &quot;keys&quot;: &quot;f1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;renameTab&quot;, &quot;title&quot;: &quot;jupyter&quot; }, &quot;keys&quot;: &quot;f2&quot; }, . | . Window Terminal 및 wsl2 zsh 세팅 . 터미널에서 설정(ctrl+,) &gt; json파일열기 &gt; ubuntu이름을 wsl2로 바꾸고 . wsl2(ubuntu)의 guid를 복사해서 &gt; defaultProfile key에 넣어 기본 프로필로 설정 | . | Fira code설치후, WindowTerminal 및 vscode-editor + vscode terminal font 변경해주기 . 깃허브 &gt; zip파일 다운후 압축풀고 &gt; ttf 다 설치 . Terminal : 없던 defaults속 fontFace속성을 넣어서 폰트를 설정해준다. . | Vscode : font 검색후, 맨앞에 &quot;Fira code&quot; 추가 후 전체복사 . terminal font 검색 후 복붙 . “Fira code”, Consolas, ‘Courier New’, monospace . | . | . | . | zsh설치(zsh는 root로 설치) . sudo apt update &amp;&amp; upgrade . sudo apt install zsh . | oh my zsh(zsh) 설치 (ohmyzsh부터는 user로 설치?!) . github 들어가서 curl로 설치 명령어 날리기 . sh -c “$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)” . | . | ohmyzsh 플러그인 2개(자동완성, 하이라이팅) 설치 . zsh-syntax-highlighting . git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting . zsh-autosuggestions . git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions . .zshrc에 기입해주기 . code ~/.zshrc . plugin 검색 . plugins=(git) 에 공백으로 추가 해주기 . plugins=(git zsh-syntax-highlighting zsh-autosuggestions) . 나와서 . source ~/.zshrc . | . | p10k(ohmyzsh의 테마) 설치 . 깃허브 에서 ohmyzsh 클릭 후 ohmyzsh 하위폴더로 clone시켜주기 . git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k . | p10k를 zsh의 테마로 설정해주기 . code ~/.zshrc . theme검색후 ZSH_THEME=”robbyrussell”를 . ZSH_THEME=”powerlevel10k/powerlevel10k” . 로 변경 . source ~/.zshrc . | p10k configure 설정이 시작됨 . | . | ls -al 등이 파일명 배경색 직접 변경하기 . cd ~ . code ~/.zshrc . # change filname background color . LS_COLORS=”ow=01;36;40” &amp;&amp; export LS_COLORS . 위 내용 추가 . source ~/.zshrc . | Win-terminal 테마 생성 및 설정해주기 . terminalsplash.com에 들어가서 고른다. . VS code theme를 찾음. 아직 json내부에서 &quot;name&quot;이 없는 상태. | . | &quot;profiles&quot; 밑에 &quot;schemes&quot;에 **name을 추가해주면서 ** custom theme를 등록해야한다. . schemes 에 등록한 뒤, colorScheme로 사용된다 | . &quot;schemes&quot;: [ { &quot;name&quot; : &quot;VScode&quot;, &quot;background&quot; : &quot;#232323&quot;, &quot;black&quot; : &quot;#000000&quot;, &quot;blue&quot; : &quot;#579BD5&quot;, &quot;brightBlack&quot; : &quot;#797979&quot;, &quot;brightBlue&quot; : &quot;#9BDBFE&quot;, &quot;brightCyan&quot; : &quot;#2BC4E2&quot;, &quot;brightGreen&quot; : &quot;#1AD69C&quot;, &quot;brightPurple&quot; : &quot;#DF89DD&quot;, &quot;brightRed&quot; : &quot;#F6645D&quot;, &quot;brightWhite&quot; : &quot;#EAEAEA&quot;, &quot;brightYellow&quot; : &quot;#F6F353&quot;, &quot;cyan&quot; : &quot;#00B6D6&quot;, &quot;foreground&quot; : &quot;#D3D3D3&quot;, &quot;green&quot; : &quot;#3FC48A&quot;, &quot;purple&quot; : &quot;#CA5BC8&quot;, &quot;red&quot; : &quot;#D8473F&quot;, &quot;white&quot; : &quot;#EAEAEA&quot;, &quot;yellow&quot; : &quot;#D7BA7D&quot; }, ], . | wsl2(ubuntu)와 win-terminal or terminal 전에 colorScheme으로 지정해준다. . { &quot;guid&quot;: &quot;{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}&quot;, &quot;name&quot;: &quot;Wsl2&quot;, &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot;, &quot;colorScheme&quot; : &quot;VScode&quot;, }, { // Make changes here to the powershell.exe profile. &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;, &quot;name&quot;: &quot;Windows PowerShell&quot;, &quot;commandline&quot;: &quot;powershell.exe&quot;, &quot;hidden&quot;: false, &quot;colorScheme&quot; : &quot;VScode&quot;, }, . &quot;profiles&quot;: { &quot;defaults&quot;: { // Put settings here that you want to apply to all profiles. &quot;fontFace&quot; : &quot;Fira Code&quot;, &quot;colorScheme&quot; : &quot;VScode&quot;, }, . | . | wsl2 계정 및 폴더 설정 in win10 . 항상 특정유저로 wsl2 진입 . /etc/wsl.conf 없으면 생성 . sudo vi /etc/wsl.confg . [user] default=is2js . | . 윈도우 탐색기에 wsl2경로 네트워크로 만들기 . 윈도우( )탐색기 창에서는 wsl$ 로 우분투로 접속가능하다. config등 경로에서는 //wsl$의 슬래쉬로 사용된다. | 참고) 윈도우탐색기상 wt -d .을 통해, 현재경로에서 윈도우 터미널 열기 | . | . wsl 쉘 킨 상태로 연결유지 | 탐색기 &gt; 내PC 우클릭 &gt; 네트워크 위치 추가 사용자 지정 네트워크 위치 선택 | [인터넷 또는 네트워크주소] 부분에 wsl$입력후 찾아보기 | 원하는 경로선택하기 : 우분투/home/is2js/workspace/ | 원하는 이름 입력 : is2js_workspace | . | 여기서 들어간 뒤 wt -d .로 윈도우 터미널(wsl)을 열면 될듯? | wsl2 ubuntu 기본설정 . 루트 계정 비밀번호 초기화참고 블로그 | 유저계정을 root 화시키기 참고 블로그 usermod -aG sudo [계정명]으로만 주기 | . | . openssl 설치 . sudo apt install openssl . | root의 기본 비밀번호 초기화 . sudo passwd root . # : 관리자 | $ : 일반유저 | . | 유저계정에 root권한부여 (파일3개 수정) . root계정으로 권한설정파일에 유저계정-&gt; root권한부여 . su . vi /etc/sudoers . 아래 root쪽에 내 계정도 추가하기 . # User privilege specification root ALL=(ALL:ALL) ALL is2js ALL=(ALL:ALL) ALL . | . wq! (readonly떠서 강제로 저장후 종료) . | root계정으로 비밀번호설정파일에 유저계정-&gt; root권한부여 . root항목처럼, root:x:0:0:root:/~f로 시작하는 부분에서 앞쪽0 : uid | 뒤쪽0: gid 관리자라면 둘다 0임. | 나는 뒤쪽 그룹id만 0으로줌. | . | . | . vi /etc/passwd . wq! . #is2js:x:1002?:1002?:,,,:/home/is2js:/usr/bin/zsh is2js:x:1002?:0:,,,:/home/is2js:/usr/bin/zsh . | root계정으로 그룹설정파일에 유저계정-&gt; root권한부여 . root가 대장인 0그룹에 추가를 해주면됨 . vi /etc/group . wq! . #root:x:0: root:x:0:is2js . | . | zsh 권한 에러시 . sudo chown -R ${LOGNAME}:staff $HOME . | wsl2-ubuntu 시작계정 설정하기 . powershell 에서 . ubuntu[1804] config --default-user [is2js] . | . | wsl2-ubuntu 시작폴더 설정하기 in WindowTerminal . 터미널의 wsl프로필에다가 옵션을 추가해줌 . 출저 | . &quot;startingDirectory&quot;:&quot; wsl$ Ubuntu-[20.04] home [myskan]&quot; . &quot;guid&quot;: &quot;{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}&quot;, &quot;name&quot;: &quot;Wsl2&quot;, &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot;, &quot;colorScheme&quot; : &quot;VScode&quot;, &quot;startingDirectory&quot;:&quot; wsl$ Ubuntu-18.04 home is2js&quot;, . | 참고 . wsl$ : 탐색기에서 우분투 폴더라도 바로 가기 | . | . | python-&gt;python3 매핑 . 참고블로그 | 더 좋은 블로그 | . Alternatives는 기본 커맨드의 심볼릭 링크를 관리해주는 리눅스 프로그램입니다. 데비안 계열의 리눅스(우분투)에서는 update-alternatives가 제공됩니다. . | 우분투(Ubuntu)를 설치하면 python path가 2.7로 설정되어 있습니다. . 리눅스의 Alternatives를 이용하면 python 버전을 쉽게 변경하고 관리할 수 있습니다. | . ❯ which python /usr/bin/python . python은 /usr/bin/python의 링크인데 | . ❯ ls -al /usr/bin/ | grep python lrwxrwxrwx 1 root root 9 Apr 16 2018 python -&gt; python2.7 lrwxrwxrwx 1 root root 16 Apr 16 2018 python-config -&gt; python2.7-config lrwxrwxrwx 1 root root 9 Apr 16 2018 python2 -&gt; python2.7 lrwxrwxrwx 1 root root 16 Apr 16 2018 python2-config -&gt; python2.7-config -rwxr-xr-x 1 root root 3633000 Feb 28 2021 python2.7 lrwxrwxrwx 1 root root 33 Feb 28 2021 python2.7-config -&gt; x86_64-linux-gnu-python2.7-config lrwxrwxrwx 1 root root 9 Oct 25 2018 python3 -&gt; python3.6 . ❯ ls -al /usr/bin/python lrwxrwxrwx 1 root root 9 Apr 16 2018 /usr/bin/python -&gt; python2.7 . /usr/bin/python 역시 실행파일이 아닌 /usr/bin/python2.7의 링크이다. . | **즉 ** . /usr/bin/python2.7 -&gt; /usr/bin/python -&gt; python | . | . | --config python로 python에 걸려있는 링크를 확인한다. . sudo update-alternatives --config python [sudo] password for is2js: update-alternatives: error: no alternatives for python . alternatives가 없다고 뜨면, 설정을 해줘야한다. | . | --install [symbolic link path(버전을 제외한 공통 경로)] python [real path(버전명시 경로)] [우선순위number]로 여러버전을 등록한다. . #sudo update-alternatives --install /usr/bin/python(버전제외 공통 경로) python(명령어=링크) /usr/bin/python3(버전명시 경로) 10(우선순위) . python2.7 등록 . sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 2 . | python3.6 등록 . 3.6 한개만 등록하고 해당 버전을 선택안해도 python -&gt; python3.6이 걸리도록 하면 된다. | . sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.6 1 . | . | (만약 2개이상 버전 등록했다면) 다시 한번 --config python으로 등록된 버전 확인 및 선택 . sudo update-alternatives --config python There are 2 choices for the alternative python (providing /usr/bin/python). Selection Path Priority Status * 0 /usr/bin/python2.7 2 auto mode 1 /usr/bin/python2.7 2 manual mode 2 /usr/bin/python3.6 1 manual mode Press &lt;enter&gt; to keep the current choice[*], or type selection number: 2 . | **버전을 선택해주면, python의 링크가 특정버전으로 옮겨져있다. ** . ❯ python -V Python 3.6.9 . | pip도 설정해준다. . 1개만 등록하면 pip -&gt; pip3가 될 것이다. | . ❯ sudo update-alternatives --config pip update-alternatives: error: no alternatives for pip . ❯ sudo update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 1 update-alternatives: using /usr/bin/pip3 to provide /usr/bin/pip (pip) in auto mode update-alternatives: warning: not replacing /usr/bin/pip with a lin . ❯ pip -V pip 9.0.1 from /usr/lib/python3/dist-packages (python 3.6) . | 1개만 alternative를 등록해서 python, pip를 default로 3버전으로 지정해주자. | . # pip3 install sudo apt-get update sudo apt-get install -y python3-pip pip3 --version # python3, pip3 alternatives command sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10 sudo update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 1 . python 가상환경 설정 . pip3 &amp; pyenv(격리된 python) 설치 . python3-pip 설치 . sudo apt update &amp;&amp; upgrade sudo apt install python3-pip pip3 -V pip3 --version . | pyenv 설치 . curl https://pyenv.run | bash . WARNING: seems you still have not added &#39;pyenv&#39; to the load path. # See the README for instructions on how to set up # your shell environment for Pyenv. # Load pyenv-virtualenv automatically by adding # the following to ~/.bashrc: eval &quot;$(pyenv virtualenv-init -)&quot; . clone한 pyenv디렉토리를 zshrc에 환경변수(PYENV_ROOT)로 직접지정해줘야한다. . cd ~ # wsl로 정상적으로 열릴려면, /mnt/상태에서 vscode를 열면 안된다. code ~/.zshrc . source ~/.zshrc . | pyenv사용전, 에러를 일으키는 미설치 패키지 다 설치하기 . sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev . | . | pyenv 사용법 . # 설치가능한 python list 확인하기 pyenv install --list # 원하는 python 버전 설치 pyenv install [파이썬버전] # 설치된 파이썬 버전 확인 pyenv versions # 가상환경 만들기 pyenv virtualenvs [파이썬버전] [가상환경명] # 가상환경 시작하기 pyenv activate [가상환경명] # 가상환경 끝내기 pyenv deactivate # 가상환경 목록 확인 pyenv virtualenvs # 가상환경 삭제하기 pyenv uninstall [가상환경명] ### 실사용 pyenv versions pyenv install 3.8.6 pyenv global 3.8.6 # 3.8.6을 pyenv 기본 python으로 지정 . python 저장위치 root -&gt; /root 가 홈폴더 유저의 경우 -&gt; /home/유저명이 홈폴더 | . | ~/.pyenv/ 라는 곳에 versions/폴더에 설치된다. github다. | . | virtualenvwrapper에서도 ~/.pyenv/versions/3.8에서 자동완성후 /3.8.6/bin/python을 이용한다. | . | . | virtualenv &amp; pyenv-virtualenvwrapper(격리된 python으로 가상환경 생성) 설치 . pip3로 virtualenv virtualenvwrapper 2개 패키지 설치 . pip install virtualenv virtualenvwrapper pip3 install virtualenv virtualenvwrapper #에러나므로 --upgrade까지 pip install --upgrade virtualenvwrapper pip3 install --upgrade virtualenvwrapper . | virtualenvwrapper 설정 . # virtualenv 설정 export WORKON_HOME=~/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python # /usr/bin/python3 . | pyenv-virtualenvwrapper 설치 . git clone https://github.com/pyenv/pyenv-virtualenvwrapper.git $(pyenv root)/plugins/pyenv-virtualenvwrapper . pyenv설정 추가 수정 . # pyenv clone후 경로 직접 지정 export PYENV_ROOT=&quot;$HOME/.pyenv&quot; export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot; if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then eval &quot;$(pyenv init -)&quot; fi pyenv virtualenvwrapper_lazy #에러나서 주석처리했다가 다시 풀어줌 . source ~/.zshrc . | virtualenv 추가 설정 . # virtualenv 설정 export WORKON_HOME=~/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python #source /usr/local/bin/virtualenvwrapper.sh source ~/.local/bin/virtualenvwrapper.sh . | . | 실사용 . pyenv install 3.8.6 pyenv versions #~/.pyenv/versions/ 에 격리된 파이썬들 버전명의 폴더에 설치됨. pyenv global 3.8.6 pyenv versions mkvirtualenv goglekaap which python #/home/is2js/.virtualenvs/goglekaap/bin/python deactivate workon # goglegkaap rmvirtualenv goglekaap # pyenv로 만든 python버전을 지정해서 가상환경 생성 mkvirtualenv -p ~/.pyenv/versions/3.8.6/bin/python goglekaap lsvirtualenv # workon이랑 동일한 듯. . # pyenv pyenv install [version] # Python 버전 설치 pyenv versions # 현재 설치된 Python 버전 목록 pyenv global [version] # 전역 Python 버전 변경 #virtualenv wrapper mkvirtualenv [project name] # 프로젝트를 위해 virtualenv 생성 workon [project name] # virtualenv 활성화 deactivate # virtualenv 비활성화 setvirtualenvproject # 현재 디렉토리를 프로젝트의 Home 디렉토리로 설정하기 rmvirtualenv [project name] # virtualenv 삭제 lsvirtualenv # virtualenv 목록 mkvirtualenv [가상환경이름] mkvirtualenv [-p ~/.pyenv/versions/3.8.6/bin/python] [tester(가상환경이름)] #가상환경이름으로 가상환경을 만들어준다. mkvirtualenv test -p [python-path]로 python 버전을 지정해 줄 수 있다. rmvirtualenv [ 가상환경이름] #해당 가상환경을 지운다. workon [가상환경이름] #해당 가상환경으로 진입한다. setvirtualenvproject # &lt;가상환경 진입상태 by workon&gt;에서 프로젝트 디렉토리로 이동 후, 해당 커맨드를 치면 디렉토리&lt;--&gt; 가상환경이 맵핑된다. 그러면 workon커맨드를 치는것 만으로 해당 디렉토리에 이동까지 시켜준다. 아주좋다. cdproject #setvirtualenvproject를 했을 경우, 현재 어디에 있든 해당 커맨드로 프로젝트 디렉토리에 이동이 가능하다. # 예를 들어, 아무폴더에서 workon [가상환경] -&gt; cdproject deactivate #가상환경에서 빠져나온다. . | 참고) path 관련 확인해보기 . python 설치(PATH) 확인 . linux에서는 python + tab, python3 + tab을 통해 깔린 버전을 간접적으로 파악 가능 python3로 자동완성된다면.. python3만 깔린 것 앞으로 모든 명령어 앞에 python+3 | . | . | python3 --help -m [모듈명] : mod로서, library모듈을 script로 실행시키는 옵션 pip, flask, venv 등에서 쓰임. 물론 패키지가 깔린상태여야함. | python3 -m venv [가상환경명] | . | -V : 버전확인 | -c &quot; python코드 &quot; : python코드를 바로 커맨드라인에서 실행함 | . | . win10 환경변수 path로 설치확인 . win+s 에서 환경 변수검색 &gt; 시스템 환경 변수 편집 . | 고급탭 &gt; 환경변수N &gt; 사용자 변수 or 시스템 변수 . 나는 초콜렛리로 설치하였더니 시스템 변수탭에 Path에 설치됨. C: Python39 Scripts : 스크립트 폴더를 더블클릭해서 가보기 | C: Python39 | . | | . | win10 or wsl2 python os모듈로 확인 . import os . | os.environ (dict) . os.environ.get(‘SHELL’) for wsl2 . os.environ.get(&#39;SHELL&#39;) &#39;/usr/bin/zsh&#39; . | . | python path로 실행가능한 python script만들기(앞에 python3 안달아도됨) . which python3 후 경로를 복사해놓는다. . /usr/bin/python3 | . | python 파일의 가장 위에 #! + python경로를 입력한 뒤, python 코드를 작성하면된다. . code calculate.py . #!/usr/bin/python3 def add(x,y): return x+y print(add(2,3)) . 결과물은 print만 되도록한다.(bash실행이라서?) | . | sudo chmod +x calculate.py . | 실행시 calculate.py가 아니라 ./calculate.py로 실행시킨다. . ./calculate.py | 에러 뜨면 sed -i &#39;s/ r$//&#39; calculate.py 실행후 다시 실행 | . | . | .",
            "url": "blog.chojaeseong.com/configuration/2021/10/13/%EC%84%B8%ED%8C%851_%EC%9C%88%EB%8F%84%EC%9A%B0_choco_terminal_wsl2_python.html",
            "relUrl": "/configuration/2021/10/13/%EC%84%B8%ED%8C%851_%EC%9C%88%EB%8F%84%EC%9A%B0_choco_terminal_wsl2_python.html",
            "date": " • Oct 13, 2021"
        }
        
    
  
    
        ,"post51": {
            "title": "vscode) python 실행용 tasks.json 기록",
            "content": "VScode . tasks.json . ctrl+shift+B로 python파일 빠르게 출력하기 함. . | 한번 눌러보고 설정&gt;템플릿생성&gt;Others&gt;기록 . | . { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;Project Label&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;python&quot;, &quot;args&quot;: [ &quot;${file}&quot; ], &quot;presentation&quot;: { &quot;reveal&quot;: &quot;always&quot;, &quot;panel&quot;: &quot;new&quot; }, &quot;options&quot;: { &quot;env&quot;: { &quot;PYTHONIOENCODING&quot;: &quot;UTF-8&quot; } }, &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true } } ] } .",
            "url": "blog.chojaeseong.com/configuration/2021/08/24/tasks.html",
            "relUrl": "/configuration/2021/08/24/tasks.html",
            "date": " • Aug 24, 2021"
        }
        
    
  
    
        ,"post52": {
            "title": "PT내용 기록.",
            "content": "스트레칭 . 양손꽉지 -&gt; 어깨내리고, 엄지세우고 -&gt; 턱을 위로 당기기 10초 | 양속 뒤로 꽉지 -&gt; 고개 아래로 잡아당기기 10초 | 고개회전+굴곡으로 대각선 아래보기 -&gt; 귀와 후두부사이를 4손가락으로 잡아서 아래로 당겨 승모근 늘이기 | 삼각근 늘려주기 코끼리코자세로 팔꿈치위쪽을 쭈욱 당긴 뒤 | 양쪽 어깨 내리고 | 다시 쭈욱 당기기 | . | 삼두근 늘이기 한손을 머리뒤로 넘기고 | 반대손으로 팔꿈치를 꾹 눌러 잠근다음 | 안쪽으로 쭉 당겨주기 | . | 꽉지끼고 허리 굴곡시켜주기 | 꽉지끼고 허리 측굴 시키기 꽉찌 위로 껴서 몸을 조금 측굴 후 | 엉덩이를 반대편으로 밀어서 완전히 측굴 | . | 허리 돌리기 양쪽방향 | . | 손목, 발목 돌리기 반대손으로 손목을 잡은 상태에서, 손목+발목 10, 반대10초 돌리기 | . | 상완전완 . 2 트라이셉스(케이블)푸쉬 다운 p.26 . . . 25:28분 . 가슴 . 가슴운동하는 이유 : 중력에 의해 앞으로 쏠리는 게 편하여 생기는 라운드솔뎌의 단축된 가슴을 펴준다. . 가슴단축을 펴준다. | 프레임이 커진다. 등운동과 같이해서 크게한다. | 푸쉬업보다 벤치프레스가 가동범위가 크다. | . | . 1-1덤벨(벤치) 프레스 p.83 . . . 1주차, 2~4kg 허리 아픈 환자는 벤치위에 양발을 올린 상태해서 하면 편하다 | . | . 준비 : 허리아치 + 어깨 내림 + 견갑골 양간 잡아주기 bar로 하듯이 잡은 상태로 팔을 편 상태가 시작. | . | 아령은 앞으로 넘어갈 때의 전완에 힘이 들어오는 선에서 | 수직선으로 내려갔다가 그대로 올려줌(모으는 느낌X) 속도는 빠르게 | . | 1-2덤벨 플라이 p.84 . . 가슴을 이완시켜 가슴 안쪽을 채워주는 운동 여성분들의 벌어진 가슴을 모음 | 남성분들은 가슴 볼륨감을 높혀줌 | . | . 허리아치 + 어깨 내림 + 견갑골 양간 잡아주기 | 팔꿈치는 수직으로 내려가고 손등은 땅바닥을 보는 방향으로 내려간다 약간 손목을 틀어주면서 해야하므로 좀 어려웠다. | . | 중력을 이용해서 내려가며 + 덤벨을 몸에서 최대한 멀리 다 피지말고 덤벨을 잡을 수 있게 약간만 전완이 굽어진 상태 | . | 어깨 . 가슴~팔을 중간 근육 | 등 운동할때도 포함되는 중간 근육 등, 가슴 근육을 눌려주는시 가운데서 버티는 역할 | . | . 1-3시티드 덤벨 프레스 p.41 . 덤벨프레스는 허리에 과부하가 가므로 반드시 앉아서(시티드) + 약간은 뒤로 기울인 상태로 등/엉덩이가 닿은 상태로 시행하자. | . . 엉덩이, 등을 딱 붙이고, 가슴 내밀고, 어깨 내린 상태에서 팔을 든 상태에서 시작. 허리통증이 없는 사람도 생기게 되니 주의 | . | 수직으로 내려오되, 이마가 아니라 정수리 라인까지 내려오게 한다. 옆에 거울 보면서 수직으로 해야 어깨로 드는 것. | . | 1-4사이드 래터럴 레이즈(사래레) p. 48 . . . 전면 삼각을 운동시키기 위해, 팔을 약간 내회전한 상태에서 시작한다. | . 대각선으로 올라간다. | 올라갔다가 바로 내려온다. 버티기X s | 대퇴, 둔부 . 2스쿼트 . . . 어깨보다 한발씩 더 벌린 상태로 발 앞꿈치로 땅바닥을 잡는다 생각하여 엉덩이를 뛰로 빼더라도 안넘어지도록 한다. | . | 약간 무릎을 바깥쪽으로 뺀 상태로 만들어 엉덩이에 자극을 주고 내려가면서 무릎은 더 바깥쪽으로 벌어져서 둔부가 자극되도록 해야한다 | 무릎이 앞으로 안나온다는 생각으로 엉덩이를 최대한 뒤로 빼면서 내려간다. | . | 허리 아픈 사람은 더 엉덩이로 보강해야해서 중요함. . | 10개 3~4세트 | . 하체 . 2런지 . . . 발을 골반너비 정도만(스쿼트는 어깨넓이) | 한쪽발을 뒤로 한뼘 | 반대발을 앞으로 그만큼 | 뒷발의 뒤꿈치를 확 올리면 앞으로 넘어간다 -&gt; 그만큼 앞으로 이동 | 중심잡기 힘들면 앞발만 바깥쪽으로 조금 회전시켜줌 | 앞무릎 고정상태에서 뒤꿈치 편상태로 뒷무릎만 내려갔다 올라온다. | 10개 3~4세트 . 복근, 기립근 . 크런치 . 팔꿉치가 앞으로 뻣어나간다고 생각하고 시행 | . 플랭크 . 발을 약간 벌려 앞으로 세우기 | 손의 위치랑 입이랑 위치 바꾸기 | 엉덩이는 계속 들고 있기 | 20초 2~3세트 | 슈퍼맨 운동 . 기립근을 직접적으로 키운다. . 대자로 뻗은 뒤 | 고개는 들지말고 팔과 다리를 들어서 1~2초간 버티고 돌아온다. |",
            "url": "blog.chojaeseong.com/pt/%EC%9A%B4%EB%8F%99/2021/08/23/PT.html",
            "relUrl": "/pt/%EC%9A%B4%EB%8F%99/2021/08/23/PT.html",
            "date": " • Aug 23, 2021"
        }
        
    
  
    
        ,"post53": {
            "title": "github index, badge 등 생성하여 꾸미기",
            "content": "참고사이트 . 참고 사이트 https://velog.io/@woo0_hooo/Github-github-profile-%EA%B0%84%EC%A7%80%EB%82%98%EA%B2%8C-%EA%BE%B8%EB%AF%B8%EA%B8%B0 | https://butter-shower.tistory.com/142 | https://velog.io/@colorful-stars/Github-%ED%94%84%EB%A1%9C%ED%95%84-%EA%BE%B8%EB%AF%B8%EA%B8%B0 | http://blog.cowkite.com/blog/2102241544/ | . | . github_id 이름으로 repo 생성 . github ID와 동일한 이름으로 repo만들기 + add Readme . local에 clone하여 환경 세팅하자. C:/jupyter_blog/ + is2js . . | . | capsule-render로 header/footer 작성 . typora에서 미리보기를 활용하여 header footer를 작성한다. . 각 옵션 목록 : https://github.com/kyechan99/capsule-render . | default(변경하면됨) . ![header](https://capsule-render.vercel.app/api?type=waving&amp;color=f6ebe1&amp;height=150&amp;section=header&amp;text=Data Engineer and KMD&amp;fontSize=50&amp;fontColor=152447&amp;desc=데이터 엔지니어를 꿈꾸는 한의사, 조재성입니다.&amp;descAlignY=80) ![footer](https://capsule-render.vercel.app/api?type=rect&amp;color=152447&amp;height=20&amp;section=footer) . . | . | sheilds.io로 기술 스택 badge작성 . shields.io를 통해 기술스택, 연락처 등의 스택아이콘 가져온다. . a태그 &gt; img태그 . | a태그는 링크주소를 / img는 badge를 여기를 통해서 편하게 가져온다. . 각 뱃지 목록 : https://github.com/alexandresanlim/Badges4-README.md-Profile | . &lt;p align=&quot;center&quot;&gt; &lt;a href=&quot;mailto:tingstyle1@gmail.com&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Gmail-d14836?style=flat-square&amp;logo=Gmail&amp;logoColor=white&amp;link=tingstyle1@gmail.com&quot;/&gt;&lt;/a&gt;&amp;nbsp &lt;a href=&quot;https://www.facebook.com/tingstyle1&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Facebook-1877F2?style=flat-square&amp;logo=facebook&amp;logoColor=white&quot;/&gt;&lt;/a&gt;&amp;nbsp &lt;a href=&quot;https://www.github.com/is2js&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/GitHub-100000?style=flat-square&amp;logo=github&amp;logoColor=white&quot;/&gt;&lt;/a&gt;&amp;nbsp &lt;/p&gt; . | . productive-box로 커밋시각 통계(gist) 노출(pinned)하기 . 참고 : http://blog.cowkite.com/blog/2102241544/ | . gist.github.com에 public으로 신규 public으로 바꾼 gist를 생성 . . | github토큰 생성 페이지로 가서 repo, gist를 포함한 scope를 설정한 뒤, 발급받은 토큰을 잘 챙겨둔다. . QQQghp_ysd0aOZbgsOJ3rOTAhj4QQQw4su6rrfPp1oc7WrQQQ . | productive-box repository를 fork한다. . 우측 상단의 Fork 버튼을 누르면 된다. . | fork 된 나의 repository의 Actions 탭에서 enabled 버튼을 눌러 Action을 활성화한다 . | .github/workflow/Schedule.yml . 파일을 수정하여 환경변수를 작성해준다 . uses: is2js/productive-box@master : 내github아이디로 바꿔준다? . maxam2017 -&gt; 내 아이디로 | . | GIST_ID: 사전 작업의 1번 step에서 생성된 gist의 id (gist URL은 gist.github.com//로 생성되기 때문에 주소창을 보면 된다.) 042e89789d6054e9b372e755e75f09f5 | . | TIMEZONE: 타임존을 적어준다. Asia/Seoul 형식으로 적어주면 된다. cf) cron : 분시일월주 cron예제 : https://ponyozzang.tistory.com/402 | . | . | . | . | 해당레포 &gt; Settings 탭 &gt; Secrets에 접속한 뒤 New repository secret 버튼을 클릭하여 환경변수를 설정해준다. . GH_TOKEN: 사전 작업의 2번 step에서 발급받은 토큰 . 토큰은 github &gt; secrets &gt; 환경변수에서 설정해주면, workflows.config.yaml을 그것을 이용한다. | . env: GH_TOKEN: $ . | . . | gist를 내 프로필 pinn에 고정시킨다. . | 내 블로그에 embed시킨다. . 아래 코드에서 gist주소만 복사해서 gist_id.js를 넣어주면 됨. | . | 깃허브 프로필 뱃지 얻기 . Github Developer program . https://developer.github.com/program/ 사이트에서 등록한다. . 2가지만 추가로 채워주면 된다. . | Highlights부분에 뱃지 생김 . . | . | 학생 PRO . 유효한 date를 포함하는, 학생증 찍어서 증명하는 부분이 생겨 나는 포기함. | . https://education.github.com 접속후 Student Developer Pack 클릭 . | Get pack &gt; Get Student benefits &gt; 아래쪽 학교인증 . github에 학교계정으로 email을 등록하고 와야한다. . . | . | 마지막에 plan을 Github Pro로 적어주면 된다. . | 증명서를 내라고한다. 나는.. 졸업해서 그냥 생략.. . | 북극곰 2020.02월 . 나는 우연히 그 때 만들어뒀나보다. | .",
            "url": "blog.chojaeseong.com/git/github/2021/08/19/github-profile.html",
            "relUrl": "/git/github/2021/08/19/github-profile.html",
            "date": " • Aug 19, 2021"
        }
        
    
  
    
        ,"post54": {
            "title": "powershell_vs_bashshell명령어",
            "content": "개요 . 출저 : 유튜브-드림코딩 . | 참고 : 티스토리 리눅스 명령어모음 블로그 . | 나는 Windows Terminal을 다운 받은 뒤, powershell vs wsl에서 실습하였다. . window의 powershell은 alias를 제공하여 unix shell과 비슷한 명령어를 사용할 수 있다. . . | . | 아직 많은 개발자들이 window를 사용함 . . | . powershell 최신버전 설치 . 링크 : https://docs.microsoft.com/ko-kr/powershell/scripting/install/installing-powershell-core-on-windows?view=powershell-7.1 | . 기본 명령어 . man, clear . manual의 약자다. 잘 모를 때 참고하는 명령어 . man man . | Get-Help 명령어를 링크 해놓은 것이다. . | 청소해주는 명령어 . | . man clear clear . 파일 탐색 . pwd(경로 확인) . Print Woring Directory의 약자 | . explorer.exe .(경로상 탐색기열기) . mac에서는 open .을 사용한다. . | explorer가 아니라 explorer.exe .연다. . | . ls [하위폴더] (경로상 파일목록) . list의 약자 . | powershell에서는 mode까지 같이 나오는 반면, . powershell은 ls만 가능하다. ls -l등의 format활용은 X. 처음부터 다 보여준다. . | wsl/mac에서는 파일명만 나온다. . ls -al, ls -atl 등을 활용하면 mode까지 같이 출력된다. | . | . . | . ls . format for WSL2 . ls -l : long의 약자 . . | ls -a : all의 약자 . ui상에서는 보여주지 않는 숨겨진 폴더, 파일을 보여준다. | . . | ls -al : all(숨겨진) + long(mode까지) . . | . format for Powershell . powershell의 ls는 기본적으로 long모드로 보여주는 듯 했다. . | ls -name : 이름만 보고 싶을 때 . mac, wsl의 ls기본과 똑같다. | . | ls -force : 숨겨진 폴더, 파일을 보고 싶을 때 . . | . 폴더이동 . cd [./../-/~] . change directory의 약자 . . : 현재 경로. cd .는 제자리 이동. . | .. : 상위 경로 . | ~ : **현재설정된 사용자의 최상위 폴더 = home 디렉토리 ** . powershell에서도 cd ~를 하면, C: Users 사용자 | wsl에서 cd ~를 하면, root계정 : /root | 특정사용자 : /Users/사용자 | . | . . | - : 직전경로 . powershell은 cd -가 안된다. -&gt; 7.14버전으로 업데이트 해보는 중. . 7버전으로 업데이트하면 된다… . . | 대신, 직전경로 1번만 사용가능하며, 이후 C: 로 이동된다.. . | . | . | . | . 파일, 디렉토리 찾기 . find [경로] -type [f/d] -name “*.*” for shell . 입력한 경로부터 시작하여 하위까지 해당 파일or폴더를 찾는다. . 예시 . 나같은 경우 -type file , -type directory해도 안되길래, f, d로 약어로 넣으니 됬다. | permission denied나니까, 관리자 모드로 접속하자. | . find . -type d -name &quot;*flask*&quot; . find . -type f -name &quot;*.csv&quot; . | . | . get-childitem for powershell . powershell사실상 안된다고 보면 된다. get-childitem -File -Filter &quot;*.txt&quot; -Recurse | . | . 프로그램 설치/설정 위치 . which for shell . 프로그램의 실행경로를 확인한다. . which node which code . | . gcm for powershell . get-command의 약자인 gcd를 이용한다. . | 경로는 창을 키워야 보임 . gcm node gcm code . | . 파일 생성 및 관리 . touch [파일명] (파일생성) . 존재하지 않으면, 파일 생성 | . man touch touch new_file1.txt . 이후 new_file1.txt를 열어 파일 | . new-item [파일명] for powershell . touch의 생성은 powershell에 없다. 하지만 cat, echo는 존재함. | . new-item new_file4.txt cat new_file4.txt . cat [파일] [파일2] (파일내용확인) . touch와 달리, powershell에도 사용가능함(alias존재) . | touch로 생성한 파일의 내용을 빠르게 확인 . 여러 파일을 동시에 쓰면, 붙혀서 string으로 확인됨. | . | . touch new_file2.txt cat new_file2.txt second line# cat new_file1.txt new_file2.txt first line 텍스트 추가second line# . echo “문자열” &gt;(») [파일] (&gt;파일생성+컨텐츠입력/ » 컨텐츠 추가) . 기본사용은 작성한 문자열을 터미널에 출력한다. (터미널에 에코~) 거의 사용안한다. | powershell에서도 사용가능하다. | &gt; [파일명]을 통해 파일생성+해당문자열을 컨텐츠로 넣어줌(덮어쓰기) | . echo &quot;third line&quot; &gt; new_file3.txt cat new_file3.txt third line . echo &quot;third line&quot; &gt; new_file3.txt cat new_file3.txt third line . &gt;&gt; [파일명] : 파일생성+덮어쓰기가 아니라 기존파일에 컨텐츠 append개념이다. | . echo &quot;third line--&quot; &gt;&gt; new_file3.txt cat new_file3.txt third line third line-- . 디렉토리 생성 . mkdir -p [폴더/하위폴더/하하위폴더] . make directory의 약자, 폴더 = 경로를 생성하는 명령어 | powershell 공용 | . mkdir dir1 ls -al . -p 옵션을 주면서 하위폴더들을 /로 연결하여 줄줄이 생성할 수 있다. | . mkdir -p dir2/subdir1/subdir2 ls dir2 subdir1 ls dir2/subdir1 subdir2 . 파일관리 cp/mv/rm . 3가지 다 powershell에서 사용가능 | . cp [파일] [원하는 경로/]or[새파일명] . copy의 약자 | . mv [파일] [원하는 경로/]or[새파일명] (파일이동/이름변경) . 이름바꾸는 것도 mv로 하는구나. . mv new_file2.txt file2.txt ll . | . rm [삭제파일명] / rm -r [디렉토리명] . -r 이라는 recursive옵션을 주면 디렉토리삭제+하위경로도 삭제 2가지 역할을 해주게 된다. 파일삭제는 rm 파일명 | 디렉토리삭제는 rm -r 디렉토리명 | . | . rm new_file4.txt rm -r dir3 . rm [디렉토리] 후 선택 / rm [디렉토리] -Recurse . 이부분 만 shell과 다름. | 그냥 rm하면 경고창(wsl)없이 선택화면이 나온다. 디렉토리를 선택하면됨. | 디렉토리 빠르게 삭제는 -r 옵션을 중간에 주는게 아니라 마지막에 -Recurse powershell에서도 마지막에 -r 줘도 삭제되는 듯 싶다. | . | . Grep (select-string) . Global regular expression print 의약자. . | 파일에서 검색 or *를 활용한 프로젝트 전체폴더에서 검색 . | . grep “검색문자열” [파일명] . grep &quot;line&quot; *.txt file2.txt:second line new_file1.txt:first line new_file3.txt:third line new_file3.txt:third line-- . grep -n : 라인정보 같이출력 . 찾은 것이 몇번째 라인에 있는지까지도 같이 출력 | . grep -n &quot;line&quot; *.txt file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . grep -ni : 대소문자상관없이 검색후 라인정보출력 . -i : intensive 옵션을 주면 대소문자 상관없이 검색하라는 말이다. | . grep -ni &quot;LINE&quot; *.txt file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . grep -nir “문자열” . : 프로젝트최상경로에서 하위끝까지 전체를 검색 . grep -nir &quot;LINE&quot; . ./file2.txt:1:second line ./new_file1.txt:1:first line ./new_file3.txt:1:third line ./new_file3.txt:2:third line-- . select-string [파일명] -pattern “검색문자열” . default로 대소문자상관없이 + 라인정보도 같이 출력된다. . select-string *.txt -pattern &quot;LINE&quot; file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . | . select-string [*, */*] -pattern “검색문자열” . -ni는 자동이고, -r 옵션은 없어서 직접 *와 ,를 연결한 경로를 지정(경로패턴)해줘야 전체 프로젝트 검색이 된다. | . select-string *, */* -pattern &quot;LINE&quot; file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . 대소문자를 구분하고 싶다면, 맨 뒤에 -CaseSensitive옵션을 주면 된다. | . 환경변수 설정 . 모바일, 웹 개발시 환경변수를 설정함 | 내 컴퓨터에서 특정한 키워드가 어떤 일을 하거나 경로를 저장할 수 있게 만드는 것. | . env . 지정한 환경변수 목록을 본다. 사용시에는 앞에 $를 붙인다. . env . | . ls env: . powershell에서 보는 환경변수목록. 사용시에는 $env:를 앞에 붙인다. . ls env: . | . export [대문자_변수명]=”경로or문자열” (환경변수 설정) . 대문자를 사용하고 사이에는 _를 이용하여 구분한다. . mkdir dir1 env # 모든 환경 변수 확인 export MY_DIR=&quot;dir1&quot; . | . $env:[환경변수명] = “경로or문자열” for powershell . $env:MY_DIR = &quot;dir1&quot; . cd $환경변수명 (환경변수 사용) . 환경변수를 터미널 등에서 사용할 수 있다. . cd $MY_DIR pwd . | . cd $env:[환경변수명] for powershell . unset 환경변수명 (환경변수 삭제) . unset MY_DIR env . $env:[환경변수명] = “” . powershell에서 환경변수 삭제는 빈 문자열을 넣어서 없애준다. . $env:MY_DIR = &quot;&quot; ls env: . | .",
            "url": "blog.chojaeseong.com/shell/powershell/windowsterminal/windows/2021/08/18/powershell_and_bashshell.html",
            "relUrl": "/shell/powershell/windowsterminal/windows/2021/08/18/powershell_and_bashshell.html",
            "date": " • Aug 18, 2021"
        }
        
    
  
    
        ,"post55": {
            "title": "윈도우 터미널 단축키 모음",
            "content": "단축키 . [ALT] + [SHIFT] + [+] : 가로 창 나누기 ![image-20210715145754288] | [ALT] + [SHIFT] + [-] : 세로 창 나누기 | [ALT] + [SHIFT] + [방향키] : 창 크기 조절 | [ALT] + [방향키] : 커서가 위치하는 창 전환 | [CTRL] + [L] : 클리어 | [CTRL] + [SHIFT] + [ W] : 창 닫기 | [ALT] + [SHIFT] + [D] : 쉘 복제 | [CTRL] + [+/-/마우스 휠] : 글자 크기 조절 | [CTRL] + [,] : 설정 | .",
            "url": "blog.chojaeseong.com/configuration/2021/08/18/WindowTerminal_shortcut.html",
            "relUrl": "/configuration/2021/08/18/WindowTerminal_shortcut.html",
            "date": " • Aug 18, 2021"
        }
        
    
  
    
        ,"post56": {
            "title": "알고리즘 문제 풀기용 array 연습 (python)",
            "content": "input array . 1&#52264;&#50896; list . 10 5 1 10 4 9 2 3 8 5 7 6 . a, b = map(int, input().split()) print(a, b) # 1개는 안된다. 튜플 언패킹시에만 따로 받아진다!! c = map(int, input().split()) print(c) . 10 5 &lt;map object at 0x000001F38F7937C0&gt; . arr = list( map(int, input().split()) ) arr . [1, 10, 4, 9, 2, 3, 8, 5, 7, 6] . 2&#52264;&#50896;(&#44396;&#48516;&#51088;O) . 9 0 0 0 1 1 1 -1 -1 -1 0 0 0 1 1 1 -1 -1 -1 0 0 0 1 1 1 -1 -1 -1 1 1 1 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 1 -1 0 1 -1 0 1 -1 0 -1 1 0 1 -1 0 1 -1 0 1 -1 1 0 -1 0 1 -1 . # - 행수만큼 list comp를 돌리고, # - 그 행의 내부요소들은 1줄을 split -&gt; map(int, ) -&gt; list 까지 만든다. N = int(input().strip()) # paper = [ for i in range(N)] paper = [ list(map(int, input().strip().split())) for i in range(N)] . paper . [[0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, -1, 0, 1, -1, 0, 1, -1], [0, -1, 1, 0, 1, -1, 0, 1, -1], [0, 1, -1, 1, 0, -1, 0, 1, -1]] . 2&#52264;&#50896; &#44396;&#48516;&#51088;X (&#49707;&#51088;&#47196; 1character&#50473;&#47564; &#52264;&#51648;) . 문자열(no split) -&gt; map(1글자를 1글자int로) -&gt; list(1글자들을 열로) | . 3 3 011 111 110 . list(&#39;1019&#39;) . [&#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;9&#39;] . list(map(int, &#39;1019&#39;)) . [1, 0, 1, 9] . # - split대신 list(&#39;문자열&#39;) -&gt; 1글자씩 list # - split대신 list( map(int, &#39;문자열&#39;)) -&gt; 숫자1개씩 list # -- map(int, &#39;문자열&#39;)은 문자열을 하나씩 쪼개받아서 int를씌운다. N, M = map(int, input().split()) # map은 튜플로 할당 받을 수 있다. but 1개 변수에 할당시는 맵객체다. # MIRO = [ for i in range(N) ] # 열은 갯수는 M대신 split이 아닌 문자열-&gt;map-&gt;list -&gt; list(map(())으로 쪼개서 받았다. MIRO = [ list(map(int, input())) for i in range(N) ] . MIRO . [[0, 1, 1], [1, 1, 1], [1, 1, 0]] . &#49440;&#50616; array . input으로 받아서 쪼개서 열을 만들지말고, 이번에는 직접 선언해보자. | numpy를 지원하지 않을 때, 리스트로 만드는 n차원 배열이다. | . INIT = -1 # 각 행렬 요소의 초기화 값이다. W = row = N H = column = M C = channel = 3 B = batch = 3 # 1차원 array : 초기화값이 요소 상태로 list comp D1 = [ INIT for _ in range(W)] # 1차원은 행길이만큼 list comp + [] X -&gt; 행길이만큼 요소롤 복제하도록 list comp + 요소 # D1 = [ INIT ] * N # 요소복제의 2번째 방법, list든 str든 곱하면 extend된다. # - but 내부 list comp 요소 + 외부 [] 그만큼 곱은 주의한다. id가 동일한놈들이 복사된다. # 2차원 array : 행[]들 먼저 행길이만큼 list comp돌고 , 내부 1row를 요소 list comp # D2 = [ [] for _ in range(H)] D2 = [ [ INIT for _ in range(W) ] for _ in range(H)] # 3차원 array : 2차원 밖에 [[]]행렬 갯수만큼 list comp 해줌. D3 = [[[ [ INIT for _ in range(W) ] for _ in range(H)]] for _ in range(C)] # 3차원 array : 2차원 밖에 [[]]행렬 갯수만큼 list comp 해줌. D4 = [[[[ [ INIT for _ in range(W) ] for _ in range(H)]] for _ in range(C)] for _ in range(B)] print(D1) print(D2) print(D3) print(D4) . [-1, -1, -1] [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]] [[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]] [[[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]], [[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]], [[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]]] . 2&#52264;&#50896; &#51025;&#50857; by range . INIT값이 아닌 1부터 순서대로 채운 N*N 행렬 range( , , 열길이)를 이용한다. N씩 건너뛰어서 가니까... | 시작은 1부터 n(n-1) + 2 로 1부터 n-1까지의 합으로 간다? | . | . 1&#48512;&#53552; &#49692;&#49436;&#45824;&#47196; &#52292;&#50868; (N,N)&#54665;&#47148; . 각행의 첫째항을 등차수열(column : N개) 를 이용해서 만들어준다. . 1부터 N의 등차수열 range(1, , N)과 끝값은 N번째항 뽑은 것 + 1 을 넣어준다 | An = a1 + (n-1)d = 1 + n(n-1) -&gt; range( , n*n-1 + 1, ) | . | 각 행렬의 첫째항부터 1씩 증가하여 N개를 채운 행list를 완성한다. . | # - 일단 1 ~ n*(n-1)/2 에서 마지막항의 의미는 그냥 찍어보면 모른다. n = 6 for i in range(1, n*(n-1)+2, n): print(i) print(n*(n-1)+2) . 1 7 13 19 25 31 32 . # - for문 안의 i가 1에서부터 **등차(k)수열**이 되어버림. # 1부터, 등차가 n이면, n열짜리 행1개를 건너띈 다음 행 첫째항이 된다. # 열의 갯수N을 등차로 하여 일반항을 잡고, 행 N개를 가야하므로 # An = 1 + (n-1)*d = n*(n-1) + 1 이 된다. # 등차수열 range(1, ,n)이 n번째항 까지는 가야하므로, n번째항+1을 넣어준 것이다. for i in range(1, n*(n-1)+2, n): print(i, &quot;&lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다.&quot;) . 1 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 7 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 13 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 19 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 25 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 31 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. . # 2중 list comp는 요소만 노출할 경우, 1차원 행렬밖에 # - list로 만들경우, 각 요소들이 list로.. # - 행단위로 묵어서는 못만든다 -&gt; result = [] for문 이용 n = 5 result = [] for i in range(1, n*(n-1)+2, n): # 첫째항 i, 등차1 의 수열을 1~n항까지 listcomp로 모으기 result.append([ i+(j-1)*1 for j in range(1, n+1)]) result . [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]] . # 행마다 돌면서 row에접근후 인덱싱.. [ row[4:6] for row in paper[4:7]] . [[0, 0], [0, 0], [1, -1]] . def check_valid(matrix): print(&quot;dict상태&gt;&gt;&gt;&quot;, count_dict) if len(matrix) == 1: print(&quot;1개짜리 돌입. matrix &gt;&gt;&gt;&quot;, matrix) # 1개짜리라면.. 넣고 +1 count_dict.setdefault(matrix[0][0], 0) count_dict[matrix[0][0]] +=1 return True paper_0_0 = matrix[0][0] flag = False for i in range(len(matrix)): for j in range(len(matrix)): if paper_0_0 != matrix[i][j]: flag = True break if flag: print(&quot;다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : &quot;,matrix ) N = len(matrix) # 3x3중 1x1 -&gt; 열 3구간 다 check_valid([ row[:N//3] for row in matrix[:N//3]]) check_valid([ row[N//3:(N//3)*2] for row in matrix[:N//3]]) check_valid([ row[(N//3)*2:] for row in matrix[:N//3]]) # 3x3중 2x2 check_valid([ row[:N//3] for row in matrix[N//3:(N//3)*2]]) check_valid([ row[N//3:(N//3)*2] for row in matrix[N//3:(N//3)*2]]) check_valid([ row[(N//3)*2:] for row in matrix[N//3:(N//3)*2]]) # 3x3중 3x3 check_valid([ row[:N//3] for row in matrix[(N//3)*2:]]) check_valid([ row[N//3:(N//3)*2] for row in matrix[(N//3)*2:]]) check_valid([ row[(N//3)*2:] for row in matrix[(N//3)*2:]]) else: print(&quot;다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix:&quot;, matrix) count_dict.setdefault(paper_0_0, 0) count_dict[paper_0_0] += 1 return True count_dict = {} check_valid(paper) . dict상태&gt;&gt;&gt; {} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, -1, 0, 1, -1, 0, 1, -1], [0, -1, 1, 0, 1, -1, 0, 1, -1], [0, 1, -1, 1, 0, -1, 0, 1, -1]] dict상태&gt;&gt;&gt; {} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] dict상태&gt;&gt;&gt; {0: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[1, 1, 1], [1, 1, 1], [1, 1, 1]] dict상태&gt;&gt;&gt; {0: 1, 1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]] dict상태&gt;&gt;&gt; {0: 1, 1: 1, -1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[1, 1, 1], [1, 1, 1], [1, 1, 1]] dict상태&gt;&gt;&gt; {0: 1, 1: 2, -1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] dict상태&gt;&gt;&gt; {0: 2, 1: 2, -1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] dict상태&gt;&gt;&gt; {0: 3, 1: 2, -1: 1} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 1, -1], [0, -1, 1], [0, 1, -1]] dict상태&gt;&gt;&gt; {0: 3, 1: 2, -1: 1} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 4, 1: 2, -1: 1} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 4, 1: 3, -1: 1} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 4, 1: 3, -1: 2} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 5, 1: 3, -1: 2} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 5, 1: 3, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 5, 1: 4, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 6, 1: 4, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 6, 1: 5, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 6, 1: 5, -1: 4} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 1, -1], [0, 1, -1], [1, 0, -1]] dict상태&gt;&gt;&gt; {0: 6, 1: 5, -1: 4} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 7, 1: 5, -1: 4} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 7, 1: 6, -1: 4} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 7, 1: 6, -1: 5} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 8, 1: 6, -1: 5} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 8, 1: 7, -1: 5} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 8, 1: 7, -1: 6} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 8, 1: 8, -1: 6} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 9, 1: 8, -1: 6} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 9, 1: 8, -1: 7} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 1, -1], [0, 1, -1], [0, 1, -1]] dict상태&gt;&gt;&gt; {0: 9, 1: 8, -1: 7} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 10, 1: 8, -1: 7} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 10, 1: 9, -1: 7} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 10, 1: 9, -1: 8} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 11, 1: 9, -1: 8} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 11, 1: 10, -1: 8} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 11, 1: 10, -1: 9} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 12, 1: 10, -1: 9} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 12, 1: 11, -1: 9} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] . print(*map(lambda x:x[1], sorted(count_dict.items(), key=lambda x:x[0]))) . 10 12 11 .",
            "url": "blog.chojaeseong.com/boj/python/array/2021/08/12/python_%EB%B0%B0%EC%97%B4_%EC%97%B0%EC%8A%B5.html",
            "relUrl": "/boj/python/array/2021/08/12/python_%EB%B0%B0%EC%97%B4_%EC%97%B0%EC%8A%B5.html",
            "date": " • Aug 12, 2021"
        }
        
    
  
    
        ,"post57": {
            "title": "파이썬을 파이썬답게 노트정리",
            "content": "&#52636;&#51200; . 파이썬을 파이썬답게 실습강의를 듣고 느낀점과 함께 풀어낸 노트입니다. | . &#44277;&#48512; &#51060;&#50976; . 정수를 담은 이차원 리스트, mylist 가 solution 함수의 파라미터로 주어집니다. mylist에 들은 각 원소의 길이를 담은 리스트를 리턴하도록 solution 함수를 작성해주세요. . 제한 조건 | mylist의 길이는 100 이하인 자연수입니다. | mylist 각 원소의 길이는 100 이하인 자연수입니다. | . | 위 문제를 아래와 같이 짰다면, 수강해야한다. 나는 list comp로 짬 . | . 아래와 같은 풀이는 c언어 or 자바 풀이임. . | 이것과 같이 짜야함 . | . 용어 설명 iterable: 자신의 멤버를 한 번에 하나씩 리턴할 수 있는 객체입니다. list, str, tuple, dict 등이 여기에 속합니다. | sequence: int 타입 인덱스를 통해, 원소에 접근할 수 있는 iterable 입니다. iterable의 하위 카테고리라고 생각하시면 됩니다. | list, str, tuple이 여기 속합니다. ( dictionary는 다양한 타입을 통해 원소에 접근할 수 있기 때문에 sequence에 속하지 않습니다.) | . | unpacking: 적절한 번역을 찾고 있습니다. | . | . &#51221;&#49688; (2) . &#47787;&#44284; &#45208;&#47672;&#51648; . 문제 설명 숫자 a, b가 주어졌을 때 a를 b로 나눈 몫과 a를 b로 나눈 나머지를 공백으로 구분해 출력해보세요. 입력 설명 입력으로는 공백으로 구분된 숫자가 두 개 주어집니다. 첫 번째 숫자는 a를 나타내며, 두 번째 숫자는 b를 나타냅니다. 출력 설명 a를 b로 나눈 몫과 a를 b로 나눈 나머지를 공백으로 구분해 출력하세요. 제한 조건 a와 b는 자연수입니다. . &#45236;&#54400;&#51060;(list comp) . input_ = &#39;5 3&#39; num_ = input_.strip().split(&#39; &#39;) a, b = [int(x) for x in num_] str(a//b) + &#39; &#39; + str(a%b) . &#39;1 2&#39; . &#45712;&#45184;&#51216; (divmod + unpacking) . divmod는 한번에 목과 나머지를 구한다. //, %보단 느리지만, 갯수가 많을 땐 더 빨라진다고 한다. | 데이터 변환을 list comp전에 map(str, ) map(int, )도 활용해보자. | tuple을 unpacking(콤마할당)을 하면, iterable객체(tuple)이 알아서 나뉜다. | . a, b = map(int, input_.strip().split(&#39; &#39;)) . a . 5 . b . 3 . divmod(a, b) # 순서대로 몫, 나머지를 반환함. . (1, 2) . print(*divmod(a, b)) #unpakcking을 print하면, 각각을 공백으로 나누어서 프린트해준다. . 1 2 . (&#52428;) n&#51652;&#48277;&#51004;&#47196; &#54364;&#44592;&#46108; string&#51012; 10&#51652;&#48277; &#49707;&#51088;&#47196; &#48320;&#54872;&#54616;&#44592; . 문제 설명 base 진법으로 표기된 숫자를 10진법 숫자 출력해보세요. 입력 설명 입력으로는 공백으로 구분된 숫자가 두 개 주어집니다. 첫 번째 숫자는 num을 나타내며, 두 번째 숫자는 base를 나타냅니다. 출력 설명 base 진법으로 표기된 num을 10진법 숫자로 출력해보세요. 제한 조건 base는 10 이하인 자연수입니다. num은 3000 이하인 자연수입니다. 예시 input output 12 3 5 444 5 124 입출력 예 설명 입출력 예 1 3진법으로 표기된 12는 10진법으로 표현하면 5입니다. ( 1*3 + 2 ) 입출력 예 2 5진법으로 표기된 444는 10진법으로 표현하면 124입니다. ( 455 + 4*5 + 4 ) . &#45236;&#54400;&#51060; . num, base = map(int, input().strip().split(&#39; &#39;)) div_sum = 0 for n in sorted(range(0, len(str(num))), reverse=True): k, num = divmod(num, 10**(n)) div_sum += k * (base**(n)) print(div_sum) . &#51221;&#45813; . n진법으로 표기된 string을 10진법 숫자로 변환하기 - int 함수 . 진법 변환 문제는 알고리즘 문제나 숙제로 자주 나오는 유형이지요. 이번 시간에는 n 진법으로 표기된 문자열을 10진법 숫자로 변환하는 방법을 배워봅시다. . 예시) 5진법으로 적힌 문자열 &#39;3212&#39;를 10진법으로 바꾸기 . 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통 사람들은 for 문을 이용해 숫자를 곱해가며 문제를 풉니다. . num = &#39;3212&#39; base = 5 answer = 0 for idx, number in enumerate(num[::-1]): answer += int(number) * (base ** idx) . 파이썬에서는 파이썬의 int(x, base=10) 함수는 진법 변환을 지원합니다. 이 기본적인 함수를 잘 쓰면 코드를 짧게 쓸 수 있고, 또 시간을 절약할 수 있습니다. . num = &#39;3212&#39; base = 5 answer = int(num, base) . &#45712;&#45184;&#51216;(enumerate, int( , base), &#47928;&#51088;&#50676;&#46020; sequence, [::-1]) . 순서가 필요한 list나 문자열은 enumerate를 활용하자. ex&gt; 진법변환 계산 | 뒤에서부터 시작을 꼭 sorted( ,reverse=True)에 집착X iterable전용인 문자열, array, dataframe등을 생각할 때 [::-1]을 활용하자. 문자열도, list처럼 sequence이다. (flatcontainerimmutablemutable) -&gt; 인덱싱으로 꺼꾸로 시작하게 할 수 있다. | . | 파이썬에서는 진법변환함수를 int( , base)로 제공한다. 필요하다면 쓰자. 진법변환시 첫자리부터 하지말고, str()+ [::-1]을 활용해 일의 자리에서부터 풀자 | . | . num = &#39;432&#39; base = &#39;5&#39; # 일의 자리부터 풀어보자. + enumerate로 번호를 줘가면서 풀어보자. num[::-1] . &#39;234&#39; . answer = 0 for idx, number in enumerate(num[::-1]): answer += int(number) * ( int(base) ** (idx) ) answer . 117 . # base진법으로 표기된 string num을 -&gt; 10진법 숫자(int())변환 answer = int(num, base=int(base)) answer . 117 . &#47928;&#51088;&#50676; (2) . &#47928;&#51088;&#50676; &#51221;&#47148;&#54616;&#44592; . 문제 설명 문자열 s와 자연수 n이 입력으로 주어집니다. 문자열 s를 좌측 / 가운데 / 우측 정렬한 길이 n인 문자열을 한 줄씩 프린트해보세요. 제한조건 s의 길이는 n보다 작습니다. (n - s의 길이)는 짝수입니다. s는 알파벳과 숫자로만 이루어져 있으며, 공백 문자가 포함되어있지 않습니다. . &#45236;&#54400;&#51060; . s, n = input().strip().split(&#39; &#39;) n = int(n) space_num = n-len(s) print(s+&#39; &#39;*space_num) print(&#39; &#39;*(space_num//2)+s+&#39; &#39;*(space_num//2)) print(&#39; &#39;*space_num+s) . abc 7 abc abc abc . &#51221;&#45813; . # -&gt; answer =&#39;&#39; 빈 문자열에 공백의 갯수만큼 돌면서(반복작업용for) 누적합으로 공백을 채운다. s = &#39;가나다라&#39; n = 7 answer = &#39;&#39; for i in range(n-(len(s))): answer+=&#39; &#39; answer+=s answer . &#39; 가나다라&#39; . s = &#39;가나다라&#39; n = 7 s.ljust(7) . &#39;가나다라 &#39; . s.center(7) . &#39; 가나다라 &#39; . s.rjust(7) . &#39; 가나다라&#39; . &#45712;&#45184;&#51216;(ljust, center, rjust) . 문자열로 sequence로 빈리스트+for+append대신 빈문자열+for++=누적합작업을 생각하자 for문을 반복작업에 활용하자. | . | python은 문자열의 공백정렬을 위해 문자열+공백으로 n자리를 채워준다. | string.ljust(공백포함 왼쪽정렬될 n자리), string.center(n), string.rjust() | . &#50508;&#54028;&#48307; &#52636;&#47141;&#54616;&#44592; . 입력으로 0이 주어지면 영문 소문자 알파벳을, 입력으로 1이 주어지면 영문 대문자 알파벳을 사전 순으로 출력하는 코드를 짜세요. 예시 1 입력 0 출력 abcd...(중간생략)..xyz . &#45236;&#54400;&#51060; . ord(&#39;a&#39;) . 97 . chr(97) . &#39;a&#39; . chr(122) . str . chr(65), chr(90) . (&#39;A&#39;, &#39;Z&#39;) . answer = &#39;&#39; for i in range(65, 90+1): answer+=chr(i) print(answer) . ABCDEFGHIJKLMNOPQRSTUVWXYZ . num = int(input().strip()) answer = &quot;&quot; if num: # num이 0이면, 소문자로 # ord(&#39;a&#39;) = 97 -&gt; z -&gt;122 for i in range(65, 90+1): answer+=chr(i) else: for i in range(97, 122+1): answer+=chr(i) print(answer) . 1 ABCDEFGHIJKLMNOPQRSTUVWXYZ . &#51221;&#45813; . import string string.ascii_lowercase # 소문자 abcdefghijklmnopqrstuvwxyz string.ascii_uppercase # 대문자 ABCDEFGHIJKLMNOPQRSTUVWXYZ string.ascii_letters # 대소문자 모두 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ string.digits # 숫자 0123456789 . &#39;0123456789&#39; . num = int(input().strip()) # answer = &quot;&quot; if num: # num이 0이면, 소문자로 # ord(&#39;a&#39;) = 97 -&gt; z -&gt;122 #for i in range(65, 90+1): # answer+=chr(i) print(string.ascii_uppercase) else: #for i in range(97, 122+1): # answer+=chr(i) print(string.ascii_lowercase) # print(answer) . 1 ABCDEFGHIJKLMNOPQRSTUVWXYZ . &#45712;&#45184;&#51216;(str.lower(), upper() -&gt; string&#49345;&#49688;, string&#47784;&#46280;.ascii_ , string&#47784;&#46280;.digits, ) . string모듈이란 것이 따로 있고, 소문자모음, 대문자모음, 소-&gt;대문자모음, 숫자모음을 상수로 제공한다. string.ascii_lowercase # 소문자 abcdefghijklmnopqrstuvwxyz | string.ascii_uppercase # 대문자 ABCDEFGHIJKLMNOPQRSTUVWXYZ | string.ascii_letters # 대소문자 모두 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ | string.digits # 숫자 0123456789 | . | 다른 사람 풀이를 보고선 chr(), ord()를 안써도되고 | 소문자만 or 대문자만 작성해서 str.lower() / str.upper() 메소드도 활용하자. | . | . iterable &#45796;&#47336;&#44592; (4) . Iterable이란? 자신의 멤버를 한번에 리턴할 수 있는 객체입니다. ex) list, str, tuple, dictionary 등 | . &#50896;&#48376;&#51012; &#50976;&#51648;&#54620;&#52292;, &#51221;&#47148;&#46108; &#47532;&#49828;&#53944; &#44396;&#54616;&#44592; - sorted . 파이썬의 sort() 함수를 사용하면 리스트의 원소를 정렬할 수 있습니다. 이때, sort 함수는 원본의 멤버 순서를 변경하지요. 따라서 원본의 순서는 변경하지 않고, 정렬된 값을 구하려면 sort 함수를 사용할 수 없습니다. . 이런 경우는 어떻게 해야 할까요? . 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통 사람들은 deep copy와 sort 함수를 이용합니다. . list1 = [3, 2, 1] list2 = [i for i in list1] # 또는 copy.deepcopy를 사용 list2.sort() . 파이썬에서는 파이썬의 sorted를 사용해보세요. 반복문이나, deepcopy 함수를 사용하지 않아도 새로운 정렬된 리스트를 구할 수 있습니다. . list1 = [3, 2, 1] list2 = sorted(list1) . &#45712;&#45184;&#51216; - (copy.deepcopy() -&gt; sort() &#50752; sorted() ) . sort()함수는 객체 직접 변환을 하니, &lt;같은값 할당은 shallow copy지만&gt; copy.deepcopy()이후 sort()를 한다고 한다. | sorted()는 새로운 정렬 list를 바로 반환한다. 그 인자로는 reverse=True, key=len, key=str.lower, key=lambda 등 정렬기준을 만드는 함수를 인자로 넣을 수 도 있다. | . | . (&#52428;) 2&#52264;&#50896; &#47532;&#49828;&#53944; &#46244;&#51665;&#44592; ( transpose&#47928;&#51228;, &#50612;&#47140;&#50880; ) . 다음을 만족하는 함수, solution을 완성해주세요. solution 함수는 이차원 리스트, mylist를 인자로 받습니다 solution 함수는 mylist 원소의 행과 열을 뒤집은 한 값을 리턴해야합니다. 예를 들어 mylist [[1, 2, 3], [4, 5, 6], [7, 8, 9]]가 주어진 경우, solution 함수는 [[1, 4, 7], [2, 5, 8], [3, 6, 9]] 을 리턴하면 됩니다. 제한 조건 mylist의 원소의 길이는 모두 같습니다. mylist의 길이는 mylist[0]의 길이와 같습니다. 각 리스트의 길이는 100 이하인 자연수입니다. . &#54400;&#51060;2&#44032;&#51648;(&#51221;&#52376;&#44592;&#49885;i&gt;j, &#48712;_list [i]&#54665;&#44284; for j &#44592;&#51316;list[j][i]&#50676;&#51012; &#54620; &#49464;&#53944;&#47196; ) . mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] mylist[::-1] # 1x1 -&gt; 1 # 2x2 -&gt; 3 # 3x3 -&gt; 5 # nxn -&gt; 2n-1 line # 각 k in 2n-1 마다.. # k=1, -&gt; 길이 1 0.0 # k=2, -&gt; 길이 2 1.0 0.1 # k=3, -&gt; 길이 3 2.0 1.1 0.2 # k=4, -&gt; 길이 2 # k=5, -&gt; 길이 5 # gg . [[7, 8, 9], [4, 5, 6], [1, 2, 3]] . # 타 문제에서는 각 행마다 길이가 같다는 보장이 없기 때문??? 이번 강의에서는 zip 함수를 이용해 2차원 배열을 뒤집는 방법을 알아봅시다. 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통은 다음과 같이 2중 for 문을 이용해 리스트의 row와 column을 뒤집습니다. . [[]]*4 . [[], [], [], []] . [[]]*len(mylist) . [[], [], []] . &#45712;&#45184;&#51216;( &#51221;&#52376;&#44592;&#49885;, new_list&#51032; &#54665;i == mylist&#51032; &#50676;i&#47196; &#44256;&#51221;&#49884;&#53020;, j&#47484; &#46028;&#47536; &#49345;&#53468;) . 2중 for문으로 행렬을 뒤집으려면, 빈 list -&gt; 빈 list의 [i]행 고정상태에 append ( mylist [행을 j로 돌리면서] [열은 i열로 고정]시켜서 뽑아낸 것들 ) . 새 list의 i행과 기존 list의 i열을 동일시 하면서 기존 list의 i열 값들을 뽑아내기 위해 j를 돌리면서 append한다. | . | 정처기식으로, i, j가 돌아가는데, 행렬 중에 i&gt;j 부분만 찾아서 한쪽만 swap . | mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] new_list = [[], [], []] for i in range(len(mylist)): for j in range(len(mylist[i])): new_list[i].append(mylist[j][i]) new_list . [[1, 4, 7], [2, 5, 8], [3, 6, 9]] . mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # new_list = [[], [], []] # new_list = [[]]*3 # 주의! 안에 요소가 콤마로 붙는다고 해서 list바깥에서 *3 하지말 것. id똑같은놈들임. # new_list = [[] for x in range(len(mylist))] for i in range(len(mylist)): for j in range(len(mylist)): if i &gt; j: mylist[j][i], mylist[i][j] = mylist[i][j], mylist[j][i] mylist . [[1, 4, 7], [2, 5, 8], [3, 6, 9]] . (&#52428;) 2&#52264;&#50896; &#47532;&#49828;&#53944; &#46244;&#51665;&#44592; - &#11088;&#65039;zip&#11088;&#65039; . &#54400;&#51060; . mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] new_list = list(map(list, zip(*mylist))) . &#45712;&#45184;&#51216;( zip(*&#47588;&#54609; 2&#52264;&#50896; &#47532;&#49828;&#53944;) -&gt; &#44033; &#54665;&#46308;&#47560;&#45796; 1&#44060;&#50473; &#48977;&#50500; tuple&#47196; ) . 행렬(2차원리스트)를 *매핑해서 zip()에 던져주면, 각 행들을 zip(a,b,c,...,n_rows)로 판단해서 나눠쓴다. 즉, for문으로 받을 때는 각 행마다 0열요소들 / 1열 요소들 / ... 들이 튜플로 모여서 들어온다. | . | 번역 : zip(*iterables)는 각 iterables 의 요소들을 모으는 이터레이터를 만듭니다. 튜플의 이터레이터를 돌려주는데, i 번째 튜플은 각 인자로 전달된 시퀀스나 이터러블의 i 번째 요소를 포함합니다. | . | 즉, 각 iter들(*매핑리스트시 - 각행들)의 요소를 하나씩 빼와서 튜플형태로 반환한다. i번째 튜플은 각 데이터(행)의 i번째열들의 모아아두었다. | 길이가 다르면, 짧은 데이터를 기준으로 끝난다. | 원래 집은 **zip으로 튜플들을 반환한다. 꼭 튜플 리스트가 아니더라도 2개의 짝을 이룬 튜플요소들이 반환되면 dict로 반환 가능하다. for문에서는 zip이 반환하는 tuple을 언패킹하는 것일 뿐 | . | . print(mylist) #[[*1*, 2, 3], # [*4*, 5, 6], # [*7*, 8, 9]] zip(*mylist) . [[1, 2, 3], [4, 5, 6], [7, 8, 9]] . &lt;zip at 0x1ed8c381800&gt; . list(zip(*mylist)) # 각 행마다 같은 열들을 튜플로 묶어서, 마치 대각선으로 transpose된다. . [(1, 4, 7), (2, 5, 8), (3, 6, 9)] . list(map(list, zip(*mylist))) # zip으로 만들어진 transpose 튜플 리스트를 map으로 각 요소 list로 변환한다. . [[1, 4, 7], [2, 5, 8], [3, 6, 9]] . print(&#39;mylist&#39;, mylist) print(&#39;*mylist&#39;, *mylist) # 함수에 튜플이나 리스트를 매핑해주면, 알아서 나눠서 쓴다는 의미다. # 인자로 대입한다면, 콤마로 나눠서 넣어줘야한다. (튜플, 리스트로 인자대입X) list(zip(*mylist)) . mylist [[1, 2, 3], [4, 5, 6], [7, 8, 9]] *mylist [1, 2, 3] [4, 5, 6] [7, 8, 9] . [(1, 4, 7), (2, 5, 8), (3, 6, 9)] . list1 = [1, 2, 3, 4, 5] list2 = [100, 120, 30, 300] list3 = [392, 2, 33] answer = [] for number1, number2, number3 in zip(list1, list2, list3): print(number1 + number2 + number3) . 493 124 66 . # 짝을 이룬 튜플리스트는 dict로 변환가능하다! animals = [&#39;cat&#39;, &#39;dog&#39;, &#39;lion&#39;] sounds = [&#39;meow&#39;, &#39;woof&#39;, &#39;roar&#39;] # print(list(zip(animals, sounds))) dict(zip(animals, sounds)) . [(&#39;cat&#39;, &#39;meow&#39;), (&#39;dog&#39;, &#39;woof&#39;), (&#39;lion&#39;, &#39;roar&#39;)] . {&#39;cat&#39;: &#39;meow&#39;, &#39;dog&#39;: &#39;woof&#39;, &#39;lion&#39;: &#39;roar&#39;} . (&#52428;) i&#48264;&#51704; &#50896;&#49548;&#50752; i+1&#48264;&#51704; &#50896;&#49548; - zip . 숫자를 담은 리스트 mylist가 solution 함수의 파라미터로 주어집니다. solution 함수가 mylist의 i번째 원소와 i+1번째 원소의 차를 담은 일차원 리스트에 차례로 담아 리턴하도록 코드를 작성해주세요. 단, 마지막에 있는 원소는 (마지막+1)번째의 원소와의 차를 구할 수 없으니, 이 값은 구하지 않습니다. 제한 조건 mylist의 길이는 1 이상 100 이하인 자연수입니다. mylist의 원소는 1 이상 100 이하인 자연수입니다. 예시 mylist output [83, 48, 13, 4, 71, 11] [35, 35, 9, 67, 60] 설명: 83과 48의 차는 35입니다. 48과 13의 차는 35입니다. 13과 4의 차는 9입니다. 4와 71의 차는 67입니다. 71과 11의 차는 60입니다. 따라서 [35, 35, 9, 67, 60]를 리턴합니다. . &#54400;&#51060; . def solution(mylist): return [abs(mylist[i] - mylist[i+1]) for i in range(len(mylist)-1)] . &#51221;&#45813; &#48143; &#45712;&#45184;&#51216; (zip( list, list[1:]) -&gt; &#51064;&#45937;&#49905; i&#50752; i+1&#51032; value&#47484; &#46041;&#49884;&#51217;&#44540; ) . 원래는 for i in n-1까지만 돌기 -&gt; [i], [i+1] | zip( list, 1개 모자란 list[1:] ) -&gt; 2개 요소 value 바로 접근 zip은 짧은 것 까지니까 자동으로 (0,1) &gt; (n-1,n) (n, ) | . | def solution(mylist): answer = [] for number1, number2 in zip(mylist, mylist[1:]): answer.append(abs(number1 - number2)) return answer . &#47784;&#46304; &#47716;&#48260;&#51032; type &#48320;&#54872;&#54616;&#44592; . 문제 설명 문자열 리스트 mylist를 입력받아, 이 리스트를 정수형 리스트로 바꾼 값을 리턴하는 함수, solution을 만들어주세요. 예를 들어 mylist가 [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] 인 경우, solution 함수는 [1, 100, 33] 을 리턴하면 됩니다. 제한조건 mylist의 길이는 100 이하인 자연수입니다. mylist의 원소는 10진수 숫자로 표현할 수 있는 문자열입니다. 즉, &#39;as2&#39; 와 같은 문자열은 들어있지 않습니다. 예시 input output [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] [1, 100, 33] . def solution(mylist): return [ int(x) for x in mylist ] . &#45712;&#45184;&#51216;(map -&gt; &#54632;&#49688;&#47484; &#51064;&#51088;&#47196; or lambda ) . list comp도 되지만, list(map(각 요소에 적용함수, 데이터)) 로 데이터 변형 가능 map( 내장함수 or 실행부없는 함수 or lambda, 데이터) | . | . list1 = [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] list2 = list(map(len, list1)) list2 . [1, 3, 2] . map &#54632;&#49688; &#51025;&#50857;&#54616;&#44592; . 문제 설명 정수를 담은 이차원 리스트, mylist 가 solution 함수의 파라미터로 주어집니다. solution 함수가 mylist 각 원소의 길이를 담은 리스트를 리턴하도록 빈칸을 완성해보세요. hint) 이전 강의에서 배운 map 함수를 활용해보세요 제한 조건 mylist의 길이는 100 이하인 자연수입니다. mylist 각 원소의 길이는 100 이하인 자연수입니다. 예시 input output [[1], [2]] [1, 1] [[1, 2], [3, 4], [5]] [2, 2, 1] . def solution(mylist): answer = list(map(len, mylist)) return answer . Sequence Types &#45796;&#47336;&#44592; (2) . sequence &#47716;&#48260;&#47484; &#54616;&#45208;&#47196; &#51060;&#50612;&#48537;&#51060;&#44592; - join . 문자열 리스트 mylist를 입력받아, 이 리스트의 원소를 모두 이어붙인 문자열을 리턴하는 함수, solution을 만들어주세요. 예를 들어 mylist가 [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] 인 경우, solution 함수는 &#39;110033&#39;을 리턴하면 됩니다. 제한 조건 mylist의 길이는 100 이하인 자연수입니다. mylist의 원소의 길이는 100 이하인 자연수입니다. . my_list = [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] answer = &#39;&#39; for value in my_list: answer += value . my_list = [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] answer = &#39;&#39;.join(my_list) . &#45712;&#45184;&#51216;( &#39;&#39;.join(sequence) &#44284; &#48712;&#47928;&#51088;&#50676; +=&#45572;&#51201;&#54633; append ) . 빈_문자열 = &#39;&#39; for in 빈문자열 += string(빈 문자열의 누적합 append) -&gt; python join | . &#49340;&#44033;&#54805; &#48324;&#52237;&#44592; - sequence&#51032; *&#50672;&#49328; . 문제 설명 이 문제에는 표준 입력으로 정수 n이 주어집니다. 별(*) 문자를 이용해 높이가 n인 삼각형을 출력해보세요. 제한 조건 n은 100 이하인 자연수입니다. 예시 입력 3 출력 * ** *** . n = int(input().strip()) for i in range(1,n+1): print((&#39;*&#39;*i).ljust(n)) . 5 * ** *** **** ***** . n = int(input().strip()) for i in range(1,n+1): print((&#39;*&#39;*i).center(n)) . 10 * ** *** **** ***** ****** ******* ******** ********* ********** . &#54400;&#51060; . 이번 강의에서는 곱셈 연산 *를 통해 문자열을 반복하는 방법을 배웁니다. | . 예시) . &#39;abc&#39;, &#39;abcabc&#39;, &#39;abcabcabc&#39;, &#39;abcabcabcabc ...&#39; 과 같이 . &#39;abc&#39;가 n번 반복되는 문자열 만들기 (my) 일정길이 문자열의 누적합 반복 -&gt; *) | . | [123, 456, 123, 456, 123, ...] 과같이 123, 456이 n번 반복되는 리스트 만들기 (my) 리스트 안에 요소들전체 의 append 반복 -&gt; *) | . | . answer = &#39;&#39; n = 5 for _ in range(n): answer += &#39;abc&#39; print(answer) . abcabcabcabcabc . # - sequence라 * 연산을 희한하게 한다. answer = &#39;abc&#39; * n answer . &#39;abcabcabcabcabc&#39; . n = 3 answer= [123, 456] * n print(answer) . [123, 456, 123, 456, 123, 456] . answer[3]=3 answer . [123, 456, 123, 3, 123, 456] . &#45712;&#45184;&#51216; (sequence * -&gt; string*, list*) . 문자열 * n : 문자열을 누적합해서 += 한 것처럼 반복된다. | list * n : 기존요소들전체 append | . Itertools / Collections &#47784;&#46280; (4) . (&#52428;) &#44273;&#51665;&#54633;(Cartesian product) &#44396;&#54616;&#44592; - product . 이번 강의에서는 iterable으로 곱집합을 구하는 방법을 알아봅니다. | 예시) 두 스트링 &#39;ABCD&#39;, &#39;xy&#39; 의 곱집합은 Ax Ay Bx By Cx Cy Dx Dy 입니다. | . iterable1 = &#39;ABCD&#39; iterable2 = &#39;xy&#39; iterable3 = &#39;1234&#39; for value1 in iterable1: for value2 in iterable2: for value3 in iterable3: print(value1, value2, value3) . A x 1 A x 2 A x 3 A x 4 A y 1 A y 2 A y 3 A y 4 B x 1 B x 2 B x 3 B x 4 B y 1 B y 2 B y 3 B y 4 C x 1 C x 2 C x 3 C x 4 C y 1 C y 2 C y 3 C y 4 D x 1 D x 2 D x 3 D x 4 D y 1 D y 2 D y 3 D y 4 . # itertools.product를 이용하면, for 문을 사용하지 않고도 곱집합을 구할 수 있습니다. import itertools iterable1 = &#39;ABCD&#39; iterable2 = &#39;xy&#39; iterable3 = &#39;1234&#39; print(list(itertools.product(iterable1, iterable2, iterable3))) . [(&#39;A&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;A&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;A&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;A&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;4&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;4&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;4&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;4&#39;)] . itertools.product(iterable1, iterable2, iterable3) . &lt;itertools.product at 0x1ed8c4750c0&gt; . import itertools iter1 = list(&#39;ABCD&#39;) iter2 = &#39;조재성 조재경 조아라&#39;.split(&#39; &#39;) iter3 = &#39;1234&#39; print(itertools.product(iter1)) # 1개의 iter도 받으며, list()로 변환해야 보인다. print(list(itertools.product(iter1))) # 1개의 iter도 받으며, list()로 변환해야 보인다. print(list(itertools.product(iter1, iter2))) # 2개의 iterable객체를 넣은 순간부터, 곱집합 튜플들의 리스트가 나온다. # 2중 for문을 도는 효과다. [ a + b + c for a,b,c in itertools.product(iter1, iter2, iter3)][:5] . &lt;itertools.product object at 0x000001ED8C58A940&gt; [(&#39;A&#39;,), (&#39;B&#39;,), (&#39;C&#39;,), (&#39;D&#39;,)] [(&#39;A&#39;, &#39;조재성&#39;), (&#39;A&#39;, &#39;조재경&#39;), (&#39;A&#39;, &#39;조아라&#39;), (&#39;B&#39;, &#39;조재성&#39;), (&#39;B&#39;, &#39;조재경&#39;), (&#39;B&#39;, &#39;조아라&#39;), (&#39;C&#39;, &#39;조재성&#39;), (&#39;C&#39;, &#39;조재경&#39;), (&#39;C&#39;, &#39;조아라&#39;), (&#39;D&#39;, &#39;조재성&#39;), (&#39;D&#39;, &#39;조재경&#39;), (&#39;D&#39;, &#39;조아라&#39;)] . [&#39;A조재성1&#39;, &#39;A조재성2&#39;, &#39;A조재성3&#39;, &#39;A조재성4&#39;, &#39;A조재경1&#39;] . &#45712;&#45184;&#51216;( itertools.product(iter1, 2, 3) -&gt; &#51473;&#52393;for &#48152;&#48373;&#51012; &#51228;&#44144; + &#49692;&#49436;&#45824;&#44032; &#51221;&#54644;&#51652; &#51312;&#54633;&#51060;&#45796;.) . itertools.product의 결과물은 list()를 씌워야 튜플 리스트로 들어온다. 1개의iter를 넣어도 (a, ) (b, )의 튜플형태로 받는다. | . | zip은 i, i+1, 같은 위상의 iter들을 동시에 받거나 *2차원리스트 등을 받아서 -&gt; 1차원으로 동시에 처리 itertools.product는 for iter1, for iter2처럼, 누적해서 곱집합을 처리한다. | . | 문자열도 iter로 인식하여 한 문자씩 돌아간다. | . (&#52428;) 2&#52264;&#50896; &#47532;&#49828;&#53944;&#47484; 1&#52264;&#50896; &#47532;&#49828;&#53944;&#47196; &#47564;&#46308;&#44592; - from_iterable . &#45236;&#54400;&#51060;(no pythonic) . def solution(mylist): answer = [] for list_ in mylist: for li in list_: answer.append(li) return answer . my_list = [[1, 2], [3, 4], [5, 6]] [ li for list_ in my_list for li in list_ ] . [1, 2, 3, 4, 5, 6] . &#51221;&#45813; . # 빈리스트[]에 +로 &lt;&lt;괄호떼고&gt;&gt;누적합으로 이어붙이기 . my_list = [[1, 2], [3, 4], [5, 6]] answer = [] for element in my_list: answer += element answer . [1, 2, 3, 4, 5, 6] . sum(my_list, []) . [1, 2, 3, 4, 5, 6] . print(itertools.chain.from_iterable( my_list ) ) list(itertools.chain.from_iterable( my_list ) ) . &lt;itertools.chain object at 0x000001ED8C79CE20&gt; . [1, 2, 3, 4, 5, 6] . # itertools.chain()은 여러 1차 iterable(1글자씩조합-문자열 or list 등)을 분해해서 # -&gt; 통합한 1차 iterable을 만든다. list(itertools.chain(&#39;ABC&#39;, [&#39;abc&#39;,2,3], &#39;F&#39;)) . [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;abc&#39;, 2, 3, &#39;F&#39;] . list(itertools.chain(my_list)) list(itertools.chain(*my_list)) . [1, 2, 3, 4, 5, 6] . 파이썬 * 의 사용 (https://mingrammer.com/understanding-the-asterisk-of-python/) 곱셈 및 거듭제곱 연산으로 사용할 때 | 리스트형 컨테이너 타입의 데이터를 반복 확장하고자 할 때 | 가변인자 (Variadic Arguments)를 사용하고자 할 때 -&gt; 인자시 패킹(내부에서는 *떼고 묶어서 써줘) | 컨테이너 타입의 데이터를 Unpacking 할 때 -&gt; 사용시언패킹(알아서 쪼개줘) | . | . from functools import reduce primes = [2, 3, 5, 7, 11, 13] def product(*numbers): p = reduce(lambda x, y: x * y, numbers) return p product(*primes) # product() 함수가 &lt;이미 내부에서&gt; 가변인자를 받고 있기 때문에, # 실제 입력시에는 콤마로 언패킹상태로 리스트의 데이터를 모두 unpacking하여 함수에 전달해야한다. # -&gt; 인자가 패킹하고있다면, 실제 대입은 콤마, , ,로 나눠서 주던지 *iterable로 알아서 처리하라고 넘겨주면 된다. # 30030 product(primes) # XXXXXXXXXX -&gt; 콤마로 줘야할 곳을 list로 주고 있다. *list로 하면 콤마로 알아서 입력해줘다. # [2, 3, 5, 7, 11, 13] . [2, 3, 5, 7, 11, 13] . list(itertools.chain.from_iterable( my_list )) . [1, 2, 3, 4, 5, 6] . from functools import reduce reduce(lambda x, y: x+y, my_list) from operator import add reduce(add, my_list) . [1, 2, 3, 4, 5, 6] . &#45712;&#45184;&#51216;( 2&#52264;&#50896; : [ ] for += &#44292;&#46524;&#51060;&#50612;&#48537;&#51060;&#44592; / sum( , start =[ ]) / &#54620;&#44732;&#54400; : itertools.chain(*)&#44284; &#51088;&#46041; 2&#44732;&#54400;: chain.from_iterable() / reduce(lambda x,y:x(list)+(new_list), &lt;--2&#52264;&#50896;&#47532;&#49828;&#53944;) . 가장 단순하게 2중 for문 or 2중 list comp로 element까지 가는 것 | 비 파이썬이라도 빈_list[ ]에 for문 1개의 list element에서 append가 아닌 빈_list += 괄호떼고 이어붙이기 | 내장sum(iter)함수에 , start=값을 default 0이 아닌 빈 []에다가 iter각 요소(2차원-&gt;1차원 리스트들)누적되도록 ! sum(iter , start = [] ) | itertools.chain( 1차원or문자열 iterable1 , iter2, ... ) -&gt; 문자열은 1개씩 풀어서, list는 element단위로 풀어서 1차원 iterable로 통합 itertools.chain()은 여러 1차 iterable들을 각각 분해하여 각각 한꺼풀만 벗겨, 통합한 1차 iterable을 만든다. | 2차원을 넣으면 그대로 2차원 반환됨. 한 꺼풀만 벗겨서 다시 통합하므로 -&gt; chain(*2차원)으로 사용시언패킹 시켜주자 | . | %timeit 결과를 보면 sum()함수만 끔찍하게 느리고 나머지 셋은 고만고만함을 알 수 있다. 성능과 가독성 중 무엇을 중시하냐의 차이지만 개인적으로 itertools.chain() 자체도 가독성이 나쁘다고 볼 수 없기에 sum()보다는 chain()을 쓰지 않을까 싶다. | . reduce도 각 데이터 요소들이 와서 연산하는데 lambda로 +연산 or operator.add를 사용해서 list들이 += 누적합이 되도록 해주면 된다. | from itertools import permutations sorted(list(permutations([2, 1,3], 2))) . [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] . (&#52428;) &#49692;&#50676;&#44284; &#51312;&#54633; - combinations, permutations . 문제 설명 숫자를 담은 일차원 리스트, mylist에 대해 mylist의 원소로 이루어진 모든 순열을 사전순으로 리턴하는 함수 solution을 완성해주세요. 제한 조건 mylist 의 길이는 1 이상 100 이하인 자연수입니다. 예시 mylist output [2, 1] [[1, 2], [2, 1]] [1, 2, 3] [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] . from itertools import permutations sorted(list(permutations([2, 1,3],2))) . [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] . &#54056;&#53412;&#51648; &#50630;&#51060; &#49692;&#50676; &#44396;&#54788;( &#54532;&#47196;&#44536;&#47000;&#47672;&#49828; while. &#50612;&#47140;&#50880;) . # # - 자기자신의 index와 value가 같아지는 순간까지만 반복되다가, 다음 index로 넘어가서 반복된다. # # - index가 더크면, 값+1 index 초기화후 # # - 값이 더크거나 같으면, &lt;인덱스+1&gt; 값 초기화 # # my) 값을 인덱스랑 같아질때까지 늘려주는데, 값 증가시 그때마다 i=0부터 시작.. -&gt; 같아지면 index+1 값은 0 # # my) index가 n-1까지 = arr갯수까지만 시행. # # - 그럼, 0` [0`,0] -&gt; `1 [0,`0] -&gt; `0 [`0,1] -&gt; `1 [0, `1] -&gt; 2 [0, 0] -&gt; 조건위배 while중지 # def permute_first(arr): # result = [arr[:]] # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c, arr, result) # # 1. i번째 데이터가 자기 순서(i)보다 값이 작다? 1증가시키고, 처음부터 돌려라. # if c[i] &lt; i : # c[i] +=1 # 값을 +1 # i = 0 # index를 0부터 다시 시작. # # 2. i번째 데이터가 자기 순서(i)보다 크거나 같다? 값을 초기화시키고, 다음 index순서로 넘어가라 # else: # c[i] = 0 # i+=1 # permute_first([0,0]) . # # my) 값을 인덱스랑 같아질때까지 늘려주는데, 값 증가시 그때마다 i=0부터 시작.. -&gt; 같아지면 index+1 값은 0 # # my) index가 n-1까지 = arr갯수까지만 시행. # # - 그럼, 0` [0`,0] -&gt; `1 [0,`0] -&gt; `0 [`0,1] -&gt; `1 [0, `1] -&gt; 2 [0, 0] -&gt; 조건위배 while중지 # # 3. 인덱스가 짝수면, arr[0]번째 값과 해당 index값 arr[i] swap한다. # def permute_two(arr): # result = [arr[:]] # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c[i], c, arr) # if c[i] &lt; i : # # 3. 인덱스가 짝수면, 원본 0번째 값 현재(짝수번째) 값을 교환. # if i % 2 ==0: # arr[0], arr[i] = arr[i], arr[0] # c[i] +=1 # i = 0 # else: # c[i] = 0 # i+=1 # permute_two([0,1,4]) . # result = [arr[:]] # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c[i], c, arr) # if c[i] &lt; i : # # 3. 인덱스가 짝수면, 0번째 값과, 짝수번째 값을 교환. # if i % 2 ==0: # arr[0], arr[i] = arr[i], arr[0] # # 4. 인덱스가 홀수면, [c list의 i번째 값]을 index로 넣고, 데이터 홀수번재 값을 교환 # else: # arr[c[i]], arr[i] = arr[i], arr[c[i]] # c[i] +=1 # i = 0 # else: # c[i] = 0 # i+=1 # permute_three([0,1,4]) . # # - 값이 index랑 같아지는 부분은 횟수를 늘리는 용도일 뿐이라는 말이다. # def permute_four(arr): # result = [arr[:]] # 2차원에 1번째 행을 원본을 넣어놓는다. # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c[i], c, arr) # if c[i] &lt; i : # # 3. 인덱스가 짝수면, 0번째 값과, 짝수번째 값을 교환. # if i % 2 ==0: # arr[0], arr[i] = arr[i], arr[0] # # 4. 인덱스가 홀수면, [c list의 i번째 값]을 index로 넣고, 데이터 홀수번재 값을 교환 # else: # arr[c[i]], arr[i] = arr[i], arr[c[i]] # # 5. arr결과를 result 2차원 리스트(원본을 1행에 가지고 있던 놈)에 append한다. # # - c[i]가 0에서부터 불들어오는 순간부터 교환후 들어올리네. # result.append(arr[:]) # c[i] +=1 # i = 0 # else: # c[i] = 0 # i+=1 # # 6. result 2차원 리스트를 반환한다. # return result # permute_four([1,2,3]) . def permute(arr): result = [arr[:]] c = [0] * len(arr) i = 0 while i &lt; len(arr): if c[i] &lt; i: if i % 2 == 0: arr[0], arr[i] = arr[i], arr[0] else: arr[c[i]], arr[i] = arr[i], arr[c[i]] result.append(arr[:]) c[i] += 1 i = 0 else: c[i] = 0 i += 1 return result . &#48264;&#50808;) python&#51004;&#47196;&#49692;&#50676; &#44396;&#54788;1 (&#48660;&#47196;&#44536;1, &#51116;&#44480;+&#48520;&#53356;&#44256;&#45124;&#44592; ) . https://shoark7.github.io/programming/algorithm/Permutations-and-Combinations | https://programmers.co.kr/learn/courses/4008/lessons/12836 | . arr = [0,1,2,3] r = 2 # def permutation(arr, r): # 1. used(list) : 해당index의 원소 사용 여부 : arr의 길이만큼 빈 [0] * n를 만들자. # - used(list)에는 해당index의 값이 사용됬는지 안됬는지 체크여부. # - 누적합이 아니라도 여부 등은 0 default에서 1 왔다갔다 하면, if문에 False, True로 걸린다. # used = [0] * len(arr) used = [0 for _ in range(len(arr))] # 2. generate( chosen, used ): 함수로 만들어야 -&gt; 내부에서 같은 로직을 한번 더 호출할 수 있다. # - 일단, 빈 list를 던져주고, 사용여부에 따라 append한 다음, 길이가 원하는 순열길이(r)과 같아졌다면 함수를 끝내는 return해준다. # generate([], used) 형태로 사용된다. def generate(chosen, used): # 2-1) default [] chosen이 원하는 길이를 만족했으면 -&gt; 탈출 -&gt; 그전까지는 내부함수 호출로 반복됨. if len(chosen) == r: print(chosen) # 결과값 저장대신 각각 만들어진 경우를 print한다. return # 2-2) arr길이만큼 반복 -&gt; used의 길이랑 arr이랑 같으며, 같이 움직이니까. # arr와 같은 길이의 used는 arr[i]의 사용여부체크시 used[i]를 사용하는 위에 떠있는 데이터 for i in range(len(arr)): # i번째 원소가 아직 사용이 안됬다? print(&#39;used&#39;, used) if not used[i]: # 사용후 -&gt; 사용표시 1 # - 일단 사용안된 i번째 요소를 chosen에 넣고, 사용했다는 표기를 한다. print(&#39;chosen&#39;, chosen) chosen.append(arr[i]) used[i]=1 # i번재 데이터가 담기고 + 사용되었다는 표시와함께 다시 호출하면 # - 재귀적? 반복적으로... i를 제외하고 사용안된 i를 =1,2,3,4에서부터 찾기..전에... generate(chosen, used) # 내부에서, 길이 못채웠고 &amp; 사용된것 넘어가면서 사용안된 것을 j를 0에서부터 찾는다. # 내부에서, 0은 used[0]이 이미 담겨있으니, 1을 chosen에 넣고, 0,1,을 넣은 상태에다. # 내부에서 또 내부함수가 호출되지만, 초기검사에서 r==2를 만족시켜 반환되며 # 내부j에서는, used[j] = 0을 넣고, 안썼다고 표시 + 데이터도 뺀 체로, j=1이 된다. # i=0는 고정상태에서 j=0을 쓴 뒤, j=1을 쓰고, r==2가 만족되면 j=2로 간다... # i 고정 -&gt; j를 돌면서 -&gt; k에서 갯수가 맞추다가,, j를 다돌면, i가 도나보다... used[i] = 0 chosen.pop() # 재귀를 써서 구하는데 # base case가 chosen == r(input)을 맞추면 끝난다... # 이 함수의 핵심이다. 모든 순열은 arr 의 0부터 i-1 번째 값으로 시작하기에 for 문으로 다 만들어야 한다. # recusive case는 nPr = 시작자리에 arr[i] 가 들어갔다고 치면(for를 n번) = N * n-1Pr 이다. # permutation([0,1,2,3], 2) = # ([0],permutation([1,2,3], 1)) + ([1],permutation([0,2,3], 1)) + ([2],permutation([0,1,3], 1))+ ([3],permutation([0,1,2], 1)) # combination([0,1,2,3], 2) = ([0],combination([1,2,3], 1)) + ([1],combination([2,3], 1)) + ([2],combination([3], 1))) # https://cotak.tistory.com/70 . used [0, 0, 0, 0] chosen [] used [1, 0, 0, 0] used [1, 0, 0, 0] chosen [0] [0, 1] used [1, 0, 0, 0] chosen [0] [0, 2] used [1, 0, 0, 0] chosen [0] [0, 3] used [0, 0, 0, 0] chosen [] used [0, 1, 0, 0] chosen [1] [1, 0] used [0, 1, 0, 0] used [0, 1, 0, 0] chosen [1] [1, 2] used [0, 1, 0, 0] chosen [1] [1, 3] used [0, 0, 0, 0] chosen [] used [0, 0, 1, 0] chosen [2] [2, 0] used [0, 0, 1, 0] chosen [2] [2, 1] used [0, 0, 1, 0] used [0, 0, 1, 0] chosen [2] [2, 3] used [0, 0, 0, 0] chosen [] used [0, 0, 0, 1] chosen [3] [3, 0] used [0, 0, 0, 1] chosen [3] [3, 1] used [0, 0, 0, 1] chosen [3] [3, 2] used [0, 0, 0, 1] . def permutation(arr, r): # 1. arr = sorted(arr) # 해당원소가 사용되고 있는 상태인지 arr와 같은길이의 0과 1로 구성될 list 생성 # - 재귀로 내부에서 함수가 또 불려질텐데, 내부함수가 밖에서 어떤 원소가 고정된 상탠지 알려주기 위해 # - 함수 입장에서 전역변수로 만들어준다. used = [0 for _ in range(len(arr))] def generate(chosen, used): # 2.재귀에서 탈출부이다. chosen이 원하는 갯수 r개가 되면 base case로 print하고 해당함수는 끝난다. # - 내부함수들이 끝나는 것이기에... 어느것이 끝나는지는... if len(chosen) == r: print(chosen) return # 3.i번째를 고정시킨 상태에서, # - i에 불이 안들어와있는 상태다 = 가장 바깥은 필요없지만.. 내부함수들은 바깥에서 고정된 것이기에 피해야한다. for i in range(len(arr)): # 사용했다는 불이 안들어온 상태다. 내부함수가 인식하도록, 내부함수호출직전에 켜주고, 직후에 꺼준다. # 맨바깥은 for로 알아서 i가 돌아가고 있기 때문에 노상관. 내부에서 i불들어온 것 제끼고 r-1개 맞추라는 신호임. if not used[i]: # 4. 내부함수가 i원소를 채운 상태로 재귀호출하도록 넣어주고, 불을 켜준다. chosen.append(arr[i]) used[i] = 1 generate(chosen, used) # 재귀상태로, 1개를 채운상태에서 r-1를 채우려고 호출된다. # 5. i고정상태에서 r-1개를 다채워 r개를 완성했다는 뜻이니, 불을 꺼주고, 빼준다. used[i] = 0 chosen.pop() # 6. 자동으로 다음 i가 고정되서 시작한다. generate([], used) permutation(&#39;ABCD&#39;, 2) . [&#39;A&#39;, &#39;B&#39;] [&#39;A&#39;, &#39;C&#39;] [&#39;A&#39;, &#39;D&#39;] [&#39;B&#39;, &#39;A&#39;] [&#39;B&#39;, &#39;C&#39;] [&#39;B&#39;, &#39;D&#39;] [&#39;C&#39;, &#39;A&#39;] [&#39;C&#39;, &#39;B&#39;] [&#39;C&#39;, &#39;D&#39;] [&#39;D&#39;, &#39;A&#39;] [&#39;D&#39;, &#39;B&#39;] [&#39;D&#39;, &#39;C&#39;] . &#48264;&#50808;2 ) python&#51004;&#47196;&#49692;&#50676; &#44396;&#54788;2 (&#48660;&#47196;&#44536;2, full &#51116;&#44480;&#54632;&#49688;&#47196; &#52376;&#47532;. &#45796;&#49884; &#48380; &#44163;) . # 출처: https://cotak.tistory.com/70 [Pool&#39;s Taek] def gen_permutations(arr, n): result = [] if n == 0: return [[]] for i, elem in enumerate(arr): # i번재 원소만 빼고, 대신 n-1개만 나머지로 순열 부분문제 정복상태 -&gt; 각 요소들P for P in gen_permutations(arr[:i] + arr[i+1:], n-1): # i번째 원소를 맨마지막에 extend해서 붙임. # [[2]] # [[1, 2]] # [[0, 1, 2]] # [[0, 1, 2]] # 순열도 제일 마지막에 첨가하면, 조합처럼 n-1개 완성 + 1개요소(n가지)가 된다? result += [[elem]+P] print(result) break return result arr = [0, 1, 2, 3, 4, 5] print(gen_permutations(arr, 3)) . [[2]] [[1, 2]] [[0, 1, 2]] [[0, 1, 2]] . &#51221;&#45813; . # itertools.permutation를 이용하면, for문을 사용하지 않고도 순열을 구할 수 있습니다. import itertools # pool = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] pool = &#39;ABC&#39; print(list(map(&#39;&#39;.join, itertools.permutations(pool)))) # 3개의 원소로 수열 만들기 print(list(map(&#39;&#39;.join, itertools.permutations(pool, 2)))) # 2개의 원소로 수열 만들기 . [&#39;ABC&#39;, &#39;ACB&#39;, &#39;BAC&#39;, &#39;BCA&#39;, &#39;CAB&#39;, &#39;CBA&#39;] [&#39;AB&#39;, &#39;AC&#39;, &#39;BA&#39;, &#39;BC&#39;, &#39;CA&#39;, &#39;CB&#39;] . &#45712;&#45184;&#51216;(itertools.permutations , combinations) . 문자열로 1글자씩으로 구성된 iter라 순열 또는 조합을 구할 수 있다. 리스트는 튜플 조합 리스트로 / 문자열을 문자열그대로의 리스트로 반환됨. | . | 원하는 구성원소갯수를 지정할 수 있다. | . (&#52428;)&#44032;&#51109; &#47566;&#51060; &#46321;&#51109;&#54616;&#45716; &#50508;&#54028;&#48307; &#52286;&#44592; - Counter . 문제 설명 이 문제에는 표준 입력으로 문자열, mystr이 주어집니다. mystr에서 가장 많이 등장하는 알파벳만을 사전 순으로 출력하는 코드를 작성해주세요. 제한 조건 mystr의 원소는 알파벳 소문자로만 주어집니다. mystr의 길이는 1 이상 100 이하입니다. 예시 input output &#39;aab&#39; &#39;a&#39; &#39;dfdefdgf&#39; &#39;df&#39; &#39;bbaa&#39; &#39;ab&#39; . &#45236;&#54400;&#51060; . dict에 단어마다 count 저장함 | dict를 sorted( , reverse=True, key=lambda x:x[1])로 밸류순으로 역순으로 정렬 -&gt; 가장 첫밸류값이 가장 최대값 | 첫, 두번째 밸류 동점일 수 있으니, value만 뽑은 뒤.. dict.items()를 돌면서 value가 같은 것을 출력함. | . my_str = input().strip() counter_dict = {} for key in my_str: counter_dict.setdefault(key, 0) counter_dict[key]+=1 max_value = sorted(counter_dict.items(), key=lambda x:x[1],reverse=True)[0][1] answer_list = [] for k,v in counter_dict.items(): if v == max_value: answer_list.append(k) print(&#39;&#39;.join(sorted(answer_list))) . aab a . &#51221;&#45813; . # 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통 사람들은 반복문을 이용해 수를 셉니다. my_list = [1, 2, 3, 4, 5, 6, 7, 8, 7, 9, 1, 2, 3, 3, 5, 2, 6, 8, 9, 0, 1, 1, 4, 7, 0] answer = {} for number in my_list: try: answer[number] += 1 except KeyError: answer[number] = 1 print(answer[1]) # = 4 print(answer[3]) # = 3 print(answer[100]) # = raise KeyError . import collections my_str = input().strip() answer = collections.Counter(my_str) print(answer) # dict형태로 출력됨. #Counter객체는 .most_common() 으로 key, count의 튜플리스트가 나옴. answer.most_common() # . asdklfjaskdfekekjek Counter({&#39;k&#39;: 5, &#39;e&#39;: 3, &#39;a&#39;: 2, &#39;s&#39;: 2, &#39;d&#39;: 2, &#39;f&#39;: 2, &#39;j&#39;: 2, &#39;l&#39;: 1}) . [(&#39;k&#39;, 5), (&#39;e&#39;, 3), (&#39;a&#39;, 2), (&#39;s&#39;, 2), (&#39;d&#39;, 2), (&#39;f&#39;, 2), (&#39;j&#39;, 2), (&#39;l&#39;, 1)] . dict_ = {&#39;k&#39;: 5, &#39;e&#39;: 3, &#39;a&#39;: 2, &#39;s&#39;: 2, &#39;d&#39;: 2, &#39;f&#39;: 2, &#39;j&#39;: 2, &#39;l&#39;: 1} dict_.values() # dict_.keys(), dict_.items() max(answer.values()) . 5 . # -&gt; values로 max값 바로 찾을 수 있다. # -&gt; max값을 알 때, for문을 돌면서, key값들을 누적할 수 있다? # -&gt; max값이 여러개일 수 있으니, 미리구한 최대값 == count 하면서 돌아야한다. my_list = input() max_count = max(collections.Counter(my_list).values()) [ word for word, count in collections.Counter(my_list).items() if count == max_count] . aaadddwqierie . [&#39;a&#39;, &#39;d&#39;] . &#45712;&#45184;&#51216; ( collections.Counter - dict + .most_common() ) . 비 파이썬이라도 dict에 저장하는 것은 똑같았다. | collections.Counter() -&gt; dict와 유사하니, Counter.values()로 max()를 구하고 | list comp로 Counter.items()를 k,v를 받아서 필터링하자 | . | 빈도순으로 튜플리스트를 반환하는 것은 .most_common()이다. | &#44592;&#53440; (7) . for &#47928;&#44284; if&#47928;&#51012; &#54620;&#48264;&#50640; - List comprehension&#51032; if &#47928; . 문제 설명 정수를 담은 리스트 mylist를 입력받아, 이 리스트의 원소 중 짝수인 값만을 제곱해 담은 새 리스트를 리턴하는 solution함수를 완성해주세요. 예를 들어, [3, 2, 6, 7]이 주어진 경우 3은 홀수이므로 무시합니다. 2는 짝수이므로 제곱합니다. 6은 짝수이므로 제곱합니다. 7은 홀수이므로 무시합니다. 따라서 2의 제곱과 6의 제곱을 담은 리스트인 [4, 36]을 리턴해야합니다. 제한 조건 mylist는 길이가 100이하인 배열입니다. mylist의 원소는 1이상 100 이하인 정수입니다. . mylist = [3, 2, 6, 7] answer = [number**2 for number in mylist if number % 2 == 0] answer . [4, 36] . &#45712;&#45184;&#51216;( X ) . mylist = [3, 2, 6, 7] answer = [] for number in mylist: if number % 2 == 0: answer.append(number**2) # 들여쓰기를 두 번 함 # 파이썬의 list comprehension을 사용하면 한 줄 안에 for 문과 if 문을 한 번에 처리할 수 있습니다. mylist = [3, 2, 6, 7] answer = [number**2 for number in mylist if number % 2 == 0] . (&#52428;) flag&#48320;&#49688; &#45824;&#49888; for-else &#49324;&#50857;&#54616;&#44592; . 문제 설명 본 문제에서는 자연수 5개가 주어집니다. 숫자를 차례로 곱해 나온 수가 제곱수가 되면 found를 출력하고 모든 수를 곱해도 제곱수가 나오지 않았다면 not found를 출력하는 코드를 작성해주세요. 예시 1 입력 2 4 2 5 1 출력 found 설명 수를 곱해나가면 2, 8, 16, 80, 80 이 나옵니다. 16은 4를 제곱해 나온 수이므로 이 수는 제곱수입니다. 따라서 found를 출력합니다. 예시 2 입력 5 1 2 3 1 출력 not found 설명 수를 곱해나가면 5, 5, 10, 30, 30 이 나옵니다. 이중 어떤 수도 제곱 수가 아니므로 not found를 출력합니다. . data = [ int(input()) for _ in range(5)] import math product = 1 check=False for n in data: product*=n if math.sqrt(product) == int(math.sqrt(product)) : print(&#39;found&#39;) check=True break if check == False: print(&#39;not found&#39;) . 2 4 2 5 1 2 1.4142135623730951 8 2.8284271247461903 16 4.0 found 2 not found . &#51221;&#45813; . # https://harryp.tistory.com/317 [Park&#39;s Life] import math data = [ int(input()) for _ in range(5)] product = 1 # check=False # 1. for내부에 if로 끊김을 나타내는 flag변수를 안쓴다. for n in data: product*=n if math.sqrt(product) == int(math.sqrt(product)) : print(&#39;found&#39;) #check=True break # if check == False: # 2. for가 안끊기고 다 돌았다면, else문 실행시킨다. else: print(&#39;not found&#39;) . 2 4 2 5 1 found . &#45712;&#45184;&#51216;( flag&#48320;&#49688; &#45824;&#49888; for-else&#47928; -&gt; for if &#52286;&#50520;&#51004;&#47732; flag break &#45824;&#49888; for if &#52286;&#50520;&#51004;&#47732;&#52376;&#47532; else&#47803;&#52286;&#50520;&#45796;&#52376;&#47532; + &#51228;&#44273;&#49688; + &#49548;&#49688;&#51216;.0&#51032; int&#54869;&#51064;) . for_if 조건: break -&gt; 만약 다 돌았는데도 if brea에 안걸린 not found == for 다돈 경우 else 조건X시 처리 . 원래는.. for문 내부에서 if 걸렸다? -&gt; break하고 for문 뒤에는 실행 X 를 for문 밖 flag=True/False 변수에 전달해줬다. | 이제는 for문 if 걸려서 flag = True + break -&gt; if flag: 처리는 하지 말자. for문 if 걸려서 break -&gt; 만약 안걸리고 다돌면 처리를 else문에서 | . | . | 제곱수의 판단 : math.sqrt()를 씌웠을 때 int여야한다. . 하지만 sqrt()씌우는 순간 int라도 2.0 3.0 이 되어버린다. | 정수.0의 int 판단방법 int()변환값 == 현재값 ( 전환된 값의 비교로 판단 ) | . | cf) 정수 판단 방법 isinstance( , int) | type( v ) == int | . | . | . &#46160; &#48320;&#49688;&#51032; &#44050; &#48148;&#44984;&#44592; - swap . # 비 파이썬은 덮어쓰기 당할 변수값을 temp에 넣어놓고 덮어쓰기 -&gt; 다른쪽 덮어쓰기 a = 3 b = &#39;abc&#39; temp = a a = b b = temp . 파이썬에서는 다음과 같이 한 줄로 두 값을 바꿔치기할 수 있음. . a = 3 b = &#39;abc&#39; a, b = b, a . (&#52428;) &#51060;&#51652; &#53456;&#49353;&#54616;&#44592; - bisect &#47784;&#46280; . 알고리즘 문제를 풀다 보면 이진 탐색을 써야할 때가 많습니다. 이런 문제를 풀 때마다 이진 탐색 알고리즘을 작성하는 건 비효율적이지요. 이번 시간엔 Python의 이진 탐색 모듈, bisect를 알아봅시다. | . # - while문에 if 탈출(break or def-return)이 없다? -&gt; 다돌고 &lt;조건문 직후 상태&gt;로 빠져나와서 최종 처리한다는 뜻 # ex&gt; while low &lt; high -&gt; low &gt;= high순간에 빠져나옴. 주로 직후인 low==high에서 빠져나와 마지막 처리 def bisect(a, x, lo=0, hi=None): if lo &lt; 0: raise ValueError(&#39;lo must be non-negative&#39;) if hi is None: hi = len(a) while lo &lt; hi: mid = (lo + hi) // 2 if a[mid] &lt; x: lo = mid + 1 else: hi = mid return lo mylist = [1, 2, 3, 7, 9, 11, 33] print(bisect(mylist, 5)) # ??? 없는 것도 나온다? . 3 . # 실제 list index의 +1을 반환하는 것 같다. # ** 해당 숫자 n을 어디에 insert해야하는지의 위치를 보여준다.** # 1) 같은게 있으면? 그 index +1 자리에 넣어라 # 2) 같은게 없으면? 오름차순으로 넣어야할 자리는 여기다. import bisect mylist = [1, 2, 3, 7, 9, 11, 33] print(bisect.bisect(mylist, 9)) # 같은게 4에 있으니 5번째 들어가야한다. print(bisect.bisect(mylist, 33)) # 같은게 6에 있으니 7에 들어가야한다. print(bisect.bisect(mylist, 5)) # 없는데 &lt;&lt;오름차순&gt;&gt; 4-&gt;value 3 뒤의 5자리에 들어가야한다. . 5 7 3 . # index 함수는 이진 탐색이 아닌 선형 탐색 함수입니다. # (물론 주어진 input에 대해서 index 함수를 쓰면 정확한 output 값을 얻을 수 있긴 합니다.) # 이진탐색의 시간복잡도는 O(logN) 이나, # index 함수는 선형탐색을 하므로 시간복잡도가 O(N)이라 시간이 오래 걸립니다. # bisect.bisect(mylist, n)의 n은 mylist에서 찾고자하는 값입니다. # bisect.bisect(mylist, n)이 리턴하는 값, x는 mylist에서 n이 위치한 index의 오른쪽 값을 나타냅니다. # insertion point를 리턴합니다. 즉, 3의 인덱스는 2이므로 이 다음에 있는 insertion point는 2+1 = 3이 되는 것이지요. # 말씀하신대로 bisect는 key 가 없으면 key가 들어갈 위치를 반환합니다. . # - 내뱉은 point가 .. 직전에 같은값이 있어서 그 바로 뒤라면? i-1 반환 # - 내뱉은 point가.. 직전에 같은값은 없으나.. 순서라서 줬다면? 그냥 탐색 실패-&gt; -1반환 import bisect def b_s(ary,key): i= bisect.bisect(ary,key) return i-1 if ary[i-1]==key else -1 . &#45712;&#45184;&#51216;(bisect.bisect( list, value) &gt; return or insert point, &#48148;&#47196;&#50526;&#50640; &#51080;&#44144;&#45208; &#47803;&#52286;&#50520;&#51648;&#47564; &#51221;&#47148;&#49345; &#44536;&#51088;&#47532;) . 정렬된 list라면, 이진탐색을 bisect.bisect로 할 수 있다. return된 값이. 실제 있떤 값이면 i + 1 = return값이다. -&gt; return값 - 1을 하자 | return된 값이. 없으나 정렬상 그자리에 들어가라고 return한 값이다 -&gt; ??? 직전과 값이 같앗 뱉은 건지 확인해야한다. if number == list[return value - 1] -&gt;returnvalue -1 else None.. | . | . | . &#53364;&#47000;&#49828; &#51064;&#49828;&#53556;&#49828; &#52636;&#47141;&#54616;&#44592; - class&#51032; &#51088;&#46041; string casting . 이번 강의에서는 인스턴스 출력 형식을 지정하는 방법을 배워봅시다. . 예) 2차원 평면 위의 점을 나타내는 Coord 클래스의 인스턴스를 (x 값, y 값)으로 출력하기 . class Coord(object): def __init__(self, x, y): self.x, self.y = x, y point = Coord(1, 2) print( &#39;({}, {})&#39;.format(point.x, point.y) ) # 또는 def print_coord(coord): print( &#39;({}, {})&#39;.format(coord.x, coord.y) ) print_coord(point) . # __str__ 메소드를 사용해 class 내부에서 **출력 format**을 지정할 수 있습니다. class Coord(object): def __init__ (self, x, y): self.x, self.y = x, y def __str__ (self): return &#39;({}, {})&#39;.format(self.x, self.y) point = Coord(1, 2) print(point) point . (1, 2) . &lt;__main__.Coord at 0x1ed8d397e80&gt; . &#45712;&#45184;&#51216; ( str&#50724;&#48260;&#46972;&#51060;&#46377; ) . print + interpret에 출력까지 될라면 repr를 오버라이딩한다. | 객체정보를 직접 찍어보지말자! 메소드 정의(비파이썬) 나 메소드 오버라이딩으로 확인하자.! | (&#52428;) &#44032;&#51109; &#53360; &#49688;, inf . 코딩 테스트 문제 등을 풀다 보면, 최솟값을 저장하는 변수에 아주 큰 값을 할당해야 할 때가 있습니다. 이번 시간에는 이때에 사용하기 좋은 inf에 대해 알아봅시다. . 이 기능을 모르시는 분은 본인이 생각하는 임의의 큰 수(99999등)를 할당합니다. . # 비파이썬에서, 최소값을 구할려구 미리 큰값을 넣어올 때, min_val = 99999 min_val &gt; 100000000 # ? . # 파이썬에서, 최소값을 구할려구 미리 큰값을 넣어올 때, # 파이썬이 제공하는 inf 를 사용. inf는 어떤 숫자와 비교해도 무조건 크다고 판정 min_val = float(&#39;inf&#39;) min_val &gt; 10000000000 . inf에는 음수 기호를 붙이는 것도 가능합니다. . max_val = float(&#39;-inf&#39;) . &#45712;&#45184;&#51216; - float(&#39;inf&#39;), float(&#39;-inf&#39;) . 최대값을 찾을 때, 일단 작은값을 변수에 넣어놓고 돈다. 가장 작은 값은 float(&#39;-inf&#39;) / 가장 큰 값은 float(&#39;inf&#39;) 로 초기값을 넣고 해결하자! | . | float(&#39;inf&#39;) . inf . float(&#39;-inf&#39;) . -inf . &#54028;&#51068; &#51077;&#52636;&#47141; &#44036;&#45800;&#54616;&#44172; &#54616;&#44592; - with open as f for line in f.readlines() . 이번 강의에서는 파일 입출력 코드를 간결하게 짜는 법을 알아봅시다. . &#39;myfile.txt&#39;라는 이름의 파일을 읽는 코드를 짜보세요 . # 1. open -&gt; 2. 반복문 while -&gt; 3.line = readlins() + if not line: break + line처리 -&gt; 4. close f = open(&#39;myfile.txt&#39;, &#39;r&#39;) while True: line = f.readline() if not line: break raw = line.split() print(raw) f.close() . FileNotFoundError Traceback (most recent call last) &lt;ipython-input-467-4f9a0ee2adde&gt; in &lt;module&gt; 1 # 비파이썬 2 # 1. open -&gt; 2. 반복문 while -&gt; 3.line = readlins() + if not line: break + line처리 -&gt; 4. close -&gt; 3 f = open(&#39;myfile.txt&#39;, &#39;r&#39;) 4 while True: 5 line = f.readline() FileNotFoundError: [Errno 2] No such file or directory: &#39;myfile.txt&#39; . # with - as 구문을 이용하면 코드를 더 간결하게 짤 수 있습니다. 코드를 아래와 같이 쓰면 다음과 같은 장점이 있습니다. # 1. 파일을 close 하지 않아도 됩니다: with - as 블록이 종료되면 파일이 자동으로 close 됩니다. # 2. readlines가 EOF까지만 읽으므로, while 문 안에서 EOF를 체크할 필요가 없습니다. # my) python은 readlines()가 EOF를 알아서 인식하니 -&gt; 반복문 in 자리에 넣으면 된다. -&gt; EOF 체크 필요없음. with open(&#39;myfile.txt&#39;) as file: for line in file.readlines(): print(line.strip().split(&#39; t&#39;)) . FileNotFoundError Traceback (most recent call last) &lt;ipython-input-468-1cec8ae34904&gt; in &lt;module&gt; 5 6 # my) python은 readlines()가 EOF를 알아서 인식하니 -&gt; 반복문 in 자리에 넣으면 된다. -&gt; EOF 체크 필요없음. -&gt; 7 with open(&#39;myfile.txt&#39;) as file: 8 for line in file.readlines(): 9 print(line.strip().split(&#39; t&#39;)) FileNotFoundError: [Errno 2] No such file or directory: &#39;myfile.txt&#39; . &#45712;&#45184;&#51216; - with as &#50752; python readlines() . with as f -&gt; close 안해도됨 + f.readlines()시 EOF 체크 자동으로 되니 반복문에 바로 삽입 | boj input() 등 f.readlines()와 달리 언제 EOF인지는 모를 땐, try except EOFError로 break해주자. | &#52280;&#44256;) &#51077;&#47141;&#51032; &#45149;(EOF) &#54869;&#51064; by except EOFError: break . f.readlines()는 알아서 EOF(end of file)을 체크하지만, boj등 input()이 언제 EOF인지는 모르니까, try except EOFError로 break해주자. | . | . while 1: try: ins=input() ans = fun(ins) if ans == -1: break; else: print(ans) except EOFError: break .",
            "url": "blog.chojaeseong.com/algorithm/2021/08/11/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_python_pythonic.html",
            "relUrl": "/algorithm/2021/08/11/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_python_pythonic.html",
            "date": " • Aug 11, 2021"
        }
        
    
  
    
        ,"post58": {
            "title": "알고리즘 문제 풀기용 input 코드 모음(python)",
            "content": "&#52280;&#44256; . 블로그 | 그외 백준 공식 레퍼런스 | . input.txt&#47484; &#51060;&#50857;&#54620; local &#54400;&#51060; &#44396;&#51312; . 폴더 input.txt | xxx.py | . | . import sys sys.stdin = open(&quot;./input.txt&quot;, &quot;rt&quot;) # jupyter notebook시 필수 input = sys.stdin.readline # 콘솔에선 미리 안해도되며, 속도향상 필요시만 해준다. / ###################################################### N = int(input()) # print(N) data = list(map(int, input().split())) # print(data) . &#44277;&#48177; &#44592;&#51456; &#45936;&#51060;&#53552; &#51077;&#47141;&#48155;&#44592;(map, int, input.split ) . map객체를 이용해 str -&gt; int 변환했지만, sequence는 아니라 인덱싱을 못한다. a, b = map : 인덱싱은 못해도 할당시 나눠받을 수 있다. | list_ = list(map) : 할당시 나눠받기가 불가능할 정도로 많으면, list()로 sequence로 변환시켜 받아야한다. | . | . # - 1개는 map쓰지말자~! n = int(input().strip()) # 2개 - int a, b= map(int, input().split()) # for문으로 n번 2개씩 n = int(input().strip()) for _ in range(n): a, b= map(int, input().split()) # 3개이상의 - list data = list(map(int, input().split())) # for문으로 n번 3개이상시 n = int(input().strip()) for _ in range(n): data = list(map(int, input().split())) . &#49884;&#44036;&#51012; &#45908; &#48736;&#47476;&#44172; &#45936;&#51060;&#53552; &#51077;&#47141;&#48155;&#44592;(sys &#47784;&#46280;) . sys.stdin.readline() 사용 | 단, 입력 후 엔터가 사용되므로 rstrip() 를 함께 사용 | . import sys str = sys.stdin.readline().rstrip() # 1개 - int import sys n = sys.stdin.readline() # 2개 int import sys N, M = map(int, sys.stdin.readline().split()) # 2차원 리스트 입력 받기 # - 행의 수 N을 입력받고, 각 행의 데이터들을 한번에 받아서 split()해서 열로 들어간다. import sys N = sys.stdin.readline() board = [list(map(int,sys.stdin.readline().split())) for _ in range(N)] . ValueError Traceback (most recent call last) &lt;ipython-input-11-198e9d917b91&gt; in &lt;module&gt; 9 # 2개 int 10 import sys &gt; 11 N, M = map(int, sys.stdin.readline().split()) 12 13 ValueError: not enough values to unpack (expected 2, got 0) . &#44277;&#48177;&#44592;&#51456; &#52636;&#47141;&#49884; *(&#49324;&#50857;&#49884;&#50616;&#54056;&#53433;)&#51004;&#47196; . result = [1, 2, 3] # 기본적인 리스트 출력시 print(result) # [1,2,3] # for loop으로 원소를 하나씩 출력 for i in range(len(result)): print(result[i], end=&#39; &#39;) # 1 2 3 # 리스트의 원소를 언패킹 시켜서 출력 print(*result) # 1 2 3 . [1, 2, 3] 1 2 3 1 2 3 . N x M &#53356;&#44592;&#51032; &#51060;&#52264;&#50896; &#47532;&#49828;&#53944; &#52488;&#44592;&#54868; &#48143; &#51077;&#47141;&#48155;&#44592; . 시뮬레이션 문제에서 주어지는 입력 중 가장 많은 형태의 입력을 list comprehension 으로 받을 수 있다. . n, m = map(int, input().split()) board = [list(map(int, input().split())) for _ in range(n)] visited = [[False]*m for _ in range(n)] print(visited) print(board) # 입력(행 열 -&gt; 열의 갯수만큼 False==0으로 채워진 행x열의 visited 2차원 리스트) # 5 9 # 0 0 0 0 0 0 0 0 0 # 0 0 0 1 1 0 0 0 0 # 0 0 0 1 1 0 1 1 0 # 0 0 1 1 1 1 1 1 0 # 0 0 1 1 1 1 1 0 0 . [[False, False, False, False, False], [False, False, False, False, False], [False, False, False, False, False]] [[3], [3], [3]] . &#51116;&#44480;&#54632;&#49688;&#50640;&#49436; &#53084;&#49828;&#53469; &#51228;&#54620;(&#51116;&#44480;&#54620;&#46020;) &#54400;&#50612;&#51452;&#44592; . import sys; sys.setrecursionlimit(10000) .",
            "url": "blog.chojaeseong.com/algorithm/2021/08/10/boj_input_codes.html",
            "relUrl": "/algorithm/2021/08/10/boj_input_codes.html",
            "date": " • Aug 10, 2021"
        }
        
    
  
    
        ,"post59": {
            "title": "타이타닉 정리",
            "content": "import numpy as np import pandas as pd # %matplotlib nbagg %matplotlib inline import matplotlib.pyplot as plt import matplotlib import seaborn as sns sns.set(font_scale=1.5) sns.set_style(&#39;whitegrid&#39;) #whitegrid sns.set_palette(&#39;muted&#39;) # 한글사용가능하게하기 from matplotlib import font_manager font_name = font_manager.FontProperties(fname=&#39;C:/Windows/Fonts/malgun.ttf&#39;).get_name() matplotlib.rc(&#39;font&#39;, family=font_name) print (plt.rcParams[&#39;font.family&#39;] ) . [&#39;Malgun Gothic&#39;] . &#45936;&#51060;&#53552; &#47196;&#46377; . import pandas as pd train = pd.read_csv(&#39;data/titanic/train.csv&#39;) test = pd.read_csv(&#39;data/titanic/test.csv&#39;) . &#45936;&#51060;&#53552; &#54869;&#51064; . train과 test 비교후, test에 없는 칼럼이 종속변수 | head()와 info()를 비교하여 범주형과 숫자형의 type이 제대로 되었는지 확인하기 | . print(train.shape) print(train.columns) train.head() . (891, 12) Index([&#39;PassengerId&#39;, &#39;Survived&#39;, &#39;Pclass&#39;, &#39;Name&#39;, &#39;Sex&#39;, &#39;Age&#39;, &#39;SibSp&#39;, &#39;Parch&#39;, &#39;Ticket&#39;, &#39;Fare&#39;, &#39;Cabin&#39;, &#39;Embarked&#39;], dtype=&#39;object&#39;) . PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | male | 22.0 | 1 | 0 | A/5 21171 | 7.2500 | NaN | S | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | female | 38.0 | 1 | 0 | PC 17599 | 71.2833 | C85 | C | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | female | 26.0 | 0 | 0 | STON/O2. 3101282 | 7.9250 | NaN | S | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 | 1 | 0 | 113803 | 53.1000 | C123 | S | . 4 5 | 0 | 3 | Allen, Mr. William Henry | male | 35.0 | 0 | 0 | 373450 | 8.0500 | NaN | S | . train.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 891 entries, 0 to 890 Data columns (total 12 columns): PassengerId 891 non-null int64 Survived 891 non-null int64 Pclass 891 non-null int64 Name 891 non-null object Sex 891 non-null object Age 714 non-null float64 SibSp 891 non-null int64 Parch 891 non-null int64 Ticket 891 non-null object Fare 891 non-null float64 Cabin 204 non-null object Embarked 889 non-null object dtypes: float64(2), int64(5), object(5) memory usage: 83.6+ KB . print(test.shape) print(test.columns) test.head() . (418, 11) Index([&#39;PassengerId&#39;, &#39;Pclass&#39;, &#39;Name&#39;, &#39;Sex&#39;, &#39;Age&#39;, &#39;SibSp&#39;, &#39;Parch&#39;, &#39;Ticket&#39;, &#39;Fare&#39;, &#39;Cabin&#39;, &#39;Embarked&#39;], dtype=&#39;object&#39;) . PassengerId Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked . 0 892 | 3 | Kelly, Mr. James | male | 34.5 | 0 | 0 | 330911 | 7.8292 | NaN | Q | . 1 893 | 3 | Wilkes, Mrs. James (Ellen Needs) | female | 47.0 | 1 | 0 | 363272 | 7.0000 | NaN | S | . 2 894 | 2 | Myles, Mr. Thomas Francis | male | 62.0 | 0 | 0 | 240276 | 9.6875 | NaN | Q | . 3 895 | 3 | Wirz, Mr. Albert | male | 27.0 | 0 | 0 | 315154 | 8.6625 | NaN | S | . 4 896 | 3 | Hirvonen, Mrs. Alexander (Helga E Lindqvist) | female | 22.0 | 1 | 1 | 3101298 | 12.2875 | NaN | S | . test.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 418 entries, 0 to 417 Data columns (total 11 columns): PassengerId 418 non-null int64 Pclass 418 non-null int64 Name 418 non-null object Sex 418 non-null object Age 332 non-null float64 SibSp 418 non-null int64 Parch 418 non-null int64 Ticket 418 non-null object Fare 417 non-null float64 Cabin 91 non-null object Embarked 418 non-null object dtypes: float64(2), int64(4), object(5) memory usage: 36.0+ KB . &#52860;&#47100;&#47749; &#49548;&#47928;&#51088;&#47196; &#51068;&#44292;&#48320;&#44221; . &#48169;&#48277;1 : &#46357;&#49492;&#45320;&#47532; &#54805;&#53468;&#47196; &#48320;&#44221;( &#51068;&#48512;&#48516;&#47564; &#44032;&#45733;) . train = train.rename( columns = { &#39;PassengerId&#39; : &#39;passengerid&#39;, &#39;Pclass&#39; : &#39;pclass&#39; , &#39;Name&#39; : &#39;name&#39;, &#39;Sex&#39; : &#39;sex&#39;, &#39;Age&#39; : &#39;age&#39;, &#39;SibSp&#39; : &#39;sibsp&#39;, &#39;Ticket&#39; : &#39;ticket&#39; , &#39;Fare&#39; : &#39;fare&#39;, &#39;Cabin&#39; : &#39;cabin&#39;, &#39;Embarked&#39; : &#39;embarked&#39;, &#39;Parch&#39; : &#39;Parch&#39;.lower() , &#39;Survived&#39; : &#39;survived&#39;, }) . test = test.rename( columns = { &#39;PassengerId&#39; : &#39;passengerid&#39;, &#39;Pclass&#39; : &#39;pclass&#39; , &#39;Name&#39; : &#39;name&#39;, &#39;Sex&#39; : &#39;sex&#39;, &#39;Age&#39; : &#39;age&#39;, &#39;SibSp&#39; : &#39;sibsp&#39;, &#39;Ticket&#39; : &#39;ticket&#39; , &#39;Fare&#39; : &#39;fare&#39;, &#39;Cabin&#39; : &#39;cabin&#39;, &#39;Embarked&#39; : &#39;embarked&#39;, &#39;Parch&#39; : &#39;Parch&#39;.lower() , # &#39;Survived&#39; : &#39;survived&#39;, }) . &#47532;&#49828;&#53944; &#52980;&#54532;&#47532;&#54760;&#49496;&#51012; &#53685;&#54620; &#54620;&#48264;&#50640; &#49548;&#47928;&#51088; &#52376;&#47532; . train.columns . Index([&#39;passengerid&#39;, &#39;survived&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;age&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;ticket&#39;, &#39;fare&#39;, &#39;cabin&#39;, &#39;embarked&#39;], dtype=&#39;object&#39;) . [col.lower() for col in train.columns] . [&#39;passengerid&#39;, &#39;survived&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;age&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;ticket&#39;, &#39;fare&#39;, &#39;cabin&#39;, &#39;embarked&#39;] . train.columns = [col.lower() for col in train.columns] train.head() . passengerid survived pclass name sex age sibsp parch ticket fare cabin embarked . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | male | 22.0 | 1 | 0 | A/5 21171 | 7.2500 | NaN | S | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | female | 38.0 | 1 | 0 | PC 17599 | 71.2833 | C85 | C | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | female | 26.0 | 0 | 0 | STON/O2. 3101282 | 7.9250 | NaN | S | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 | 1 | 0 | 113803 | 53.1000 | C123 | S | . 4 5 | 0 | 3 | Allen, Mr. William Henry | male | 35.0 | 0 | 0 | 373450 | 8.0500 | NaN | S | . &#48276;&#51452; &lt;-&gt; &#49707;&#51088; type &#51228;&#45824;&#47196; &#46104;&#50632;&#45716;&#51648; &#54869;&#51064; . Pclass 범주인데 숫자로 | Survived 범주인데 숫자로 | Parch 도 | Sipsp 도 | . train[&#39;survived&#39;] = train[&#39;survived&#39;].astype( object ) train[&#39;pclass&#39;] = train[&#39;pclass&#39;].astype( object ) train[&#39;parch&#39;] = train[&#39;parch&#39;].astype( object ) train[&#39;sibsp&#39;] = train[&#39;sibsp&#39;].astype( object ) . test[&#39;pclass&#39;] = test[&#39;pclass&#39;].astype( object ) train[&#39;parch&#39;] = train[&#39;parch&#39;].astype( object ) train[&#39;sibsp&#39;] = train[&#39;sibsp&#39;].astype( object ) . Null &#52404;&#53356; . train.isnull().sum() . passengerid 0 survived 0 pclass 0 name 0 sex 0 age 177 sibsp 0 parch 0 ticket 0 fare 0 cabin 687 embarked 2 dtype: int64 . train.isnull().sum().reset_index() . index 0 . 0 passengerid | 0 | . 1 survived | 0 | . 2 pclass | 0 | . 3 name | 0 | . 4 sex | 0 | . 5 age | 177 | . 6 sibsp | 0 | . 7 parch | 0 | . 8 ticket | 0 | . 9 fare | 0 | . 10 cabin | 687 | . 11 embarked | 2 | . missing_df = train.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df . columns count . 0 passengerid | 0 | . 1 survived | 0 | . 2 pclass | 0 | . 3 name | 0 | . 4 sex | 0 | . 5 age | 177 | . 6 sibsp | 0 | . 7 parch | 0 | . 8 ticket | 0 | . 9 fare | 0 | . 10 cabin | 687 | . 11 embarked | 2 | . missing_df = train.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df[&#39;missing_rate&#39;] = missing_df[&#39;count&#39;] / train.shape[0] # 미싱 갯수 / 전체데이터의 데이터수 - shape(row,col)의 첫번째!! missing_df . columns count missing_rate . 0 passengerid | 0 | 0.000000 | . 1 survived | 0 | 0.000000 | . 2 pclass | 0 | 0.000000 | . 3 name | 0 | 0.000000 | . 4 sex | 0 | 0.000000 | . 5 age | 177 | 0.198653 | . 6 sibsp | 0 | 0.000000 | . 7 parch | 0 | 0.000000 | . 8 ticket | 0 | 0.000000 | . 9 fare | 0 | 0.000000 | . 10 cabin | 687 | 0.771044 | . 11 embarked | 2 | 0.002245 | . train . missing_df = train.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df[&#39;missing_rate&#39;] = missing_df[&#39;count&#39;] / train.shape[0] # 미싱 갯수 / 전체데이터의 데이터수 - shape(row,col)의 첫번째!! missing_df.loc[ missing_df[&#39;missing_rate&#39;] != 0, :] # missing_Rate가 0이 아닌 것들만 가졍괴 . columns count missing_rate . 5 age | 177 | 0.198653 | . 10 cabin | 687 | 0.771044 | . 11 embarked | 2 | 0.002245 | . test . missing_df = test.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df[&#39;missing_rate&#39;] = missing_df[&#39;count&#39;] / test.shape[0] # 미싱 갯수 / 전체데이터의 데이터수 - shape(row,col)의 첫번째!! missing_df.loc[ missing_df[&#39;missing_rate&#39;] != 0, :] # missing_Rate가 0이 아닌 것들만 가졍괴 . columns count missing_rate . 4 age | 86 | 0.205742 | . 8 fare | 1 | 0.002392 | . 9 cabin | 327 | 0.782297 | . &#51333;&#49549;&#48320;&#49688; &#54869;&#51064; &#48143; &#51333;&#49549;&#48320;&#49688;&#50640; &#45824;&#54620; &#45796;&#47480;&#48320;&#49688;&#46308; &#44288;&#44228; &#52628;&#47200; . &#51333;&#49549;&#48320;&#49688;&#51032; &#48276;&#51452;&#48324; &#48712;&#46020; &#52404;&#53356; . matplotlib &#44592;&#48376; . train[&#39;survived&#39;].value_counts().plot(kind=&#39;bar&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x259dad8add8&gt; . sns . fig, ax = plt.subplots(1, 2, # 1x2 Pieplot + barplot figsize= (12,8)) # 1 X1 Pie plot train[&#39;survived&#39;].value_counts().plot.pie( explode = [0, 0.1], autopct = &#39;%1.1f%%&#39;, # 퍼센트는 소수점1자리까지 ax = ax[0], shadow = True ) ax[0].set_title(&#39;Pie plot&#39;) ax[0].set_ylabel(&#39;&#39;) # # 1 X 2 bar plot (sns.countplot) # train[&#39;survived&#39;].value_counts().plot( # kind= &#39;bar&#39;, # ax = ax[1], # ) sns.countplot( &#39;survived&#39;, #칼럼명 data = train, # df ax = ax[1] # 좌표평면 ) plt.tight_layout() . import relationship as r r.categorical_all(train, &#39;survived&#39;) . 0 549 1 342 Name: survived, dtype: int64 . &#45800;&#48320;&#49688; &#53456;&#49353;1 : &#48276;&#51452;&#54805; &#52860;&#47100;&#51032; &#48712;&#46020; . &#48276;&#51452;&#54805; &#52860;&#47100;&#47749;&#47564; &#44032;&#51256;&#50724;&#44592; &amp; id&#50752; &#51333;&#49549;&#48320;&#49688; &#51228;&#50808;&#49884;&#53412;&#44592; . train[&#39;survived&#39;].dtypes . train[&#39;survived&#39;].dtypes == &quot;object&quot; . category_feature = [ col for col in train.columns if train[col].dtypes == &quot;object&quot;] category_feature . [&#39;survived&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;ticket&#39;, &#39;cabin&#39;, &#39;embarked&#39;] . id&#52860;&#47100;&#44284; &#51333;&#49549;&#48320;&#49688;&#52860;&#47100; &#51228;&#50808;&#49884;&#53412;&#44592; by set . # set으로 마이너스 연산을 한 뒤, list()로 감싸서 다시 리스트로 만든다. categorical_feature = list( set(category_feature) - set( [&#39;passengerid&#39;, &#39;survived&#39;]) ) categorical_feature . [&#39;embarked&#39;, &#39;ticket&#39;, &#39;parch&#39;, &#39;cabin&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;sibsp&#39;] . &#48276;&#51452;&#52860;&#47100;&#47749; &#47532;&#49828;&#53944;&#47484; &#51060;&#50857;&#54620; &#48276;&#51452;&#52860;&#47100;&#46308; &#54620;&#44732;&#48264;&#50640; &#48712;&#46020; &#48372;&#44592; . for col in categorical_feature: f, ax = plt.subplots(1, 1, figsize=(10,7)) sns.countplot( col, #칼럼명 data = train, # df ) plt.title(col) plt.show() # 여러개 그림을 한셀에 띄울 때, plt.show()를 통해 하나씩 끊어주기! . &#54632;&#49688;&#54868;&#54616;&#44592; ( &#45800;&#48320;&#49688; &#48276;&#51452;&#54805; &#52860;&#47100;&#51032; &#48712;&#46020; ) with &#48276;&#51452;&#54805; &#52860;&#47100;&#47749; &#47532;&#49828;&#53944; . def categorical_all(df, categorical_feature): # 칼럼명 하나만 입력시 if type(categorical_feature) is str: sns.countplot( categorical_feature, #칼럼명 1개 data = df, # df ) plt.title(categorical_feature) #칼럼명 1개 plt.tight_layout() plt.show() # 여러개 그림을 한셀에 띄울 때, plt.show()를 통해 하나씩 끊어주기! else: # 범주형 칼럼명 리스트가 들어왔을 때 for col in categorical_feature: sns.countplot( col, #칼럼명 data = df, # df ) plt.title(col) plt.tight_layout() plt.show() # 여러개 그림을 한셀에 띄울 때, plt.show()를 통해 하나씩 끊어주기! . categorical_all(train, &#39;cabin&#39;) . categorical_all(train, categorical_feature) . &#45800;&#48320;&#49688; &#53456;&#49353;2 : &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252; . &#49707;&#51088;&#54805; &#52860;&#47100;&#47749; &#44032;&#51256;&#50724;&#44592; = &#51204;&#52404;&#52860;&#47100; - &#48276;&#51452;&#54805;&#52860;&#47100; - (id+&#51333;&#49549;&#48320;&#49688;) . train.head() . passengerid survived pclass name sex age sibsp parch ticket fare cabin embarked . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | male | 22.0 | 1 | 0 | A/5 21171 | 7.2500 | NaN | S | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | female | 38.0 | 1 | 0 | PC 17599 | 71.2833 | C85 | C | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | female | 26.0 | 0 | 0 | STON/O2. 3101282 | 7.9250 | NaN | S | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 | 1 | 0 | 113803 | 53.1000 | C123 | S | . 4 5 | 0 | 3 | Allen, Mr. William Henry | male | 35.0 | 0 | 0 | 373450 | 8.0500 | NaN | S | . numerical_feature = list( set(train.columns) - set(categorical_feature) - set([&#39;passengerid&#39;, &#39;survived&#39;]) ) numerical_feature . [&#39;age&#39;, &#39;fare&#39;] . np.sort(numerical_feature) . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . numerical_feature = list( set(train.columns) - set(categorical_feature) - set([&#39;passengerid&#39;, &#39;survived&#39;]) ) numerical_feature = np.sort(numerical_feature) numerical_feature . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252; sns.distplot &#54620;&#44732;&#48264;&#50640; &#44536;&#47532;&#44592; . for col in numerical_feature: print(train[col].describe()) sns.distplot( train.loc[train[col].notnull(), col] ) # 해당칼럼 중 NaN아닌것만 인덱싱한 칼럼만 그리기 plt.title(col) plt.show() . count 714.000000 mean 29.699118 std 14.526497 min 0.420000 25% 20.125000 50% 28.000000 75% 38.000000 max 80.000000 Name: age, dtype: float64 . count 891.000000 mean 32.204208 std 49.693429 min 0.000000 25% 7.910400 50% 14.454200 75% 31.000000 max 512.329200 Name: fare, dtype: float64 . &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252;2 boxplot . for col in numerical_feature: print(train[col].describe()) sns.boxplot( data=train.loc[train[col].notnull(), col] ) plt.title(col) plt.show() . count 714.000000 mean 29.699118 std 14.526497 min 0.420000 25% 20.125000 50% 28.000000 75% 38.000000 max 80.000000 Name: age, dtype: float64 . count 891.000000 mean 32.204208 std 49.693429 min 0.000000 25% 7.910400 50% 14.454200 75% 31.000000 max 512.329200 Name: fare, dtype: float64 . &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252;( hist(dist) + boxplot ) &#54620;&#48264;&#50640; &#44536;&#47532;&#44592; . for col in numerical_feature: # 숫자형 칼럼의 기술통계량 print(train[col].describe()) print(f&quot;Skewed : {train[col].skew():.2f}&quot;) f, ax = plt.subplots(1, 2, figsize=(18,9)) # dist sns.distplot( train.loc[train[col].notnull(), col], ax = ax[0] ) ax[0].set_title(col +&#39; &#39;s hist(dist) plot&#39; ) # boxplot sns.boxplot( data=train.loc[train[col].notnull(), col], ax = ax[1] ) ax[1].set_title(col +&#39; &#39;s boxplot&#39;) plt.tight_layout() plt.show() . count 714.000000 mean 29.699118 std 14.526497 min 0.420000 25% 20.125000 50% 28.000000 75% 38.000000 max 80.000000 Name: age, dtype: float64 Skewed : 0.39 . count 891.000000 mean 32.204208 std 49.693429 min 0.000000 25% 7.910400 50% 14.454200 75% 31.000000 max 512.329200 Name: fare, dtype: float64 Skewed : 4.79 . &#54632;&#49688;&#54868;&#54616;&#44592; ( &#45800;&#48320;&#49688; &#49707;&#51088;&#54805; &#48516;&#54252; dist+boxplot ) with &#49707;&#51088;&#54805; &#52860;&#47100;&#47749; &#47532;&#49828;&#53944; . def numerical_all(df, numerical_feature): for col in numerical_feature: # 숫자형 칼럼의 기술통계량 print(df[col].describe()) print(f&quot;Skewed : {train[col].skew():.2f}&quot;) f, ax = plt.subplots(1, 2, figsize=(18,9)) # dist sns.distplot( df.loc[train[col].notnull(), col], ax = ax[0] ) ax[0].set_title(col +&#39; &#39;s hist(dist) plot&#39; ) ax[0].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 # boxplot sns.boxplot( data=df.loc[df[col].notnull(), col], ax = ax[1] ) ax[1].set_title(col +&#39; &#39;s boxplot&#39;) ax[1].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 plt.tight_layout() plt.show() . &#51060;&#48320;&#49688; &#53456;&#49353;1 : &#51333;&#49549;&#48320;&#49688;(&#48276;&#51452;)&#48324; - &#48276;&#51452;&#54805; &#48320;&#49688; . &#48169;&#48277;1: &#53945;&#51221;(&#51333;&#49549;)&#48276;&#51452;&#48324; &#48276;&#51452;&#52860;&#47100; &#51064;&#45937;&#49905;&#54616;&#50668;&#49436; &#44033; &#48276;&#51452;&#48324; series&#47484; df&#47196; &#54633;&#52824;&#44592; . survived = train.loc[ train[&#39;survived&#39;] == 0,&#39;sex&#39; ].value_counts() survived.name = &#39;Survived&#39; dead = train.loc[ train[&#39;survived&#39;] == 1,&#39;sex&#39; ].value_counts() dead.name = &#39;Dead&#39; # 시리즈를 리스트형식으로 df합치기 df = pd.DataFrame( [ survived, dead] ) df.head() . male female . Survived 468 | 81 | . Dead 109 | 233 | . print(df) df.plot(kind=&#39;bar&#39;) . male female Survived 468 81 Dead 109 233 . &lt;matplotlib.axes._subplots.AxesSubplot at 0x2962005c550&gt; . &#48169;&#48277;2 : pd.crosstab &#51004;&#47196; &#44536;&#47532;&#44592; . &#48712;&#46020; . pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;]) . survived 0 1 . sex . female 81 | 233 | . male 468 | 109 | . pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;]).plot(kind=&#39;barh&#39;, stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x296212901d0&gt; . pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;], margins = True).style.background_gradient(cmap=&#39;summer_r&#39;) . survived 0 1 All . sex . female 81 | 233 | 314 | . male 468 | 109 | 577 | . All 549 | 342 | 891 | . &#48708;&#50984; . cross = pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;]) cross_ratio = cross / cross.sum() cross_ratio . survived 0 1 . sex . female 0.147541 | 0.681287 | . male 0.852459 | 0.318713 | . cross_ratio.plot(kind=&#39;bar&#39;, stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cfa31ef0&gt; . cross_ratio.transpose().plot(kind=&#39;bar&#39;, stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cfd34eb8&gt; . &#48169;&#48277;3 : groupby( &#48276;&#51452;) [ &#51333;&#49549;&#48320;&#49688;].&#51665;&#44228;.unstack() - &#48712;&#46020;+&#54217;&#44512;&#46020; &#44032;&#45733; + &#44032;&#49345;df&#47196;&#49436; apply()&#47196; &#48708;&#50984;&#44228;&#49328;&#44032;&#45733;&#54632; . &#48712;&#46020; . sex_to_survived = train.groupby(&#39;sex&#39;) [&#39;survived&#39;].value_counts().unstack() sex_to_survived . survived 0 1 . sex . female 81 | 233 | . male 468 | 109 | . sex_to_survived.plot(kind=&#39;bar&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cf4b85f8&gt; . &#48708;&#50984; : groupby( [&#39;&#48276;&#51452;&#39; ,&#39;&#51333;&#49549;&#39;]) [&#39;&#51333;&#49549;&#39;] &#51004;&#47196; &#48708;&#50984; &#44228;&#49328;&#54616;&#44592; . 비율을 계산하려면, 숫자칼럼 형태( 범주에서 counts() .unstack()도 먹인상태) | .count().unstack() : 범주별, 종속별, 종속의 범주마다 row단순 count -&gt; 칼럼으로 | .count().unstack() 한 것을 칼럼별로 계산하도록 df/df.sum() 으로 비율계산 | .transpose() 를 통해 index = x축에 종속변수가 가야 비율이 가득찬다 | . dict( list( train.groupby([&#39;sex&#39;, &#39;survived&#39;]) ) ).keys() . dict_keys([(&#39;female&#39;, 0), (&#39;female&#39;, 1), (&#39;male&#39;, 0), (&#39;male&#39;, 1)]) . dict( list( train.groupby([&#39;sex&#39;, &#39;survived&#39;]) ) )[&#39;female&#39;, 0].head() . passengerid survived pclass name sex age sibSp parch ticket fare cabin embarked . 14 15 | 0 | 3 | Vestrom, Miss. Hulda Amanda Adolfina | female | 14.0 | 0 | 0 | 350406 | 7.8542 | NaN | S | . 18 19 | 0 | 3 | Vander Planke, Mrs. Julius (Emelia Maria Vande... | female | 31.0 | 1 | 0 | 345763 | 18.0000 | NaN | S | . 24 25 | 0 | 3 | Palsson, Miss. Torborg Danira | female | 8.0 | 3 | 1 | 349909 | 21.0750 | NaN | S | . 38 39 | 0 | 3 | Vander Planke, Miss. Augusta Maria | female | 18.0 | 2 | 0 | 345764 | 18.0000 | NaN | S | . 40 41 | 0 | 3 | Ahlin, Mrs. Johan (Johanna Persdotter Larsson) | female | 40.0 | 1 | 0 | 7546 | 9.4750 | NaN | S | . train.groupby(&#39;sex&#39;)[&#39;survived&#39;].value_counts() . sex survived female 1 233 0 81 male 0 468 1 109 Name: survived, dtype: int64 . cross_df = train.groupby(&#39;sex&#39;) [&#39;survived&#39;].value_counts().unstack() cross_ratio = cross_df / cross_df.sum() cross_ratio . survived 0 1 . sex . female 0.147541 | 0.681287 | . male 0.852459 | 0.318713 | . cross_ratio.transpose().plot(kind=&#39;bar&#39;, stacked=True, figsize=(10,8)) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196d17e84a8&gt; . &#48169;&#48277;4 : sns.countplot( &#39;&#48276;&#51452;&#52860;&#47100;&#39; , hue= &#39;&#51333;&#49549;&#48320;&#49688;&#39; ) -&gt; &#48708;&#50984;&#51008; &#48380; &#49688; &#50630;&#45796; . sns.countplot(&#39;sex&#39;, data = train, hue=&#39;survived&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cfa68080&gt; . &#48276;&#51452;-&#51333;&#49549;(&#48276;&#51452;) &#51333;&#49549;&#48320;&#49688;&#48324; &#48276;&#51452;&#51032; &#48708;&#50984; &#54620;&#48264;&#50640; &#44536;&#47532;&#44592; . cross_df = train.groupby(&#39;pclass&#39;)[&#39;survived&#39;].value_counts().unstack() # 세로로 합하고, 칼럼별로 나누어 비율계산하기 print(pd.DataFrame(cross_df)) cross_ratio = cross_df/ cross_df.sum() # 세로방향기준으로 각 비율이 나눠져있는데, 그냥 그리면 row별로 x축에 틱이 찍힘 # 뒤집기 cross_ratio = cross_ratio.transpose() cross_ratio.plot(kind=&#39;bar&#39;, stacked=True, figsize=(10,5)) . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . &lt;matplotlib.axes._subplots.AxesSubplot at 0x1dd55006e48&gt; . &#51333;&#49549;-&#48276;&#51452;&#54805;&#48320;&#49688; &#44288;&#44228; &#54632;&#49688;&#51221;&#51032;&#54616;&#44592; . def cate_to_categorical(data,name_c, name_d ): # index 범주형 변수/ col 종속 변수 cross_df = data.groupby( name_c)[name_d].value_counts().unstack() # 세로로 합하고, 칼럼별로 나누어 비율계산하기 print(cross_df) cross_ratio = cross_df/ cross_df.sum() # 세로방향기준으로 각 비율이 나눠져있는데, 그냥 그리면 row별로 x축에 틱이 찍힘 # 뒤집기 cross_ratio = cross_ratio.transpose() f, ax = plt.subplots(1, 2, figsize=(18,9)) cross_df.plot(kind=&#39;bar&#39;, ax=ax[0]) ax[0].set_title(name_c +&#39; to &#39; +name_d ) ax[0].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 cross_ratio.plot(kind=&#39;bar&#39;, ax = ax[1], stacked=True) ax[1].set_title(name_d +&#39; to &#39;+name_c +&#39; ratio&#39; ) ax[1].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0)) # 범례 밖으로 빼기 plt.tight_layout() plt.show() # for문에 들어갈 것 대비 끝내기 . relationship_new.cate_to_categorical(train, &#39;survived&#39;, &#39;sex&#39;) . survived 0 1 sex female 81 233 male 468 109 . cate_to_categorical(train, &#39;survived&#39;, &#39;pclass&#39;) . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . import relationship_new relationship_new.cate_to_categorical(train, &#39;survived&#39;, &#39;pclass&#39;) . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . relationship_new.cate_to_categorical(train, &#39;survived&#39;, &#39;parch&#39;) . survived 0 1 parch 0 445.0 233.0 1 53.0 65.0 2 40.0 40.0 3 2.0 3.0 4 4.0 NaN 5 4.0 1.0 6 1.0 NaN . for+&#54632;&#49688;(&#48276;&#51452;-&#48276;&#51452;)&#47928;&#51012; &#53685;&#54644; &#47784;&#46304; &#51333;&#49549;&#52860;&#47100;&#50640; &#45824;&#54644; &#47784;&#46304; &#48276;&#51452;&#52860;&#47100;&#51032; &#48516;&#54252;&#50752; &#48708;&#50984; &#44536;&#47140;&#48372;&#44592; . 범주가 너무 많을때는 금지!! feature engineering | . for col in categorical_feature: relationship_new.cate_to_categorical(train, &#39;survived&#39;, col) . survived 0 1 embarked C 75 93 Q 47 30 S 427 217 . survived 0 1 sex female 81 233 male 468 109 . survived 0 1 name Abbing, Mr. Anthony 1.0 NaN Abbott, Mr. Rossmore Edward 1.0 NaN Abbott, Mrs. Stanton (Rosa Hunt) NaN 1.0 Abelson, Mr. Samuel 1.0 NaN Abelson, Mrs. Samuel (Hannah Wizosky) NaN 1.0 Adahl, Mr. Mauritz Nils Martin 1.0 NaN Adams, Mr. John 1.0 NaN Ahlin, Mrs. Johan (Johanna Persdotter Larsson) 1.0 NaN Aks, Mrs. Sam (Leah Rosen) NaN 1.0 Albimona, Mr. Nassef Cassem NaN 1.0 Alexander, Mr. William 1.0 NaN Alhomaki, Mr. Ilmari Rudolf 1.0 NaN Ali, Mr. Ahmed 1.0 NaN Ali, Mr. William 1.0 NaN Allen, Miss. Elisabeth Walton NaN 1.0 Allen, Mr. William Henry 1.0 NaN Allison, Master. Hudson Trevor NaN 1.0 Allison, Miss. Helen Loraine 1.0 NaN Allison, Mrs. Hudson J C (Bessie Waldo Daniels) 1.0 NaN Allum, Mr. Owen George 1.0 NaN Andersen-Jensen, Miss. Carla Christine Nielsine NaN 1.0 Anderson, Mr. Harry NaN 1.0 Andersson, Master. Sigvard Harald Elias 1.0 NaN Andersson, Miss. Ebba Iris Alfrida 1.0 NaN Andersson, Miss. Ellis Anna Maria 1.0 NaN Andersson, Miss. Erna Alexandra NaN 1.0 Andersson, Miss. Ingeborg Constanzia 1.0 NaN Andersson, Miss. Sigrid Elisabeth 1.0 NaN Andersson, Mr. Anders Johan 1.0 NaN Andersson, Mr. August Edvard (&#34;Wennerstrom&#34;) NaN 1.0 ... ... ... Widegren, Mr. Carl/Charles Peter 1.0 NaN Widener, Mr. Harry Elkins 1.0 NaN Wiklund, Mr. Jakob Alfred 1.0 NaN Wilhelms, Mr. Charles NaN 1.0 Willey, Mr. Edward 1.0 NaN Williams, Mr. Charles Duane 1.0 NaN Williams, Mr. Charles Eugene NaN 1.0 Williams, Mr. Howard Hugh &#34;Harry&#34; 1.0 NaN Williams, Mr. Leslie 1.0 NaN Williams-Lambert, Mr. Fletcher Fellows 1.0 NaN Windelov, Mr. Einar 1.0 NaN Wiseman, Mr. Phillippe 1.0 NaN Woolner, Mr. Hugh NaN 1.0 Wright, Mr. George 1.0 NaN Yasbeck, Mr. Antoni 1.0 NaN Yasbeck, Mrs. Antoni (Selini Alexander) NaN 1.0 Young, Miss. Marie Grice NaN 1.0 Youseff, Mr. Gerious 1.0 NaN Yousif, Mr. Wazli 1.0 NaN Yousseff, Mr. Gerious 1.0 NaN Yrois, Miss. Henriette (&#34;Mrs Harbeck&#34;) 1.0 NaN Zabour, Miss. Hileni 1.0 NaN Zabour, Miss. Thamine 1.0 NaN Zimmerman, Mr. Leo 1.0 NaN de Messemaeker, Mrs. Guillaume Joseph (Emma) NaN 1.0 de Mulder, Mr. Theodore NaN 1.0 de Pelsmaeker, Mr. Alfons 1.0 NaN del Carlo, Mr. Sebastiano 1.0 NaN van Billiard, Mr. Austin Blyler 1.0 NaN van Melkebeke, Mr. Philemon 1.0 NaN [891 rows x 2 columns] . C: Users is2js Anaconda3 lib site-packages matplotlib tight_layout.py:181: UserWarning: Tight layout not applied. The bottom and top margins cannot be made large enough to accommodate all axes decorations. warnings.warn(&#39;Tight layout not applied. &#39; . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . survived 0 1 cabin A10 1.0 NaN A14 1.0 NaN A16 NaN 1.0 A19 1.0 NaN A20 NaN 1.0 A23 NaN 1.0 A24 1.0 NaN A26 NaN 1.0 A31 NaN 1.0 A32 1.0 NaN A34 NaN 1.0 A36 1.0 NaN A5 1.0 NaN A6 NaN 1.0 A7 1.0 NaN B101 NaN 1.0 B102 1.0 NaN B18 NaN 2.0 B19 1.0 NaN B20 NaN 2.0 B22 1.0 1.0 B28 NaN 2.0 B3 NaN 1.0 B30 1.0 NaN B35 NaN 2.0 B37 1.0 NaN B38 1.0 NaN B39 NaN 1.0 B4 NaN 1.0 B41 NaN 1.0 ... ... ... E12 NaN 1.0 E121 NaN 2.0 E17 NaN 1.0 E24 NaN 2.0 E25 NaN 2.0 E31 1.0 NaN E33 NaN 2.0 E34 NaN 1.0 E36 NaN 1.0 E38 1.0 NaN E40 NaN 1.0 E44 1.0 1.0 E46 1.0 NaN E49 NaN 1.0 E50 NaN 1.0 E58 1.0 NaN E63 1.0 NaN E67 1.0 1.0 E68 NaN 1.0 E77 1.0 NaN E8 NaN 2.0 F E69 NaN 1.0 F G63 1.0 NaN F G73 2.0 NaN F2 1.0 2.0 F33 NaN 3.0 F38 1.0 NaN F4 NaN 2.0 G6 2.0 2.0 T 1.0 NaN [147 rows x 2 columns] . C: Users is2js Anaconda3 lib site-packages matplotlib tight_layout.py:181: UserWarning: Tight layout not applied. The bottom and top margins cannot be made large enough to accommodate all axes decorations. warnings.warn(&#39;Tight layout not applied. &#39; . survived 0 1 ticket 110152 NaN 3.0 110413 1.0 2.0 110465 2.0 NaN 110564 NaN 1.0 110813 NaN 1.0 111240 1.0 NaN 111320 1.0 NaN 111361 NaN 2.0 111369 NaN 1.0 111426 NaN 1.0 111427 NaN 1.0 111428 NaN 1.0 112050 1.0 NaN 112052 1.0 NaN 112053 NaN 1.0 112058 1.0 NaN 112059 1.0 NaN 112277 NaN 1.0 112379 1.0 NaN 113028 1.0 NaN 113043 1.0 NaN 113050 1.0 NaN 113051 1.0 NaN 113055 NaN 1.0 113056 1.0 NaN 113059 1.0 NaN 113501 1.0 NaN 113503 1.0 NaN 113505 NaN 2.0 113509 1.0 NaN ... ... ... SOTON/OQ 392082 1.0 NaN SOTON/OQ 392086 1.0 NaN SOTON/OQ 392089 NaN 1.0 SOTON/OQ 392090 1.0 NaN STON/O 2. 3101269 NaN 1.0 STON/O 2. 3101273 1.0 NaN STON/O 2. 3101274 1.0 NaN STON/O 2. 3101275 1.0 NaN STON/O 2. 3101280 1.0 NaN STON/O 2. 3101285 NaN 1.0 STON/O 2. 3101286 NaN 1.0 STON/O 2. 3101288 NaN 1.0 STON/O 2. 3101289 NaN 1.0 STON/O 2. 3101292 1.0 NaN STON/O 2. 3101293 1.0 NaN STON/O 2. 3101294 1.0 NaN STON/O2. 3101271 1.0 NaN STON/O2. 3101279 1.0 1.0 STON/O2. 3101282 NaN 1.0 STON/O2. 3101283 NaN 1.0 STON/O2. 3101290 1.0 NaN SW/PP 751 NaN 1.0 W./C. 14258 NaN 1.0 W./C. 14263 1.0 NaN W./C. 6607 2.0 NaN W./C. 6608 4.0 NaN W./C. 6609 1.0 NaN W.E.P. 5734 1.0 NaN W/C 14208 1.0 NaN WE/P 5735 1.0 1.0 [681 rows x 2 columns] . C: Users is2js Anaconda3 lib site-packages matplotlib tight_layout.py:181: UserWarning: Tight layout not applied. The bottom and top margins cannot be made large enough to accommodate all axes decorations. warnings.warn(&#39;Tight layout not applied. &#39; . &#51060;&#48320;&#49688; &#53456;&#49353;2 &#49707;&#51088;-&#49707;&#51088;&#54805;&#51032; &#49328;&#51216;&#46020;&#54665;&#47148; with &#51333;&#49549;&#48320;&#49688; . numerical_feature . array([&#39;age&#39;, &#39;fare&#39;, &#39;parch&#39;, &#39;sibsp&#39;], dtype=&#39;&lt;U5&#39;) . # list는 (-)연산은 안되도 (+) 연산은 된다. list(numerical_feature) + [&#39;survived&#39;] . [&#39;age&#39;, &#39;fare&#39;, &#39;parch&#39;, &#39;sibsp&#39;, &#39;survived&#39;] . sns.pairplot( train[ list(numerical_feature) + [&#39;survived&#39;] ], hue = &#39;survived&#39;, x_vars = numerical_feature, y_vars = numerical_feature) . C: Users is2js Anaconda3 lib site-packages statsmodels nonparametric kde.py:448: RuntimeWarning: invalid value encountered in greater X = X[np.logical_and(X &gt; clip[0], X &lt; clip[1])] # won&#39;t work for two columns. C: Users is2js Anaconda3 lib site-packages statsmodels nonparametric kde.py:448: RuntimeWarning: invalid value encountered in less X = X[np.logical_and(X &gt; clip[0], X &lt; clip[1])] # won&#39;t work for two columns. . &lt;seaborn.axisgrid.PairGrid at 0x296230e9828&gt; . &#54632;&#49688;&#54868;( &#49707;&#51088; - &#49707;&#51088;&#51032; &#49328;&#51216;&#46020; &#54665;&#47148; : pairplot) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) by &#49707;&#51088;&#54805;&#52860;&#47100;&#47749;&#47532;&#49828;&#53944; . type(numerical_feature) . numpy.ndarray . list().dtype . AttributeError Traceback (most recent call last) &lt;ipython-input-119-0901fc39190d&gt; in &lt;module&gt; -&gt; 1 list().dtype AttributeError: &#39;list&#39; object has no attribute &#39;dtype&#39; . numerical_feature . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . type(list(numerical_feature)) is list . True . len(numerical_feature) . 2 . def num_to_numerical(df, numerical_feature, name_d=None): # 종속변수 없을 때 if name_d == None: sns.pairplot( df[ list(numerical_feature) ] , # 숫자형칼럼들만 인덱싱 x_vars = numerical_feature, y_vars = numerical_feature ) plt.tight_layout() # 숫자 - 숫자 산점도 행렬 with 종속변수 범례 else: sns.pairplot( df[ list(numerical_feature) + [name_d]] , # 숫자형칼럼들 + 종속변수 인덱싱 hue = name_d, # 범례(색)으로 종속변수 추가 x_vars = numerical_feature, y_vars = numerical_feature ) plt.tight_layout() . num_to_numerical(train, {&#39;age&#39;, &#39;fare&#39;}, &#39;survived&#39;) . &#51060;&#48320;&#49688; &#53456;&#49353;3 : &#48276;&#51452;&#48324; - &#49707;&#51088;&#54805; &#52860;&#47100;(&#46308;)&#51032; &#48516;&#54252;(boxplot) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) by &#49707;&#51088;&#54805;&#52860;&#47100;&#47749;&#47532;&#49828;&#53944; . &#48276;&#51452;&#48324; &#49707;&#51088;&#52860;&#47100;1&#44060;&#51032; &#48516;&#54252;(boxplot) . print(train.groupby(&#39;sex&#39;)[&#39;age&#39;].describe()) plt.figure(figsize=(18,9)) sns.boxplot(x=&#39;sex&#39;, y=&#39;age&#39;, data=train.dropna()) plt.title(&quot;Sex - { }&quot;.format(&#39;age&#39;)) plt.show() . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . KeyError Traceback (most recent call last) &lt;ipython-input-277-1a8c01f185d7&gt; in &lt;module&gt; 2 plt.figure(figsize=(18,9)) 3 sns.boxplot(x=&#39;sex&#39;, y=&#39;age&#39;, data=train.dropna()) -&gt; 4 plt.title(&#34;Sex - { }&#34;.format(&#39;age&#39;)) 5 plt.show() KeyError: &#39; &#39; . &#54632;&#49688;&#54868;(&#48276;&#51452;&#48324; &#49707;&#51088;&#52860;&#47100;1&#44060;&#51032; &#48516;&#54252;(boxplot)) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) . def cate_to_num_box(df, name_c, name_n, name_d=None): # 범주별 기술통계량 if name_d != None: print(df.groupby([name_c, name_d])[name_n].describe()) else : print(df.groupby(name_c)[name_n].describe()) # 범주별 boxplot - 범례는 선택 plt.figure(figsize=(18,9)) sns.boxplot(x=name_c, y=name_n, data=df.dropna(), hue = name_d) plt.title(&quot;{} to {}&quot;.format(name_c, name_n)) plt.tight_layout() plt.show() . cate_to_num_box(train, &#39;sex&#39;, &#39;age&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . type(numerical_feature) . numpy.ndarray . type(&quot;age&quot;) . str . &#54632;&#49688;&#54868;( &#48276;&#51452;&#48324; - &#49707;&#51088;&#52860;&#47100;(&#46308;)&#51032; &#48516;&#54252;(boxplot)) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) . def cate_to_num_box(df, name_c, numerical_feature, name_d=None): # 숫자형 칼럼명 1개 ( 칼럼명 = 문자열 1개 직접 입력) if type(numerical_feature) is str: # 범주별 기술통계량 if name_d != None: print(df.groupby([name_c, name_d])[numerical_feature].describe()) else : print(df.groupby(name_c)[numerical_feature].describe()) # 범주별 boxplot - 범례는 선택 plt.figure(figsize=(18,9)) sns.boxplot(x=name_c, y=numerical_feature, data=df.dropna(), hue = name_d) plt.title(&quot;{} to {}&quot;.format(name_c, numerical_feature)) plt.tight_layout() plt.show() # 숫자형 칼럼명 리스트가 들어와서 for문을 돌면서 여러개 그릴 때 else : for col in numerical_feature: if name_d != None: print(df.groupby([name_c, name_d])[col].describe()) else : print(df.groupby(name_c)[col].describe()) plt.figure(figsize=(18,9)) sns.boxplot(x=name_c, # 범주칼럼명 y=col, # 숫자칼럼명 data=df.dropna() , # df hue = name_d ) # 종속칼럼명(선택) plt.title(&quot;{} to {}&quot;.format(name_c, col)) plt.tight_layout() plt.show() . cate_to_num_box(train, &#39;sex&#39;, &#39;age&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . cate_to_num_box(train, &#39;sex&#39;, &#39;age&#39;, &#39;pclass&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 count mean std min 25% 50% 75% max sex pclass female 1 85.0 34.611765 13.612052 2.00 23.000 35.0 44.00 63.0 2 74.0 28.722973 12.872702 2.00 22.250 28.0 36.00 57.0 3 102.0 21.750000 12.729964 0.75 14.125 21.5 29.75 63.0 male 1 101.0 41.281386 15.139570 0.92 30.000 40.0 51.00 80.0 2 99.0 30.740707 14.793894 0.67 23.000 30.0 36.75 70.0 3 253.0 26.507589 12.159514 0.42 20.000 25.0 33.00 74.0 . numerical_feature . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . cate_to_num_box(train, &#39;sex&#39;, numerical_feature, &#39;pclass&#39;) . count mean std min 25% 50% 75% max sex pclass female 1 85.0 34.611765 13.612052 2.00 23.000 35.0 44.00 63.0 2 74.0 28.722973 12.872702 2.00 22.250 28.0 36.00 57.0 3 102.0 21.750000 12.729964 0.75 14.125 21.5 29.75 63.0 male 1 101.0 41.281386 15.139570 0.92 30.000 40.0 51.00 80.0 2 99.0 30.740707 14.793894 0.67 23.000 30.0 36.75 70.0 3 253.0 26.507589 12.159514 0.42 20.000 25.0 33.00 74.0 . count mean std min 25% 50% sex pclass female 1 94.0 106.125798 74.259988 25.9292 57.24480 82.66455 2 76.0 21.970121 10.891796 10.5000 13.00000 22.00000 3 144.0 16.118810 11.690314 6.7500 7.85420 12.47500 male 1 122.0 67.226127 77.548021 0.0000 27.72810 41.26250 2 108.0 19.741782 14.922235 0.0000 12.33125 13.00000 3 347.0 12.661633 11.681696 0.0000 7.75000 7.92500 75% max sex pclass female 1 134.500000 512.3292 2 26.062500 65.0000 3 20.221875 69.5500 male 1 78.459375 512.3292 2 26.000000 73.5000 3 10.008300 69.5500 . &#51060;&#48320;&#49688; &#53456;&#49353;4 : &#48276;&#51452;&#48324; &#49707;&#51088;&#54805;&#52860;&#47100;&#51032; &#48276;&#50948;&#48324; kde&#48516;&#54252; &#53456;&#49353; . facet = sns.FacetGrid(train, hue = &#39;survived&#39;, height = 4.5,aspect=4) facet.map(sns.kdeplot, &#39;age&#39;, shade=True) facet.set(xlim = (0, train[&#39;age&#39;].max())) facet.add_legend() . &lt;seaborn.axisgrid.FacetGrid at 0x2241e1602b0&gt; . facet = sns.FacetGrid(train, hue = &#39;survived&#39;, aspect=4) facet.map(sns.kdeplot, &#39;age&#39;, shade=True) facet.set(xlim = (0, train[&#39;age&#39;].max())) facet.add_legend() plt.xlim([10,20]) . (10, 20) . &#54632;&#49688;&#54868; . # ( dataFrame, &#39;범주형 칼럼명&#39; , &#39;숫자형 칼럼명&#39; ) or # ( dataFrame, &#39;범주형 칼럼명&#39; , &#39;숫자형 칼럼명&#39; , xlim = [ a, b ] ) def cate_to_num_kde(df, name_c, name_n, xlim = None ): print(df.groupby(name_c)[name_n].describe()) facet = sns.FacetGrid(df.dropna(), hue = name_c, aspect=4) # df 및 범주형 변수 설정 및 가로길이(aspect) facet.map(sns.kdeplot, name_n, shade=True) # kdeplot 설정 및 숫자형변수 지정 facet.set(xlim = (df[name_n].min(), df[name_n].max())) # 숫자형 변수의 최소값부터 최대값까지 x범위 최초 지정 facet.add_legend() if xlim != None: print( &#39;범위지정 : {}&#39;.format(xlim)) plt.xlim(xlim) # xlim 지정시 그 범위만 출력 . cate_to_num_kde(train, &#39;sex&#39;, &#39;age&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . cate_to_num_kde(train, &#39;sex&#39;, &#39;age&#39;, xlim = [20, 30]) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 범위지정 : [20, 30] . &#49340;&#48320;&#49688; &#53456;&#49353;1 : &#48276;&#51452;2(&#48276;&#47168;)&#48324;&#47196;&#48372;&#45716; &#48276;&#51452;1(x&#52629;)&#48324; --&gt; &#50672;&#49549;(&#51333;&#49549;)&#48320;&#49688; &#51032; &#48708;&#50984; . 범주1이 종속변수에 끼는 영향에 대해 범주2(범례)의 영향이 있는지(크로스) 없는지(평행) 판단 | . # https://kaggle-kr.tistory.com/17?category=821486 sns.catplot(&#39;sex&#39;, &#39;survived&#39;, hue=&#39;pclass&#39;, data=train, kind=&#39;point&#39;, # default kind - factorplot height=6, aspect=1.5) . &lt;seaborn.axisgrid.FacetGrid at 0x1dd548ba160&gt; . &#54632;&#49688;&#54868; . def legend_to_cate_to_num(df, name_l, name_c, name_n): sns.catplot(name_c, name_n, hue=name_l, data=df, kind=&#39;point&#39;, # default kind - factorplot height=6, aspect=1.5) plt.tight_layout() plt.show() . legend_to_cate_to_num(train, &#39;sex&#39;, &#39;pclass&#39;, &#39;survived&#39;) . &#49340;&#48320;&#49688; &#53456;&#49353;2 : &#48276;&#47168;&#48324;(&#51333;&#49549;&#48320;&#49688;)&#48324;&#47196; &#48372;&#45716; &#48276;&#51452;&#48324;(x&#52629;) &#49707;&#51088;&#54805;(y&#52629;-&#48148;&#51060;&#50732;&#47536;)&#51032; &#48516;&#54252; . sns.violinplot(&quot;pclass&quot;,&quot;age&quot;, hue=&quot;survived&quot;, data=train, scale=&#39;count&#39;, split=True) plt.legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 plt.tight_layout() plt.show() # for문에 들어갈 것 대비 . &#54632;&#49688;&#54868;(&#48276;&#47168;&#48324;(&#51333;&#49549;&#48320;&#49688;)&#48324;&#47196; &#48372;&#45716; &#48276;&#51452;&#48324;(x&#52629;) &#49707;&#51088;&#54805;(y&#52629;-&#48148;&#51060;&#50732;&#47536;)&#51032; &#48516;&#54252;) . def legend_to_cate_to_num_violin(df,name_l, name_c, name_n): sns.violinplot(name_c,name_n, hue=name_l, data=df, scale=&#39;count&#39;, split=True) plt.legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 plt.tight_layout() plt.show() # for문에 들어갈 것 대비 . legend_to_cate_to_num_violin(train, &#39;survived&#39;, &#39;sex&#39;, &#39;age&#39;) . categorical_all(train, &#39;embarked&#39;) . cate_to_categorical(train, &#39;survived&#39;, &#39;embarked&#39;) . survived 0 1 embarked C 75 93 Q 47 30 S 427 217 .",
            "url": "blog.chojaeseong.com/data/2021/08/06/%EC%97%91%EC%85%80%EC%A0%95%EB%A6%AC-05-%EC%BA%90%EA%B8%80-1-%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89-%EB%B3%80%EC%88%98%EB%B3%84-EDA-+-%ED%95%A8%EC%88%98%EC%A0%95%EC%9D%98%EB%A1%9C-%EC%A0%95%EC%9D%98(upload).html",
            "relUrl": "/data/2021/08/06/%EC%97%91%EC%85%80%EC%A0%95%EB%A6%AC-05-%EC%BA%90%EA%B8%80-1-%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89-%EB%B3%80%EC%88%98%EB%B3%84-EDA-+-%ED%95%A8%EC%88%98%EC%A0%95%EC%9D%98%EB%A1%9C-%EC%A0%95%EC%9D%98(upload).html",
            "date": " • Aug 6, 2021"
        }
        
    
  
    
        ,"post60": {
            "title": "fastpages로 블로그 제작",
            "content": "1 fastpages 만들기 . 클릭만으로 repo, actions key 생성/ 추가 merge | . google에서 fastpages검색후 &gt; 깃허브 &gt; setup instruction &gt; on this link (generating by link) . is2js(@naver.com) / 12!@ | . | 블로그 원본 내용이 들어갈 레포지토리 생성임.(github.io 아님) . is2js/blog_raw 이후 자동으로 https://is2js.github.io/blog_raw/ 로 생성된다. | . | . | 조금 기다리면, Pull Request가 자동으로 올라온다. . link클릭으로 create/clone repo + PR으로 설치까지 자동화된 것임. . | PR로 온 Initial Setup부분을 보자. merge전에 1,2,3번은 순서대로 직접 작동시켜야한다. . 1. ctrl+클릭으로 this uility를 클릭 &gt; RSA - 4096 클릭 &gt; 생성된 key 그대로 복사 . Private Key . --BEGIN RSA PRIVATE KEY-- . Publick key . ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCGIVY8FQf9x1Y52HUUJmpAyOfrzH96K4QtGb7 . | 2.도 컨트롤+클릭해서 1.에서 생성한 ssh key를 붙혀넣어 Action secret key를 만든다. . actions secrets 부분에 New repository secret을 클릭해서 붙혀넣음. Name : SSH_DEPLOY_KEY | Value : SSH RSA 4096 private key 복붙 | . | . | 3. 도 컨트롤+클릭해서 fastpages-blog의 Deploy (public) key를 생성해야한다. Add deploy key클릭 . 여기서는 생성한 ssh RSA 4096 key중에 밑에 있는 publick key를 사용한다. . Title : fastpages-blog | Key : SSH RSA 4096 public key 복붙 | [O] Allow write acess | . | . | . | . | PR 아래부분에 merge PR &gt; merge를 눌러준다. . Actions에 보면 Merge가 진행중인 것이 보인다. 2분 정도 걸림. | 다 되고나면, &lt;code&gt;탭으로 와서 맨 첫줄에 블로그 주소가 보이게 된다. | . | 2 설정해주기 . blog 타이틀 변경 . 깃헙을 다룰 줄 알면, 로컬에서 clone을 떠서 수정하면 된다. . push만 해주면, actions가 자동으로 돌아가면서 static 파일로 수정해준다. | 우리가 올린 파일 기준으로 static한 파일을 생성해준다. | . _config.yaml 수정 &gt; title 변경 &gt; commit | jupyter upload . fastpages가 만들어준 readme에 보면, writing blogs with jupyter가 있다. . 여기서는 .md or .ipynb의 파일이름 양식만 참고함. . YYYY-MM-DD-*.ipynb | . 2020-01-28-My-First-Post.ipynb 2012-09-12-how-to-write-a-blog.ipynb . | Front Matter : 내 블로그 첨에 작성된 ipynb글(Fastpages Notebook Blog Post)을 참고해서 가져다 쓴다.(공식은 너무 김) . 쥬피터 노트북 맨 위에 들어갈 markdown 양식이다. . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true - branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . | 올릴 쥬피터에 아래와 같이 작성한다. . | 노트북 이름을 바꾼다. . 2021-08-06-엑셀정리 05 캐글 1 타이타닉 - 변수별 EDA + 함수정의로 정의(upload).ipynb . | github의 _notebooks 폴더로 가서 add file &gt; 업로드 &gt; commit해보았음. . | . | . | markdown upload . 해당 폴더는 _posts다 . | 제목양식은 yyyy-mm-dd-제목.md다 . 실제로 표시되는 이름은 예제파일속 format의 title:이 실제로 포스트 제목이 된다. | _posts &gt; 예제파일.md &gt; raw를 클릭해서 내용을 복사후 &gt; add file &gt; create file | . toc: true layout: post description: A minimal example of using markdown with fastpages. categories: [markdown] title: An Example Markdown Post # Example Markdown Post ## Basic setup . | . 3. local에서 clone해와서 작업해보기 . C: jupyter_blog에 폴더를 만들고, 우클릭 &gt; 터미널 &gt; code . . | git clone https://github.com/is2js/blog_raw.git . C: jupyter_blog blog_raw에 파일 복사됨. . | vscode는 해당 폴더로 들어가야함. . cd blog_raw/ . | . | 블로그 계정(is2js)과, 컴퓨터 전체 git 계정(is3js)이 다르므로, --local로 깃 계정을 설정해준다. . 참고 | . git config --local user.name &quot;is2js&quot; git config --local user.email &quot;is2js@naver.com&quot; . vscode에서 github확장관리에서 로그인을 제공하고 있어서, 로그아웃후 is2js로 로그인했다. | . | 첫화면 수정 . index.html은 첫 화면에 대한 내용을 md형식으로 닮고 있다. | 내용을 수정하고 이미지가 필요하면, images폴더에 업로드후 사용한다. 작성글들은 이 페이지 아래 자동으로 모아진다. | . | 메뉴 추가 . . _pages/폴더에 들가면 각각의 메뉴가 md파일로 작성되어있다. . about은 md파일로 작성되어있으며, 추가 nav 메뉴는 다 md파일로 작성한다. . layout: page title: About Me permalink: /about/ . 파일명이 아니라 양식속 title이 nav메뉴에 뜨는 페이지명이 된다. | . | 404, search, tags는 html파일로 섞어서 작성되어있다. . | . | _pages/에서 파일을 하나 생성하여 메뉴를 추가한다. . about에 있는 양식을 사용한다. | 작성하고 commit해준다. | . | comment 추가 . utterances를 이용하여 깃허브로 댓글 달도록 함. | . 현재 아무 post에나 comment를 달면 is2js/blog_raw/폴더에 앱이 인스톨 안되어있다고 나옴. install_app을 클릭해서 어터런스 설치 | install을 all repo가 아니라 select해준다. 필요한 저장소마다 설치를 추가로 해주면 된다. | . | . | social comment . disqus를 이용하여 소셜 or 깃헙없이 댓글 달도록 함. | utterances설치시 생성된 _includes/utterances.html을 수정하여 스크립트로 disqus스크립트를 넣어준다. disqus는 url기준으로 댓글창을 열어준다. | url만 다르다면, 다른 댓글창이 열린다. | . | . 구글에서 disqus 검색 블로그 &gt; 로고클릭 &gt; com | . | 난 페북으로 로그인함. -&gt; get start | 선택 | i want to comment on sites | I want to install Disqus on my site | . site네임은 is2js_blog_raw로 함 . | basic버전을 subscribe now로 선택함 . | 우리는 스크립트로 넣을 거라 platform선택 없이 아래 i don&#39;t see my platform 선택 . 스크립트는 카피 해놓는다. . &lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt; &lt;script&gt; /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page&#39;s canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page&#39;s unique identifier variable }; */ (function() { // DON&#39;T EDIT BELOW THIS LINE var d = document, s = d.createElement(&#39;script&#39;); s.src = &#39;https://is2js-blog-raw.disqus.com/embed.js&#39;; s.setAttribute(&#39;data-timestamp&#39;, +new Date()); (d.head || d.body).appendChild(s); })(); &lt;/script&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;https://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; . | . | configure(next랑 똑같음) 클릭후 정보는 비워놓아도 된다. . | 4. 추가 커스텀 . 방문자 카운터 . 해당 프로젝트는 오픈소스라 작동이 안되거나 없어질 수 있음. | 키워드를 기억했다가 다른 것을 검색해서 | . 구글에서 github blog hits counter를 검색 . 최상단 hit-counter 깃허브 들어갔음. https://hits.seeyoufarm.com/ | . | . | 해당 내용을 채운다. . . | 3가지 타입으로 넣을 수 있다. 특히 embed로 넣을 수 있는 것은 노션으로도 넣을 수 있다는 말이 된다. . markdown . ![Hits](https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fis2js.github.io%2Fblog_raw&amp;count_bg=%239E9E9E&amp;title_bg=%2308445E&amp;icon=python.svg&amp;icon_color=%23E1DFDF&amp;title=%EB%B0%A9%EB%AC%B8%EC%9E%90+%EC%88%98&amp;edge_flat=false) . | html . &lt;a href=&quot;https://hits.seeyoufarm.com&quot;&gt;&lt;img src=&quot;https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fis2js.github.io%2Fblog_raw&amp;count_bg=%239E9E9E&amp;title_bg=%2308445E&amp;icon=python.svg&amp;icon_color=%23E1DFDF&amp;title=%EB%B0%A9%EB%AC%B8%EC%9E%90+%EC%88%98&amp;edge_flat=false&quot;/&gt;&lt;/a&gt; . | embed url . https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fis2js.github.io%2Fblog_raw&amp;count_bg=%239E9E9E&amp;title_bg=%2308445E&amp;icon=python.svg&amp;icon_color=%23E1DFDF&amp;title=%EB%B0%A9%EB%AC%B8%EC%9E%90+%EC%88%98&amp;edge_flat=false . | . | 이제 markdown을 index.html안에다 넣어주자. . | 5. 깃허브 잔디와 레포 페이지(git.html) 추가 . 잔디이미지는 솔루션을 통해 https://ghchart.rshah.org/is2js | . | 레포정보는 url로 접근하는 github api를 통해 레포들정보 : https://api.github.com/users/[is2js]/repos | 특정레포정보 : [https://api.github.com/repos/[is2js]/[레포명] | . | 참고자료(노션) | . 솔루션(https://ghchart.rshah.org )을 이용하여, 잔디정보를 이미지로 가져올 수 있다. . index.html에 유저이름만 적어준 이미지 url or MD을 붙혀넣어준다. . 이미지 주소 : https://ghchart.rshah.org/is2js . | 이미지태그 . &lt;img src=&quot;https://ghchart.rshah.org/is2js&quot;/&gt; or &lt;img src=&quot;https://ghchart.rshah.org/is2js&quot; /&gt;로 변경 . | 마크다운 주소 . ![잔디](https://ghchart.rshah.org/is2js &quot;https://github.com/is2js&quot;) . | . | index.html의 hits 아래에 넣고 확인해보자. . . | . | 새로운 페이지 /_pages/git.html을 만들자. . 노션에 미리 작성해둔 코드를 복붙하자. . js스크립트를 사용하기 위해 html양식으로 작성한다. github API를 script태그를 이용하여 github repo정보를 가져온 것이다. api -&gt; h2, p, a태그로 map으로 돌면서 정보출력. 원하면 태그를 바꾸면 된다. | . | is2js부분을 해당하는 githubID로 변경해서 사용하면된다. | . layout: default permalink: /gitInfo/ title: gitInfo search_exclude: true &lt;img src=&quot;https://ghchart.rshah.org/is2js&quot; alt=&quot;&quot; style=&quot;width: 660px; height: 100px;&quot;&gt; &lt;div id=&quot;repos&quot;&gt; &lt;script&gt; // 비동기 작업을 위해 async function 선언 const initRepo = async () =&gt;{ const _username = &#39;is2js&#39; // 추가할 dom선택 const repoUl = document.getElementById(&quot;repos&quot;) // headers 설명 : 깃허브에 요청할 형식 지정 let response = await fetch(&#39;https://api.github.com/users/is2js/repos&#39;, {headers:{ &#39;Accept&#39; : &#39;application/vnd.github.v3+json&#39; }}); const repoJson = await response.json() // repo받아온 내용 확인 // console.log(repoJson); // json내용을 map을 이용해 각 dom을 만들고 추가 repoJson.map((repos)=&gt;{ let h2Element = document.createElement(&quot;h2&quot;) h2Element.textContent = repos.name let pElementDesc = document.createElement(&quot;p&quot;) pElementDesc.textContent = &quot;레포설명 : &quot; + repos.description let aElementURL = document.createElement(&quot;a&quot;) aElementURL.href = repos.svn_url aElementURL.textContent = repos.svn_url //각 요소를 &lt;div id=&quot;repos&quot;&gt;에 추가 repoUl.append(h2Element) repoUl.append(pElementDesc) repoUl.append(aElementURL) repoUl.append(document.createElement(&quot;br&quot;)) }) } initRepo() &lt;/script&gt; . | . | 6. repo마다 언어 퍼센트 출력하도록 변경 . 특정 레포 : [https://api.github.com/repos/[is2js]/[레포명] . 특정레포에서 쏴주는 정보를 관찰해보기 : blog_raw . | 랭기쥐만 출력해서 보기 : blog_raw/languages . 각 언어의 line수가 출력된다. | 다 더한 뒤, 총합으로 나누고, 100을 곱해서 %를 만든다. | . { &quot;Jupyter Notebook&quot;: 12491591, &quot;HTML&quot;: 20989, &quot;JavaScript&quot;: 10532, &quot;SCSS&quot;: 9877, &quot;Shell&quot;: 5458, &quot;Python&quot;: 2772, &quot;Smarty&quot;: 1965, &quot;Ruby&quot;: 1945, &quot;Makefile&quot;: 1422, &quot;Dockerfile&quot;: 364 } . | . | . git.html의 script부분(단순정보나열)을 퍼센트까지 뿌려주도록 변경된 스크립트를 복붙해주면 된다. . 모든 line수(values)를 sumcodeline에 더해주고, 각각의 value에다 나눈 뒤, 100을 곱한다. | strong태그로 출력을 해서, h2 아래에 추가해준다. | count변수를 사용해서 불러올 repo를 5개로 지정해준다. 최대갯수는 100개다. | . // 사용한 언어를 return해주는 함수 const repoLanguage = async (repo) =&gt; { let response = await fetch( `https://api.github.com/repos/is2js/${repo}/languages`, { headers: { Accept: &#39;application/vnd.github.v3+json&#39;, }, } ); let resJson = await response.json(); let sumcodeline = Object.values(resJson).reduce((a, b) =&gt; a + b, 0); s = &#39;&#39;; for (const [key, value] of Object.entries(resJson)) { s += `${key} : ${((value / sumcodeline) * 100).toFixed(3)}% `; } return s; }; // 비동기 작업을 위해 async function 선언 const initRepo = async () =&gt; { // 추가할 dom선택 const repoUl = document.getElementById(&#39;repos&#39;); //갯수설정 const count = 5; // headers 설명 : 깃허브에 요청할 형식 지정 let response = await fetch( &#39;https://api.github.com/users/is2js/repos?&#39; + &#39;per_page=&#39; + count, { headers: { Accept: &#39;application/vnd.github.v3+json&#39;, }, } ); const repoJson = await response.json(); // repo받아온 내용 확인 // console.log(repoJson); // json내용을 map을 이용해 각 dom을 만들고 추가 // repoLanguage 함수의 비동기 작업을 위한 async function선언 repoJson.map(async (repos) =&gt; { let h2Element = document.createElement(&#39;h2&#39;); h2Element.textContent = repos.name; let pElementDesc = document.createElement(&#39;p&#39;); pElementDesc.textContent = &#39;레포설명 : &#39; + repos.description; let aElementURL = document.createElement(&#39;a&#39;); aElementURL.href = repos.svn_url; aElementURL.textContent = repos.svn_url; //사용한 언어 불러오기 let language = await repoLanguage(repos.name); let strongElementLang = document.createElement(&#39;strong&#39;); strongElementLang.textContent = &#39;사용언어 : &#39; + language.toString(); //각 요소를 &lt;div id=&quot;repos&quot;&gt;에 추가 repoUl.append(h2Element); //사용언어부분 추가 repoUl.append(strongElementLang); repoUl.append(pElementDesc); repoUl.append(aElementURL); repoUl.append(document.createElement(&#39;br&#39;)); }); }; initRepo(); . | latex 사용 on . _config.yml에서 LaTex 적용이 default가 true가 아니라서 아래와 같이 _config.yml 파일에 use_math 옵션을 true로 변경해주시면 됩니다. . use_math: true . | 구조 . ### . index.html : 첫 화면에 대한 내용을 md형식으로 닮고 있지만, html파일임. . ``/images/diagram.png “https://github.com/fastai/fastpages”) . . ``은 나중에 is2js.github.io/blog_raw/ 폴더(깃허브 블로그 원본 폴더)로 연결된다. | . | . | _pages/ : md or html의 nav메뉴들의 모음 . about.md, search.html 등 | 추가된 md파일의 양식속 title:[ ]이 nav메뉴에 뜨는 페이지명이 된다. resume.md | git.html | . | . | images/ . 사진, favicon | . | . 커스텀 . 커스텀 도메인을 붙이는 조건 . 내 블로그는 is2js.github.io는 아니지만, github의 네임서버가 is2js.github.io.가 작동하는 것 같았다. (뒤에 . 있음) 원래는 리눅스서버의 공인ip주소를 적어줘야한다. | 하지만, github는 따로 ip주소를 제공하지 않으므로, [git_id].github.io.를 적어두고 해당폴더에서 설정과정을 추가한다. | . | . 가비아 DNS관리 페이지로 간다 dns.gabia.com | . | blog라는 서브도메인에다가 CNAME &amp; [github_id].github.io.로 레코드를 추가한다. . | 해당 fastpage 깃폴더 -&gt; settings &gt; pages로 이동한다. custom domain 부분에 dns에 등록한 서브도메인 blog.chojaseong.com을 적어준다. | 어떠한 확인과정이 있는데, 여기서 dns에 적어둔 [git_id.github.io.]에다가 현재깃폴더 배포ip를 배정시켜주는 작업을 하는 듯 싶다 | . | 밑에 https도 되도록 체크해준다. . | LOCAL 블로그폴더의 root에 CNAME이라는 파일을 만들고, 내부에 커스텀 도메인의 url만 적어준다. . CNAME . blog.chojaeseong.com . | root폴더의 _config.yml속 url 과 baseurl을 수정한다. . url: &quot;https://is2js.github.io&quot; -&gt; &quot;blog.chojaeseong.com&quot; | baseurl: &quot;/blog_raw&quot; -&gt; &quot;&quot; 아~ fastpage가 git_id.github.io아름의 레포가 아닌데도 page로 배포된 이유는 url을 git_id.github.io | baseurl을 /레포명으로 가지고 있어서 기 때문이구나. | . | 하지만, 커스텀도메인에서는 레포명까지 풀로 포함되서 github가 해당 커스텀도메인에 배포해준다. 그로 인해 baseurl은 사라진다.(빈문자열) | . | . | . | . . | _action_files폴더 속 settings.ini파일에도 baseurl이 있으니 수정해준다. 지워서 빈칸 남겨놓기 | . | 커스텀도메인으로 접속하는 순간부터, search 결과의 link들이.. 상대주소화되어 있어서, 도메인/search + 도메인/풀/주소.html 형식으로 잇슈가 있음. . search.js에서 만들어주는 a태그의 주소에 https://를 붙혀서 절대주소화 시켜 뒤에 붙지않고 바로 접속되게 한다. | . search.js . var resultLink = document.createElement(&#39;a&#39;); resultLink.classList.add(&#39;search-result&#39;); // a태그에 http:// 등이 없어서, 상대주소로 걸려서 커스텀도메인 + 다시 또 풀경로가 상대주소처럼 붙음.. // -&gt; href에 https://를 명시해주면, 상대주소가 아니라 절대주소로 인식되어 그 주소로만 간다. resultLink.setAttribute(&#39;href&#39;, &quot;https://&quot; + doc.url); //resultLink.setAttribute(&#39;target&#39;, &quot;_blank&quot;); . . |",
            "url": "blog.chojaeseong.com/fastpages/2021/08/06/fastpages%EB%A1%9C_%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%A0%9C%EC%9E%91.html",
            "relUrl": "/fastpages/2021/08/06/fastpages%EB%A1%9C_%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%A0%9C%EC%9E%91.html",
            "date": " • Aug 6, 2021"
        }
        
    
  
    
        ,"post61": {
            "title": "Notebook posting example(title)",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "blog.chojaeseong.com/example/2021/08/05/test.html",
            "relUrl": "/example/2021/08/05/test.html",
            "date": " • Aug 5, 2021"
        }
        
    
  
    
        ,"post62": {
            "title": "markdown 사용법",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . `![](/images/logo.png &quot;fast.ai&#39;s logo&quot;)` . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "blog.chojaeseong.com/example/markdown/2021/08/05/markdown.html",
            "relUrl": "/example/markdown/2021/08/05/markdown.html",
            "date": " • Aug 5, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "준비중입니다. .",
          "url": "blog.chojaeseong.com/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "",
          "content": "공사중입니다(template).. 자세한 정보는 github.com/is2js . 데이터엔지니어로서의 역량 . Data Engineer란? . Data관련 직군 출저 : Youtube-indiflex | . 프로젝트 . python를 활용한 진료보조프로그램들 한방병원 진료기록부(ipywidget, panel) | 초진기록지(ipywidget) | 환자 티칭 프로그램(ipywidget) | 동료선생님들 거주지역 확진자수 알림(flask, GCP, jandi) | . | Class를 활용한 CLI blog (CRUD) | NLP 분석 Packages | . | 사람인 공고 수집 크롤링 프로젝트 - 크롤링 심화 프로젝트 | . | 데이터 분석 프로젝트 . 나만의 데이터분석 노트 gitbook(Updating~) | 나만의 데이터분석(EDA) 패키지 -Cho Package : numpy, pandas, matplotlib, seaborn . | 논문작성을 위한 한의학 박사들의 설문지 분석후 ROC커브 작성 [노트] | DL논문 작성을 위한 image전처리, DL, ROC커브 작성 [노트] | 관심기업 과제와 유사한 데이터 분석 프로젝트 [노트] 관심기업 과제 pandas to SQL | . | inflearn Pipeline . | 멋쟁이사자 X Naver 연계 프로그램 - clovar API이용 프로젝트 | | Flask 프로젝트 게시판 : Docker, MongoDB, Flask, JQuery | 질답앱 : | 대쉬보드 | like finterest 메모대쉬보드 | . | FastAPI 프로젝트 API : | . | Algorithm &amp; Pythonic . Pythonic Python 정리 및 회고 [노트, 출저-프로그래머스] | 알고리즘 패러다임 및 연습문제 풀이 [저장소], 출저-Codeit] | 알고리즘 자료구조 및 연습문제 풀이[노트, 출저-프로그래머스] | 알고리즘 고득점 kit 연습문제 풀이[노트, 출저-프로그래머스] | Python 고급 [저장소] | DataAnalyst . DS스쿨 - DL반 수료 | DS스쿨 - ML반 수료 | FastCampus - 논문작성을 위한 R 통계 수료 | DL(cnn)을 활용한 독성약재감별 논문작성 논문 | 논문 작성을 위한 설문지 분석후 ROC커브 작성 [노트] | 관련 프로젝트 in 고려대 [노트, 프로젝트] | . | penguin package를 활용한 통계분석 정리[노트] | 고려대 빅데이터 청년인재 수료 NLP | Vision | ML, DL | . | Data Engineer . DS스쿨 - Pandas 데이터분석반 수료 | FastCampus - 전처리CAMP 수료 | Udemy - The Complete Python &amp; PostgreSQL Developer Course 수료 | DataCamp - Data Engineering for Everyone 수료 | DB &amp; SQL . DAP자격대비 데이터 모델링 스터디[노트, 출저-데이터와사람들] | SQL 데이터 분석[노트, 출저-책] | SQL, Bigquery를 이용한 코호트 분석[노트, 출저-탈잉] | MySQL 심화[노트, 출저-SSAC] | Postgresql tutorial 4hour[노트, 출저-FreeCodeCamp] | Postgresql for DataEngineer[노트, 출저-itversity] | Postgrsql &amp;Python course[노트, 출저-udemy] | SQL vs Pandas 비교정리[노트, 출저-조재성] | mongoDB for 데이터수집[노트, 출저-멋쟁이사자처럼, 그외] | SQLAlchemy . 2.0과 이전버전 비교 및 튜토리얼[노트, 출저-Youtube] | SQLAlchemy - pandas 비교 튜토리얼[노트] | Infra . 운영체제 공부[ 노트, 출저 - 정보처리기사 및 유튜브 ] | PowerShell vs BashShell 다빈도 명렁어 정리[노트, | Docker 기본 문법[노트, 출저-Indiflex] | Docker &amp; Ncloud[노트, 출저-SSAC] | Linux 기본[노트, 출저-Indiflex] 출저-드림코딩] | git 기본 | git flow | Frontend . HTML, CSS, JAVASCRIPT로 모던 웹페이지 만들기[프로젝트] | Javasctip와 TypeScript 정리 | React | Vue |",
          "url": "blog.chojaeseong.com/_pages/edustudy.html",
          "relUrl": "/_pages/edustudy.html",
          "date": ""
      }
      
  

  

  

  
      ,"page5": {
          "title": "",
          "content": "공사중입니다…(template) 제시한 정보는 github.com/is2js . 기본정보 . Photo Future . | | . Name | 조재성 | . - Chinese | 趙在聖 | . - English | ChoJaeSeong | . Age | 1987 | . Birth Day | 1987.12.18 | . Email | tingstyle1@gmail.com | . Mobile | xxx-46xx-62xx | . 신상정보 . Profile Content . Address | 서울시 관악구 | . Married | 미혼 | . Family | 2남 1녀 | . Blood type | RH+ O | . Religion | 없음 | . 학력정보 . Level School Name Major Start End Status 최종학력 . University | DongShin University | Korean Medicine | YYYY.MM | YYYY.MM | graduated | 최종 | . High School | NamHae High School |   | YYYY.MM | YYYY.MM | graduated |   | . 직장이력 . Period Company Part &gt; Team . 2011.10 - 2013.4 | Company Inc | R&amp;D &gt; Mobile | . 2010.05 - 2011.9 | Company Corp | Big Data &gt; Visualize | . 2008.08 - 2010.3 | Venture | Web &gt; UI | . 2007.02 - 2008.8 | Company Name | Marketing 3 | . 오픈소스 프로젝트 (2012.03 ~ 현재) . 프로젝트 공식 명칭 . 소개 프로젝트에 대한 간략한 소개를 한다. . | 주요기능 주요 기능을 일일이 상세히 나열한다. | . | 사용기술 . 사용된 기술을 상세히 나열한다. | . | 개발기간 : 2013.2.3 을 시작으로 최근까지 xxx 커밋 | 공식 사이트 - http://rhiokim.github.io/resume | 소스 저장소 - https://github.com/rhiokim/resume | . | 마크다운 이력서 표준화 프로젝트 . 소개 . 이력서에 대한 몇가지 불편한 마음을 개선하고자 마크다운 이력서 표준화 프로젝트를 시작한다. . 개발자를 잘 표현할 이력서 양식이 없다. | 2,3 년에 한번씩 업데이트 해야하는 이력서 너무 힘들다. | 이력서 양식이 도구에 너무 의존적이다. | | 주요기능 . 마크다운으로 기술한다. | PDF, HTML, EPUB, Mobi 등 다양한 포맷으로 변환할 수 있다. | 개발자를 잘 표현할 수 있다. | . | 사용기술 마크다운. . | 개발기간 : 2012.3 을 시작으로 약 6개월에 걸쳐 500여 커밋 | 공헌자 : https://github.com/rhiokim/resume/contributors | 공식 사이트 - http://rhiokim.github.io/resume | 소스 저장소 - https://github.com/rhiokim/resume | . | . 기타 공개/비공개 프로젝트 . 프로젝트 명 추가 설명 : https://vimeo.com/51812784 | . | . 진행중인 프로젝트 (2013.04 ~ 현재) . 프로젝트 명 소개 모바일 앱으로 현재 3명의 멤버가 개발 진행 중 . | 사용기술 Node.js, Mongodb, APNS(Apple Notification), Gumby2 (Responsive CSS Framework) . | 역할 RESTful API 디자인, 시스템(Node.js, Mongodb, APNS) 엔지니어링, 웹 사이트 개발 . | . | . 참여한 프로젝트 이력 . 회사명 1 . 프로젝트 소개 프로젝트에 대한 간략한 소개를 한다. . | 역할 자기가 참여한 프로젝트에서 했던 역할에 대해서 기술한다. | . | 사용기술 Backbone.js, jQuery, require.js, grunt.js, twitter bootstrap, Node.js 등 | . | 개발기간: 12개월 | 공식 사이트: https://project.com | 소스 저장소: https://github.com/company/project | . | . 회사명 2 . 프로젝트 소개 프로젝트에 대한 간략한 소개를 한다. . | 역할 자기가 참여한 프로젝트에서 했던 역할에 대해서 기술한다. | . | 사용기술 Backbone.js, jQuery, require.js, grunt.js, twitter bootstrap, Node.js 등 | . | 개발기간: 6개월 | 공식 사이트: https://project.com | 소스 저장소: https://github.com/company/project | . | . 대외 활동 내역 . 커뮤니티 . 커뮤니티명 주제 관련 참고 자료 . 2010.05 | Title | http://slidesha.re/xxxxxx | . 2010.10 | Title | http://scr.bi/xxxxxxx | . 세미나 . 행사 / 모임 주제 규모 관련 참고 자료 . XX R&amp;D Campus | 1. subject 1 | 30 | http://bit.ly/xxxxxx | . 2. subject 2 |   | http://bit.ly/xxxxxx |   | . 컨퍼런스, 강연 . 행사 / 모임 주제 규모 관련 참고 자료 . Conference | Title | 250 | http://bit.ly/xxxxxx | . Conference | Title | 1,000 | http://bit.ly/xxxxxx | . 소셜 . Site URL . Github | https://github.com/{account} | . Twitter | https://twitter.com/{account} | . Facebook | https://facebook.com/{account} | . . 위의 사실은 GNU 정신에 의거하여 사실임을 증명하며, 만약 사실이 아닐 경우 MIT 라이센스로 공개해도 무방합니다. . YYYY년 MM월 DD일 {홍길동} .",
          "url": "blog.chojaeseong.com/_pages/resume.html",
          "relUrl": "/_pages/resume.html",
          "date": ""
      }
      
  

  
  

  

  
  

  

  
  

  

  

  

  
  

}