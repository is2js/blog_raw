{
  
    
        "post0": {
            "title": "python project 설정",
            "content": "Project init . 01 git init 및 .gitignore 생성 . 프로젝트 폴더 생성 | wt -d .로 터미널 열기 | git init | root에 .gitignore 생성하기 | . 02 virtualenv 설치 및 실행 . # 1. OS python으로 가상환경 패키지 설치 pip3 install virtualenv # 2. 가상환경 생성 python -m virtualenv -p python310 venv #virtualenv -p python310 venv # 3. .gitignore에 venv 추가 # 4. 가상환경 실행 . venv Scripts activate #. venv/bin/activate . vscode에서도 Python interpreter에 가상환경 선택 . code . . | F1 &gt; Python Interpreter Select . . | . | . 03 pylint with vscode ext. . pylint(style checking) with vscode extension . style checking, error checking, 리팩토링과 관련된 조언과 함께 코드에 점수도 매겨 준다. 외부 의존성으로 syntax tree를 위한 astroid, 알파벳 순서로 import를 정리하는 isort, McCabe 복잡도를 구현한 mccabe만을 가지고 있는 것을 보아, 자체적인 lint 알고리즘을 사용했다는 것을 알 수 있다. 설정을 customize할 수 있는 범위도 꽤 다양해서, IDE를 사용하고 있더라도 서드파티로 추천하고 싶다. | . # 1. 가상환경 실행 . venv Scripts activate #. venv/bin/activate # 2. pylint 설치 pip3 install pylint # 3. .pylintrc 설정파일 생성 pylint --generate-rcfile &gt; .pylintrc . .pylinctrc 설정 변경 . C0114 : 독스트링 없어도 무시하도록 disable= . | max-line-length 수정 100 -&gt; 120 . | min-public-methods 갯수 줄이기 2-&gt; 1 . . | | vscode에서 pylint extension 설치 . | . 04 flake8, black 설치후 세팅 . flake8(style and error checking) ex&gt; unused . pycodestyle + pyflakes + 복잡도 검사 기능이라고 생각하면 된다. pylint처럼 복잡도 검사를 위해 mccabe를 사용하지만, style/error checking에 대해 pycodestyle과 pyflakes를 사용한다. 그냥 라이브러리 여러 개 묶은 wrapper 형태다. 아래는 usage다 . $ flake8 ./parse.py ./parse.py:2:1: F401 &#39;logging&#39; imported but unused ./parse.py:3:1: E302 expected 2 blank lines, found 0 ./parse.py:6:5: E303 too many blank lines (2) ./parse.py:7:24: W291 trailing whitespace ./parse.py:8:15: E221 multiple spaces before operator ./parse.py:9:18: E701 multiple statements on one line (colon ./parse.py:15:1: W391 blank line at end of file . | . # 1. 가상환경 실행 . venv Scripts activate #. venv/bin/activate # 2. flask8 설치 pip3 install flake8 . .flake8 파일 생성 . ignore Do not use bare except, specify exception instead (E722) | Line break occurred before a binary operator (W503) | . | max-line-length 수정 100 -&gt; 120 | code없는 init 허용 | . [flake8] ignore = E722, W503 max-line-length = 120 per-file-ignores = __init__.py: F401 . | black(code formatter) . Black은 Python 재단에서 2018년에 시작한 Python Code Formmater | . # 1. 가상환경 실행 . venv Scripts activate #. venv/bin/activate # 2. black 설치 pip3 install black . 04 (선택) faker, pytest 설치 . # 1. 가상환경 실행 . venv Scripts activate #. venv/bin/activate # 2. black 설치 pip3 install faker pip3 install pytest . 사용 _test.py를 만들고 | def test_ method를 + assert 비교구현하여 만든 뒤 | pytest -vs [상대경로] | | . 05 (선택) dotenv 설치 . # 1. 가상환경 실행 . venv Scripts activate #. venv/bin/activate # 2. python-dotenv 설치 pip3 install python-dotenv . root에 .env 생성 후 .gitignore에 추가 | 06 .gitignore 추가 . 기존에 추가한 venv, .env외에 | test용 DB, vscode cache파일들 추가 | . venv .env storage.db .pytest_cache **/__pycache__ . 07 pre-commit 설치 및 세팅 . # 1. 가상환경 실행 . venv Scripts activate #. venv/bin/activate # 2. pre-commit 설치 pip3 install pre-commit . root에 .pre-commit-config.yaml 생성 | flake8, black hook 설정 . .pre-commit-config.yaml를 열고 . | python버전을 기록하고 . | 2개 패키지의 정보를 기입한다 . rev는 태그버전인데 stable을 기록해놓고 차후에 pre-commit autoupdate을 시행하면 자동으로 버전이 기록된다. | . default_language_version: python: python3.10 repos: - repo: https://github.com/ambv/black rev: 22.10.0 hooks: - id: black stages: [commit] - repo: https://gitlab.com/pycqa/flake8 rev: 3.9.2 hooks: - id: flake8 stages: [commit] . | requirements.txt 자동업데이트 설정 . .pre-commit-scripts폴더 생성 . | requirements.py 생성 . | 아래 스크립트 복붙 . #!/usr/bin/env python from subprocess import call # nosec from sys import platform def main(): file_name = &quot;./requirements.txt&quot; if platform == &quot;win32&quot;: with open(file_name, &quot;w&quot;) as file_: call([&quot;./venv/Scripts/pip3&quot;, &quot;freeze&quot;], stdout=file_) else: with open(file_name, &quot;w&quot;) as file_: call([&quot;./venv/bin/pip3&quot;, &quot;freeze&quot;], stdout=file_) call(f&quot;git add {file_name}&quot;) # nosec if __name__ == &quot;__main__&quot;: exit(main()) . | .pre-commit-config.yaml에 hook 추가 . - repo: local hooks: - id: requirements name: requirements entry: ./.pre-commit-scripts/requirements.py language: system pass_filenames: false stages: [commit] . | (선택) pytest hook 추가 . - repo: local hooks: - id: pytest name: pytest language: system entry: pytest -v -s always_run: true pass_filenames: false stages: [commit] . (선택) dotenv example generator hook 추가 . .pre-commit-scripts폴더 생성 . | dotenv_example_generator.py 생성 . | 아래 스크립트 복붙 . #!/usr/bin/env python import os import re from subprocess import call # nosec def main(): dotenv = &quot;./.env&quot; dotenv_example = &quot;./.env.example&quot; if not os.path.exists(dotenv): exit() # (Get-Content . .env) -replace(&#39;=.*&#39;, &#39;=&#39;) | Set-Content .env.example # sed &#39;s/=.*/=/&#39; .env &gt; .env.example with open(dotenv, &quot;r&quot;, encoding=&quot;utf8&quot;) as file_: lines = file_.readlines() with open(dotenv_example, &quot;w&quot;) as file__: for line in lines: if line[0] == &quot;#&quot;: file__.write(line) continue file__.write(re.sub(&quot;=.*&quot;, &quot;=&quot;, line)) call(f&quot;git add {dotenv_example}&quot;) # nosec if __name__ == &quot;__main__&quot;: exit(main()) . | ``.pre-commit-config.yaml`에 hook 추가 . - repo: local hooks: - id: .env.example name: .env.example entry: ./.pre-commit-scripts/dotenv_example_generator.py language: system pass_filenames: false stages: [commit] . | pre-commit install . 아래 명령어로 .git/hooks에 세팅을 해준다. | . pre-commit install . rev들의 버전을 맞추고 싶다면 | . pre-commit autoupdate .",
            "url": "blog.chojaeseong.com/python/project/configuration/settings/lint/formatter/black/flake8/pre-commit/dotenv/2022/10/11/python-settings.html",
            "relUrl": "/python/project/configuration/settings/lint/formatter/black/flake8/pre-commit/dotenv/2022/10/11/python-settings.html",
            "date": " • Oct 11, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "windows python 설치경로 확인",
            "content": "where python | python -m site --user-site | sysdm.cpl &gt; 고급 - 환경변수 &gt; PATH &gt; PYTHON적힌 경로보기 |",
            "url": "blog.chojaeseong.com/windows/python/path/2022/09/25/python%EC%84%A4%EC%B9%98%EA%B2%BD%EB%A1%9C%ED%99%95%EC%9D%B8.html",
            "relUrl": "/windows/python/path/2022/09/25/python%EC%84%A4%EC%B9%98%EA%B2%BD%EB%A1%9C%ED%99%95%EC%9D%B8.html",
            "date": " • Sep 25, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "TDD 총정리3-블랙잭 구현을 통한 상태패턴과 랜덤로직 전략패턴",
            "content": "랜덤을 셔플로 구현하여 데이터를 제공해주는 Deck에서, 랜덤부분을 전략패턴으로 만들고, 외부에서 [직접 반환되는 객체를 만들어놓고 -&gt; 최종 객체만 람다식에 넣어] 제공함. | . 블랙잭 상태 패턴 구현 . 컴퓨터내부에서 로직의 시작인 card 2개가 주어진다면, 정제된input이라 생각하고 카드부터 만든다. . 제한된 종류의 값 = 상수묶음은 enum으로 만들어서 카드를 만든다. | 테스트메서드명은 인자 -&gt; 1case 가 결정한다. | . . | 4 x 13 종류의 객체는 캐싱이 가능하다. . 캐싱을 적용하려면 일단 생성자 인자 그대로 정팩메로 만들고, 기본생성자는 private해준다 | . . . | 원래는 기본생성자의 1개 인자에 대해 hashMap&lt;생성자인자, 객체&gt;형으로 static CACHE map을 만들어야하지만, 파라미터가 2개일경우, 1개로 합친 Key를 만들어야한다. . 2개이상의 정보를 묶은 class를 만들어도 되지만, string을 이용해서 합쳐 1개의 key로 만들어 &lt;String, 객체&gt;형을 많이 사용한다. | 캐쉬의 기본공식은 꺼내서 없으면 put해주고, return get을 반환이다. | . . . | 테스트메서드명도 함수를 from or of의 정펙메로 바꿔주고, isSameAs로 테스트한다. . . | java의 기능으로서 없으면 key에 대한 value를 생성해주고 있으면 반환하는 computeIfAbsent를 사용해서 리팩토링한다. . 또한 캐싱될 객체의 수를 알고 있으면 미리 넣어줘도 된다. | . . . | CACHE대상객체는, 거의 값객체기 때문에, 값으로 비교하기 위해 eq/hC오버라이딩도 해준다. . | 이제 가진 2장의 카드로 정해진 종류의 행위마다 변화하는 상태 판단하면서, Game을 풀어 가야한다. . 카드2장 -&gt; if 상태판단 -&gt; 상태에 따른 행위 -&gt; 다른 상태 | if 상태에 따른 행위의 결과가 다른 상태가 나온다면, 상태패턴을 고려한다 | 2장의 받은 상태에서 if 21 -&gt; 블랙잭 상태 -&gt; stop | if 21미만 -&gt; hit상태 -&gt; stay or hit지속 | . | 가장 만만하게 응답될 상태의 input부터 case를 만들고 -&gt; 테스트메서드명으로 시작하면 된다. hit가 output상태로 나오는 input을 넣어주자. | . | . | Service가 아닌 만들어낸 input부터 시작하는 Game클래스를 만들고, 서비스메서드처럼 static으로 start()를 만들고 재료를 넣어주자. . input으로 hit대상이되는 카드2장을 인자를 넣어주고, 응닶값이 hit상태이어야한다. | . . . . | 다음은 Game.start()가 blackjack상태를 응답하도록 작성해보자. . 테스트에 인자를 blackjack으로 넣어주고 . . | blackjack시 ACE가 11로 사용될줄알아야한다. enum에 매핑된 값이 필요함을 인지한다. . . | enum에 값이 매핑되는 순간부터 바로 getter를 작성해주면 된다. . ACE는 1or11을 가질 수 있으나 규칙상 상한이 21점으로 제한되어있다면, 11을default시 2장을 아예 가질 수 없기 때문에, default를 작은 수로 주고 보정한다 . . | . . | card입장에서는 enum getter -&gt; enum point getter 2번을 거쳐야하므로, getter를 래핑해서 만들어준다. . . . | . | 2장의 카드 중에, ACE가 포함되어 있을 경우 &amp;&amp; [11로 쓸 때, 합 21] -&gt; [1로 쓰면 합 11]일 경우만, blackjack이 되도록 처리해줘야한다. . 2개의 카드 중에 ace가 있는지 확인한다. . 일급컬렉션이 아닌 상태에서 동일형 객체 일괄처리는 List.of()나 Stream.of()를 사용해서 묶어서 처리한다. . | 있는지 없는지 판단은 filter + count가 아니라anyMatch( -&gt; 개별요소판단 )로 판단한다. . . . | . | ace를 가졌다면 &amp;&amp; 2장의 합이 11이하인지 확인한다 . 11이하이면, ace는 10으로 쓰일 수 있다. | 11이면, ace를 가진 경우 blackjack이다. | . . | 즉, ace를 작은값로 유지하고, 기준값을 큰값일때로 잡아서 처리하면 된다. . ace(1) + 10 -&gt; 11이면 21로 블랙잭 | ace(1) + x -&gt; 11미만이면, ace(11) + x | ace(1) + 11 -&gt; 12이상이면, 교환불가 | ace가 2장있다면? 변환될 수 있는 ace는 한장이다. 2장 변환시 이미 22가 되어버림 | . . | . | 테스트를 통과했다면, 리팩토링한다. . 일급컬렉션이 아닌 같은형 객체 일괄처리를 위해 List.of()로 묶었지만, 같은형끼리의 단순집계또한 List.of()로 묶어서 누적연산으로 처리가능하다. . 같은 context에서 일괄처리와 같은형 끼리의 연산이 뭉쳐있다면, List.of()나 Stream.of()로 묶어주는 것은 공통코드가 된다. 파라미터 추출로 각각을 빼낸뒤, 1개의 변수로 대체할 수 있다. | . . . | 같은형끼리의 단순연산 or 일괄처리로 인해 2개이상의 같은형을 List.of로 묶었다면, List.of()로 묶는 곳에서 일급컬렉션을 고려한다. . Stream.of()는 List.of()로 바꿔서 일급컬렉션의 생성자 인자로 올리자. . | 이후 인자없는 생성장에서 빈컬렉션으로 초기화하여, add가능한 일급컬렉션으로 수정하자. . . . . | 인자없는 생성자는 부생성자이므로 빈컬렉션 초기화를 this()에 넣어서 초기화해주자 . add시 새객체 반환시, 얕은복사 안해줘도 add전 객체는 버려져서 오염될 일이 없을 것 같아서 빼줬다. | . . . | . | | 책임위임을 위임하려면, 일단 현재context상의 메서드의 파라미터에 걸려있어야 하며, static메서드라면, static키워드를 삭제하고 위임해야한다. . getter를 쓰더라도 파라미터로 들어가서 완성해놓자. | static메서드라면, static키워드를 지운 뒤 f6으로 위임해야한다 | getter를 썼다면, 위임된 객체에서는 내수용getter가 사용되고 있으니 지우고, 필드로 바꾸자. | . . . | 또다른 리팩토링으로서 조건식에 하나의 도메인에 대한 메서드호출이 나열되어있다면, 메서드 추출시 파라미터에 1개만 도메인만 걸리며, 이 또한 묶어서 책임을 위임할 수 있다. . 역시 static안이라면, static을 지우고 위임한다. . . . | . | 상태패턴 적용을 위해 state라는 추상체 인터페이스를 만들고, 응답형을 Object가 아닌 추상체로 주면 -&gt; 알아서 응답되는 객체들을 구현하라고 intellij가 알려준다. . . . | 테스트코드의 응답형에 따른 변수형도 변경해준다. . | 추상체를 만드는 순간부터 패키지를 분리하여, 패키지폴더 대상 다이어그램으로 의존성을 확인하자. . 이후, 구상체만의 메서드 개발후 올리기전 다이어그램 + CompareFile하자 | . . | 상태패턴을 도입했으면, 응답값으로 나온 현재 상태를 바탕으로 추상체에 있는 [다음상태로 갈 수 있는 인자]를 받아 [다음상태로가는 메서드]를 정의해줘야한다. 에러호출로 종료되는 제일 쉬운 현재상태(blackjack)부터 [다음 상태로 넘어가는 메서드]를 만들자 . 테스트메서드에 작성한 응답된 상태 Hit | Blackjack -&gt; draw즉시 에러 호출로 종료라서 더 쉽다. | . | . . | 이 때, 특정 쉬운 구현체부터 메서드 작성이라면, 공통메서드일지 모르니, 오퍼레이터로 만들지말고 다운캐스팅해서, 구현체만의 메서드로 만든 뒤, 공통이면, @Override해서 올린다. . 응답값을 받을 때 (특정구현체) 다운캐스팅을 하고, 메서드를 작성한다 | . . . | 특정구현체의 메서드이며, thr 던질 메서드라도 미래에 공통으로 사용될 예비오퍼레이터라면, 응답형을 지정한뒤 던진다. . 게임종료는 thr로 한다. | . . | 다운캐스팅된 구상체만의 메서드 개발이 완료되면, 다이어그램을 확인해서, 올려도 되는지 판단한다. . 다이어그램 + CompareFile을 펼쳐 모든 구상체가 호출해도 되는 메서드인지 확인한다. 다이어그램 단축키 : ctrl + alt + shift + U | compareFile : 구상체들만 선택후 ctrl + D | . | 올릴 거면, 다운캐스팅했떤 로직을 삭제하고, 다른 구상체들도 구현한다. | . . | Override + pull members up으로 오퍼레이터로 올린 뒤, 테스트상 다운캐스팅한 로직은 삭제해준다 . . . | blackjack -&gt; 게임종료(thr)는 끝났다. 이제 hit상태에서 -&gt; draw or stay를 할 수 있다. . 일단 draw부터 만든다. | hit상태에서는 합 20이하라면, hit상태 | 합21이라면, blackjack상태 | 합 21초과라면, bust상태이다 | | 테스트에서는 case마다 인자로 넣어줘서 차근차근 개발하며, 제일 쉬운 것(hit)부터 응답하게 만들어나가면 된다. | . | hit응답상태에서 합 20이하가 되는 인자를 넣어줘 다시 히트상태를 응답하도록 case를 만든다. . 첫 case만 만들 땐, 빠르게 return이라 연산식이 없다. 하지만,,, | . . . 아직까지는 hit만 빠르게 반환하도록 만든다. . . . | . | 이제 hit에서 2번째 쉬운 상태응답case인, hit -&gt; bust로 간다. . 테스트를 작성하고 | . . Bust 클래스를 만들고, State구현한 뒤, hit의 draw()의 내부 로직을 작성해야하는데.. . . | Hit의 트리거메서드인 draw의 2번째 case Bust를 판단하려면, 기존 카드정보를 모두 상태값으로 쥐고 있고 vs 메서드 인자로 넘어온 정보를 통해 상태업데이트 후 새객체반환해야한다. . . | . | 최초의 상태객체를 만들어내는 Game.start()에서 현재정보를 생성자의 인자로 넘겨줘 상태값으로 가지고 있어야한다. . . trigger + 정보를 판단하려면, 상태객체는 생성시부터 이미 정보를 상태값으로 가지고 있도록해야한다. . | 최초로 상태객체가 만들어지는 곳에서 현재 상태를 결정하는 정보를 생성자 주입해서 물고 있자. . . . | 기존에 생성자 없이 사용하던 객체에, 상태값이 추가되어 생성자가 추가될 경우, 부생성자로 빈값할당으로 초기화해주는 기본생성자를 추가해서 기존코드가 망가지게 않게 한다 . . . . . | 또한, trigger메서드내에서는 업데이트된 상태값으로 새 상태객체를 생성해서 반환해줘야한다. . 상태값도 포장된 일급컬렉션이라, cards + card를 처리해야한다. | . . | . | 같은형의 일급vs단일라면 메세지를 보내서 처리해야한다. 주로 add가 쓰일 것이다. . add를 만든다면, list + add로 인해 상태변화된 불변일급컬렉션을 반환해줘야한다. | 이 때, 기존 상태값(컬렉션 필드)를 얕은복사후 add해야한다. | 컬렉션 파라미터의 사전검증으로서 일급컬렉션에서 add하여 새로운 컬렉션 상태를 만들어, 새로운 일급컬렉션 객체를 불변하게 반환할 때는, 기존상태값을 얕은복사해서 연관성을 떼어내야한다 | . . . | 상태필드가 객체이상, 일급컬렉션인 경우, 현재 구체적인 값의 상태를 물어볼땐 getter대신 메세지를 보낸다 . 상태필드가 객체이상, 일급컬렉션인 경우, 현재 구체적인 값의 상태를 물어볼땐 getter대신 메세지를 보내서 값으로만 응답받는다. 이미 가진 카드들의 합을 묶어서 연산하도록 프로그래밍 되어있으니, 갯수가 늘어나도 합 연산은 그대로 유지되고, 그 메서드를 내수용으로 사용하면 된다. | . | . . 상태값이 객체이상이라면, 메서드를 보내서 현재상태를 물어본다 . . . | . | 현재 진척도 . hit or blackjack blackjack -&gt; 뽑을 시 예외발생해서 종료 | hit hit | bust -&gt; 뽑을 시 예외발생해서 종료 « 먼저 처리해주자 | blackjack? | . | . | . | 종료상태객체는 trigger메서드 호출시 예외발생으로 종료까지 마무리해줘야한다. . Blackjack상태객체, Bust상태객체 (앞으로 Stay도 종료상태일 것임) | . . 참조변수 재할당시 람다캡처리 문제가 발생한다. 체이닝가능한 메서드는 체이닝해주자. . . . | . | setNext, add와 같이 같은형 객체를 반환하는 메서드들뿐만 아니라 같은카테고리인 추상체를 반환하는 메서드들도 체이닝 메서드이다. . 객체반환메서드는 체이닝을 생각하자. | 이 때, static메서드로서 게임출발을 담당했던 메서드도 State를 반환하는 메서드이므로 체이닝 가능하다 | . . | 2장인데, ace를 안 가진상태에서도 블랙잭이 될 수 있다. hit -&gt; blackjack을 개발해보자. . hit or blackjack blackjack -&gt; 뽑을 시 예외발생해서 종료 | hit hit | bust -&gt; 뽑을 시 예외발생해서 종료 | blackjack -&gt; ace를 가졋다면 합 11 , ace가 없다면 합21시 만족 | . | . | . . . . | 핵심로직을 시작하는 카드2장input -&gt; 상태객체 output하던 스태틱 클래스도 Ready 상태의 상태객체다. . Game -&gt; Ready 수정 . 테스트의 Ready.start() -&gt; 찾아바꾸기로 new Ready().start()로 수정하자. . . | . . | State인터페이스 구현 후 start보다 구현메서드draw()를 가장 위로 . 상태를 구현한 구현객체라는 의도를 명확히 하기 위해서는 구상메서드를 가장 위로 올린다. | . . 상태객체 패키지로 이동시킨다. . . | . | | 서비스 메서드 == 스태틱 메서드 like 유틸메서드에서 -&gt; 객체가 되었다면 . 상태값으로 카드 2장을 받는다. . | 상태값을 만드는 input들은 다 생성자로 들어와야한다. . 메서드로 상태값 정보가 들어온다면, setter다. 지양해야한다. | . | 서비스의 유틸메서드 input -&gt; 생성자로 주입 된다 . | 서비스의 유틸메서드내 로직을 거친 뒤 1개의 output응답값(상태객체) -&gt; 필드로 가진다. . . | . | start의 카드2장의 input은 생성자로 주입되고, 1개의 output인 상태객체는 필드가 되어 상태객체를 초기화해서 최초로 가지는 상태 포장객체가 Ready가 된다. . 즉, 서비스메서드는 나중에 첫 상태객체를 초기화해서 사용하는 포장객체가 되는 것이다. | . . . | 이렇게 Cards가 아닌 다른 상태객체를 가지게 되면, 상태객체가 아니라 상태객체를 사용하는 객체가 된다. . 하지만, Ready라는 상태객체도 상태를 사용할 객체가 State state의 초기값으로 가져야할 객체로서 엄연히 존재해야하며 다른 상태객체들처럼 draw()를 구현하여 다른 상태로 넘어가야 한다 | . | 정리하면 . Ready도 다른 상태객체들과 동일 상태값 필드(Cards)를 가지며 생성자로는 아무것도 주입 안된 빈카드로 초기화하는 기본 생성자로 만들어져야한다. . | Ready도 .start()로 다른 객체로 넘어가는 것이 아닌 다른 상태객체들의 메서드처럼 Trigger메서드(draw())로부터 setter정보를 받아 상태값업데이트 이후 상태값을 가지고 판단하여 다른 상태로 넘어가도록 수정한다. . Ready는 카드를 2장을 받는다. -&gt; 다른상태객체처럼 draw로 1장씩 받도록 정의하고 외부에서 2번을 호출하던지 다른 파라미터로서 받도록 오버로딩메서드로 정의해준다. | . | | 빈생성자 -&gt; 빈 상태값으로 생서될 수 있도록 생성자를 수정하고, 다음 상태객체로 넘어가는 로직을 draw로 옮긴다. . . . | 문제는 Ready는 1장이 아니라 2장을 다 받은 상태에서 판단이 이루어져야하는데, 1장만 받고 hit로 바로 가고 있다. . . | Ready가 2장을 받은 상탠지 확인하는 것은 Ready의 상태값인 cards로 판단해야한다. . 객체이상이므로 메세지를 던져 물어본다. 너 2장 받았냐고, 아직 2장미만의 Ready상태냐고 | 1장 받고 상태값이 바뀌면, 새객체를 반환해야줘야하므로 다시 new Ready(바뀐cards)로 응답한다. cards로도 만들어져야하므로 생성자가 추가되고, 기존 생성자는 부생성자가 된다. | . | . . . 밑에 로직도 업데이트된 상태값으로 생성하도록 수정한다. . . | . | test에선 다 start(카드, 2장)으로 작성된 상태다. . 코드 수정은 기존코드start를 복사해서 수정draw하고 나서 지운다. | . . . 서비스 or 핵심로직 통합테스트가 Ready라는 1개 상태객체 테스트로 바꼈다. . 개별 상태객체에 해당하는 코드들은 각자의 테스트로 나누어서 옮긴다. . | 비록 Ready에서 시작하지만 일단 옮겨간다. . | . . | . | Ready부터 시작하는 테스트를, 해당객체부터 시작하도록 수정한다. . Ready는 인자없는 생성자에서 draw()2번했지만 | 특정상태 객체는 cards를 상태값으로 주고 시작하도록 변경하면 된다. | . . | 파라미터 변경한 생성자 추가해주기 -&gt; 파라미터 추가는 해당 파라미터로 생성자 추가한 뒤 오버로딩으로 처리한다고 했다. . client가 편해야한다. . | Cards를 만드려면 List.of() 로 묵어줘야하니, 내부에서 묶어주고 가변인자로 주도록 변경해보자. . 기존 . | 인자입력시 List.of() -&gt; 가변배열로 입력하도록 변경한다. . . . . | . | . | 상태변화가 없는 캐싱 객체는 싱글톤이라, testutil패키지 &gt; Fixtures클래스안에 상수객체로 만들어 써도 된다. . test루트에서 testutil 패키지를 만들고 내부 Fixtures를 만들자 . . . | . | Fixtures에 쓸려면 어디서든 불러도 같은 객체가 생성되도록 캐싱==싱글톤이 보장되어야한다. . isSameAs로 확인해야한다. | 만약, 캐싱객체가 아니더라도, eq/hC를 재정의하여 값이 같으면 같은 객체가 되는 값객체가 되어야한다. 이 땐, isEqualTo로 정의한다. | . . | **싱글톤 캐싱객체 or VO라서, 생성해서 쓰면 무조건 같은 객체가 보장되었다면, 테스트에서 쓰인 객체들의 상수추출 -&gt; Fixture로 옮겨서 재활용할 수 있다. ** . 상수가 되면 편하게 생성안하고 편하게 쓰면 된다. | 한글로 Fixture를 생성해서 쓰자 | 상수 추출후, Fixture로 옮기기전에 미리 다 상수로 바꿔놓으면 더 쉽다(ctrl+H) | . . . | 이제 빈 생성자로 빈 상태값으로 시작하는 Ready의 [시작상태객체]가 완성되었다. . . | 시작객체가 있다면, 같은 패키지로 몰아서 시작객체public을 제외한 나머지들은 default가시성을 가지도록 해서, 외부에서 생성안되도록 한다면, 사전검증을 안해도 된다. . 만약, 생성자가 기본생성자라서 정의를 안해줬다면, 재정의 후 가시성변경해줘야한다. 대표적인 예가 유틸클래스(상태값없이 input-&gt;output static메서드만 가지는)는 생성자를 private가시성으로 변경해주는 것이다. | 생성자가 없는 클래스 -&gt; public으로 열여있으며, 재료를 바탕으로 상태값을 만들지 않는 클래스 | . | client가 잘못입력할 수도 있기 때문에 중간에 생성되는 상태객체들은 외부에서 생성못하도록 가시성으로 막아주기 | . . . | 상태객체는 trigger메서드(draw)외에 중도 stop메서드와 stop상태를 가질 수 있다. . ready + trigger . blackjack | hit + trigger bust | blackjack : 블랙잭은 2장일때만 가능이다. | hit | . | hit + stop : 중도stop 메서드 stay : 중도 stop상태객체 반환 | . | . | stop메서드와 stop상태객체 2개를 다 만들어준다. . . | . | hit상태에서 stay를 호출하도록 테스트를 짠다. . | 메서드가 반환해야할 상태객체부터 만들고, State 추상체상태의 hit에서 stay()를 만들면, 오퍼레이터로 등록된다. . . | 각 구현체는 외부에서는 추상체변수에서 다형성으로 사용되니, 특정 구상체(hit)에서 빨간줄 메서드로 만들면, 추상체인 인터페이스의 오퍼레이터로 올라간다. . 일단 인터페이스에 생성하고 -&gt; 해당 구현체만 일단 구현해보자. . . . . | . | 특정 구상체에만 사용되는 메서드가 등장했다. . 상속관계면, 조합관계로 바꾼다. . | 이미 인터페이스를 구현하는 조합관계의 구상체였다면 . 일단 인터페이스에 올리고, 특정구상체만 자기메서드를 로직을 구현한다. | 마저 테스트를 진행해야하니 나머지 구상체들은 로직 없이 구현만 해준다 | 이후 해당메서드 테스트가 끝나면, 특정구상체 외 사용하지 않는 구상체들에게 내리기 전에 중간에서 막아주는 추상클래스로 만들어지는 중간추상층을 만들어준다. | | 일단 모든 구상체들도 구현은 하고 특정 메서드의 테스트를 진행한다. . . . | . | 사용하지 않는 메서드를 억지구현한 코드가 중복이라서 해당하지 않는 구상체들만 묶은 중간추상층(추상클래스)를 도입하고, 거기서 구현해준다. . 중간추상층은 구상체로 내려가는 메서드를, 중간에 구현하여 중복되는 코드를 가운데서 막아준다. . 이 때, 중간추상층은 카테고리로서, Ready는 같이 묶기엔 의미가 다르다 | . . | . 일단 인터페이스를 구현하는 중간추상층 추상클래스를 형용사 상태네이밍해서 만들고 stay할 수 없는 것들은 이미 끝난 Finished라고 하고 | Ready는 논외로 성격이 달라, 놓아두고 | Hit도 구현하므로 놓아둔다 | . | 해당하는 구상체들은 추상클래스를 상속한다 | 사용하지 않는 메서드는 thr IllegalState로 처리한다. | | State를 구현한 추상클래스Finished를 만들고 . abstract를 달고, 2개의 오퍼레이터 모두 구현해주되 | 먹어줄 것(stay -&gt; 사용안됨)만 남기고, 개별구현할 것들은@Overide 구현 메서드들을 자식들에게 다 내려보낸다 | . . 하위 구상체들은 인터페이스 impl이 아닌 중간추상층인 Finished를 extends한다 . . | | 추상클래스 도입시 중간에 먹어줘서 공짜로 물려주는 것들은 final을 달아서 자시이 수정 못하게 막아야한다 . . 구상체가 도입되고, 추상체도 추가되었으니 다이어그램을 본다. . . | 추상클래스 도입후 눈꽃모양의 final을 확인하자. . . | . | 모든 구상체에 대해 stay()메서드가 추가되었으니 메서드 테스트를 추가한다. . blackjack, bust, stay -&gt; finished -&gt; stay호출시 예외 | ready -&gt; stay호출 시 예외 | . . Stay 도메인객체가 추가되었으니, 생성 및 메서드 테스트를 해야한다. | . | 상태패턴의 상태객체반환 with trigger되는 결국엔 다른 객체의 상태값으로 포장될 객체들은 view에 넘기기 위해 getter를 무조건 가진다 . trigger 등 set계열 메서드들 개발이 완료되면 getter도 개발해야한다. . | 원래 추상클래스의 중복필드처리는 부모필드는 생성자 정의없이 -&gt; setter만든 뒤, setter주입되어서 자식이 super를 못쓰게 해야하는데.. . | . | 복잡한 구조에서 getter개발하기 . 현재는 복잡한 구조로 되어있기 때문에, 메서드 개발을 1개의 구현체에서부터 올리기를 하진 못한다. 최상위 인터페이스State에서 정의후 하나씩 내려오기해야한다. | . . 최상위 인터페이스에 getter를 정의하되 값의 반환이 아닐 때는 .get필드()대신 .객체()형식으로 정의해본다. . 인터페이스에서는 접근제한자가 public이 default이므로 두고 반환형을 상태값 Cards로 주면서, 메서드명도 cards()의 필드명으로 만들자 | . . . | 개별 구상체(Ready, Hit)는 바로 구현하되, 중간추상층 Finished에서는 해당오퍼레이터가 중복인지 확인한다. . getter오퍼레이터의 구현은 getter구현 전에 필드값이 존재해야하는데 . 중간추상층의 부모가 없다면, 바로 자신의 필드를 반환해주면 된다. . | Ready / Hit 구상체 . | . . . | **중간추상층에서 먹어준다면, [좋은 부모로서 생성자없이 setter로 -&gt; private필드올릴 준비]를 해야한다 ** . . | . | 3개 구상체에 대해 공통getter라고 판단이 들었으면, final 템플릿메서드로서 중간에서 먹어준다 . . . 추상클래스는 무조건 public final or protected abstract다 . . | . | 문제는, getter로 반환될 필드를 부모인 중간추상층에 올리는 순간, 부모의 생성자가 정의되어 자식이 super를 쓰는 불상사가 생길 수 있다. . . | 부모는 해당필드에 대해 생성자가 아닌 public final setter로 객체를 초기화시키며 . 해당 부모의 구상체 자식들은 안보이지만 setter를 이용해서 해당 필드를 채워야한다 . 맞는지 모르겠지만, setter로 인해 상태값 변화했으면, 변화된 객체를 반환해줘서 체이닝가능하게 한다 . 예시 . . . | . | . . | 기존에 cards를 생성자 주입했던 구상체들은 setter로 변경해야한다.?! . | | | ​ . 6. **부모가 `getter를 먹으려면 + 공통의 필드 cards`까지 먹어야했다.** ![image-20220806141621141](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806141621141.png) 7. **자식들은 getter구현 안한 상태 유지 + `공통필드 + 그 생성자까지 제거`해줘야한다.** ![dbbd4ebb-90b5-4ed0-a344-3de8cfc09e02](https://raw.githubusercontent.com/is3js/screenshots/main/dbbd4ebb-90b5-4ed0-a344-3de8cfc09e02.gif) ![image-20220806141930165](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806141930165.png) 8. **자식들이 그동안 테스트에서 `new Blackjack( cards )`를 사용한 부분은** 1. **부모에 위치하는 `부모 속 공통필드에 템플릿setter로 공급`하고 -&gt; `템플릿getter`를 사용해서 해당 필드를 조회할 수 있다.** ![b01ac58e-55d8-4730-aa34-d4007ea55429](https://raw.githubusercontent.com/is3js/screenshots/main/b01ac58e-55d8-4730-aa34-d4007ea55429.gif) 2. **생성자주입으로 사용하던 객체를 -&gt; [부모공통필드로 옮기는 바람에 setter로]사용해야된다면, 코드변화가 많지는 않다** 1. new 객체( 주입 ) -&gt; new 객체**( ). setter**( 주입 ) ![image-20220806142627252](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806142627252.png) ![image-20220806142650775](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806142650775.png) . ​ . 9. **getter구현이 완료되었으면 getter에 대해서 생각해보기** - **만약 view로 반환하는 객체가 `불변객체(불변일급 -&gt; 상태변화시 새객체 반환)`라면, `DTO가 필요없고, public getter가 가능`하다.** - 객체의 **상태를 변화시키는 set계열을 호출해봤자 `내부에서는 새객체를 반환`되는 메서드만 제공**된다. ![image-20220806145015195](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220806145015195.png) - **객체의 상태를 꺼내보는 get계열을 호출해봤자 ** - **`컬렉션 필드라면, 이미 내부에서 생성자복사(얕은복사)`를 통해 `기존상태값과의 연결을 끊어놓은 상태`로 내준다.** - **그 내부의 개별요소 객체들을 set계열로 호출해봤자 새객체가 반환된다.** - 개별객체들은 get계열로 호출해도 연결안되고 반환된다. - **view로 보내는 `컬렉션 필드 반환 getter들은 깊은 복사`를 이미 하고 있어야한다.** - **조작불가 + 깊은복사까지 이루어져야한다.** - **개별요소들을 view에선 건들이면 안되기 때문** - **암기getter** 1. **`getter정의시 return 불변객체`라면, `public열어두기 가능 + dto없어도 됨`** - **불변의 일급컬렉션 객체 반환 -&gt; dto없는 public getter로 제공** - **불변객체 아니라면, `Dto로 만들어서 반환`** 2. **`getter정의시 return 컬렉션필드라면, view로 보낼 땐, 깊은 복사로 못건들게 해서 반환`** - **불변의 일급컬렉션 `자신 내부의 컬렉션 필드 반환`** - server사이드 반환이라면, 얕은복사 반환후, 내부에서 객체들 조작 - **view반환이라면, `깊은 복사 반환 or DTO로 반환` 후, 내부 객체들 조작안되게** 10. **Ready도 getter가 있어야하나?** - 0개 카드 확인? 1개 카드 확인? -&gt; **갯수만 메세지보내서 확인하면 되는데, 내부까지??** - 선택이다 1. **Ready는 `카드 2장채워질때까지==다른상태객체 될때까지` 값을 반환안하려면 `thr`로 막아주기** 2. **보여줘도 되면 getter구현** . getter 추가 -&gt; 중복필드로서 같이 움직이는 해당 상태값이 추가된 상황에서 . 최상위 인터페이스에서부터 추가되었으며 . | 구현시, 어느 구상체들도 thr로 예외없이 다 100% 다 구현된 상태라면 . | 구상체 100%구현 메서드 + 필드로서 중복제거를 위한 중간추상층이 추가된다. . . | | 추상클래스 이름은 Finished를 포함하여 모든 구상체를 아루는 형용사인 Started(시작된 상태)로 한다. . State인터페이스를 구현한 추상클래스를 만든다. . | getter만 구현하여 막아주고, 구상체 100% 동일구현이 아닌 나머지는 다 흘려보낸다 . | 중복된 필드의 구현이라면 생성자 대신 public final 템플릿 setter로 정의한다. . . . | 하위에 있는 추상클래스Finsished, Ready, Hit는 State가 아닌 Started중간추상층을 extends하고 중복되는 getter + 필드 + 생성자를 모두 제거한 뒤, 필드를 사용하던 곳은 getter로 / 생성자로 받던 재료는 setter로 변경해야한다. . . Finished . . | Ready . . | Hit . 자신의 필드 cards를 사용하던 곳은 부모가 물려준 중복메서드인 템플릿 getter -&gt; cards()를 내수용으로 사용한다. | 자신의 생성자 주입으로 상태를 받았던 것을 부모가 물려준 중복메서드의 템플릿 setter를 이용해 물려받는 -&gt; 부모의 field를 채우고 -&gt; 나는 getter cards()만 사용할 수 있게 한다 | . . | . | | 추상클래스로 중복필드 + 생성자까지 제거 하다보니 -&gt; 생성자가 없으면 public생성자상태가 되어버렸다. . 하지만, 패키지내 중간객체 클래스 or 유틸메서드 클래스의 생성자들은 default와 private으로 잠겨있어야한다. . | 패키지내 시작객체 Ready를 제외한 모든 구상 상태겍체들의 보이지 않는 기본생성자를 재정의해서 default로 변경해주자 . . . | | 상태객체의 인터페이스 오퍼레이터는 최소 4개+ @가 필요하다 . trigger 메서드: draw() . | 중단 메서드: stay() . | 현재상태값 반환메서드: getter cards() . | is특정[중간추상층]인지 확인 메서드: boolean isXXXX() . 여기서는 stay개발시 불가하여 묶여진 Finished 형용사 중간추상층이 이미 있으니 끝난 상태냐라고 물어볼 수 있다. . 특정 구상체인지는 물어보지 않는다. 그놈빼고 다 false를 대답하기 때문에 -&gt; 특정 구상체인지는 물어보지말고 메세지를 던진다. | . | 다형성 인터페이스에 존재하는 boolean 메서드는 -&gt; 구상체들이 구현만 해주면 알아서 개별 답변되는 메서드다 . . | . | | State인터페이스에 특정상태(그룹, 중간추상층) 확인 메서드를 구현하고 . Started는 건너띄고, Finished에서는 True / 나머지 구상체 Ready, Hit에서는 False를 return하자 . . Finished에서 구현했다면, 추클로서 중간에 중복을 먹어 구현하였으니 final을 달아야한다 | . . . . . | . | 상태객체의 인터페이스 오퍼레이터는 최소 4개+ @가 필요하다 . trigger 메서드: draw() | 중단 메서드: stay() | 현재상태값 반환메서드: getter cards() | is끝난상태[중간추상층]인지` 확인 메서드: boolean isXXXX() | 현재 상태객체를 만드는 상태값Cards를 이용해서, 정보를 가진놈이 기능을 가진다 정보전문가패턴에 따라, 상태값으로 가능한 연산은, 가진 놈이 한다. | cards를 가진 state객체가, cards로 계산하는 것을 한다. | . | | 상태별 수익계산 profit()메서드를 State인터페이스에 구현해보자. . 만약, 추상체변수만의 구상체별 자동 구현을 모른다면? state객체를 보유한 player 내부에서 . state.isBlackjack()? -&gt; 블랙잭 계산 . | state.isBust()? -&gt; 0 반환 . | state.isStay()? -&gt; Stay 계산 . | 하나하나 다 확인해서 그에 따른 계산을 해줘야한다. . . | . | 추상체변수의 구상체별 기능 구현은 전략패턴처럼 구현만 하면 알아서 적용된다. . 이미 외부생성(전략패턴) or trigger메서드(상태패턴)에 의해 State state안에는 Blackjack이나 Bust나 Stay가 담겨있는 상태다 개별로 구현만 해주면, 알아서 작동한다. | . | 대신, 알아서 계산안되어야할 놈들은 thr나 예외처리 해놔야한다. | . | 추상체 변수의 상태이용 개별구현 메서드는 구상체를 물어보지말고 구현만 해놓으면 알아서 적용된다. . 상태값이 일반 객체였으면… 물어보고 판단했을 것인데… 추상체변수인 순간 알아서 구현됨을 생각하자. | . | . | State 인터페이스에 전략패턴과 달리, 구상체들이 가진 상태값cards를 바탕으로 계산하는 기능인 profit을 구현하되, 파라미터로 [계산마다 바뀔 수 있는 필요정보 betMoney]를 인자로 받자 . 구상체들이 상태값을 가지는 경우, 인터페이스 오퍼레이트는 상태값을 이용한 계산 기능도 추가할 수 있다. . getter도 그랬고.. | . | 인터페이스에 메서드를 올리는 순간 알아서 구상체별로 개별구현되는 메서드구나 생각하자 . . | 계산의 대상은 이미 끝난 상태의 Finished만 해당이 된다. . Ready와 Hit는 예외상황으로 먼저 막아놓자. . . . | . | . | 구상체들에서 개별구현되니 일단은 중간추상층(Finished)는 건너띄고 구현한다 . Blackjack -&gt; betMoney의 2배 반환 | Bust -&gt; -1을 곱해 반환 (그만큼 손해) | Stay -&gt; 추가정보가 더 필요하니 계산말고 그냥 반환 | . | 중간추상층이 좋은 부모가 되려면, 공통점이 아예 없는 개별구현로직 조차, 개별구현훅메서드를 래핑하고 있는 public final 템플릿메소드로 가지고 있고, 서로 다른 로직은 protected abstract 훅메서드만 내보내줘야한다. . CompareFile(ctrl+D)로 구상체 메서드들의 공통점과 차이점을 살펴보고, 어느부분까지를 훅메서드로 뺄 것인지 생각한다. . 상수만 서로 달라도, 해당부분을 훅 메서드로 뺄 수 있다. | . | 구상체들 중 서로 다른 훅 부분에 가장 파라미터가 많이 사용되는 로직을 가진 구상체 1개를 선택하고 해당 메서드를 중간추상층으로 잘라내서 올린다 . | 올린 public 템플릿메서드 내부에서 다른 부분만 내수용 메서드 추출(구상체private -&gt; 추상체protected abstract)의 훅메서드로 만든다 . 올리고 나서 훅을 만든다면, 메서드 추출후 가시성을 private -&gt; protected abstract로 직접 변경해줘야한다. | 올린 템플릿메서드는 final로… | . | 나머지 구상체들은, 훅메서드를 구현하면서, 기존 구현메서드의 다른 부분만 훅에 입력한 뒤, 기존 메서드는 삭제해준다. . . . . | public 템플릿메소드는 final을 달아준다. 깜빡했으면… . | | 중복제거 등 추상화/상속 관련작업이 끝날 때마다, diagram을 보자 . 복잡하다면, 생성자+method만 키고 보자. | . . 추상화 레벨을 보고 싶다면, 바로 위의 추상클래스에 데고 usage(shift+F12)를 통해 어떤 놈들이 나를 직접 extends했는지확인하면 된다. . . | . | Finished 기존 중간추상층과 추상화레벨을 맞추기 위해 Ready와 Hit구상체의 공통점과 차이점을 확인한다. . draw, stay는 구현내용이 개별구현으로 100% 달라서 일단 유지하고 . | profit()과 isFinished()는 비슷한게 아니라 완전히 동일하므로, 추상층에 올릴 것이다. . . | . | finished에 대항하는 isFinished false를 가진 형용사 중간추상층 Running을 만든다. . . Started를 구현하고, Ready에서 공통메서드만 중간에서 먹어준다. . | abstract클래스며, 중복코드를 제거하는 템플릿메소드들은 final을 달아준다. . . . . . | | 이제 추상화레벨이 맞춰졌다. . . | 부가적인 처리로서, 자식들은 훅메서드만 가지도록 좋은 부모 만들기의 일환으로 . 100% 로직이 달라도 메서드명만 같다면, 100% 훅메서드인 포장 public final template으로 올리자. | . . 문제는 오퍼레이터 메서드명은 유지되어야하는데, 100% 훅메서드명을 동일하게 못잡으니 어렵다. . draw -&gt; drawFrom . | stay -&gt; stayEach . . | . . . . | 자식 구상체들은 훅만 소유 . . | . | Finished에서도 좋은 부모를 만들기 위해 템플릿메서드로 올리고, 자식들은 훅만 소유하도록 변경해보자. . . draw를 중간추상층의 템플릿메서드로 올리자 . 100%로직이 같아서 훅메서드를 뽑을 필요가 없었다. . . | final을 달아주는 것을 깜빡해서 달아주자. . . | . . | . | 그러고보니, 중간추상층 2개도 상위 추상클래스로 올릴 수 있을 것같은데, 훅을 메서드 vs 안가진 메서드 등의 차이도 있고, 카테고리 문제도 있어서 일단 여기까지만 처리한다. . 구상체(자식들)은 모두 훅메서드만 가졌다. | 전략패턴으로 변경된다면, 전부 전략메서드만 구현하게 되는 것이다. | . . | 이제 상태객체를 추상체변수로 소유해서 사용하는 Player를 다른 패키지에서 생성한다. . 상태객체는 trigger에 의해 계속 변화므로 not final 필드초기화+ set계열메서드로 가지고 있는다. . | 상태를 바꾸는 set계열이지만, 이미 정해진 종류의 상태를 가진다면 set대신 public void toggle에 가깝다. . 필드초기화시 유일하게 열린 Ready 로 만든다. | . . . | . | 메서드가 호출객체(자신)의 상태가 변하는 메서드(setter/toggle계열)때, 호출객체(state) 상테에 따른, 제한[호출시 예외발생코드가 존재]이 있는 action이라면, if문으로 [예외발생 코드 상태로 진입못하게 하는] 상태condition을 확인후 시행해야한다. . state가 blackjack, bust, stay로 업데이트되었다면, draw를 호출 시 예외가 발생한다. | 애초에 해당 상태(Finished)가 아닐때만 호출하도록 condition을 걸고 시행한다 예외발생 코드를 짜놨찌만, 그쪽에 도달하지 못하게 막아주는 것이다. | . | . . | 만약, 매번 확인하며 자신을 업데이트하는 작업을 여러번 &amp;&amp; 조건불만족시까지 반복하고 싶다면 -&gt; if condition + set계열 action의 반복문이 while이다. . 이 때, 파라미터는 Cards의 컬렉션 뭉태기가 아니라 반복이 끝날때까지, iterator로서 1개씩 재료 제공메서드()getter를 제공해주는 객체가 파라미터로 와야한다. . 1번일 때 파라미터가 Card라고 해서 -&gt; Cards 나 Cards컬렉션을 생각하지말고 iterator같은 객체를 생각하자. public 메서드의 파라미터 == 외부에서 생성되어 들어옴 -&gt; 도메인 객체를 외부에 함부러 -&gt; 허용하지말자 . my) 데이터(도메인)객체를 함부로 외부에서 생성하도록 public 메서드의 파라미터로 받지말자. -&gt; 내부에서 생성하거나, 내부에서 iter로 받자 -&gt; 도메인객체의 메서드가 public으로서 외부에 공개된 것이면 상관없지만, 일단 내부생성/캡슐화 조달(iter)로 받자 | . | 반복이 끝날때까지, 매번 재료를 1개씩 제공해줘야한다. . . | . . | . | 카드를 1장씩 제공해줄 수 있는 Deck을 만들어보자. . Deque의 재료 컬렉션을 생성할 땐, ArrayList로 일단 생성하고 . | 제공할 때, 얕은복사(생성자복사)시 new ArrayDeque&lt;&gt;( list )의 생성자 복사시 형 변환하여 deque를 제공해주면 된다. . | 이 때, 랜덤으로 섞인 것을 제공해주려면, ArrayList를 먼저 shuffle한 뒤, deque로 생성자복사해서 제공한다 . . | 가변 콜렉션 -&gt; append을 써서 생성하는 것은 stream으로 묶어서 일괄처리가 가능하다. . 2중 for문은 stream -&gt; map -&gt; stream -&gt; 기존map을 flatmap후 바깥에서 collect하면 된다. . . . . . | | 생성자에서 쓰이는 내부context(보라색)은 필드인데, 내부 필드 초기화는 메서드 추출시 안뽑히고 내수용메서드가 되어버리니, 필드 초기화하는 = 우항값을 지역변수로 뽑아서, [필드 = 초기화]가 아닌 [지역변수 할당 = ]해서 필드초기화는 제외시키고, 위쪽만 메서드 추출하자. . 메서드 추출시, 필드 초기화 부분은 제외시키자! . | 메서드 추출시, 다른 곳에 위임되지 않을, 내부context필드 초기화 &amp;&amp; 재할당은 할당값(우항)만 따로 지역변수로 빼놓고, 해당 context를 제외시키고 추출한다 . 만약, 내부context를 다른쪽에 위임하는 로직이면, 내부context를 지역변수로 빼서 위쪽으로 놓고, 해당 지역변수가 파라미터로 잡히게 한다. | . . . . | . | | 랜덤이 포함된 로직은, 보이자마자, 전략패턴적용을 위해, 메서드추출 -&gt; 전략객체.메서드()호출 -&gt; 전략객체에 위임 -&gt; 전략 인터페이스 생성으로 빼놓자. . 랜덤이 껴있는 전체로직( 객체 반환까지 )을 1개의 메서드로 추출한다. . . | 위임을 위해 예비전략메서드의 인자에 new 랜덤전략객체()를 넣어서 파라미터로 추가한다. 내부에선 사용하진 않는다.(위임하기 위해 만든 객체라서 원래 사용된 상태) . 파라미터에 전략객체가 있어야 -&gt; 파라미터 속 1개의 객체로 위임할 수 있다. . . | . | 내부 메서드가 있다면, 모두 new 전략랜덤객체를 파라미터로 추가해준다. . 내부 메서드들 내부의 this context도, 모두 전략객체로 교체 . . . this가 메서드레퍼런스에 껴있으면, 다시 람다식으로 풀어서 파라미터 추가 . . . | . | 보라색 context가 껴있으면, 파라미터로 추출 . | . | 내부메서드들부터 F6으로 위임한다 . 만약, 바깥부터 하면, 내부 내수용메서드 == Deck메서드 == Deck가 파라미터로 달린체로 위임된다 . . | 아주 안쪽 &amp;&amp; 먼저 실행되는 내수용 메서드들부터 위임하자 . . . . 위임된 내수용메서드들은 수동으로private으로 바꿔주자.(옮길때는 위임해준 쪽으로 넘겨줘야해서 public이 자동으로 걸린다.) . . | . | | 이제, 특정 전략객체가 아닌, 전략인터페이스를 파라미터를 통해 외부에서 주입받아서 소유하도록 하기 위해, 구상체로부터 전략인터페이스를 만들어 올린다. . 구상클래스에서 @Override -&gt; extract interface -&gt; 전략인터페이스 생성 -&gt; 전략메서드만 추출 . | 구상체 사용처(Deck)에서 파라미터 추출 -&gt; 생성자로는 전략인터페이스가 들어오도록 수정 . . . | | | 이제 Deck에서는 랜덤Deque카드들을 소유한 상태이므로 Player에게 pop으로 1개씩 제공해준다. . Player는 while문으로 상태확인하면서, Deck으로부터 1개씩 재료를 iterator처럼 제공받는다. . . . | . | 하나의 기능만 뺀 전략패턴은 람다식을 편하게 사용하도록 애너테이션을 붙여준다. . . | RandomCardGenerator는 List로 종류별로 만든 카드 List -&gt; Shuffle후 -&gt; Deque로 반환해주는데, Deque의 재료 List는 1번만 생성해놓고, 필요시 shuffle후 생성자복사만 매번 해주면 된다. . 즉, 카드종류별 List는 static 필드에 미리 1번만 생성해놓으면 된다. | . . . | 이제 Random로직이 보여서 묶어서 만든 전략패턴의 수동전략 생성 or 람다식 대입을 만들어보자. . 수동전략은 사실상 Test에서 밖에 안쓰이므로 도메인에 전략객체 생성을 안한다 | 람다식으로 바로 대입이 불가능하면, 수동전략 클래스를 testutil에 추가해준다. | . | 전략객체가 주입되는 객체를 생성하고, 전략객체 주입부에 가상인자 람다식으로 [전략메서드 대신구현]이 가능한지 보자. . 확인해보니 , Deck의 생성자에서 쓰고 있다 -&gt; 테스트에서 new Deck() 을 만들자. | . . . . 람다식으로 전략메서드 로직을 구현하여 시그니쳐에 맞는 응답을 해줄 수 있는지 확인하자. . 전략메서드는 Deque&lt;Card&gt;인 new ArrayDeque&lt;Card&gt;();를 채워서 응답해주면 된다. | . . | 람다식 내에서 수동으로 채워주기엔 무리가 있으니 위쪽에서 지역변수로 채워놓고, 해당 지역변수를 넣어줘도 된다. . . | 카드2, 5를 수동으로 채워서 deck을 pop해보면, 뒤쪽 5가 나온다 . . . | . | 수동으로 전략메서드 시그니쳐 응답값 구현을 반복해서 사용할 예정이라면 메서드 추출후, Fixed수동전략객체Class에 위임하여 재활용한다. . 이 때, 수동으로 넣어주는 값들을 변수로 빼서 사용할 수 있다. . 랜덤카드생성은 정해진 수의 카드만 가능 | . | 수동카드생성은, 파라미터로 원하는 요소들로 짧게 구성 가능 . . . | 원하는 수만큼 받을 수 있게 2번째 파라미터부터를 가변배열로 받아서 처리한다 . . . | . | 이 때, 테스트용 수동 전략이 적용된 객체생성까지를 하나의 fixture생성으로 보고 묶을 수 있다. . . . | 캐싱객체 or 불변Vo객체의 Fixture 모음이 아니라 1개의 FixtureGenerator로서 testutil패키지지 &gt; FixtureGenerator클래스를 만들고, 생성 유틸메서드로 추출하여 재활용할 수 있다. . testutil패키지 아래 FixtureGenerator 클래스를 만든다 . | private메서드를 유틸메서드(Fixture정팩매)로서 public static을 붙인 뒤 위임한다 . . . . | | player는 카드1장 받으면 Ready이 되어야한다. . . . 하지만, 최초의 Ready상태에서 Started에 선언된 공통필드가 null상태라서 getter호출시 에러가 난다. . . . . . . | . | 교훈) not final + setter계열 조합 for좋은부모는 null참조가 될 수 있으니 반드시 초기값 필드초기화를 해주자 . . . | 2장이상 draw하면, Ready가 아닌 상태가 된다. . . | Player가 Deck을 전달받으면 finished가 될때가지 draw로 뽑아간다. . 이럴 경우, hit상태도 !finished라서 계속 반복하여 stay를 못한다 | . . deck을 받아도 finished까지 반복이 아닌 1장만 받도록 수정해보자. | . . . 만약, ! state.isReady()가 존재했다면… 연속해서 Ready아닐때까지 받으면 좋으련만.. 이 draw는 Ready를 벗어나기 위한 것으로 1번밖에 안쓰인다. draw는 범용으로 finished전까지 호출되어야하는 것이 맞다 | 그러나, stay호출을 무시 ready -&gt; hit -&gt; finished로 가기엔 finished까지 가기엔.. stay상태는 hit -&gt; stay()메서드호출만 가능한 finished상태임. | . | . | isReady는 isFinished(끝난후 호출가능한 메서드 ex&gt; profit 등이 있는 중요한상태)와 달리, 오퍼레이터로 작성하기엔.. 무리가 있다. Ready빼고 finisehd그룹 -&gt; 공통 false / Hit -&gt; false로 2개만 주면 되긴 하는데.. | . | . | . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/tdd/%EB%B8%94%EB%9E%99%EC%9E%AD/%EB%AF%B8%EC%85%98/%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%A0%95%EB%A6%AC/2022/08/05/TDD-%EC%B4%9D%EC%A0%95%EB%A6%AC3-%EB%B8%94%EB%9E%99%EC%9E%AD-%EA%B5%AC%ED%98%84%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4%EA%B3%BC-%EB%9E%9C%EB%8D%A4%EB%A1%9C%EC%A7%81-%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/tdd/%EB%B8%94%EB%9E%99%EC%9E%AD/%EB%AF%B8%EC%85%98/%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%A0%95%EB%A6%AC/2022/08/05/TDD-%EC%B4%9D%EC%A0%95%EB%A6%AC3-%EB%B8%94%EB%9E%99%EC%9E%AD-%EA%B5%AC%ED%98%84%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4%EA%B3%BC-%EB%9E%9C%EB%8D%A4%EB%A1%9C%EC%A7%81-%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4.html",
            "date": " • Aug 5, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "TDD 총정리2-로또 구현을 통한 랜덤로직 전략패턴",
            "content": "분기문 자체를 enum에 [찾을 때 지연실행될 로직]으로서 매핑할 수 있으며, 이미 시그니쳐가 정해진 함수형인터페이스를 이용해 돌면서(values().stream.filter내부) 지연 수행(.test)될 분기문을 [가상인자+람다식으로 실시간 외부 구현]으로 매핑해야한다 | . 로또 구현 . 도메인 및 객체 산출이 어렵다면 controller부터 정제된 input을 받고, output도 받환해야하는 service부터 출발한다. . 로또부터? 로또번호부터? 로또 게임부터? 로또 서비스부터? 정제된 입력을 받아 구현할 수 있다면 서비스부터 | . | 블랙잭 카드부터? 블랙잭 게임부터? 블랙잭 서비스부터? 정제된 입력은 이름 밖이고 카드를 사람당 랜덤 2장 뽑아야해서.. 그걸 지서 2장 받는 카드부터 | . | . | . | 서비스부터 짠다면, input -&gt; output까지 메인 흐름을 생각해야한다. . 입력1: 사용자의 로또번호 + 보너스번호 입력 | 입력2: 당첨번호 입력 | 출력: 당첨등수 응답 | . . | 정제된 input -&gt; string을 split등 전처리를 다 끝낸 원시형 + 컬렉션(List.of() - 어차피 불변객체 넣어줄테니까, 조작불가능 얕은복사 사본)을 사용해서 만들어준다. . 아직 도메인 객체 추출을 못했으니, 원시형 + 컬렉션으로 작성한다 . . | . | 테스트할 메서드는 무조건 응답하도록 먼저 작성하며 이 때, 응답값은 [넣어준 인자에 대한 case값을 응답]을 해줘야한다 . 만약, 로또번호 vs 당첨번호 인자 입력을 1등 번호로 예시case로 넣어줬다면, 그 인자 case에 맞는 1등이 응답값으로 반환해야한다(아무거나 반환X) | 인자가 3개이상이면, 엔터쳐서 줄바꿈해준다. | . . | 테스트 성공시 refactor -&gt; 다음case (2번째부턴 일반화함)를 준비한다. . . | 2번째 case를 넣기 전에, 1case 인자를 그대로 사용한 체 2메서드를 복붙 생성하고 이 상태로 로직을 짜면서 if등을 활용해 1case 통과하도록 짜도 된다. 1case통과 시하면 2case에 맞는 인자로 변경하여서 본격적으로 짜도 된다. . . | 새로운 case(2번째라서 일반화)를 추가하되, 2번째 case추가 == only 1case -&gt; 일반화로서 일반화 로직 추가 -&gt; 2메서드로 작성한다 . 서비스는 상태값이 없으므로 지역변수에 결과값이 나올 것인데, 1case가 통과하도록 if를 걸어주며 짠다. | 컬렉션 vs 컬렉션 비교는 반복문 + 요소vs컬렉션 비교 + 업데이트 지역변수가 사용된다. | . | 1case가 통과되도록 짠 뒤 -&gt; 2case(일반화 케이스)로 짠다 . 이 때, ValueSource(고정 값 1개)나 | CSVsource(고정 값 2개이상)나 | MethodSource(객체 이상)을 활용해서 경계값 케이스 위주로 확인한다. | . . 통과되면 2메서드로 기존테스트 돌린 뒤 대체 | . | 매칭5개가 2등이 아니라, 매칭 5개 + 보너스볼이 2등이고, 5개는 3등이다. . 만약, 6-5-4 순으로 내려온다면 (7-매칭갯수)만 return하고 분기는 없어질텐데 예외적인 상황이 발생하므로 if분기를 가지고 가야한다. | . | 중간에 예외를 처리하기 위해 if분기로 보너스볼 매칭까지 확인해야한다. | . . . | service 메서드를 통해 정제된input에 도메인 지식이 쌓였으면, SERVICE에서 input중 가장작은 단위의 input부터 예외발생해야하는 case를 작성하고 -&gt; 도메인에서 검증로직을 작성한다. 이후 그다음 input단위인 컬렉션에서 예외발생 case를 작성하고 -&gt; 도메인에서 검증로직을 작성한다. . service에서 가장작은단위 input에 대한 예외 case를 작성한다. . . | 원시값에 대한 검증을 위해 검증이 필요한 원시값을 new 때려서 도메인객체로 포장한다. . . . . | 현재 1개인자만 포장해줬기 때문에 컴파일에러가 뜬 상황임. 먼저 수정해준다. . . | | ​ . 인자를 1개만 포장했다면 -&gt; 전체 인자 다 포장한 뒤, 메서드의 파라미터도 변경해줘야한다. . 이 때 쓰는 것이 오버로딩이다. . 메서드의 파라미터 타입이나 시그니쳐가 달라졌을 때 | 기본값을 입력해야할 때 ex&gt; 꼬리재귀 재귀함수 최초호출 기본값 인자 | . . | 기존의 원시값컬렉션인자 -&gt; 객체 컬렉션인자로 가려면, 기존 메서드 내부에서 포장처리를 한번 해줘야 한다. . 원시값컬렉션 파라미터 메서드 내부에서 -&gt; 도메인 컬렉션으로 변경하여, 도메인컬렉션 파라미터 메서드를 호출하도록 한다. . | 원시값 로직은 아직 일급컬렉션을 도입안했다면, 로직을 그대로 도메인컬렉션 메서드 내부로 옮길 수 있다 . . | 다만, 다만 도메인 컬렉션(List)가 contains( 단일도메인 )처럼 원시값처럼 도메인을 사용하려면, eq/hC재정의를 해줘야한다. . . | 다시 원시값으로 인자 입력이 가능해진 상태이므로 서비스 호출시 에러가 나도록, 원시값 인자 입력으로 바꿔준다 . 만약, 도메인 인자를 입력하면 service메서드 진입전 도메인 자체에서 에러가 난다. | . . | 테스트가 통과되었으면 리팩토링해준다. . . | 테스트에 도메인인자가 모두 사라졌다면, 오버로딩으로 내부 호출되는 도메인 파라미터 메서드는 private화 해준다. . | | 서비스에서 원시값의 도메인 포장 로직이 반영되었다면, 도메인 자체의 검증Test도 시행해준다. . | . | 이후 도메인 컬렉션 인자 포장시 [이미 원시값 인자 존재 + 1개의 오버로딩 존재 + 도메인컬렉션 파라미터는 필요없을 때] . public 원시값 컬렉션 파라미터 메서드가 있는 상태에서 | 원시값 -&gt; 도메인변환 -&gt; 오버로딩 private도메인컬렉션 파라미터 메서드 | 오버로딩 private도메인 파라미터메서드만수정대상으로 삼아 2메서드를 만들고 도메인 컬렉션 파라미터 -&gt; 내부에서 일급컬렉션 변환후 | 오버로딩 private일급컬렉션 파라미터 메서드 대신, 내부에서 만든 p-&gt;변환메서드-&gt;p2(일급컬렉션) 자체를 파라미터 추출로 올려 도메인컬렉션 -&gt; 일급으로 변환을 오버로딩 내수용 메서드의 인자에서 호출 + 내부는 변환로직의 return값인 p2(일급컬렉션)이 파라미터가 되게 한다. | . | . | | 적용해보기 . 수정대상 메서드는 private내수용 오버로딩 [도메인 컬렉션 파라미터] 메서드이다. . | 수정 대상을 2메서드로 복사한 뒤, 내수용 오버로딩 메서드라서 여기서 테스트는 못한다. public 메서드로 테스트할껏이므로 상위메서드는 2메서드를 사용하도록 일단 바꾼다. . . . | 2메서드의 파라미터를 변환하여 파라미터가 되길 원하는 값을 return하는 변환메서드(or 생성자호출)를 작성한다. . p1 -&gt; 변환메서드(p1) 추출 -&gt; 예비 p2 상태에서 . | 변환메서드를 파라미터 추출하면 . 외부메서드호출부( 변환메서드(p1) ) -&gt; 내부는 (p2)가 파라미터가 된다. | 파라미터 변환 적용하기 작전이다. | . | 변수명은 똑같이 추출해서, 잠시는 에러나더라도 같은이름으로 변경하여, 내부로직에서 변경사항 파악이 쉽게 빨간줄들어오게 해놔야한다. . . | . . . | | 파라미터 변환(도메인 컬렉션 -&gt; 일급컬렉션) 변경에 따라 컬렉션 에서 물어보던 것들을, 일급컬렉션 내부러 던져야한다. . 일단은 빨간줄을 없애도록 작성한다. | 파라미터 변경메서드로 기존테스트가 잘돌아가는지 확인한다. | . | 일급컬렉션에 원하는 검증로직(중복검사 by distinct.count vs size, 갯수)를 확인한다. -&gt; 예외발생 테스트 통과시 2메서드를 반영한다 . . | 이제, 도메인 객체(Lotto, 일급컬렉션)의 경계값 테스트도 작성해야햔다. . 현재는 도메인 컬렉션 생성자만 있다. 원시값 컬렉션 파라미터 생성자를 추가하고 싶다. . 파라미터 추가는 인자 그대로 작성후 -&gt; 변환 -&gt; 오버로딩의 과정으로 추가한다고 했다. | . . 만약, 원시값 배열로 입력하면 가변인자(배열)로 받는다. | . . . | | 서비스 start~end까지 로직이 짜여졌으면 해당 로직에 맞는 메서드명으로 변경한다. . start() -&gt; match() | . . | 서비스내 getter가 보이면, 도메인 내부 로직으로서 캡슐화로 감춰야하는 로직임을 100% 생각한다. . 출력을 제외하고 getter는 없다고 보자. | getter이후가 같은형의 비교면 -&gt; 해당형으로 책임을 위임해 옮긴다 | getter이후가 다른형의 비교면 -&gt; 제3형을 만들어 책임을 위임한다. | 같은형의 비교시 -&gt; 내부 메서드로 돌아갈 때, 하나는 other라는 파라미터명으로 잡아서 처리해준다. | 일급컬렉션엔 일반 컬렉션이 못했던 책임위임을 할 수있다. 내부에서 알아서 하도록 / 출력할때 빼곤, 객체에 getter를 쓰지 않고 위임한다. | . | . | 같은 형 2개의 비교로직 위임이면, getter를 쓰는 하나만 타겟팅해서 위임받을 context로 잡아야한다. . 위임받지 않는 녀석만 파라미터에 포함되도록 하려면 . static에서 static으로추출된 상태로 옮기면 위임받는 객체가 this등으로 리팩토링 안되게 된다. . | 객체에 위임하는 로직은 메서드 추출후, static있다면 삭제해야한다. static내부 nonstatic메서드로 빨간줄이 떠도 참아야함 . static은 공용, 상태없는 유틸메서드이므로.. 파라미터 input -&gt; output형태라서 this등 리팩토링 안됨 | . . . . | 같은형의 객체 2개가 파라미터에 있으면, 타겟팅할 변수를 선택하라고 인텔리제이가 알려준다. . private변수를 객체에 위임할 땐, Escalate -&gt; Public으로 바꿔서 이동시켜준다. | . . . . . | 같은형의 비교에서 파라미터에 있는 같은형은 other로 네이밍해주자. . . | | 메서드 추출로 위임되었으면 getter()호출부를 삭제한다. . . | . | 제한된 종류의 상수가 보이면 enum 값객체로 대신할 수있다. . 이 때, 네이밍은 의미_원래값형태로 해주면 된다. 1 -&gt; RANK_1 | 0 -&gt; RANK_NONE | . | . . . 제한된 종류의 상수를 작성한 뒤 원래값을 매핑해둔다. . . . . | 응답값이 상수에서 -&gt; 값객체enum으로 변경되었으니 테스트도 다 수정해준다. . . | . | **enum은 ** . **{} : 값객체가 외부에서 파라미터로 입력되면 추상클래스로서 추상메서드를 이용해 [가상인자+람다식]에의해 수행되도록 전략객체로서 행위를 구현해놓을 수 있지만, ** | (): 분기별 값객체 반환시 분기문 자체를 값객체에 매핑해놓고, values()를 통해 매핑된 정보를 바탕으로 해당 값객체를 반환해주는 정적팩토리메서드가 될 수 있다. | | 현재 분기별로 생성된다. -&gt; 정적 팩토리 메서드로서 [분기를 함수형인터페이스로 매핑하여 돌면서 지연실행될] 생성메서드를 만들고 위임해야한다. . 기존 : 분기별 생성을 정적팩토리메서드에 위임하기 전 확인사항이 있다. | . 전체 값객체(enum)생성 분기문을 위임해야한다. 그전에 해야할 것이 있다. . 위임의 첫단추는 내부context로 사용하는 값은 위임객체에선 외부context가 되도록 위임객체context외에 모든 context값들을 변수로 만들어서 추출해야한다. . | 특히 파라미터가 제일 많은 부분을 확인해야하며, 조건식 내에서 메서드호출된 것도 값이다!! . boolean문안에서 여러객체를 이용한 메서드호출() -&gt; 1개의 응답값을 가지는 값(파라미터) 1개로서 -&gt; 1개의 외부context로 위임될 수 있도록 추출될 로직보다 더 위쪽에 미리 1개의 지역변수로 빼놔야한다. . . | badCase: 로직 위임전 [내부 여러객체.메서드호출()]부를 지역변수로 안빼놨을 때 . 여러객체를 사용한 메서드호출은 어차피 1개의 값으로 사용되는데, 연관된 객체가 모두 변수로 뽑힌다. | . . | GoodCase: 로직 위임전 [내부 여러객체.메서드호출()]부를 위임로직 더 위쪽에 지역변수 1개로 응답값을 받았을 때 . . . | . | | | 위임할 로직 전체보다 더 위쪽에서, 위임 로직 내부 객체.메서드호출()부를 지역변수 1개로 빼놓고 메서드추출한다. . 정팩메 위임의 메서드명은 of라고 지으면 된다. . . . | . | 위임할 정팩메of를 enum에 위임한다. . | enum은 내부 분기문들을 인스턴스에 ()매핑후 돌면서 찾기로 제거가 가능하다. . 각 분기문들을 values() -&gt; filter에 걸릴 수 있게 각 인스턴스에 지연될 실행될 로직으로서 매핑해야한다. 지연실행될 로직은 함수형 인터페이스(or전략인페.전메())으로 지연호출부 정의 -&gt; 가상인자 람다식에서 외부구현(or전략객체로 생성)의 방법이 있다 | | | 지연실행될 로직은 전략패턴이 아니라면 미리 시그니쳐가 정의된 boolean을 반환하는 Predicate함수형인터페이스를 사용하여 정의한다. . 매핑될 boolean반환형 함수형인터페이스의 변수명은 condition으로 편하게 지어주자. . | enum에 매핑되어있는 condition을 찾아서 .test()로 지연실행할 것이다. . | 이 때, 람다식의 가상인자로 구성되는 분기식에 쓰이는 실제 인자들을 지연실행 메서드에 넣어줘야한다. . . . | | 매핑할 함수형인터페이스는, enum의 필드로 선언해줘야한다. . 빨간줄 생성하면 filter속 .test()로 사용될것을 인식하여 BiPredicate변수로 만들어준다. | . . . | 값매핑 필드 삭제, 함형 필드는 생성자에서 추가한 뒤 각 분기문들을 가상인자 람다식으로 구현해야한다. . 이 때, 분기문이 없는 enum필드도 매핑되어야하므로 분기문을 만들어주고 매핑한다. | . . Bi로 정의했기 때문에, 1개의 파라미터만 쓰더라도, 파라미터가 많은 것을 따라야한다. . . . . | . | enum도 메서드 생성시 도메인 테스트를 해줘야한다. . . . | 정적팩토리메서드로 class를 객체찍는템플릿에서 능동적인 객체관리자로 승격시킨다. . new 생성자 : 100% 객체를 생성해야함(캐싱못함) | 정펙매 캐싱(재사용) 가능해짐. | . | . 인자의 갯수에 따라 .of or from으로 public static 메서드를 생성한다. . | 기존 생성자와 동일한 형으로 key / 재사용할 객체형을 value로 해서 HashMap을 만든다. / 캐싱할 인스턴스 객체수를 알고 있다면 capacity를 저적어준다. . 변수는 static변수로서 상수의 map으로서 jvm돌때 미리 생성된다. | . . . | 캐싱의 핵심은, 존재하면 map에서 get으로 꺼내고, 없으면 생성이다 . map의 초기화도 미리 이루어진다. | . . . | 없으면 key-value 넣어주기, 있으면 꺼내기는 map.computeIfAbsent( key, 람다식으로 value생성식)을 넣어주면 된다. . 람다식은 가상인자로 작성해야해서, key값을 그대로 넣어주면 에러남. | . . . | 정적팩토리메서드가 완성되었으면, 기본생성자는 private으로 막아두고 각종 검증방법은 정팩메로 이동시킨다. . . . | 기존 new때려서 생성한 객체들을 of로 다 수정해준다. . . | 캐싱의 테스트는 식별자 일치를 확인하는 .isSameAs를 사용해서 테스트한다. . . . | 여러 쓰레드에서 접근한다면, 미리 모두 static생성 + ConcurrentHashMap으로 변경하고 getter만 하게 한다. . static 컬렉션 변수의 요소들은 staitc블록으로 요소들 미리 생성하게 할 수있다. | static블럭이 늘어나면, 해석하는데 힘이쓰여 좋지 않ㄴ다. | . . . | | 생성할 수 있는 파라미터를 추가해 생성자가 많아 견고한 클래스를 만들 수 있다. . 일반 생성자든 정펙매(캐싱 등) 생성자든 정팩메or생성자에 또다른 파라미터를 추가할 수 있다. | 상위 파라미터(더 원시) 추가는 변환 후 오버로딩을 하면 된다고 했다. 참고) 더 하위 파라미터를 추가해도 마찬가지지만, 더 하위 파라미터(기존 파라미터 변환해서 만들어지는)로 변환은 변환후 -&gt; 메서드추출 -&gt; 파라미터로 추출로 바깥에서 일하게 만들어서 파라미터를 바꾼다고 했음. | . | . . . | 불변 일급컬렉션을 만드는 과정 . 멋도 모르고 컬렉션&lt;단일객체&gt;을 생성자에 통채로 집어넣어 만든 일급컬렉션은 사실 상태 변화(setter/add 등) -&gt; [변화된 상태의 새 객체]를 생성해서 반환하기 위해 생겨난 생성자임을 생각해야한다. | . 단일객체에 대한 복수형으로 final 불변의 일급컬렉션 클래스를 생성하고, Set으로 단일객체를 보유할 빈 컬렉션을 조합한 필드를 가지고 있는다. . . . | 필드에 대해서 setter(상태변화) / getter를 고민해야한다. . 단일객체가 외부에서 변수로 받아져 조작되는 객체라면, 객체 자체를 파라미터로 받는 setter로 만든다. | 컬렉션에 대한 setter는 add/remve등이다. add로 단일객체 파라미터를 받되 | 상태변화의 setter(add)는 상태변화된 새 객체를 반환하여 불변성을 유지한다. | . . . 2번에서 상태변화된 컬렉션으로 새 객체 생성해서 반환을 하기 위해컬렉션을 통째로 받아 생성하는 생성자가 필요했음을 생각한다. | 즉, 필요에 의해 객체컬렉션을 받는 생성자가 생겼음을 인지한다. | | 컬렉션 필드의 상태변화는 기존 컬렉션필드가 변하지 않도록 사본으로 복사한 다음 상태변화시킨 후 새객체 생성을 해줘야한다. . 컬렉션필드를 수정할 땐, 항상 사본복사후 연산하자. 생성자를 통한 복사는 객체요소는 같은 주소를 바라봐서 요소변화가 가능한상태로 복사이다. | . | . . . | 기본생성자외 컬렉션 필드의 생성자가 생성되는 순간, 빈컬렉션의 필드초기화는 의미가 없어진다. 최초의 시작은 빈컬렉션으로 될 수 있도록 부생성자로서 추가해줘야한다. . . . | 파라미터가 없는 생성자는 부생성자이므로 파라미터가 있는 주생성자를 this로 사용해줘야한다. . . . | 불변의 일급컬렉션에 요소를 add하는 과정은 매번 재할당해줘야한다. . 불변 객체를 받는 변수는 재할당이 운명이다. . | 일급컬렉션은 getter().size()가 아니라 .size()메서드를 정의해서 쓴다. . | . . | | ​ . 참고스샷 . 최범균 블로그? 배민 팀장 블로그 | . .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/tdd/%EB%A1%9C%EB%98%90/%EB%AF%B8%EC%85%98/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%A0%95%EB%A6%AC/2022/08/04/TDD-%EC%B4%9D%EC%A0%95%EB%A6%AC2-%EB%A1%9C%EB%98%90-%EA%B5%AC%ED%98%84%EC%9D%84-%ED%86%B5%ED%95%9C-%EB%9E%9C%EB%8D%A4%EB%A1%9C%EC%A7%81-%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/tdd/%EB%A1%9C%EB%98%90/%EB%AF%B8%EC%85%98/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%A0%95%EB%A6%AC/2022/08/04/TDD-%EC%B4%9D%EC%A0%95%EB%A6%AC2-%EB%A1%9C%EB%98%90-%EA%B5%AC%ED%98%84%EC%9D%84-%ED%86%B5%ED%95%9C-%EB%9E%9C%EB%8D%A4%EB%A1%9C%EC%A7%81-%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4.html",
            "date": " • Aug 4, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "TDD 총정리1-자동차경주를 통한 랜덤로직 전략패턴",
            "content": "내부의 테스트 제어가 안되는 코드(랜덤, 날짜)는 [해당로직을 포함한 메서드]로 추출하고 전략객체.전략메서드()에 위임하고 외부에서 로직을 전달할 수 있게 하여, [테스트에 용이한 다른 전략]으로서 [랜덤 대신 확정값을 가상인자+람다식으로 구현]하여 전략메서드를 구현한다. | . . 메서드내 랜덤로직이 있어서 테스트가 곤란한 경우 . . 자동차 경주 구현 . 전략객체에 위임할 로직을 (예비 전략)private메서드로 추출한다. . | **추출한(위임할) 로직은 전략메서드 구현이므로 구상 전략객체로 넘겨야한다. ** . 인터페이스 생성 -&gt; | 구상체 생성 -&gt; 위임 메서드 복붙 -&gt; | 전략 인터페이스로 pull up해서 올려보자. | . | 전략객체는 협력객체로서 메서드인자가 아닌 생성자 주입되는 소유모델이 되어야한다. . 파라미터에서 전략객체를 받지말고, 생성자에서 받자. | . . | 인자로 들어가는 [협력객체]가 [Product용 기본값]이 있는 경우, 오버로딩을 이용해서 내부에서 협력객체 기본값을 강제시킬 수 있다. . ​ . | 이제 테스트코드에서는 랜덤전략 대신 실시간 확정 전략을 주입하자. . 전략객체.전략메서드()는 1개의 오퍼레이터만 가지는 함수형인터페이스로서 전략메서드를 구상전략객체 없이, (내부 추상체.전략메서드()부분을) 가상인자와 람다식을 통한 실시간 구현이 가능하다 . . . | 필요하다면, 전략메서드에 확정전략을 구현하는 구상전략객체를 추가해서 대입해줘도 된다. . 실시간 구현이 어렵거나, 테스트용 람다식이 아닌 구상체를 선택해야할 경우 | . | . | 상태를 변화시키는 메서드가, 테스트를 위해 상수 응답하는 getter의 역할까지 하고 있으므로 2메서드를 만들고, return상수응답 로직을 제거 뒤, 테스트에서 객체의 변화된 상태로 비교할 수 있게 수정해본다. . eq/hC재정의 후 객체 비교 vs getter구현하여 해당 상태값만 비교할 수 있다. . 현재는 전략객체 또한 필드로 들고 있으므로 getter를 따로 생성하여 상태 비교를 하자 | . . | 비교가 잘되면, 기존 테스드들 원본메서드 -&gt; 2메서드로 수정 + 응답값비교 -&gt; 객체상태값비교로 모두 수정하고 원본 삭제후 2메서드를 원본으로 네이밍한다. . | . | 상태변화 메서드인 .move()는 setter의 상태변화 대신, 상태변화된 객체를 반환하는 메서드로 변경한다. . 객체 자체를 수정하는 것이므로 2객체를 만들어서 테스트해야한다. . | move2를 만들고 position++처럼 상태를 변화하는 부분에서 상태변화된 필드로 새 객체를 만들어 반환하도록 수정한다. . . | 상태변화하는 필드는 기본값을 주고 생성자에서 안받았기 때문에, 생성자를 추가해주고 필드에는 final을 붙여준다. . . . | 테스트에서는 자신형 반환 메서드는 체이닝이 가능하므로 체이닝으로 작성해주면 된다. . 현재 객체는 협력객체를 포함하고 있어서, 객체끼리 비교가 불가하므로 어쩔 수 없이 getter로 필드를 확인한다. | . . | 기존의 테스트들(동일 객체 상태비교)을 새 객체반환을 변수로 받아서 상태를 확인하도록 변경한다. . 이후, Car의 기존이름을 바꾸고, Car2 -&gt; Car로 변경한다. | . | | 상태변경 메서드(새 객체반환)의 테스트가 끝났으면, 해당 상태로 만들어주는 생성자 추가를고려해서, 다른 테스트에 용이하게 한다. . . position 3과 5에 상태로 바로 도달하게끔 생성자를 추가해서, 이미 확정된 객체를 만든다. . 이렇게 하면,빈컬렉션+add로직이 컬렉션.of(특정상태,객체들)로 변경된다. | . . . . | . | 참고 스샷 . 자동차경주-테스트에서 서비스주입 . . 자동차경주-service로부터 raw결과(list)를 반환시 반환형 ResultView . . . . . . 정리 md(맷) . 마크다운 | . 정리 . service는 inputview를 알아도 되고, resultview를 반환해도 된다. | resultview는 출력을 하기 위해 도메인객체를 input으로 받고, 출력관련 책임만 가진다. 실제 print는 outputview가 하고, resultview는 출력될 요소를 만드는 역할이다. | resultview는 유틸메서드로서 string을 반환해준다. | racingGame -&gt; resultview에 전달할때는, car list를 반환해주고, 실제 list에서 문자열을 뽑아주는 기능을 사용하는 resultview내부에서 일급컬렉션을 의존사용하고 외부에서 일급컬렉션 생성가능한 파라미터로는 객체가 아닌 재료만받는다. 객체로 메세지를 전달하지만, 1개 객체의 add(create)에서는 재료만받을 수도 있다(객체 조작을 외부에서 꺼내서못하게 할때) | 객체list도 객체라서 굳이 일급컬렉션을 외부에서 사용안할때 생성할필요는 없다? | . | . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/tdd/%EC%9E%90%EB%8F%99%EC%9E%90%EA%B2%BD%EC%A3%BC/%EB%AF%B8%EC%85%98/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%A0%95%EB%A6%AC/2022/08/03/TDD-%EC%B4%9D%EC%A0%95%EB%A6%AC1-%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%9E%9C%EB%8D%A4%EB%A1%9C%EC%A7%81-%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/tdd/%EC%9E%90%EB%8F%99%EC%9E%90%EA%B2%BD%EC%A3%BC/%EB%AF%B8%EC%85%98/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%A0%95%EB%A6%AC/2022/08/03/TDD-%EC%B4%9D%EC%A0%95%EB%A6%AC1-%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%9E%9C%EB%8D%A4%EB%A1%9C%EC%A7%81-%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4.html",
            "date": " • Aug 3, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "TDD 총정리0-요구사항 정리와 테스트 코드 작성 정리",
            "content": "TDD 작성 . 참고블로그 | . 요구사항 정리 . 제목(##)과 - [ ] 박스를 만든다. | 키워드를 추출한다 | 객체 vs 메서드 vs UI vs 세부요구사항으로 나눈다. | 관리 vs 객체 시작점을 고른다. | ## 요구사항 - [ ] 각 자동차에 이름을 부여할 수 있다. - [ ] 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다. - [ ] 자동차 이름은 쉼표(,)를 기준으로 구분한다. - [ ] 자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한명 이상일 수 있다. ## 키워드 -&gt; 분류 -&gt; 객체 vs 메서드 vs 세부요구사항 vs ui 나누기 -&gt; 시작점 고르기 - 자동차 - 이름 : object - , 기준으로 구분 : 세부요구사항 - ui 맨 나중에 - 전진 : method - 자동차 경주 게임 - 완료한 후 누가 우승했는지를 알려준다. : 메서드 - 우승자 - 한명 이상 : 세부요구사항 . 테스트 . 테스트 작성요령 . **시작점을 고를 때, ** . **기능(메서드)을 가진 데이터객체이외에 ** . | controller에서 정제된 input이 들어오고, controller로 output응답도 해야하는 Service부터 시작할 수 있다. . 정제된 input부터 -&gt; 메인 흐름을 다 나열 -&gt; 출력될 ouput객체까지 반환해주는 것이 service의 역할이다. 처음부터 객체도출은 어려울 수 있다. | . | 서비스의 메서드부터 짠다면, input 부터 output까지 메인 흐름을 생각하고 정리해야한다 | 서비스 start~end까지 로직이 짜여졌으면 해당 로직에 맞는 메서드명으로 변경한다 | . | service에 대한 input이 내부 로직에 의해 데이터객체로 주어진다면, 컴퓨터가 줄 데이터객체로부터 만들어놓고, 그것을 이용한 input으로 한 -&gt; output을 내는 핵심로직부터 시작한다. . 예를 들어, 블랙잭게임을 하면, 카드덱으로부터 카드2장이 주어진다. 이미 카드 2장이 주어졌다고 가정하고 데이터객체 카드부터 만들고 핵심 로직으로서 시작하자. | . | service가 핵심로직이 아닐 수 있다. 서비스내 Game등이 핵심로직일 수 있다. | input -&gt; output이 나오는 핵심로직부터 시작한다. Game.start()로 시작하자. | . . | 핵심로직 자체도 service가 아니라 (상태패턴이라면) 상태를 가지는 객체로 바뀔 수 있다. . 서비스 메서드 == 스태틱 메서드 like 유틸메서드에서 -&gt; 객체가 되었다면 . 상태값을 가지며, 상태값을 만드는 정보input들은 다 생성자로 들어와야한다. | 메서드로 상태값 정보가 들어온다면, setter다. | . | 서비스의 유틸메서드 input -&gt; 생성자로 주입 된다 . | 서비스의 유틸메서드내 로직을 거친 뒤 1개의 output응답값(상태객체) -&gt; 필드로 가진다. . 상태객체는, 정보만 가져야하므로 상태객체가 아닌 상태객체를 사용하는 객체일뿐이다. . | 상태객체로 다시 변환하려면 다른 상태객체들과 상태값(필드) 와 메서드를 동일하게 사용하도록 수정해야한다. . Ready도 다른 상태객체들과 동일 상태값 필드(Cards)를 가지며 생성자로는 아무것도 주입 안된 빈카드로 초기화하는 기본 생성자로 만들어져야한다. . | Ready도 .start()로 다른 객체로 넘어가는 것이 아닌 다른 상태객체들의 메서드처럼 Trigger메서드(draw())로부터 setter정보를 받아 상태값업데이트 이후 상태값을 가지고 판단하여 다른 상태로 넘어가도록 수정한다. . Ready는 카드를 2장을 받는다. -&gt; 다른상태객체처럼 draw로 1장씩 받도록 정의하고 외부에서 2번을 호출하던지 다른 파라미터로서 받도록 오버로딩메서드로 정의해준다. | . | . | . | 서비스 or 핵심로직 통합테스트가 Ready라는 1개 상태객체 테스트로 바꼈다. . 개별 상태객체로 테스트코드들을 나누어서 옮긴다. | . | . | | 정제된 input(원시값)을 통해 service개발을 완료하고 나면 . 가장작은 단위의 input에 대한 서비스에서 예외발생테스트를 먼저 만들고 -&gt; 필요에 의해 도메인 객체에서 예외발생 되도록 도메인을 생성한다 원시값input을 도메인객체로 만들면서 사전검증이 이루어지도록 해야한다. 검증이 필요한 원시값에 new도메인()을 때려서 시작한다 | | | 그 다음에 컬렉션을 일급컬렉션으로 만들면서 중복 검증 등의 검증이 이루어져야한다. | . | 가장 빠르게 실패는 thr IllegalStateException을 활용하고. 가장 빠르게 성공은 로직 없이 응답값만 return하도록 만든다. . 실패 -&gt; 성공 -&gt; 리팩토링 을 반복한다. | . | 생성자로 시작 이외에 나중엔 (상태필드 변경후 상태로 확인) 바뀌더라도 상수 응답 메서드로 먼저 테스트를 작성한다. . car.move()는 setter같은 메서드인데, 처음 메서드 작성시 1칸 전진마다 상수1을 응답값으로 주도록 만든다 | 응답도 getter로서 조회의 일이다. 조회용 메서드가 아니라면, 로직 테스트 완료후 응답 대신 상태로 확인하도록 변경해야한다. 조회용 메서드가 맞는지 확인한다. | 조회용 메서가 아니라면 getter같은 return응답을 제거한다. | 기존에 메서드결과로 응답값을 조회했던 부분을 값 비교 -&gt; 객체 비교를 하도록 eq/hC 재정의 및 테스트 assert문 수정을 해줘야한다. | | 상태가 변하는 메서드는 setter이므로 불변객체를 유지하기 위해, 상태값 변화 대신, 상태값이 변화한 객체 응답메서드로 바꾸자. 다시 한번 응답메서드가 되지만, 상수 응답이 아닌 새 객체를 만들어 반환이다. | 객체의 상태값 및 생성자 등이 바뀌므로 2메서드가 아니라 2객체를 생성해서 테스트한 뒤 반영한다. | . | . | 테스트할 메서드는 무조건 응답하도록 먼저 작성하며 이 때, 응답값은 [넣어준 인자에 대한 case값을 응답]을 해줘야한다 . 만약, 로또번호 vs 당첨번호 인자 입력을 1등 번호로 예시case로 넣어줬다면, 그 인자 case에 맞는 1등이 응답값으로 반환해야한다(아무거나 반환X) 2번째부터는일반화하는 경우가 많으니, 첫 메서드 생성하는, 1번째 첫 인자를 입력할 때, case에 맞는 반환도 생각하고 입력하자 | . | TDD메서드의 응답값은 테스트메서드의 테스트CASE에 의해 작성순서가 결정된다. | . | case별로 테스트 메서드를 만든다. 메서드명_CASE____세부내용형태를 빌린다. . 2번째case부터는 일반화해도 좋다 | case == 메서드의 인자가 결정 | . | **테스트케이스 추가에 따른 기능추가, 사전 검증과 같이 전체메서드가 걸린 기능추가는 ** . 메서드를 전체를 2메서드로 복사해놓고 테스트 | 기존 테스트들을 2메서드로 호출하도록 변경 후 전체 테스트 이 때 기존테스트()의 소괄호까지를 ctrl + h로 찾아서 변경하면 쉽게 변경된다. | . | 기존테스트들 다 통과시 회색으로 안쓰게 된 원본메서드 안전삭제(alt+del) | 2메서드를 -&gt; 원본메서드로 변경 | | 기능 추가 -&gt; 2case부터 일반화로직 추가시, 1case를 보존하기 위해, 2메서드 복붙후 테스트에서 1case 인자를 그대로 사용 + 내부로직의 결과값에 if를 사용하더로 먼저 통과시키게 해야한다. . | 특정로직(private메서드)에 대한 기능 추가는 private메서드만 복사해서 테스트해놓고 끝나면 반영하고 삭제한다. . | 요구사항이 복잡해질 땐, 그 부분만 아래에서 학습테스트를 진행해도 된다. . | 상태변경 메서드의 테스트가 끝나고 다른 기능 테스트를 할 때, 특정 상태를 만들기 위해 상태변경메서드 반복 호출을 하지말고, 직접 해당 상태로 만드는 생성자를 추가해서 현재하는 테스트에 집중하게 한다 . 특정상태의 객체를 불변객체로 바로 만들면, 빈컬렉션+add가 사라진다. | . | 기존파라미터(원시 컬렉)를 살려두고 이어서갈 땐 새 인자(도메인 컬렉)로 메서드 작성후 오버로딩 . 기존 파라미터(도메인 컬렉)를 변환된 파라미터(일급컬렉션)로 대체하고 싶다면 내부변환후 파라미터 추출 | . . | 서비스내 getter가 보이면, 도메인 내부 로직으로서 캡슐화로 감춰야하는 로직임을 100% 생각한다. . 출력을 제외하고 getter는 없다고 보자. | getter이후가 같은형의 비교면 -&gt; 해당형으로 책임을 위임해 옮긴다 | getter이후가 다른형의 비교면 -&gt; 제3형을 만들어 책임을 위임한다. | static메서드였으면, static을 삭제하고 -&gt; 메서드 이동 -&gt; 파라미터 중 위임할 객체가 2개가 같은형이면, 하나의 변수를 택1한다 | . | 같은형의 일급vs일급은 -&gt; 일급vs단일(contains) 메서드를 사용할 확률이 높다. 확인해서 처리한다. . | 정해진 갯수의 인스턴스는 정팩메를 통한 캐싱을 도입하자 . | 정팩메든 생성자든 파라미터를 추가하면 견고한 클래스가 된다. . 자바(부생성자개념)이외 언어들은 주생성자로만 생성하고 다양한 타입의 파라미터로 생성하려면 정팩매를 이용해야한다. | 나도 앞으로 파라미터 추가를 위해서 정팩매 도입을 고려해봐야겠다. | . . | 일급컬렉션도 빈컬렉션으로 시작하여 add시 새객체반환하는 일급컬렉션으로 만든다. . new 빈컬렉션을 인자로 받는 부생성자를 만들어주면 된다. | . | 기존에 생성자 없이 사용하던 객체에, 상태값이 추가되어 생성자가 추가될 경우, 부생성자로 빈값할당으로 초기화해주는 기본생성자를 추가해서 기존코드가 망가지게 않게 한다 . | 여러종류의 클래스객체 응답이 가능한 메서드에 대해 특정 클래스의 객체를 응답하는 테스트를 작성하려면, Object actual -&gt; isIntanceof(특정클래스.class)로 테스트코드를 작성한다. . | 여러 종류의 객체return는 추상체 응답의 상태패턴을 고려한다. . . 상태패턴을 도입했으면, 응답값으로 나온 현재 상태를 바탕으로 추상체에 있는 [다음상태로 갈 수 있는 인자]를 받아 [다음상태로가는 메서드]를 정의해줘야한다. 에러호출로 종료되는 제일 쉬운 현재상태(blackjack)부터 [다음 상태로 넘어가는 메서드]를 만들자 | . | 추상체를 만드는 순간부터 패키지를 분리하여, 패키지폴더 대상 다이어그램으로 의존성을 확인하자. . 이후, 구상체만의 메서드 개발후 올리기전 다이어그램 + CompareFile하자 | . | 상태변화가 없는 객체는 캐싱객체 or VO로, eq/hC를 재정의하여 값이 같으면 같은 객체가 되는 값객체라서 testutil패키지 &gt; Fixtures클래스안에 상수객체로 만들어 써도 된다. . test루트에서 testutil 패키지를 만들고 내부 Fixtures를 만들자 | Fixtures에 쓸려면 어디서든 불러도 같은 객체가 생성되도록 캐싱==싱글톤이 보장되어야한다. 캐싱객체는 test코드에서 isSameAs로 확인해야한다. | eq/hC의 VO값객체는 test코드에서 eq/hC 재정의 후 isEqualTo로 확인해야한다 | . | 상수객체 Fixture는 한글로 알아보기 쉽게 네이밍해도 된다. | . | 상태패턴의 상태객체반환 with trigger되는 결국엔 다른 객체의 상태값으로 포장될 객체들은 view에 넘기기 위해 getter를 무조건 가진다 . trigger 등 set계열 메서드들 개발이 완료되면 getter도 개발해야한다. | . | 좋은 부모를 만들기 위한 전략(템플릿메소드) 중 중복 필드 처리 . Object)중복로직제거 Strategy to Templatemethod(Plan3) 추상클래스는 좋은 상속의 부모로서 변수는 private, 메서드는 final or protected abstract, 생성자없이 setter로확인하여 달아준다. | | 구상체별 중복되는 필드를 올릴 땐, 구상클래스 생성자 주입 -&gt; setter메서드 -&gt; private필드로 올린다. | 부모의 private필드는 부모내에서 처리하게 하고, 자식은 부모private필드자체는 못쓰고, final 물려주는 템플릿메소드들만 쓴다. 자식들이 훅메서드 구현시 필요한 정보들은, 자기가 생성자 주입받아서 쓰면 된다. | 자식이 부모의 private필드값을 써야한다면, 부모에게 구현된 getter를 물려받아 쓰면된다. | . | | 암기getter . getter정의시 return 불변객체라면, public열어두기 가능 + dto없어도 됨 불변의 일급컬렉션 객체 반환 -&gt; dto없는 public getter로 제공 | 불변 객체 아니라면, Dto로 만들어서 반환 | . | getter정의시 return 컬렉션필드라면, view로 보낼 땐, 깊은 복사로 못건들게 해서 반환 불변의 일급컬렉션 자신 내부의 컬렉션 필드 반환 server사이드 반환이라면, 얕은복사 반환후, 내부에서 객체들 조작 | view반환이라면, 깊은 복사 반환 or DTO로 반환후, 내부 객체들 조작안되게 | . | . | | 중복제거 등 추상화/상속 관련작업이 끝날 때마다, diagram을 보자 . 복잡하다면, 자물쇠의 show dependencis만 끄면 상속관계가 잘 보인다. . | 추상화 레벨을 보고 싶다면, 바로 위의 추상클래스에 데고 usage(shift+F12)를 통해 어떤 놈들이 나를 직접 extends했는지확인하면 된다. . . | . | 랜덤이 껴있는 로직은, 테스트를 고려해서 1개 메서드(함수형인터페이스)로 추출하고, 무조건 전략패턴으로 만들어야한다 . 추출할 메서드는 [전략객체-or]에 대해 -동사()를 쓴다 ex&gt; Generator -&gt; generate() / Applier -&gt; apply() | 구상 전략객체에 해당 내수용메서드를 위임하기 위해선 [인자에 구상체 생성 -&gt; class생성 -&gt; 파라미터에 추가]해야지 F6으로 위임된다. | 내수용메서드들이 포함되어있다면, 모두 해당객체를 인자추가 -&gt; 파라미터로 추가해놓자. | 내부 this를 사용했다면(위임전 객체의 context) -&gt; 위임받을객체로 일단 바꿔주자. | 내부 context(상태값 등)이 사용되었다면 -&gt; 추출 전 지역변수로 받아 추출하던지 or 추출후 파라미터추출해서, 파라미터에 포함되게 한다. | 다 만들어놨으면, 위임은 내부 &amp;&amp; 먼저 호출되는 순으로 위임해야지, 기존context가 안잡힌다. | 위임과정에서는 내수용private -&gt; public으로 된다. 위임후 수정해주자. | 구상 전략객체에서 @Override만 붙이면 extract interface가 가능하다. | 전략패턴이 되었으면 인터페이스에 @FunctionalInterface를 달아준다. | 테스트에선 람다식으로 만들되, 바로 못만들면, 시그니쳐 반환형에 맞춘 객체를 수동으로 만들어, 람다식에 넣어주는 식으로 한다. 꼭 또다른 전략객체를 안만들어도 된다. test용 class라면 만들필요가 없다. | 만드는 과정에 바뀌는 변수들을 파라미터 추출하고 메서드로 정의한다. | 전략주입 객체까지를 하나의 Fixture로 볼 수 있다. [ 테스트용 수동전략 생성 + 전략적용객체 생성 ]까지를 1개의 fixture로 보고 여러 테스트에서도 사용할 수 있다면, testutil패키지의 FixtureGenerator클래스에 유틸메서드(public static)로서 빼주면 된다. | . | . | . | 테스트 코드 작성시 팁 . split등으로 actual될 값이 2개이상이면, assertAll을 활용해서 0번인덱스부터 단계별로 확인하자 . | 상수 리팩토링은 result_index , result_prefix 등으로 case_result + 명칭을 그대로 붙여서 지어도 된다. . | 메서드 안에서 또다른 일을 하는 경우, 파라미터 -&gt; 또다른 일 -&gt; 반환 과정을 메서드추출하고, 파라미터로 올리면, 추출메서드가 현재메서드의 인자로 올라가서 일하고 있게된다. . | 케이스 추가 -&gt; 테스트메서드 추가 -&gt; 메서드2 작성시 개별 메서드 호출마다 저장소가 필요하다면, 메서드주체인 객체의 상태필드를 이용해야한다. 필드를 만들어서 쓰자. . | 메소드에 존재하는 테스트 힘든 코드는 확정값을 만들 수 있는 전략객체로 위임하되 전략객체는 협력객체로서 메서드 인자가 아닌 생성자 인자로 받아야한다 . 프로덕션용 기본 전략값이 정해져있다면 생성자 오버로딩을 이용하자 | . | getter에서 get을 뺀 뒤 필드처럼 지어서, 내부의 필드명이 없는 것처럼 감출 수 있다. . | .setter처럼 상태변화 메서드가 만들어졌다면, 상태변화한 객체를 새로생성해서 반환하는 메서드로 변경한다. . 필요시 생성자를 추가한다. | 자신형 객체반환 메서드는 체이닝이 가능하니 테스트에서 체이닝으로 작성해도 된다. | . | 특정 상태를 만들기 위해 상태변경메서드 반복 호출을 하지말고, 직접 해당 상태로 만드는 생성자를 추가해서 현재하는 테스트에 집중하게 한다 . 특정상태의 객체를 불변객체로 바로 만들면, 빈컬렉션+add가 사라진다. | . | 컬렉션 인자 작성사 List.of는 컬렉조작불가능한 얕은복사을 사용하자. . Arrays.asList는 조작가능한 생성자 복사(얕은 복사) 사본 | . | 인자가 3개이상이면, 엔터쳐서 줄바꿈해준다. . | 컬렉션 vs 컬렉션 -&gt; 반복문 + 요소 vs 컬렉션 + 저장/업데이트용 지역변수가 생긴다 . | 원시값 인자 포장시, 검증대상에 new때려서 만들기 시작하며, 검증로직 작성 후, 전체 원시값인자들을 도메인 인자로 변경하여 -&gt; 도메인 파마리터 메서드를 생성한 뒤, 원시값 파라미터 메서드 내부에서 도메인 전환후 오버로딩 호출할 수있도록 로직을 변경한다. . 테스트코드에서 도메인 인자들이 다 사라지고 원시값으로 다시 복구되었다면, 오버로딩의 도메인 파라미터 메서드는 private화 시켜서, 외부에서 객체 생성을 막는다.?! | . | 도메인 컬렉션 인자 포장시 [이미 원시값 인자 존재 + 1개의 오버로딩 존재 + 도메인컬렉션 파라미터는 필요없을 때] . 내부에서 p1 -&gt; 일급컬렉션 변환과정까지 작성하고 새롭게 파라미터 추출해서 파라미터 자체를 변경한다. | 원시값 포장시에는 도메인입력 &lt; 원시값입력이므로 기존 파라미터 메서드를 살리는 방향으로 오버로딩 적용을 했었지만, 도메인 컬렉션 -&gt; 일급컬렉션에서는 도메인컬렉션 입력을 죽인다. | . | 일급컬렉션의 검증은 도메인객체들의 갯수, 중복여부등이다. . | 같은형의 비교시 -&gt; 내부 메서드로 돌아갈 때, 하나는 other라는 파라미터명으로 잡아서 처리해준다. . | getter를 포함한 로직을 위임할 땐, . 메서드 추출 -&gt; 위임받을 객체가 파라미터로 뽑혀야함 | 그외 보라색 내부context는 위임객체 포함 모두 외부context -&gt; 파라미터가 되도록 추출해야함 | static이 붙어있으면 반드시 삭제(빨간줄감수)하고 이동해야함 | 같은형이 2개가 파라미터에 있다면 알아서 선택하는 창이 뜸 | private을 객체에 위임한다면, 옮길 때, public으로 선택할 수 있음(안하면 default로 감) | 옮긴 후 (this.)getter()호출을 삭제하고 내부 필드context로 바꿈 | | **enum은 ** . **{} : 값객체가 외부에서 파라미터로 입력되면 추상클래스로서 추상메서드를 이용해 [가상인자+람다식]에의해 수행되도록 전략객체로서 행위를 구현해놓을 수 있지만, ** . | (): 분기별 값객체 반환시 분기문 자체를 값객체에 매핑해놓고, values()를 통해 매핑된 정보를 바탕으로 해당 값객체를 반환해주는 정적팩토리메서드가 될 수 있다. . 지연실행될 로직은 함수형 인터페이스(or전략인페.전메())으로 지연호출부 정의 -&gt; 가상인자 람다식에서 외부구현(or전략객체로 생성)의 방법이 있다 . | 위임의 첫단추는 내부context로 사용하는 값은 위임객체에선 외부context가 되도록 위임객체context외에 모든 context값들을 변수로 만들어서 추출해야한다. . | 특히 파라미터가 제일 많은 부분을 확인해야하며, 조건식 내에서 메서드호출된 것도 값이다!! . | boolean문안에서 여러객체를 이용한 메서드호출() -&gt; 1개의 응답값을 가지는 값(파라미터) 1개로서 -&gt; 1개의 외부context로 위임될 수 있도록 추출될 로직보다 더 위쪽에 미리 1개의 지역변수로 빼놔야한다. . . | badCase: 로직 위임전 [내부 여러객체.메서드호출()]부를 지역변수로 안빼놨을 때 . 여러객체를 사용한 메서드호출은 어차피 1개의 값으로 사용되는데, 연관된 객체가 모두 변수로 뽑힌다. | . . | GoodCase: 로직 위임전 [내부 여러객체.메서드호출()]부를 위임로직 더 위쪽에 지역변수 1개로 응답값을 받았을 때 . . . | . | | 캐싱 도입 방법 . 정팩메가 필요하다 | static컬렉션(hashMap) CACHE (기존 생성자파라미터를 key, 객체를value로 하는 Type)를 필드초기화하고 | static정팩메에서 if 없으면 생성해서 넣어주고 , 있으면 get을 요청한다 computeIfAbsent(key, 가상인자람다식으로 value생성(객체생성)) | . | 미리 static블럭에서 static변수들(캐싱변수도)을 초기화해서 캐싱할 객체들을 미리 생성할 수 있음. | 여러쓰레드에서 입력할 가능성이 있다면, ConcurrentHashMap으로 캐싱static 변수를 초기화한다. | 캐싱대상 객체는, 상수나 다름없기 때문에, 값으로 비교하기 위해 eq/hC 오버라이딩 한다. | . | 일급컬렉션도 빈컬렉션으로 시작하여 add시 새객체반환하는 일급컬렉션으로 만든다. . new 빈컬렉션을 인자로 받는 부생성자를 만들어주면 된다. | . | enum의 생성은 Enum.상수의 빨간줄로 만든다. . | 메소드 인자나 조건식에서 연산을 하고 있다면 -&gt; 메서드 추출로 리팩토링한다. . | functional자리에 supplier의 객체생성자 호출이면, 가상인자를 ignored -&gt; 로 만들고 안쓰면 된다. . | 여러종류의 객체를 응답받는 메서드의 응답값중에 특정 class가 응답되어야하는 메서드의 테스트 코드 작성시 . return null으로 작성하고 | Object형으로 변수로 받고 | assert문에서 isInstanceOf( 특정클래스.class )로 확인한다. | . . | enum에 값이 매핑되는 순간부터 바로 getter를 작성해주면 된다. . | 일급컬렉션으로 포장안된 상태라면, 동일형 객체 일괄처리는 List.of()나 Stream.of()를 사용해서 묶어서 처리한다. . 동일형 객체끼리의 단순연산도 List.of()로 묶은뒤 stream으로 연산이 가능하다. | 단일형은 단순연산도 일단 묶어서 처리하자. | . | 동일형을 묶어서 일괄처리 or 단순연산한다면, 묶는 부분(List.of)에서 일급컬렉션을 도입하고, 일괄처리 + 단순연산되는 로직을 위임하자. . 단순연산도 -&gt; 묶어서 일괄처리해놓으면 -&gt; add로 갯수가 늘거나 줄어도 메서드가 유지된다 | . | 있는지 없는지 유무만(몇개 있는지)filter + count가 아니라anyMatch( -&gt; 개별요소판단 )로 판단한다. . | 책임위임을 위임하려면, 일단 현재context상의 메서드의 파라미터에 걸려있어야 하며, static메서드라면, static키워드를 삭제하고 위임해야한다. . 파라미터로 걸면서 getter를 사용했다면, 위임후에도 내수용getter를 쓰고 있으니 필드로 바꿔줘야한다. | . | 또다른 리팩토링으로서 조건식에 하나의 도메인에 대한 메서드호출이 나열되어있다면, 메서드 추출시 파라미터에 1개만 도메인만 걸리며, 이 또한 묶어서 책임을 위임할 수 있다. . 역시 static안이라면, static을 지우고 위임한다. . . . | . | 여러 종류의 객체return는 추상체 응답의 상태패턴을 고려한다. . . 상태패턴을 도입했으면, 응답값으로 나온 현재 상태를 바탕으로 추상체에 있는 [다음상태로 갈 수 있는 인자]를 받아 [다음상태로가는 메서드]를 정의해줘야한다. 에러호출로 종료되는 제일 쉬운 현재상태(blackjack)부터 다음 상태로 넘어가는[trigger메서드]를 만들자 | 특정 쉬운 구현체부터 시작한다면, 테스트에서 다운캐스팅해서 구현체만의 메서드로 생성하여 테스트하고 공통이면 올린다 . | 특정구현체의 메서드이며, thr 던질 메서드라도 미래에 공통으로 사용될 예비오퍼레이터라면, 응답형을 지정한뒤 던진다. 게임종료는 thr로 한다. | . | 다운캐스팅된 구상체만의 메서드 개발이 완료되면, 다이어그램을 확인해서, 올려도 되는지 판단한다. 다이어그램 + CompareFile을 펼쳐 모든 구상체가 호출해도 되는 메서드인지 확인한다. 다이어그램 단축키 : ctrl + alt + shift + U | compareFile : 구상체들만 선택후 ctrl + D | . | 올릴 거면, 다운캐스팅했떤 로직을 삭제하고, 다른 구상체들도 구현한다. | . | trigger + 정보를 판단하려면, 상태객체는 생성시부터 이미 정보를 상태값으로 가지고 있도록해야한다. | . | 일급컬렉션에서 add할 때, 내부에서 새로운 일급컬렉션 상태를 만들기 위해, 업데이트된 컬렉션 필드 상태를 만들어야하는데, 기존상태값(컬렉션 필드)를 얕은복사해서 연관성을 [떼어낸 상태에서 업데이트]야한다 . 기존 컬렉션 필드는 add하기 전에 얕은복사한 뒤, 생성자복사된 새 컬렉션에 add하고, 그것을 새로운 상태로 삼는다. | . | 상태필드가 객체이상, 일급컬렉션인 경우, 현재 구체적인 값의 상태를 물어볼땐 getter대신 메세지를 보낸다 . | setNext, add와 같이 같은형 객체를 반환하는 메서드들뿐만 아니라 같은카테고리인 추상체를 반환하는 메서드들도 체이닝 메서드이다. . | 작은 코드라도 수정한다면, 복사해서 수정하고 지운다. . | 인자입력시 List.of() -&gt; 가변배열로 입력하도록 변경한다. . | 상태변화가 없는 객체는 캐싱객체 or VO로, eq/hC를 재정의하여 값이 같으면 같은 객체가 되는 값객체라서 testutil패키지 &gt; Fixtures클래스안에 상수객체로 만들어 써도 된다. . test루트에서 testutil 패키지를 만들고 내부 Fixtures를 만들자 | Fixtures에 쓸려면 어디서든 불러도 같은 객체가 생성되도록 캐싱==싱글톤이 보장되어야한다. 캐싱객체는 test코드에서 isSameAs로 확인해야한다. | eq/hC의 VO값객체는 test코드에서 eq/hC 재정의 후 isEqualTo로 확인해야한다 | . | . . 상수객체 Fixture는 한글로 알아보기 쉽게 네이밍해도 된다. . | 상수 추출후, Fixture로 옮기기전에 미리 다 상수로 바꿔놓으면 더 쉽다(ctrl + H) . Fixture로 옮긴 후 프로젝트 전역으로 확인하고 싶다면, 상수값(우항)을 Ctrl + shift + F로 찾으면 된다. . . | . | . | 시작객체가 있다면, 같은 패키지로 몰아서 시작객체public을 제외한 나머지들은 default가시성을 가지도록 해서, 외부에서 생성안되도록 한다면, 사전검증을 안해도 된다. . 만약, 생성자가 기본생성자라서 정의를 안해줬다면, 재정의 후 가시성변경해줘야한다. 대표적인 예가 유틸클래스(상태값없이 input-&gt;output static메서드만 가지는)는 생성자를 private가시성으로 변경해주는 것이다. | 생성자가 없는 클래스 -&gt; public으로 열여있으며, 재료를 바탕으로 상태값을 만들지 않는 클래스 | . | client가 잘못입력할 수도 있기 때문에 중간에 생성되는 상태객체들은 외부에서 생성못하도록 가시성으로 막아주기 | . | 특정 구상체에만 사용되는 메서드가 등장했다. . 상속관계면, 조합관계로 바꾼다. | 이미 인터페이스를 구현하는 조합관계의 구상체였다면 일단 인터페이스에 올리고, 특정구상체만 자기메서드를 로직을 구현한다. | 마저 테스트를 진행해야하니 나머지 구상체들은 로직 없이 구현만 해준다 | 이후 해당메서드 테스트가 끝나면, 특정구상체 외 사용하지 않는 구상체들에게 내리기 전에 중간에서 막아주는 추상클래스로 만들어지는 중간추상층을 만들어준다. 억지로 구현한 코드가 중복이라서 중간추상층을 두고 중복코드를 제거한다는 개념으로 간다. | . | | 추상클래스 도입시 중간에 먹어줘서 공짜로 물려주는 것들은 (템플릿메소드) final을 달아서 자식이 수정 못하게 막아야한다 추상클래스의 public 템플릿메서드라면 눈꽃모양으로 final을 확인하자. | . | . | 좋은 부모를 만들기 위한 전략(템플릿메소드) 중 중복 필드 처리 . Object)중복로직제거 Strategy to Templatemethod(Plan3) 추상클래스는 좋은 상속의 부모로서 변수는 private, 메서드는 final or protected abstract, 생성자없이 setter로확인하여 달아준다. | | 구상체별 중복되는 필드를 올릴 땐, 구상클래스 생성자 주입 -&gt; setter메서드 -&gt; private필드로 올린다. | 부모의 private필드는 부모내에서 처리하게 하고, 자식은 부모private필드자체는 못쓰고, final 물려주는 템플릿메소드들만 쓴다. 자식들이 훅메서드 구현시 필요한 정보들은, 자기가 생성자 주입받아서 쓰면 된다. | 자식이 부모의 private필드값을 써야한다면, 부모에게 구현된 getter를 물려받아 쓰면된다. | . | | 암기getter . getter정의시 return 불변객체라면, public열어두기 가능 + dto없어도 됨 불변의 일급컬렉션 객체 반환 -&gt; dto없는 public getter로 제공 | 불변 객체 아니라면, Dto로 만들어서 반환 | . | getter정의시 return 컬렉션필드라면, view로 보낼 땐, 깊은 복사로 못건들게 해서 반환 불변의 일급컬렉션 자신 내부의 컬렉션 필드 반환 server사이드 반환이라면, 얕은복사 반환후, 내부에서 객체들 조작 | view반환이라면, 깊은 복사 반환 or DTO로 반환후, 내부 객체들 조작안되게 | . | . | | getter 추가 -&gt; 중복필드로서 같이 움직이는 해당 상태값이 추가된 상황에서 . 최상위 인터페이스에서부터 추가되었으며 . | 구현시, 어느 구상체들도 thr로 예외없이 다 100% 다 구현된 상태라면 . | 구상체 100%구현 메서드 + 필드로서 중복제거를 위한 중간추상층이 추가된다. . . | | 상태객체의 인터페이스 오퍼레이터는 최소 4개 + @가 필요하다 . trigger 메서드: draw() . | 중단 메서드: stay() . | 현재상태값 반환메서드: getter cards() . | is끝난상태[중간추상층]인지 확인 메서드: boolean isXXXX() . 상태객체 소유 객체(Player)는 상태가 isFinished될때까지 반복작업할 것이다. . | 여기서는 stay개발시 불가하여 묶여진 Finished 형용사 중간추상층이 이미 있으니 끝난 상태냐라고 물어볼 수 있다. . 특정 구상체인지는 물어보지 않는다. 그놈빼고 다 false를 대답하기 때문에 -&gt; 특정 구상체인지는 물어보지말고 메세지를 던진다. | . | 다형성 인터페이스에 존재하는 boolean 메서드는 -&gt; 구상체들이 구현만 해주면 알아서 개별 답변되는 메서드다 . . | . | | 추상체변수의 구상체별 기능 구현은 전략패턴처럼 구현만 하면 알아서 적용된다. . 이미 외부생성(전략패턴) or trigger메서드(상태패턴)에 의해 State state안에는 Blackjack이나 Bust나 Stay가 담겨있는 상태다 개별로 구현만 해주면, 알아서 작동한다. | 대신, 알아서 계산안되어야할 놈들은 thr나 예외처리 해놔야한다. | . | 추상체 변수의 상태이용 개별구현 메서드는 구상체를 물어보지말고 구현만 해놓으면 알아서 적용된다. | 상태값이 일반 객체였으면… 물어보고 판단했을 것인데… 추상체변수인 순간 알아서 구현됨을 생각하자. | . | 중간추상층이 좋은 부모가 되려면, 공통점이 아예 없는 개별구현로직 조차, 개별구현훅메서드를 래핑하고 있는 public final 템플릿메소드로 가지고 있고, 서로 다른 로직은 protected abstract 훅메서드만 내보내줘야한다. . CompareFile(ctrl+D)로 구상체 메서드들의 공통점과 차이점을 살펴보고, 어느부분까지를 훅메서드로 뺄 것인지 생각한다. 상수만 서로 달라도, 해당부분을 훅 메서드로 뺄 수 있다. | . | 구상체들 중 서로 다른 훅 부분에 가장 파라미터가 많이 사용되는 로직을 가진 구상체 1개를 선택하고 해당 메서드를 중간추상층으로 잘라내서 올린다 | 올린 public 템플릿메서드 내부에서 다른 부분만 내수용 메서드 추출(구상체private -&gt; 추상체protected abstract)의 훅메서드로 만든다 올리고 나서 훅을 만든다면, 메서드 추출후 가시성을 private -&gt; protected abstract로 직접 변경해줘야한다. | 올린 템플릿메서드는 final로… | . | 나머지 구상체들은, 훅메서드를 구현하면서, 기존 구현메서드의 다른 부분만 훅에 입력한 뒤, 기존 메서드는 삭제해준다. | | 다 구현된 상속구조에서 추상화레벨을 맞추기 위한 중간추상층 도입을 한다. . | 제한된 종류의 상태값을 가진다면 not final 시작상태 필드초기화 + setter대신 -&gt; public void toggle로 정의해준다. . | if 상태확인 -&gt; 상태업뎃을 매번 확인하면서 반복하는 것이 while 상태확인 -&gt; 상태업뎃이다. . | 좋은 부모를 위해 생성자없는 [not final + set계열 메서드]를 정의했다면, set전에 null나올 수 있으니, 빈값 필드초기화 해야한다 . | 이미 정해진 종류의 setter는 state = state변화의 toggle에 가깝다 . | 매번 상태확인후 시행하는 if condition -&gt; action를 반복하는 것이 while condition 반복문이다. . 이 때, 반복되는 동안 메서드 인자인 재료는 iterator처럼 1개씩 주어질 수 있어야한다. | . | 도메인 객체를 함부러 public메서드의 파라미터 == 외부생성으로 주지말자. . | 내부생성 or 내부에서 1개씩 제공해주는 iter느낌의 객체를 받을 수 있다. . | deque의 재료는 미리 list로 만들어놔야한다. 제공할 때 생성자복사시 형변환을 같이해서 줄 수 있다. . deque로 변환해서 가지고 있으면, pop()으로 iterator객체가 될 수 있다. | 형변환되어 제공될 재료 컬렉션은, 미리 만들어놓아도 된다면, static필드 + static블럭으로 초기화해놓는다. | . | 가변 변수 콜렉션에 add는 stream으로 해결할 수 있다. . | 2중 for문은 stream을 stream-&gt;map-&gt;stream-&gt;map -&gt; 첫번째 map을 flatmap으로 만들면 사용할 수 있다. . | 생성자내에서 [내부context인 상태값(가변변수) 재할당]을 포함한 메서드추출은 파라미터없이 그대로 재할당을 들고들어가 only내수용이 된다.(위임불가) . 재할당되는 line에 지역변수를 만들고, 그 지역변수를 재할당시키게 한 뒤, 내부context재할당을 제외한 로직을 추출하여, [재할당되는 값return]이 추출되게 한다. | 만약, 내부context도 같이가야한다면, 내부에 포함시키고, 파라미터 추출을 해준다. | . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/tdd/%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/%EC%A0%95%EB%A6%AC/2022/08/02/TDD-%EC%B4%9D%EC%A0%95%EB%A6%AC0-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD-%EC%A0%95%EB%A6%AC%EC%99%80-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1-%EC%A0%95%EB%A6%AC.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/tdd/%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/%EC%A0%95%EB%A6%AC/2022/08/02/TDD-%EC%B4%9D%EC%A0%95%EB%A6%AC0-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD-%EC%A0%95%EB%A6%AC%EC%99%80-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1-%EC%A0%95%EB%A6%AC.html",
            "date": " • Aug 2, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "command패턴 중 cmd객체 외부저장소List에 cursor도입 정리",
            "content": "command홀더객체 내, cmd객체들 외부저장소(List배열)과 cursor로 상태확인 . . redo는 undo로 인해 cursor가 원래배열의 끝보다 더 뒤에 있을 때, 한칸 앞으로 움직이므로 . cursor가 배열의 맨끝에 있지는 않은지 검사한다 . . | . | undo는 실행되어 기록이 저장된cmd가 1개라도 있어야한다. . cursor가 원소가 1개도 없을 경우인, 0보다 뒤에 있는지 확인한다 . . | . | execute후 add는, 현재 add된 것이 배열의 제일 마지막에 위치하도록 (add를 단순 cursor++만 해선 안됨) 해야 add후 redo시 에러가 발생안하게 되는데, cursor는 undo로 인해 배열 끝보다 더 뒤에 있을 수 있으니, add하는 순간에는 cursor이동 전에, 배열 remove로직도 들어간다. . **cursor만 빽(undo)하고 redo를 위해 배열에는 cmd객체를 남겨놓는데, cursor가 빽 한 상태에서 add한 것이 배열의 제일 끝에 위치하여, redo는 불가능하도록 만들어놔야한다 ** . | 그럴려면, 현재cursor(빽한 상황)보다 더 앞에 있는 cursor + 1 ~ 마지막까지는 먼저 배열에서 삭제해놓아야 한다 . | 그리고 난 뒤, 요소를 배열 맨마지막에 add했으면, cursor의 업데이트는 불변식 size()-1로 업데이트한다 . . | . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/menu/command/memento/%EC%A0%95%EB%A6%AC/2022/08/01/%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%8C%A8%ED%84%B4%EC%9D%98-undo,redo%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%B0%B0%EC%97%B4-cursor%EB%8F%84%EC%9E%85-%EC%A0%95%EB%A6%AC.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/menu/command/memento/%EC%A0%95%EB%A6%AC/2022/08/01/%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%8C%A8%ED%84%B4%EC%9D%98-undo,redo%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%B0%B0%EC%97%B4-cursor%EB%8F%84%EC%9E%85-%EC%A0%95%EB%A6%AC.html",
            "date": " • Aug 1, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "PATTERN 패턴 배우는 순서 정리",
            "content": "패턴을 배우는 순서 . 패턴을 배우는 순서 좋은 상속의 Templatemethod 패턴 . | 좋은상속이라도 조합폭발방지 -&gt; strategy패턴 . 전략패턴의 전략패턴 -&gt; adapter 패턴 | . | 전략객체가 많이 나오다보면, 단일요소 객체 vs 컬렉션 객체를 포괄하는Composite패턴 element vs collection -&gt; 컴포짓 패턴 | . | Composite객체의 출력을 위한 구상class 속 loop등의 제어문들을 타는 객체를 따로 외부에 위임 -&gt; Visitor패턴 . 제어문을 타야 자신의 데이터를 다 뿌릴 수 있는 객체(Composite객체)가 있다고 치자 . 제어문을 가진 체 출력하는 Renderer클래스가 있다 . | 제어문의 안에 내용만 바뀐다면 [종류별 XXXXRenderer클래스들]을 여러개 만드는 대신 제어문을 역전하여 유지만 하고, 제어문 안의 내용은 Visitor를 주입해서 끼워넣은 다음, 전략패턴으로서 종류별 XXXXVisitor를 만들어서 끼워넣자 . 제어문은 전략패턴으로 못만든다. 제어문 속에서 라이프싸이클별 작동하는 로직을 전략패턴으로 뺀 다음 Visitor로 이름 붙인다. . . | . | 이제 제어문 속 라이프싸이클을 타는 visitor별로 실제 제어대상 객체(Composite객체)를 제어역전된 클래스(Renderer의 메서드 인자 -&gt; Visitor의 메서드인자(역할위임)을 통해 Visitor에게 전달한다 . . | . | visitor를 주입받는 구상클래스(Renderer) 자체가 제어의역전 클래스임. Visitor객체 는 제어역전된 속에서 제어문만 탄다 . | 실제 컴포짓객체 속 데이터를 반환해주는 것은, Visitor의 역할책임으로 위임 . 데이터자체는 Composite객체가 VIsitor의 역할/책임 메서드의 파라미터로 들어가서 사용됨 | . | . | element간에 연결 by linkedlist -&gt; 데코레이터 패턴 . | 중간에 멈출 수 없는 한번에 쭉 가는 for문을 써야한다는 문제점 -&gt; 책임사슬 패턴 . | 나머지들 -&gt; 끝판왕 커맨드 패턴 Visitor주입으로 인한 제어의역전 이후에 행위도 캡슐화한 뒤 역전하는 Command패턴 | 이미 존재하는 composite 객체를 소유한 Command홀더 객체내에서 만들어간다 지연실행에 대한 일이라 어렵다 | 해야하는 일을 함수에 담아서 -&gt; 객체로 만들고 -&gt; 모았다가 -&gt; 실행or역카운터실행 | . | 제어에 참여하는 객체(Visitor가 파라미터로 위임받은 객체)를 소유한 커맨드홀더객체를 만들고 1개의 메서드(with 서비스메서드들) + 여러 구상커맨드객체들로 런타임에서 행위를 조작할 수 있는 범용객체가 된다. Visitor에 위임하는 객체를, 커맨드홀더가 소유함으로써 커맨드객체를 통한 행위조작으로 의존성없는 안전한 범용객체가 Visitor에게 역할 위임하게 되어 Visitor도 안전해진다. | 행위를 추가하려면, 커맨드객체 추가해서 처리하면 되니까?? | . | 커맨드홀더객체는, 범용객체로서, runtime에 행위위임 커맨드객체를 교체해서 갈아낄 수 있게 된다. xml에는 string으로 -&gt; 주입돌 커맨드들을 설정하는 것이고, 스프링빈즈가 runtime에 조립한다. | @autowired애노테이션 -&gt; 범용객체 생성 후, @달린 것들을 끼워넣어서 돌아가게 한다. | 커맨드홀더객체 == 커맨드invoker == 범용객체 == composite라면 root객체를 소유한 객체?! | . | . | 저장하고 로드하려면 -&gt; 메멘토 패턴 . 메멘토패턴은 visitor패턴을 통해 쉽게 구현할 수 있다. . 구상 visitor 중 1개(JsonVisitor)가 라이프싸이클을 타면서 처리된 내용을 매번 객체context인 필드에 저장해놓는다. . 이 때, 이미 외부에서 생성된 Visitor를 주입해야한다 | 다른 Visitor는 내부 지연생성도 할 수 있도록 주입대상인 Renderer는 factory 함수형인터페이스를 생성자로 받는다. | . . | save를 구현하는 곳에서는 상태값에 데이터정보를 저장한 상태이므로 getter로 제공받아 저장한다. . | . | 메멘토패턴은 Visitor패턴계열이다. 일단 Composite패턴 -&gt; 출력을 위한 Visitor패턴을 구현할 줄 알아야 구현된다. | . | 참고로 Command패턴은 다른 동네이다 bridge, adapter, command패턴이 한 동네이다. | 행위를 포장하는 것이 더 큰 동네이고 힘들다 | . | @Transactional을 하려면, 메멘토패턴으로 상태를 저장해야한다. undo/redo를 할 수 있다. 트랜잭션으로서 롤백을 할 수 있다. | 내가 만든 메소드도 롤백할 수 있게 된다. | . | . | 동네 구분 Visitor계열: strategy -&gt; composite + visitor -&gt; 전체의 40% | command계열: bridge, adapter 등 -&gt; 나머지 전부 | . | composite + visitor가 자유로우면 중급개발자이다. | . | 1패턴 -&gt; 1객체가 아니라 1객체가 여러가지 패턴을 소유할 수 있음. 분산되어있는 컴포짓패턴 -&gt; 다음장에 바로 컴포짓패턴의 3가지 역할을 다 수행하는 컴포짓패턴을 소개함. | 디자인패턴의 다이어그램은, 객체의 역할이지 객체가 아니다. 다이어그램 갯수만큼 객체가 나오지 않는다. | . | 역할별로 1개의 객체로 연습 | 이후 모든 역할을 1개의 객체에 몰빵하는 연습 전략객체이자 실행객체 | 전략객체이자 상태객체 | 전략객체 소유하는 객체를 상태객체로 만들기 | . | . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/pattern/%EC%A0%95%EB%A6%AC/2022/07/31/%ED%8C%A8%ED%84%B4%EC%9D%84-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%88%9C%EC%84%9C.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/pattern/%EC%A0%95%EB%A6%AC/2022/07/31/%ED%8C%A8%ED%84%B4%EC%9D%84-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%88%9C%EC%84%9C.html",
            "date": " • Jul 31, 2022"
        }
        
    
  
    
        ,"post8": {
            "title": "CACHE 정해진 갯수의 인스턴스 캐싱 적용 정리",
            "content": "캐싱 방법 정리 . 캐싱 도입 방법 . 정팩메가 필요하다 | static컬렉션(hashMap) CACHE (기존 생성자파라미터를 key, 객체를value로 하는 Type)를 필드초기화하고 갯수가 정해져있으니 capacity를 기입해서 빈컬렉션 초기화 | 만약, 기본생성자로 들어더온 데이터가 2개이상이면, 1개의 key로 만들기 위해 innter KeyClass도입 or string으로 연결한다. | . | static정팩메에서 if 없으면 생성해서 넣어주고 , 있으면 get을 요청한다 computeIfAbsent(key, 가상인자람다식으로 value생성(객체생성)) | java라면 computeIfAbsent를 활용하되 Funtional이 기본이므로 객체생성자 호출시 ignored -&gt; 를 활용한다 | . | 미리 static블럭에서 static변수들(캐싱변수도)을 초기화해서 캐싱할 객체들을 미리 생성할 수 있음. | 여러쓰레드에서 입력할 가능성이 있다면, ConcurrentHashMap으로 캐싱static 변수를 초기화한다. | . 정팩메로 1개 input에 대한 캐싱객체 생성방법 . 정적팩토리메서드로 class를 객체찍는템플릿에서 능동적인 객체관리자로 승격시킨다. . new 생성자 : 100% 객체를 생성해야함(캐싱못함) | 정펙매 캐싱(재사용) 가능해짐.ㅁ | . | . | 인자의 갯수에 따라 .of or from으로 public static 메서드를 생성한다. . | 기존 생성자와 동일한 형으로 key / 재사용할 객체형을 value로 해서 HashMap을 만든다. / 캐싱할 인스턴스 객체수를 알고 있다면 capacity를 저적어준다. . 변수는 static변수로서 상수의 map으로서 jvm돌때 미리 생성된다. | . . . | 캐싱의 핵심은, 존재하면 map에서 get으로 꺼내고, 없으면 생성이다 . map의 초기화도 미리 이루어진다. | . . . | 없으면 key-value 넣어주기, 있으면 꺼내기는 map.computeIfAbsent( key, 람다식으로 value생성식)을 넣어주면 된다. . 람다식은 가상인자로 작성해야해서, key값을 그대로 넣어주면 에러남. | . . . | 정적팩토리메서드가 완성되었으면, 기본생성자는 private으로 막아두고 각종 검증방법은 정팩메로 이동시킨다. . . . | 기존 new때려서 생성한 객체들을 of로 다 수정해준다. . . | 캐싱의 테스트는 식별자 일치를 확인하는 .isSameAs를 사용해서 테스트한다. . . . | 여러 쓰레드에서 접근한다면, 미리 모두 static생성 + ConcurrentHashMap으로 변경하고 getter만 하게 한다. . static 컬렉션 변수의 요소들은 staitc블록으로 요소들 미리 생성하게 할 수있다. | static블럭이 늘어나면, 해석하는데 힘이쓰여 좋지 않ㄴ다. | . . . | 정팩메로 2개 이상 input에 대한 캐싱객체 생성방법 . 컴퓨터내부에서 로직의 시작인 card 2개가 주어진다면, 정제된input이라 생각하고 카드부터 만든다. . 제한된 종류의 값 = 상수묶음은 enum으로 만들어서 카드를 만든다. | 테스트메서드명은 인자 -&gt; 1case 가 결정한다. | . . | 4 x 13 종류의 객체는 캐싱이 가능하다. . 캐싱을 적용하려면 일단 생성자 인자 그대로 정팩메로 만들고, 기본생성자는 private해준다 | . . . | 원래는 기본생성자의 1개 인자에 대해 hashMap&lt;생성자인자, 객체&gt;형으로 static CACHE map을 만들어야하지만, 파라미터가 2개일경우, 1개로 합친 Key를 만들어야한다. . 2개이상의 정보를 묶은 class를 만들어도 되지만, string을 이용해서 합쳐 1개의 key로 만들어 &lt;String, 객체&gt;형을 많이 사용한다. | 캐쉬의 기본공식은 꺼내서 없으면 put해주고, return get을 반환이다. | . . . | 테스트메서드명도 함수를 from or of의 정펙메로 바꿔주고, isSameAs로 테스트한다. . . | java의 기능으로서 없으면 key에 대한 value를 생성해주고 있으면 반환하는 computeIfAbsent를 사용해서 리팩토링한다. . 또한 캐싱될 객체의 수를 알고 있으면 미리 넣어줘도 된다. | . . . | CACHE대상객체는, 거의 값객체기 때문에, 값으로 비교하기 위해 eq/hC오버라이딩도 해준다. . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/lotto/cache/%EC%A0%95%EB%A6%AC/2022/07/31/%EC%BA%90%EC%8B%B1-%EC%A0%81%EC%9A%A9-%EB%B0%A9%EB%B2%95-%EC%A0%95%EB%A6%AC.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/lotto/cache/%EC%A0%95%EB%A6%AC/2022/07/31/%EC%BA%90%EC%8B%B1-%EC%A0%81%EC%9A%A9-%EB%B0%A9%EB%B2%95-%EC%A0%95%EB%A6%AC.html",
            "date": " • Jul 31, 2022"
        }
        
    
  
    
        ,"post9": {
            "title": "불변 일급컬렉션(invariant first class collection) 정리",
            "content": "불변 일급컬렉션의 장점 . 호출시 복사된 새 객체를 제공해주니 DTO처럼 view에 막 던져도 안정적이다 건들이고 싶어도 기존 객체는 불변이라 못건들이게 되니 | view에서도 복사된 가변 새컬렉션을 새 객체로 넘겨주면 된다. | . | 불변객체를 map의 key로 사용하게 될 경우 식별자 변경의 문제가 발생하지 않는다. key로 사용하는 객체는 불변객체여야한다. | . | 도중에 실패하는 경우, 일부만 달라질 수 있다. 기존 객체는 불변을 유지하게 해줘서 그런 문제(실패 원자성)를 막자. | . | . 불변 일급컬렉션을 만드는 과정 . 멋도 모르고 컬렉션&lt;단일객체&gt;을 생성자에 통채로 집어넣어 만든 일급컬렉션은 사실 상태 변화(setter/add 등) -&gt; [변화된 상태의 새 객체]를 생성해서 반환하기 위해 생겨난 생성자임을 생각해야한다. | . 단일객체에 대한 복수형으로 final 불변의 일급컬렉션 클래스를 생성하고, Set으로 단일객체를 보유할 빈 컬렉션을 조합한 필드를 가지고 있는다. . . . | 필드에 대해서 setter(상태변화) / getter를 고민해야한다. . 단일객체가 외부에서 변수로 받아져 조작되는 객체라면, 객체 자체를 파라미터로 받는 setter로 만든다. | 컬렉션에 대한 setter는 add/remve등이다. add로 단일객체 파라미터를 받되 | 상태변화의 setter(add)는 상태변화된 새 객체를 반환하여 불변성을 유지한다. | . . . 2번에서 상태변화된 컬렉션으로 새 객체 생성해서 반환을 하기 위해컬렉션을 통째로 받아 생성하는 생성자가 필요했음을 생각한다. | 즉, 필요에 의해 객체컬렉션을 받는 생성자가 생겼음을 인지한다. | | 컬렉션 필드의 상태변화는 기존 컬렉션필드가 변하지 않도록 사본으로 복사한 다음 상태변화시킨 후 새객체 생성을 해줘야한다. . 컬렉션필드를 수정할 땐, 항상 사본복사후 연산하자. 생성자를 통한 복사는 객체요소는 같은 주소를 바라봐서 요소변화가 가능한상태로 복사이다. | . | . . . | 기본생성자외 컬렉션 필드의 생성자가 생성되는 순간, 빈컬렉션의 필드초기화는 의미가 없어진다. 최초의 시작은 빈컬렉션으로 될 수 있도록 부생성자로서 추가해줘야한다. . . . | 파라미터가 없는 생성자는 부생성자이므로 파라미터가 있는 주생성자를 this로 사용해줘야한다. . . . | 불변의 일급컬렉션에 요소를 add하는 과정은 매번 재할당해줘야한다. . 불변 객체를 받는 변수는 재할당이 운명이다. . | 일급컬렉션은 getter().size()가 아니라 .size()메서드를 정의해서 쓴다. . | . . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/lotto/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%EC%A0%95%EB%A6%AC/invariant/2022/07/31/%EB%B6%88%EB%B3%80-%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98-%EB%A7%8C%EB%93%A4%EA%B8%B0.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/lotto/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%EC%A0%95%EB%A6%AC/invariant/2022/07/31/%EB%B6%88%EB%B3%80-%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98-%EB%A7%8C%EB%93%A4%EA%B8%B0.html",
            "date": " • Jul 31, 2022"
        }
        
    
  
    
        ,"post10": {
            "title": "menu2를 만들며 익히는 command, memento 패턴",
            "content": "menu를 만들며 익히는 command, memento 패턴 . composite패턴, visitor패턴 적용 | 시작 깃헙 | . Command패턴 적용하기 . 커맨드 인터페이스에서 역할(execute, undo)부터 정의하고, 기능위임한 객체는 파라미터로 받는다. . 인터페이스를 만들고 2가지 기본역할을 만든다. . void execute . | void undo . . | | 행위를 위임하여 캡슐화할 객체를 메서드인자로 받아서 내부에서 실행시킨다. . task객체를 직접적으로 조작하는 것이 아니라 객체 인자 -&gt; 객체 기능 자체를 포장해서 지연실행시킨다. | 객체 기능 위임 -&gt; 위임한 객체의 메서드 파라미터로 들어온다. | . . | 커맨드홀더객체 -&gt; [기능 위임받을 객체를 소유]해서 래핑하는 구상클래스를 만들며, [모든 기능을 래핑]하기 위해, 위임객체Composite의 내장을 다 복사해온다. . 상속없이 특정객체의 기능을 위임하려면, 필드로 소유 -&gt; 내장복사 -&gt; 래핑하는 방법 밖이다 . 커맨드홀더 객체는 기능위임객체를 소유해서 래핑하고 있다. . | 모든 기능을 위임받기 위해, 소유객체의 내장을 모두 복사해서 가져온다. . . | 소유객체 기능복사후 내장을 정리한다 . 01 소유객체 기능 래핑을 위한 내장복사후 [필드는 소유객체 빼고 다 삭제] + [생성자 이름 수정]부터 한다. . . . 02 기능의 command화 대상들인 [상태변화 set계열] 메서드들은 일단 두고, [getter계열만 소유객체를 통해 래핑]한다. . getter는 제공기능이므로, 행위가 아니다. -&gt; 행위를 캡슐화하여 지연실행하는 커맨드객체 대상이 아니다 . 어떤 객체에 대해 상속없이 기능 위임하는 방법은 소유한 뒤, 래핑하면서 위임하는 방법밖이다. | return 필드 -&gt; return 소유객체.get필드() | getter가 파라미터가 있다면 -&gt; 소유객체.getter(파라미터)를 넣어주면 된다. . | getter내부가 복잡해도, 해당 메서드이이름만 보고 -&gt; 소유객체.해당메서드()로 만들자. . . ​ . | . . getter래핑이 끝나면, 맨 밑으로 내려놓자 . . | . 커맨드화 대상인 setter계열 메서드의 [실행시점] 위임하기 . 새로운 객체인 command객체를 만들고, 커맨드홀더 객체가 [소유객체 래핑해서 실행]하는 책임을, 다시 한번 [커맨드객체에서 실행]하도록 [실행시점]을 위임한다 . 01 execute와 undo가 같아 제일 쉬운 set계열 toggle커맨드객체부터 만들어보자. . 소유객체의 set계열 메서드 실행의 위임받을 커맨드객체는, 커맨드 인터페이스를 구현해서 생성한다. . 정해진 메서드로만 위임할 것이다. | 특정메서드의 실행위임은 파라미터로 원래 기능객체가 가서 실행되는 것으로위임된다. . | 위임될 행위는, 파라미터로 같이 가는 이상, 해당객체.이미정해진 기능()으로 실행된다. 따라서 따로 구현하거나 하지 않는다. | . | . . . . | 커맨드홀더객체는, 소유객체의 실행을 커맨드객체에게 위임하되 [커맨드 객체 내부 생성]후 [커맨드객체 위임 실행]함으로써, [지연실행 주체인 커맨드객체 자체]를 [실행전 컬렉션 필드에 저장]할 수 있다. . undo/redo는 지연실행 주체인 [커맨드객체]를 컬렉션 필드에 저장해놓기 때문에, execute한 주체를 다시 불러와서 undo할 수 있게 된다. 커맨드홀더객체가 [커맨드객체들 외부저장소(List필드)] 역할을 한다 . 커맨드객체를 내부생성후, 실행 전 저장하는데, 컬렉션필드 생성후 한참 뒤에 add되므로 빈컬렉션 + set/add메서드가 필수다 . 이 때, Set이 아닌 List를 외부저장소로 채택하여, 차후 마지막 꺼만 or 커서도입 or 짝수만 등의 형태로 command를 뽑아 쓸 수 있게 한다 . | 외부에서 add하는게 아니라, 내부에서 요소 생성후 add하니까, setter메서드는 현재 필요없다 . . . . | . | 모든 set계열메서드들은 커맨드객체에 실행시점위임으로서 해당 커맨드객체생성 -&gt; 외부저장소에 저장 -&gt; 실행한다. 이 때, [추상체변수cmd의 add -&gt; cmd.execute]는 반복된다. 내수용 addCommand()메서드를 만들고, 반복사용하도록 하자. . 공통필드외에 추상체변수 호출의 반복 또한 반복되는 코드라서 내수용메서드로 추출해야한다. | . . . 이제부터 매 set메서드들의 커맨드화할 때마다 addCommand()를 통해 저장 + 실행까지 한다. . 커맨드 홀더 소유객체는 [메서드인자를 통한 를 기억해서 사용] 안해도될까? . 아래와 같이 소유객체는 호출당시 context를 안받아도 될까? . . . | . 현재 모든 set계열메서드마다 [필드소유객체 CompositeMenu]를 [호출메서드의 파라미터]가 아니라 [내부context필드로서 반복 사용]하고 있다 . . 행위 위임을 위한 메서드(위임당할 객체는 파라미터로)가 아닐 때, 파라미터로 받을 필요없이 내부context를 재활용해도 되는 객체는? [절대 상태변화가 없는 final 불변객체]만 가능하다 . 내부context라도 setter등으로 상태변화하는 객체는 상태 확인후 사용해야하지만, 상태확인 없이 내부context를 재활용해도 되는 객체는 final이 붙어서, context생성 당시, 생성자로만 받고 난 뒤, 아예 변할일이 없는 필드만 가능하다. | command홀더 클래스는, 래핑할 소유객체를 final불변으로 유지하여, 어떤 커맨드객체에서든 똑같이 작동하도록 한다 . final 필드 -&gt; 생성자 주입 받도록 수정한다. . . . | Command홀더는 소유객체를 대신해서 외부에서 생성 -&gt; 활용될 것이므로 소유객체 생성자 파라미터(값을 받아 필드 채우는)를 그대로 유지하며, 소유객체를 내부 생성한다 . command홀더객체를 도입하는 순간부터, 기존 Composite객체는 외부에서 사용안된다. command홀더내에서 소유객체composite객체를 생성한다. 생성자 내장을 그대로 활용한다 . . . 모든 상태변화메서드 setter(setTitle 등)를 커맨드화 한다 . 정해진 인터페이스의 구상클래스가 기능을 위임받을 땐, 필요한 외부정보를 메서드로부터 받지못하니, 생성자를 통한 필드로 context를 기억해놔야한다. . 02 setTitle 커맨드화 . 커맨드객체를 인터페이스 구현후 생성한다. . | 외부저장소add 후 exexcute해주는 addCommand( ) 메서드에 cmd객체를 넣어준다. . | 이 때, 오퍼레이터 execute에 필요한 외부 정보는, 구상클래스로서 생성자-&gt;필드로 기억해서 내부에서 사용한다 . . . . | undo의 비밀은? 구상 커맨드[객체]에 [메서드인자로 들어가는 실행위임]했다면, [execute직전의 context를 getter로 가져와 객체 내부필드에 저장(set)]해놓아서, [undo시 불러와 사용]하여 counter칠 수 있다. . 커맨드객체라는 새로운 구상class에 위임하게 되면, 당시context를 필드로 기억할 수 있다. . 단순 setter의 undo: execute직전에 getter를 통해 당시context를 가져와 내부필드(oldXXXX)를 이용해서 [old값으로 다시 setter]한다. . execute당시의 context를 필드에 박아 기억해둔다 . 필드명은 oldXXX로 지으면 된다. | . . . | 03 setDate 등 나머지 단순Setter 커맨드화 . setTitle클래스를 복사해서 만들면 쉽다. . | execute당시 필요한 context들은 위임객체(커맨드객체)의 생성자로 주입해서 박아둔다 . | execute직전 바뀌기 전 old context는 getter로 불러와서 필드로 주입해서 기억해놓는다. . . . | add의 undo: 원본메서드에서 컬렉션에 add된 객체를 반환하도록 해야, 저장 후 undo를 칠 수 있다. . 일단 04 add execute만들기 . 인터페이스 구현 Add 커맨드객체 생성 . | addCommand()를 태워서 외부저장소 add후 execute까지 . 기존 add메서드는 void add가 아니라 boolean add였지만, cmd.execute() 오퍼레이터는 반환값없이 다 void로 정의되어있어서 add래핑메서드는 boolean반환이 불가능해서 void로 바뀐다. . . . ​ . . | . | add의 undo는 실행 전 old값이 아닌, add될 내부생성객체가 필요하다 . . add메서드는 undo를 위해서라도 내부생성되어 내부컬렉션에 [add될 객체를 반환]를 해줘야한다. . 내부에서 생성된 후 , add되는 만큼, 해당 메서드에서 return해줘야 외부에서 가질 수 있다. . | public void add로 만드는 컬렉션setter는 undo가 불가능하다고 생각하자. . | . 원래 기능을 가지는 compositemenu의 add메서드를 add되는 객체를 반환하도록 수정한다 . | 커맨드객체는, execute시 반환되는 undo용 add된객체를 필드로 저장한다. . . . . | 저장된 add된 객체를 바탕으로 undo치면 된다. . . | remove의 undo: remove된 객체가 아니라, [remove되기 전 객체의 필드정보들]을 [getter]로 받아와야, 저장 후 add할 수 있다. . 05 remove 커맨드화 . add의 undo는 내부생성된 객체를 필요로했지만 | remove의 undo인 add는 삭제 객체의 필드정보들을 알아야 내부생성되도록 add할 수 있다. remove되면 해당 객체필드정보들을 얻을 수 없으니, execute에서 객체 삭제전, 객체필드정보들을 미리 getter로 빼놓는다. | . | . . . 생각해보기 . 커맨드객체에는 2가지 종류의 기억필드를 가진다. . 소유객체의 기능호출에 필요한 context를 생성자 -&gt; 필드로 기억한다. | execute당시의 context를 old계열필드로 기억한다. | 만약, 커맨드객체에 위임안하고 undo를 한다면? 당시의 context들을 모두 set or 배열 컬렉션으로 기억해놓고, 순서대로 가져와서 쓴다. | . | 하지만, 하나의 객체를 만들어놓고, 거기다가 기능 위임(파라미터로 원본객체)하게 되면, 객체context로서 필드에 이름으로 저장해놓고 뽑아 쓸 수 있다. | 커맨드객체로 굳이 기능(행위)를 한번 더 포장해서 써야하나? undo/redo와 지연실행 . 위에 말한 것처럼, Closure와 같이, 포장 객체 필드에 당시context를 기억할 수 있어서 undo, redo가 가능하다. | 또한, 행위 포장객체를 이용하면, 지연실행이 가능해진다 addCommand()에는 외부저장소 add + execute를 묶어놨지만 | 따로 분리하여 add따로 / execute따로 가능하다 | . | . 커맨드객체 외부저장소를 Set&lt;Command&gt;가 아닌 List&lt;Command&gt;를 쓰는 이유 . 보통 같으면 index가 없이 객체식별자로 구분하는 Set을 썼겠지만 . | List를 저장소로 채택하면 index(값context)를 이용해서 짝수만/홀수만/원하는 갯수/ 마지막꺼만 뽑아 쓸 수 있기 때문이다. . Set은 마지막꺼만 뽑아 쓸 수 없어 undo를 할수 없다 | . . | . 지연실행(포장객체에 위임)의 장점 . 지연실행이 안된다면, 여러 행위 실행시, 반복문에서 무조건 행위를 호출해야만 한다 | 지연실행 된다면, 반복문을 10번 돌더라도, 객체만 뽑아놓고, 나중에 행위호출할 수 잇께 되어, 비동기 실행이 가능해진다. | . 커맨드홀더의 undo메서드(미완성) . 지금까지는 커맨드홀더의 addCommand() -&gt; cmd객체의 execute호출만 했고, cmd객체의 undo()를 호출하지 않았다. . . addCommand와 달리 undo()는 외부저장소List의 (조회전 처럼) remove 전(pop과 동일) 존재검증을 해야한다. . undo할 게 없으면 그냥 early return하고 끝내자 (원래는 thr) | . . 원래는 list에서 stack으로 pop을 해야하지만, java에서는 pop == remove(맨 마지막index)이다. . . . . | . 커맨드홀더의 redo: undo시 외부저장소(List)에서 remove(pop)로 날리지말고 Cursor 도입 . undo만 짠다면 외부저장소(List)에서 remove(size-1)로 pop하여 쉽게 짜여지지만, | redo기능이 존재할 예정이라면, remove로 커맨드객체를 외부저장소List에서 바로 날리면 안된다. | . 외부저장소List의 index를 cursor로 도입하여, 컬렉션 요소 날리지 않고 add-execute하기 . 저장소List 필드에 대해 cursor의 위치도 항상 기억되어야하므로 cursor대상 컬렉션 밑에 int cursor필드를 추가한다. . 빈 컬렉션 시작이므로 cursor를 0으로 초기화 원래 cursor 0은, 1개 아이템이 index 0에 들어가있는 상태이다. | 원래라면 cursor를 -1 상태로 초기화해야할 것 같다 | 어차피 cursor는 add시 add-execute시 size()-1로 마지막 위치로 업데이트될 것이다. | . | cursor는 바뀌는 것이니 not final | . . | cursor는 대상컬렉션에 요소를 add할때마다 1씩 증가되어, 맨마지막 index에 위치시킨다. 컬렉션이 사용되는 곳(ctrl+F7, alt+F7, add기능이 있는 곳 등)에서 cursor도 업데이트 로직을 추가한다. . ctrl + F7로 컬렉션변수가 사용된 곳을 다 찾는다. . . | add면 add전 cursor++, remove면 remove전 cusror--;업데이트를 해준다. . . . . | 상태변화하는 컬렉션의 cursor(variant변수)를 직접 상태변화하지말고, 이미 변화한 연결 variant 필드(컬렉션)의 api를 이용한 불변식으로 관리해라 . 직접 ++으로 업데이트하면, 틀림없이 오류가 생긴다. | 상태변화 필연시 되는 variant 필드는, 원치않는 상태를 방지하는 불변식을 찾아서 불변식으로 재할당하여 업데이트해야한다 List의 index는 제한범위가 있다. 직접 업데이트해서 if로 검사하지말고, 불변식을 찾아서 그것으로관리해야한다. | . | . add시 cursor를 마지막index로 업데이트는, add전에 하지말고, add후 바뀐 컬렉션으로 불변식을 만들어서 한다. . 앞으로 cursor의 업데이트는 add후 한다. add후에 컬렉션.size() - 1을 이용해 제일 마지막 index를 가리키게 한다. | . | . . . cmd외부저장소 List는 stack(역할)으로서 방금 add-execute한 커맨드객체가 [현재cursor + 1] 위치에 있어야한다. 그래야 undo(cursor-1)시 원래자리를 찾아올 수 있게 된다. . add후 cursor를 컬렉션api로 마지막위치로 업데이트하는 상황에서, add-execute하여 List에 add될 객체가 [현재cursor+1]위치에 이어야한다. -&gt; add전, [cursor+1~마지막]요소들을 remove해서 날려놔야, add후 size()-1이 마지막위치가 된다. . . 뒤로 이동했을 cursor의 위치에서, 마지막부터 ~ cursor+1까지 돌면서, remove로 날린다. . . . | 커맨드 홀더의 undo의 remove를 제거하기 위해 업데이트 . undo에서 삭제 전 컬렉션 존재검증 -&gt; 더이상 컬렉션 요소를 삭제하지 않으니, cursor로 검증(cursor 0은 undo시킬 cmd객체가 있는 상황) . undo할 요소가 컬렉션에 있는지 . (기존) add/remove로 관리었다면 -&gt; .size() == 0 or .isEmpty() . . | (현재) 요소remove없이 cursor로 뒤로 이동만 함 -&gt; cursor 0이 첫 요소에 cmd객체가 undo할 것이 남아있는 상황 -&gt; cursor가 0보다 작으면 요소가 없는 상황 . cursor0에서 뒤로 가면, 데이터가 없는 상황이다. | cursor0은 첫 원소가 있는 위치다 | . | . . | undo는 (pop==remove(size-1) 대신) 현재cursor의 외부저장소cmd객체를 가져온 뒤, cursor는 한칸 뒤로 이동시켜야한다 . 기존에는 remove로 pop해와서 썼는데, 지금은 현재커서 위치 갖다쓰고, 컬렉션은 유지하고 커서만 이동시킨다. . . . | 사용후 1씩 업데이트라면, java에서는 메서드(변수사용--) 이나 메서드(변수++)형태로 단일연산자로 처리할 수 있다. . . | 트랜잭션일어날 일이 아니면 지역변수 쿠션을 안준다. . 단항연산자는 앞에 붙을때만 업데이트되서 사용되고, 뒤에 붙으면 사용후 업데이트 된다. | 단항연산자 사용변수 이후 체이닝메서드는 이미 업데이트된 변수 상태니, 사용시 주의하자 | 트랜잭션을 만드는 메서드 체이닝시 단항연산자를 사용해서, 중간에 다른 사용 못하게 하자 | . . | redo 구현 . (이론) redo는 [커서만 빽한 undo상태가 대상]이며 cursor + 1 위치로 가서 꺼내서 execute하는 것이다. . . (이론) undo의 대상과 redo의 대상 . undo의 대상: 현재 execute하여 stack에 add된 cmd객체 add-execute시, cursor도 맨 마지막으로 업데이트 된 상태가 되도록 로직이 짜여져있다. | 현재 cursor의 cmd객체를 가져와서 .undo만 치면 된다. | . | redo의 대상: 현재 undo하여 stack상 cursor가 -1 빽한 상태이며, cursor한칸 앞의 cmd객체 cursor를 +1 해준 뒤, 그곳의 객체를 execute해주는 것이 redo | cursor가 add-execute의 대상cmd객체에 위치하고 있으니, 다시 undo가 가능하다 | . | execute는 처음 add-execute든, redo든, 방금 시행한 객체를 가리키고 있어야 undo가 가능해진다. | . 구현1 - redo전 cursor invariant검사로, [redo할게 없는 상황이면 종료] (cursor한칸 앞으로 못감 == undo안한상황 == add-execute만 한 상황 == cursor가 제일 마지막에 위치) . cursor가 undo를 하지 않은 상태면, redo가 안된다. . redo는 undo한 상태에서 cursor를 다시 +1 한 뒤, execute하는 것인데 | cursor가 List 맨 마지막에 위치한 상태(undo안하고 add-execute만 한 상황)이면 redo는 불가능하다. | . . . | 진해서 두고, 그 놈을 한번 더 execute하는 것이다. . 만약, 먼저 업데이트되서 쓴다고 하면, ++변수 단항연산자를 메서드 인자로 쓰면 된다. . . . . | . addCommand/ undo/ redo with cursor -&gt; 객체소유 커맨드홀더객체 완성 -&gt; 커맨드패턴 완성 -&gt; undo/reo하며 출력 . Main에서 Composite객체(소유객체) 대신 Command홀더객체를 사용해보자. . 더이상 소유된 composite객체는 외부에서 사용하지 않는다. Command홀더객체가 생성자에서 재료만 받아 내부생성했다 . Main에 있는 CompositeMenu -&gt; CommandMenu로 변경하자 . ctrl + F7로 사용 context들을 표시하고 시작하면 편할 것이다. | . . . | . root에 menu에만 add할게 아니라, 자식menu을 먼저 미리 생성(자식에 자식 미리 추가)한 것도 add하려면, 자식 menu를 지역변수로 받아서 생성해놓고, [root에 미리 생성된 menu도 add가능하도록 수정]해야한다 . 현재는 root menu의 정보 -&gt; root생성 | root의 1차 자식의 menu정보 -&gt; root 1차 자식들 add만 할 수 있는 상황 | . | 정보를 통한 add 이외에 외부에서 미리 생성된 CommandMenu를 add할 수 있도록 메서드를 추가해보자. 문제점이 발견된다. | . | . 기존의, 정보를 통한 소유객체 내부생성 Add커맨드객체는, 이미 생성된 Menu객체와 전혀 다른 context -&gt; 생성자-필드가 다름 -&gt; 새로운 커맨드객체가 필요하다 . 일단, 외부에서 Composite객체 대신, Command홀더객체로 만든 것을 add해보면, 기존 커맨드객체가 instance context로서 기억하는, 당시context == 필드가 달라진다. . | 기존 필드들을 초기화할 수 없어서 생성자 및 필드에 불이 들어오게 된다. . . | 억지로 필드에 기억했다고 치더라도 execute시에도 다른 메서드를 호출해야해서 곤란하다 . . | 게다가 커맨드홀더는 포장객체일 뿐, 내부 자식들은 Composite객체(소유객체)형으로 자식들이 추가된다. . 메서드 파라미터가 달라지면, 행위위임받은 커맨드객체는, 메서드처럼 오버로딩해서 재활용못한다 | . . | 파라미터만 다르더라도 새 커맨드객체 생성 . 행위위임 커맨드객체는, 커맨드호출 서비스메서드의 파라미터가 달라지면, 커맨드객체의 기억필드가 달라져서 [메서드 오버로딩처럼]재활용 못하니, 새 커맨드객체를 생성해서 위임해야한다. . add시 정보 -&gt; 내부compoiste객체 생성 형태가 아니라 add시 이미 완성된 command객체로서 파라미터가 달라졌다면, 새롭게 커맨드객체를 만들어야한다. . . . . | 위임해줬던 Composite객체는, 커맨드객체 내부에서 지연실행 될 때, 완성된 커맨드객체가 아닌, 자신형을 자식으로 add한다 . . | 커맨드홀더객체로부터 소유객체 getter를 만들어준다. . Add과정과 동일하게 처리해준다. | . . . | 출력은 Command홀더객체(root) -&gt; report생성 -&gt; Renderer with Visitor -&gt; ConsoleVisitor로 출력이다. . 제어는 Renderer가, 제어를 타는 것은 특정 Visitor들을 미리 생성자 주입 . 제어타면서 행위를 할 객체를 Renderer에게 건네주면, 내부에서 Visitor에게 파라미터로 객체를 넘겨, Visitor에게 위임한다 . 출력은 ConsoleVisitor를 주입해서 만든 Renderer로 한다. . 어차피 Visitor는 Renderer내부 (지연)생성이니, Render의 메서드에게 재료객체Report를 던져줘서 호출한다. | . . . | 생각해보기 . 소유객체는 undo에서 remove하기 위해, add시 add되는 객체를 return해서 필드로 저장 / 커맨드홀더객체의 add는 return없는 void . CommandMenu . . . | CompositeMenu . . | **커맨드홀더객체의 add는 원래 return이 없다 ** . 소유객체를 지연실행시키기 위해 add동작이 구상 커맨드객체 내부에서 소유객체의 add가 실행된다. | 커맨드객체에 위임한 뒤, 커맨드객체를 필요할 때 지연실행 시킬 수 있어야, 실행 전 외부저장소에 저장해놓고 실행할 수 있기 때문에, 최종 소유객체의 add가 미리 실행되서 return되면 안된다. 바로 실행한다면 무조건 동기적인 실행이며, undo/redo를 못한다. | . | . | . 커맨드객체에 지연실행을 위임함으로써, 실행 시 aggregation필드(외부저장소List)에 저장해놓을 수 있으며, 다시 반복실행, undo실행, redo 등을 저장소에서 꺼내서 한다 . . 오타 수정 . CompositeMenu의 remove에서 존재검증시 !느낌표 하나 빠짐 . . Composite객체 -&gt; Command객체 사용전환 완료됨 -&gt; 커맨드홀더객체(커맨드패턴)만의 undo/redo를 사용해보자. . 포장한 커맨드홀더객체를 만든 이유는, 내부에 커맨드객체 외부저장소(aggregation)를 가져서 undo/redo를 하기 위함. | . 커맨드홀더객체.undo()는 커맨드홀더객체 어느행위 든(addMenu, setTitle 등) 직전 행동에 대해 카운터를 친다. . undo는 해당 Command홀더객체의 최근행동에 1개씩 적용된다. . . | . redo는 직전의 undo에 대해서 카운터를 친다 . . 잘 작동한다 . . 생각해보기 . public 서비스메서드 with private 도메인객체 파라미터 메서드 -&gt; 도메인객체 generator 서비스메서드 . 커맨드홀더객체의 소유객체 래핑 set계열메서드들은 다 [addCommand(해당 커맨드객체) 를 호출하는 래핑된 서비스 메서드]들이다 . 전부다 내부에서 execute-add하는 addCommand(new 커맨드객체())만 호출한다. . . | . 래핑을 풀고 private addCommand메서드 만 public으로 공개하면 처리 가능하지만, 외부에서 직접 커맨드객체를 new때려서 생성해서 넣어줘야한다. -&gt; 차라리 서비스메서드를 제공하고 커맨드 홀더객체 내부에 private generator로 생성하는게 낫다 . 가정 . . | . 객체 파라미터를 public으로 공개한다는 것은, 외부에서 생성한 뒤 받겠다는 말인데, 도메인을 보호하자. -&gt; public메서드의 객체 파라미터는 최대한 피하자 -&gt; 서비스 메서드를 제공하자 . . 커맨드패턴(커맨드홀더객체)을 쓰면 좋은 점(지연실행으로 인한 외부저장소 -&gt; undo/redo 장점 외) . composite객체가 제공하던 모든 메서드들 -&gt; command홀더객체는 사실상 외부에 public addCommand(execute+add)만 제공 + 구상 커맨드객체만 외부에서 입력해주면, 그외 메서드는 없어도 된다.(편의상 커맨드객체별 서비스메서드로 제공 중) . 행위(compositeMenu)를 구상클래스(command객체들)에 위임한다 -&gt; 행위객체를 소유하는 홀더객체(포장객체, commandMenu)는 위임된 구상클래스를 인자로 받는 메서드 1개(addCommand())만 가지면 된다. | . 실시간, 실행(런타임) 중 상태변경은 커맨드객체가 최고다. 커맨드홀더 + addCommand( 원하는 상태변경 커맨드객체 ) ex&gt; 홈페이지 빌더 . 이렇게 되면, 컴파일 타임에는 메서드가 없고, 런타임에 위임받은 구상클래스만 원할때마다 동적으로 바꿔서 넣어주면 기능이 작동한다 . | 즉, 커맨드홀더객체만 가진 상태로 + 관련 구상 커맨드객체만 받으면, 원하는 기능을 수행하게 된다. . 잠시 서비스 메서드들 없다고 가정하고 addCommand를 public으로 풀어놓은 상태 | 버튼 클릭시, 해당 구상체만 addCommand해주면 원하는 상태가 된다. | . . homepage 빌더들은 해당 요소클릭시, 해당하는 커맨드객체만 add-execute해준다 | . | . 즉 범용 커맨드홀더객체 + 차이점을 만드는 구상커맨드객체들을 소유하고 있으면, 객체간 차이를 런타임에서 실시간으로 만들어낼 수 있다. . 커맨드홀더객체 내 서비스메서드들(addCommand래핑)이외에 메서드들(get계열) 의존성을 가진 것으로, 소유객체가 변하면 같이 죽는다. 하지만, 서비스메서드들은 이미 죽은상태의 메서드들이라 의존성없이 좋은 메서드들임 . . 커맨드패턴이 무적같지만.. save와 load가 안된다. save와 load를 하려면, [시리얼라이제이션을 통한 영속화]를 따로 해야한다. . 메멘토 패턴 save with Visitor패턴 . 커맨드홀더객체는 소유객체(Composite객체)의 메멘토(상태정보)를 관리하는 CareTaker역할을 하여 저장컬렉션 필드를 가진다. . 고전에는 Stack으로 관리하지만, 여기서는 Map으로 한다. map의 key는 주로 string으로 받는다. save는 json으로 저장될 메멘토라서 string으로 저장한다. . . 메멘토 관리자 커맨드홀더는, save와 load함수를 가지며, void save, String load 시그니쳐부터 작성한다. . save시 저장할 string key를 외부에서 받고, load로 꺼낼 때도 key를 받는다. . . Save는 Renderer와 JsonVisitor를 활용해서 만든다. . 제어역전한 Renderer, 생성자주입되어 제어를 타는 전략객체 Visitor, 메서드인자로 들어가는 데이터객체(Composite-&gt;report)의 역할을 변경해야한다 . 실질적으로 전략 중 하나로서 Composite객체를 메서드 인자로받아, Renderer부터 Composite객체 제어로직을 위임받은 JsonVisitor의 역할이 . 현재는 Composite객체의 데이터를 json형태로 만들어서, 콘솔에 출력하는 상황이다. . . . | 출력이 아니라 string으로 모아서 반환해주도록 변경해야한다 . | . | 최종적으로 Renderer가 render함수를 통해 데이터 객체의 제어 처리하므로 JsonVisitor를 태운 renderer는 출력이 아닌 데이터객체 + 제어 시 string을 모아서 반환하게 하고, 이것을 이용해 save해야한다 . ConsoleVisitor만, 데이터객체를 제어를 태우면서 출력 . . | JsonVisitor는, 데이터객체를 제어를 태우면서 String반환 . | . | Renderer는 [제어만 역전해서 visitor에게 제어로직을 위임해주는 void메서드]만 제공한다. 뭔가를 반환안해준다. . . 전략Visitor들은, Renderer(제어역전)클래스에 주입되서, 데이터객체를 메서드인자로 위임받아, 자기 전략메서드들에서 사용하지만, [제어처리 전략메서드들도 다 void]이다. 뭔가를 반환안해준다 . Renderer속 Visitor . . | Visitor인터페이스 . . | . 출력관련 제어역전Renderer와, Visitor 전략오퍼레이터들은 모두 void로 정의해놓고, [구상 전략객체들이 데이터+출력 제어로직을 담당]한다 . . 구상 Visitor들은 [위임받은 데이터 객체를 처리]할 때, [싸이클을 타면서 처리한 정보를, 구상 객체context로서 필드에 저장]해놨다가, [차후 getter로 제공]해줄 수 있다. . 출력, rendering관련 제어로직들은 다 void로 시작한다. Visitor가 싸이클을 타면서, 처리된 정보를 [구상 Vsititor전략객체마다 저장하고 싶은 데이터개체 처리정보는 상태값으로 저장]으로 일단 저장해서 품고 있자!! . JsonVisitor에 제어 라이프싸이클을 타는 메서드들의 처리결과를 모을 수 있는 상태 필드를 추가하자 . . | 더이상 출력하지 않으므로, sout 와 padding부분을 삭제한다. . json을 출력안한다면, 공백문자열인 padding을 삭제해줘야한다. . | padding 관련 삭제 . . . | . | sout삭제하고 Visitor의 상태값에 다가 stirng add로 모으기 . Visitor의 저장상태값은 final이면 안되겠구나! 사이클타면서 계속 저장 . . | . | factory에 ( () -&gt; new객체) 지연생성 vs ( () -&gt; 외부생성객체 로컬변수) 이미 생성된 객체 주입 . . my) 함수형 인터페이스 factory(지연생성)으로 주입하는 이유는 [가상인자 람다식을 통한 구현]시 [new 때리는 것을 넣어 지연생성]할 수도 있지만, [이미 외부에서 생성된 객체를 주입]도 선택가능하기 때문이다. . 상태값을 가지는 Visitor는 더이상 [Reneder 속 factory로 주입 -&gt; 내부에서 new때려서 생성 후 처리하고 소멸]해서는 안된다. . save에 필요한 정보를 이미 생성한 JsonVisitor가 renderer의 싸이클을 타고와서 getter로 제공해줄 것이다. . JsonVisitor는 상태값을 가지는 순간부터, [외부 미리 생성 -&gt; 싸이클 태워 상태값에 정보채우기 -&gt; 외부에서 getter로 채운 데이터 사용]이 가능하다 | . renderer + jsonvisitor를 커맨드홀더객체 속 메멘토 save메서드로 가져와 정보, 싸이클태워, 출력대신 상태값 저장된 정보를 getter로 제공해준다. . Main에서 출력에 사용됬던 Renderer + Visitor 사용코드를 CommandMenu#save메서드로 가져온다 . . . Renderer와 Visitor는 이제 커맨드홀더객체의 내부생성 의존도를 가지게 된다. | . | JsonVistor를 Renderer에 주입해서 싸이클을 태우도록 변경한 뒤, Renderer 내부 지연생성이 아니라, 외부에서 미리 생성된 jsonVisitor를 지역변수로 빼서, 넣어준다. . . . | 참고) 지연실행을 위한 람다식 속 지역변수는 inline하면 안된다! . 람다식에서 생성식이 있다? -&gt; 지연실행이 -&gt; 지연생성이다. -&gt; 지연생성은 내부생성이며 -&gt; 내부에서 소멸되는 상태값 정보가 외부에서 필요없는 유틸성 메서드만 가진다 | **람다식에 이미 생성된 객체를 넣어준다? -&gt; ** **구상체 중 지연생성 == 내부생성하는 유틸성, 상태값없는 객체도 있지만, ** | 다른 구상체는 외부에서 미리 생성해서 내부에서 처리되며, 상태값에 정보를 저장하는 과정을 거치게 된다. 이것을 인라인해버리면… 내부생성으로 바뀐다. | . | . | . 참고2) 커맨드홀더객체는 Main에서 생성한 [컴포짓 root객체]를 소유한다. 그래서 save속 renderer에 필요한 report를 만들 때, root인 소유객체필드(Composite필드)로 만든다. . Main 속 root 객체 -&gt; report생성 -&gt; renderer가 태움 . . | save 속 compoiste소유객체 -&gt; report 생성에 사용 -&gt; renderer에 사용 . . | . my) 지연생성은 내부에서 new때려서 생성하는 것과 동일하다. 상태값 없는 불변객체 생성시 이렇게 한다. 그러나 어떤 구상체는 상태값을 가지고, 내부에서 처리된 후 [변경된 상태] == [새로운 정보]를 외부에 제공할 수 도 있다. [지연생성 람다식에 -&gt; 이미 생성된 객체]를 넣어줘서, 내부로직이 끝난 후에도 정보가 외부지역변수 속 객체는 정보를 가지고 있게 된다. . 외부미리 생성된 뒤, 싸이클을 타는 Visitor객체는 싸이클을타며 저장한 상태필드 속 정보를 getter로 제공해줘야한다. . . . . save내부 json만드는 일을 메서드추출하여 리팩토링하고, json만드는 일을 테스트하자 . 내수용 메서드추출시, 내부context가 불변객체면 파라미터로 안빼도 된다. . 메서드 추출시 내부context(보라색)이 불변 필드면, 굳이 파라미터로 추출안해도 된다! . 만약, 다른객체에 위임할 예정이라면, 파라미터로 올려줘야한다. | . . . | . create json하는 일은 private내수용메서드다. 테스트는 그대로 복사해가서 하고 지운다 . 테스트는 작성안하는 중이니 Main으로 복사해놓고 . static을 붙이고 | 필요한 context는 파라미터로 빼서, main내에서 공급받아 테스트한다 | json출력을 확인하려면, .json파일을 만들어서, 자동정렬시켜보면 된다. | . . . . | . 생각해보기 . memento패턴은, visitor패턴이 이미 구현되어있으면 쉽게 구현가능하다 . Visitor패턴으로 데이터객체의 정보처리를 Visitor의 상태값에 저장한다. . Visitor는 출력관련 제어로직을 역전시킨 Renderer클래스에 주입되어 | 출력관련 라이프싸이클을 타면서 | 데이터객체를 인자로 받아 라이프싸이클 메서드 내부에서 제어로직을 처리한다 | 제어로직 처리가 출력 or 데이터를 모으는 과정이라면, 메서드마다 처리내용을 상태값에 저장해놓으면 된다. | 한번 타고온 외부생성Visitor는 상태값에 가진 정보를 getter로 토해낸다 | . . | Visitor가 Memento정보를 내부 상태값으로 가지고 있는 것이므로, 데이터객체 홀더 객체(커맨드홀더객체) 내부에 save, load를 구현하는데, save메서드에서 데이터객체 인자 + Visitor 생성자주입으로 라이프싸이클 태우고 나온 Visitor의 상태값을 그대로 받아서, save할 컬렉션에 저장한다. . . | 메멘토 패턴 load 구현(jsonString -&gt; root부터 자신setter + 자식동적트리순회 -&gt; composite객체 만들기) . load는 조회이므로, [존재검증 -&gt; 조회 -&gt; 가져온 데이터의 postcondition검사]까지 동시에 한다. . . . 오타수정 . . | . load시 컴포짓객체의 생성은 커맨드홀드가 소유한 필드객체(root Composite)을 재활용해서 한다. . 재활용하는 composite root 객체는 자식들을 먼저 비워야한다. 이 때, 자식들도 자신내부의 자식들을 비워야하니, [재귀 -&gt; 동적트리순회를 통한 삭제]를 해야한다. . 재활용할 커맨드홀더객체 내부필드인 root composite객체에게 자식들을 삭제하라는 메세지를 보낸다. . Composite객체 내부에서 자식컬렉션을 지우는 작업이 이루어진다. | 자신을 비우는 것은, 생성시 setter를 사용할 예정이므로 안해도 된다. | . . | composite객체의 자식들 삭제는 [자식의 자식들도 삭제되거야하는 동적트리 순회] -&gt; 재귀메서드가 된다. . 외부에서 자식들 지우라고 메세지를 보냈지만, 자식들의 자식들도 지워져야하므로 composite객체의 삭제역시, 동적트리순회를 통한 삭제 -&gt; 재귀메서드이다. . . | [동적트리삭제] 재귀메서드의 종착역으로서, [삭제할 자식들이 없으면 ealry return]으로 종료한다. (삭제 전 존재검증은 thr, [없을 수 도 있는 것의 삭제]는 early return이다. ) . . . 자식들 삭제를 위한 재귀에서, [자신의 처리] -&gt; [자식들 처리]의 호출만되고 삭제로직은 아직 없다. . . | . [자식들의 동적트리삭제]는 자신의 차례에서 [자식들삭제 로직]을 넣어줘야한다. [자식들을 동적트리순회하면서, 호출하고 난 다음] -&gt; 끝처리로서 [자식들 컬렉션필드를 .clear()] 해준다 . 자식들에게 피드백받는 재귀처리는, 자식들을 살려놓고 돌린상태의 [동적트리 or 자식재귀호출 1~여러개 호출]이 끝난 상태에서, [끝처리로 자식들을 처리]한다 . . 리팩토링 -&gt; load + 자식들처리에서 load로직을 1개 메서드로 추출 . 할당문이 포함된 로직에서, 아직 할당된 지역변수가 뒤에 쓰이지 않았다면, return없이 추출된다. -&gt; 뒤에 억지로라도 써놓고 추출하면 편하다 . 참고) 할당문 추출시, 뒤에 쓰이지도 않았는데, return한다? 반복문 내 업데이트변수를 포함한 추출이다 -&gt; 어차피 외부에서 업데이트될테니, 가변변수 빼고 추출할 수 있도록 해보자. | . . . . json String을 cursor도입하여 다음depth로 이동하면서 Composite객체 재생성하기 . load메서드내 json(string) 파싱하는 복잡한 작업이 시작된다. 디버깅하면서 내부로직을 만들기 위해 load한 json을 반환하도록 수정한 뒤, 테스트에서 환경을 조성해 만들어나가자 . . . . . 최소한 자식을 가지는 예제 json String을 만들어둔다. . . . 커맨드홀더객체 내, root자신부터 만들기 위해 데이터 추출 by target String + .indexOf() + cursor + .substring . 01 찾고싶은 string속 data의 직전 string을 target변수로 추출한다 (예제 jsonstring 복붙활용) . title의 데이터를 찾기 위해 데이터 직전까지 중에 타겟string title: &quot;을 잡는다 | . . . 02 cursor을 0으로 초기화하고, index.Of( string타겟, 시작index)에 쓰일 [데이터추출시마다 업데이트되는 검색 시작인덱스]로 사용한다 . . 03 .indexOf( target[데이터직전까지의 문자열], cursor[검색시작인덱스] )을 통해 -&gt; target start index를 찾는다. -&gt; 못찾는 경우 -1을 반환하며, 그 때 cursor도 -1으로 업데이트한다 . . . 04 target start index + target.length() 로 cursor 업데이트하여 -&gt; cursor가 데이터시작점에 오도록 위치시킨다. . . 05 data의 끝을 알려주는 target인 &quot;를 cursor(데이터시작) + 1부터 .indexOf( , )로 찾아, data끝 + 1위치를 찾는다. . . 06 data시작(cursor) ~ data끝+1 까지를 substring을 통해, data만 추출한다 . . title에 해당하는 데이터만 잘 추출되는지 확인한다. . . | . 07 data를 추출할 때까지, cursor의 움직임을 관찰하고, 다음 target도 찾아본다. . . cursor 0 -&gt; data시작위치로 업데이트된다 | 다음은 직전data시작위치 -&gt; 다음data시작위치로 업데이트 될 것이다. | . 08 [가변변수 cursor 초기화]와 [변수 초기화] 부분은 제외하고 [가변변수 업데이트 부분만 메서드 추출]한다 . 가변변수 업데이트로서 벌써 1개의 메서드추출이 1개의 역할을 하고 있는 것이다. 가변변수가 로직에 포함되면, 메서드 추출시, 가변변수 재할당업데이트 = 추출메서드()로 뽑히기 때문에, 그것부터 해결해야한다 | . | . 가변변수는 외부에 두고 [추출한 메서드가 반환한 값]으로 [외부 가변변수 업데이트]하게 한다 . 가변변수는 외부에 두어 파라미터로 뽑히더라도, 내부에서 다시 가변변수를 업데이트하고, 그 가변변수를 return -&gt; 외부에서 다시 업데이트도록 뽑힌다. [어차피 외부에서 업데이트하도록 메서드 추출]되므로 [내부 메서드에서는 가변변수가 업데이트될 값만 return]하도록 수정한다. . . . 어차피 외부에서 가변변수 재할당해서 업데이트되도록 메서드가 추출된다. 내부에서는 가변변수 업데이트하여 반환안해도 된다. 그냥 업데이트할 값을 return하도록 수정하자 | . | . . 지역변수 초기화 부분은 외부에 두고 [추출한메서드의 파라미터로 입력]되도록 [외부에서 다른 값으로 초기화해도 사용할 수 있는 메서드]로 만든다. . 추출하면, 해당 지역변수값만 쓸 수 있는 것처럼 나온다 | . 변수초기화관련 메서드추출에서, [지역변수 -&gt; 추출메서드 인자]의 과정을 [INLINE으로 바꾸는 순간, 특정 지역변수with초기화없이, 다른 값을 대입]할 수 있게 된다 . . ​ . [값이 바뀌는 변수]는 지역변수를 inline화 했지만, [가변변수는 inline하면 안된다. 계속 업데이트 되서 외부 다른 메서드들도 쓸 것이기 때문에, 초기값 + 외부 업데이트가 유지되어야한다] -&gt; inline해도 지역변수가 사라지지 않고 남아있음 . . 즉, 내부context(불변필드제외)를 지역변수로 위에두고 추출하여 파라미터로 만들 듯, [가변변수]와 [다른 값으로 바뀔 수 있는 변수 초기화]부분은 위쪽 == 외부에 두고 메서드추출한다 . 바뀌는 지역변수의 값 -&gt; 인자로 inline화 되었다면, [특정 지역변수로 만들어진 파라미터]의 이름을 바꿔주자 (title target -&gt; dataPrefix 등) . . . 09 업데이트된 가변변수cursor를 이용하는, 다음로직인 substring 부분을 메서드추출해보자 . &quot;가 데이터의 끝임을 알려주므로, 변하지 않는 상수로 취급한다면, 바뀌는 변수는 [포함된 가변변수 사용]밖에 없다 . . . 10 조심! [가변변수 = 업데이트 –이후–&gt; 가변변수 ]사용 부분은 inline화 하면 안된다! . 기존 . . | 잘못된 예: 가변변수 업데이트 -&gt; 가변변수 사용을 inline . . | . 가변변수란, [위쪽에 컨트롤타워로서 지역변수에 계속 업데이트 되는 것이 목적]이다. 업데이트 로직을 inline화 시키면, 컨트롤타워가 업데이트 안되고, 일회성 사용하는 것 밖에 안된다. . 가변변수 업데이트 이후 사용 . . | 가변변수 업데이트 로직을 inline화 하여, 업데이트된 값만 사용하고 치웠을 때 . . | . 가변변수는 [컨트롤 타워에 업데이트하면서, 사용할 사람들은 사용]해야한다. [가변변수를 업데이트와 동시에 인자로 INLINE화]하고 싶다면 -&gt; 메서드 인자에서 [ (가변변수 = 업데이트로직)]자체를 수동INLINE해야한다 . . java는 python3.8의 업데이트후 사용 -&gt; 코끼리연산자로 업데이트와 동시에 사용이 가능하다 | . 11 targetPrefix만 바꿔서, 다음 타겟이 잘 추출되는지 확인한다 (title -&gt; date) . json예시 출력을 활용해서 prefix를 만들고 | 컨트롤타워를 통해 업데이트되는 가변변수 cursor를 지속 업데이트하면서 | title대신 date도 뽑아본다. | . . . 12 available까지 추출해보고, 가변변수업데이트 inline으로 바꾼 뒤, 자신의 처리가 끝났으니 커맨드홀더객체#load로 옮겨서, root Composite객체를 setter로 만들어주자 . Test에서 만든 로직 + private메서드들을 load메서드로 옮긴다 . . . . 커맨드홀더객체 내 root Composite객체를, 재활용하기 위해, 추출한 필드정보를 setter로 채운다. String date -&gt; LocalDateTime.parse() / String boolean -&gt; Boolean.parseBoolean() 으로 를 한번더 씌워서 set해줘야한다 . available필드는 setter대신 toggle만 있었는데, setter를 추가해줬다. | . . . 커맨드홀더 객체 내, 자식들 정보가 있는지 확인 후, add해서 붙여주기 . composite객체의 자식생성은 [데이터가 있을 경우] -&gt; 데이터를 추출해서 .add()로 root에 붙여주면 된다. . 기존 main에서 자식을 생성하는 방법 . . | . 13 자식 존재유무 판단할 수 있는 곳인 [sub: [ 를 prefix로 그 1칸 뒤까]지 이동시켜, 자식 있다면, {로 시작하도록 cursor업데이트 시키기 . 데이터는 추출안하고, 자식데이터를 뽑을 수 있는 위치까지만 cursor를 업데이트시켜놔야한다 . . . | . 14 다시 한번 복잡한 로직(자식 존재유무 &amp;&amp; 데이터 추출)이 예견되므로 Test로 현재까지 결과를 옮겨서 디버깅하며 처리하기 . 자신의 정보 추출까지는 cursor가 업데이트 되어있으니, cursor 업데이트 로직까지 들고와서 Test에서 진행한다. . . . Test참고) 커맨드홀더객체내 load메서드에서 재활용하는 객체는 command홀더객체가 아니라 소유 composite원본객체를 만든다. 하지만, Test에서는 Command홀더객체 내부 composite객체를 생성해서 테스트한다면, save나 load가 호출불가하므로 테스트의 목적인 load메서드를 호출하고, load의 뒷부분만 처리하기 위해 중간결과인 json을 받고 처리 중에 있다. . 14 자식정보가 남아있을 때까지 add -&gt; while문을 사용해서 반복하며, [cursor와 같이 움직이는 배열]은 [cursor로 현재 위치를 확인]하도록 while문을 작성한다. 이때, cursor업데이트 조건은 1칸씩 이동이다(데이터 추출이 아니라 데이터 존재유무 확인부터) . while문은 if매번확인후 action을 여러번 하는 것이며, 내부 확인변수를 업데이트도 시켜줘야한다 . cursor가 json의 끝에 위치하여 -&gt; 자식정보 탐색이 끝났는지 매번확인하면서 자식데이터를 추출한다 | 현재는 Test파일에 작성 중. | . . | while속 조건문은 매번 호출되는 확인문장이라서 메서드호출 결과가 상수라면, 지역변수로 빼서 상수로 검사한다 . 조건문에 들어가는 메서드호출은 값이라서 -&gt; 조건문 속 메서드 호출을 피하는게 좋다. | 만약 내수용으로 로직정리용이라면, 그대로 둔다. | . . | . 참고) command홀더객체 내, cmd객체들 외부저장소(List배열)과 cursor로 상태확인 . redo는 undo로 인해 cursor가 원래배열의 끝보다 더 뒤에 있을 때, 한칸 앞으로 움직이므로 . cursor가 배열의 맨끝에 있지는 않은지 검사한다 . . | . | undo는 실행되어 기록이 저장된cmd가 1개라도 있어야한다. . cursor가 원소가 1개도 없을 경우인, 0보다 뒤에 있는지 확인한다 . . | . | execute후 add는, 현재 add된 것이 배열의 제일 마지막에 위치하도록 (add를 단순 cursor++만 해선 안됨) 해야 add후 redo시 에러가 발생안하게 되는데, cursor는 undo로 인해 배열 끝보다 더 뒤에 있을 수 있으니, add하는 순간에는 cursor이동 전에, 배열 remove로직도 들어간다. . **cursor만 빽(undo)하고 redo를 위해 배열에는 cmd객체를 남겨놓는데, cursor가 빽 한 상태에서 add한 것이 배열의 제일 끝에 위치하여, redo는 불가능하도록 만들어놔야한다 ** . | 그럴려면, 현재cursor(빽한 상황)보다 더 앞에 있는 cursor + 1 ~ 마지막까지는 먼저 배열에서 삭제해놓아야 한다 . | 그리고 난 뒤, 요소를 배열 맨마지막에 add했으면, cursor의 업데이트는 불변식 size()-1로 업데이트한다 . . | . | 15 sub: [ 1칸 뒤에서부터 cursor를 1개씩 증가시키면서 문자열1개씩 확인하며, 자식존재여부를 판단한다. . 데이터 추출이전에, cursor에 있는 문자열 1개씩 json.charAt(cursor)으로 뽑아 검사하여, if 자식데이터 존재유무를 확인한다. cursor++업뎃 중에 if에 안걸린다면 건너띈다는 의미이다. . . [담에 나온 문자열이 {라면, 자식이 최소 1개 존재한다는 의미이다. -&gt; 자식데이터들을 추출한 뒤, add자식 해준다. . root 자신 데이터 추출시 사용했던 코드를 복사해와서 수정한다. | . . . root.add( )에 들어갈 데이터들을 추출하고, 파싱까지 한 뒤 add해준다. | . . . 현재 Available(boolean)에 대한 setter메서드는 toggle만 커맨드로 만들어줬다. 여기서 available의 setter를 추가해줘야한다. . 객체를 생성하면 기본 default로 정해져서 toggle만 정의하고, setter는 무시했지만, save된 jsonstring으로 load할때는, 기본값이 아닌 저장된 값으로 채워줘야한다 . 기본값을 가지고 태어나서, setter를 정의안해준 Composite객체의 available . . | command#addMenu의 파라미터 / composite#add시 파라미터에 available이 빠져있다. . CommandMenu . | CompositeMenu . . | . | . CompositeMenu생성자에 available을 받아서 생성되는 것까지, Test에서부터 추가해 나가야한다. . 현재 Test . . | . command객체에 available을 포함하여 자식을 추가하는 서비스 메서드를 만든다. . . | 커맨드객체는, 래핑할메서드의 파라미터가 완전히 달라지면 새로운 커맨드객체를 생성해야하지만, 파라미터가 추가되는 경우는, 기존 커맨드객체의 생성자를 추가함으로써 가능하다. 대신 기존 생성자는 기본값 처리 + 오버로딩해줘야한다 . 기억해야하는 context의 종류가 달라짐 -&gt; 필드종류가 달라짐 -&gt; 새객체 | context가 추가해됨 -&gt; 필드 추가 -&gt; 생성자 추가 및 기존은 부생성자로 변경 | . | 기존 Add 커맨드객체에 기억context추가에 따른 필드를 추가하고, 그 전에 파라미터가 없던 것은 기본값을 초기화해보자. . . . | execute에 추가 기억한 context를 넣어서 작동시키자. 만약 안들어왔으면, 기본값 true로 초기화되었다가 들어간다. . . | execute되는 원본 composite객체의 add도 파라미터 추가된 메서드를 추가한다. . | 커맨드홀더 소유객체(Composite)의 필드가 추가되었으면, Add만 수정하지 말고 -&gt; Remove도 다 처리해줘야한다. (필드에 대해 oldXXXX처리) . 현재 remove커맨드 작동시, 삭제execute 전 old필드들을 기억했다가, undo시, old필드들로 되살리는데, available도 기억했다가 되살리기 해야한다. . 기존 . . | 기억해야할context를 필드로 추가 . . | . | command홀더객체는, add/remove/undo/redo 이외에 소유객체의 필드setter들도 커맨드객체 처리해줘야했다. . available은 t/f라서 toggle만 만들어줬었는데, 객체 재활용을 통한 생성을 하기 위해 setter로 만들어줘야한다. . 기존 . . | . command홀더객체내 available setter 서비스 메서드를 만들어주고 . . | setter에 대한 cmd객체를 만들어준다. . setter의 execute는 set전에 old값 기억후, undo가능하게 하기다 | . . | 다시 Test로 넘어와서, 자식데이터 중에 available까지 뽑아서 자식menu를 추가해준다 . . 16 sub[ 담에 {를 발견해서 자식데이터 추출후 add했다면, } 닫히기 전에 [로 자식의 자식이 있는지 확인해야한다 . 하지만, { 자식 발견하도 바로 continue로 넘어가는게 아니라 이어서 추출+cursor업뎃+자식add후 자식의 자식[이 있는지 vs ` ]가 바로 나와서 sub[가 닫히는지 `검사하는 중이다. . 일단 자식발견해서 add하는 부분을 리팩토링하자 . . | . if로 1개의 작업이 끝났다면, 빠른 continue를 해주는게 좋은데… 뒤에 공통로직인 [반복문변수 업데이트로직] cursor++가 남아있다면, continue로 끝내면 안된다. . 최대한 if로 어떤처리가 끝나면 continue로 다음 루프로 넘어가자 . . | 하지만, 반복문에서는 continue전에 반복문변수 업데이트를 해줘야한다. . . | . 매번 if - continue할때마다 cursor업데이트할지 vs if만 처리하고 continue없이 공통으로 cursor업데이트할지 정해야한다 . 매번 해준다면, 코드가 반복될 것이다. . . | . 반복문내 모든 if에 대해 밑에 반복문 업데이트 같은 공통로직이 남아있다면, if에서 early continue하면 안된다 . 모든 if에 대해 밑에 반복문 업데이트 같은 공통로직이 남아있다면, if에서 early continue하면 안된다. . . | . 이대로 반복문이 흘러가면, 자식 발견후, 같은level의 다음자식들은 다 {발견될시 데이터 추출후 add가 끝날 것이다. . . 17 {확인으로 자식의 데이터를 추출해 add했다면, 다음 해야할 일은, 자식의 [가 열리고 {가 발견되어 또다른 depth(자식의 자식)이 열리는지 확인해야한다. 그리고 이것은 {가 발견되어서 최소 1개의 자식이 있고, 거기서 sub: [가 열리는지 확인하는 것이다. . 반복문 속에서 특정if에 걸린 것을 확인하는 방법은 가변변수를 통해 결과물or불린Flag을 챙겨놓는 방법 밖이다. . if에 걸려서 결과물이 있다면, 그것을 형으로 하는 가변변수 = None초기화로 챙겨놓으면 된다. 만약 결과물이 없는 void로직이라면, bolean가변변수 = false;초기화의 Flag변수를 챙겨야한다 | . | . 원래 load는 composite객체의 add로 자식을 넣지만, 테스트에서는 포장된 command홀더객체를 사용하고, 커맨드홀더객체들의 메서드들은 결과물이 없는 void라서 지연실행한다고 했다. -&gt; 지금은 boolean으로 플래그를 챙기고. 내부에서는 add결과물로 if걸린 것을 확인하도록 바꾸자. . . . 18 자신의 처리후 -&gt; 반복문으로 데이터뽑아 자식들을 채우다가, [자식의 자식]을 발견한 순간부터는 재귀를 돌려야한다 . 자신에서 [자식들의 처리]는 [반복문 + 자식 1개처리]로 여러자식들을 처리하도록 정의된다. 이 때, [반복문을 포함한 자식들처리 전체] 부분을 재귀함수로 추출해야, 내부에서 자식의 자식이 등장할 때, 똑같이 [반복문 + 자식1개로 처리 + 자식의 자식들 재귀로 처리] 처리를 할 수 있다. . . 재귀함수에서는 [반복문내 자식1개 객체]-&gt; [재귀에서 자식의 자식으로 업데이트]되어서 호출되어야하므로 [재귀함수 파라미터에는 반복문내 자식1개 객체가 포함된 후 -&gt; 자식의 자식으로 업뎃하여 호출]되어야 한다. . 위에서 값이 초기화되어 필요한 변수인 json이나, 가변변수들은 알아서 파라미터로 뽑힌다. . | 재귀함수를 정의할 때 고려해야할 것은 . 다음stack결정변수 . 값이라면: cnt(0)-&gt; cnt+1, n-&gt;n-1 . 종착역 if cnt == 2, n == 1 등 | . | 연결된 객체라면: . 객체 -&gt; 객체 = 객체.next, | 객체 -&gt; 반복문속 자식객체, | 외부에서 사용한다면 객체.재귀메서드() -&gt; 다음객체로 업뎃 -&gt; 다음객체.재귀메서드() | 종착역 if 객체 == 시작특이점객체 | 아예 자식객체가 없어서 반복문 x -&gt; 다음재귀 호출x 반복문속의 자식객체.재귀호출()는 종착역이 따로 필요없다 | . | . | . | | 필요정보 변수(전역변수면 노상관이지만 객체에선 x) . | 계속 업데이트되는 가변변수 . | 연산식을 직접 적어서 업데이트하는 누적결과값 . | | . 19 직접 composite객체의 자식객체들 생성을 위한 재귀로 만들어보기 . root의 자신처리는 재귀에서 제외한다. [자식들부터만, 자신의 처리가 반복문 + 자신처리1개의 여러번 반복되기 때문]이다. . 01 root의 자식들처리를 위한 반복문부터 재귀메서드로서 메서드 추출한다. . . . 02 객체의 반복문처리 재귀는 [반복문내 자식객체1개 -&gt; 자식의 자식 등장 -&gt; 자식의 자식객체 1개로 업데이트된 재귀 호출]을 하면 된다. 그러기 위해서는, [파라미터로 자식객체 1개의 형]이 올라와야하며 [인자는 child -&gt; 파라미터는 parent로 명명]해준다. . . . 03 문제상황1) 객체반복문 재귀메서드의 stack결정 파라미터 초기값이 반복문내 자식1개 객체가 아니라, [root 자신]이 들어간다. -&gt; “아~! 재귀에서 인자는 필요한 현재상태 값(root)일 뿐이고, 실제 내부 작동하는 것은,그 상태값으로 만들어진 다음 자식객체(child) 내부에서 만들어지거나 getter로 불려져서, 그놈이 다음재귀에 상태값으로 들어가는 구나~!” . . 04 문제상황2) root가 들어갔으면, [반복문내 자식객체1개]가 만들어져서 변수로 활용되어야, 다음 재귀의 root대신 들어가서 자신이 root역할을 한다?! . 원래 커맨드홀더객체#load내에서는, 소유한 composite객체로 처리하며, add결과 add된 자식객체 1개가 추출된다 . 하지만 지금은 cmd객체를 사용하고 있어서, void로 add결과 아무것도 안나온다 | 억지로 맨 마지막것을 뱉어내도록 getter를 만들어줘야하나?? | 기존의 자식들을 불러내주는 getter가 있으므로 이것의 제일 마지막 것을 대신 사용하자 | . . | add후 추가된 child 객체 1개를 뽑아냈다면, flag 가변변수를 대체하고, 사용하자 . . | . 05 이제 자식의 자식이 발견된 시점에서, 자식의 자식을 -&gt; 자식처럼 처리하기 위해, 재귀메서드를 [parent -&gt; child로 바꿔]호출해준다. . 자식을 억지로 가지고이 위해 child가 composite객체로 가져와서 재귀에 넣었더니, 재귀메서드 자체가 최초인자가 command홀더객체라서 -&gt; composite객체로 바꾸도록 변경하고, cmd홀더객체에 getter를 써서 넣어주었다. . . . | 이렇게 된다면, cmd로부터 억지로 child객체를 빼올 필요없이 composite객체.add의 결과로 나온 child를 챙겨주자 . . | . 06 일반적인 반복문 객체재귀의 [for 자식객체들 -&gt; 다음재귀]와 다르게 [종착역: 자식들 소유안해서 for가 안돌고 끝나는 곳이 종착역]이 아니다. -&gt; 반복문이 json과 cursor로 돌아가고 있으므로, 해당depth(stack)의 처리가 끝나는 곳을 직접 알려줘야한다 -&gt; &#39;]&#39;를 만나는 순간 해당 stack을 종료해야한다. . . . 07 정해진 소스(json)을 돌며, 모든 재귀stack에서 cursor를 업데이트하고 공유해야한다면, 해당 stack이 끝나더라도, 외부에서 초기화된 가변변수 cursor를 반환해줘야, 다음 또다른 stack이 쓸 수 있다. -&gt; 자식객체 for문이 아니라, [외부 컨트롤타워를 두고 초기화된 가변변수 cursor를 쓰는 재귀문]이라면, [stack끝나고 빽할 때마다 업데이트된 cursor를 종착역에서 반환]해줘야한다. (종착역반환 -&gt; 자식재귀 반환 -&gt; 재귀정의부 반환 -&gt; 외부에 반환) . . . . 08 재귀로 더해진 자식들을 확인하기 위해 cmd.getMenu()객체를 지역변수로 빼고 -&gt; composite객체를 출력하라면 rendere에 consolevisitor를 주입하고, 메서드인자 compoiste-&gt; report로 만들어서 넣어줘야한다 . . . . 09 이제 command홀더객체# load 내부로 옮긴 뒤, 재활용이 완성된 소유Composite객체를 반환하도록 load메서드의 시그니쳐를 바꾼다. . . . 10 test에서는 load의 반환이 string json -&gt; 재활용완성된 composite객체를 받도록 수정하고 다시 한번 출력해보자. . . .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/menu/command/memento/side/2022/07/31/menu%EB%A5%BC-%EB%A7%8C%EB%93%A4%EB%A9%B0-%EC%9D%B5%ED%9E%88%EB%8A%94-command,-memento%ED%8C%A8%ED%84%B4.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/menu/command/memento/side/2022/07/31/menu%EB%A5%BC-%EB%A7%8C%EB%93%A4%EB%A9%B0-%EC%9D%B5%ED%9E%88%EB%8A%94-command,-memento%ED%8C%A8%ED%84%B4.html",
            "date": " • Jul 31, 2022"
        }
        
    
  
    
        ,"post11": {
            "title": "menu1를 만들며 익히는 composite, visitor패턴",
            "content": "menu를 만들며 익히는 composite, visitor패턴 . 나중에 menu에 적용할 코드들 깃헙 | 블로그정리 | . | . Composite패턴을 적용한 메뉴+폴더 = CompositeMenu . 01 단일 menu(파일)부터 만든다 . 필드초기화 필드, 생성자초기화지만 상태가 변하는 not final + setter필드 . 초기값이 이미 주어지는 필드는 생성자에서 받으면 안된다. -&gt; 필드초기화 available = true; | 외부에서 받는 생성자초기와 구분된다. 생성자 파라미터에서 빠진다. | . | 외부에서 받아 시작되지만, 바뀌는 필드 -&gt; 생성자 + not final + setter | . . . boolean필드는 setter가 아닌 toggle로 상태변화한다. . 외부에서 값을 받아 상태를 변화하는 setter가 아니다. this.flag = ! this.flag형태로 외부값없이 t/f만 토글된다. | . | true/false왔다갔다만 한다면, setter대신 toggle로 따로 정의해줘야한다. | . . 생성자초기화 + not final/setter조합은 반드시 setter메서드를 통해 생성자 할당코드를 대체한다. . 중복코드를 제거함과 동시에 외부정보에 대한 특별한 처리를 setter에 정의하고, 생성자는 setter를 이용해 처리로직도 같이 적용되도록 한다. setter시 처리와, 생성자 초기화시 처리가 다르면 문제가 생긴다. | . | . . . 필드 -&gt; setter (-&gt; getter)가 정의되면 객체 구분을 위한 eq/hC + toString도 정의해주자. . . | . 02 Menu를 담을 Menus(폴더)를 만든다. . 폴더menus는 Set으로 파일들을 관리하는일급컬렉션인데, 이름 필드를 가진다 . . 폴더객체는 기본적으로 getChild+ add + remove 기능을 가져야한다. . add/remove/getChild3개는 폴더가 | draw(operation)은 파일의 기능으로 정의되어있다. | . 컬렉션필드의 setter(add)/remove는 CRUD에 포함되므로 boolean으로 반환해야한다. . 컬렉션필드는 void setter개념으로 void add를 만들어도 되지만 | 컬렉션의 상태변화는 실패가능성을 가진 CRUD이므로, 사용하지 않더라도, boolean으로 결과를 알려줘야한다. | . . . 일급컬렉션(폴더) add를 통해 관리되는 컬렉션 관리 단일객체 추가시 외부public생성한 것 받아add vs 외부정보 받아 일급컬렉션(폴더)내부 생성해서add 할지 결정해야한다. [컬렉션관리 단일객체의 public외부생성은 당연한 것이 아니다. 외부new때리는 것은 최소화] . 컬렉션으로 관리할 객체를 public메서드(add)의 파라미터로 받는다는 말은 단일객체의 생성자가 public이며 | 외부에서 객체가 생성되고 들어와 add한다. | 만약, 단일객체의 생성자가 수정되면 -&gt; 외부의 생성자 사용코드들도 모두 수정해야한다. | . | 컬렉션 관리객체를 public메서드(add)의 파라미터에서는 생성정보만 받고 + add메서드 내부에서 내부발행하게 한다는 말은 단일객체의 생성자를 internal로 수정한다 | 내부에서만 생성되므로, 생성자 사용코드들은 여기에만 존재한다 | 단일객체가 필요에 의해 외부공개(public 생성자)되기 전까지, 일급컬렉션 내부발행으로 잠궈놓아 수정시 드는 비용을 줄인다 | . | [컬렉션으로 관리될] 단일객체가 public외부에서 객체 생성되는 것이 당연한 것이 아니다라고 생각해야한다. 동시에 바깥에서 new키워드 때리는 객체는 최소화해야한다. | . | . 컬렉션으로 관리되는 단일객체를 내부생성할 수 있게 add메서드의 파라미터를 생성된 객체 -&gt; 생성정보로 바꾸고, add메서드내부에서 new때린다고 생각한다. | 객체의 생성자를 internal로 수정한다. | 객체의 생성자 파라미터를 복사해와서 add메서드의 인자로 바꿔준다. | 내부에서는 단일객체를 생성후 add까지 해준다. | . . . 일급컬렉션 remove는 add와 달리, 이미 생성된 객체를 인자로 받아야한다. [생성코드만 내부에 있지, 객체자체는 public메서드를 가진 public클래스라서 외부에 공개/조작가능한 객체이다.] . 생성코드를 외부공개 안하는 것과 객체 자체를 외부공개 안하는 것은 다르다. 생성 자체는 컬렉션관리객체가 내부에서 하고, 외부에 반환 + 조작가능은 거의 다 public메서드를 통해 가능하다. | 내부생성 -&gt; 컬렉션add -&gt; 외부 컬렉션반환 -&gt; 외부 단일객체 추출 -&gt; 단일객체 조작가능 -&gt; remove는 외부에 존재하는 단일객체를 식별해서 remove | . | 이미 존재하고 있는 &amp;&amp; public메서드를 통해 외부 공객객체를 삭제하는 것이기 때문에, remove의 인자는 객체를 받는다 add에서만 생성을 외부vs내부를 판단한다. | . | 객체의 식별은 값이 아닌 객체 자체로 되기 때문에, 반드시 객체인자를 받아 지우자. 대신 생성만 인자를 선택해서 생성장소를 선택한다 | . 폴더객체는 add/remove외에 get컬렉션()을 통해 외부에 공개하는 getter를 가지며, Set컬렉션을 정렬가능한 List를 변환 공개해야한다. 주의) 컬렉션 자체는 무조건 사본으로 반환해야한다. [생성자를 통한 얕은복사(단일객체 조작가능)]는 사본생성 및 변환도 동시에 가능하다. . 외부에 컬렉션을 반환할 때는, 객체반환후 조작과는 달리, 내 컬렉션필드가 영향을 받으므로 사본반환한다. | 생성자를 통한 얕은 복사는 Set -&gt; List로 변환이 가능하다 | 얕은 복사이므로 개별요소(단일객체)의 조작이 가능하다. 깊은 복사 vs 얕은 복사는 개별요소의 메서드가 public(외부조작가능)인지 아닌지를 보고 판단하면 된다. | 출력용이 아니라면 거의 다 얕은복사 | 출력용은 객체조작하면 안되니 깊은복사 | . | | . . . 제공기능에 제공방식(정렬방식 지정)를 원할 경우, 파라미터로 정의해서 외부에서 선택하게 한다. . 외부에서는 정렬된 컬렉션인 List의 반환을 원하며, 제공방식 또한 외부에서 원하는대로 받고 싶어한다 getter를 가지는 것은 명백한데, 외부가 따로 정렬을 원하는 경우, 외부가 원하는 것을 인자로 받아서 처리해 줘야한다. | . | . . . Comparator같은 함수형인터페이스(3가지 패턴) 자체를 파라미터로 빼지 않는다. 파라미터는 메세지로서 객체만 허용하므로 1) new 인터페이스()를 통한 전략메서드 실시간 구현 익명클래스 인자 -&gt; 2) 객체에 전략메서드 구현 후 가상인자와 람다식 인자로 -&gt; 3) 추상체 정의후 구상체로 가상인자와 람다식으로 인자. 정렬방식 지정은 상수개념의 값객체가 필요하니 enum을 도입하고, enum을 추상체로 본다. . 만약, 정렬방식을 어떤 값으로 준다면, switch분기가 필요하지만, 값객체 enum으로 주면, 값객체도 객체로서 분기없이 각자의 일을 정의해놓고 위임할 수 있게 된다. | 외부에서 정렬방식을 지정할 땐 상수개념의 값객체가 필요하다 . | java에서는제한된 수의 값객체에 ` enum을 활용`한다. . | 함수형 인터페이스는 instanceof를 대신하는 분기추출용 전략인터페이스일 수도 있고, 로직을 추출한 함수형인터페이스일 수 있다. . **함수형인터페이스 인자는 내부에서 [인터페이스 추상체변수].전략메서드()로 사용하여 정의되어있다는 뜻이다. ** . | 우리는 전략인터페이스를 구현한 전략객체를 만들어 인자로 넣어주면, 전략메서드는 이미 구현된 상태이므로 추상체변수대신 구상체가 들어가 그대로 시작된다. . | 전략객체의 구상체를 만들지 않고, new인터페이스(){익명클래스로 실시간 구현한 객체}를 넣어줘도 된다. . impl한 전략객체를 만들기 싫다면, new 인터페이스(){ 익명클래스로 전략메서드 실시간 구현} 인자를 만들어서 넣어줄 수 있다. . 인자 부분에 new 인터페이스() 를 하면 익명클래스가 만들어지는데, 여기서 전략메서드 시그니쳐를 확인할 수 있다. . | 또한, 각각의 익명클래스를 변수로 빼서 Naming하여 적용되게 할 수 있다. . . | . | . | 중요한 것은 전략메서드내용을 객체로 구현만 하면 되므로, 가상인자의 람다식을 통해 전략메서드 시그니쳐 유지한 체, 내부에서 지연실행될 로직을 객체의.메서드() 등을 통해 람다식에서 호출한 것을 대입해도 된다. 중요한 것은 지연 실행될 전략메서드 로직을 시그니쳐대로 구현한 로직이 필요한 것이다. . 예를 들어, 객체 생성을 내부에서 하고싶은데, 여러종류의 객체 생성이라 추상체로 두고, 구상체 new때리는 로직은 외부에서 전달하고 싶다면? . 생성로직에 맞는 시그니쳐를 가진 함수형인터페이스를 사용하고, 지연실행 될 내부로직에서는 함형인페.전략메서드()형태를 가진다. . . | 외부에서는 가상인자의 람다식으로, 지연실행될 로직을 객체.메서드(여기선 생성자호출)로 작성만해서 인자로 넣어둔다 . 내부에서 알아서, 건네 준 로직의 람다식을 -&gt; 추상체.전략메서드()로 지연실행한다 | . | . | 들어가면 전략메서드_실행메서드() -&gt; 구현내용을 가진 부분인, 전략객체.전략메서드()를 실행 . get(supplier), accept(predicate?), apply(functional) 등 | . | . | . | . 블로그1 함수형인터페이스 정리 . 함수형 인터페이스 파라미터 -&gt; 지연실행을 위해 전략객체가 아니더라도, 전략메서드 내용구현한 객체.메서드()로 대체할 수 있다. . 파라미터에 함수형인터페이스가 있다는 것은 전략객체 or 익명클래스 전략메서드 실시간구현 or 전략메서드 구현객체의 람다식 호출등 복잡하므로 객체로만 메세지를 전달하게 한다. . 대신 전략메서드가 무엇인지 확인하기 위해 인자 자리에new 인터페이스(){}익클을 한번 구현해서 전략메서드 시그니쳐를 확인한다. | . . . | 인터페이스를 구현한 전략객체로 분기를 대체할 것은 아니므로 전략메서드 시그니쳐대로 로직을 구현한 객체.메서드()를 만들 준비를 한고 인자 자리에는 전략 시그니쳐에 맞는 가상인자 -&gt; 람다식를 이용해서, 객체가 구현할 준비를 한다. . 인자 2개를 받고, int를 반환하는 compare이름의 메서드 | . . . | sortType은 제한된 종류의 값객체이며, 종류를 가지므로 enum에 정의한다. . . . | Enum은 enum필드를 확정된 인스턴스, 그 아래로는 추상클래스로 보고, 추상메서드로 정의하면, 인스턴스(enum필드)들은 추상메서드를 익명클래스로서 구현할 수 있다. . enum는 static초기화보다 더 빨리 jvm이 먼저 확정짓는 인스턴스를 만든다. . os가 보장하는 thread안전 인스턴스다. | 싱글톤의 syncrhronized안걸어도 안전해진다. | . | enum은 이미 만들어진 필드들의 추상클래스 역할도 하기 때문에 abstract를 정의할 수 있다. . enum은 추상메서드를 정의해놓고 -&gt; enum필드들이 익명클래스로 실시간 구현을 전개해놓을 수 있다. enum필드들의 구상체를 만들진 않기 때문에, 익클을 통한 구현 밖에 안된다. | . | . | string이나 date는 내장 compareTo를 이용해서, 2개를 비교해서 int를 반환한다. . 이 값을 compare의 int반환에 return해주면 된다. | . | . 일반메서드로 정의된 compare를 시그니쳐만 가진 추상메서드로 바꾸고, enum필드들을 선언 하여 구상체 인스턴스로 생각한다. . . . | List의 정렬방식은 요소들의 필드들에 대해 X 2(오름차순ASC, 내림차순DESC) 로 enum필드을 만든다. . enum필드는 Menu들의 정렬방식이 와야하는데 Menu의 필드들을 기준으로 오름차순/내림차순으로 만든다. . . . | enum필드의 소괄호()는 값/메서드를 인스턴스내 필드로 매핑하여 생성자를 추가해야하지만, 맨끝의 {}를 달아주는 순간 익명클래스로 인식되어, enum내부 추상클래스를 구현하도록 유도된다. . . enum필드(인스턴스)마다 자신의 필드getter로 꺼내서 compareTo시켜 정렬방식을 구현한다. . 내림차순은 String, LocalDateTime의 compareTo() 인자의 순서를 바꿔주면 된다. | . . . row == 인스턴스 종류가 확정일 땐 enum으로 객체를 구현하자. n개이상 끝을 모르는 객체에 대해서만 class를 만들어야한다. . 만약, enum으로 구현안하면, 확정적인 종류 이상의 객체를 누군가 만들어낼 것이며, 그것 자체가 오류이기 때문이다. | enum을 쓰면, 객체 수량오류(상수) 및 객체종류 오류가 안생긴다. class를 만들기 전에, enum으로 만들어보는 것도 방법이다. . | 이로서 폴더가 구현해야하는 getList with 제공방식(정렬)까지 구현했다. . . | . 03 컴포지트패턴은 파일+폴더를 합친, Set컬렉션 데코객체라고 요약할 수 있다. . 컴포지트 패턴의 4가지 구성요소 파일(operation) + 폴더(add/remove/getChild)를 합쳐서 CompositeMenu에 한번에 구현한다. . Menu를 복사해서 CompositeMenu를 만들고, 생성자 등을 수정한다. . 폴더&lt;-&gt;파일 따로 있을 때, 파일인 Menu를 폴더내에서만 생성(외부생성X)으로 수정비용 최소화 했던 것을, 이제는 CompositeMenu라는 폴더겸 파일은 폴더로서 외부에서 root폴더 최초 생성해야하기 때문에 생성자를 public으로 복구한다. | 필드 수정외에도 변화가 일어나면, eq/hC + toString은 다 옮겨진 때 재정의한다. | . . . | 이제 폴더역할을 하던 Menus의 내용을 가져온다. . 중복되는 필드 및 getter/setter는 제외하고 가져온다. | 재정의할 것들을 재정의한다. | . . | Set컬렉션 데코객체로서, 자신형의 Set컬렉션을 관리하도록 변경한다. . 참고 . . | 현재는 폴더(Menus)가 파일(Menu)를 관리했지만 | 현재는 폴더 겸 파일인 CompositeMenu가 CompositeMenu를 관리하도록 변경한다 | . | 수동변경해야한다. Menu형 -&gt; Composite형 | . . Menu정렬 enum과 새로운 CompositeMenu정렬 enum은 다른 것이다. compare(a,b)의 대상이 달라짐. 새로 구현해야한다. enum은 제네릭이 안되므로 형이 달라져도 새롭게 구현해야한다. . . 컴포지트 객체는 자신+자식들의 정보를 같이 반환해야하므로 출력사본 컴포지트객체(Report)형이 새롭게 필요하다. . getMenus()에서 . 기존에는 자식들만 list에 넣어서 반환했지만, | 지금은 자신의 정보 + 자식들 정보 같이 return해야하는데, 여러정보를 1번에 return하려면, 출력사본 컴포지트 객체가 필요하다. | . | 출력사본 컴포지트형이 만들어지면 . 자신 이외에 자식들은 add로 넣어서 Composite객체와 동일하게 자신 생성후 + add 자식들까지차례대로 컴포지트 객체를 새롭게 만들어서 반환해야한다. | . | 현재 CompositeMenu . title | date | available | Set CompositeMenu | . | 출력사본 MenuReport . CompositeMenu : 파일1개를 묶은 것 (CompositeMenu를 묶은 것) | List MenuReport : 출력사본 파일들을 묶은 것 List CompositeMenu | . | . | 참고 . . | . 일단 출력사본 Report는 1개의 Composite객체로부터 최초 사본이 만들어진다. . 이후 Composite객체처럼, add를 통해 자신형(Report)을 모으는 컬렉션필드를 가지고, add를 통해 자식들을 추가한다. . . | . . | composite객체는 자식들을 add시 내부생성을 고민할 필요가 없다. 폴더역할을 하는 이상 외부에서 root폴더는 무조건 생성되므로 composite객체는 외부생성이 풀린 객체이므로 add시 정보가 아닌 객체를 받는다. . 출력사본은 원본의 getter내부에서 사용될 것들을 정의한다. 먼저 원본의 파일을 -&gt; 출력사본 report를 만들고 | 원본의 자식들을 순회하면서 -&gt; report들의 자식으로 add한다. | . | . compositeMenu는 변할일이 없고(final + setter X), 이미 외부에서 생성된 것을 받아 생성(생성자에서 객체를 인자로 유지)되지만, 자식들은 add로 추가해야 composite패턴을 따르는 출력사본이 된다. . 컬렉션 필드는 빈컬렉션 + add조합이 많다. | report들을 자식으로 받아야한다. CRUD는 boolean으로 반환하도록 void가 아닌 boolean응답형으로 작성해주자. | add시 내부관리하는 객체를 add내부에서 객체 생성하도록 외부에서는 생성정보만 받는 경우도 있었지만, report는 컴포지트 객체라서 폴더+파일의 역할을 동시에 수행하므로 외부에서 이미 생성하는 작업이 이루어졌기 때문에 고민 안해도 된다. 객체를 받는다. | . . . | 출력사본 composite객체 report는 파일+폴더(자식들)의 getter로제공하는 것이 주목적 -&gt; 무조건 getter를 정의해준다. . | . 04 컴포지트 객체의 사용은 getter에 for+자식들도 getter재귀호출로 동적트리순회하는 것이다. (자식없으면 순회x -&gt; 재귀호출x -&gt; 종착역) . composite객체는 더이상 getChild(getList)가 아니라 getReport로 변경해야한다.(composite가 된 이상 자식들만 반환할 일은 없다) . getList로 반환되면, 재귀호출시 문제가 생길 수 있다. | 출력사본 객체(파일+폴더 다 반환)를 만들어서 report객체 1개를 반환하도록 수정해야한다. 자식들을 Set -&gt; List 사본 만들어, 정렬하는 로직은 그대로 둔다. 자식들을 이미 정렬해서, report자식들도 정렬된체 add되게 한다. | . | . | . . . 원본 컴포지트객체(CompoisiteMenu)의 operation()은 getter에서 (1)자신의 정보 이용 + (2) for문과 getter재귀호출로 동적트리순회하여 자식들 이용 것인데, 여기선 getter내에서 출력사본을 만들 때 작동된다. . 자신 + 자신형의 컬렉션필드를 가진 컬렉션필드 데코객체는 자신필드orthis이용 + getter 속 for문과 재귀호출을 통한 자식사용이 operation이다. | 원본 -&gt; this로 출력사본 report를 만든다. | 원본의 자식들 (CompositeMenu) menus -&gt; List사본 + 정렬된 상태 -&gt; 내 자신의 사본에 자식사본으로 add해줘야한다. | . 주의점) for내부에서 자식menu를 report로 변환 생성하여 addReport해줘야하는데, composite객체라면 자신이용(this)의 report생성이 이미 for내부 자식 재귀호출 전 로직에 명시되어있을 것이며, 자식이 getter를 재귀호출하면, 자식 자신에서 재귀호출전 로직이 자신에게도 적용될 것을 생각해서 자식들도 재귀호출해야한다. . 자신 -&gt; this를 이용해서 사본 report를 만든다. | 자식들 -&gt; for문에서 순회하여 하나의 composite지만, **this로 이용해서 report를 만들면 안된다. ** 자식들도 하나의 composite객체로서, 자신의 자식들을 순회하여 반영되도록 동적트리순회를 위해, 자식들도 현재 정의 중인 getter를 재귀 호출하여 변환되도록 한다. | 재귀호출전까지의 로직이 현재 자식에게도 이루어진다 -&gt; this로 report만드는 로직이 그대로 적용된다. | 재귀의 종착역은, 자식들 자신의 컬렉션필드가 비어서 for문을 안타 -&gt; 재귀호출이 없어지는 순간이다. 즉, 자식들이 없는 자식은, 재귀호출안하고 끝난다. | . | . . . 역으로 for반복문 속에서 재귀호출되고 있다면? “아~ 동적트리순회해서 자식들을 돌면서 자식입장에서도 재귀호출전의 로직이 똑같이 적용 되고 있구나~! 자식없으면 순회x -&gt; 재귀x -&gt; 종착역이구나.” . . my) 동적트리순회하는 for속 자식들을 변수1개로 생각할 때, (1) 자식들은 무조건 자식들 동적트리순회 로직을 가지는 operatin()을 재귀호출해야만하며, (2) 재귀호출전까지의 로직이 자식에게도 반영될 것 생각 (3) 재귀호출() 결과 자체를 == 종착역(자식이 없어서 for걸리지 않고, 결과값이 반환)의 상황으로 가정하자. . . 이렇게 생각하면, for문 속에서 자식을 new MenuReport(자식)으로 report를 생성하지 않을 것이다. composite객체의 자식들(파일들)은 폴더로서 operaiton을 재귀호출 할 의무를 가진다. | . | . my) 컴포짓객체는 자식들 -&gt; for재귀로 동적순회 -&gt; 자신은 결과물 return -&gt; 자식들 동적순회 재귀호출시 결과물 return하므로, 자식들의 재귀호출도 자식자신의 결과물이 있으며, 재귀호출전 자신로직이 반복된다. . . 05 [Main] Composite객체는 root부터 생성하여 첫번째 자식들은 add(생성정보)로 넣어주지만, 자식의 자식은… getter(정렬문제가 아니라 꺼내려면, set-&gt;list사본 반환)로 자식들만 꺼낸 다음, 처리해야하는 불편함을 가진다. . 자식의 자식부터는 add해주기가 너무 불편해진다. 자식을 list로 받아와 -&gt; 객체로 받아서 -&gt; add | . | . . composite객체의 add시 내부생성 -&gt; 외부에서 생성후 조작된(자식add된) 객체를 받도록 메서드 오버로딩 메서드 추가후 중복코드 제거 . . . root의 자식들에 자식들이 추가될 것이라면, 조작가능한 객체로 생성하되 가장 아래층부터 만들어 자식들 add해서, 마지막에 root에 add하기 . . 06 Composite를 출력 하기 전, root만 출력사본 report를 만들어주면 된다. 동적트리순회로 자식들을 다 report로 변환해서 넣어준다. . createReport메서드는 자식들을 재귀로 알아서 변환하여 넣어주기 때문에, root만 호출하면 report가 완성된다. . . 07 [MenuRenderer] Report를 출력할 방법이 없다. 출력 역시 report를 [자신출력 -&gt; 자식들 for+재귀호출을 통한 출력] 의 메서드를 동적트리순회를 돌아야 (report하나하나) 출력이 가능하다. . 출력을 담당하는 객체 MenuRender를 만들되, render(report) 호출시 Composite -&gt; report 와 마찬가지로, report -&gt; renderer로 동적트리순회를 돌아야한다. . . . composite객체(컬렉션필드 데코객체)의 동적트리순회는 재귀함수를 정의하고, 그 내부에서 (1) 자신이 할일 (2) Set이라면 정렬+사본(report는 생략) (3) 자신의 할일 끝난 상태에서 for 자식순회 -&gt; 내부에서 재귀호출로 자식들이 자신의 일 (4) 종결처리(결과물을 반환한다면 return 자신이 할일 결과물) . . Visitor패턴으로 구현하는 Renderer(메서드에 제어구조 소유) . . 08 [동적트리순회의 제어구조를 가진 메서드를 가진 class]는 라이프싸이클을 타는 visitor객체를 소유하여, 제어를 역전한다. . 기본적으로, visitable(renderer)은 visitor객체를 생성자 주입받아 필드로 가진 상태에서, 제어구조 속 라이프싸이클 메서드들을 배정받는다. Visitor는 생성자주입하되, interface로 정의한다. . . . Visitor인터페이스가 제어역전Visitorable내에서 제어구조에 맞게 [컬렉션 데코객체, Composite객체]가 하는 일을 위임받는다. (1) 자신 할 일 (2) 자식 순회 (3) 종착역시 종결처리 . . . 09 Composite객체는 타 클래스 메서드의 인자로 들어가서 사용될 때, 자식들 역시 인자로 재귀호출 된다. . Composite-&gt;Report의 [Composite객체 내부 자신메서드 동적트리순회 -&gt; 자식도 자신 메서드에서 재귀호출]가 아니라, Report -&gt; print [타 구상클래스(Renderer#render) 메서드의 인자로 들어가서 동적트리순회]를 돈다면, [자식들도 타 클래스 구상메서드의 인자로 들어가면서 재귀호출이다. . CompositeMenu 내부에서 자신의 메서드에서 자식들도 호출 주체 객체가 되어 동적트리 순회 . . | 현재 Renderer 메서드의 인자로 들어가서 동적트리 순회된다면, 자식들 또한 메서드의 인자로 동적트리 순회 . . | . 10 Composite객체의 동적트리 순회시, depth마다 누적/변하는 값이 필요하다면, 파라미터에 추가되어 사용되고, 최초호출(root)시 초기값을 인자로 넣어줘야한다. 이 때, 메서드 추출부터해서 오버로딩이 필요하다. . 자식으로 진입할때마다 +1씩 증가하는 depth의 값을 알아야하며, 그 depth로 padding을 만들어서 출력에 반영되어야한다. | . 일반 재귀를 일만 하던 데코객체 동적트리순회(자기일 + 자식순회 자식일)에서 depth마다 변하는 값을 반영하고 싶다면 (1) 그 순간 누적결과값을 달고 다니는 꼬리재귀가 될 것이므로 재귀부분 전체를 메서드추출(오버로딩) 후 (2) 들고 다닐 값을 인자에 root 초기값 넣어주기 (3) 들고 다닐 값을 파라미터로 추가 (4) 트리 속 자식들 순회시 depth진입시 업데이트 될 인자로 업데이트 . Extract Method로 파라미터 추가전에 먼저 추출한다면, signature같아서 추출안될 수 도 있으니 일단 아무이름으로 추출해놓는다. . python은 오버로딩이 안되서 helper로 추출해서 쓴다. | . | 외부에서 public재귀되는 메서드의 시작을 호출하는 것 &lt;-&gt; private꼬리재귀가 시작되는 것은 서로 다르다. 꼬리재귀는 개발자가 넣어줘야하는 누적결과값의 초기값 입력을 필요로하는데 | 이것을 외부에서 입력하게 둘 수 없으니 오버로딩한 private메서드를 내부에서 호출하는 방법을 선택한다. | . | 내부에 depth라는 누적하여 변하는 인자가 필요할 땐, 꼬리재귀로서 전체 로직을 메서드 추출부터 한다. | . . . 11 [외부 생성자 주입되는 협력객체] Visitor의 사용 메서드에서 [사용 전 동시성 문제] 생각하기 -&gt; 생성vs재활용context . 라이프싸이클을 타면서 출력하는 일을 위임받는 외부주입 협력객체 Visitor가 다른데도 쓸 수 있는 것을 배제하기 위해, 매번 사용될때마다 초기화된 객체여야하냐 -&gt; 생성context | 다른데서도 써야하며, 재활용되기 위해, 외부에서 이미 생성된 것을 받아야하냐 -&gt; 재활용context | . | 제일 안전한 것은 언제나 협력객체는 생성context로 보고 생성자 파라미터를 [협력 객체형]가 아닌 [지연실행될 협력객체의 생성자 자체]를 받는 것이다. | . my) 협력객체가 상태값을 가진 체 재활용 될 것이 아니라면, (전략객체라면) 생성context로 보고, 객체형이 아닌 [지연실행 생성자로직]을 [함수형 인터페이스 파라미터]로 받자. . 라이프싸이클을 타고, 실행만 시켜주는 인터페이스 visitor는 인터페이스로 정의될 것이며, 여러종류의 visitor전략객체가 주입되며, 전략객체는 상태값을 가져 재활용 될 확률이 거의 없다. . | 함수형 인터페이스는, 1개의 메서드를 인터페이스로 정의해놓고 . 내부에서는 전략객체(추상체). 전략메서드()형태로 정의해놓고 | 외부에서는 전략메서드를 구현한 전략객체 자체를 주입하거나 | new 전략인터페이스(){} 전략메서드의 실시간구현 익명클래스를 주입하거나 | 가상인자+람다식을 이용한 [전략메서드 구현 메서드를 호출]하는 방법이 있다. | . | 전략객체를 안 만들것이라면, 사실상 3번이 제일 많이 쓰인다. | . | . 블로그2 생성자로직을 지연실행하기 . 추상체(인터페이스)의 협력관계에서 [형 파라미터]로는 [지연 생성]은 전략패턴 포함 불가능하며, [의존성으로서 내부 생성]도 추상체라 안된다. . . 추상체 협력관계에서, [생성context == 객체의 지연 생성]의 유일한 방법은 객체 생성에 맞는 시그니쳐를 가진 [이미 짜여진 함수형인터페이스 + 자신만의 전략메서드()]를 이용해 지연실행을 정의해놓고, 외부에서 가상인자의 람다식으로 생성자호출 로직을 전략메서드내용으로 전달하는 것이다. . 기존: 협력객체 visitor를 외부에서 생성된 것(재활용된 것일지도 모름) 그대로 받아 사용 . . | . 지연 생성으로 바뀔 협력객체(visitor)는 보라색 내부context으로 표기되어 사용되고 있는데, 내부context가 아닌 것으로 간주하고 메서드 내부라면 파라미터로 추출한다. . . . | 협력객체의 생성자 시그니쳐를 확인한 뒤, 외부 주입 생성자 파라미터자리에 시그니쳐에 맞는 함수형인터페이스&lt;협력객체형&gt;으로 받는다. . 받는 필드 또한 함수형인터페이스&lt;협력객체형&gt;이 되며, 생성자 지연로직 함형을factory로 이름짓는다. | 이제 협력객체가 사용되는 메서드에서 사용 직전에 함형.자신전략메서드()로 생성자를 지연실행시켜 변수로 받는다. | . . . . | 내부 생성된 협력객체는, 꼬리재귀에선 초기값으로 줘서, 재활용된다. . 참고 . . | . | 외부에서 협력객체를 주입할 땐, 가상인자 람다식을 통한 전략메서드 구현부에 해당 객체 생성자 호출로직을 넣어주면, 생성자호출을 통한 객체 생성이 class내에서 지연실행되어 매번 생성된다. . 구상체까지 구현하고 넣어줘야한다 | . . . . | 12 composite사본객체 Report는 getter로 자신 + 자식들 꺼내서 써야한다. . Report는 전달객체일 뿐, 사용하는 곳에서는 자신 getter + 자식들 getter로 각각 꺼내서 써야한다. . . . composite객체 출력 종결처리는, 재료는 필요없지만, depth는 필요하다. 자식들 순회에서는 재귀로 자식 자신들을 그리니 따로 처리할 일이 없다. . depth만큼 padding을 만든 뒤 -&gt; 닫아주는 출력을 해줘야한다. | . . 13 visitor는 인터페이스로서, 라이프싸이클 함수들을 가진다. . . visitor구상체들을 라이프싸이클함수를 구현하여, 재료인 report -&gt; menu를 depth만큼 padding 넣어서 그리면 된다. . 일단 구상체를 구현한다. 그리되 콘솔에 그리는 놈을 Console을 붙여서 구현한다. . . | depth에 따라서 padding을 만들고, 그만큼 띄어서 출력해야한다. . 0부터 시작하며, 그만큼 반복문 돌면서 padding을 빈 문자열에 누적으로 쌓아야한다 | . . . | 자신들의 할일은 [자신 ~ 자식들의 자신 직전] 까지 [depth만큼 padding + 자신의 필드 정보를 get하여] 그리는 것이다. 불린flag가 있다면 삼항연산자를 통해 그려준다. . todo의 complete처럼, menu도 toggle이 반영된 available부터 삼항연산자로 그려준다 | . . 그외 일반 필드정보는 편하게 getter뽑아서 찍어준다. 괄호필요하면 따로 끊어주기 | . | . 종결처리는 [자식없어 순회없이 끝나는 마지막 node]를 생각해보면 빠르고, 실제 적용은 매 node마다 적용된다. [시작시 무엇을 열어줬는지에 대해, 닫아줘야할 것이 있는지] 등을 생각한다. . console은 자신~자식호출직전까지 시작시 특별하게 열어주는 것이 없으므로 종결처리가 필요 없지만 | 자신 ~ 자식들 다끝나고, 마지막 node의 끝에 한줄씩 띄워주는 것으로 넣어보자. | . . 14 Main에서 라이프싸이클을 채운 구상Visitor를 지연생성용 factory에 넣어주고, 어떻게 출력되는지 확인해보자. . . . Composite객체(자신 + 자식들)의 종결처리는 [바로 아래 자식들의 종결처리 이후 마지막 직후자식의 종결처리후 1번만 종결처리된다.] . . 줄바꿈으로 종결처리 하지말자. 자신의 시작시 [여는 처리]가 있을 때만 [닫는 처리]를 종결처리에 추가하자. (종결처리는 생략해도 된다) . 줄바꿈 종결처리를 지운다. . | 따로 여는 처리가 없기 때문에 종결처리를 생략하자 . | 추가로, available 출력은 지워도 될 것 같다. . | 추가로, LocalDateTime중에 date만 표시해도 될 것 같다. . | . . . 15 Composite객체는 호출하는 메서드가 depth를 함께 가지므로 depth와 함께 자신+자식+종결처리를 할 수 있어서 json을 만들 수 있다. . consoleMenuVisitor를 복사해서 만든다. | 종결처리를 할 수 있다면, json의 시작괄호를 닫아줄 수 있어서, 생성 가능하다. | . json의 문자열을 모으지말고 일단 출력하는 형식을 만든다. padding은 -대신 공백으로 바뀐다. . ConsoleMenuVisitor를 복사해서 JsonMenuVisitor를 만든다. . . | 패딩을 -에서 공백으로 바꾼다. . 공백의 갯수는 상관없으니 공백 2개를 기본으로 바꿔보자. | . . | json의 구성은 padding + 여는중괄호 / padding + 중괄호 대체공백 + 필드 + 큰따옴표 속 필드정보 + 콤마 / 자식들의 시작 직전인 sub : [ 여는 대괄호까지를 자신처리를 한다. -&gt; 매번 padding이 들어가니, 매 줄을 일단 sout으로 생성한다. . json의 출력은 필드마다 매번 공백 padding을 사용하므로, 매 라인을 sout으로 편하게 작성하자. . . | 이대로 한번 Main에서 출력해보자. . 아직 매 자신의 닫는 중괄호} + 콤마,의 종결처리가 안되어있다. . . | . | json은 자신의 처리시 여는 중괄호 존재 + 모든 자식들 끝날 때 1번 처리해야할 부분(닫는 중괄호 + 콤마)이 있기 때문에 종결처리를 채워줘야한다. 이 때, detp를 padding을 바꾸는 로직이 재활용되니 내수용 메서드로 추출해야한다. . . . ​ . 종결처리의 확인은, 자식없는 마지막 node에서 [자신의 종결처리] + [나의부모의 마지막node뒤 종결처리]를 확인하면 된다. -&gt; [내 시작뿐만 아니라, 자식들 진입직전에 열어주는 것도 종결처리 해주자!] . . sub의 자식들이 끝나고 자식들 진입직전에 열어주는 대괄호는 닫는 종결처리가 아직 안되어있다. | 자식들끝에 1번 등장하는 내 시작시 열어주는 중괄호는 닫는 종결처리는 잘되어있다. | . 자식들 시작시 열어주는 처리는 콤마없이 종결처리 해주면 된다. 먼저 처리하고, 내 시작시 열어주는 처리를 뒤에 종결처리한다. . . . . 내 시작시 열어주고, 내 종결시 닫는 처리의 콤마는 트레일링 콤마라고 한다. . . 프레임웤을 만들어본 사람이라면, depth를 통한 분기처리를 통해 없애주지말고 사용하자고 하는 사람들이 많다고 한다. | . 16 Json자체를 만드려면, 출력관련(report, visitor, renderer)가 필요없이 Composite객체 원본이자 자식들을 다 담고 있는 root 객체만 Gson라이브러리에 넣어주면 된다. . 참고 블로그 | . implementation . dependencies { //gson implementation &#39;com.google.code.gson:gson:2.8.7&#39; . | composite root객체를 gson#toJson()에 넣어주면 . . | 자식들을 포함하여 다 json으로 만들어준다. . . | 필드명을 변경하고 싶다면, composite객체 필드에 @SerializedName(&quot;바뀔필드명&quot;)을 달아주면 된다. . . | 17 JsonVisitor가 끝처리로서 내어주는 트레이링콤마를 회수해야 serializing이 가능해진다. . 다시 한번 구조분석(Rendere-Visitor-Composite) . Renderer는 composite객체인 MenuReport를 받아, 재귀를 돌면서 뿌려주는 놈이다. . 재료인 Composite객체를 바로 돌지 않고,Visitor(Supplier-Factory-지연생성-돌기직전에생성)를 주입받고, Visitor와 Composite객체를 같이 재귀태운다 | | Visitor는, Composite객체가 재귀를 타면서 할 일자신의처리 + 자식들호출+ 끝처리 가운데 . Composite객체가 스스로 해야할 일을, Visitor에게 위임하며, Visitor메서드의 인자로 넘어간다 . . | visitor는 인터페이스로서, 구상Visitor들이 종류별로 알아서 composite객체를 재료삼아, 자신의 처리 + 끝처리를 하게 해준다. . . . | | Composite객체는 어떤 제어문의 재료로서 재료를 사용하는 책임 위임을 해준 놈으로서, 위임자Visitor의 파라미터로 들어가, Visitor의 책임들에서 사용된다. . | JsonVisitor의 composite객체 끝처리(endMenu)마다, [외부 동적트리순회-반복문의 끝(같은레벨선상 마지막자식) 호출 일때]마다 [재귀함수 isEnd플래그 파라미터]에 true를 넣어주세요~!를 부탁하면서 재귀함수에 파라미터를 추가 -&gt; 끝처리함수에선 이용하기 위해 파라미터를 추가 한다 . 끝처리 함수에 있는 트레일링콤마 출력이, if 레벨선상마지막일 땐, 콤마없이 출력하도록 필요한 정보가 끝처리메서드 파라미터로 들어오도록 해야한다. . . . | 끝처리에 쓰일 정보 isEnd는 동적트리순회 메서드 내에서 사용되므로 재귀의 파라미터로 업데이트 되어야한다 . . | 재귀메서드는 depth마다 업데이트 변수 뿐만 아니라 동적트리순회마다 반복문을 통과하면서 바뀌는 변수도 파라미터로 올린다. -&gt; 반복문내에서 특정요소에서 바뀔 것이다. . 기존까진 재귀메서드 -&gt; 자식호출후 depth(stack)이 변했을 때, 변수들에 depth+1도 업데이트시켜셔, 현재depth마다 padding이 계산되게 하였다. 이 때, 자식들 트리 순회하는 반복문내에서의 재귀호출마다, 다른정보가 발생한다면, 전체 재귀메서드의 파라미터로 올려 반영하게 할 수 있다. | . | . 일단 isEnd는 재귀메서드의 파라미터로 올려야한다. 새로운 변수를 재귀메서드 파라미터로 올리면, 재귀 최초인자 호출 for root에서 시작값을 입력해줘야한다. . root는 레벨선상 마지막이 맞으므로 true를 넣어준다. | . . . | 반복문 속 컬렉션(set)이라면, invariant(불가능한 상태 방지) 불변식인 .size()로 초기화한 변수를 반복문내에서 업데이트하며 사용한다(레벨선상 마지막 요소 찾기) . 만약 i = 0부터 시작해서 i++로 업데이트해나가며 찾는다면, if i == size() - 1메서드를 매번 호출해야한다. | 컬렉션에 대한 불변식인 i = size()를 변수로 빼놓고, 반복문내에서 --i로 업데이트해나가면 메서드를 1번만 호출해도되고 | 어차피 i–를 업데이트해야니, 1개 큰 것에서 시작하여 미리 까고 나서 그 변수로 확인한다 | . | 자바에서는 반복무내 .size()로 시작하는 인덱스가, 먼저까고 검사 인자에 넣으면, 단항연산자를 통해 뒤에 업데이트식이 없어진다. | . 자바에서는 반복문내 등차업데이트 변수라면, 1개 큰데에서 시작하여 --i, ++i등의 단항연산자를 통해 업데이트가 완료된 변수를 바로 사용하여, 업데이트 문이 없앨 수 있다. . size()-1( 마지막인덱스 )부터 시작한다고 치면, 시작부터 해당사항이 있어서 [검사후 업데이트해야한다 . | 인자로 true/false가 들어간다면, 조건식 자체를 메서드 인자에 넣자 . . | 만약, .size()의 +1 큰곳에서 시작하여 단항연산자로 먼저깐 변수를 사용한다면, 업데이트문이 없어진다 . . . | 조건문에서 자식동적트리에서 레벨선상 마지막요소가 호출시 True가 들어가게 되었다 . Main에서 이제 찍어봐야한다. | . . | 이렇게 마지막엔 트레일링콤마가 안붙게 되면, json으로 직렬화가 가능하다 . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/menu/composite/visitor/side/2022/07/30/menu%EB%A5%BC-%EB%A7%8C%EB%93%A4%EB%A9%B0-%EC%9D%B5%ED%9E%88%EB%8A%94-visitor%ED%8C%A8%ED%84%B4.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/menu/composite/visitor/side/2022/07/30/menu%EB%A5%BC-%EB%A7%8C%EB%93%A4%EB%A9%B0-%EC%9D%B5%ED%9E%88%EB%8A%94-visitor%ED%8C%A8%ED%84%B4.html",
            "date": " • Jul 30, 2022"
        }
        
    
  
    
        ,"post12": {
            "title": "variant variable(가변 변수)와 loop 리팩토링 정리",
            "content": "가변 변수 누적 반복문 [미리처리 + if문] 리팩토링 . 01 가변변수 누적 + 반복문내 모든 요소가 매번 하는 일을 미리 처리 . 가변변수 업데이트 이외에 [반복문내 모든 요소에 적용]할 게 있으면, 미리 적용하고 -&gt; 밖에서 적용하게해서 -&gt; 반복문 및 메서드의 파라미터를 바꿔라 . 누적 업데이트 하는 일과 vs 반환하는 일을 분리해야한다. . | 기존 . private static int convertAndSum(String[] values){ return sum(values); } private static int sum(String[] values) { int result = 0; for (final String value : values) { result += Integer.parseInt(value); } return result; } . | . 반복문내 모든 요소에 대해 Integer.parseInt( )를 해야한다면, 반복문 진입 전에 하고 -&gt; 반복문을 도는 파라미터를 미리적용한 결과값으로 변경해야한다. . . . | 미리하는 작업은 메서드 추출 -&gt; 파라미터 추출하여, 밖에서 일을 마치고 오게 위임한다 위쪽의 메서드의 결과물을 파라미터 추출하게 되면, 밖에서 일하게 하여 -&gt; 한번에 한 일만 하게 만들 수 있다. | . | 가변컬렉션(method -&gt; add)의 convert나 가변변수의 누적(+=)은 stream으로 바꿀 수 있다. . 가변 컬렉션을 convert후 add는 stream의 map -&gt; toCollect로 변경할 수 있음. . . . | 가변 변수의 누적계산은 .reduce( 기본값, 누적연산 메서드(람다식) )으로 대체할 수 있다. . . | . | 최종 . . | 02 가변변수 누적 + 반복문 + if의 처리 . for 문속 if는 추출해 depth 때문에 추출해야하는데, 누적되는 값은 [가변변수 + 업데이트 로직] 포함된 로직이라면, 가변변수를 return하니, [추출로직에 가변변수 없이 순수 업데이트값만 return하도록]변경하자. . 가변변수는 어차피 외부에서 업데이트되니, 추출메서드내 가변변수는 밖으로 빼자 . 기존 . . public class Lotto { private final List&lt;LottoNumber&gt; values; public Lotto(final int... rawNumbers) { this(toLottoNumber(rawNumbers)); } private static List&lt;LottoNumber&gt; toLottoNumber(final int[] rawNumbers) { return Arrays.stream(rawNumbers) .mapToObj(LottoNumber::new) .collect(Collectors.toList()); } public Lotto(final List&lt;LottoNumber&gt; values) { this.values = values; } public int calculateMatchCount(final Lotto other) { int matchCount = 0; for (final LottoNumber lotto : values) { if (other.contains(lotto)) { matchCount += 1; } } return matchCount; } public boolean contains(final LottoNumber lottoNumber) { return values.contains(lottoNumber); } . | . 반복문 내 if는 depth를 만드므로 추출(타객체라면 위임)해야한다. . 위임(추출)의 첫단추는 메서드()호출부를 더 위쪽 지역변수로 빼서 1개의 외부 context(파라미터)로 만들어야한다. | . . . | 이 때, return문 없는 로직인데 값을 반환하도록 추출되었다면, 위쪽의 가변변수가 포함된 것이다. . . . | 추출된 메서드에서 가변변수를 받아 return업데이트된 가변변수가 아니라 업데이트는 외부에서하고, 내부에서는 업데이트에 필요한 값만 return하도록 -&gt; 추출메서드 내부에서 가변변수를 삭제해보자. . if 만족시 업데이트이외에 if 불만족시 기본값으로 업데이트하여 return을 생각한다 . . . | 추출한 가변변수를 메서드 시그니쳐에서 삭제하고 업데이트된 가변변수 return이 아닌 업데이트할 값만 return하도록 수정한다. . 외부에서 어차피 존재하는 가변변수를 값만 받아 외부에서 가변변수 업데이트하도록 변경한다 | . . . . | | 가변변수 누적 업데이트시 [추출된 메서드의 반환값]이라면, [mapToInt 등]으로 변환하여 .sum()때리면 된다. . 외적으로 가변변수의 누적은 스트림으로 대체할 수 있다. . 일단 누적될 로직은 리팩토링해서 1개의 메서드로 모은다. . . . | stream으로 가변변수에 값을 누적한다면 . 원시값 누적이면 .reduce(0 , 연산람다식 ) | 변환된 값 누적이면, mapToXXX( ) -&gt; .sum()을 때리면 된다. | . . . | . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/refactoring/variant/variable/loop/refactor/%EC%A0%95%EB%A6%AC/2022/07/29/%EA%B0%80%EB%B3%80-%EB%B3%80%EC%88%98-%EB%88%84%EC%A0%81-%EB%B0%98%EB%B3%B5%EB%AC%B8-%EB%82%B4%EB%B6%80-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/refactoring/variant/variable/loop/refactor/%EC%A0%95%EB%A6%AC/2022/07/29/%EA%B0%80%EB%B3%80-%EB%B3%80%EC%88%98-%EB%88%84%EC%A0%81-%EB%B0%98%EB%B3%B5%EB%AC%B8-%EB%82%B4%EB%B6%80-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81.html",
            "date": " • Jul 29, 2022"
        }
        
    
  
    
        ,"post13": {
            "title": "Object)요일(묶음)별 계산(DayOfWeekCalc)을 Set<rule> rules로 구현(Plan8)",
            "content": "연속된 구간이 아닌 범주별처리 or 범주묶음별 처리도 Rule객체 소유 . 요일별 요금 계산(DayOfWeekCal) . call -&gt; interval -&gt; 특정요일 -&gt; 요일별로 따로 계산 | call -&gt; interval -&gt; 특정 시간대구간 -&gt; 미리 시간대구간별로 계산법을 쪼개놓은 prev데코객체를 for문을 돌면서 -&gt; 자기구간에 걸리면 처리하도록(연결되어있는 것이 마치 컬렉션)처럼 미리 요일별로 계산법을 쪼개놓은 class -&gt; 객체들(rows)을 만들어놓고, 반복문을 돌면서, 자기 요일이면 계산해서 반환하도록 한다. | 이 때, 단일 필드 1개 요일 하나하나 쪼개놔도 되지만, Set&lt;요일&gt; = 을 통해, 미리 쪼개놓기을 주중/주말로 짤라놔도 된다. | . | . 이미 정해져있는 범주별로 계산해줄 Rule객체를 만들고, 계산클래스는 Rule컬렉션(Set) 1개만 필드로 보유한다. Rule들은 자신이 처리할 대상이 맞는지 확인해야한다. . 이미 정해져있는 구간 / 범주별 처리는 개별처리해줄 rule객체 컬렉션or prev데코객체를 두고, 반복문을 통해 돌리고, 해당하는 처리들이, 자기몫만 계산하고 반환하게 한다. 이 때, 해당하지 않는 놈들도 있으니 ZERO반환하면서 누적되는 계산법이 필수다 . 필드로 연결되는 데코객체라면 -&gt; 단일 객체필드 1개만 소유한다. | 범주별 개별 처리하는 객체라면 -&gt; 모든 범주별처리 객체를 Set필드에 모아서 이것을 소유한다. 동적으로 변하는 것이 아니기 때문에 final필드 + 생성자 주입으로 Set필드를 초기화한다. | . | 미리 모든 경우의수를 다 쪼개놨기 때문에, 반복문을 돌며, 각Rule자신은 자신의 처리대상이 맞는지 확인기능도 포함되어야한다. | . | . Calc계산기와 이미 정해져있는 범주들을 처리해줄 모든 경우의수 rules 필드를 만든다. . . . | 기존 Calculator를 구현해서, 계산기능을 넣는다. . . | Rule객체의 class는 자신의 처리구간(요일) + 처리시 필요정보(단위시간과, 단위시간당 부과할 요금)를 필드로 가진다 . . . Rule객체는 처리할 대상이 범주1개가 아니라 범주묶음이라면, Set컬렉션필드를 가지면 된다. 자신이 처리할 대상이 1개의 범주라서 contains로 확인하면 된다. . . . Rule들을 소유한 Calc는 처리대상을 만들어주고, rule를 반복문 돌리되, 개별계산은 해당없을시 ZERO반환하여 바깥에서 누적계산이 되도록 한다. . . . 주의) 시간 구간처리시, 23, 59, 59의 가능성이 있다면, +1초 예외처리를 해줘야한다. . . rule 테스트 . . calc 테스트 . .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/rule/dayofweek/2022/07/22/%EC%84%9C%EB%A1%9C%EB%8B%A4%EB%A5%B8-%EC%9A%94%EC%9D%BC%EB%B3%84-%EC%9A%94%EA%B8%88(DayPrice)-%EA%B3%84%EC%82%B0(DayOfWeekCal).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/rule/dayofweek/2022/07/22/%EC%84%9C%EB%A1%9C%EB%8B%A4%EB%A5%B8-%EC%9A%94%EC%9D%BC%EB%B3%84-%EC%9A%94%EA%B8%88(DayPrice)-%EA%B3%84%EC%82%B0(DayOfWeekCal).html",
            "date": " • Jul 22, 2022"
        }
        
    
  
    
        ,"post14": {
            "title": "Object)하루 시간대별 계산(TimeOfDayCalc)을 prev데코객체로 처리(Plan7)",
            "content": "TimeOfDayCalc를 암묵적 index로 묶인 컬렉션필드 -&gt; prev데코객체로 처리하도록 변경하기 . 시작커밋 | . 구간처리를 해줄 prev데코객체 생성 및 필드 1개로 소유하기 . . . prev데코객체는 시작특이점객체로 필드초기화하니, 생성자는 정의해줄 필요 없이 체이닝setter로 받되, 매번 다음타자로 업데이트하고, 현재 rule을 prev필드에 저장하게 한다. . prev객체를 필드로 소유하는 클래스는, 생성자에서 받지 않고, 이미 내부에 시작특이점 객체를 가지고 있어서, setter를 정의해준다. . | 테스트코드가 돌아가도록 기존필드를 받는 생성자를 둔 상태에서, 생성자는 추가 선언이 되므로, 빈 생성자를 하나 추가해준다. . . | 테스트코드에서 (컬렉션은 아니지만 버금가는 연결 데코객체므로) addRule( )을 사용 생성하되, 다음 타자를 외부에 생성후 넣는게 아니라 다음타자 생성에 필요한 prev제외 나머지 정보 를 주어서 **prev소유 클래스 내부에서 필드로 가지고 있던 prev를 필드로 넣은 다음타자생성한 뒤, 다음타자를 필드로 가지고 있도록 setter를 정의한다. ** . test코드에서 사용 생성하면된다. . Rule 생성에 필요한 정보를 생성자 정의부 파라미터 복사해서 가져와 prev를 제외하고 넣어줘야한다. . . . | . | . | 다음타자를, 60초를 단위시간으로 10원씩 부과하며, 다음구간은 0시 출발이므로 2시까지로 한다. . . | 다음구간의 끝은, 무조건 직전구간보다 커야한다. . . . . | . 기존 전략메서드는 놔두고, public 기본메서드로 새로 작성후, 다음타자로 업데이트까지 필요한 틀을 잡는다. . . . prev데코객체의 개별처리 메서드는, 자신의to와 prev의 to로 인해 정해놓은개별구간만 처리하지만, 전체 처리할 구간을 duration으로 변형된 인자를 받는다. (Duration.ofSecconds()나 기존 start+end (localdatetime) -&gt; between()활용) . . . . [추가] 처리해야할 구간이 처음부터 시작안할 수 있다. 그럴 경우, a-b 구간을 = 0-b구간 처리 - 0-a구간처리로 나눠서 처리해야한다. -&gt; 물어보고 중간구간이면, 2번 계산후 차이를 구해야한다. (데코객체 자체가 0부터 시작하는 구간으로 인지하고 비교 등 연산하기 때문) . 먼저 처리해야할 구간을 가진 interval한테, 0부터 시작하는 구간인지 vs 중간구간인지 물어본다. . | 중간 구간이라면, 0~큰구간 과 0~작은구간을 가지고와서, 각각을 계산후 차이를 내야한다. . . | . prev데코객체들이 개별구간을 처리하기 전에 확인해야할 2가지 . 01 내 자신이 시작특이점은 아닌지 확인한다.(prev필드 == null) -&gt; 차후에는 외부 반복문 돌릴 때, 조건에 걸려서 없어진다. 처음 Rule객체 작성 및 테스트시에 넣는다. . 02 처리할 구간이 나보다는 작아도 되지만, 내 하한인 (prev의 to)보다는 커야 일을 한다. -&gt; prev데코객체 생성시에는 내 처리구간의 끝(to)를 LocalTime으로 받더라도, 연산은 0(시)부터 시작하는 구간으로 변환해야한다. . . . 03 쪼개놓은 모든 구간은 반복문으로 돌아가므로, 외부에선 값을 누적하고 있다면, 내가 일을 하지 않을 땐 누적0의 값을 반환하게 한다(thr X) . . 04 내가 처리해야할 구간이라면, 내 상한 vs 처리구간 상한을 비교하여, 실제 처리할 구간의 upperbound를 찾는다. 하한은 이미 prev의 상한으로 정해져있다. 이 때, localtime으로 상한을 받았으니, 메서드를 이용해서 0부터 시작하는 duration으로 변경해준다. . . . 05 [추가] localtime.of의 입력한계는 23, 59, 59인데, (1) 내 구간이 23, 59, 59를 담당하고 있고 (2) 처리해야할구간과 비교하여 정한 상한upperbound가 23, 59, 59까지 실제 처리해야한다면, Duration.ofSeconds(1)로 1초를 더해준다. . . . 06 실제상한 ~ prev상한으로 만든 하한의 구간 차를 duration으로 계산후, getSeconds()로 환산후 단위초당 요금을 부과한다. . . 07 백업한 전략메서드를 지우고, 구간처리로 바꾼 메서드로 대체한다. .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/decorator/prev/section/timeofday/2022/07/21/TimeOfDay(%ED%95%98%EB%A3%A8%EC%9D%98-%EC%8B%9C%EA%B0%84%EB%8C%80%EB%B3%84-%EA%B3%84%EC%82%B0)%EB%A5%BC-prev%EB%8D%B0%EC%BD%94%EA%B0%9D%EC%B2%B4%EB%A5%BC-%ED%86%B5%ED%95%9C-%EA%B5%AC%EA%B0%84%EC%B2%98%EB%A6%AC%ED%95%98%EB%8F%84%EB%A1%9D-%EB%B3%80%EA%B2%BD.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/decorator/prev/section/timeofday/2022/07/21/TimeOfDay(%ED%95%98%EB%A3%A8%EC%9D%98-%EC%8B%9C%EA%B0%84%EB%8C%80%EB%B3%84-%EA%B3%84%EC%82%B0)%EB%A5%BC-prev%EB%8D%B0%EC%BD%94%EA%B0%9D%EC%B2%B4%EB%A5%BC-%ED%86%B5%ED%95%9C-%EA%B5%AC%EA%B0%84%EC%B2%98%EB%A6%AC%ED%95%98%EB%8F%84%EB%A1%9D-%EB%B3%80%EA%B2%BD.html",
            "date": " • Jul 21, 2022"
        }
        
    
  
    
        ,"post15": {
            "title": "python decorator 작성 순서",
            "content": "데코레이터를 작성하는 순서 . 기본 데코레이터 만들기 . 01 기능을 입힐 base함수부터 작성한다. 이왕이면 print가 아니라 return하는 결과물이 있는 함수를 작성하여, 반환값에 대한 장식도 가능하게 한다. . . . 02 base함수를 (호출부없는)함수객체를 인자로 받는 클로져 함수를 사용-생성한다. 여기까지는 지역상태(메서드내부 인자 등)를 기억하는 함수객체를 return한 뒤, 외부에서 실제 인자를 받는 클로져가 된다. . 데코레이터는 장식할 함수를 일급객체로서 간주하여, ()호출부 없이 함수객체만 인자로 받으며 -&gt; 장식 후 -&gt; 다시 함수객체로 반환하는 클로져 형태를 띈다. | 대문자로 변경하는 장식을 할 것이므로, 데코레이터 메서드 명을 uppercase로 만든다. | . . . . 03 클로져 상태에서, base함수를 호출한 결과값을 장식해야한다면? 반환은 값이 되므로 함수객체를 반환하지 않게 되어, 클로져도 아니고 데코레이터도 아니게 된다. 그냥 값이 반환된 상태라서 외부에서 ()호출없이 끝난다. . . . . . 04 base결과물 장식 후, 클로져 상태(함수객체 반환)를 유지하기 위한 inner메서드 wrapper로 감싼 뒤, return wrapper함수객체 -&gt; 외부에서 호출될 함수로서, 함부러 파라미터를 내부context라고 파라미터로 만들면 안된다. -&gt; base함수의 인자에 맞춰야한다. . wrapper는 inner메서드이므로, context객체들을 그대로 사용하여 paramter로 뺄 필요가 없다.(외부호출시 사용될 메서드 객체기 때문에 파라미터를 함부러줘선 안된다.) . . . . | . 05 완성된 데코는, base함수에 @달아서 사용해주기 . . . . 06 다중데코레이터는, 외부에서 한번더 감싸서 만들고, 달 때는 아래-&gt;위 순서대로 단다. . . . . . 함수객체 name에 base함수가 찍히도록 디버깅되는 데코레이터로 바꾸기 by wrapper메서드에 @functools.wraps(func) 데코 달아주기 . 데코레이터를 입힌 base함수를, 함수객체.__name__을 찍어보면, 중간의 wrapper로 나온다. | 데코레이터의 wrapper함수에 @functools.wraps(func) 데코레이터를 달아줘야, base함수가 찍힌다. . | 만약, 2개의 데코레이터를 중첩적용하고 있고, 첫번째 데코만 처리해줬다면? -&gt; wrapper로 나온다. . . . . 2번째 데코레이터도 달아줘야한다. . . . | . | . base함수호출시 필요한 특정 인자를 외부에서 조달하려면, 외부에 return되서 ()가 붙는 함수객체 wrapper에 *args, **kwargs로 파라미터를 정의하여 어떤 인자든 들어오게 한다. . 데코레이터 함수 자체에 인자가 아니다(func만 받는다.) . | 마지막엔 return wrapper로 wrapper의 함수객체가 반환되므로 wrapper에 *args나 **kw args를 받도록 하면, 어떤 인자든 다 들어올 수 있다 . 들어온 인자를 그대로 사용하려면 *args를 base에서 그대로 사용한다. | 만약 콤마로 연결된 인자들이 들어왔는데, 반복문 등에 사용된다면 *를 빼서 패킹된 상태로 돌린다. | . | . 현재 base함수를 파라미터를 통해 문자열 인자 받도록 변경한다. . 그래도 바로 사용못한다. 왜냐면, 데코레이터에 감싸진 이상 wrapper가 반환되기 때문에 | wrapper는 인자를 안받는데, 왜 받고 있냐 물어본다. | . . | 외부에서 호출되는 wrapper함수에 base함수호출시 필요한 인자를 주되 *args, * *kwargs로 주어 어떤 인자든 받을 수 있게 한다. . args : 튜플로 패킹된다. . | *args: 받은 인자 그대로를 언패킹해서 사용한다. . 파라미터속 *args : 콤마 = 튜플로 넘어온 인자를 언패킹한 상태로 가지고 있다. 언제든지 *를 떼서 컬렉션형태로 사용할 수 있다. | . . . . | . | 역순으로 jwt 인증 decorator 작성 . 01 Route마다 매번 [token 인증 -&gt; 실패시 예외]의 검증하는 로직을 route에 반복 기술하는 대신 데코레이터로 만들기 . 참고 내 블로그 . 기본 데코레이터 만들기 01 기능을 입힐 base함수부터 작성한다. 이왕이면 print가 아니라 return하는 결과물이 있는 함수를 작성하여, 반환값에 대한 장식도 가능하게 한다. 02 base함수를 (호출부없는)함수객체를 인자로 받는 클로져 함수를 사용-생성한다. 여기까지는 지역상태(메서드내부 인자 등)를 기억하는 함수객체를 return한 뒤, 외부에서 실제 인자를 받는 클로져가 된다. 03 클로져 상태에서, base함수를 호출한 결과값을 장식해야한다면? 반환은 값이 되므로 함수객체를 반환하지 않게 되어, 클로져도 아니고 데코레이터도 아니게 된다. 그냥 값이 반환된 상태라서 외부에서 ()호출없이 끝난다. 04 base결과물 장식 후, 클로져 상태(함수객체 반환)를 유지하기 위한 inner메서드 wrapper로 감싼 뒤, return wrapper함수객체 -&gt; 외부에서 호출될 함수로서, 함부러 파라미터를 내부context라고 파라미터로 만들면 안된다. -&gt; base함수의 인자에 맞춰야한다. 05 완성된 데코는, base함수에 @달아서 사용해주기 06 다중데코레이터는, 외부에서 한번더 감싸서 만들고, 달 때는 아래-&gt;위 순서대로 단다. 함수객체 name에 base함수가 찍히도록 디버깅되는 데코레이터로 바꾸기 by wrapper메서드에 @functools.wraps(func) 데코 달아주기 base함수호출시 필요한 특정 인자를 외부에서 조달하려면, 외부에 return되서 ()가 붙는 함수객체 wrapper에 *args, **kwargs로 파라미터를 정의하여 어떤 인자든 들어오게 한다. . | . 001 src &gt; auth_jwt &gt; token_verifier.py 생성 . . 02 token인증(실패시 예외)을 데코레이터 만드는 방법(바깥에서부터) . route의 메서드가, 데코레이터의 decorator -&gt; warpper -&gt; base_func 중 basefunc을 차지하게 됨. | . 001 decorator는 ()호출 전의 base_func객체를 인자로 받아서 내부에서 호출하고, return은 func객체를 호출하고 실제 deco하는 inner method wrapper를 호출하지 않은체 반환하므로 [input:func(base_func) -&gt; output func(wrapper)]이다. . 참고 . . | . def token_verify(function: callable) -&gt; callable: . 002 inner method wrapper메서드는 [결과값을 deco당하거나 or 호출전후로 작업을 하고 싶은 base_func()]의 decorating 과정에서 -&gt; 외부 인자가요구하는 순간, wrapper method도 인자를 *args, **kwargs로 받는다. inner method인 wrapper는 decorator 맨 마지막에 호출하지 않은 체 반환되는 closure다 . 참고 . . | . def token_verify(function: callable) -&gt; callable: def decorated(*args, **kwargs): ## pre decoration # result = function() ## post decoration # post_decorated_result = result + @ # return decorated_result return decorated . 003 GET route에서 token인증을 위한 decode + 예외처리 했던 로직을 inner method warpper(여기선 decorated) 내부로 가져와서, [base_func (여기서는 route함수) 호출전 (1)TOKEN인증(==실패시 예외) + (2) TOKEN REFRESH 작업]을 항상 진행하게 해준다. . get route . . | 이동 . . | . 004 필요한 것들을 import하고, 수정해나간다 . auth_jwt &gt; token_verifier.py에 flaks관련 모듈이 import된다 | jwt가 import된다 | 싱글톤 token_creator도 import된다 인증 및 예외발생 route에는 없던 refresh를 해주기 위해 | . | . | . import jwt from flask import request, jsonify def token_verify(function: callable) -&gt; callable: def decorated(*args, **kwargs): raw_token = request.headers.get(&quot;Authorization&quot;) uid = request.headers.get(&quot;uid&quot;) # if not raw_token: if not raw_token or not uid: return jsonify({ &quot;error&quot;: &quot;Bad Request&quot; }), 400 try: token = raw_token.split()[1] token_information = jwt.decode(token, key=&#39;1234&#39;, algorithms=&#39;HS256&#39;) token_uid = token_information[&quot;uid&quot;] except jwt.InvalidSignatureError: return jsonify({ &quot;error&quot;: &quot;Invalid Token&quot; }), 498 except jwt.ExpiredSignatureError: return jsonify({ &quot;error&quot;: &quot;Token expried&quot; }), 401 except KeyError as e: return jsonify({ &quot;error&quot;: &quot;Invalid Token2&quot; }), 401 if int(token_uid) != int(uid): return jsonify({ &quot;error&quot;: &quot;User not permission&quot; }), 400 return decorated . 005 base_func인 function(route함수)는 wrapper(decorated)에서 [token인증 및 예외처리] 끝내고, 자신만 호출되면 되나? 인증안되면 예외발생하고, 인증되면 route 자신의 역할만 하면 끝?? . 시나리오 . route함수가, 인증 및 예외처리만 할 경우 -&gt; deco내wrapper내 token처리 끝나고 base_func()호출시 특별한 인자 없이 base_func( *args, **kwargs)로 return하고 끝낸다 . . . | route함수가, 인증 및 예외처리하고 REFRESH한 token이 새로 발급되어서, 이것을 인자로 받아갈 때 . . . | . | . 006 route함수가 decorator로 token인증을 거치는 경우, 인증성공시의 refresh된 token을 route함수 인자로 받아야하며, decorator작성시, base_func(route_func)은 *args**kargs 앞에 가장 첫 인자로 next_token을 추가해야한다 . . import jwt from flask import request, jsonify from .token_handler import token_creator def token_verify(function: callable) -&gt; callable: def decorated(*args, **kwargs): raw_token = request.headers.get(&quot;Authorization&quot;) uid = request.headers.get(&quot;uid&quot;) # if not raw_token: if not raw_token or not uid: return jsonify({ &quot;error&quot;: &quot;Bad Request&quot; }), 400 try: token = raw_token.split()[1] token_information = jwt.decode(token, key=&#39;1234&#39;, algorithms=&#39;HS256&#39;) token_uid = token_information[&quot;uid&quot;] except jwt.InvalidSignatureError: return jsonify({ &quot;error&quot;: &quot;Invalid Token&quot; }), 498 except jwt.ExpiredSignatureError: return jsonify({ &quot;error&quot;: &quot;Token expried&quot; }), 401 except KeyError as e: return jsonify({ &quot;error&quot;: &quot;Invalid Token2&quot; }), 401 if int(token_uid) != int(uid): return jsonify({ &quot;error&quot;: &quot;User not permission&quot; }), 400 next_token = token_creator.refresh(token) # route function # return function(*args, **kwargs) return function(next_token, *args, **kwargs) return decorated . 007 inner method wrapper메서드에 @functools.wraps( base_func )을 달아주면, 디버깅시 함수name이 같이 찍힌다 . from functools import wraps #... def token_verify(function: callable) -&gt; callable: @wraps(function) def decorated(*args, **kwargs): . 008 auth_jwt init에 올리기 . from .token_handler import token_creator from .token_verifier import token_verify . 03 token 인증필요 route(GET)에서 jwt 인증 decorator사용하기 . 001 jwt 인증 데코레이터는 base_func이 인자로 next_token을 받는 것을 가정했으니 -&gt; route함수는 token을 인자로 받아야한다 -&gt; return에도 받은 next_token을 반환해보자. . api_route.py | . #... from src.auth_jwt import token_creator, token_verifier #... @api_routes_bp.route(&quot;/secret&quot;, methods=[&quot;GET&quot;]) @token_verifier def secret_route(token): return jsonify({ &#39;data&#39;: token }), 200 . 002 POSTMAN에서 토큰생성 (POST) -&gt; 토큰 인증(GET) 해보기 . token 생성은 생성요청자 uid를 넣어줘야하는데, 여기선 하드코딩으로 넣어준다 . . . token 인증요청자는 token생성한uid와 동일해야하는데, (10Headers에 하드코딩으로 POST에 썼던 uid를 하드코딩해서 넣어주고 요청한다. 또한, (2) Authrization탭에 POST시 발급받은 token을 똑같이 직접 넣어줘야한다. . . . 003 인증요청자가 발급자와 다른uid를 가지고 있다면? @token_verify가 인증실패 -&gt; 예외처리를 잘해준다. (400, Bad Request인데, -&gt; 400, User not permission) . . . . uid를 입력안해도 (or 토큰이 없어도)예외처리를 잘해준다.(400, Bad Request인데 -&gt; 400에 No Authorized) . . . . token 맨끝에 1~2글자 지워도 잘 에러 내준다.(498, Invalid Token, -&gt; 401 Invalid Token) . . . .",
            "url": "blog.chojaeseong.com/python/algorithm/pycharm/decorator/2022/07/20/python_%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EC%88%9C%EC%84%9C.html",
            "relUrl": "/python/algorithm/pycharm/decorator/2022/07/20/python_%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EC%88%9C%EC%84%9C.html",
            "date": " • Jul 20, 2022"
        }
        
    
  
    
        ,"post16": {
            "title": "OBJECT 21 객체 작성 원칙 및 테스트 작성 요령 정리(마지막)",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . 객체 작성 원칙 . 메세지 전송 이유: 3가지 관계 . 객체망으로 해결한다: 객체로 메세지를 보내어서 해결한다 . | 객체 -&gt; 객체로 메세지를 보내는 3가지 기준 관계 . . 의존성으로서 전송하는 것인지 | 알림을 주기 위해 전송하는 것인지 | 조정을 하기 위해 전송하는 것인지 | | 대부분의 has-a관계(소유모델)은 delegate(위임)관계 때문이다. . templatemethod -&gt; strategy를 써서 delegate(위임)한다 | . | . 테스트와 객체설계 및 발견 . . 무조건 메인함수 or 테스트 코드부터 짠다. . 그래야 지구평화를 안지키고, 필요한 것만 짤 수 있다. | class를 사용하는 코드(인스턴스)부터 짠다. | input -&gt; output되는 객체부터 짠다. | . | 테스트를 작게 짠다. . 테스트 규모가 크다 == 값으로 짰다 or 단일책임원칙 실현안했다. or 의존성이 너무 심하다 | . | 처음부터 의존성 주입을 고려한다. . 생성자주입 or setter주입 2종류가 있다. | 주입할 수 있는 코드를 분리하여서 짜서 넣어본다. | 이것을 해보면, 밖에서 주입시의 제약조건을 확인할 수 있다. 인자로 인터페이스를 받아들이면, 해당 구상클래스들이 다 들어올 수 있게된다. 구상을 받으면, 1개 밖에 못넣는다. | . | 자바의 메서드의 인자는 반공변이다. 선언된 형의 자식들 밖에 못들어온다 가장 위쪽으로 파라미터를 선언해야한다. | typescript는 공변이라서… 더 위를.. 집어넣을 수도 있다. | . | 메서드 시그니쳐 짤 때 가장 중요한 것은, 이 함수가 외부세계에서, 얼마나 포괄적인 데이터를 받을 것인가를 결정하는 것이다. Object를 넣으면.. 다 받을 수 있다. | integer, boolean을 가장 밑에 기본형을 쓰면, 거기 밑에는 아무것도 없어서 값밖에 못받는다. | . | 객체지향에서 객체를 인자로 쓴다? -&gt; 값x -&gt; 좁은형을 안쓰겠다. 객체는 확장도 되니, 역할과 책임을 나타내기 위핸 객체로 나타낸다. 객체의 특징은 메서드에 있으며, 그 인자와 응답형에 의해 원하는 형을 넣어줘서 역할과 책임을 나타낸다. | 인자는 들어올 수 있는 상한을 정해주고, return은 하한을 정해준다. 그 위로만 받겠다. 최소한 하한형까지는 보장해준다. | . | 처음부터 의존성주입을 할 수 있는 메서드 인자로 만들어놓아서, 이것 저것 넣어보면서 확인하며 상한/하한을 정해나간다 | . | 목 객체 테스트를 해야한다. . 그래야 객체의 통신테스트를 할 수 있다. | context독립성 == 객체의 격리를 확인한다. | 아예 처음부터, 목객체를 왕창 만들어놓고, 얘는 a한테 뭘 받아서 b를 주는게 역할이야. 이런식으로 짠다. office한테 영화를 받아와서 customer에게 줄거야 | office와 customer의 목객체들을 만들어놓고 테스트하면서 만들어나간다. | . | . | 목객체 테스트 요령 . . 처음에 객체들을 만들어서 중복을 제거한다. 중복되는 부분들은 템플릿메소드패턴 -&gt; 전략패턴으로 빼서 다른 부분만 구현하고 본체만 남기도록 하게 한다 | Renderer의 경우, 단위 (구상)클래스 1개만 나오고, Visitor가 여러개 나오게 했다. 만약,전략패턴 같은 VIsitor로 빼지 않았더라면, ConsoleRenderer, JsonRenderer와 같은 제어문 속에 중복이 발생하게 된다. | . | . | 단일 책임 원칙을 구현하다보면, 부수적인 로직들은 도우미 메서드로 빠지게 된다. 도우미 메서드들은 Util클래스를 만들어서 static 메서드들로 때려박는다. | . | 도우미 메서드의 조직화 과정에서 종단점 도우미를 발견한다 (책 읽어야 할 수 있음) | 최종목표는 구현계층 vs 선언계층 나눠져있는 것을 모두 선언계층으로 옮기는 것이다. 보다 선언적으로 바뀌었다는 말 | Visitor객체는 보다 선언계층으로 옮겨간 것이다. 제어의 역전으로 제어구문을 뺏겨 인터페이스대로 메서드를 만들 수 밖에 없다 | 자유롭게 구현 vs 인터페이스 아래 선언된 메서드로 오버라이딩만 | 달라진 값밖에 줄 수 밖에 없다. | . | 선언적으로 바뀌게 되면, 팩토리가 되거나, 조립층에 DI가 들어가게 된다 | 디자인패턴들은 선언적으로 바뀌는 핵심적은 블록들이다. 다 의존성역전, 제어의역전을 만들어 선언으로 빼야한다. | 커맨드패턴 -&gt; 커맨드객체를 받아들이는 커맨드홀더객체(invoker객체)가 됨으로서 모든 메서드들은 필요없게 된다. | Visitor패턴 -&gt; 제어문을 완전히 한 쪽에다가 위임(Renderer)하고 나는 제어구조에 참여하는 메서드로 만든 다음, visitor가 된다. | . | . | 어댑터 계층 구현하기 . . 절대로 라이브러리 코드를 바로 쓰지말고 무조건 감싸서 써라 ex&gt; useEffect -&gt; useXXXEffect(어댑터)를 통해서 써라 | 외부충격을 흡수하는 어댑터를 만들 때부터 끼워서 써라 | 아무것도 안하는 path함수라도 만들어서 써라 jquery -&gt; jQ라고 함수로 감싸서 써라 jquery기능들을 바로 쓰지말고, 함수로 따로 만들어서 써라 | $함수 감싸기, attribute함수 감싸기, css함수 감싸기 | . | jquery가 시그니쳐를 바꿔도 충격흡수를 함수/클래스에서 해준다. | jdbc보다는 springjdbc가 더 낫다. 한번이라도 더 감싸진 것이 낫다 | . | . | 어댑터의 종류 3가지 1:1매핑해서 쓰는 단순한 어댑터 한번 감싸써 서드파티의 시그니쳐가 바뀌더라도 충격을 흡수하지만, 변경시마다 수정해줘서야해서 서드파티변경에 취약하다는 단점 | . | 델리게이터 어댑터 : 위임(델리게이터)를 추가한 것 이벤트를 받는다던지, 직접적인 관계들을 다 뺀 것 jquery를 아무리 감싸도 event를 걸면 직접적으로 연결된다. | jquery가 요구하는대로의 리스너를 만들 수 밖에 없다 | 하지만 델리게이터가 있다면, jquery이벤트 -&gt; 델리게이터의 이벤트 -&gt; 우리는 델리게이터가 요구하는 리스너를 주면된다. 델리게이터는 jquery가 원하는 리스너를 전달해주겠지만 | 그 안에는 우리가 준 리스너를 호출하는 코드가 들어가있고 안변한다. jquery를 리스너를 넘기면, jquery event를 인자로 받는 리스너인데, | 델리게이터 리스너 인자에 도우미객체 + native객체 2개를 받도록 만들어, 델리게이터는 jquery에게 jquery리스너를 주겠지만, 그 내부에는 내 리스너를 jquery리스너 형태에 맞게끔 변형해서 건네준다. | . | . | 도우미객체 + 원래 객체를 같이 jquery에게 건네주는 델리게이터? | . | . | 어댑터 레이어: 어려운 것.. 레이어 수준.. 시스템을 감싸서.. | |",
            "url": "blog.chojaeseong.com/object/%EC%A0%95%EB%A6%AC/2022/07/20/(object2-5)%EA%B0%9D%EC%B2%B4-%EC%9E%91%EC%84%B1-%EC%9B%90%EC%B9%99%EA%B3%BC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1-%EC%9A%94%EB%A0%B9.html",
            "relUrl": "/object/%EC%A0%95%EB%A6%AC/2022/07/20/(object2-5)%EA%B0%9D%EC%B2%B4-%EC%9E%91%EC%84%B1-%EC%9B%90%EC%B9%99%EA%B3%BC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1-%EC%9A%94%EB%A0%B9.html",
            "date": " • Jul 20, 2022"
        }
        
    
  
    
        ,"post17": {
            "title": "Object) prev vs next 비교 및 next를 컬렉션소유 전략패턴으로(Plan6)",
            "content": "prev데코객체 vs next데코객체 비교 . 공통점 . 같은형의 다음타자를 필드로 가지고 있어, 필요하다면 객체class내에서 꼬리재귀 호출(필드검사 터미네이팅 + 다음타자 꼬리재귀 호출) 가능하다. . 다음 타자를 필드로 가지고 있어서 데코객체 내부에서 꼬리재귀 호출로 다음 것으로 넘어가는 것이 가능하다. . 구간처리 prev . . | 기능추가 next . | . | 하지만, 재귀호출은 stackoverflow를 발생시키므로, 데코객체 소유 클래스에서 반복문 + 다음타자로 업데이트를 통해 실행한다. . | . 데코객체 소유 클래스는 1개의 필드만 가지고 있어도 연결된 모든 객체를 호출할 수 있다. . 데코객체 특징 자체가 다음타자를 필드로 소유하기 때문에 연결된 여러객체를 알 필요가 없다 prev . | next . . | . | . 차이점 . ### . 다음 타자를 업데이트 방식과 주체가 다르다. . 데코 소유 클래스는 필드 1개로만 소유하고 있으며, add(prev)나 void setter(next) 메서드를 통해, 다음 타자를 붙여야하는데 | . prev . prev는 마지막부터 실행될 예정이며, 소유클래스에는 시작특이점객체를 공유한다. prev를 소유하는 데코객체 소유 클래스는 시작특이점을 알고 출발하며, 이미 존재하는 prev를 prev필드로 넣으면서 다음 타자가 생겨나므로, prev를 들고 있는 [데코객체 소유 클래스]가 내부에서 다음 타자를 생성 + prev객체필드를 다음타자로 업데이트시키며, 최종에는 마지막 타자만 알게되어, 뒤에서부터 시작점까지 돌아간다. . 데코 소유 클래스는, prev데코객체의 시작특이점 객체로 초기화된 prev데코객체를 가지고 태어난다. . | 데코 소유 클래스는, 생성된 prev를 들고 있으므로, 자신의 내부에서 prev를 저장하는 다음타자를 생성하여, 알고있는 데코객체를 업데이트(재할당) 한다. . . | 그로 인해, 맨 마지막 타자부터 -&gt; 시작특이점까지 순환하게 된다. . . | . 요약: 다음타자 업데이트 주최는 데코객체 소유 클래스 + 애초에 시작특이점 객체를 prev로서 들고서 시작됨. . next . next는 순서대로 실행되기 위해, 외부에서 미리 다 연결된 상태로 시작데코객체만 공유하므로, 시작객체 생성시 모든 연결이 완료가 되어야한다. next라는 것은 아직 존재하지 않기 때문에, 생성자에서 받더라도, 실제 생성시 생성자 내부에서 next가 생성되어야하므로 생성자 체이닝으로 한번에 다 연결된 뒤, 시작객체가 반환되어야한다. next를 소유하는 데코객체 소유 클래스는 시작부터 끝(null)까지 아무것도 모른다. 또한, 넣어주는 시작next데코객체만 받아서, 처음부터 -&gt; 마지막까지 순서대로 순환한다. [next데코객체 자신이] 생성자or setter로 다음 타자를 받아들이되, 시작객체가 반환되어야한다. . next데코객체는 순서대로 시작되기를 원해, 시작데코객체만 반환되어 공유되므로, 소유클래스가 아닌 데코객체 자신내부에서 생성자체이닝이나 체이닝setter(next필드에 다음타자를 채우되, 반환은 나 자신 return this;가 되어야한다 . . | return this의 체이닝 받기는 setter를 호출한 나 자신이 반환되므로, 시작객체가 반환된다. . 데코 소유 클래스에서 들어가는 것은 시작데코객체인 BaseCalc만 들어간다. | . . | 체이닝으로 한번에 받지만, 아는 것은 시작데코객체 뿐 -&gt; 마지막 연결된 놈을 모르며 접근이 불가능하므로 prev때처럼의 동적기능추가가 안된다. . 시작객체가 반환된 상태인데, 또 next를 추가할 순없다. 미리 한번에 추가됬어야 하며, null로 끝내놓은 상태일 것이다. | null까지 모든 게 결정되어있을 때만 next데코객체를 써야하나보다. | . | next데코객체 소유클래스는 아무것도 모르고, **이미 다 연결된 데코객체만 받는다. ** . 이로 인해, 동적으로 추가가 안된다. | . . . | . 요약: 다음타자 업데이트는, 객체자신 내부에서, 시작부터 끝까지 다 받기 + 데코 소유 클래스는 시작next데코객체만 공유받음. . 실행순서가 다르니 용도도 다르다? . prev . prev는 끝을 모르지만, 시작은 아는 구간처리를 했었는데, 각 데코객체들이 개별구간을 정해놓고, 그곳만 처리하면 되니, 마지막부터 실행되어도 상관없다(게다가 필드의 prev정보가 있어 마지막부터 개별구간 처리해도 문제없다) . 마지막이 정해지지 않는 &amp; 순서대로 적용 안해도 되는 기능(계산 자체가 순서와 상관없이 특정금액 누적?) 추가 or 마지막이 정해지지 않는 구간을 미리 쪼개놓고 해당부분만 개별처리 하는 곳에 사용한다. -&gt; 마지막부터 실행되므로 순서대로 누적적용은 못하고, 개별구간 처리만 하되 for문에서 누적시키는 것을 생각하자. . next . next는 처음부터 시작하니 [직전까지의 결과값을 메서드 인자로 들고다니며 누적된 계산]을할 때 좋을 것 같다. -&gt; for문에서는 누적하면 안된다. . 처음부터 순서대로 마지막까지 누적 적용하고 싶은 곳에 [직전결과값을 들고 있는 메소드]로 사용한다. 대신 for문에서는 누적안하고 업데이트만 하게 한다. . 구상next데코객체 1개 소유 대신, 컬렉션Set필드에 전략객체 소유하기 . 시작커밋 | . 순서대로 누적적용 연산을 반복문(do-while)으로 할거면, 동적 기능 추가 안되는 구상next데코객체 소유 대신, 동적 추가 가능한 Set컬렉션 필드 소유와 for문으로 해결 . 반복문내에서 동적 기능 추가 안되는 next데코객체를 부를 거면 동적 기능 추가가 가능한 컬렉션(Set)으로 소유하고,객체 소유 클래스에서 add로 동적 추가가 가능하며, 순차적으로 누적적용 시킬 수 있다. | . | . 01 next데코객체의 추상체인 AbstCaclculator추상클래스를 전략 인터페이스로 변경하면서, next와 객체자신이 다음타자를 받는 체이닝setter 등 전략메서드만 남기고 다 삭제한다. . 더이상 다음타자를 next데코 객체 자신(시작객체가 전를 체이닝으로)이 안받는다 -&gt; 소유객체가 Set으로 받을 예정으로 순차적으로 동적기능 추가가 가능해진다. | 각 데코객체들은 다양한 기능만 가지므로 전략객체로 변경한다. | 템플릿메소드패턴 &lt;-&gt; 전략패턴 전환 정리글 참고 | . . . 02 전략인터페이스명으로 변경하고, 훅메서드 구현자식들(next데코객체class들)은 전략인페를 구현하도록 수정한다. . . . . . 03 전략주입 구상클래스(구, next데코 1개 소유 클래스)에서 필드를 Set컬렉션으로 변경후 -&gt; 실행기 반복문을 do while + getNext() + null터미네이팅로직을 -&gt; for문으로 바꾼다. . . . 04 전략주입 구상클래스가, Set필드에 동적으로 다음타자를 추가 + 체이닝 할 수 있도록 컬렉션필드에 체이닝setter를 만든다. . next데코객체의 체이닝setter는 필드가 1개 뿐이라 return this하는 순간, next의 추가는 어려워졌지만 컬렉션필드로 들고 있는 소유클래스의 체이닝setter로 동적으로 객체(기능)을 추가할 수 있다. | . | . . . 05 client에서는 전략주입 구상클래스의 필수로 1개를 넣어서 생성후 -&gt; set필드에 체이닝해서 편하게 전략객체들을 동적으로 받는다. . . .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/decorator/prev/next/section/2022/07/18/prev_vs_next_%EB%8D%B0%EC%BD%94%EA%B0%9D%EC%B2%B4%EB%B9%84%EA%B5%90_next%EB%8D%B0%EC%BD%94%EB%A5%BC_%EC%BB%AC%EB%A0%89%EC%85%98%EC%86%8C%EC%9C%A0_%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4%EC%9C%BC%EB%A1%9C.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/decorator/prev/next/section/2022/07/18/prev_vs_next_%EB%8D%B0%EC%BD%94%EA%B0%9D%EC%B2%B4%EB%B9%84%EA%B5%90_next%EB%8D%B0%EC%BD%94%EB%A5%BC_%EC%BB%AC%EB%A0%89%EC%85%98%EC%86%8C%EC%9C%A0_%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4%EC%9C%BC%EB%A1%9C.html",
            "date": " • Jul 18, 2022"
        }
        
    
  
    
        ,"post18": {
            "title": "Object) prev, next 데코객체 적용 예시(Plan5)",
            "content": "시작특이점을 아는 (동일형)prev데코객체 for 0부터 시작하는 구간처리 . 0부터 시작하는 연속된 구간을 받아, [미리 쪼개놓은 구간별 데코 객체들이 돌아가며 처리]하여 누적하는 계산기 . 10 ~ 12 / 12 ~ 14의 구간을 쪼개놓았는데, 11~13을 11~12 /12 ~13을 계산하는 방식이 아니다 . 0 ~ 14까지, 0~5, ~10, ~12, ~14 를 쪼개놓았더라도 | 11~13을 계산하는 것이 아니라, 0~2로 계산된다. | 즉, 중간만 계산못하고, 처음부터 구간만큼만 계산되는데 | 중간구간을 계산하고 싶으면, 0~13 - 0~11로 하면 된다. | . . | SectionPriceCalc . SectionPriceRule : prev로 연결할 데코레이터 객체 SectionPriceRule#calculateFee(duration): 데코레이터 실행기 | . | SectionPriceCalc#calculateFee(duration): 처리할 구간을 외부에서 받아와 구간별 계산해줄 메서드 | . | . SectionPriceRule#구간별 요금을 각자 구간만큼 처리해줄 시작특이점의 데코객체 . 구간처리 데코, 시작특이점을 아는 데코 객체는, 같은 형의 prev로 생성자로 받아 저장한다. 처리할 구간은 start는 없이 처음부터 ~ 끝to(처리구간전체)를 가지되, 내부에서 prev를 이용해 짜른다. . 구간별 요금 처리를, 구간별로 담당해줄 데코레이터 객체(-Rule)를 만든다. 각 구간처리 데코 객체들은 . 자신이 처리할 구간(시간: Duration)의 (처음부터~) to를 받으며 ,중간에 짤린 시작from은 안받는다. 소유할 prev객체로부터 prev의 to를 이용해서 짜를 것이다. | . | 자신의 구간에서 계산에 필요한 정보(돈) Money을 받는다. | 데코 객체 특이성으로서 자신의형의 prev(혹은 next)를 받아서 태어난다. 구간은 제일 처음( 구간0 )의 특이점 객체를 알기 때문에, 다음 타자는 prev를 받는다. 특이점객체는 연산을 하지 않는 꼬리재귀 종착역으로서, 그 타이밍에 현재까지 누적계산된 값을 반환한다. | 구간처리 데코 or 시작특이점을 아는 데코객체는 prev를 인자로 받아 생성된다. | . | . | . . 내가 처리할 구간은, 처음부터 시작되는 것 같지만, 변수명을 to로 하고 내부의 prev의 상한to를 이용해서 짤라서 처리할 예정이다. | . | 1개 데코객체의 구간처리는, 누적될 결과값을 반환하므로, prev가 null인 시작특이점 객체 검사(invariant) + 전체구간이 처리구간보다 짧은지 검사(precondition)검사 후 부적절시 0에 해당하는 결과값 NULL객체를 반환한다. . 구간처리 데코객체는, 전체구간을 받되, 각 데코객체별로 처리할 수 있는 구간을 짤라서 해당 부분만 계산해준다. . 처음부터 to의 끝만 정해진 처리구간을 가지고 있지만 내부에서는, 소유한 prev의 상한 ~ 내 상한큼만 계산해서 반환해준다. | . . | 구간처리 데코객체는, 내부에서 필수 invariant검사 및 precondition(전체구간) 검증을 해야한다. . 구간처리 데코객체의 1구간 처리는 전체 데코객체들을 돌고 있는 외부에 누적될 결과값을 반환할 것이다. | . invariant: prev는 시작특이점(연산X)가 아니여야한다. -&gt; 맞다면, 연산하지말고, 누적될 결과값을 NULL객체를 반환한다. | precondition: 들어오는 전체구간은, 내 하한인 prev의 상한보다 더 길어야한다. 같거나 더 짧으면, 내가 처리할이유가 없어서 누적될 결과값을 NULL객체를 반환한다. | . | 전체구간의 상한이 내 상한 안쪽인지 -&gt; duration이 상한 vs 내 상한보다 큰지 -&gt; to가 상한 을 확인한다. (시작이 구간 비교 == 상한 비교) . 시작이 0에서 시작하는 것으로 같으므로, 구간의 비교 == 상한 비교가 된다. . duration &gt; to : 내가 처리할 수 있는 끝인 to가 상한 | duration &lt;= to: duration이 상한 | | 상한이 결정되면, prev의 상한인 prev.to를 하한으로 하여 처리할 구간 결정한다. . . | 구간을 시간(초)로 바꿔서, 초당 가격을 곱하여 구간별 요금처리를 마무리한다. . . test# duration은 LocalDateTime 2개를 between으로 구한다. . . SectionPriceCalc#협력할 데코객체를 1개만 소유 + 다음타자를 생성하고 기존은 prev에 저장해서 누적 -&gt; 재귀형식으로 다음 객체에 저장하면서 마지막 타자만 가지고 있는 클래스 . 구간처리(시작특이점) 데코객체를 소유하여 협력하는 계산클래스는 시작특이점 객체를 1개를 미리 소유하고 있다. (어차피 변경될 필드이라서 final의 생성자 초기화는 불가능하다. 컬렉션처럼 빈컬렉션(시작특이점객체) + add로 받기기능 형태) . 생성자로 안받고, 내부에서 미리 필드 초기화해서 가지고 있다. . 생성자 type이 아니라 필드 type으로 초기화한다. 어차피 다음 타자 데코객체를 재할당해서 알고 있을 예정이므로 | . . | 시작특이점 객체로 초기화할 땐, 그것의 NULL객체들로 채워준다. prev는 null이어야한다. . . . | . 시작특이점 데코객체를 이용하는 클래스는, 데코객체를 필드로 1개만 소유하되, setter받기기능 메서드 호출을 통해 내부에서 다음타자를 생성하고 필드에 재할당한다. 이 때, 다음 타자 생성에 필요한 prev제외 필드정보들을 넣어줘야한다.(다음타자 생성에 필요한 정보prev가 내부에 있으니, 그외 정보만 받아서, 내부에서 생성해야한다.) . 다음 타자는, prev로서 rule필드값이 필요하므로, 그외 정보만 받아와서 내부에서 생성한다. . | 다음타자 정보들은, 내부정보를 이용하여 preconditino검증을 해야한다. . to(다음타자의 구간(상한)) : 예비 prev구간인 rule.getTo()보다 커야한다. | price : 계산 결과값을 0으로 만드는 NULL객체가 아니어야한다. | . . | . prev를 가지는 시작특이점 데코객체는, 다음 타자를 생성하여 후 1개 필드에 마지막 타자만 재할당해서 소유하면, 반복문을 통해, 마지막 타자 -&gt; 저장된 prev -&gt; 그것의 저장된 prev -&gt; 시작특이점 객체까지 소환할 수 있다. . 다음타자를 생성하고, 그 전 타자(현재 rule 필드)는, 다음타자 prev에 저장되게 한다. . | 마지막 타자만 rule필드에 소유하고 있으면 된다. 그 전에 것들은 다음 타자의 prev에 연쇄적으로 저장되어있다. . . | . 데코객체 다음타자의 개별구나 추가시 구간은 start없는 처음부터이므로 인자로는 Duraton.ofSeconds()등의 0부터 시작하는 구간을 준다. . 사용 : 아래는 잘못되었다, 입력은 start가 없이 end로서 처음부터 상한까지의 개별구간을 입력해줘야한다. . . . . | . 마지막 타자(rule필드)부터 시작하는 순차적 데코객체 loop실행기는, 현재 타자를 지역변수로 뺀 뒤, 처리 후 prev로 업데이트 해 나가되, do-while문을 사용해서 마지막타자부터 시작특이점 객체까지 개별처리를 누적한다. . 외부에서 전체 구간을 주고, 누적될 결과값을 초기값을 준다고 가정한다. . . | . 데코객체는 반복문 속에서 prev로 업데이트될 예정이므로, 누적 결과값 처럼, 반복문 위에서 지역변수로 빼서 재할당하며 업데이트 되어야한다. . . 현재 target 데코객체는, prev를 꺼내서 재할당 업데이트 한다. 그 prev(target)의 prev가 null이면, 시작특이점 객체라서, 연산없이 종료된다. (재귀, 데코객체 실행기 등의 종착역은 계산 안하는 곳이다.) . . 주의) 쪼개놓은 구간의 데코객체들은, 자기구간이 아니면 default값을 반환하니, postcondition에서 zero를 검사하면 안된다. . . 구간처리에서 중간구간을 계산하고싶다면, [0~중간구간 끝] - [0~중간구간 시작] 형태로 계산해야한다. . . my) 중간에 구간추가하는 로직 짜보기 . . . 시작을 모르지만, 끝이 정해진 (템플릿추상클래스) 구상 next데코객체 for 정해진 기능 추가 . 동적 기능추가를 next로 연결한 뒤, 꼬리재귀호출로 누적 적용하는 방법 . 서로 다른 기능을 가졌지만, 같은 형으로서 next에 받기 위해서는, 추상체아래 구상체로서 기능을 수행해야한다. 근데, next라는 공통필드를 가지므로, 추상클래스여야한다. . 일단 next를 첫번째 인자로 받고 생성자체이닝하는 구상 next데코객체들을 만들자. . 일단 next필드를 1번째 인자로 가질 첫번째 구상체 데코객체를 만든다. . 각 구상체들은 여러번 누적 적용시킬 것이므로, 직전 next데코객체의 계산 결과값을 인자로 가져야한다. 첫번째 인자로 줘야, 생성자 체이닝이 매끄럽게 나온다. | 괄호에서부터 줄바꿈한다. | . | 그외 자신만의 계산에 필요한 정보가 필요하나, 메서드에서 실제 계산로직 수행시, 생성자에서 받도록 추가 예정이다. 결과값은 메서드로 호출되어 메서드로 반환하니, 누적결과값변수는 여기서 안받는다. | . | 마지막 next데코객체라면, 연산을 하는 끝 특이점 객체로서 next로 null을 가진다. 시작특이점 객체는 구간을 처리하고, 그 구간이 0으로서, 연산이 없다. | 끝특이점 객체는 추가기능의 마지막으로서, 마지막인 자신의 연산까지 하고 결과값을 반환해야한다. | . | . . | 생성자 첫번째 인자의 파라미터를 next필드를 공통으로 가질 추상클래스로 주고 추상체를 만들고 상속한뒤, next필드에 받아준다. . . . . | 구상체들은 추상체의 next필드와 그 것을 받는 생성자를 공통으로 필요로 한다. -&gt; 하지만, 좋은 부모는 생성자를 쓰지 않으므로, [생성자 대신, not final 필드 + 체이닝setter로 변경후 public 템플릿메소드]로 올린다. . 공통필드(next)를 생성자에서 받던 자식들은, not final 필드 + 체이닝setter 조합으로 만들어서 public템플릿메서드로 올린다. . 생성자의 결과는 자기자신이다. setter후에도 자기자신이 나오려면, return this의 체이닝setter로 변경해줘야한다. | . | 추상클래스의 구상체들은, 공통 필드에 대해서만, 해당필드를 애초에 생성자에서 받지말고 필드 + setter조합으로 올리자!!! . | 체이닝 setter를 만드는 과정에서, 자동완성하면 -&gt; return this 대신, 파라미터가 나아가버리니, 수정해줘야한다. . . . . | setter를 pull members up으로 올리면, not final 필드도 같이 올릴 수 있다. . . . | 추상체로 메서드 등을 올리고 난 뒤에는, 좋은 부모의 조건을 확인해서 수정해준다. . . | 나머지 구상 next데코객체에서도 공통로직은 삭제한다 . . | . 구상 next데코객체의 소유해서 사용하는 class는 외부에서 setter체이닝(by null)이 끝나 완성된, 시작 next데코객체만 받는다. . prev데코객체처럼, 해당 데코객체 소유 클래스 생성 후엔 동적으로 기능 추가는 못한다. . 외부에서 체이닝을 통해 동적기능추가가 완료된 시작 next데코객체만 받는다. | . . . | . next데코객체 소유 클래스에서, 계산책임위임시 - 추상체에 public템플릿 공통메서드이자 모든 구상체들이 재귀호추할 [꼬리재귀함수]로서, 누적결과값변수를 포함해야하며, 초기값을 인자로 넣어서 호출되어야한다. . 올리는 메서드가, 단순 public 템플릿메서드가 아니라, 꼬리재귀로 호출될 public 템플릿메소드이다. | 계산에 필요한 정보 + 누적결과값 변수를 파라미터로 가질 것이며 -&gt; 최초호출시 누적결과값 초기값을 넣어 호출한다. | . . . next데코객체의 실행기 메서드의 2가지 선택지 -&gt; 꼬리재귀 or 반복문 . 둘다 돌아가면서 계산값을 누적결과값 변수를 업데이트하는 것은 동일하다 꼬리재귀 -&gt; 누적결과값을 파라미터로 가지고 다니며, 누적 전 초기값을 인자로 주고 호출 시작한다. return문에서 다음 next데코객체를 호출하며, 삼항연산자로 재귀문 첫줄처럼 nul로 터미네이팅한다. | 객체의 꼬리재귀는 객체내부에서 next필드의 메소드를 호출함으로써 다음타자를 부른다. | . | 반복문 -&gt; 누적결과값을 반복문내에서 update하며, 반복문 위에 update되는 결과값의 초기값을 지역변수로 선언한다. while문에서 null로 시작특이점 or 끝특이점 객체를 찾는다. | 객체의 재귀 데코객체를 반복문으로 만드려면, 데코객체 소유 클래스에서 돌려야한다. | . | | . 데코객체소유 클래스에서, 데코객체 실행기메서드내부에서, [훅메서드로 개별계산] 후 [업데이트된 누적결과값 변수를 null터미네이팅 + 꼬리재귀]로 호출하기 . 꼬리재귀를 호출할 next데코객체들의 추상클래스는, 현재 구상체 상태이며, 재귀호출로 다음 것으로 넘어온 상태임을 인지해야한다. 그래야, “나는 마지막 타자까지 넘어왔다고 생각하여 -&gt; next필드에 null이 차있으면 터미네이팅”도 쉽게 생각이 든다. . . 개별 데코객체들의 계산은 내수용형태의 훅메서드로, 누적 결과값 변수를 인자로 받았다가 -&gt; 반환받아 업데이트 한다. | . . 꼬리재귀 필수조건은 return문내 update된 누적결과값변수를 포함한 인자들로 다음재귀호출이며, 현재객체의 연산까지 마치고 누적결과값을 반환하고 싶다면, 연산후 return문내에서 삼항연산자로 null로 터미네이팅(종착역) 처리를 한다. . 꼬리재귀 필수족거return내에서 [삼항연산자]로 null터미네이팅(지금까지 누적결과값 변수를 반환) + next필드에 저장된 다음 next데코객체로 [업데이트된 누적결과값을 받아 꼬리재귀]를 호출한다 . . | . 각각의 훅구상체들의, 개별계산로직을 넣어준다. 개별구상체들 계산에서 필요한 정보가 있다면, 자식수준에서 생성자에서 주입받도록 정의하면 된다. . . . 중요! 오류수정: 꼬리재귀하는 구상next데코 객체들의 계산내부에 이미 기존 누적값 -&gt; 여기에 추가하는 누적의 성질이 존재하기 때문에, 구상next데코객체를 소유하는, 추상클래스의 재귀호출에서는 [누적계산완료된 결과값변수를 재할당 업데이트만] 해주면 된다. . . 구상next데코객체 자체 꼬리재귀 대신 객체 소유 클래스의 반복문으로 호출하도록 변경 . 값의 n -&gt; n-1의 메서드재귀를 메서드루프로 바꾸는것 과 달리, 데코객체의 꼬리재귀(자신class의 method내에서 다음객체를 바로 호출 + 데코객체의 메서드에 처음부터 누적결과변수 끝까지 달고 다님) -&gt; 데코객체의 반복문(외부에서 소유class가 데코객체를 다음타자로 업데이트 + 각 객체는 누적없이 자신의 연산만 처리함)으로 변경하는 것은 더 복잡하다. . . 구상next데코객체 소유 클래스(반복문이 생기는 곳)부터 수정 . 01 누적결과값을 가지고 다녀 매번 누적후 종착역(특이점) 도달시 한번에 누적결과값을 반환하는 로직을, 반복문위의 누적변수에 누적하기 위해 자기것만 계산하는 로직으로 바꿔야하며 객체는 자신의 계산만 반환후 객체 바깥으로 반환되어 누적되도록해야하므로, –&gt; 데코객체 소유 클래스에서 반복문을 형성하게 된다. . 기존 . 데코객체 소유 클래스 | 구상 next데코객체의 추상체 | . | 그러려면, 데코객체 소유class(Calculator)는 데코객체에게 (반복문이라면 초기값으로 줬던) 꼬리재귀 최초 호출 인자의 계산위임 -&gt; 인자에 있던 누적 초기값을 변수로 선언하고, 반복문내에서 next데코객체들도 직접 업데이트해주기 위해 업데이트변수로 초기값을 선언한다. . 데코객체들의 종특(다음타자를 필드로 저장)으로서 자신은 연산후, 자신의 정보를 통해 다음타자를 확인한다면, do-while문을 쓴다. | . . . | . 02 꼬리재귀 정의 파라미터 -&gt; 다음타자 꼬리재귀 호출의 인자를 보고 업데이트 로직을 가져와 반영한다. + for문이 아니므로, 다음타자로 넘어가는 업데이트 로직도 반영한다. + 더이상 데코객체가 누적을 안할 것이기 때문에, 반복문에서 누적해야한다 + 값객체라서 누적도 재할당으로 반영해야한다. . 오타: 아래 보라색 필드의 calculator가 아니라 업데이트될 직전 targetCalculator로 수정되어야한다. | . . . 03 구상next데코객체의 반복문 while의 종착역은 특이점객체(연산x, 필드만null)가 아니라, 자신의 연산까지 끝낸 상태이므로, 다음타자를 불렀을 때 null이면 종료한다. . prev는 종착역이 계산을 안하지만, 필드만 null인 객체라서, 업데이트된 다음타자의 필드를 ull이면 끝내지만 . prev는 종착역에는 시작특이점 객체가 존재하며, 필드로 null을 가지기 때문에, 다음타자의 필드 null을 검사한다. . 왜냐면, 시작을 null객체로 시작할 수 없기 때문에 구간0의 필드가null인 객체를 따로 잡았다. | . . | . | next는 특이점객체가 없으며, 업데이트된 다음타자가 null이면 종료다. . next는 종착역이 끝 특이점 객체 없이, 마지막까지 연산하고, 다음타자 자체가 null객체이므로 다음타자가 null인지를 검사한다 | . . | . . 04 누적된 결과값을 반환한다(필요시 postcondition검사) . . 구상next데코객체가 더이상 누적연산이 아니라, 자신의 차례에 자신의 연산만 하도록 변경 . 이미 밖에서 누적시키고 있으니, 구상next데코객체는 자신의 연산만 해서 반환해주면 된다. . 이 때, 직전까지의 누적값이 필요하면 인자로 받지만, 꼬리 재귀호출은 하지 않는다. | . . | . 01 꼬리재귀의 흔적인 return 속 종착역 + 다음타자 부르는 처리를 삭제하고, 자신의 처리(훅메서드)만 하도록 수정한다. . . . 02 이제 [for문에서 누적 + 개별next데코객체는 자기값만 반환] vs [for문은 업데이트만 + 개별next데코객체가 기존값을 받아 유지하면서 누적]하는 방법 중 1가지를 선택한다. . 현재는 현재까지의 계산결과에 누적하며 계산하는 로직이기 때문에 for문이 개별next데코객체가 누적완료한 값으로, 누적 결과값 변수를 업데이트만하는 것으로 유지하자. . next데코는, 직전까지의 계산후 업데이트된 결과변수를 인자로 받아 사용해야하므로 현재까지 누적된 결과를 가져오니, for문은 업데이트만 하자. | prev데코는, 구간처리에 쓰였는데, 계산메서드가 누적결과값을 변수로 받지않고, 자기 일만 하므로, 바깥의 for문에서는 누적을 해줬어야했다. | . . . | . 03 구상next데코객체는 넣어준 순서대로 next로 나아가긴 하나, 생성하는 순간, 현재 존재하니 않는 nxt다음타자도 생성자에서 실시간 생성해야하며, 끝 null까지 다 한번에 넣어줘야한다. 즉, 동적 기능 추가가 어렵다. (고전적인 데코레이터도, base기능을 생성자에 넣는, prev방식으로 바깥에서 직전타자를 감싸서 넣어줬다.) . . 고전적인 데코레이터 패턴도 prev데코객체 형식으로서, 다음타자자 생성시, 직전객체를 넣어주고, 마지막 타자로 업데이트하여, -&gt; 마지막 타자에 다음타자를 동적으로 추가가 가능하다 . 실제로는 다양한 기능을 가진 구상 prev데코객체로 표현하며의 | prev필드를 추상클래스가 가지고서, 각 구상체들은 부모가 정의해놓은 prev의 기능 호출 + 현재 구상체의 현재기능추가로 메서드를 오버라이딩해서 호출한다 우리는 구간처리에 있어서는 prev데코객체가 정보만 같은 형으로 구성되었었음. | . | . . . . . | . prev vs next 비교 . next 대신 컬렉션으로 연결 + 전략패턴으로 변경해서 사용하기 .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/decorator/prev/next/section/2022/07/16/prev%EB%8D%B0%EC%BD%94%EA%B0%9D%EC%B2%B4_%EA%B5%AC%EA%B0%84%EC%B2%98%EB%A6%AC_next%EB%8D%B0%EC%BD%94%EA%B0%9D%EC%B2%B4_%EC%88%9C%EC%B0%A8%EC%A0%81%EA%B8%B0%EB%8A%A5%EC%B6%94%EA%B0%80.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/decorator/prev/next/section/2022/07/16/prev%EB%8D%B0%EC%BD%94%EA%B0%9D%EC%B2%B4_%EA%B5%AC%EA%B0%84%EC%B2%98%EB%A6%AC_next%EB%8D%B0%EC%BD%94%EA%B0%9D%EC%B2%B4_%EC%88%9C%EC%B0%A8%EC%A0%81%EA%B8%B0%EB%8A%A5%EC%B6%94%EA%B0%80.html",
            "date": " • Jul 16, 2022"
        }
        
    
  
    
        ,"post19": {
            "title": "Object) 정책적용관련 객체들의 계약관계(Plan4)",
            "content": "계약 . 계약조건 4가지 . precondition: 전달받은 메세지(인자, 파라미터)의 검증 validation이라고 한다. | 인자들의 null검증 + 인자들의 상태(도메인)검증 if로 무시 with 불린flag 토해내기(my early return false;로 null검증) | ifThrow로 멈추기 with 메시지 | | 내가 만든 형 객체라면, 형에게 시켜 스스로 검증해서 죽도록하여, 묻지않아 변화의여파가 없어진다. | | postcondition: 전달할 메세지(결과값)의 검증 반환하기 전, 결과값을 검증하는 것은 도메인검증이다. | | class invariant: 메세지 처리전, 클래스의 상태값(필드)의 불변성(or 필수조건 확보) 검증 필드초기화 하지 않고 &amp; setter로 런타임에 받아서 초기화된다면, 그전에 null객체를 넣어 초기화 해주기 | 생성자type으로 초기화한다면, 생성자내에서 null검사하기 | | 위임된 책임의 context: 내가 계약조건을 검증하는지 확인 precondition위임: 발동은 받은 내가 해준다. | postcondition위임: 나한테는 코드가 안보인다. | | 계약조건 적용하기 . 시작커밋 . | Plan - Calculator(전략주입 구상클래스) - Calc(전략인터페이스) - 전략객체들 . Plan과 1차 계약자 Calculator의 pre/post/invariant를 체크한다. | 이후 계약의 전파를 생각한다. | . | . Invariant#Plan#setter로 초기화된다면, 그 전에 null객체로 미리 초기화해놓기 . setter로 주입받는 Calculator필드는 런타임 때 받기기능을 부르기 전에, calculateFee()를 호출한다면, NullPoint예외가 발생할 것이다. . . calculateFee()에 throws도 안달려있어서 NP예외를 예상할 수도 없다. | . | 이럴 경우, Calculator필드를 new Calculator()의 빈객체를 NULL객체로서를 임시로 넣어두면 되는데 . Calculator자체가 생성자를 요구하는데 안에 null을 넣어두면 된다? . Calculator 자체의 생성자 검증(invariant) 작성시시 걸린다 | | Calculator를 살펴보니, 자기가 일하는 것이 아니라 컬렉션필드를 돌면서 일처리를 하고 있으니, NULL객체용 아무것도 안받는 생성자를 추가해주고, 작동해도 빈 컬렉션을 for문으로 돌면 아무일도 안하고 그대로 반환해주니 괜찮을 것 같다. . . | . | Precondition#Plan#파라미터로 넘어온 인자의 null검증 by thr . 기본적으로 외부(package내 계약된 깨끗한 인자가 아닌)에서 넘어노는 인자는 만능키 null의 가능성이 있다. . Null일때는 if에 안걸리고 빠져나가면서 return false를 반환하도록 최소한 불린flagf를 반환하도록짠다. . null일때는 로직자체가 안걸리게 무시하고, != null일때만 로직을 통과하게 하던지 null일때 early return false;로 무시해도 된다. . . | . . | 불린flag반환없이 if Throw로 멈춰서 죽도록 null검증을 해도된다. . if로무시하며 불린반환하는 것보다 더 강력하다. | . . . | | . Precondition#Plan#파라미터로 넘어온 인자의 상태(NULL객체, 도메인)검증 by thr . calculator는 내부에 전략객체가 없는 것이 넘어오면 사실상 null의 객체다 . 도메인으로서 의미가 있을라면, 해당 도메인이 NULL객체와 같은 상태가 아닌 의미있는 상태를 가짐을 검증해야한다. . 실제로 해당객체의 필드들(상태값)들을 살펴보고 의미있는 상태임을 코드로 적는다. | Calculator는 내부에 가진 calcs(전략객체들)의 갯수가 1개 이상인 상태여야 한다. | . . | . . | 이렇게, precondition으로서 날아가는 메세지 객체는 자신에 대한 validation의 책임을 외부에 서비스로 제공해야하므로 자신의 상태에 대한 validation책임(메서드)이 늘어난다 . client에서 보이지 않지만 메세지로 들어가는 객체들은, precondition검증으로 쓰이는 내부 메소드가 많다. | . | . postcondition#plan#return해줄 결과값에 대한 도메인 검증(재료가 있을 땐, 결과값이 NULL객체가 아니어야한다) . . 객체는 직접 자기의 로직을 수행하기보다는, 메세지를 통해 적합한 객체에게 책임을 위임해서 시킨 뒤, 값을 받아오는 경우가 많다. 위임객체에 받아온 결과값도 반환하기 전에 도메인 검증해야만한다. . 검증하기 위해서는 지역변수로 받아서 확인한다 | 계산값은 calls가 1개이상인 경우에만 &amp;&amp; 0원이 되어선 안된다. calls가 0개인 경우는 0원이 나와도 상관없다. | . | 재료가 1개이상일 때는, NULL객체가 아닌 결과값가 나와야한다. | . . . | . precondition위임#Plan#인자 객체의 상태검증에, this context가 사용되지 않으면 묻지말고 시켜서 스스로 죽도록 코드를 옮기고 + 변화의여파를 없앤다. . precondition의 null검증은 메세지 객체에게 위임할 수 없다. 객체 대신 null이 들어오므로, 아예 다른 범주다. | . | 만약, 물어보고 여기서 죽인다? -&gt; 해당 객체가 변할시, 기존 물어보는 것 자체가 의미가 없어진다. 시켜서, 알아서 물어보고 알아서 죽으라고 한다. | my) 객체 자신의 상태검증은, 물어보고 여기서 죽일 이유가 없으니 스스로 죽게 만들면, 변화의 여파가 안오며, 내가 만든형으로서 검증코드가 그쪽으로 이동되는 효과가 있다 | . | 해당객체에게 시킬 때는 내수용 메서드로 추출 -&gt; 해당 객체로 이동 | . | . . . postcondition위임#Plan#결과값검증 과정에서 this context가 사용되지 않으면, 결과값 검증로직도 결과값 계산로직 내부로 위임한다. . this(현재class의 필드들)가 없으면, 나의 코드, 나의 메서드가 아니다. | . 결과값 검증 로직에 this가 사용되는지 확인한다. . 만약, plan의 필드들이 사용되었다면, postcondition은 그대로 두어야 하고, 처리전에 상태값들의 invariant부터 검증한다 . | 만약, plan의필드들(this)가 사용안되었다면, 결과값 계산로직 속으로 위임한다. . | 필드가 사용되었어도 계산위임된 메소드의 인자로 넘어갔다면, this로 안보고 결과값 검증 로직도 위임할 수 있다. . . | . . . | postcondition 검증이 안보인다면, 검증에 this가 사용안되서, 결과값계산로직 내부로 결과값 검증 로직이 위임됬음을 생각하자 . precondition에서 인자 상태검증은 this가 사용안되더라도, 명시적으로 호출은 해야해서 보인다. cf) 만약 안보인다면, 메서드 호출하는 인자에서 이미 검증된 인자를 보냈을 수도 있다. | . | . . pre/postcondition의 책임은 작성하고 나면, 대부분 위임받은 객체들이 가져가게 된다. 그 pre/postcondition검증 코드가 안보인다면, 이미 계약관계라고 생각할 수 있다. | . | precondition은 위임되더라도 받은쪽이 발동은 시켜줘야하고, postcondition은 위임한 객체 내부에서 처리되어 안보인다. . postcondition은 return해주는 쪽에서 다 처리해줘 | preconditiond은 받은 쪽에서 검증해줘 | | precondition위임#Calculator#외부Client가 아닌 계약자가 넘겨준 precondition의 상태검증은 애초에 계약자가, 삼항연산자 등을 통해 검증된 precondition을 넘겨주도록 계약조건을 명시할 수 있다. . Calculator는 계약자 Plan가 넘겨준 메세지의 상태검증을 직접하지말고, Plan에서 미리 검증된 인자만 넘겨주도록 할 수 있다. . 메세지 calls의 상태검증을 precondition으로 여기서 하지말고, 계약자가 건네주기전에 미리 검증해서 줄 수 있다. | . | 메세지가 1개이상만 넘어가도록, 외부가 아닌 계약자는 1개이상의 메세지만 넘어가도록 미리 검증하고 넘겨주는 계약내용을 추가할 수 있다. . . . | 삼항연산자도 ealry return형식으로 바꿔준다. . 1건이상이면 진행 -&gt; 0건이면 NULL결과값 반환 | . . . | 결과값 반환로직을 보고 계약조건을 확인할 수 있다. . calls가 0건이면 계약안함 -&gt; 1건이상일 때만 계약진행 | . | 메소드 위임으로 진행되는 계약은, 계약서의 제목일 뿐이다. 구체적인 계약조건들은 코드로 나타나있다. . . | . precondition위임-&gt;Invariant#Plan-&gt;Calculator#setter를 가져 runtime시 상태변화하는 책임위임객체(전략주입 구상클래스)는 생성(주입)시점 precondition 상태검증가 의미없어 -&gt; 해당객체의 계약된(위임된)책임메서드 호출시마다 invariant으로서 자신의 상태를 매번 검증하도록 위임하여 보장해야한다. . . Plan에 주입되는 Calculator 객체는, setter로 상태변화가 가능한 놈이기 때문에, invariant보장이 안된다 -&gt; precondition 상태검증은 의미없다 받은 해당 객체의 책임(계약)메소드 호출시마다 자신의 상태를 검증하는 invariant로 위임해서 처리한다. | . | . . . compile타임에 invariant가 확정되려면, 생성자type으로 초기화해야만한다 만약, setter type으로 상태변화가 런타임으로 미뤄진다면, 호출시마다 매번 invariant 검증을 해야한다. | life cycle처럼 순서를 가지도록 짜더라도, 중간에 메서드 호출을 빠트리는 것은 컴파일러가 확정시켜줄 수 없다. 런타임으로 미뤄진다면, 101번째 에러가 발생한다. 모든 경우의 수를 알아야하며, 매번 검사해야한다. | . | precondition#Calculator#계약자가 넘겨주는 깨끗한 인자가 아니라 외부에서 들어오는 인자라면 precondition검증(null 및 가진 상태값)을 해야한다. . . . 만약, 계약자가 넘겨준 인자라면 . 메세지 처리전, 나의 invariant를 검증한다. setter를 가져 상태가 변한다면, 상태검증을 매번해줘야한다. . | 계약자가 이미 검증된 인자를 넘겨주는지 확인한다. . | . | . 계약의전파precondition#Calc(전략객체들)#계약전파된 메서드는 precondition 검증이 없다. . Plan(계약자) - Calculator(계약메서드) - Calc(인터페이스) - Calc구상체들(계약전파 메서드) . 계약메서드 이미 검증된 메세지들을 받은 상태이며, 그것을 그대로 받았는지 확인한다. | . . calls는 1건이상의 좋은 인자 + result는 초기값으로 좋은 인자가 들어온다 하지만, Plan(계약자)와 Calculator(계약메서드)사이에만 최초인자가 계약된 깨긋한 인자로 들어감이 보장된다. | . | . | 계약메서드, 계약전파 메서드들은 public으로 유지되는 한, 계약자들 이외에 객체들이 호출할 수 있기 때문에, 좋은인자라는 보장이 없다. . 계약자들만 호출할 수 있도록 하려면 생성자는 public으로 외부에서 생성되도록 하되, 계약메서드들은 한 package내 internal로 처리해야한다. | plan은 public으로서 외부에서 호출되어야한다. | . | . 계약의전파precondition#package#계약된 좋은 인자 보장을 위해, 위임된 계약객체들의 계약된 책임메서드부터는 internal가시성을 이용하여 계약자에게 독점공급한다. 만약 public default의 인터페이스면 추상클래스로 변경한다. . . . 최초 계약자 Plan을 특정package plan을 만들어서 이동시킨다. . 패키지는 계약관계에 의해 이루어진다. | . . | 위임된 계약객체들도 특정package이동 후 메서드는 접근제한자를 지워 internal 가시성을 통해, Plan에 메서드를 독점 공급한다. . 패키지내 부를 수 있지만, Plan만 해당 메서드를 호출하는 것은 개발자가 통제한다. | . . . . 접근제한자가 없는 internal가시성을 보면 -&gt; package내 호출하는 쪽에 독점공급하겠구나 생각한다. | . | 다음 계약전파메서드를 보면, 인터페이스로서 가시성누수 문제로 인해 public으로 만들어야하는 제한이 있으므로 internal가시성 적용을 위해 전략패턴을 템플릿메소드패턴으로 변경한 뒤, public 템플릿메소드의 접근제한자를 삭제하여 internal가시성으로 변경한다 . 참고 내 블로그 글(전략 to 템플릿메소드패턴) . 추상클래스로 변경 및 전략메서드 삭제 . | 1개 구상체에 대해 추상클래스 상속 후, 개별구현 로직을 private내수용 메서드로 추출하여, 훅메서드를 만들어 올린다. 올린 메서드의 접근제한자를 final or protected abstract로 수정한다. . 개별로직만 존재하더라도, 템플릿메서드만 올리지말고, 해당로직을 다시 한번 메서드추출하여 공통로직 내부 개별로직형태로 만들어야, 템플릿메소드패턴이 된다. . | 만약, 공통필드가 있다면, 생성자가 아닌 setter를 만든 후 setter를 올리면서 필드를 올린다. . . | . . | 구상체들이 올라간 템플릿메소드 + 훅메서드를 구현하면서, 전략메서드를 내용만 복붙후 삭제한다. . 훅메서드 추출시, 특정 구상체에서 템플릿메서드로 넘어온 인자들이 사용안됬다면, ctrl + F6을 통한 시그니쳐 변경이 필요할 수 있다 | . . | | 이제 추상클래스의 템플릿메소드를 public이 아닌 internal로 변경하여, 추상클래스도 전파된 책임메서드가 독점공급되도록 한다. . . | . | 계약의전파precondition#package#계약의전파로 인해 같은 병행package를 유지하여 internal독점공급하는 것은 부모와 protected관계인 구상체들에게는 해당사항이 없다. 구상체들만 따로 내부package를 파서 넣어준다. . . . . 계약의전파postcondition#훅구상체들#postcondition검사는, 계약전파된 pre의 더 상위레이어 계약체결로 인한 생략과 달리, 매번 검증해야한다. . . precondition은 계약전파시, internal가시성을 통해 계약된 메세지들만 받아서 생략이 가능했다. | 하지만 postcondition(반환될 결과값 검증)은 매번 해야한다. | . 계약의전파postcondition#구상체들#계약전파 메서드의 postcondition을 검사하기 전에 결과값 계산시 사용된 상태값의 invariant를 먼저 검증하자. . 결과값 검증하기 전에, 내 필드값들이 눈에 밟혀서 invariant검증이 안된 것이 눈에 밟혀야한다. | . . 계약전파 메서드들의 precondition은 가기성확보로 좋은인자가 확보되어어 생략했지만, postcondition은 검사해야하는데, 그 전에 계산에 사용된 보라색 상태값들의 invariant부터 NULL/상태 검증하자. . price는 Money형으로서 NULL검사 외 상태검증(0원이하면 의미 없음)을 검증해야한다. . . . 내가 만든형이므로 스스로 죽도록 묻지않고 상태검증을 시킬 수 있다. | . | second는 Duration형으로서 NULL검사 외 상태검증(0초이하면 의미없음)을 해야한다. . . 외부객체이므로 새로운 wrapper형을 만들 것이 아니라면, 물어서 검증해야한다. | . | . . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/contract/plan/precondition/postcondition/invariant/package/2022/07/14/Object_contract_plan4.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/contract/plan/precondition/postcondition/invariant/package/2022/07/14/Object_contract_plan4.html",
            "date": " • Jul 14, 2022"
        }
        
    
  
    
        ,"post20": {
            "title": "SIDE)정책 누적 적용하기(메서드체이닝)",
            "content": "정책 누적 적용하기(메서드체이닝) . 지난글 - SIDE)특정객체에 정책적용 . | 시작커밋 . 현재 전략주입 구상클래스가 1개의 factory(전략객체)만 받는 상태다. | condition전략은 여러개 받는 상태다. | . | . 필수로서 1개의 전략객체는 생성자 주입 받도록 유지하되, 받는 필드를 컬렉션(Set)으로 변경하고, 빈 컬렉션 초기화후 생성자에서 할당이 아닌 add하도록 변경한다. . . | 추가 전략객체를 받기기능(setter/add)로 받되, return this를 통해 외부에서 체이닝으로 받을 수 있게 한다. 메서드명은 setNext()를 활용한다. (condition도 받으려고 addPolicy로 변경함) . 여러 구상체를 return this의 외부에서 체이닝으로 받으려면, 컬렉션 필드가 필수다. cf) 빌더패턴은 여러필드에 대한 서로 다른 받기기능들을 체이닝으로 사용한다. | . | . . . | 컬렉션 필드에 누적된 전략객체들을 for loop를 돌면서 전략메서드를 누적변수에 누적 적용한다. . 파라미터로 초기값이 변수가 넘어왔다면, 누적변수로 활용하는 센스 | . . . | condition전략도 컬렉션필드로 여러개를 받으므로, 체이닝으로 받을 수 있게 return this를 활용한다. . . | 테스트에서 할인policy가 누적적용이 잘되는지 확인한다. . . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/policy/side/hospital/2022/07/13/(side)%EC%97%AC%EB%9F%AC-%EC%A0%95%EC%B1%85%EC%9D%84-%EB%88%84%EC%A0%81-%EC%A0%81%EC%9A%A9.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/policy/side/hospital/2022/07/13/(side)%EC%97%AC%EB%9F%AC-%EC%A0%95%EC%B1%85%EC%9D%84-%EB%88%84%EC%A0%81-%EC%A0%81%EC%9A%A9.html",
            "date": " • Jul 13, 2022"
        }
        
    
  
    
        ,"post21": {
            "title": "Object)중복로직제거 Strategy to Templatemethod(Plan3)",
            "content": "전략패턴 to 추상 템플릿메소드패턴 for 전략객체 중복코드(실습) . . 해당 커밋 | 전략 to 추상템플릿패턴 방법 정리 전략인터페이스를 추상클래스로 변경하고, 전략메서드를 삭제한다. | 구상체(전략객체) 1개를 택하여, 추상클래스를 상속후, 중복되는 필드(next)를 생성자 삭제후 setter 먼저 만들어 같이 올린다. 올라온 필드는 privte을, 템플릿메소드도 final을 달아준다. | 다른 전략객체들도, 추상클래스를 상속하고, 삭제된 중복필드 및 생성자주입부를 삭제한다. | 구상체들을 compare files이후, 인자로 넘어온 객체context를 많이 사용하는 구상체를 택하여, 예비훅메서드를 private내수용 메서드로 추출한 뒤, 공통로직을 가진 전략메서드를 템플릿메서드로 올린다. | 다른 구상체들은 올라간 템플릿메서드와 훅메서드에 대해, 훅메서드를 구현하여, 전략메서드 중 개별로직을 붙여넣고, 전략메서드를 삭제한다. | 추상클래스가 좋은 부모인지 확인한다. (private필드, final메서드 or protected abstract 메서드) | 연결되는 합성객체인 경우, setter에 return this + 추상체 응답이후, client에서는 생성자체이닝처럼 setter를 체이닝한다. | | . 전략적용객체(Plan)에 주입되는 추상체를 전략인터페이스 -&gt; 추상클래스로 변경하고, 구상체에서 템플릿메소드로 올릴 예정이므로 전략메서드 오퍼레이터는 삭제한다. . . . | **구상체(기존 전략객체) 중 1개를 선택하여, 추상클래스를 상속 후 -&gt; 중복되는 필드 + setter 메서드를 올린다. ** . 이 때, 생성자 주입 상태라면 setter를 먼저 만들고 setter 주입으로 변경(생성자 주입 삭제)해서, setter메서드를 올리면서 필드를 같이 올린다. | 올라간 필드는 private을 통해 자식이 변경못하도록 막는다. | . . . | 다른 구상체들도 모두 추상클래스를 상속하고, 생성자 주입부분 + 공통필드를 삭제한다. . | 각 구상체들의 개별로직을 compare files로 확인이후 전략메서드로 넘어온 인자들을 내부context라 생각하고, 가장 많은 인자를 사용하는 구상체를 택하여 훅메서드생성을 위한 개별로직을 private내수용 메서드 추출을 해놓고 템플릿메소드로 올린다. . 이 때, 내수용 private메서드 추출시, 템플릿메서드 파라미터를 기준으로 하여 필요한 인자를 가장 많이 사용한 구상체를 기준으로 private 예비 훅메서드를 만들어야, 나중에 인자가 모자라지 않는다. 템플릿메소드가 부모context이며, 그 파라미터들이 훅메서드가 인자로 가질 수 있는 객체context임을 생각해야한다. | 그외 보라색 내부context로직들은 내수용 private내부 훅메서드에 추출되어도, 추상템플릿으로 올린 뒤, @Override protected 개별구현 훅메서드로서, 내부context로 개별구현하게 된다. | . | . . . . | 나머지 구현체들은 올라간 훅메서드들을 구현하면서, 기존 전략메서드 속의 공통로직을 제외한 개별구현 로직만, 훅메서드로 옮긴후, 전략메서드를 삭제한다. . . . . . | 생성된 추상클래스는 좋은 상속의 부모로서 변수는 private, 메서드는 final or protected abstract, 생성자없이 setter로확인하여 달아준다. . . . | 부모클래스로 올릴 때 삭제한 생성자 주입으로 인해, next필드에 다음 전략객체 주입시, 변수로 먼저 선언후 setter메서드 호출()까지 해야하는 번거로움이 생긴다. . 생성자 주입은 setter메서드호출을 안해도 되니, 따로 변수로 선언후 호출하는 번거로움은 없었다. | . . . | next필드로 연결되는 합성객체용 생성자 주입 대신, void setter를 가진 추상클래스에 [구상층 객체별 체이닝 받기기능]으로 대체하기 . 생성자 단계별 주입 방식이 아닌 형태로 객체별 체이닝 받기를 시행하려면 (호출주체객체 == 응답형자리에 자신class응답 )1개 class 모아서 받는다면 -&gt; 매번 변한 상태의 객체를 return this한다 | (구상층들은 같은 class가 아니더라도 1type 응답가능하므로)각 class의 필드에 다음 객체 받는다면 -&gt; 응답형은 추상체 + return this(구상체)한다 여기서는 각 전략객체별로 다음 타자를 받도록 한다. | . | | . 현재는 각 전략객체별로 void setter받기기능을 이용해야하므로 변수로 빼서 받기기능()을 호출해야한다.(문제점) . . | 원하는 방향은, 생성된 전략객체를 지역변수 추출없이 [객체별 체이닝 받기기능]을 구현하고 싶다. . . . | 대신 이렇게 구현할 경우, 변수가 없으니 외부에서 받아놓은 객체들을 직접적으로 접근하는 것이 힘들어진다. . | next필드용 생성자 체이닝을 대신하는 void setter를 [구상층 객체별 체이닝 받기기능]으로 만들기 (실습) . 구상체 1개만 들어가는 자리에 .setNext()를 호출하여 빨간줄을 만들고 void setter -&gt; 추상체 setter로 시그니쳐를 변경한다. 자동완성시, return this가 되는지 확인하고 변경해준다. . 변수 추출후 setNext()는 빨간줄이 안만들어진다. void라서, 만들려면 좌측에 추상체 변수에 할당해서 만들어야 체이닝 받기의 형이 틀림의 에러가 뜬다. 에러의 확인은 Ctrl + F1의 Error Description을 활용한다. | . | . . . | 체이닝 받기시, 1개의 객체가 변화하면서 다 받는 구조가 아니므로 메서드 체이닝을 하면 안된다 . 조심) 1개의 class내부에서 1개의 객체가 연속해서 받는 것이 아니므로 진정한 메서드 체이닝이 아니라 new 1번재객체().setNext( new 2번째객체().setNext() )로서 생성자 체이닝 모양이다. **1개 객체가 연속해서 체이닝하여 받는 경우 -&gt; 변화된 객체를 반환하므로 메서드호출 끝나고 체이닝하지만, ** | 여기서는 new 객체 생성() 하자마자 .setter로 다음타자 넣어준 객체를 생성자에 넣어준다는 느낌이므로 마치 생성자 체이닝과 같은 형태가 유지되어야한다. | . | 만약, 메서드체이닝을 해버리면, return this되는 첫번째 객체의 next에 들어가는 객체만 돌아가면서 바뀐다. | . . . | 연결되는 합성객체를 가지는 추상템플릿메서드패턴 -&gt; 여러개의 전략객체를 가지고 누적용시키는 전략주입 구상클래스를 가지는 전략패턴으로 변경(실습) . . 시작커밋 . | 추상클래스는 객체화 될 수 없어서, 공통필드next를 한 곳에 모아서 사용할 수 없다. 개별 구상체들이 next를 소유하는 방법을 버리고 -&gt; 1개의 구상클래스가 컬렉션필드를 가지고 모으는 구조를 구상클래스를 가지는 전략패턴을 통해 구현 가능하다. | . | next필드를 각 구상체마다 가지려면, 데코레이터 패턴의 생성자 체이닝이나 setter체이닝을 해야만한다. **템플릿메소드 -&gt; 전략패턴으로 변경하면서 생기는 전략주입 구상클래스는 적용할 전략객체들을 모아서 누적 적용시킨다. ** | . | 템플릿메소드 패턴 -&gt; 전략패턴 변경 방법 정리 . 전략적용대상의 class가 추상클래스로 개별로직을 가지는 상태 | . 추상class를 일반클래스로 변경 및 훅메서드 정의부 삭제 -&gt; 훅메서드를 alt+del로 삭제하면, 구상체들의 개별로직이 재활용안되므로 그냥 삭제한다. | 내수용 private훅메서드 호출부를, 주입된 전략객체.전략메서드()호출로 변경 -&gt; 전략객체명은, 전략메서드(구 훅메서드)를 바탕으로 or로 만드는게 일반적이다. | 전략 인터페이스 만들고, 전략메서드를 올린다. | 전략객체를 생성자 주입받는다 (생성자 or 확장(좋은 상속 가능성)있으면 setter로 받기) -&gt; 일단은 1개만 필수로 받도록 생성자 주입 받는다. | 훅메서드구현 개별자식들을 [구상내용+전략인페명]으로 변경하고, 전략인터페이스 구현시킨다. | @Override 개별구현 proected훅메서드 -&gt; public전략메서드로 시그니쳐 변경 . | 전략주입 구상클래스가 된 부모클래스의 템플릿메소드 공통로직 with 내부 context변수들 -&gt; 전체를 전략메서드에 인자로 context위임 내부context변수들(보라색)을 지역변수로 추출 이후 -&gt; 제외하고 메서드 추출 -&gt; 인라인으로 메서드인자로 context 넘겨주기 | . | delegate로 추출한 전체로직을 전략메서드에 default메서드로 위임 | 위임된 default메서드 로직에서, default를 지우고 로직을 개별 전략객체들에게 구현-&gt;전달후, 기존 전략메서드(context인자X)는 삭제 . | 전략주입 구상클래스가 여러개의 전략을 받는다면, Set컬렉션 전략객체 필드를 만들고 1번째 전략객체는 필수로서 생성자 주입 받되, add해준다. | 2번째 전략객체부터는 setter로 add하여 받는다.(setNext()) 만약, 메서드 체이닝으로 받고 싶다면, add 후 return this로 컬렉션필드를 가진 구상클래스를 반환해서, 체이닝하여 계속 받도록 하면 된다. | . | | 전략객체를 사용하는 기존 템플릿메서드에서, for문으로 컬렉션필드를 돌면서 누적적용해준다. | client에서 전략주입 구상클래스에 1번째 전략객체는 생성자 주입 -&gt; 2번재부터는 setNext의 메서드체이닝으로 전략객체들을 받아준다. | 전략적용객체에는 전략주입 구상클래스를 set해줘야한다. | . | . 추상클래스를 일반클래스로 내리고, 훅메서드 정의부를 단순삭제한다. . . | 내수용 훅메서드 호출부를 생성자 or setter 주입받을 전략객체 (소문자)필드로 채운 뒤, 전략인터페이스를 생성한다. . . | 전략객체를 일단 1개는 필수로 생성자 주입 받는다. . | 훅구상체들의 class명을 [구상내용 + 전략인페명]으로 변경하고, 전략인터페이스를 구현하도록 변경한다. . . | @Override + proected의 훅메서드를 -&gt; public 전략메서드로서 개별구현하도록 접근제한자를 바꿔준다. . | 전략주입 구상클래스가 된 부모클래스의, 템플릿메소드 로직 중, 전략메서드로 넘겨줘야할 부분이 남아있으면 SRP원칙에 맡게 메서드추출하여 넘겨준다. . 여기선 없다. 여러 전략객체 적용부만 남은 상태 | . . | 전략주입 구상클래스가 여러개의 전략을 받는다면, Set컬렉션 전략객체 필드를 만들고 . 1번째 전략객체는 필수로서 생성자 주입 받되, add해준다. | 2번째 전략객체부터는 setter로 add하여 받는다. 만약, 메서드 체이닝으로 받고 싶다면, add 후 return this로 컬렉션필드를 가진 구상클래스를 반환해서, 체이닝하여 계속 받도록 하면 된다. | . | . | 모은 전략객체 컬렉션필드를 돌면서, 구 템플릿메소드 현 전략객체 호출 메서드를 누적적용해준다. . . | client에서 전략주입 구상클래스에 1번째 전략객체는 생성자 주입 -&gt; 2번재부터는 setNext의 메서드체이닝으로 전략객체들을 받아준다. . 전략적용객체에는 전략주입 구상클래스를 set해줘야한다. | . . . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/strategy/templatemethod/plan/connectobject/2022/07/12/Object_strategy_to_template_for_duplicate.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/strategy/templatemethod/plan/connectobject/2022/07/12/Object_strategy_to_template_for_duplicate.html",
            "date": " • Jul 12, 2022"
        }
        
    
  
    
        ,"post22": {
            "title": "Object) 전략 ↔ 템플릿메소드 패턴 전환 정리",
            "content": "템플릿메소드패턴 to 전략패턴 . 만약, 템플릿메소드의 자식이 주입되는 전략주입 구상클래스가 이미 존재하는 상황이고, 템플릿추상클래스가 [훅구현 자식들의 기능]외에 공통로직이 없는 상황이면, 추상클래스를 인터페이스로 변경후, 훅메서드 정의부(proteceted abstract) -&gt; 전략메서드 정의부로 변경(public)로 변경해서 남기고 다 지운 뒤, 바로 5번으로 가면 된다. | 추상class를 일반클래스로 변경 및 훅메서드 정의부 삭제 훅메서드를 alt+del로 삭제하면, 구상체들의 개별로직이 재활용안되므로 그냥 삭제한다. | . | 내수용 private훅메서드 호출부를, 주입된 전략객체.전략메서드()호출로 변경 전략객체명은, 전략메서드(구 훅메서드)를 바탕으로 or로 만드는게 일반적이다. | . | 전략 인터페이스 만들고, 전략메서드를 올린다. | 전략객체를 생성자 주입받는다 (생성자 or 확장(좋은 상속 가능성)있으면 setter로 받기) 일단은 1개만 필수로 받도록 생성자 주입 받는다.(base) | . | 훅메서드구현 개별자식들을 [구상내용+전략인페명]으로 변경하고, 전략인터페이스 구현시킨다. | @Override 개별구현 proected훅메서드 -&gt; public전략메서드로 시그니쳐 변경 . | 전략주입 구상클래스가 된 부모클래스의 템플릿메소드 공통로직 with 내부 context변수들 -&gt; 전체를 전략메서드에 인자로 context위임 내부context변수들(보라색)을 지역변수로 추출 이후 -&gt; 제외하고 메서드 추출 -&gt; 인라인으로 메서드인자로 context 넘겨주기 | . | delegate로 추출한 전체로직을 전략메서드에 default메서드로 위임 | 위임된 default메서드 로직에서, default를 지우고 로직을 개별 전략객체들에게 구현-&gt;전달후, 기존 전략메서드(context인자X)는 삭제 . | 전략주입 구상클래스가 여러개의 전략을 받는다면, Set컬렉션 전략객체 필드를 만들고 1번째 전략객체는 필수로서 생성자 주입 받되, add해준다. | 2번째 전략객체부터는 setter로 add하여 받는다.(setNext()) 만약, 메서드 체이닝으로 받고 싶다면, add 후 return this로 컬렉션필드를 가진 구상클래스를 반환해서, 체이닝하여 계속 받도록 하면 된다. | . | | 전략객체를 사용하는 기존 템플릿메서드에서, for문으로 컬렉션필드를 돌면서 누적적용해준다. | client에서 전략주입 구상클래스에 1번째 전략객체는 생성자 주입 -&gt; 2번재부터는 setNext의 메서드체이닝으로 전략객체들을 받아준다. 전략적용객체에는 전략주입 구상클래스를 set해줘야한다. | . | 전략패턴 to 템플릿메소드패턴 . 전략인터페이스를 추상클래스로 변경하고, 전략메서드를 삭제한다. | 구상체(전략객체) 1개를 택하여, 추상클래스를 상속후, 중복되는 필드(next)를 생성자 삭제후 setter 먼저 만들어 같이 올린다. 올라온 필드는 privte을, 템플릿메소드도 final을 달아준다. | 다른 전략객체들도, 추상클래스를 상속하고, 삭제된 중복필드 및 생성자주입부를 삭제한다. | 구상체들을 compare files이후, 인자로 넘어온 객체context를 많이 사용하는 구상체를 택하여, 예비훅메서드를 private내수용 메서드로 추출한 뒤, 공통로직을 가진 전략메서드를 템플릿메서드로 올린다. | 다른 구상체들은 올라간 템플릿메서드와 훅메서드에 대해, 훅메서드를 구현하여, 전략메서드 중 개별로직을 붙여넣고, 전략메서드를 삭제한다. | 추상클래스가 좋은 부모인지 확인한다. (private필드, final메서드 or protected abstract 메서드) | 연결되는 합성객체인 경우, setter에 return this + 추상체 응답이후, client에서는 생성자체이닝처럼 setter를 체이닝한다. |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/strategy/templatemethod/convert/2022/07/12/Object_strategy_templatemethod_convert_text.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/strategy/templatemethod/convert/2022/07/12/Object_strategy_templatemethod_convert_text.html",
            "date": " • Jul 12, 2022"
        }
        
    
  
    
        ,"post23": {
            "title": "Object) Connect to Strategy Object (Plan2)",
            "content": "context를 인자로 공유하는, 연결될 합성객체는 개별로 [생성자 주입받는 다음타자 next필드] + [return null터미네이닝 재귀호출]로 연결된다.(실습) . 연결합성객체는 재귀처럼 다음 연결된 합성객체를 호출한다. 재귀처럼 호출하려면, if 종착역 끝 + return 종착역 아니면 다음타자 호출한다. 종착역은 다음타자가 null으로서 없을 때 누적변수를 반환하는 것이다. | . | 전략객체는 전략메서드로서 시그니처가 통일되었으므로 주체만 next필드에 미리 담아놓아야한다 -&gt; 생성자 주입 받는다. | 만약, 생성자 주입에서 null이 입력되면, 다음타자는 없는 것으로 한다. | . | PricePerTime . . 생성자로 동급의 다음 합성객체(전략객체)를 주입받는다. 이후 client에서 사용은 데코레이터 패턴처럼 포장하는 모양을 가지게 된다. | . | 나의 할일이 끝나고, return문에 재귀함수처럼 next필드에 있는 다음타자의 전략메서드를 호출하되, 다음타자가 없으면 == null 현재의 결과누적변수를 반환한다. | . . | early return + 바로 return은 3항연산자로 변경할 수 있다. . . . | 나머지 NightDiscount는 같은 처리 . . | Tex 전략객체는 새로 추가해준다. ratio만큼 세금만 뗀다. . . . | AmountDiscount도 추가한다. . . . | Main에서 사용법 . 각 전략객체를 데코레이터 패턴으로 생성자 주입하면, 콜백 지옥의 장풍형태가 만들어진다. . | 다음 타자가 없을 경우, 생성자에 null을 입력하여 터미네이팅하는 재귀호출형태다. . . | . | . 유사 데코레이터 패턴의 Clinet코드 및 내부 중복로직을 추상클래스로 제거하기(설명) . client에서 사용하는 유사 데코레이터 패턴의 생성자 체이닝 (문제점) . . | 내부에 존재하는 유사 데코레이터 패턴 로직 . . | 문제점 파악하기 . 전략객체들이 직접 다음타자 주입 + next필드 + 재귀호출부를 가져 코드중복이 발생한다. 중복코드는 템플릿메소드형태의 추상클래스로 제거한다. . . . | 중복제거를 위해 올린 생성자 주입 -&gt; 부모 추상클래스는 좋은 상속조건에 의해 생성자 주입을 받지 않는다.에 의해 생성자 주입 대신 setter받기기능을 사용하되, return this를 이용한 [setter 체이닝 받기기능]를 이용한다. . setter체이닝받기는 받기기능의 주체 = 받고난 뒤 return되는 객체가 동일해야한다. | . . | . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/strategy/plan/context/2022/07/11/Object_connected_composite_object.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/strategy/plan/context/2022/07/11/Object_connected_composite_object.html",
            "date": " • Jul 11, 2022"
        }
        
    
  
    
        ,"post24": {
            "title": "PRACTICE) 여러 전략객체를 적용하는 방법",
            "content": "여러 전략객체 적용하기 . 완성 커밋 | . 설명 . 사실, 여러 전략객체들을 적용하려다보니 원래는 각 전략객체마다 next의 다음 타자 전략객체를 소지하고 있어야하며 | next 필드 + 다음 타자전략객체들을 재귀형식으로 호출해줄 공통로직에 의해 템플릿메소드패턴의 추상클래스가 전략인터페이스를 대체하여 바뀌며 | 좋은 상속은 합성으로 다시 변경되어서 구상클래스화 + 전략인페 추가+ 전략객체들형태가 된다. | 이 때, 추상클래스-상속에서 -&gt; 전략주입 구상-합성으로 변경할 때 로직이 변경되는데 다음 타자next소유 + return null터미네이팅 + next로 전략메서드()를 재귀호출로직을 전체 타자 컬렉선 소유 + forloop 누적 연산으로 바뀌고 | . | 다음 타자 [받기 + &lt;추상체this&gt;(현재구상체) 반환]의 외부 &lt;타자별&gt; 체이닝 받기로직을 첫번째 타자 생성자 필수 add받기 + 2번째부터 [add받기 + &lt;구상체this반환&gt;]의 외부 &lt;자신의 연속&gt; 체이닝 받기 | 추상체this반환 받기기능은, 현재구상체가 반환되어 다음 타자로 넘어간다? | 구상체this반환 받기기능은, 받아서 상태가 달라진 현재상태의 객체를 다시 반환하여, 체이닝해서 연속해서 받기가 가능해진다. | . | | . | . 실습 . 정잭적용객체 &lt;-&gt; 전략객체들 사이에 [전략주입 구상클래스]의 다리를 만든다. . 단순히 전략메서드만 적용하는 것이 아니라 전략조건을 여러개 받아야할 때, 중간에 구상클래스를 둔다. | 여러 전략객체들을 모아 한번에 적용할 때, 중간에 구상클래스를 둔다. | 여러 카테고리의 전략이 필요할 때, 중간에 구상클래스를 둔다. | | . . 여러 전략을 받는, 전략주입 구상클래스는 return this가 달린 add받기기능인 [외부 체이닝 받기기능]을 가진다. . 받아서 변화된 상태의 자신을 반환하면, 또다시 받기가 가능하다. | . CalculatorBasedOnCalls는 전략주입 구상클래스로서 . 첫번째 전략객체는 생성자 주입으로 인한 필수 받기 to 컬렉션 . . . . | 2번재 전략객체부터는 setNext()의 받기 + this반환의 외부 연속 체이닝 받기 to 컬렉션 을 적용할 것이다. . my) 받기기능을 체이닝으로 하려면 setter느낌이지만, 받고나서 return this로 인해 상태변화된 나 자신을 반환해준다. | . . . | 받아서 변화된 나를 반환해주는 setNext()를 정의하면 외부에서 체이닝해서 계속 받을 수 있다. . . . | | 적용객체에 주입되어, 적용대상 객체context를 [여러 전략이 적용되어 누적되서 반환될 것의 초기값]을 전달받은 뒤, 내부에 소유한 여러 전략객체를 forloop로 돌면서 여러번 전략메서드를 누적 호출한 뒤 변화된 객체를 최종 반환한다. . 전략이 주입되는 적용대상 객체 Plan이 직접 계산해서 외부에 전략으로 계산된 요금을 제공한다. | 전략 객체가 누적연산한다면, 그 초기값을 건네주어 -&gt; 누적된 값을 반환받는 것이 context공유의 한 부분이다. | . 전략적용 객체 Plan은, 전략주입 구상클래스를 주입받은 것을 활용해서 내부에서 처리를 해주는데, plan 내부에 있는 적용대상 객체(여기선 객체에 적용하진 x) or 누적연산이라면 초기값(Money.ZERO) + 계산시 필요한 정보(calls)을를 전략주입 구상클래스에게 적용하라고 건네준다. . 요금계산 적용객체는계산정보 calls와 누적 연산 초기값을 건네준다. 초기값을 건네주고, 누적연산을 받는 것이야말로 객체context 공유다 값을 건네주고 업데이트된 상태값을 받는다. | 값을 건네주고 쌩뚱맞은 값을 반환받거나 반환안받으면 객체context공유가 아님. | . | . | . . . | 필요한 부수재료들을 만들어준다. . List컬렉션은 index에 값을 사용하므로 값context다 | HashSet은 순서가 보장되며 + 중복검증해주며 + 객체로 꺼내고 넣는 객체context라서 적극 활용한다. | . . | 전략주입 구상클래스에서 여러 전략객체들을 forloop돌면서 누적 적용한다. . 개별 전략메서드마다 계산한 값을 파라미터로 온 초기값을 for문위 누적변수(지역변수) 삼아서 누적해주고, 반환해준다. 넘어가는 초기값의 type은 Money의 VO로서 값객체다. | . | . . . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/practice/strategy/setnext/chaining/2022/07/08/(practice)%EC%97%AC%EB%9F%AC_%EC%A0%84%EB%9E%B5%EA%B0%9D%EC%B2%B4_%EC%A0%81%EC%9A%A9.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/practice/strategy/setnext/chaining/2022/07/08/(practice)%EC%97%AC%EB%9F%AC_%EC%A0%84%EB%9E%B5%EA%B0%9D%EC%B2%B4_%EC%A0%81%EC%9A%A9.html",
            "date": " • Jul 8, 2022"
        }
        
    
  
    
        ,"post25": {
            "title": "Algorithm) Pycharm 알고리즘 풀이 세팅",
            "content": "예시 미리 정리 . # backjoon/101/Solution(heap).py + input, output.pxt 백업 ./sol.bat bj 101 heap # programmers/101/Solution.py + input, output.pxt 백업 ./sol.bat pg 101 # leetcode/101/Solution(heap).py + input, output.pxt 백업 ./sol.bat lc 101 heap # others/101/Solution.py + input, output.pxt 백업 ./sol.bat others 101 . pycharm 알고리즘 풀기 세팅 . 루트폴더에 input.txt , output.txt, Solution.py를 만든다. . solution.py는 아래내용으로 작성한다. . import sys input = sys.stdin.readline def solution(): pass if __name__ == &#39;__main__&#39;: solution() . | . . | Edit Configurations &gt; + &gt; Algorithm으로 설정을 생성한 뒤 . Script Path: 만든 Solution.py로 설정 | Redirect input from: 만든 input.txt로 설정 | [ ] Active tool window: 체크해제 | Logs탭 &gt; Save console output to file : 만든 output.txt로 설정한다 | . | input.txt와 output.txt를 하단에 띄워놓고, 결과를 확인해본다. . 한글에러가 나면 xp949로 설정해준다. | . . . | batch파일 -&gt; 해결한 문제 특정폴더에 백업하기 . batch 명령어 정리 블로그 | . root 경로에 sol.bat파일을 만든다. . sol.bat [ ] [ ] [ ] or sol.bat [ ] [ ] 형식으로 사용한다. 첫번째 인자는 bj or pg or lc or others가 되어야한다. | 2번째 인자는 첫번째인자 폴더 아래 생길 문제번호폴더명이면서 Solution.py가 %2인자.py로 백업될 파일명이와야한다 이미 푼 문제로서 해당 폴더가 존재하면 에러가 뜨고 종료된다. | . | 3번째 인자는 %2인자(%3인자).py로서 파일명 뒤에 괄호로 추가 설명이 오도록 한다. | . | . @echo off if &quot;%1&quot; == &quot;bj&quot; ( ::backjoon폴더가 없으면 일단 생성한다. if not exist &quot;. backjoon &quot; md &quot;. backjoon&quot; ::backjoon/ 첫번째인수명/ 으로 해당 문제의 폴더를 생성한다. if not exist &quot;. backjoon %2&quot; ( md &quot;. backjoon %2&quot; ) else ( echo &quot;already solved problem&quot; GOTO:EOF ) ::변수할당시 = 사이에 공백이 있으면 안된다. Set CURRENT_FOLDER=backjoon ) else if &quot;%1&quot; == &quot;pg&quot; ( :: else는 닫는괄호와 같은 위치여야한다. :: programmers폴더가 없으면 일단 생성한다. if not exist &quot;. programmers &quot; md &quot;. programmers&quot; ::programmers/ 첫번째인수명/ 으로 해당 문제의 폴더를 생성한다. if not exist &quot;. programmers %2&quot; ( md &quot;. programmers %2&quot; ) else ( echo &quot;already solved problem&quot; GOTO:EOF ) Set CURRENT_FOLDER=programmers ) else if &quot;%1&quot; == &quot;lc&quot; ( ::leetcode폴더가 없으면 일단 생성한다. if not exist &quot;. leetcode &quot; md &quot;. leetcode&quot; ::leetcode/ 첫번째인수명/ 으로 해당 문제의 폴더를 생성한다. if not exist &quot;. leetcode %2&quot; ( md &quot;. leetcode %2&quot; ) else ( echo &quot;already solved problem&quot; GOTO:EOF ) Set CURRENT_FOLDER=leetcode ) else if &quot;%1&quot; == &quot;others&quot; ( ::leetcode폴더가 없으면 일단 생성한다. if not exist &quot;. others &quot; md &quot;. others&quot; ::leetcode/ 첫번째인수명/ 으로 해당 문제의 폴더를 생성한다. if not exist &quot;. others %2&quot; ( md &quot;. others %2&quot; ) else ( echo &quot;already solved problem&quot; GOTO:EOF ) Set CURRENT_FOLDER=others ) else ( echo &quot;Must First arguments contains bj, pg, lc, others&quot; GOTO:EOF ) ::Solution.py -&gt; . backjoon 첫번째인수명 첫번째인수명.py으로 복사한다 if &quot;%3&quot; == &quot;&quot; copy %cd% Solution.py . %CURRENT_FOLDER% %2 %2.py :: 만약, 2번째 인수가 존재한다면-&gt; . backjoon 첫번째인수명(2번째인수명).py으로 복사한다. if not &quot;%3&quot; == &quot;&quot; copy %cd% Solution.py . %CURRENT_FOLDER% %2 %2(%3).py :: input, output.txt를 . backjoon 첫번째인수명 폴더로 복사한다. copy %cd% input.txt . %CURRENT_FOLDER% %2 input.txt copy %cd% output.txt . %CURRENT_FOLDER% %2 output.txt ::기존 Solution.py 초기문장 적어 초기화 echo import sys &gt; . Solution.py echo. &gt;&gt; . Solution.py echo input = sys.stdin.readline &gt;&gt; . Solution.py echo. &gt;&gt; . Solution.py echo. &gt;&gt; . Solution.py echo def solution(): &gt;&gt; . Solution.py echo pass &gt;&gt; . Solution.py echo. &gt;&gt; . Solution.py echo. &gt;&gt; . Solution.py echo if __name__ == &#39;__main__&#39;: &gt;&gt; . Solution.py echo solution() &gt;&gt; . Solution.py :: 기존 input, output.txt를 빈 파일로 생성 type NUL &gt; . input.txt type NUL &gt; . output.txt . | 문제를 다 풀었으면, 터미널에서 ./sol.bat [bj] [문제번호] [optional]형태로 백업하고, 3개 기본 파일을 초기화한다. . 기본 저장경로는 ./%1의 full word/%2이다. | 2번째 인자는 폴더명이자 py파일명이다. | 3번째 인자는 존재한다면, py파일명(괄호) 괄호안에 텍스트를 적는다. | . . . . |",
            "url": "blog.chojaeseong.com/python/algorithm/pycharm/boj/batch/input/output/2022/07/07/pycharm_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%ED%92%80%EA%B8%B0_%EC%84%B8%ED%8C%85.html",
            "relUrl": "/python/algorithm/pycharm/boj/batch/input/output/2022/07/07/pycharm_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%ED%92%80%EA%B8%B0_%EC%84%B8%ED%8C%85.html",
            "date": " • Jul 7, 2022"
        }
        
    
  
    
        ,"post26": {
            "title": "OBJECT 20 TODO2 작성을 통한 command, memento패턴 학습",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . 디자인패턴 심화 - 커맨드 패턴 . visitor패턴: 제어를 뺏고 행위만 남겨둔다. renderer: 제어를 뺏음. 제어의 역전(invasion) | visitor: 행위만 공급하게함. | . | 제어만 역전해서는 프레임워크가 작동하지 않는다. 행위도 역전하지 않았기 때문 행위를 각자 객체가 가지고 있으면 너무 많은 자율권이 부여되기 때문에 행위도 캡슐화해야한다 | 행위캡슐화하는 패턴: 커맨드패턴 | . | 커맨드패턴은, 이미 존재하는 코드에 다 적용할 수 있다. 처음부터 커맨드패턴을 적용한다는 생각을 버려야한다. 헤드퍼스트에 나와있는대로 쓰면 안된다. | 내가 어떤 객체를 소유하고 있는 상황 -&gt; 커맨드패턴화 시킨다. CompositeTask를 소유하고 있어서 -&gt; 그 기반으로 CommandTask를 만들 것이다. | . | . | . 커맨드 인터페이스를 먼저 만들고, 오퍼레이터로 기능 객체 조작행위의 오퍼레이트를 정의해서 행위를 위임한다. . 일반적으로 대표적인 메서드는 2개가 있다 . void execute() | void undo() | . . | 현재는 인자를 안받고 있지만, 인자에 객체를 줘서, 객체를 조작하는 행위를 위임한다 . 실행/취소는 뭔가를 대신한다는 개념인데, Task를 대신하려면 Task객체를 보내서 대신 시켜야한다 사실상 기존에 있던 task속 set계열 메서드들을 인자로 온 task를 통해 호출한다. | my) 을의 입장에서 물건을 반환해주는 / 기능을 가진 갑을 인자로 받는 것과 유사 | . | . | 직접 Task를 조작하던 것을 Command객체에게 기능객체의 조작을 위임하기 위해 , 인자로 기능객체를 먼저 보내준다 . . | . | 커맨드패턴은행위 위임뿐만 아니라 자기만의 저장소(인스턴스 context)를 이용해서 행위를 조작할때 외부저장소로 이용한다 . undo할때 한다. redo도.. 우리가 하는 것에 대부분은 undo/redo가 있다. 기본인데 못하는 중… | . | 인터페이스가 아닌 위임행위를 가지는 커맨드 구상객체라는 인스턴스에서 내부 필드로 행위 외부저장소를 가진다. | . | CommandTask (커맨드 구상객체)를 만든다. . 오브젝트 책에서 나오는 (행위)위임 객체로서 CompositeTask를 소유하여 바깥으로 매핑하고 있는 상태다. | 기능객체의 소유만 하고, 커맨드인터페이스를 구현하는 것은 아니다!! | . . | 해당객체를 소유하므로 해당 객체 내장을 모두 복사해서 가지고와서 바깥에서 매핑해주고 있는 부분부분을 수정한다. . 소유객체인 compositeTask내용을 모두 복사해온다. | 필드는 CompositeTask를 소유하도록 수정한다 나머지 필드는 날린다. | . | 생성자는 자신형으로 바꿔준다. impl은 오타 | . | . . | 복사해온 코드중에 set계열들(커맨드패턴 대상)은 일단 두고, get계열코드부터 확인한다. . 매핑객체가 소유객체의 코드를 복사해왔다면 getter계열은 매핑해주고 있으므로 소유객체에 위임하도록 바꾸면 된다. | toggle은 get계열이 아니라 set계열(상태변화)이다. set계열은 command패턴을 직접적으로 먹는 애들이다. 나중에 수정한다. | . | . | getReport() 같이 getter계열에는 return만 해주면 되는데, 이미 소유객체 내부에서 정의된 메서드들이고, 현재 그 메서드 정의부에 있으니 시그니쳐만 보고이므로 소유객체.해당메서드명(인자)으로 위임호출하면 된다. . 인자가 있는 getter라면, return 소유객체.메서드(인자)로 getter를 위임하면 된다. | getter제거를 위한 위임이 아니기 때문에, 소유객체 자체의 메서드만 호출해서 get계열위임을 쉽게할 수 있다. | . . | getter계열들은 소유객체코드 + 소유객체를 통해 위임해서 쉽게 해결했다. . 상속안쓰려면 소유 후-&gt; 위임 메서드 정의해야한다. | . | set계열은 새로운 커맨드 객체를 통해, 소유객체의 행위를 위임해보자. . 제일 쉬운 toggle부터 처리해본다. . 쉬운 이유는… toggle의 execute 와 undo가 같기 때문에.. | . | 지금까지 set계열 = 상태변화는 문을 통해 해결했는데, set계열의 처리를 소유 -&gt; 커맨드 객체를 통해 위임하기로 한다. . . | set계열을 처리하는 커맨드객체들은 Command인터페이스를 구현해서 생성되고, 인터페이스 추상체변수(for 오퍼레이터 사용)로 받는다. . . . | . | set계열의 메서드들도 커맨드객체 -&gt; execute에서 set계열 위임하는 것이다. . 대신 undo에서 카운터칠 수 있는 메서드를 만들어내는 것이 관건이다. | . . . | 이제 객체소유 커맨드객체에서는 커멘드인터페이스 변수를 통해 execute를 호출한다. . . | 우리는 커맨드 구상객체를 통한 실행 뿐만 아니라 undo/redo호출을 위한 외부저장소가 필요하다. . 그래서 객체소유필드 외에 여러 커맨드 구상객체들을 쌓아놀 스택(List)가 필요하다. | 또한, 소유객체 행위를 할때마다, 빈 컬렉션(커맨드스택)에 add해줘야하므로 addCommand(Command cmd)메서드도 필요하게 된다. my) 저장소 컬렉션 필드는 빈컬렉션 + add메서드조합이 필수임 | . | 어차피 커맨드 실행도 add하고 바로 할 것이므로 addCommand에서 execute까지해주면 된다. 앞으로 set계열의 커맨드 행위 메서드들은 addCommand(new 해당커맨드())만 호출하면 저장+실행을 동시에 한다. | . | . . . . | 기존에 소유한 객체에서 하드코딩되었던 toggle명령이 커맨드 구상객체로 빠져나간 것을 알 수 있다. . getter계열들은 바깥에 제공해주는 것이므로 행위가 아니다. . | 상태를 건들이는 setter나 remove등은 객체로 다 뺄 것이다. . | . | setter들은 모두 같은 패턴으로 행위를 위임한 커맨드객체로 빼보자. . 행위에 있어서 필요한 인자는 커맨드객체에 그대로 전달해줘야지 일을 할 것이다. | . | 생각해볼 거리 . 인자를 받는 setter계열들은, 인자로 커맨드객체내에서의 재연을 위해, 행위 위임에 필요한 것들을 모두 인자로 가져서 당시의 context로 기억해야한다. 특히, undo, redo를 하려면, 여러번 재연&amp; 시간이 흐른뒤 재연하려면 당시의 context를 모두 기억하고 있어야하므로 생성자의 인자로 기억해야한다. . 그래야 task.가 setTitle(title)로 커맨드객체내에서 행위를 할 것이다. | . . | 그렇다면, task는 인자로 받아서 기억안해도 되나? . 필요한 것을 인자로 안받고 소유한 필드로서 계속 재활용하여 호출 하는 이유는, 소유객체는 불변객체라는 가정이 있기 때문이다. | . | 그렇다면, 소유필드 task를 생성자 초기화하여 불변객체로 만들어놔야한다. . | . | 커맨드에게 행위를 위임하고 소유될 객체는 생성자초기화하는 불변객체여야한다. . CompositeTask는 final로 확정되는 불변객체다 . | 내부에 필드가 불변이려면, 생성자에서 이미 완성된 상태로 초기화 되어야한다. . . . | final의 불변객체라면, 내부에서 커맨드객체가 사용할 때, 그 상태를 인자로 기억안하고 필요할때마다 갖다쓰면 된다. . . | | 소유한 불변객체 이외에 필요한 것들은 모두 당시의 상황을 메서드 인자 -&gt; 커맨드 객체의 생성자로 받아서 기억하고 있어야한다. . 계속 기억되려면, 생성자로 받아야 한다. . | 불변객체는 불변하니까 필요할때마다 갖다쓰면 된다. | set계열의 메서드는 호출될때마다 당연히 다른 값이 들어올 것이며, 그 당시의 context를 기억해두기 위해선, 객체의 생성자로받아 필드로 박아서 기억해야한다. 그렇지 않으면 set계열 메서드내 인자는, 메모리에서 한번호출후 제거되는 값으로서 메모리에서 영원히 사라진다. | . | 객체의 상태값으로 남겨야, GC에 안걸리고, 남아있다. 함수형언어의 Closure역할로서 외부상태를 보관하려고 만든 것이 생성자-&gt;필드이다. | . | . | 다시 setTitle에서 작동할 커맨드 구상객체 Title을 만들어보자. . 당시 context를 기억해야해서 생성자로 들어온 것은 final로 받는다. | 커맨드패턴의 특징이다. 생성당시 context들은 확정되어야하기 때문에 다 final이다. | execute는 set그대로 작성하면 된다. | . . . | undo는 어떻게 할까? . 마법은 없다. set하기 전에 older로서 미리 기억해야한다. 당시 컨택스트를 기억하는 방법은 필드로 박아두는 것이다. | execute전 상태값을 getter -&gt; 필드에 기억 -&gt; old값으로서 set해서 undo한다. getter를 통해 당시 상태를 기억해야하며 기억은 필드에 한다. | . | . . . | undo의 비밀은 . 커맨드객체를 사용하면, 객체로서 자기만의 context를 가질 수 있다. | 실행당시의 context는 생성자를 통해 받아들여 필드로 기억하지만 | 실행당시 자신의 상태도 getter -&gt; 필드로 기억할 수 있다 toggle은 그냥 왔다갔다만 하므로 기억해야할 상태가 없어, 필드도 없다. | . | . | 나머지 setter들은 1개만 만들면, class자체를 복붙해서 편하게 만들 수 있다. . setDate . | 인텔리제이로 복붙하면, 형+생성자도 자동으로 지정한 이름으로 바꿔주고 나머지코드들을 그대로 복붙해주면 -&gt; 필드변경으로 파라미터까지 다 바꿔준다. | 나머지 필드타입 등만 다 잘바꿔주면 된다. shift + F6으로 타입바꿔주면,,, 물린 것 다 바뀌므로 조심.. 복붙한 클래스에서는 사용안해야할듯.. | . | . . | add/remove도 마찬가지로 new Add( ), new Remove( )를 때려서 만들고, 구상객체들은 복붙해서 수정한다. . 이 때, 또 생각해볼 거리가 생긴다. | add할 당시의 task를 기억해야만 for undo = add의 카운터는 remove -&gt; 당시의 task를 삭제해야한다. | 일단, new Add()부터 만들어보자. 단일객체 task의 생성자는 관리자인 compositeTask내부에서 생성하여 add시 내부에서 생성하도록 공개를 안한 상태임. | . | . . . | add를 카운터(undo)치려면, 당시의 add된 객체(task)를 remove해야하는데, task는 저장된 title, date를 재료 받아 내부에서 객체생성하는 상황이다. . execute 당시의 값을 getter -&gt; 필드에 저장하는 것과 달리, | execute 당시의 add되는 객체task알아야 -&gt; 필드 저장해서 -&gt; remove때릴 수 있다. 하지만, task.add()메서드 내부에서 재료를 통해 생성된다. | . | . . | 특정 메서드 내부에서 재료받아 내부 객체 생성후 add되는 메서드는 생성되어 add된 내부생성객체를 반환하는 add메서드로 정의해야한다. . 기존 add | . . remove -&gt; add된 task를 알아야 카운터 칠 수 있다. | . . void가 아니라 내부생성되는 객체를 반환해주는 add메서드로 수정하고, add당시 task를 반환받아 -&gt; 필드에 기억 -&gt; undo에서 remove로 카운터 칠 수 있게끔 해줘야한다. | my) void한 add메서드는 undo를 할 수없다!!는 결론 | . | void add를 add한 객체반환 add로 바꾼다. . execute에서 반환받은 add한task를 oldTask = 의 필드로 저장한다. | . . . . | add의 undo는 기억한 oldTask를 remove한다. . . | 켄트백이 말하는 대칭성은 커맨드패턴을 작성하다보면 알게 된다. undo가 되려면 대칭성 메서드를 만들어야한다. | undo를 하려면, 자연스럽게 인터페이스를 대칭성있게 만들 수 있게 된다. | . | remove같은 경우에는 인자로 소유한 불변의 task를 받아들인다. task를 기억하면 된다. . 커맨드객체는 항상, 소유객체가 받던 인자를 받는다. | 대칭 커맨드객체 만들땐 복사를 활용하자.ㅠ -&gt; 거의 대칭성있게 작성하니까 코드를 재활용하거나 확인할 수 있음. | . . . | remove의 카운터는 add인데, add에 필요한 것은 객체가 아니라 내부생성을 위한 title, date의 재료들이다. . 카운터add를 위해선 재료들을 old로 기억해야한다. undo인 카운터에 사용되는 메서드를 위해 execute상태를 기억함 | . | . . . old필드들로 카운터add해주기 | . . | remove작성시 생성자를 통해 들어온 task context와 execute/undo 메서드의 인자로 들어오는 task객체의 변수명을 똑같이줘서 에러가 발생한다. . . 실제 소유한 객체로서 일을 하는 놈인 execute인자는 task그대로 두고, context로 Remove 행위시 기억해야할 대상인 task객체 -&gt; 불변필드는 baseTask로 바꾸자. . . | . | 커맨드패턴에서는 2가지 기억필드가 있다. . 위임역할을 하기 위해, 소유객체가 필요한 context를 생성자로 받아 기억 | old계열를 붙여, undo를 위해 execute당시의 상태를 기억 되돌아가려고 execute시 old계열을 기억한다. | **만약, 커맨드패턴을 쓰지 않고 undo했더라면, old계열들은 CommandTask내부에 set계열메서드마다 모두 실행당시 상태를 필드로 &amp; 배열로 기억해야만 한다 ** | 하지만, 객체로 빼고, 인스턴스 메모리를 사용함으로써 각기 다른 사정들을 각기 인스턴스로 기억해서 해결 | . | . | CompositeTask를 CommandTask로 감싼 후 감싼 환경속에서 새로운 객체에게 각 set계열행위들을 위임하지않으면, 이런 기능들을 이용할 수 없다. 아니 내 함수를 왜 또 감싸서 쓰지???? | 한번 감싸고, 감싼 곳에서는, 행위들을 같은 인페의 구상객체에 위임하면, 당시의 context를 기억해서, 원본기능에 인스턴스메모리에 실행당시 상태들을 기억함으로써 되돌아가기, 다시하기등의 기능을 할 수 있다. | 행위를 행위객체에 감싸면, 감싼 객체에서 context를 필드로 기억할 수 있어서 undo, redo가 가능하다. Closure같이 실행당시의 context들/상태들을 기억할 수 있다. | | 행위를 하는 대신에 포장 공간 속에서 [행위를 command객체]로 만드는 것이 비효율적인 것 같지만, 인스턴시 메모리 활용으로 상태저장이외에 execute하기전까지는 실행되지 않는 지연실행도 할 수 있다. . 함수형언어만 지연실행을 하는 것이 아니다. . | 행위를 객체에 위임한 순간 커맨드객체를 만든 시간 &lt;-&gt; execute하는 시간이 나눠진다. . 현재는, 이해하기 좋으라고 commandTask에서 바로 execute때리고 있지만, 실제로는 원할 때 원하는 만큼 command객체를 생성해놓고, 원할 때 execute를 때린다 | 게다가 command객체를 List로 모아두는 필드를 가진 이유는 값context은 index를 활용해서 원하는 갯수(1~5번까지, 짝수들만, 홀수들만)만 실행 가능하기 때문이다. | . . | 이렇게 execute전 command객체들만 모아서 지연실행하면, 코드중복이 엄청나게 없어진다. . 이유: 우리가 쓰는 제어문은 대체할 수 없다.즉, for문 내부가 조금만 달라져도 for문을 다시짜서 처음부터 돌리는 수밖에 없다 제어구조를 재활용하려면, visitor패턴 or composite 쓰던지 해야한다. | . | 행위를 객체위임함으로써 지연실행이 가능하면, 원하는 만큼만 / 원하는 형태로 나눠서 실행시킬 수 있다. | for문 10번실행 구문 &lt;-&gt; 지연실행가능하여 for문에서는 index를 물고 있는 커맨드객체를 생성만 하고서 지연실행가능한 것들로서 상태를 물고 있는 지연실행 객체를 배열에 넣어두는 것이랑 굉장히 다르다. for문 10번 실행: 무조건 1번부터 10번까지 실행 | for문 10번 index를 물린 커맨드 객체: 짝수만 실행/홀수만실행/반만 실행/ eventLister가 도착할때 실행 | . | . | 또한, 지연실행은 [순차적실행=동기실행]이 아닌 비동기실행도 가능하다. . 앞에 놈을 실행하고, 다 끝난 사인이 오면, 2번째놈을 꺼내서 실행 | 지연실행은 비동기 실행의 기반이며, 비동기실행은 커맨드객체가 아니면 객체지향에서는 불가능하다. js에서 promise객체는, 생성당시 context를 promise객체에 넣어놓고 then을 때리는 시점에 실행이 일어나도록 바뀌는 일종의 커맨드객체다. | . | . | . | 우리가 진짜 하고 싶었던 것은 undo/redo다. . 커맨드객체는 응용범위가 너무 넓다. 비동기 실행, 패턴화 실행, undo/redo실행 다 다르게 쓰인다. | . | . | undo는 커맨드구상객체 컬렉션 필드에 쌓여있는 마지막 요소를 처리해야한다.(그래서 List로 보관) . 개별 undo는 커맨드객체에 정의되어있지만, 포장하여 소유하는 Command객체에서 호출해야한다. | . . | 제일 먼저 해야하는 일은 컬렉션에서 빼써야하는 조회개념으로서 존재검증인 list의 사이즈부터 파악해야한다. . 컬렉션 조회 사용시 존재유무 검사부터 : 0개이면, undo할게 없어서 early return . | 1개 이상일 때, 마지막꺼 remove후 반환되는 객체를undo() . index로 remove시 반환은 삭제되는 객체다. . . | . | 디자인 패턴은, 각 문제를 해결하는 가장 짧은 패턴이다. undo를 하는데 코드가 몇줄 안된다. . 모든 경우에 대한 위임객체에 코드가 좀 들어가긴했지만, 각 case별 제어문의 중복코드를 다 제거해서 코드가 짧다 | . . . | . | undo다음에 이어지는 redo는 어떻게 할까? . undo시 이미 컬렉션에서 command객체를 제거했는데?? . . | 현재상태에선 불가능하다. . undo만 짠다면 remove로 쉽게 짜여지지만, redo기능이 존재할 예정이라면, remove로 커맨드객체를 바로 날리면 안된다. | 만약, undo로 바로 날리게 되면, undo -&gt; add 시 마지막 index만 사용하게된다면, undo할 위치를 덮어써서 날아가게 된다. | . | . | 언두와 리두를 하는 방법은 [마지막index만 고정대상] -&gt; [undo로 바로 삭제]가 아니라, database에서 하는 것처럼 list-index를 커서로 사용해서 커서가 존재해야만 한다. . 나의 list에 커서가 있어서, undo는 커서를 한칸씩 뒤로 보내기. / redo는 커서를 다시 한칸씩 앞으로 보내서 작동하며 제일 마지막 커서에 도착하면, 더이상 redo할 것이 없다. | 제일 앞 커서에 도착한다면, 더이상 undo할 것이 없다. | . | 만약, 커서없이 undo하다가 add를 한다면? 커서가 없다면, 마지막index 고정대상으로 보고, 앞쪽 (직전)의 상태는 다 날아간다. | . | . | 컬렉션에 커서를 도입하려면, 컬렉션 필드가 초기화되는 곳에 cursor필드를 default 0인 값의 커서로 초기화해줘야 . . | 커서 필드를 도입했다면, 컬렉션을 건드는 곳들(addCommand)을 수정해줘야한다. . 일단, add하자마자 알기쉬운 cursor부터, 기계적으로 cursor를 + 1할려고 한다. . . | 하지만, 증감연산자 ++을 사용하는 것은 상태를 알아서 잘 관리하겠다는 말도 안되는 자신감이다. . variant로 연산하지말고, [불변식 -&gt; 재할당을 통한 상태 업데이트]해서 [연산 전 원하는 상태를 확정해주는 invariant를 지키게 만들도록 상태를 변화시키자.] variant로 관리한다면, 훨씬 더 민감하게 상태를 관리해야한다. | calculator의 예제의 경우, 연산전 check()하여 원하지 않는 상태땐 스스로 죽게만들어서, variant변수가 원치않은 상태는 연산에 진입하지 않게 invariant임을 확정했다. | cursor++의 경우, list의 index라는 제한범위가 있다. 객체가 아니므로 스스로 죽지도 않고, if cursor로 제한범위를 확인도 해야한다. 원치 않은상태를 아예 방지하려고, 컬렉션의index로부터 cursor를 만드는 식을 통해 불변식을 만들었다. | . | 상태를 맘대로 업데이트하는 대신, [불변식-검증을 거쳐서 원하는 상태로 만듦]을 쓰면 [원치않은 상태 방지를 위한 if]가 없어진다. . | 컬렉션의 커서를 +1하는 [불변식]은, cursor++를 상태를 바로 건들 + if로 제한범위 확인하는 것이 아니라, [현재를 상태를 구한 식(0도 마지막 인덱스)을 생각해서, 안전범위(size를 통한 index도출하여 range확인안해도됨)가 되도록 내부요소만 수정하여 변화된 상태를 만들어야한다.(여기선 api가 알아서 마지막 인덱스 구해줘서 내부요소 변화x) -&gt; [컬렉션.size() - 1]이다. . cursor라는 상태를 변화시키지말고, 상태변화된 새 값을 재할당|반환 or 상태변화된 새 객체을 재할당|반환해주자. | . . | . . | . | 이제 상태변화하는 cursor를 불변식으로 확정시켰다면, 어플리케이션에서 새로운 행위를 할 시(addCommand), 현재커서를 마지막 index로 만들어서, cursor+1~마지막index의 command는 삭제해야한다. 그리고 나서 현재시점에서 +1개를 해야한다. . . 추가한 행위에 대한 undo하기 위해 현재커서가 마지막 인덱스 위치에 남아있어야한다. 그 뒤로는 안돌아가게 한다. | 새로운 행위인 add(cmd)를 하기 전에 만들어놔야하는 일어나는 일들이다. | . | 제일 마지막index에서부터 cursor+1까지 까면서 삭제해야한다. . cursor+1부터 출발하면, cursor가 제일 마지막index인 경우, indexError가 발생할 것이다. | 컬렉션의 불변식(원치않은 range상태 방지)인 .size() - 1을 시작 index로 주자. | . . intellij는 표준api인 subList를 이용하라고 한다. 하지만, 가독성이 안좋아 다시 ctrl+z 성능도 for가 더 좋다. | 마지막인덱스보다 cursor가 작을 경우만, cursor+1~마지막index까지 subList를 만들고, clear때려서 삭제해라..? | . | 노란색보이면 한번은 보자. | . | 이제 undo시, cursor처리를 해야한다. . 기존 | 우리는 커서 도입순간부터 commands 자체를 바탕으로 invariant기준을 잡으면 불변식 위반이다. 이미 커서로 commands를 다루기로 약속한 상태 이다. 커서를 불변식으로 유지하고 이를 바탕으로 움직여야한다. | 커서가 잘못되어도 commands에 의해 작동할 수도 있다. | . | commands 컬렉션필드의 [원치않은 상태 방지 invariant 검증]은 모두 cursor 기준으로만 작성해야한다. 커서가 237이라도, commands.size()가 0이 아니면, 작동하게 되어버린다. | . | . | (기존)undo는 [마지막index에 있는 것을 꺼내 실행하여 없애는 것]이 remove하는 것인데, (바뀔)커서로 치면, 현재 것을 얻고 1칸 왼쪽으로 커서 이동해야한다. cursor는 0이 마지막 위치이며, 0보다 작아지면, 현재것을 얻을수도&amp;왼쪽칸으로 갈 수 없는 상태로서 작동불가능이다. . index == cursor == 0까지는 undo할게 0번자리에 남아있다. size == 0 은 아예 없는 상황이다. 이것과 동치는 cursor &lt; 0이다. | cursor 0은 데이터 size가 1개라는 것을 생각 | . | . . cursor를 통한 불변조건(원하지 않는 상태 방지)을 만들었다. | . | 이제 undo할 커맨드객체를 commands의 index를 통해 가져오면 안된다. 커서를 통해 get으로 가져와야한다 . 기존 . . | 이 때, cursor위치의 command를 얻고나서 커서는 --로 한칸 줄어야한다 . remove하여 강제로 마지막index를 없애는 대신 | 현재것을 얻고, 커서만 1칸 뒤로 가는 것이 undo로 바꼈다 | . | 이미 cursor는 &lt;0이 아니라 안전한 invariant상태라서-&gt; 단항연산자|증감연산자를 써도 된다. . cursor상태의 것을 얻으면서 &amp;&amp; --증감연산자를 써서 바로 1칸 왼쪽 이동시킨다 이미 cursor &lt; 0상태라서 빠른 상태 업데이트가 가능하다 | . | . . | . | 현재 트랜잭션 추가처리할 것도 없는 지역변수로 쿠션을 준 상태다. 이해하기 쉬우라고 . . 원래는 쿠션안준다. . . | . | **사람들은 단항연산자 | 증감연사자를 쓰지말라고 한다. 멍청하기 때문에 이해를 못해서** | . 해당 문장을 순서대로 파악해보자. | 가장 먼저 일어나는 것은 첫번재 괄호다. 메서드의 호출은 괄호안을 해소해야 메서드가 호출된다. | 그래서 cursor만 빼내서 메서드에 들어가고 -&gt; --된 cursor가 return되어 업데이트된다. | 그 결과, 체이닝된 메서드 호출이전에 이미 cursor는까여져있다 my) 증감연산자 이후 체이닝은 까진상태!!! | . | 체이닝한 이유는 딴짓을 못하게 트랜잭션으로 만들기 위함이다. | 트랜잭션 내에서 체이닝 속에서 증감연산자로 cursor를 업데이트하는 이유는, 트랜잭션이 아니라면, cursor를 가지고 또다른 짓을 할 가능성이 있기 때문이다. | . | 드디어 redo를구현할 수 있는 기반(cursor기반의 commands작동)이 마련되었다. . redo도 undo처럼, 커서기반 행위하기 전에, 커서를 invariant로서 먼저 검증해야한다. . 커서가 마지막인덱스에 놓인 상황이면, 더이상 커서를 앞으로 갈 수 없으므로 커서를 한칸 앞으로 땡기는 redo를 할 수 없다. | . . | . | redo는 현재커서의 것을 execute하는 것일까? . undo는 현재커서의 커맨드객체가 execute한 상황에서 현재 커서의 커맨드객체에 정의된 카운터 undo를 실행시키면 해결되지만 . | redo는 커맨드객체에 정의되어있는 것이 아니라서 현재 커맨드객체를 redo하는 것이 아니다. . redo는 (1) 해당커맨드 execute (2) 해당커맨드 undo해서 카운트치면서 cursor를내린 상태에서 시행된다. | 즉, 이미 (1) execute된 커맨드객체에 대해 그곳으로 커서를 +1 옮겨 redo하려고 한다. | . | 즉, redo의 대상은 cursor를 먼저 ++해주고 execute해줘야한다. . . 참고) 컬렉션에 add와 동시에 cursor도 이동은 set다. 여기서 add시 실행도 한번 일어나는데, add된 객체 == cursor를 add된 객체로 이동 == add되어 실행될 커맨드객체 위치에서, 현재 커서위치의 command는 add와 동시에 실행된 상태다. . . | 또한, 인자로 들어온 command에 대해서 -&gt; [add(커맨드관리코드) + 커맨드 실행] 둘중에 뭐가 먼저 일어나도 상관는 없다 . . | . . | 어찌 됬건, add된 마지막index위치로 들어간/들어갈 command객체는 이미 실행된 상태다. . | . | redo를 할 땐, 현재 커서의 위치 == 이미 쓴 command의 위치인데 이것을 다시 실행하진 않는다. . redo의 대상은 현재커서[=이미쓴 객체]의 다음위치이다. | undo의 대상은, 현재커서[=이미쓴 객체]의 카운터함수를 실행하는 것이므로 다르다. cursor는 invariant상태이므로, 증감연산자를 앞에 달아서, 먼저 증가시킨 뒤 실행되게 한다. | . | . . | Main에서 수정 . 일단 root객체의 CompositeTask형을 포장 소유한 CommandTask로만 바꿔주면, 나머지 기능들은 다 매핑되어서 작동하게 된다. . . . | 다음으로 .addTask()가 add한 객체를 return하는지 안하는지 살펴본다. . 커맨드 구상객체(new Add())는, add시 undo를 위해 내부생성하여 add될 객체를 인스턴스메모리(필드)에 저장하기 위해 반환했었지만 . Add . . | . | (컴포짓 객체, 행위객체)포장 소유 커맨드객체(CommandTask)는 add시 객체를 반환하지 않는다. . CommandTask . . | **커맨드객체는 원래 return할 수 없다. ** . | 커맨드객체가 객체를 return하려면, 처음부터 return하는 인터페이스를 써야된다. . | . | 일반적으로 커맨드객체의 메서드는 객체를 return하지 않는다. . 이유는 여러가지가 있으나 커맨드객체가 커맨드 구상객체를 return한다 == 커맨드 구상객체 만들자말자 execute했다는 뜻 ==무조건 동기적으로 움직인다.는 뜻이다. CommandTask . . | . . | 그러나 커맨드 구상객체의 장점은 마음대로 지연실행가능하다이다. . return으로 보고하지 않고 -&gt; return을 콜백으로 보고하던지 뮤텍스에?보고하던지 한다. | . | 그럼, 비동기적으로 복잡하게 작동하는 커맨드객체는 어떤 이링 생길까 값을 모아야하는데 (aggregate) 어떻게 한다? | 커맨드객체 내부에 aggregator필드를 만들어놓고, 실행될때마다 값을 모아준다?! | 보통 이 agreegator는 invoker가 담당한다. 커맨드task에서는 root가 해당한다. 자신의형을 물고 태어나서 반환하도록 하는 컴포짓패턴 시작점을 말하는 듯 | . | . | return값들을 쌓아서 다시 return | . | . | | 프레임워크 작동원리 . - **visitor패턴으로 제어를 역전한 다음** - **실행명령을 반복하거나, 처리하거나 `쌓아두기`위해 `커맨드객체로 구현`되어있다.** . | . 기존에 report를 만드는 기능들을 주석처리하고, ConsoleVisitor를 살려 올려서 뿌려보자. . . | 이제 addTask2번을 출력하고, undo때린 뒤 출력해보자. . . . . | redo하고 출력해보자. . ![image-20220801175605782](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220801175605782.png) . | 다시 commandTask로 가서 set계열이어서 상태를 변화하던 행위를 매핑했던 친구들을 보자.서비스 메서드에 래핑되어있지만, 1개의 메소드(addCommand())로 행위를 사용할 수 있다. . private인 addCommand( new커맨드객체( ) )를 호출하고 있다. | private메서드만 호출하고 있다면, 사실은 addCommand()를 private만 public으로 바꾸고 &amp; 커맨드객체를 밖에서 호출 만들어서 호출하도록 바꾸면, 없어도 되는 서비스 메서드들이다. 밖에서 커맨드객체를 직접 만들어 입력하는 것이 불편해서, 재료정보만 파라미터로 받아 대신 커맨드객체 add후실행을 호출해주는 command generator가 내장되어있는형태를 띄고 있다. | 딱히 커맨드객체는 internal이나 private으로 만들지 않았으므로 | . | . . | 또 좋은 점?? 커맨드패턴을 쓰면?? 객체에 메서드가 하나도 필요없게된다. . 왜?? 모든 메서드가 외부 커맨드 구상객체들로 공급되니까 . | 모든 행위들이 **컴파일 타임에 확정된 메서드로 정의되는 것이 아니라 ** . | 커맨드객체를 쓰는 객체는 public addCommand()외에는 노출할 메서드가 없다 . addCommand만 있으면 내부의 다른 메서드들도 (현재 있지만) 다 필요없게 된다. | . | 컴파일타임에 정의된 메서드들을 다 지워버리고, 런타임에 투입된 커맨드구상객체들의 조합으로 행위가 정해진다. . 그로 인해 객체가 범용객체가 된다 | 커맨드 패턴을 사용하는 커맨드홀더==invoker객체들은, 전부 사실상 메서드가 필요없다. 행위를 위임한다는 의미는 이런 것이다. | . | . | 커맨드패턴 기반으로 만든 프레임웤에는 모두 포조객체같은 것들만 있다. 왜냐면, 커맨드홀더, 커맨드invoker만 있으면 된다. 어떤 행위를 하고 싶으면 커맨드구상객체만 넣으면 된다. . Member클래스(커맨드홀더, invoker) -&gt; Member관련 command구상객체만 받으면 Member가 된다. | admin도 admin관련 커맨드구상객체만 넣어주면 된다. | . | 범용적인 invoker객체 생성 -&gt; UI의 버튼을 통해 클릭시, 해당 커맨드 구상객체만 넣어주면 -&gt; 객체탄생 . 홈페이지 빌더에 인터랙션 가능한 객체를 만들 때, 해당 커맨드만 넣어주면 된다. | 예를 들어, 버튼에 helloworld를찍어주는 execute를 가진 커맨드객체를 넣으면, 버튼 누를때마다 helloworld를 계속 찍어준다. | 만약 커맨드슬롯이 3개가 있다면, 그 놈은 command1.execute() … 이런식으로 3개만 받아서 실행하게 된다. | . | 1클래스에서 생성한 객체1, 객체2가 차이점을 가지고 있다면, 매번 클래스를 생성하는게 아니라 차이를 만드는 궁극적인 방법은 1개의 범용객체 + 차이점 부분만 커맨드패턴을 주입받도록 만드는 것이다. . | 커맨드패턴은, 들어온 것 모두 동일한 execute를 실행하는 것이니 어댑터패턴과 마찬가지다 . 그외 visitor와 같이 하는 전략패턴, 상태패턴, 책임사슬패턴 등… | . | 사실상 커맨드패턴을 쓰는 순간 addCommand()만 있으면 되고 바깥껍데기는 서비스메서드라서 사망된 것이다. 그외에는 다 메서드내부의 context에 의존성을 가진 메서드이다 . 객체에 의존성을 가진 메서드라면, 객체가 바뀌면 메서드는 죽는 메서드이다 | 하지만, 커맨드패턴의 서비스메서드들은 안죽는다. | 커맨드 구상객체를 쿠션삼아서 일을 처리하게 되어 [중계만하고 의존성이 없어진다.] | . . | . | 커맨드패턴이 무적같지만, undo/redo만 되고 save/load는 안된다. . 8비트 게임들은 보물상자 잡몹상태 등 다 기억된다. | 어떻게 save/load했길래, 모든게 다 기억되고 객체 상태가 복구되는가 | 진정한 프레임웤을 만들려면, 시리얼라제이션 == 영속화해야한다. | . | 진정한 프레임웤으로 가는 길 . visitor를 익혀야한다. -&gt; 그럴려면, composite(제어역전 필요한 것)/전략패턴(제어역전 기반)을 배우고 와야한다. . visitor패턴은 제어가 필요한 객체(컴포짓객체)에 대해 Renderer의 종류별 XXXRenderer를 안만드는 대신, 전략패턴을 적용한 XXXVisitor를 끼어넣는다 | 데이터를 가지고 제어될 객체인 컴포짓객체는, Renederer의 메서드인자 -&gt; 방문하는 추상Visitor의 메서드인자로 들어가 사용된다. | . . | 커맨드 -&gt; 제어에 참여하는 객체를 포장하고, 메서드는 1개로 제공하고 커맨드구상체로 빼서 유연하게 포장된 범용객체로 만들고, 행위는 모두 커맨드들로 분리하는 것 . visitor가 사용(소유?)하는 컴포짓객체를 -&gt; 범용 커맨드홀더 객체로 만들면, 다양한 행위를 외부에서 다양한 커맨드객체로 대신하게 할 수 있다. | visitor는 참여객체를 -&gt; 커맨드홀더만 소유함으로써, 행위변동/메서드변동에 대해 안정화된다. | . | 메멘토 -&gt; 모든 것을 저장한다. . | | 마법은 없다. 저장할 수 있으려면, 모든 상태를 시리얼라이즈할 수 있도록 시리얼라이즈 메서드를 구현해야한다 . 반대로 load시에는 시리얼라이즈된 데이터로붙 객체를 생성하는 generator가 있어야한다. | . | 일단 시리얼라이즈를 완성하기 위해 Renderer에 방문하는 JsonVisitor에서 트레일링콤마를 회수해야한다. . 컴포짓객체를 메소드 인자로 받아 제어에 참여시키는 하는 Visitor의 오퍼레이터는 자신의 일처리 == drawTask + 자식들 동적트리순회 + 끝처리 == end 2개의 메서드가 있다. . . . | 이 visitor는 동적트리순회의 재귀에 돌면서, 재귀를 타는 모든 컴포짓객체마다 항상 호출된다. . . | | 끝처리에서 마지막 트레일링콤마를 회수하는 방법은 end메서드가, [현재끝인지 아닌지(==Level선상 마지막 !=마지막레벨)]를 알 수있도록 -&gt; [재귀 속 end 메서드]의 파라미터에 불린 isEnd를 주고 업데이트 시켜야한다 . 재귀속 메서드의 파라미터 -&gt; 재귀메서드의 파라미터에서 와야 -&gt; depth마다 업데이트되는 변수가 되므로 재귀함수 render에도 파라미터를 추가해야한다. | . 컴포짓용 재귀(Renderer-render)속에서 역전된 제어에 참여하는 visitor객체의 인터페이스에서 end메서드 시그니쳐에 불린 isEnd를 추가한다. . 인터페이스의 시그니쳐변경하면, 구현체들 알아서 바뀜 | . . . | | JsonVisitor end처리에서, 항상 마지막에 붙여줬던 콤마를 조건부 붙이기로 수정한다. . println이 아니라 print로 붙여줘야한다. | . . . | 이제 재귀를 돌리는 renderer에서 [재귀 내부 메서드가 업데이트되는 파라미터를 가지고 싶으니, 재귀 당사자의 파라미터에 추가] -&gt; [동적꼬리순회에서 &lt;&lt;트리의 각 LEVEL상 마지막 객체&gt;&gt; 마지막일때만 true가 들어가도록]수정해줘야한다. . 기존 . . | . 재귀 내부 메서드(end)가 업데이트되는 파라미터를 가지고 싶으니, 재귀 당사자(render)의 파라미터에 추가해준다. . . . | 최초 재귀호출의 인자에서 컴포짓객체처리는 root에 level에서의 정보들이며, 같은 레벨선상에서 마지막인가?를 물어보고 맞으면 true를 넣어줘야한다. . . | 재귀 속 end메서드의 인자는 [직접 업데이트하지 않고, 현재 재귀의 정보를 이용해서 메서드 처리해하는 것이므로 파라미터를 그대로 받아먹어야]한다. -&gt; 파라미터 업데이트는 [동적트리순회 속 자식들로 depth가 깊어질때만 업데이트]시킨다고 생각해야한다. . 동적트리순회속 depth깊어지는 자식재귀의 인자를 제외하고는, 최초호출인자 -&gt; 정의부에 그대로 반영해서 사용해야한다. | . . | | 이제 자식들을 동적트리순회할 때, 순회를 도는 list 마지막 == Level상의 마지막 번째에만 true를 인자로 넣어줘야한다. . 여긴 list라서 마지막 인덱스를 불변식으로 알 수 있긴한데…? . | set의 loop라고 가정하고 index를 알 수없다고 가정하고 직접 세어야한다. . .size()를 때리면, 전체길이는 안다. 다만 index를 알 수 없다. | . | index를 모르는 loop의 마지막을 찾는 방법은 . 반복문위에 업데이트 변수를 컬렉션의 길이로 초기화한다. . 0부터 시작안하는 것이 신기하다. | 만약, 0으로 시작했으면 반복문 내부에 끝인지 검사를 매번 if i == list.size()로 api를 호출해야하며, 만약 [조건문속 메서드 호출]을 상수 값으로서 위쪽에 뽑아놓는다면, 0 시작변수 + 끝 상수 2개를 변수로서 초기화해야한다 | my) 끝인지 검사는 컬렉션.size()를 출발변수로 앞?뒤? 판단해서 --로 먼저 깍아 변수 업데이트해서, --size변수== 0인지 검사한다. | . . . | 인덱스를 모르는 컬렉션의 끝인지 검사(boolean)은 size 상수 시작 -&gt; 먼저까고 &gt; 0인지 검사해서, 끝이면 true다 . 만약, size가 2라고 치면 2로 시작할텐데 첫번째 루프 -&gt; level선상 첫번째node -&gt; 안까면2, 까면 1 | 두번째루프 -&gt; 2번재node -&gt; 안까면1, 까면 0 | size시작변수는 마지막 요소일 때 먼저까고 0인지 검사하면 된다. | . | . . . | | . | 이제 Main으로 돌아가서 JsonVisitor를 통해, commandTask를 찍어서 트레일링콤마가 빠지나 확인하자 . . . level상 마지막들은 콤마를 안찍는 것을 확인할 수 있다. . . | isEnd가 아닌, 중간들만 콤마가 붙는다. . . | . | json의 트레일링콤마를 해결했다면, 이제 직렬화가 가능하므로, 메멘토패턴으로 save를 구현해야한다. . command holder(invoker)인 commandTask의 제일 꼭대기에다가 public void save()를 만든다. . 메멘토로 만든 시리얼라이제이션을 1. 외부출력하는 경우, 2.내부 기억하는 경우가 있다. | 일반적으로 프레임웤들은 내부에 기억한다. 외부에 노출되면 변조될 수 있다. | . | . | 내부에 기억하는 경우는 기억한 것을 찾기 위해일반적으로 String key를 파라미터로 줘서 외부에서 저장할 key를 공급받아 save한다 . . . | public void load도 해당String key로 찾을 수 있도록 파라미터를 줘서 생성한다. . . | Main에 있던 Renderer 생성후 root를 .render()호출하는 2줄의 코드를 복사해온다. . . | key로 save하고 load한다면 커맨드홀더 내부에 hashMap 빈컬렉션 필드를 만들어서 저장소로 둔다. . 이 때, String으로 보아둔 json을 저장하므로 String(key), String(JsonString) 자료구조다 | . . | | 이제 출력하는 JsonVisitor를 상태를 토해놓도록 sout 대신 문자열 모음으로 바꿔야한다. . 기존 | . | 메서드내부에서 처리된 문자열들을 visitor구상체로서 상태값을 선언한 뒤, string을 모아야한다. . . | **더이상 출력하지 않으므로 padding은 관심사가 아니다. 출력확인후 padding관련내용은 삭제해줘야한다. ** . . | 이제 json을 구성하는 문자열들을 result에 누적합으로 더해주자. . . . | 더이상 상태없이 유틸메서드를 담는 객체로서 JsonVisitor를 매번생성하는게 아니라 상태를 가져 재활용되는, 상태필드에 string을 모으는 객체로서 . Renderer에 방문하는 Vistor를 함형factory를 통한 매번 지연생성이 아니라 이미 생성된 객체를 반환하도록 람다식을 () -&gt; 이미 생성된 객체로 바꿔줘야한다. . | 왜 이미 생성된 객체를 넣어줄까??? . 재귀내에선 내부생성 -&gt; 재귀 타는 것이나 외부주입 -&gt; 재귀타는 것이나 재귀내에선 재활용되면서 상태업데이트(result에 모으기)는 똑같은데?? | . . | 왜냐면, saved.put( )에 visitor객체가 가진 result를 getter로 받아서 넣어줘야하기 때문에, 출력용으로 내부생성하면, 반환로직이 없는 상태다. . my) 출력관련 객체(ViewRenderer 출력용JsonVisitor)에서는, return이 없으므로 유틸객체는 factory로 받아 -&gt; 매번 내부생성후 사용하자 | 객체의 데이터를 꺼내쓸 외부에서 객체를 먼저 생성하고 -&gt; Reneder에 주입되서 객체상태변화하고 -&gt; 다시 외부에서 변화된 상태의 값을 getter로 얻어야한다 | my) 데이터를 상태값으로 저장하는 객체(saved에게 데이터 제공용 JsonVisitor)에서는, 외부에서 getter로 return을 해줘야하므로, Visitor로서 방문하기 전에 객체를 미리 선언해놓고, 방문하면서 업데이트하자. | . | 바깥에서 생성한 포장 소유 CommandTask객체인 root대신 내부 CompositeTask객체를 직접 사용하도록 변경하자 . . . | . | JsonVisitor는 Visitor오퍼레이터 이외에 자신만의 getter .getJson()을 만들어서, svaed에 시리얼라이즈된 데이터를 put가능하게 해야한다. . getter호출전에 이미 방문한 상태로서, result에 jsonString들을 모아놨으므로 return result만 해주면 된다. | . . . | save될 결과를 main에서 찍어보기 . save를 load없이 찍어보려면, 시리얼라이즈되는 로직을 가지고 와서 visitor.getJson()을 출력해야한다. . . . | . | 메멘토는 visitor로 구현하게 되면 껌이 된다. . 그러나 Composite패턴과 visitor구현이 안되서 일반적으로 메멘토 구현이 안된다. | 메멘토는 visitor동네이다. | 커맨드가 대단한 것은, bridge, adapter, 커맨드패턴이 한 동네이다. 행위를 포장하는 것이라 더 큰 동네이다. | 더 힘들다. 전략패턴동네 -&gt; 컴포지터+비지터 -&gt; 전체의 40% | 나머지는 커맨드패턴의 동네 | . | . | composite, visitor가 자유로우면 중급개발자라 본다 무한트리를 쓸 수 있으면, 실무를 해도 된다. | . | . | load는 과제이다. 일단 key를 통해 saved에서 json String을 받아온다. . . | 범용객체로서 커맨드들을 runtime에서 교체할 수 있는 것 : 커맨드패턴 . xml그 커맨드들을 설정해놓으면, 스프링빈즈가 가서 runtime에조립한다. | 빈즈는 거대한 커맨드객체다 | @autoweird등 애노테이션을 달면, 범용 커맨드객체를 만들어서, 애노테이션애들을 끼워넣는다. 범용객체를 만들었으니 끼워진다. | 다 커맨드invoker로 만들어진다. | . | @Transactional을 하려면, 상태를 저장해야한다. 메멘토 패턴을 이용한다. | undo/redo를 할 수 있다. 트랜잭션으로서 롤백을 할 수 있다. | 내가 만든 메소드도 롤백할 수 있게 된다. | . | . | 숙제 시작 . 기존 composite객체를 동적트리 순회하는 것 살펴보기 . Composite객체 자신이, 반환형을 만들 때 내부순회하는 재귀를 돌리며 report형 만들기 . 자신내부의 재귀메서드 정의 -&gt; 자신처리 -&gt; 필드 자식들돌면서 -&gt; 자식들객체. 재귀메서드호출 -&gt; 끝처리 | 끝처리가 새로운객체반환일 경우 자식들도 반환하니, 새로운객체에 add해줘야함 | . . | 바깥의 객체가 메서드 인자로 받아서 돌리기 . 바깥 객체 Renderer가 composite객체(report)를 재귀를 돌려주는 상황 생성자로 comsposite객체를 받아도 되지만, | 바깥에서 따로 돌려주는 객체가 있다면, 제어역전 객체로서, 생성자에는 visitor가 방문하게 한다 | visitor가 대신 라이프싸이클을 타면서 | . | . | 제어역전 객체의 재귀 메서드의 인자로 compoiste객체가 들어오는 상황 visitor의 메서드 인자로 composite객체가 들어가서자신의 일처리 -&gt; | getter로 자식들꺼내줘서 자식들 처리 -&gt; 재귀 | 끝처리에는 주로 composite객체 자신을 이용안한다 -&gt; visitor가 끝처리 | . | . . | | 참고, prev데코객체는 컬렉션 필드 자식들이 아니라, 같은형의 단일객체 필드를 가지고 돌아야한다. . Rule이라는 데코객체를, Calc라는 바깥 포장객체가 돌리는 상황 -&gt; 내부필드로서 메서드인자로 안받아 돌릴 수 있음 | **또한, 재귀 속 자신 -&gt; 자식들getter -&gt; 자식처리 -&gt;끝처리 대신 ** **자식들 트리순회를 안해도 되니 -&gt; while != 시작특이점객체의 [루프]로 돌릴 수 있다. ** | 1개씩 자신처리 메서드만 반복호출하면 되니 | 마지막에 자신 -&gt; 다음 것으로 업데이트만 해주면 된다. | . | 꼬리재귀 형식이며, 1번씩 계산하여 반복문 위에 누적변수에다가 누적해준다 데코객체를 통한 누적처리는 해당사항 없을 시 기본값 반환으로 처리해줘야한다. | . | . . | 힌트 . 복원하려면, 기존의 task에 있던 모든 subtask들을 날리고 봐야한다. removetask도 있고, getList도 있으니 가져와서 다날린다. | . | json을 파싱하여 composite로 순회하면서 task에 끼워넣어줘야한다. json이 한단계내려갈 때, target되는 task도 같이 한단계내려가야한다. | . | | | 현재 CommandTask라는, Composite을 포장하는 바깥객체에서 재귀순회 돌아야 하는 상황이므로 . 내부에 없다면 생성자 or visitor객체 + 메서드인자로 받아서 재귀 메서드가 받아서 돌린다 . | 내부에 필드로 존재한다면, 필드사용으로 재귀를 돌려줘야한다. . | 현재는 바깥포장객체 CommandTask가 CompositeTask를 싸고 있는 상황에서 load를 만들어야하므로 내부필드를 이용해서 돌리면 된다. 그래도 바깥이므로, 재귀로 돌릴 거면, getter로 자식들을 뽑아서 동적트리순회 돌려야한다. . . | | 일단 들어오는 key로 존재검증 + value의 json포맷 첫글자 검증을 한다. . . . | load를 위해서는 내부필드로 가지고 있는 Composite객체라면, 속을 먼저 비워야만, 다시 새로운 composite객체를 만들 수 있다. . save로 데이터가 저장된 필드 composite task는, 내부를 초기화 해줘야한다. . . | 컬렉션의 삭제시, 존재검증을 해줘야한다. . | . | 자식들의 삭제도 동적트리순회이므로 반복문 속 재귀로 호출되어야하며, 끝처리에서 자신의 자식들을 clear()해줘야한다. . 자신의 처리로서 자신의 단일 필드를 비우는 것은 나중에 덮어쓰니까 상관없다.?? | 자신의 처리에서 list를 비우는 것은, 자식들 돌고 비워야하므로, 끝처리에 배정한다. | . . . | task를 다 비웠으니, 자신의 처리로서 setTitle, setDate -&gt; 재귀로 자식들 load를 해야한다. . 그전에 먼저 json을 depth별로 파싱해야한다. . | 찾는 과정을 다음과 같이 한다. . 원하는 데이터의 prefix(&quot;title : &quot;)와 cursor를 도입해 시작점 cursor를 찾는다. . string의 indexOf(타겟, 시작index)를 통해 찾고, 커서를 이동시킬 수 있다. | . . | data시작점 cursor + substring + [ cursor+1부터 데이터끝따옴표의 index찾아 substring마지막index(exclusive)), 데이터만 골라낸다. . . | | . | 이제, 각 행위를 메서드로 추출하여, title외에 다른 것들도 데이터 추출할 수 있게 한다. . 가변변수 업데이트는 return을 통해 가변변수에 들어가게 한다. | . . cursor는 가변변수라서, inline으로 만들경우, 다음타겟에 적용이 안될 것이다. . | 이 때는 inline으로 만들 되, 인자에서 가변변수 재할당업데이트를 해주면 된다. . inlien하면 가변변수의 밑줄이 사라짐. 근데 업데이트되서 생겨야함 | . . . | . | 이제 root task에 setter로 자신의 title을 넣어준다. . . . | 타겟도 inline으로 만들어주고, 타겟을 바꿔서 date도 만들어주자. . date는 string으로 가져와도, LocalDateTime.parse()를 거쳐서 set해줘야한다. | . . . | 이제 자신의 생성처리가 끝났으니 자식들을 반복문 + 재귀호출해서 생성해줘야한다. . 여기서는 for 소유한 자식돌기 + 자식객체.재귀호출()이 불가능하다. . | composite를 만들어나가는 과정은 다음과 같다. . 자신을 만들고 -&gt; add메서드로 정보가 있는 만큼 생성하여 자식 add하기 때문이다. | . . . 자식의 자식을 add하는 것은 add한 자식list에서 getList+indexing해서 add해줘야했다. | . . | 즉 json정보를 통해 나오는 만큼 반복문을 돌면서 자식 만들어add + json에서 자식의 자식정보가 확인되면, 재귀호출 . 결국 자식의 자식add를 위한 add재귀호출을 위해 add과정을 메서드추출해서 재귀함수로 만들어야한다 | . | . | 자식직전까지 처리해야하므로 sub: [를 target으로 해서, cursor를 [다음에 자식데이터가 시작하는 곳으로 커서를 이동시켜줘야한다. . . | 일단, 컴포짓 객체의 생성은, 자식의 정보가 있는 만큼만 while로 반복문을 돌아서, 자식을 생성후 add해줘야한다. . 일단, json의 총길이만큼 cursor가 움직일 수 있으니 반복문을 cursor &lt; json.length()로 준다. | . . 반복문조건으로 들어간 변수를 이용해서 업데이트해줘서 끝나게 해야한다. | . . 현재 커서위치의 문자열을 뽑아 판단한다. {: title, date를 뽑아내서 이동했는데도, {가 열린다는 것은 새로운 자식의 시작이다. title과 date를 뽑아 add한다. cursor는 그 뒤로 업데이트 될 것이다. | . | [ &amp;&amp; 다음depth부모가 될 child!=null로 존재: 대괄호가 발견되면, 자식의 [다음자식]이 시작되는 부분으로 재귀호출되어야한다.이다. load(String key) 중 [자식처리 시작부분부터]를 -&gt; 재귀함수를 만들어 호출해야한다 [를 만났더라도, 현재자식이 부모역할로서 재귀호출인자로 들어갈 수 있게 존재해야만 다음 depth로 넘어가는 재귀호출 시점이다. 모든 자식들은 {를 가지고 있으므로 depth별 [지역변수를 도입하여, depth별 null초기화 되는, add된 현재자식child]를 기억놔야한다.을 해야한다. | . | 바깥 포장 객체내부필드로 있는 Composite객체의 생성은 root로서 자신은 setter로 완성하고, 자식들부터 root(parent)에 add하며 재귀로 생성한다 | 그전까지 composite객체의 생성은 Main에서 root만들고, add add만 때려서 제어문 없이 생성했었다. | composite객체의 사용은 모두 재귀에서 자신처리 + 반복문 자식처리로 편하게 했었다. | . | }: depth레벨선상 마지막이다. cursor를 return해서 현재depth의 stack을 제거한다. 재귀의 종착역… | . | {, [, }가 안나왔다면, cursor++로 다음 위치로 이동한다. ]는 자식의 끝인데, 나와도 무시하고 커서++해서, {로 넘어간다. {로 새로운게 뒤에 없다면 }로 끝나서 종료다. | . | . | . | 정보가 있는만큼 돌면서, sub:[ 이후로 {가 나왔다면, 자식정보 시작이다. 현재 자식의}가 나올때까지 정보에서 title, date를 뽑아, root에 add해줘야한다. . . . | [는 다음 자식정보의 시작인데, [지역변수에 child가 존재 == 부모로서 자격을갖춘놈]이라면... 다음depth의 부모로 넘어가도록 재귀를 호출해야한다. . 첫자식임을 확인하는 방법은 [반복문 위 지역변수(depth마다 초기화되는)flag]를 둘 수도 있으나 [로만 판단한다. | 자식을 add를 통해 생성하고, add는 카운터용으로서 내부생성되어 add되는 객체를 반환하므로 자식 add마다 뱉어내는 빈 task객체를 지역변수로 선언해놓고, 자식발견후 add로 생성되어 반환되는 자식객체를 재할당업데이트해서, 그 변수가 null이면, 첫자식으로 판단한다. | 또한, 자식 -&gt; 다음자식으로 가는 getter는 없다 -&gt; 다음depth로 가는 방법은 add시 반환되는 자식객체를 잡을 수 있게, 반복문위에 지역변수로 반드시 빼놔야한다. 그래야 다음depth의 자식으로 갈 때, 재귀메서드에 넣어줄 수 있다 | . 첫자식이 발견되는 순간부터, composite는 자식처리 로직부터 재귀함수를 만든다. . . . | | composite객체의 생성에 대한 동적트리순회는 자식처리 시작 로직부터를 재귀함수로 추출한다. . 재귀함수로 메서드 추출해야한다. 메서드 추출의 첫단계는 내부context(보라색)를 지역변수로 위쪽에 따로 빼놓고 추출하여 -&gt; 파라미터에 잡히게 한 뒤-&gt; 인자에 inline이다. 누적 업데이트 가변변수는 예외로서 파라미터에 없애는게 좋다?! | 누적되는 값만 추출한 메서드가 반환하게 수정할 수 있음 한다. | 재귀함수에서는 예외다. 가변변수는 변하기 때문에 재귀메서드추출시 가변변수도 파라미터로 뽑혀야 업데이트된다 | . | 재귀메서드 추출의 첫단계는 depth마다 변할 것들은 모두 파라미터로잡혀야한다. 재귀호출에서 가변변수는 파라미터로 반드시 잡혀야한다. depth마다 달라질 것이다 | . | composite의 동적트리순회용 재귀메서드는 외부에서 돌아간다면, 반드시 [composite객체]를 재귀메서드의 인자 -&gt; 파라미터로 잡혀야한다 외부 내부필드로 있으면 내부context로서 메서드추출시 안걸릴 수 있으니 반드시 확인해야한다. | 즉, 내부context(필드)를 쓴다면, 메서드 파라미터로 잡혀야하는지 확인해야한다. 특히, 외부에서 돌리는 재귀메서드는 재귀대상(composite객체)가 파라미터로 잡혀야한다 | . | . | 일단 추출해놓고, 합성된 내부필드의 보라색인 composite객체를 파라미터 추출하면 된다. . composite생성에서는 자식처리부터 시작하는 재귀를 돌고 있으므로, 재귀메서드 추출시 파라미터의 composite객체의 파라미터명을 parent로 주자. | . . . | . | 다음 depth로 가서 정보를 빼내도록 재귀로 [다음 depth상 첫번째자식]을 넣어준다 . 이 때, 재귀를 빠져나온 뒤, 업데이트된 cursor값은 반환해줘야한다 depth로 들어가 자식들을 다 처리해준 뒤, 자식들level에서 앞으로나간 업데이트 cursor가 있어야, 돌아와서 부모것의 데이터를 뽑을 수 있다. | . | 다음depth로 갈땐, [composite객체의 부모를 parent -&gt; child로 인자 업데이트로 변경]해줘야한다 | cursor를 이용한 동적트리순회는 재귀의 반환이 cursor인 것을 기억하자 | . . | 이제 재귀에 대한 종착역으로서 }(]같은데..)를 만나면 cursor를 return해준다. . . | 이제load가 완성되었으니, Main에서 save / load해서 출력해본다. . save는 커맨드홀더 속 내부필드로 있는 root Composite객체에 저장/로드된다. . | 출력하려면, root -&gt; report -&gt; visitor -&gt; renderer에 꽂기 -&gt; render로 돌리기 -&gt; visitor객체로 getJson으로 출력해야한다. . | . . | 오타들 수정하기 . jsonString에 필드는 &quot;가 없다 . . | 레벨선상의 마지막은 }가 아니라 ]다. . . | . |",
            "url": "blog.chojaeseong.com/object/2022/07/07/(object2-4)todo_2_todo_%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%8C%A8%ED%84%B4%EA%B3%BC_%EB%A9%94%EB%A9%98%ED%86%A0%ED%8C%A8%ED%84%B4.html",
            "relUrl": "/object/2022/07/07/(object2-4)todo_2_todo_%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%8C%A8%ED%84%B4%EA%B3%BC_%EB%A9%94%EB%A9%98%ED%86%A0%ED%8C%A8%ED%84%B4.html",
            "date": " • Jul 7, 2022"
        }
        
    
  
    
        ,"post27": {
            "title": "method 수준의 반복문<->꼬리재귀 변환",
            "content": "method 수준에서 반복문과 꼬리재귀 . 반복문 to 꼬리재귀 . ex1) 피보나치 수열 반복문(업데이트 변수 2개) . 피보나치 수열의 반복문 예시 . def fibonacci_loop(n): assert n &gt; 0, &quot;0이하를 입력할 수 없습니다.&quot; if n &lt;= 1: return n a, b = 0, 1 # 1 2 3 5 for _ in range(2, n + 1): a, b = b, (a + b) return b . | . 01 전체로직을 업데이트변수를 가지는 꼬리재귀 함수helper로 추출 . 반복문을 실행시키는 메서드 파라미터 n만 존재하는 상태이므로 전체로직을 꼬리재귀용 파라미터가 추가될 새 메서드(helper)로 추출한다. . . | 02 반복문에서 업데이트되는 변수들의 초기값들의, 반복문 위의 초기값을 -&gt; 파라미터로 추출 후 최초 호출 인자로 대입 . 반복문 위에 초기값으로 시작하여 업데이트 되는 변수(a,b)들을 파라미터로 빼고, 반복문 위 초기값(0,1)들을, 최초 호출시 인자로 사용하도록 올린다. . 재귀함수는 업데이트되는 값들을 파라미터로 올리고 다음 재귀 호출시, 인자에서 업데이트 시키는데 . n을 인자로 호출하여 시작해서 n-1로 업데이트되는 것처럼, 다른 파라미터도 초기값을 인자로 호출하여 매번 업데이트 시킨다. 재귀함수는 n부터 시작해서 내려가므로, n이 초기값이다. | 꼬리 재귀함수는 n이외의 파라미터도 시작 초기값을 준다 | . | . | 업데이트 되는 필수 누적결과값 b의 파라미터 추출 및 초기값을 최초호출 인자로 . | 업데이트 되는 변수 a의 파라미터 추출 및 초기값을 최초호출 인자로 . . | . . | 03 return문에서 다음 꼬리재귀만 호출 + 업데이트 로직을 인자로 대입 . 꼬리재귀를 만들기 위해, return문에서 업데이트변수들을 품은 꼬리재귀를 호출하되, 업데이트 로직을 반영해서 호출하도록 한다. . . . | 04 반복문 끝 횟수(n to 시작)의 다음을 종착역으로 잡아, 종착역에서 누적 결과값 반환 . 꼬리재귀는 마지막 연산(n -&gt; 2)의 다음을 종착역으로 잡고, 그 종착역에서 누적된 결과값을 반환한다 . 현재 반복문이 n부터 -1씩 업데이트되서 2까지 가고 있다. . | 2에서 누적연산이 끝나고, 다음번인 1을 종착역으로 잡아, 연산없이 누적된 결과값을 반환해줘야한다. . . | . . | ex2) 누적합 반복문(업데이트 변수 1개 + n도 로직에 사용) . 누적합 반복문으로 구현 . . def cumulative_sum_loop(n): s = 0 for i in range(1, n + 1): s += i return s . . | 반복문에서 업데이트시 index i를 사용하지만, n번째라고 생각하고 업데이트 인자에 반영해준다. . 반복문은 1부터 시작하지만, 재귀함수는 n부터 깍으면서 내려가며, n-1번째 연산시, index i는 n이다. | . . | . 꼬리재귀 to 반복문 . ex1) 피보나치 수열 꼬리 재귀 . 01 꼬리재귀문과 [꼬리재귀 호출부]를 복사해놓고 시작한다. . 호출부의 인자는 원래 반복문 위에 있던 업데이트 변수들의 초기값들이다. . . | . 02 n부터 깍여내려가, early return되는 종착역을 보고, (1)연산하는 종착역인지 vs 누적결과값만 반환하는 특이점인지 확인 뒤, (2)업데이트 반복문 횟수(n~종착역직전 or n~종착역) 및 return할 누적결과값 변수를 확인후 일단 n만 인자로 가지는 메서드를 작성한다. . n부터 내려가다가, 종착역은 n==1이며, 연산없이 결과값만 반환하므로 실제 반복문 구간은 n==2까지다. . 2~n까지 range(2, n+1)로 작성해준다. . 스샷에는 range(2, n)으로 오타 . . | . | . . . | . 03 꼬리재귀 최초 호출부로 넘어간, 누적 업데이트 변수들의 초기값들을 확인하여, n을 제외하고 반복문위에 업데이트 변수의 초기값으로 선언한다. . . . 04 n정의 파라미터들 -&gt; n-1일때 업데이트되는 인자들을 보고, 업데이트 로직을 반복문 내부에 넣어준다. . python이므로, 파라미터 복사 = 인자 복사 형태로 그대로 복사해서 넣어줘도 된다. | 만약, 업데이트로 로직에 n이 들어가면, 반복문의 index i 를 사용하면 된다. | . . . 05 특이점 종착역을 포함하여 초기값 early return문들은 그대로 복사 한 뒤, 종착역의 누적결과값 반환이 아니라, 초기값들을 반환하도록 처리해준다. (특이점 종착역도 연산이 없어서 반복문에 반영안되므로 초기값으로서 early return으로 처리해줘야한다. 만약, 의미가 없는 초기값이면 삭제해도 된다.) . 특이점 종착역은, 누적결과값만 반환하고 업데이트 연산로직이 없어서 반복문에 반영이 안됬다. -&gt; 그 종착역과 그 이전 초기값들 처리를 해줘야한다. . . . | . ​ . ex) 누적합 꼬리 재귀 . .",
            "url": "blog.chojaeseong.com/python/recursive/tailrecursive/loop/algorithm/2022/07/06/%EB%B0%98%EB%B3%B5%EB%AC%B8%EC%9D%84_%EA%BC%AC%EB%A6%AC_%EC%9E%AC%EA%B7%80%EB%A1%9C_%EB%B3%80%EA%B2%BD.html",
            "relUrl": "/python/recursive/tailrecursive/loop/algorithm/2022/07/06/%EB%B0%98%EB%B3%B5%EB%AC%B8%EC%9D%84_%EA%BC%AC%EB%A6%AC_%EC%9E%AC%EA%B7%80%EB%A1%9C_%EB%B3%80%EA%B2%BD.html",
            "date": " • Jul 6, 2022"
        }
        
    
  
    
        ,"post28": {
            "title": "Object) TemplateMethod to Strategy2(Plan1)",
            "content": "템플렛 메소드 패턴 -&gt; 전략패턴 . 요약 . 전략적용대상의 class가 추상클래스로 개별로직을 가지는 상태 | . 전략적용대상 추상class를 일반클래스로 변경 및 훅메서드 정의부 삭제 | 내수용 private훅메서드 호출부를, 주입된 전략객체.전략메서드()호출로 변경 | 전략 인터페이스 만들면서, 전략객체 주입 (생성자 or 확장(좋은 상속 가능성)있으면 setter로 받기) | 전략메서드 올리기 | 훅메서드구현 개별자식들을 [구상내용+전략인페명]으로 변경하고, 전략인터페이스 구현 | @Override 개별구현 proected훅메서드 -&gt; public전략메서드로 시그니쳐 변경 | 부모의 템플릿메소드 공통로직 with 내부 context변수들 -&gt; 전체를 전략메서드에 인자로 context위임 내부context변수들(보라색)을 지역변수로 추출 이후 -&gt; 제외하고 메서드 추출 -&gt; 인라인으로 메서드인자로 context 넘겨주기 | . | delegate로 추출한 전체로직을 전략메서드에 default메서드로 위임 | 위임된 default메서드 로직에서, default를 지우고 로직을 개별 전략객체들에게 구현-&gt;전달후, 기존 전략메서드(context인자X)는 삭제 | 좋은 상속(템플릿메소드패턴) -&gt; 합성객체(전략패턴) . 시작 커밋 . | 참고 내 블로그 정책적용 글 . | . 템플릿메서드는 기계적으로 전략패턴의 전략객체로 만들 수 있으며, 그 방법이 상속모델 -&gt; 합성모델로 바꾸는 것과 마찬가지다 . 판단은 조합폭팔이 일어날 것 같을 때 기계적으로 바꾸면 된다. | 연습은 상속이 보이면 조합으로 바꾸기(합성)를 해보면 된다. | . 템플릿추상클래스를 일반클래스로 내리고, 훅메서드 정의부 삭제하기 . 훅메서드가 내려가지 않고, 전략객체로 정의된 내용이 외부에서 주입된다. | . | 훅메서드() 호출부를 전략객체.전략메서드()호출로 변경하기 . 추상클래스의 훅메서드 구상 자식클래스들을 전략객체가 대신한다. | . | . . | 전략객체를 생성자 주입하기 전략객체를 생성자주입이 아닌 void setter받기기능으로 받기 . 템플릿 추상클래스는 전략객체 주입 일반클래스로 바뀌어도 여전히 추상층으로서 확장(상속) 가능성이 있다면, 생성자 주입하면 안된다. | . . | 전략메서드 만들어서 올리기 . . | 훅메서드 구현체자식들을 전략객체로 변경 . 클래스명을 구상내용 + 전략인페명으로 바꾸기 | extedns 템플릿추상체 -&gt; implements 전략인터페이스 로 바꾸기 | protected훅메서드들 public전략메서드명으로 바꾸기 | . | 전략객체를 받기기능으로 받아, 상속(확장)가능성이 있다면 class에 final을 달지말고 3가지 원칙 지키는지 확인하기 . private변수 | final or protected abstract 메서드로 구성 | 생성자 주입 말고 받기기능으로 받을 것 | | 최소 책임 전략 -&gt; context를 공유하는 연결되는 합성객체 . 훅메서드의 최소 책임 합성 -&gt; 연결되는 합성객체는 context를 공유받아 메서드단위(SRP)의 책임을 위임받을 수 있음. . | 현재 전략객체는 1개의 call만 유틸메서드처럼 입력받아 값을 반환해주며 실질적으로 연산 전체의 상태(누적변수result, 초기값 Money.Zero)인 context를 위임받진 못하고 있다. . . 하지만, 연결되는 합성객체가 되려면 해당 메서드내 context를 공유받아서 처리해줘야 제대로 책임위임받는 것이다. 훅메서드는 상속 특성상 최소의 구현만 맡고 있었고, 그것을 합성으로 변경하려다 보니, 합성객체는 context공유받아 관련 SRP를 전체로 책임질 수 있는데 못하고 있는 상태다. | . | . | 기존 코드(Plan - 전략객체 적용(주입) class) . . | . 기존 전략객체의 작은 책임을 포함하여 전략적용 메서드 전체를 전략메서드로 빼기 위해 인자가 잡힌 내수용 메서드로 추출한다. . 현재 적용객체 context의 시작 값들을 지역변수로 메서드 추출 위로 뺀다. . . . | 전략 인터페이스로 move시키기 위해 내수용으로 추출 후, 위에 빼놓은 지역변수를 인라인 으로 인자 자리에 넣어준다 . 미리 사용되는 변수들의 선언을 지역변수로 위에 빼놨기 때문에, 내수용메서드로 추출하여도 인자로 잡힌다. | . . . | | 인자잡힌 내수용 메서드를 move를 통해 전략 인터페이스로 이동시킨다. . 구현부가 존재하니, default 메서드로 이동된다. | 내부context로서 사용된 변수들이 인자가 이미 잡혀있으므로 잘못생긴this 파라미터는 제거한다 | . . . . | 새로운 전략메서드에 기존 전략메서드가 내수용으로 사용되고 있다. -&gt; 인라인 리팩토링으로 제거될 예정이다 . 새로운 전략메서드로서 default를 지우고, 구상체들이 구현하게 한다. | default내용을 구현부를 복사해서 전략객체들이 구현부에 넣어준다. | 기존 전략메서드는 inline refactoring을 이용해서 지운다. | 기존 전략메서드를 인터페이스에서 지운다. | 모든 전략객체에 구현부 복붙이 끝났으면, 전략메서드의 구현부도 삭제한다. | . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/templatemethod/strategy/plan/context/2022/07/06/Object_template_to_strategy_to_context_composition.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/templatemethod/strategy/plan/context/2022/07/06/Object_template_to_strategy_to_context_composition.html",
            "date": " • Jul 6, 2022"
        }
        
    
  
    
        ,"post29": {
            "title": "SIDE)추상체X추상체 관계에서 템플릿,전략패턴 적용",
            "content": "상호의존도 도시 . . . . . . 문제점 . Director 내부에서 추상체ProjectPaper를 가지고 있지만, 추상층의 정보(전략메서드, 템플릿메서드)가 부족하여, 특정형인지 확인후 작업한다. instanceof는 2개이상이면 if의 문제라고 본다. | 개별구상체를 물어보지말고 시킬 수 있는지 확인한다. (혹시나 this로 넘어가면… 문제가 생길 수 있다.) 중복로직이 존재하면, 템플릿메서드로 | 중복로직 없으면, 전략패턴으로 | . | . | . FrontEnd, BackEnd내부에서 추상체 ProjectPaper를 받아오지만, 추상층에 물어보고(get) -&gt; 필드에 저장(set)하기 위해서 if instacneof가 생긴 상태다. . 구상체별로 물어보지 않으려면 (getter -&gt; setter)에서 set시키기 위해 this로 나 자신을 넘겨 시켜야 하는데 | 나 또한, Programmer의 구상체로서, 추상체로 넘어가 -&gt; 물어보고 set시킨다. | 나에게 set등의 로직을 가져 나를 넘기면서 시켜야하는 로직일 때, 내가 추상체로 넘어갈 상황이면 넘기지 말고 물어보도록 두자. | instanceof가 2개이상이라 if의 문제라고 본다. | 추상체에, 시켜서 해결하는 방법이 템플릿메서드, 전략메서드다. 하지만, 시키는 로직이 this(추상체)로 넘어갈 경우 따져야한다. | instanceof 2개이상이 해결이 안된다면 넘어온 추상체(paper)의 구상형들 자리에 제네릭 T를 넣어서 -&gt; 인스턴스는 특정형을 사용할 수 있게 한다. | if 2개이상으로 개별 구현로직이 생기기 때문에, 현재 class를 중간추상층 with T로 만든 뒤, 최종구상층에서 T를 개별구현시키도록 한다. | | . . | 실습용 초기코드 . 해당 develop br의 커밋 | . 해결1: 추상체 X 추상체로 인해 한쪽 구상체가 넘어오는 추상체의 instanceof 구상형(제네릭)마다 다른 개별로직(자체 추상화) 구현을 해결해보기 . 설명 . . 넘어오는 추상체에게 시킬 수 없다면(그 추상체(1)가 this(N, 나도추상체)로 받아가서 더 복잡해지는 1:N관계) 넘어오는 추상체에 전략메서드/템플릿메소드로 추상화로 시키기가 불가능 하다. | 그렇다면, Type에 따른 개별구현 로직은 나를 추상화 + 개별구현메서드를 T형으로 처리하는 수 밖에 없다. | 개별구현 로직이 구상층으로 넘어간다면, 나는 여러형을 T형으로 줘서, 최종구상층이 특정형을 알고 개별구현하게 한다. | . | 내부에 instanceof = 여러Type을 T의 제네릭으로 대체하려면, 나는 인스턴스&lt;특정형&gt;의 일반class이거나 | T형에 따라 개별구현이 내부에 존재하는 구상체라면, 분신술 개별구현 익클&lt;특정형&gt;의 추상클래스여야한다. | . | . . 실습(템플릿 메소드 -&gt; 제네릭) . 제네릭으로 instanceof를 지우기 전에, 추상체 파라미터의 Type에 따른 개별구현 로직을 제거하기 위해, 전략객체에 추상화가 아닌 나를 추상화(중간추상층)화 해서 if 1개를 없애야한다 . 각각의 if후 return createFrontEndProgram();의 공통로직이 존재하므로 템플릿메소드패턴으로 나를 추상클래스로 만들어 추상화해야한다. 여러 if들을 포함하는 전체로직이public 템플릿메소드에 전체로직이 쌓여있는지 확인한다. -&gt; 현재 완료 | 1개의 if에 대해 전체로직 내부의 개별구현로직은 내수용메서드 형태의 protected abstract 훅메서드로 추출한다 | 다른 if의 개별구현부는 주석처리후 if문을 삭제한다. 다른 if의 개별구현 로직들은 최종구상체들이 사용할 로직으로서 주석으로 보관하여 훅메서드 근처에 옮겨둔다. | . | 클래스에는 abstract를 달아주고, 훅메서드는 protected abstract가 달려있는지 확인한다. | | . . . | 1개의 if만 남기고 삭제하고(개별구현은 주석으로 챙겨놨다.) if 및 instanceof 삭제후 구상체 대신 추상체를 사용하도록 로직을 바꾼다. . . . | 이제 최종추상층(익클-분신술)이 개별구현시 특정형을 알고서 &amp;&amp; 그것을 받아 개별구현하도록 제네릭T extends upperbound처리를 해준다. . . . | 이제 FrontEnd 인스턴스를 사용하던 곳에서 제네릭 + 익명클래스로 구현해야한다. . 제네릭을 안달고 implements 훅메서드 하면, upperbound가 T자리를 차지하니 제네릭을 먼저 달고 구현한다. . | 개별구현은 T에 들어갈 구상체마다 다른데, 주석으로 보관해놨으니 참고한다. . | 익명클래스는, 분신술의 원조 추상클래스의 필드를 protected로 변경하여 편하게 사용한다. . . | . . . | 이제 추상체(paper) -&gt; 추상체(programmer) 의 구상체(FrontEnd)이외에 나머지 구상체들(BackEnd)도 똑같이 추상화 -&gt; 제네릭 처리 해준다. . | 중간추상층이된 FrontEnd와 BackEnd가 각각이 템플릿메소드로서 공통로직을 가져 -&gt; 상위추상층을 템플릿메소드패턴 적용해서 올리기 . 기존에 인터페이스가 상위추상층으로 있으면, 훅메서드가 안올라가므로, 추상클래스로 변경 먼저 해놓는다. . . | compare file로 2개의 구상체를 띄워놓고, 구상체 1개를 선택하고 . public 템플릿메서드 + private내수용 훅메서드를 만들고, 각각의 메서드명을 추상화해서 올린다. . private메서드를 같이 members로서 같이 들고 올라가야하므로 밑에 것을 선택한다. . . 훅메서드로 들고올라가는데, 이미 구현된 private메서드를 올리면, 자식은 부모를 개별구현된 상태로 남아있다 . 반면 올리기 전에도 훅메서드(protected abstract)였던 메서드와, public 템플릿 메서드는 그대로 올라가서, 자식에게는 업섹 된다. | . . | . | . | . . . | . | 메서드를 올리는 FrontEnd내 메서드가 T extends ProjectPaper형을 써서 올리면, 상위추상층은 단지 upperBound로 구현하고 있으니 최종구상층이 특정형이 아닌 추상체를 써라는 에러가 나온다. . . FrontEnd&lt;T extends ProjectPaper&gt;의 부모인 extends Programmer에 Programmer&lt;사용 T&gt;를 쓰도록 만들고 . | Programmer class 자체에서는 &lt;T extends ProjectPaper&gt;로 정의한다. . 사용 T를 미리 지정해놓고 -&gt; 자동완성 -&gt; Change signature of to match &lt;T&gt;를 사용하면 된다. | . . | 이제 올라간 템플릿 메소드 및 훅메서드에서 추상형 대신 T형으로 정의해놓고, 최종구상층에서는 특정형을 알게 한다. . | . . | backEnd도 마찬가지 처리를 해준다. . . 제네릭이 제대로 되어있나 확인하고 | 템플릿메서드는 지워주고, 훅메서드는 메서드명을 맞춰준다. | . . | 이제 FrontEnd, BackEnd의 사용처(Director#runProjectPaper)로 가보면 . 자신들이 분신술로 인스턴스를 생성하면서, 특정형을 알면서 개별구현하도록 구현되어있다. . . . | . | 해결2: if instanceof는 [전략패턴]으로 시킬 수 있음 시키자. . 설명 . . if instanceof는 추상체에게 물어보고, 내 내부에서 펼치는 것 -&gt; 추상체에게 getter이후의 로직까지 시킬 수 있나 확인한다. 현재 context도 같이 넘어가면 this로 넘어가는데, this가 추상체인지 확인한다. 만약 추상체라면 N:1관계를 확인한다. | 지금은 추상체 -&gt; 각 구상체 -&gt; director(this)에 영향을 주는 로직이 없으므로 메서드(추상체)로 추출 -&gt; 이동 -&gt; 추상체.메서드()로 시킬 수 있다. | . | 공통로직이 충분히 있고, 틀이 잡히고, 나를 추상클래스로 + 훅 구상체class들(or익클분신술로 외부구현)을 만들거면 템플릿메소드패턴으로 추상화 / 그게 아니라 들어오는 추상체를 전략인터페이스로 간주하고 전략객체들만 만들거면 if 내부 전체를 개별로직으로 보고 전략패턴으로 추상화 현재는 public 메소드내에 있지만, 공통로직이 없다고 보면 된다. deploy()는 director의 내수용 메서드이며, 추상체가 개입안하는 부분이다. | 구상체들로부터 추상체를 만드는 게 아니라, 내부 if 로직으로 템플릿메소드 패턴을 적용한다면, 내 자신(Director)이 추상클래스가 되어야하는데, Director를 추상클래스로 만든 이유가 없다. 들어오는 추상체에게 시키기만 하면 된다. 템플릿메소드패턴의 추상클래스 + 훅 구상체들 = 전략객체주입 일반클래스 + 전략인터페이스 + 구상 전략객체들 director내부 내용을 익클 분신술 director로 생성하면서 구현할만한 size가 아니다. | 시킬 수 있으면 추상체에 시켜서 나를 추상화하면 안됨. | . | 나 자신을 추상클래스로 -&gt; ADirector BDirector등으로 만들것이 아니라면, 템플릿메소드패턴X | . | . | 실습(전략 적용) . 여러 if들을 포함하는 전체로직 여러 if들내에 구상체가 사용되어 반환되는 로직을 확인한다. . 반환값이 2개이상이 되는 순간부터는 메서드 추출이 안되므로 반환값이 1개인 if가 있다면, 그쪽 if에서 메서드 추출한다. | 구상체로부터 이어지는 로직과 원래 현재class의 로직을 구분해서 if별 개별구현 부분을 확인한 뒤 메서드로 추출한다. | . | 1개의 if에 대해 전략메서드로 처리될 개별구현 로직만 내수용메서드( 구상체 )형태로 추출한다. 전략객체가 될, 현재 파라미터의 구상체class로 move하면 전략객체.전략메서드()가 형태가 된다. . 1개의 전략메서드 내부 구현된 구상체class로 옮기기 위해서, 아직 추상체로 변수명을 바꾸진 않았다. . | 내부에 사용되는 구상paper의 내용이 있다면, this로 바뀐다. . . | . . | 추출한 예비전략메서드를 -&gt; 선택된 구상체 내부로 로직을 이동시킨다. . . | 옮겨간 구상체1개만의 전략메서드를 @Override를 통해 추상체(전략 인터페이스)에 오퍼레이터로 만들어주고, 해당 구상체if문을 추상체.전략메서드()형태로 바꿔준다. . . . ​ . | 다른 if의 개별구현부는 주석처리후 나머지 if문을 삭제한다 . 다른 if의 개별구현 로직들은 최종구상체들이 사용할 로직으로서 주석으로 보관하여 훅메서드 전략메서드 근처에 옮겨둔다. | . | 주석처리한 개별구현로직은 각각의 전략객체에 구현될 메서드에 옮겨준다. . | 이 때, 반환값 갯수가 다를 경우, 배열을 응답값으로 활용한다. . 추출한 전략메서드는 1개 Program, 2번째 전략객체의 응답값은 2개 Program -&gt; 응답형을 배열로 바꿔서 처리해준다. | . . | 추가: 전략객체/템플릿구상체들의 개별구현로직을 외부로 밀도록 나 자신을 추상화 . 설명 . if분기에 해당하는 전략메서드 / 훅메서드들을 특정 구상체class가 담고 있다. 해당 개별구현을 나를 추상클래스로 추상화 -&gt; 외부에서 익명클래스로 개별구현한다면, 최후에 개별구현 로직을 client에서 DI 선택해서 해결가능한 형태를 만든다. | 나를 추상클래스화 해서, client에서 개별구현을 선택해서 작성하는 형태는, 개별구현로직이 달라질 때, 구상층 추가시 유용할 수 가 있다. . | 참고 . . | . 실습(전략객체들의 중간추상층화 -&gt; 전략메서드 구현을 client로) . 개별구현하는 구상체들을 모두 abstract 달아주기 . 다는 순간, new 구상체();로 객체로 만들었떤 것들이 -&gt; 단순 객체생성으로 사용 불가하게 됨. | 다는 순간, 필수구현이 -&gt; 선택구현으로서 익명클래스에서 구현해도 되도록 변경된다. | . . | 개별구현 로직을 복사한 뒤 -&gt; 전략메서드 삭제 -&gt; 생성자의 usage(alt + f7)를 통해 일반class의 객체로 생성되었던 곳(client)에 개별구현로직 복사해서 옮겨 구현하기 . 추상클래스로 변화 -&gt; 단순 객체로 생성했던 곳이 익명클래스로 구현해야하는 것으로 바뀜 -&gt; 생성자 사용처들에 개별구현로직 복사한 뒤 구현해주기 추상클래스상에 구현해서 막고 있는 전략메서드를 삭제해야 -&gt; 구상체들 implement가 되니 구현로직만 객체생성처에 옮겨놓기 | . | usage를 find Tool window로 보기 위해 alt + F7을 활용한다. | . . 옮긴 뒤 context(this)가 달라지는 것을 수정해준다. paper를 벗어난 상황이므로, paper의 필드를 얻으려면 this.필드 -&gt; paper.getter()로 변경해줘야한다. | . | . . | 나머지 전략객체(TxPackagePaper)도 추상화해주기 . abstract달기 | 생성자 사용처(객체 생성)에 가서 개별구현 로직 옮겨놓기 | 전략메서드 삭제후 생성자 사용처(객체 생성)에 익명클래스 구현하며 로직 만들기 | | 참고 . . | ​ .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/relationship/side/hospital/templatemethod/strategy/2022/07/05/(side)%EC%B6%94%EC%83%81%EC%B2%B4X%EC%B6%94%EC%83%81%EC%B2%B4-%ED%85%9C%ED%94%8C%EB%A6%BF_%EC%A0%84%EB%9E%B5-%EC%A0%81%EC%9A%A9.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/relationship/side/hospital/templatemethod/strategy/2022/07/05/(side)%EC%B6%94%EC%83%81%EC%B2%B4X%EC%B6%94%EC%83%81%EC%B2%B4-%ED%85%9C%ED%94%8C%EB%A6%BF_%EC%A0%84%EB%9E%B5-%EC%A0%81%EC%9A%A9.html",
            "date": " • Jul 5, 2022"
        }
        
    
  
    
        ,"post30": {
            "title": "SIDE)계약, 거래의 트랜잭션 관계 맺기",
            "content": "계약과 거래를 하는 트랜잭션 관계 . 계약하기 . 형태 을인 doctor가 reception들에게 [void setter/boolean 거래 제안기능]을 통해, [거래조건]과 함께 먼저 알고서 데리고 온다. [거래 제안기능]은 내부에서 갑인 reception의 [boolean 거래 수락기능]을 통해 결과를 받아와서, 결국엔 내부 필드에 계약자들을 저장하는 void setter받기기능과 유사한 형태며, boolean으로 doctor를 사용하는 사람에게 알려줘도 된다. | . | 갑인 reception은 [boolean 거래 수락기능]을 통해, doctor와 [거래조건]을 알고서 데려가 검증한 뒤, 성공시 필드에 거래조건과 함께 저장하며, boolean으로 수락여부를 을인 doctor에게 알려준다. 계약이든 거래든 갑이 데리고 가서 검증/결정후 결과를 반환해서 알려주면 을은 결과에 따라서 행동한다. | . | . | . 을(doctor)가 먼저 [boolean 거래제안 기능]을 거래대상인 갑(reception)에게 [거래조건]과 함께 제안한다. . . | doctor의 계약제안 기능의 내부에서는 . 갑의 [boolean 계약수락 기능]을 호출한 뒤, 반환받은 결과에 따라 행동한다. . | 추가로 이미 계약중(컬렉션필드 -&gt; CRUD 생각 -&gt; CREATE시 중복검증)되면 안된다. if A &amp;&amp; B 여야만 수행 -&gt; 컬렉션에 계약자로 추가 **if not A |   | not B -&gt; return false (early return) -&gt; 수행** | . 만족(if A) 시 수행이라면 not A early return을 고려한다. | **둘다 만족시(if A &amp;&amp; B) 수행이라면, not A |   | not B early return을 고려한다.** | . **둘다 return값이 동일하다면, |   | 로 묶어서 한번에 early return** | . | . | not A return (early) false ; | not B return (early) false; | 수행 == not A |   | not B reutrn (early) false; | . | == 수행 | . | . | . | . | Set컬렉션을 쓰고 있으므로 중복검증(A)는 생략한다. if not B early return 후 수행만 하면 된다. | . | . . . | reception의 거래수락 기능 내부에서는 . 거래대상과, 거래조건을 매칭해서 저장할 HashMap 필드를 만들고 | (거래는 상대방의 돈검증) 이미 계약중인지, 거래대상 검증(중복검증)을 한다. | (거래는 내가 줄 물건검증) 계약대상과 계약조건을 내부필드에 저장하여 계약한다. | (거래는 상대방 돈차감 -&gt; 물건반환) 수락여부true를 반환한다. (검증실패시 false) | . . . | 계약 제안/수락 기능처럼, 계약취소 제안/수락기능도 있다. . 계약취소 제안기능(DELETE) . A: 계약취소 대상자 존재 검증 &amp;&amp; B:갑의 계약취소 수락기능의 결과가 true . 둘다 만족해야지 수행 **not A |   | not B early return한다.** | . | . | . . . | . | 계약취소 수락기능(DELETE) . 갑으로서 누구의 결과를 기다리지 않으니, 삭제 전 존재 검증만 하면 된다. . . | . . | | 거래하기 . 참고 . . Patient가 [void setter구매기능]을 통해 거래를 제안한다. . | Coordinator는 최초 [getter물건 판매기능]을 제공하고, Patient에게 결과를 [물건반환]으로 알려주는데, 실패시 NULL객체를 반환한다. (NULL객체를 쓰는 순간, boolean의 반환이 필요없어진다.) . A(돈 검증) &amp;&amp; B(물건 검증)시 상대방의 돈을 차감한다. 돈 가산은 물건을 주는 Reception에게 미룬다. not A |   | not B early NULL객체 return을 해도 될 것 같지만. | . if A 와 if B 사이에 로직이 존재하여 early return이 불가하다. | . | 이 땐, 실패의 else마다 똑같은 값이 반환되므로, 애초에 반환값을 EMPTY(NULL객체)로 변수로 선언해놓고 시작하고, 성공시 재할당하여, 마지막에만 해당 변수를 return한다. | . | . [상대방 돈 검증] 하기 전, 검증기준인 [물건의 가격을 계산]해야한다. . Coordinator는 계산의 책임을 수수료를 챙겨서 계산하는 Reception에게 [물건 가격 계산]도 위임한다. . | 사실, 물건가격계산은, 정책이 적용될 Specialty객체로 바로 할 수 있지만, 의존성이 1곳에서만 생기도록 Reception에게 위임한다. . | . | [상대방 돈 검증] . | [건네줄 물건 검증]을 하기 전, 검증 기준은 [물건]을 받아와야한다. . Coordinator는 최초 물건 발행권자인 Doctor로부터 생성해서 받아와야하므로 [getter물건 판매기능]을 Coordinator -&gt; Reception -&gt; Doctor까지 연쇄적으로 호출해서 물건을 받아온다. | . | [받아온 물건 검증] . | [상대방 돈차감] . 돈 가산은 계산의 책임이 있는 Reception에서, Reception의 [판매기능]내에서 이루어지게 한다. | . | [물건 반환] . | | Reception . 연쇄적인 [getter물건 판매기능]안에서 들어오는 [구매정보 검증]을 한다. 돈 검증은 구매자와 최초연결된 Coordinator에서 담당한다. | [정보 검증]을 통해, Doctor로 가서 Package발행 전에 NULL객체를 물건으로 반환해서 미리 컷한다. | . | [물건 검증]전, 물건을 Doctor의 [getter물건 판매기능]으로 떼온다. 수량제한에 걸려서 Doctor가 NULL을 건네줄 수 있다. | . | [물건 검증] | [돈 가산] 물건이 검증되면, Coordinator의 돈차감과 같은 레벨로 [돈 가산]을 해야한다. | 구매정보에 담긴 (정책적용객체) Specialty에서 물건가격을 계산하고 | **구매정보의 doctor와 계약된 commisionRate를 꺼내서, 수수료를 계산해, [내 자본금을 가산] **한 뒤 | 물건가격 -수수료 만큼을 [발행권자 doctor에게 가산]해준다. 계산은 Reception에서만 이루어져서 나도 챙기고, 발행권자도 챙겨준다. | . | . | [물건 반환] | | Doctor . 연쇄적인 [getter물건 판매기능]을 통해 물건을 생성해야하는데 | . 내가 소유하고 있는 정보로 [구매정보 검증]한다. Reception에서 컷 안당했지만, doctor만의 소유정보로 컷 당할 수 있다. | 예를 들어, Specialty - Treatment들의 매칭 정보 | . | [발행 전 발행가능 갯수 검증]을 한다. 발행가능 갯수는 Treatment의 count로 명시되어있으며, 생성될때마다 감산되어야한다. 발행가능한지 검증(trigger) 실패시 runtime에러를 낸다. | . | . | [물건 발행하여 반환]한다. | | . | . 환자는 [void setter 구매기능]을 통해 Coordinator(거래대상, 갑) 이외에 구매package정보들 from 발행doctor내부정보와 구매 갯수를 같이 인자로 넘긴다. . . | 구매기능 내부에서는, 거래의 갑인 Coordinator의 [getter물건 판매기능]을 이용하여 반환받아 저장한다. . 실패시 NULL객체가 반환되도록 짤 예정이므로 바로 필드에 저장만 하면 된다. | . . | coordinator(seller)의 판매기능은 거래 성공의 조건이 if + 로직 + if로 복잡하고 까다롭기 때문에 . 그외 많은 경우가 실패이므로 early return없이 default NULL객체가 반환되도록 미리 반환변수를 NULL객체로 선언하고, 성공의 경우 재할당해주도록 짠다. | . . 쿠폰 유무의 경우의 수를 if + else 로 하기 싫다면 if + if 혹은 if-earlyreturn + NoIf 를 선택한다. | . | 일반적인 쿠폰이 없는 경우부터 작성한다. Seller가 먼저 상대방의 돈 검증을 시행해서 돈 없으면 컷 해야한다. 그러기 위해선, 돈 검증 전에, 물건(Package)의 가격을 계산해야한다. . 가격계산은 가격정책이 적용될 예정 &amp;&amp; fee를 가지고 있는 Specialty객체로 할 수 있다. | 그러나, specialty를 Coordinator내부에서 사용할 경우 vs 전달만 할 경우 의존성을 가지냐 안가지냐의 차이를 가지므로 specialty를 받아가고, 계산도 할 Reception에게 가격 계산의 책임을 위임한다. . | 구매 물건의 가격을 계산시, 1개당 가격정보를 포함하는 Specialty + 몇개 살 것인지 Count도 같이 받아야지 총 금액이 계산된다. 또한, 차후 정책조건의 trigger에서 sequence/time 등을 조건판단 정보로 주려고, 지금은 사용하지 않는 treatment도 같이 넘겨준다. | . | . . reception의 판매기능 내부에서도 결국 가격은 fee필드를 가진 specialty가 한다. . . | 정책이 없다면, specialty는 내부 1개당 가격 X count를 해준다. 나중에 NONE POLICY에서 이걸 반환하면 될 듯 하다. . . | 맞는지는 모르겠지만, count만큼 돌면서 money를 더해서 곱하기를 만들었다. . | . | . | 구매자 돈 검증 . . | 물건 검증 전에, 물건 떼오기 from Reception . 물건을 생성해주는 Doctor까지 위해 정보들을 다 전달해줘야한다. | Coordinator와 연결된 Reception에게 doctor부터 물건정보 + 갯수까지 다 전달한다. . | 물건을 떼오는 것도, reception입장에서는 getter물건 판매기능으로서, 실패시 NULL객체를 반환, 성공시 정상물건이 온다. 이 때, default NULL객체의 물건반환변수에 재할당한다. | . | . . reception은 앞에서 이미 상대방 돈검증으로 미리 컷 가능하게 했으니, 구매정보 검증을 통해 doctor에게 가기전 컷(NULL객체로 물건반환)할 수 있게한다. . 3가지 구매정보 검증( A&amp;&amp; B&amp;&amp; C)을 다 통과해야하지, 판매가 진행되므로 . **not A |   | not B |   | not C** -&gt; early return false대신 NULL객체를 사용한다. | . | . . | doctor가 제공하는 isValidMatching . . | treatment가 제공하는 구매가능갯수 검증 . . | . | doctor는 [getter물건 판매기능]으로 물건을 만들어서 반환해줘야한다. . 내부에서는 생성전, 구매정보 검증하여 미리 컷(NULL객체 반환) . 돈 검증 대신 구매정보 검증한다. | . | 발행(생산)전, 구매갯수가능 검증 및 차감 . 물건검증-&gt;돈차감 대신 생산가능갯수 검증 및 갯수 차감을 한다. 차감의 책임은 treatment에 있으며, count필드로 조정한다. | . | 물건 생성하여 반환 . . | . | reception은 떼온 물건을 검증한다. . . | reception은 구매자돈차감(Coordinator)대신 돈 가산(reception-커미션, doctor-나머지 금액)을 한다. . . | recpetion은 물건을 반환한다. . if 물건검증 통과시만 돈계산이 이루어지고, 내부에서 반환은 안한다. if 내부에서하지 않아도 이미 물건떼오기에서 반환받은 물건은 if와 무관하게반환될 물건은 결정된 상황이기 때문이다. | 반환될 물건은 이미 결정, if 정상물건일시, 돈계산 추가 | . | . . | . | 떼온 물건 검증 후 -&gt; 환자(구매자)의 돈차감 . . | 쿠폰이 있는 경우는, Coordinator가 어떻게 해야할까 . 돈계산 -&gt; 돈검증안한다. | 물건 떼오기 -&gt; 물건 검증 -&gt; 돈차감이 아니라 쿠폰차감 with count만큼 | . | 일단 reception에게 물건을 공짜로 가져온다. . reception에서는 doctor에게 발행하여 물건 받아오는 과정이 완전히 동일하기 때문에 . sellPackage 메서드를 그대로 쓴다. | doctor의 기능은 돈계산이 없이 정보검증 -&gt; 구매가능갯수 차감 -&gt; 발행의 3단계만 거치기 때문이다. | . . | reception은 물건검증 성공시 돈차감했었는데, 돈차감이 없으니 물건검증도 생략한다. . | . | Coordinator에서는 물건 검증이 되면, 돈차감 대신 patient의 쿠폰을 차감한다. 여러개 골랐으면 갯수만큼 차감해야한다. . . | patient는 Coupon coupon = Coupon.EMPTY로 1개 밖에 못들고 있게 설계되었다. . 여러개 쿠폰을 가질 수 있게 coupon필드를 컬렉션으로 바꿔줘야한다. . . 필드를 바꾸면 getter나 eq/hC도 변경해준다. | setter도 할당이 아니라 add로 바꿔준다. / remove도 NULL객체 할당에서 remove(0)으로 바꿔준다. | . | 컬렉션 필드의 검증은 EMTPY(NULL객체)가 아니라 size로 하도록 다시 다 바꿔줘야한다. . | . | 돈계산 -&gt; 돈검증 대신, 돈검증 자리에 구매count만큼 Coupon을 들고 있는지도 검증한다. . . . . | 원래로직을 유지하고 (뒤에 쿠폰없는 상황에 대한 early return이 껴있는 상황) . 쿠폰 갯수가 모자랄 땐, 에러메세지로 알려주도록 early thr를 던졌다. | 그대로 두면, 쿠폰갯수가 모자라면 NULL객체로 갈텐데, 그것보다 직접 알려준다. | . . | Doctor -&gt; Paitent 쿠폰 주는 것에 대해, 갯수를 정해서 주고, 차감시에도 여러개 차감하게 한다. . 쿠폰 직접주기 in Doctor by Client . | 쿠폰 차감 in Patient by Coordinator (돈 차감 대신) . . | . | Package와 Coupon을 발행하는 Doctor(생산자)는 Patient(구매자)가 가진 데이터객체(Package)를 확인하는 검증을 한다. . Doctor는 필드에 무리하게 Many테이블의 정보를 컬렉션으로 모은 상태의 정보전문가로 만들어놨다. 원래 DB에서는 Many테이블의 One테이블의 정보를 fk로 가진다. | . | . . Doctor가 Paitent들의 구매한 Package들을 검증한다. . . | . | Doctor는 내부정보로 검증할 예정이므로 Patient를 인자로 받아서 . 물건 제공받기 by getter 물건 검증(기본) : NULL객체 검증 | 물건 기본정보(필드) 검증 by getter 발행권자로 받은 것(Doctor자신) | 상하위도메인 매칭정보 검증 Treatment는 사기전 count필드와 사고난 후 count필드가 변한다 | 구매정보 비교시, 구매 전후로 변하는 필드인 Counteq/hC에서 제외한다. | . | 구매한 갯수 vs 검증할 갯수 검증 | | | . | A &amp;&amp; B &amp;&amp; C &amp;&amp; D의 검증은 검증마다 early thr를 날려서 어떤 것에 검증실패했는지 알려주도록 변경한다. . . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/policy/side/hospital/transaction/2022/07/03/(side)%EA%B3%84%EC%95%BD,-%EA%B1%B0%EB%9E%98%EC%9D%98-%ED%95%98%EB%8A%94-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B4%80%EA%B3%84.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/policy/side/hospital/transaction/2022/07/03/(side)%EA%B3%84%EC%95%BD,-%EA%B1%B0%EB%9E%98%EC%9D%98-%ED%95%98%EB%8A%94-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B4%80%EA%B3%84.html",
            "date": " • Jul 3, 2022"
        }
        
    
  
    
        ,"post31": {
            "title": "SIDE)특정객체에 정책적용",
            "content": "준비물(정책 조건과 액션) . 정책 조건과 액션 종류 조건(-Condition) Sequence: 순서에 해당한다는 조건(혹은 선착순 몇명 안에 조건) | Period: 특정 기간내에 해당한다는 조건(혹은 특정기간에 드는 조건) | DayOfWeek: 특정 요일에 해당한다는 조건 | None: 조건없이 시행 | | 액션(-Discount) Amount: 일정 금액을 Discount해준다. | Percent: 일정비율을 Discount해준다. | None: 할인 없음. | | | method1: trigger+action의 인터페이스 + 마커 인터페이스 . 설명 . 정책 condition 인터페이스: trigger와 action추상메서드를 다 가질 것임. . 발동조건 검증 메서드 역할(추메) | 액션 메서드 역할(추메) | | 정책 action 인터페이스: 마커인터페이스들을 내부에서 가짐.(enum과 비슷한 역할) . enum대신 인터페이스 속 마커 인터페이스들로 구성 됨. . | 마커인 이유: 실제 정책내용을 같이 붙어다니는 조건 정책의 액션메서드에서 실제 정책내용을 구현할 예정 . 정책 trigger 인터페이스가 2개의 추상메서드(trigger, action)을 다 가진다. . | 정책action마커인터페이스를 구현한 정책action별 중간추상층(추상class)을 두어 1개의 추상메서드만 구현한다. . 이 때, 특정 action마커인터페이스 구현 &amp;&amp; action메서드를 먼저 구현한 중간추상층으로 만들어야 | . | 정책을 적용할 객체 생성시, 특정 action 중간추상층 알도록(T자리에 대체)한 최종구상체를 선택하여 action이 적용된 객체를 생성할 수 있게 된다. . . | 제네릭을 통해, 특정action추상층을 알게된 정책적용객체는 제네릭으로 알게된 만큼, 그 추상층를 생성자 인자로 사용하여, 생성자에서 구상체들을 받을 수 있게 된다. . | action별 중간추상층마다 condition별 최종구상층을 만들어서, condition메서드를 구현하여 구상화한다. . . . | | . | my) . 각각이 추상메서드로 가지는 인터페이스로 구현했다면? . DiscountPolicy인터페이스에 action메서드가 올라가며 | DiscountCondition인터페이스의 trigger메서드도 같이 implements하여 | 최종구상체는 2개의 메서드를 구상하게 된다. | 하지만, movie마다 특정 action정책을 줘야하는 카테고리화를 못한다(action별 추상층이 없다) | movie가 특정action에 대한 여러 condition들을 동시에 인자로 받을 수 없다(action별 추상층이 없다.) | . | action X condition의 조합의 상태에서, . 2가지 중 1가지로 카테고리화하려면, 추상층이 2개(action -&gt; condition or condition -&gt; action)여야하며 | 카테고리 대상(action)인터페이스를 먼저 구현하는 중간추상층이 필요하다. | 조합의 나머지(condition)은 구상층에서 구현한다. | 상위 추상층은 2개의 메서드를 가지는 1개(DiscountCondition)로도 충분하지만 | 1개 메서드를 구현한 중간추상층을 만들 때, 중간추상층별 나는 특정action 상층이다!를 나타내줄 마커인터페이스들이 필요하다. | . . | . | . 실습 . Action 중간추상층 1개 -&gt; Condition+Action 최종구상체 1개 생성 . 정책을 적용할 객체를 정책주입 없이 먼저 구현한다. . 내부 정책이 적용될 대상메서드 등이 다 구현되어있어야한다. . . | . | 적용할 정책을 설계해보기 위해, client에서 그림을 그려보기 . 정책적용은 action(어떤 할인 적용할지) vs condition(어떤 조건에 적용할지) 2가지 카테고리가 있는 상태다 각 카테고리마다 나올 2가지 전략메서드를 한개의 인터페이스에 몰아넣는다 생각한다. | 먼저 1개는 중간추상층엑에서 구현 -&gt; 나머지 1개는 최종구상체에 이름을 추가하여 구현한다고 생각한다 | 먼저 구현할 카테고리의 종류마다 -&gt; 나머지 카테고리들을 가지게 된다고 생각한다. action을 먼저 구현한다면 AmountDiscount, PercentDiscount (중간추상층 2개) aAmountDiscount, bAmountDiscount, cAmountDiscount,dAmountDiscount (각 중간추상층 마다 4개) | aPercentDiscount, bPercentDiscount, cPercentDiscount,dPercentDiscount (각 중간추상층 마다 4개) | . | . | . | 그렇다면, 2가지 카테고리 중 어느 카테고리를 먼저 선택할 것인지에 따라 중간추상층으로 먼저 구현하게 한다고 생각한다 | 정책적용 객체는 중간추상층을 upperbound로 제네릭을 적용하여 -&gt; 해당 중간추상층을 구상체들만 알고서 인자/파라미터에 받을 수 있게하여 해당 카테고리의 1개만 적용할 수 있게 한다고 생각한다. | | 아래의 예시는 . action으로 먼저 카테고리화하고, 각 action마다 중간추상층을 만들 것이다. . | 제네릭에 action중간추상층을 사용하면, 내부 T로 정의한 변수들은 중간추상층의 구상체들만 올 수있게 되므로, 해당action에 대한 condition들을 선택하여 집어넣을 수 있다. . . | . | . | 먼저 적용할 카테고리인 action 중에 1개의 중간추상층과 condition 중 1개를 추가반영한 최종구상체 1개를 반영해 빨간줄로 만든다. . 최종구상체를 먼저 만들고 -&gt; extends 중간추상층 -&gt; impl 상위추상층 DiscountCondition을 만든다. 상위추상층의 이름이 Condition인 이유는, **중간추상층에 action을 구현했다는 마커인터페이스를 DiscountPolicy 내부에서 만들것 이기 때문 ** | . | . | . 최종구상층 1개 -&gt; 중간추상층 중 1개 -&gt; action+condition 전략메서드 2개를 달 예정인, 상위 추상층 DiscountCondition -&gt; action마커인터페이스를 순서대로 틀만 만든다. . 최종구상층을 1개를 먼저 만들되, 중간추상층을 상속하도록 만들고, 중간추상층도 상위추상층 DiscountCondition을 implements하도록 만든다. . . | 사용 제네릭의 빨간줄을 해당class정의부에 T로 만들어주는 기능은 없다. -&gt; 생성자에 파라미터 추가를 이용해 해당 제네릭에 최종구상체의 추상체인 중간추상층이 들어가도록 특정형 T -&gt; upperbound 상위추상층으로 내부에 정의해서 빨간줄제네릭을 해결 하도록 해야한다. . 하지만, 제네릭 빨간줄 때문에 생성자 자동생성이 안된다. 잠시 지웠다가, 생성자에 T형(사용시 중간추상층 들어갈 예정) 파라미터로 들어가는 전략객체를 추가하고, T upperbound 상위추상층으로 정의 한뒤 사용제네릭을 다시 넣어주자. T에는 최종구상체들의 추상체인 [중간추상층들이 사용]될 수 이도록 T type 파라미터 -&gt; [T의 upperbound에 상위추상층]으로 지정해줘야한다. 사용되는 제네릭 중간추상층은 T 정의시 직접적으로 사용X upperbound에 의해 결정되는 것이 제네릭의 특징 | . | 최종구상체들의 파라미터를 T로 정의하여 생성자 인자 추가때, change signature에 추가 되는 인자에 대해 최종구상체 1개 deafult value로 들어가면 related problem들이 알아서 해결됨. | . | . . | 생성자에 주입받은 정책용 전략객체를 필드로 받아준다. . . | . | 이제 정책적용에 필요한 2가지 전략메서드를 사용하면서 하나씩 정의하고 올려준다. . 할인정책을 적용할 메서드(calculateFee) 내부에서 . 정책 적용전 로직은 그대로 두고, early return을 활용하여 정책적용시 변화가 생길 field를 action메서드의 인자로 + 정책조건에 판단정보의 field를 trigger메서드의 인자로받아가며 아래와 같이 정의해준다. . if 정책객체.isStatisFiedBy()를 사용하여 정책 조건trigger메서드를 사용하고 | if내부 early return에 기존 반환값 로직에서 정책을 적용하여 바뀔 부분과 나머지 로직을 나눈 뒤, 정책 적용 대상만 정책 적용action메서드의 인자로 사용한다. 이 때, 정책적용전 메서드 이름을 가져온다. | . | . . | . | 빨간불로 최종구상체에서 작성한 2개의 전략메서드 create method하면 중간최상층을 지나 바로 -&gt; 상위추상층(인터페이스)에 알아서 오페이터로 작성된다. . 최종구상체 : isSatisfiedBy의 2번째 카테고리(Condition)만 개별구현할 예정 | 중간추상층 : calculateFee의 1번째 카테고리(Policy)만 개별구현할 예정 이 때, 중간추상층마다 가질 action별 마커인터페이스를 달아줄 예정 | . | . . . | 중간추상층은 2개의 오페이터 중 action 메서드만 먼저 구현하고, 최종구상층은 나머지 trigger 메서드를 구현한다. . 중간추상층은 에서 action메서드 구현시, 정책 적용에 필요한 정보들은 추상클래스의 생성자주입으로 해결하고, 나중에 최종구상체들이 그 생성자주입부 + 필드를 super()로 물려받아 구상체 생성시 받아서 부모에게 넘겨준다 . . . | 주의! 중간추상층은 추상층으로서 개별구현이 구현되면 반드시 final로 자식이 못건들이게 막자 -&gt; 추상층에 구현된 개별구현 method + 사용된 field . . | | 최종구상체는 실제 외부Client에서 생성되고, 값을 받아들이는 놈으로서 부모의 생성자주입에 필요한 값을 자식이 대신 받아 super()를 통해 부모선에서 처리되도록 던져준다. . . . | 최종 구상체는 2개 전략메서드 중 1개인 정책조건trigger메서드를 구현하며, 필요한 것이 있으면 생성자로부터 받아서 정의한다. . Sequence -&gt; Treatment정보에 찍혀있으며, 외부에서 입력해줄 선착순 sequence명에게만 적용되는 정책조건이라고 가정하자. | . . . | 최종구상체의 주입을 받는 부분에서, 최종구상체의 생성자주입 인자 중간추상층(부모)용 1개 + 최종구상체용 1개 의 인자가 늘어나므로 deafult값을 미리 명시해놓고 주거나 안꼬이게 할려면, 미리 NONE정책으로 구현했어야할 듯 하다. . . ctrl+F6으로 생성자에서 Sequence를 삭제후 바로 정책조건에 만족 안되는 값을 default로 주기 . 중간추상층에 default값을 주면, 최종구상층에 적용되어버리니 하지말기 | super()에 들어갈 부모를 위한 생성자인자도 최종구상층에서 지웠다가 default값과 함께 추가하기 | . . . | . | 중간추상층의 abstract class에 Discountpolicy 카테고리인터페이스 &gt; 개별 마커인터페이스로 1개 카테고리의 개별종류 표시하기 . Amount외에 Percent, Count, None 등의 할인정책action들이 있다. | 메서드가 없는 마커인터페이스를 만들고, 하위 최종구상체들을 묶어줄 카구체 테고리를 표시한다. 현재 Condition X policy의 조합인데, 인터페이스가 그만큼 명시되어있어야하며, Amount계열/Pecent계열의 최종구상체를 묶어서 한번에 처리할 수 있다? 추상클래스론 안되는가?? | . | . | . DiscountPolicy의 카테고리 인터페이스를 만든다. . . | 인터페이스 내부에서 마커인터페이스들을 만든다. . 인터페이스 내부 인터페이스는 상위인터페이스{}를 extends하여 구현한다. | . . | 완성된 action중간추상층에 마커인터페이스를 추가 impl한다. . extends상속은 1개만 되지만, | 카테고리 인터페이스의 implements는 콤마로 여러 개 할 수 있다. | . . | 중간추상층의 제네릭사용을 위한 정책적용객체(Specialty)의 제네릭정의부 T의 upperbound를 중간추상층의 상위추상층을 줘야하는데, 1개더 추가되었을 땐, &lt;T extends A &amp; B&gt;형태로 &amp; 추가인터페이스를 주면 된다. . . | | 완성된 discountpolicy 관련 파일들을 discountpolicy패키지로 이동시키고, 개별 action중간추상층별로 패키지를 만들어서 관리한다. . . . | 최종구상체들추가 Condition+Action . . 이제 AMOUNT계열의 Sequnce Trigger외 다른condition들을 반영한 최종구상체들을 늘려간다. . AmountDiscount라는 중간추상층(추상클래스)가 인터페이스 2개와 1개의 전략메서드를 구현하고 있으니, 최종구상체는 추상클래스 1개 상속 및 super()에 전달위한 인자 생성자 주입만 해주면 된다. . Sequence 조건외에 Period, Weekend이 남았음 | . . | 추가된 2개의 AMOUNT계열 최종구상체의 trigger메서들 구현한다 . 요일참고 블로그 | 특정날짜 기간 참고 . | (예비) 시간대 period적용시에는 참고 | . | | DayOfWeekAmountDiscount . . . . PeriodAmountDiscount . . . Action 중간추상층 추가 . action을 구현한 action 중간추상층은 아래과 같이 형성되어있다. . package로 따로 분리해서, 하위에 condition을 단 최종구상체들이 오도록 한다. | 2개의 오퍼레이터를 가진 상위추상층 DiscountPolicy와 action에 대한 마커인터페이스 DiscounPolicy.XXXX 2개의 인터페이스를 구현한 추상클래스로 만든다. | action메서드 구현에 필요한 것은 생성자 주입으로 받는다. 추상메서드(오페레이터, 전략메서드)에서는 이미 시그니쳐가 정해져있음. | . | . | . PercentDiscount . . NoneDiscount . . OverlappedDiscount -&gt; 불가. action 1개당 1개의 condition만 배정되는 상태 . 현재 movie에는 1개의 action - 1개의 condition이 반영된 최종구상체만 들어간다. 만약, 1개의 action을 여러번 적용하려면, 정책적용 객체가 여러개의 정책객체를 받도록 해당계열 최종구상체들을 가변배열로 여러개 받게 한다. | . | . 정책적용 객체(Specialty)가 여러 정책객체(최종구상체)를 가지게 하기 . action과 trigger를 동시에 가지는 정책객체이므로 여러 trigger를 돌면서 fee객체에 만족시마다 여러번 정책 적용시키도록, 생성자 주입 정책객체를 가변배열로 여러개 받도록 수정하기 . 변경전 . . | . | . 생성자 파라미터를 ... 가변배열로 바꾼다. . | 필드를 빈 Set으로 바꾼다. . | 생성자에서 배열 -&gt; List -&gt; addAll 으로 초기화해준다. . . . | 여러개의 정책객체를 for문으로 돌면서, 만족할때마다 적용시켜주며, 누적 적용에 대한 코드를 작성한다. . .multi(count)는 1개당 가격에 정책이 다 적용된 뒤 곱해야한다. | 여러개가 누적되서 적용이므로 누적적용용 재할당 누적변수를 for문 위에 만들어놓는다. 내부에서 trigger를 만족할때마다 누적변수에 적용 후 누적변수에 재할당한다. | . | 마지막에 정책적용후 로직인 .multi(count)를 적용한다. | . | method2-1: 전략condition을 머금은 템플릿policy . 설명 . 참고 내 블로그object_part1_summary.html#discountpolicy-1) . | as-is . . . . | to-be . . . | 기존 discountpolicy 관련 로직을 다 삭제함 . step4 | . | . 실습 . 정책적용 대상 객체(Specialty)에 action policy(템플릿)의 구상체부터 시작하되, step1의 2개 인터페이스 조합 -&gt; action중간추상층을 생성 -&gt; 특정 중간추상층을 사용하기 위한 제네릭 이 필요 없다. . 직전: 최종구상체 SequenceAmountDiscount -&gt; action 중간추상층 AmountDiscount -&gt; 그외 action추상층들을 제네릭으로 선택해야, 그 하위 condition조합된 최종구상층들을 받을 수 있었음. | 현재: condition전략을 선택해서 받은 action템플릿의 자식1개만 알면 된다. 조합으로 인해 생긴 중간추상층이 없음 -&gt; 제네릭 필요 없음. | . | . . 생성자 인자 추가시 change signature -&gt; default value를 활용한다. 기존에 생성되어 사용되고 있는 객체면, 자동으로 defaultValue 지정 change signature가 뜸. | . | . . | 정책적용대상 객체 내부에서, 생성자로 받은 action템플릿 객체를 사용해서 -&gt; 추상체 변수로 받으면서 추상클래스 생성 + public 템플릿메소드를 빨간줄로 완성해보자. . action템플릿메소드는 정책적용 필드 뿐만 아니라 내부에 머금을 condition을 위한 조건정보(treatment, count)도 같이 건네줘야한다. | . . . 템플릿 추상층만 만들었으니, 연결해준다. . 훅메서드를 만들어서 올리는 구조가 아니라서 직접 상속해준다. | . . | . | action템플릿을 작성할 때, 구상체로부터 올리는 것은 @Override + protected 훅메서드밖에 없으니 템플릿메소드부터 직접 작성해준다 . 여기서 템플릿action에서는 여러개의 condition전략객체들을 알고 있다고 가정한다. 여러 조건들을 다 적용시킬 예정 | . | 템플릿 메소드 내에서 훅메서드 만드는 방법은 내수용 private메서드로 작성해서 proteced abstract로 빼야한다. | . conditions들을 반복문 돌리려면, DiscountCondition전략인터페이스 생성 -&gt; 빈컬렉션으로 초기화 한다. | condition의 trigger전략메서드를 사용하면서 정의한다. | 개별action적용을 위해 내수용 메서드(객체없이 정의)를 통해정책을 적용할 필드(객체)에 훅메서드를 건다. | 누적 적용을 위해서, 초기값(fee 파라미터)을 누적용 변수에 넣고, 누적용 변수에 적용해서 반복문 안에서 재할당한다. | 적용된 객체를 반환한다. | . . | 템플릿policy를 직접 작성하여 내부 훅이 정의 (by 내수용 메서드)되었으면, 구상policy에서 훅을 구현하여 완성한다. . . . | action템플릿(추상클래스)도 condition전략객체를 생성자 주입하는데 conditions가 여러개면서 유연하게 받으려면 빈컬렉션 초기화+ void setter(add)를 이용한다 . 여러 전략객체들을 받으며 -&gt; 빈컬렉션 필드 . 빈컬렉션으로 초기화한 순간 생성자에 자동주입은 안된다. | 생성자에서도 받아서 add하도록 시킬 수 있는데, 이럴 경우 생성시 반드시 입력해야해서 유연성이 사라져버린다는 단점이 생긴다. | . | policy 생성후에도 condition들을 유연하게 추가 -&gt; ( setter-&gt;add) . . | 외부에서는 지역변수로 미리 생성해놓고고 condition전략객체들을 add해서받는다. . . | | 구상 템플릿policy -&gt; 추상 템플릿policy -&gt; 구상템플릿policy 완성 -&gt; 추상 전략condition -&gt; 구상 전략condition순서로 개발 중이다. . 구상condition을 추상condition 변수자리에 넣어 사용하면서 만든다. . 구상 전략객체를 개별정의시, 역시 필요한 정보는 생성자 주입 받는다. | . . . | . | 전략condition 객체 1개와 전략condition을 먹금은 템플릿policy 구상체 1개가 만들어진 상태다. . . 전략Condition과, 템플릿Policy가 따로 관리되므로 package를 분리해준다. . . | . | 만들어진 구상체들을 테스트해준다. . 가장 하위계층에 있는 condition을 테스트하고 -&gt; condition을 먹금은 템플릿policy을 테스트하는 순서대로 진행한다. . | 템플릿의 구상체는 상속된 자식으로서 개별구현하는 훅메서드 이외에 보이지 않는 템플릿메소드 및 추상클래스에 정의한 필드 + 메서드들을 활용해야한다. . . | . | 남은 전략Condition객체 생성 . PeriodCondition . | DayOfWeekCondition . . | . | 남은 템플릿policy 구상체들 생성. 템플릿의 구상체들은 훅메서드만 개별구현한다. . PercentPolicy . . | NonePolicy . . | . | method2-2: 템플릿policy를 일반class + 전략policy로 변환(2개의 전략객체를 사용하는 일반policy) . 설명 . . 현재 전략condition을 머금은 템플릿policy(확장시 조합폭발)를 확장가능성을 고려한 차악 일반policy클래스 + 전략action(의존성폭발)로 변경한다 . . . | step5 . | . 실습 . 템플릿메소드패턴의 추상클래스 DiscountPolicy를 -&gt; 일반클래스로 바꾼다. . abstract제거 &amp; 훅메서드 정의 제거 | 템플릿메소드내 훅메서드(내수용메서드)앞에 전략객체(전략메서드+ -er) 소문자로 달아서 훅메서드 -&gt; 전략객체.전략메서드()로 변경하여 개별구현시키기 | 전략객체를 필드로 생성후 생성자 주입 현재 전략condition을 머금고 있기 때문에, 전략객체 2개를 사용하는 일반클래스가 된다. | 전략condition은 생성자 주입이 아니라, 빈컬렉션 -&gt; 여러개+유연하게 setter(add)로 처리하는 중이다. | . | 전략 인터페이스 및 오페레이터 완성 전략이 들어가는 순간 strategy패키지로 파서 넣어주자. | . | . . | 템플릿메소드패턴의 구상체들을 전략객체로 변경한다. 구조가 유사하므로 조금만 바꿔준다. . 클래스명을 구상내용+전략인터페이스명으로 변경 . | 상속을 impl로 변경 . 상속관련 super() 등 삭제 | | protected 훅메서드를 public 전략메서드로 접근제한자 변경 . | 훅메서드명을 전략메서드로 변경 . 메서드명 변경이나 삭제시 f2/alt+del 이용해서 변경/삭제할 것 | . . | . 나머지 템플릿 구상체들도 전략객체로 바꿔준다. . . . | . | Main이나 Test에서는 전략객체를 생성하고, 일반클래스 DiscountPolicy에 생성자 주입하도록 변경해서 사용한다. . . | method2-3: policy전략객체마다 위임&amp;캐싱된 policy전략Factory 생성 . 설명 . 생성 &lt;-&gt; 사용을 분리한다. 생성해주는 Factory를 만든다. Factory별 캐싱을 적용해서, 전략객체별-Factory객체 -&gt; 전략객체별 한번만 만든다. | . | . | 생성(전략객체 생성)해주는 Factory가 사용(전략객체로 전략메서드 호출)의 책임까지 위임받는다. 전략인터페이스 구현 -&gt; 전략메서드 정의시 내부에서 생성-&gt;사용까지 | . | . . . . 실습 . 전략인터페이스를 구현한 위임된 Factory를 생성하고, 정책적용객체(전략객체 주입)의 변수명을 전략객체 -&gt; factory로 변경한다. . 위임된 팩토리는 전략객체별로 생성하며, 전략객체를 미리 생성 -&gt; 강제 주입하는 대신전략객체 대신 factory로 주입하고 factory가 내부에서 전략객체를 필요시마다 캐싱하여 1회만 생성하며, 사용될때 생성을 한다. 전략인터페이스 구현한 Factory 생성 기존 전략객체명 복사해놓은 상태 + Factory만 붙이기 | . | 정책적용 객체는 기존에는 미리 생성된 전략객체를 강제 주입 -&gt; 전략객체 대신 factory를 주입할 예정 | | . . . . | Factory가 구현해야할 전략메서드 내부에서, 내수용 &amp; synchronized 캐싱 전략객체 생성메서드를 정의한 뒤, 전략메서드를 사용한다. . 전략메서드 내부에서, 전략객체 생성 메서드create() or get전략객체 (내수용 + synchronized)를 작성하되, 내부에서 캐싱 적용 빈 cache필드를 이용하여 없으면 재할당해서 채운다. 있으면 그대로 반환한다. | . | . . | 정책적용 객체(DiscountPolicy)에 전략객체가 아닌 전략Factory를 주입시키도록 기존코드를 변경한다. . . . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/policy/side/hospital/2022/07/01/(side)%ED%8A%B9%EC%A0%95%EA%B0%9D%EC%B2%B4%EC%97%90-%EC%A0%95%EC%B1%85%EC%A0%81%EC%9A%A9.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/policy/side/hospital/2022/07/01/(side)%ED%8A%B9%EC%A0%95%EA%B0%9D%EC%B2%B4%EC%97%90-%EC%A0%95%EC%B1%85%EC%A0%81%EC%9A%A9.html",
            "date": " • Jul 1, 2022"
        }
        
    
  
    
        ,"post32": {
            "title": "OBJECT 19 TODO1 작성을 통한 compoiste, visitor패턴 학습",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . 디자인패턴 심화 - 컴포짓 + 비지터 패턴 . 프레임웤과 제어 역전 . 책 15장에 관한 내용을 정리한다. | 이 책의 비밀은 디자인 패턴 중에 전략패턴, 템플릿메소드패턴, 데코레이터패턴을 써서 적용하는 것이었다. 데코레이터 패턴 -&gt; 핸드폰 요금 계산 | 전략&lt;-&gt;템플릿 -&gt; 무비씨어터 | . | 우리는 프레임웤에다가 제어의역전으로 인해 기능만 공급해주고, 언제 실행될지는 라이프사이클이 가지고 있는 프레임웤이 결정한다. . | 프레임웤과 라이브러리의 차이는? 프레임웤 : 제어의 역전이 되어있는 것 우리의 코드가 프로세스 제어구문을 가지고 있냐 안가지고 있냐 우리 코드에 제어구문이 없다면? -&gt; 바깥에 있는 것. 나는 visitor로서 라이프싸이클 메서드를 흐름대로 구현하는 중. | 우리는 제어구문이 소비할 함수와 객체만 만드는 것 | . | 예를 들면, for문은 바깥에서 주어짐 -&gt; 우리는 for문에 쓸 함수만 만듦 그렇다면, 우리는 프레임웤을 쓴다면, 함수를 건네주는 것 밖에 할 수 없다. | . | for라는 프레임웤을 만들었다고 가정하자. 우리는 객체만 만들어서 넣어준다. 이 객체는 initialze, loop, end, 3개의 메서드를 만들라고 프레임웤으로 부터 강제 받는다. | 프레임웤은 제어를 하는데 프레임웤이 받은 객체의 initialize메서드를 호출 | 프레임웤이 for반복문을 돌리되, 받은 객체의 loop메서드를 호출 | 프레임웤이 객체의 end메서드를 호출 | | 우리의 코드에는 for반복문이 없어졌고, 라이프사이클에 맞춘 행동(순서대로 호출)도 없어졌다. 우리는, 프레임웤이 제어구문을 미리 짜놓고, 거기에 맞춘 객체(메서드)만 전달해준다. | . | . | 제어의 역전은, 하나의 역할(인터페이스)만 역전시키지 않고, 보통 제어의 흐름대로 역전을 시키기 때문에, 프레임웤은 내부에 라이프사이클을 가지고 있게 된다. 스프링을 예를 들면, 우리는 컨트롤러를 만들지만, 스프링 프레임웤은 내부에 라이프사이클인 interceptor를 만들면 before-controller-after를 라이프사이클 순서대로 가지고 있다. | my) 처음부터 코드를 짠다면, 라이프사이클 코드는 그대로 작성해두고, 바뀌는 기능부분만 제어역전시켜 밖으로 빼준다?! | . | 우리는 프레임웤에다가 제어의역전으로 인해 기능만 공급해주고, 언제 실행될지는 라이프사이클이 가지고 있는 프레임웤이 결정한다. my) 프레임웤의 제어의역전: 제어는 프레임웤이 미리 라이프사이클 순서대로 짜놓아서 우리가 못짜는 역전 현상이 발생하고, 우리는 흐름대로의 역할(기능, 메서드 by객체)만 공급해주니, 우리가 공급한 기능의 호출, 실행 타이밍은 프레임웤에 결정되어있다. | . | . | 라이브러리: 제어의역전이 아니므로, 기능을 우리가 언제든 호출할 수 있다. 프레임웤은 기능을 공급만하고, 호출은 프레임웤이 제어해놓은 순서대로 결정해서 호출하게한다 | 함수로서 오직 값의 획득만 위임할 수 있다. 조작해서 뭔가를 하는 프로세스는 위임할 수 없다. | . | . | 우리의 코드도 프레임웤화 되어있어야한다. 제일 어려운 부분은 알고리즘이다. 우리는 엑셀의 피벗테이블을 바로 짤 수 없다. 2단 for인 것은 알고 있으나, 복잡한 상태와 제어가 관여되고, 분기가 심하다 우리는 1개의 분기를 제거할때마다 전략패턴을 썼었다 | . | . | 제어가 없는 알고리즘은 없으니 필수적인데, 제어는 1개만 만들고, 나머지는 제어의 혜택을 받게 만들자. | 우리는 라이브러리를 만들어서는, 제어를 위임할 수 없다. 함수로서 오직 값의 획득만 위임할 수 있다. 조작해서 뭔가를 하는 프로세스는 위임할 수 없다. | . | . | 제어에 대해서 익숙해질려면 코드 연습을 통해서 할 수 밖에 없다. | . 컴포짓패턴: 파일탐색기에서 파일이름으로 검색 . 전략패턴과 데코레이터패턴을 짬뽕한 컴포지트 패턴이 책에 소개된다. . 영화라는 검색키워드를 아래 트리형태의 구조에 어떻게 다 던질까 폴더1 파일1 | 파일2 | 폴더2 | . | . | 파일도, 폴더도 검색기능을 제공해야하니 파일과 폴더 모두 searchText()라는 메소드를 공통으로 가지고 있어야한다 파일이라면 돌면서, 빈 배열에 자기가 해당하면 자신을 담아준다. | 하지만 폴더라면, 자기자신이외에 자식들까지 순회하면서 해당하면 다 담아줘야한다 폴더자신도 재귀적으로 돈다 | 폴더의 폴더도 재귀로 돈다 | . | . | 여기서 핵심은, 폴더든 파일이든 모두 searchText()메소드를 공통으로 구현했다는것이다 | . | NoDiscountpolicy를 만들 때, 빈값리턴하는 특이한 클래스를 만들지말고, 아예 discountpolicy를 top에서부터 상속받지만, discount가 안되는 클래스를 만들어보자 할 때, 다른 policy들은 discountpolicy를 상속하는 전략객체이나 policy전체를 커버하는 애로 바껴서 leaf계열 tree계열로 바뀌게 된다. . 혹시… 할인 전략객체들 vs 노할인 단일객체를 포괄하는 정책으로 바꾼다는 소리인가? | 일단 참고 깃허브 | . . | . 패턴을 배우는 순서 . 패턴을 배우는 순서 상속 -&gt; 좋은 상속의 템플릿메소드패턴 | 조합폭발방지 -&gt; 전략패턴 전략패턴의 전략패턴 -&gt; 어댑터 패턴 | . | 전략객체가 많이 나오다보면, 단일요소 객체 vs 컬렉션 객체를 포괄하는 -&gt; 컴포짓패턴 element vs collection -&gt; 컴포짓 패턴 | 컴포짓 패턴의 loop를 외부에 위임 -&gt; visitor패턴 | element간에 연결 by linkedlist -&gt; 데코레이터 패턴 | . | 중간에 멈출 수 없는 한번에 쭉 가는 for문을 써야한다는 문제점 -&gt; 책임사슬 패턴 | 나머지들 -&gt; 끝판왕 커맨드 패턴 지연실행에 대한 일이라 어렵다 | 해야하는 일을 함수에 담아서 -&gt; 객체로 만들고 -&gt; 모았다가 -&gt; 실행or역카운터실행 | . | . | 1패턴 -&gt; 1객체가 아니라 1객체가 여러가지 패턴을 소유할 수 있음. 분산되어있는 컴포짓패턴 -&gt; 다음장에 바로 컴포짓패턴의 3가지 역할을 다 수행하는 컴포짓패턴을 소개함. | 디자인패턴의 다이어그램은, 객체의 역할이지 객체가 아니다. 다이어그램 갯수만큼 객체가 나오지 않는다. | . | 역할별로 1개의 객체로 연습 | 이후 모든 역할을 1개의 객체에 몰빵하는 연습 전략객체이자 실행객체 | 전략객체이자 상태객체 | 전략객체 소유하는 객체를 상태객체로 만들기 | . | . | . TODO 실습(컴포짓패턴) . task와 tasks(파일 -&gt; 폴더안에 파일들 구성) . taks(할일) 클래스를 만든다. . 기본적으로 title / date (localdatetime) / isComplete(boolean)를 가져야한다. 새로만들어지면 항상 false상태여야하므로, false로 필드 초기화해서 만든다. | 나머지(title, date)만 생성자에서 받는다. | . | 코드를 짤 때, 기본값이 있는 것들은 생성자에서 받으면 안된다. 그렇단 얘기는, 기본값 -&gt; 외부에서 받는 정책과는 구분된다. 코드의 의도를 잘 읽어내야한다. | . | title과 date는 생성자에서 외부로 받는 정책인데, 왜 final을 안쓸까? 중간에 바뀌는 필드라는 의도 | . | taks라는 어떤 모델을 만들 때, 상태 변화하는 필드(not final)에 대한 메서드(setter, 그외)를 만들어 행위를 제약하고, 필드는 내부에서 알아서 처리되도록 캡슐화를 해야한다. . 대표적으로 todo앱에서는 check를 켰다껐다 밖에 안되므로 isComplete에는 setter를 주면 안된다. 외부에서 임의의 값을 받아 상태를 업데이트(저장 복원 등)setter를 주면 안된다. | . | my) boolean으로 제약이 걸린 필드의 받아업데이트는 void setter(값)가 아니라 파라미터 없는 void toggle이다. void setter(파라미터) 대신 제약걸린 받아 저장은 void(받기용!) toggle() 인자가 없이 제약걸린 뒤집기만 함 | . | 객체는 자신의 상태를 자기가 관리한다는 개념 state management의 책임 | 그외의 변하는 필드(not final)에는 setter를 만든다. | . | Task는 1개의 데이터객체일 뿐이며, Task를 담을 그릇이 필요하다 . 일급컬렉션 느낌으로 Tasks를 만든다. . | 하지만, 폴더의 개념으로서 폴더도 이름도 필요하다 . tasks폴더도 title을 가지게 된다. . 기본값x -&gt; 필드초기화x -&gt; 생성자에서 외부에서 받지만, 변경가능한 not final -&gt; setter가 생긴다 -&gt; 외부(생성자)에서 받고, 변하기도 하는(setter) 필드는 생성자에서 재할당 코드를 setter로 덮어 코드중복을 없앤다 | . . . . | setter로 title이 들어올 때, 내부에서 데코레이터 글자색정하기+태그달기 등을 할 수 있다. . 그 과정을 생성자에서 받을 때도 반영하기 위해서는 setter로 코드중복을 제거한다. | . | . | 최초 생성자에서 받고 + 그 다음에 변경되는 필드값은 setter와 생성자에서의 코드 중복을 제거해야한다. 많은 회사에서 이것때문에 문제가 발행한다. . setter할때랑, 최초 생성할때랑 로직이 달라져서 | | | task들을 가지기 위해 Set컬렉션 필드를 가진다. 이 필드 역시 상태 변화 필드에 대한 메서드로 제약 + 캡슐화인 setter(받아 업데이트 기능)을 만들어줘야한다. . 컬렉션필드는 변경가능성 없는 것으로보고 즉시 final을 걸어놓자. | 컬렉션은 void setter대신 boolean addXXX()로 만들어야한다. 지금은 귀찮으니 void add로 만든다. | | . | **이 때, setter/add의 인자 결정으로 2가지 판단할 수 있다. ** . 데이터객체task를 받는 메서드가 public인데, 외부에서 바깥에서 생성된 task = 외부에 task의 생성자를 공개(내부발행X) = 바깥에서 마음대로 task를 만들 수 있어를 받을 것인지를.. . | 우리는 바깥에서 task를 만들어야할지 말아야할지는 잘 모르겠으나, task를 바깥에서 만들 수 있게 푸는 순간(public 받기 메서드에서 인자로 들어오는 순간) -&gt; task의 생성자를 함부로 못 고치게 된다. . 받기 메서드의 인자로 데이터객체를 받는다 = 외부에서 생성된다 = task생성자를 수정할 때, 외부의 모든코드도 수정해야한다 = 상당한 비용을 치루고 task를 수정할 수 있다. | . | 프로젝트 초창기부터 수정에 대한 비용이 많이 드는 것을 방지하려면 어쩔수 없이 외부에 task를 공개하는 시점직전까진 외부의 task를 인자로 받는 것을 미뤄두고 -&gt; task생성 필수정보만 받아서 내부발행(생성)하도록 한다. . 일단 setter의 인자를 객체가 아닌 객체생성에 필요한 정보를 받도록 수정한다. . . . | Taks의 생성자를 public -&gt; 폴더인 Tasks와 같은 패키지에위치할 것이므로 internal로 수정한다. . . . | 필요에 의해 외부에 task가 생성되어야하면, 그때 공개한다. . | . | Task객체의 생성을 관리폴더 Tasks내부에서 하게되면 수정의 여파가, 내부발행처인 Tasks에만 미친다. . | public class의 public객체지만, 생성자는 public이 아닌 것은 당연한 것이라고 생각해야한다. 왠만하면 아니여야 정상이다. | 바깥쪽에서 new키워드쓰는 객체는 최소화하는 것이 최고다 | . | remove는 add(setter)와 다르다. . 받을 때는, 없는 객체에 대해 외부 생성을 최대한 피하고, [같은 package에 존재하며, 그 객체의 추가를 관리하는 폴더]가 필요정보만 받고, 내부발행하여 -&gt; 수정 비용을 줄이는 것이 반영되지만, . | 삭제는 이미 기존에 생성되어 존재하는 객체며, public class의 public 객체로서 외부에 이미 존재하게 된다. . | 이미 존재해야지만 -&gt; 메서드 인자로 들어와 -&gt; 지워진다. . 삭제시 존재유무 검사를 안해도 된다. | . | 원시형으로 지우는 것이 더 웃기게 된다. . | Set -&gt; 객체는 메모리주소 = 값x = 객체 = id로 식별로 식별되며, 삭제시에는 이미 존재하는 public객체이므로, 인자로 받아도 된다 . | add는 생성자를 외부에 감추기 위해 원시형으로 받았지만, remove는 지울때는 반듯이 객체를 통해 지워야한다. 값으로는 객체 식별이 안되기 때문이다. . 값이 주어지면, 같은 title을 가지는 다른 객체가 지워질 수도 있다(unique보장이 안된 필드이므로) | . . . | . | 지우는 것은 이미 바깥에서 존재하는 객체를 지우는 것이다. 내부 정보를 가지고 발행하는 정보전문가의 상황이 아니더라도, 컬렉션으로 관리하는 데이터객체를 받는 메서드를 정의할 때, 일단은 필요정보만 인자로 받고, 내부발행으로 시작하여, 외부에서생성로직의 수정시 드는 비용을 절감하기 위해 내부발행으로 시작한다. | . | tasks만 가지고 있는 task set을 외부에 getter로 공개해야지만, 렌더링이 될 수 있을 것이다. . 이 때, 컬렉션을 외부에 제공할 때는, 우리가 짜는 코드는 메모리 걱정을 안해도 되니, 사본정책을 쓴다 | 컬렉션은 외부에 주면 외부 조작가능성이 있다. 누군가 반드시 한다고 생각한다. | . | 원시값이 아닌 이상 컬렉션 뿐만 아니라 객체필드 역시 사본으로 제공해줘야한다. 객체를 주면, 외부에서 객체메서드를 통해, 객체의 상태를 조작할 가능성이 있다. | 컬렉션을 주면, 컬렉션의 메서드로 통해 순서나 요소들을 조작할 수 있다 Set의 add/remove를 막을 수 있는 방법은 없다 | . | . | 이 때도 2가지 판단을 할 수 있다. . | 사본 중에도깊은 복사/얕은 복사 둘중에 뭐를 해줄지 어떻게 판단할까? . 반환되는 객체/컬렉션에 대해 [원래 객체의 메서드들이 public으로 외부에 공개되어있던 놈이라면] -&gt; 얕은 복사를 해준다. . 원래 task객체는, 외부에서 조작할 수 있는 public을 가지는 놈이라서 얕은복사를 해준다. | . . public은 원래 외부에서 조작하는 것이 허가된 메서드 | . | 만약, task객체가 외부에서 조작불가능한 메서드를 가지고 있었다면 -&gt; [외부에서 조작하는 것이 겁나므로] -&gt; [깊은 복사]를 해주면 된다. . | . | 따라서, 컬렉션이라도 내부 객체 task는 원래 외부조작 가능하니 컬렉션을 깊은 복사할 필요없다. 얕은 복사만 해주면 된다. . . . . | Tasks의 상태인 컬렉션 필드는 건들이면 안되니 무조건 사본을 줘야하는데 . 외부에서 컬렉션사본을 받았지만, 그 사본과 내부컬렉션 필드 속 요소는 여전히 연결될 수 있다 내부 상태와 연결된 요소들은 외부에서 조작해도 상관없다면, 얕은복사 | 연결된 내부 요소들을 조작해선 안된다면, 깊은 복사를 내어준다. | . | . | . | task의 제공은 순서를 가진 set이 아닌 list로 반환해줘야한다. . task는 date순서대로 오름/내림차순 되어야하므로 Set으로 식별한 객체들이지만, 외부에 제공은 List로해준다. . . | . | 내부관리 Set대신 순서적용이 가능한 list를 반환한다면, 미리 sort도 해주고 반환한다. . 보통은 정렬까지해서 반환한다. | 이 때, 정렬을 바로 오름차순으로 하지말고, public외부 제공getter해줄 때, [정렬방법]과 같은 [제공방식을 인자]로 외부에서 받아서 제공해준다 객체지향에서 메세지는 객체로 받으므로 정렬type도 객체 파라미터로 받는다. | 객체지향에서 처리는 값type의 객체이므로 정렬type객체는 제한된 종류의 값type을 정의하는 enum일 것이며, 값으로 췩브해서 처리될 것이다. | . | . . | 제한된 종류의 값type은 enum(애넘)으로 만든다. . 객체를 정렬할 때, 그 기준은 해당 객체가 가진 필드를 기준으로 오름차순/내림차순이 있을 것이다. | 필드의 종류마다 _ASC, _DESC형식으로 enum필드를 만들어준다. | . . | 객체지향에서는 직접일을 하지않고, enum필드라도 객체에게 일을 위임한다. . 값type이라고 인자를 위임해줄 객체가 아니라 값으로 본다면? swtich문이 들어가게 된다. . | swtich문 == if문이 싫으면 전략객체로 바꿔주면 된다. . | enum은 싱글톤처럼 인스턴스를 미리 확정지어서 만들어주는 것이다. . 인스턴스를 static초기화 전에, jvm이 만들어주는 인스턴스이므로 os가 보장하는 인스턴스, thread시작전에 만들어진다. | thread에 안전한 인스턴스를 만들 땐, 1개는 싱글톤객체, n개의 인스턴스만들라면 enum으로 만들어야한다 | 싱글톤객체를 만들 땐, syncronized를 걸어야하는데, enum은 안걸어도 된다. | . | . | SortType을 클래스로 보고, enum필드들을 이미 만들어진 인스턴스들이라고 보자. . enum은 내부적으로 enum필드로 만들어진 인스턴스들의 추SortType추상클래스가 되며, ;이후에 정의된다. 공통로직을 정의한 클래스 | . | . | enum은 ;뒤로는 추상클래스로서 abstrac 메서드를 정의할 수 있다. . 이 때, 정렬을 하려면 Task a와 Task b를 compare해야한다. | 이렇게 추상메서드를 정의해놓으면, 인스턴스 4개는 추상메서드를 구현해야만 한다 | . . . | . | enum을 ;아래 추상클래스의 추상메서드를 구상class없이 익명class로 구현하는 분신술로 보고 공통로직 추상메서드를 구현하도록 한다 . 익명클래스를 구현해서 인스턴스를 생성하는 과정과 똑같은 과정인데, 단지, thread문제가 생기기도 전에, jvm에서 만들어주는 것이 다르다 | . ​ . . | 이렇게 enum객체에 sort()에 들어갈 인터페이스Comparator(compare 구현 인터페이스)을 위임한 전략객체 4개 enum으로 만든 것이다. . 전략객체의 전략메서드로 대신했다면, [메서드 1개의 함수형 인터페이스Comparator]가 들어갈 자리에 람다식[ (인자) -&gt; 전략객체.전략메서드(a,b) ]처럼 ` (인자) -&gt; 추상체Enum의 객체.Enum속(공통)추상메서드()`를 넣어주면 된다. . | 전략패턴과 함수형인터페이스 참고 . | Comparator는 함수형 인터페이스로서 Consumer의 .accept()나 runnable의 .run()처럼 내부에서는 함수형인터페이스 추상체.compare(실제인자a,실제인자b); 호출 == 전략객체.전략메서드(); 내부정의와 파라미터에선 함수형인터페이스 추상체 파라미터(전략인페-추상체) + 외부 입력인자는 전략메서드구현 구상 전략객체나 (가상인자) -&gt; 가상인자로 전략메서드 실시간 구현의 람다식이 필요하다 . 내부정의는 .sort( Comparator파라미터 )의 내부에서 실제인자로 전략객체.전략메서드 호출(실제인자); 이 정의되어있다 | . . 외부에서는 가상인자를 통한 전략메서드 실시간 구현 람다식을 전략인터페이스 인자 자리에 넣어줘야한다. | . . . 이 때, 람다식+가상인자를 통한 전략메서드compare 실시간 구현에 필요한 것이 외부에서 보내준 정렬방식 값객체이자 compare구현을 위임받은 SortType객체이므로, 해당객체에서 정의된 compare로 전략메서드compare를 구현하게 한다. | . . . . . | . | enum의 필드들의 익명클래스 compare들을 구현해준다. . String의비교는 compareTo()로서 &gt;=&lt; 0없이 비교만해주면 된다. | 역순이라면 compareTo에 들어가는 인자만 바꾸면 된다. | . . . | 우리는 처리를 위한 값type인 SortType을 enum을 선택하고, enum을 추상클래스로보고 내부 익명클래스로 구현하여, 각 enum객체들이 정렬에 관한 인터페이스를 구현하도록 전략패턴으로 위임했다. . 우리가 class를 만드는 것은 인스턴스가 n개 이상이야 끝을 모를 때만 만든다. | 우리가 인스턴스 갯수가 확정일 땐 class로 만들면 안된다. 왜냐면, 다른놈이 해당 class의 인스턴스를 더 만들어낼 것이니까.. 안잠겨있으니까! 무조건 발생한다 생각한다. 그 상태가 오류라고 생각한다. | 인스턴스가 1개만 있어야하면 된다면, 싱글톤패턴으로 만든다. | 인스턴스가 n개만 있어야한다면, enum으로 만든다. | . | 클래스를 만들기 전에 enum을 통해서 객체의 수량을 한정지어야되는지 결정부터 하고 class를 만드는 것이 java에서 맞는 방법이다. | . | enum을 쓰면 수량오류가 안생긴다. | . | 밖에서는 tasks사본을 받게 된다. 그것을 작업을 하든 뭘하든 하면 된다. | 지금까지 컴포짓패턴을 쓰려고 파일과 폴더를 만든 것이다. | 파일과 폴더를 합친 composite객체(CompositeTask) 와 파일+폴더정보를 묶어서 출력할 사본Composite객체(TaskReport)만들기 . todo안에 또 todo들을 만들고, 그안에 또 todo들을 가질 수 있다. | 업로드시스템도 왼쪽메뉴가 끝없는 tree depth를 가질 수 있다. | 나는 파일(task)이면서, 그안에 자식들을 가지는 폴더(tasks)가 되게 된다. . | 컴포지트 패턴은 4가지 구성요소가 있는데, 1class에 4가지를 한꺼번에 구현할 것이다. | . CompositeTask 클래스를 새로 만들고 , task과 tasks의 내장을 다 가져올 예정이다. . | CompositeTaks는 기본적으로 Task이므로, Task의 코드를 다 가져온다. . 이 때, 폴더에서 파일 추가시 수정비용 최소화를 위해, 폴더객체내부에서 생성을 위해, 생성자를 default로 걸어놨던 것을 public으로다시 바꿔준다. 왜냐하면, Composite는 더이상 폴더객체 내부에서 생성되는 파일객체가 아니라 파일+폴더역할의 객체기 때문에 | 내장을 긁어올 때, 생성자의 이름은 생성한 class로 다시 바꿔줘야한다. | . | . . | 또한,CompositeTaks는 기본적으로 Tasks(폴더) 역할도 하니, 내장을 다 긁어오되, task랑 겹치는 필드와 생성자는 빼고 가져온다. . . . | 간과하기 쉬운 것 -&gt; 생성할때 받고(생성자) + 변하기도(setter) 하는 필드는 받을 때 가공처리를 setter에 배정후, setter를 생성자에서 사용한다. . . | 현재 CompositeTask는 task이자, sub_task들을 붙일 수 있게 되었다. . **이제 Tasks(폴더)와 Task는 안쓰게 되었다. ** . | CompositeTask에 붙인 Tasks의 내장속에 사용된 Task들을 모두 CompoisteTask로 변경한다. . 함수형인터페이스의 가상인자 람다식도, 그 주체가 바뀌면 자동으로 변환 추천해준다. | 바꿀 때는 ctrl + d의 Select next occurrence를 이용해서 하이라이팅만 해서 바꾸자 변수가 아니라 여기저기서 쓰이는 형이므로 ctrl + h로 한번에 다 바꿀수 없다. | . | . . | . . . | task관련 메서드들은 task관련 메서드보다 내려서 정렬해주자. . | 현재 CompositeTask를 보면 Set(컬렉션)데코객체가 되었다. . 기존에는 구간처리시 prev데코객체, 순차적 기능추가시 구상 next데코객체를 사용해서 linkedlist로 연속된 처리를 for문이나, 꼬리재귀를 통해서 해줄 수 있었다. . | 데코객체가 같은형의 컬렉션필드(Set)필드를 가지는 순간 무한뎁스가 가능해진다. . . | . | 폴더인 tasks의 자식 반환 기능인 정렬방식을 받아 list제공기능이 바뀌어야한다 . 현재 . 컬렉션의 사본 반환 -&gt; 생성자 복사를 통한 얕은복사 사본이 바로 가능하다. | 컬렉션 1개만 반환 -&gt; 여러 필드의 반환이 아니므로 객체 만들필요없이 바로 반환가능하다. | . . | 나 자신(task1) + 자식들(set -&gt; list) 모두 반환되어야한다. . set을 list로 변경해서 반환 -&gt; 반환메서드는 내가 하지말고 내부에서 변환을 다른객체에 위임해서 처리할 수 있다. 여기서는 직접 얕은복사로 사본을 만들었다. | 서로 다른 필드 2개를 묶어서 반환해야한다. - &gt;묶어주는 처리는 반환메서드 내부에서 다른 객체에게 객체생성으로 위임해야한다. | 값의 반환이 아니라, 컬렉션반환부터는 사본으로 반환해야하는데 컬렉션이 포함된 객체(컬렉션 + 다른필드)의 자신this를 반환하고 싶다면, 나의 사본class를 만들어서 반환한다. | . | 객체의 사본은 -Report객체를 만들어서 반환한다. . | . | 컬렉션을 포함한 객체의 반환 = 사본 객체 TaskReport클래스를 만든다. . . 출력될 사본 속 반환후보1. 나 자신인 CompositeTask필드를 만든다. | 출력될 사본 속 반환후보2. 컬렉션 자신필드인 내 자식들 컬렉션을 Set대신 List로 변환된 것을 보유해야한다. | . | 컴포짓객체의 사본인 TaskReport는 반환후보2인 List&lt;CompositeTask&gt;를 필드로 가져야하나? . 내 자식들 컬렉션을 Set대신 List필드로 변환되어 가지고 있되 List&lt;CompositeTask&gt;가 아니라,,, List&lt;TaskReport&gt;를 가진다. | 무한뎁스를 자랑하던 CompositeTaks처럼 TaskReport도 무한뎁스를 가진체 출력되어야한다. (동일형)Set컬렉션(을 들고 있는) 데코객체로서 자신형의 컬렉션 필드에다가 자식들을 달고 있어야 무한뎁스가 가능하다. | . | . | TaskReport가 CompositeTask의 출력될 사본을 담당한다면, 자식들도 다 출력될 사본인 TaskReport를 가지고 있어야하므로 TaskReport가 List의 타입으로 와야한다 . . 왜 그렇다면 사본 속 나 자신은 CompositeTask로 필드를 만들었을까? tree구조와 상관없는 나 자신의 정보 필드는 아무형이나 갖다써도 된다 | 중요한 것은, 나 자신의 자식들을 컬렉션+나와 같은형으로 들고 있는 것이 중요하다. | . | . . | 나 자신의 사본인 CompostieTaks 는 이미 생성되어있고 변하지 않아, 생성자에서 최초 주입 -&gt; final로 확정하여 setter는 안만든다 . . | 나의 출력사본 자식들은 바깥에서 추가를 해줘야하는 변수 -&gt; 필드초 빈컬렉션 초기화 -&gt; add(Setter) 추가해줘야한다. . 출력사본객체를 만들 때, 원본에 더해진 자식들을 반복문으로 돌면서 출력사본의 자식으로 그대로 add하는 과정이 발생할 것이다. | . . . | 출력하기 위해 묶은 출력사본 객체라도 출력을 하는 곳에서는 각각의 필드 정보(나 자신+자식들)을 제공해줘야하므로, 각 필드에 대한 getter는 필요하다 . report의 실체 task -&gt; 자식이 없는 사본task인 report -&gt; 바깥에다가 report를 만들어주면 | 출력책임이 있는 놈은, report의 getTask or getList를 통해, 자기자신 + 자식들을 받아가 출력하려고 할 것이다. 자식들을 받았으면 반복문을 돌면서, 각 개별 자식들도 하나의 task가 되어, getTask + getList자식들을 요청할 것이다. | . | . | . . . | 이제 4가지 기능 중에 3가지는 나왔고, 사용하는 쪽과 그에게 제공할 operation()기능만 남았다. . . 이제 원본인 CompositeTask가 출력을 위해 List를 만들어 제공할 때, 출력 사본인TaskReport를 만들고 사용한다. | . | 원본 컴포짓객체인 CompositeTask가, 외부에 출력용으로 자신+자식들을 반환할 때 출력사본용 컴포짓객체 TaskReport를 쓴다. . 현재 . . | . 이제 외부에 제공을 폴더가 자식들만 반환하는 getList메서드 + List&lt;자신task&gt;형태가 아니라 getReport메서드 + 자신&amp;자식들묶은 사본객체로 시그니쳐를 변경한다. . . | 내부에서는 new TaskReport를 만든다. . 객체 자신의 사본을 내부에서 생성할 땐, this로 객체 자체가 들어간다. | . . | | 출력사본 객체도 컴포짓객체이므로 자식들을 만들고 add 끼워넣어야한다. 그러려면 원본객체 내부(현재context)에서 자식들을 for로 돌면서 -&gt; 자식들 또한 report로 변환하여 add해준다 . Report도 컴포짓객체라 컬렉션 필드에 자신과 동일형으로 자식들을 받는다. . | 자식들task를 돌면서, 자식들을 report로 변경하는 방법은? . 본인 내부에서의 변환은 new TaskReport(this)였지만, . | 외부 task객체 상태에서의 변환은 현재 정의하고 있는 getReport(SortType type)호출해야한다. . 즉, 재귀형식으로 부른다. . | 재귀호출은 마지막 스택에서 호출없이 끝나는 종착역을 가져야하는데, -&gt; 다음 자식 -&gt; 자식메서드의 재귀로 안가려면 for문에 걸리는 자식이 없을 때이므로, 자식없으면 알아서 재귀호출이 종료된다. | prev,next데코객체는 종착역이 데코객체필드 null을 지정 | 컬렉션데코객체(컴포짓객체)는 종착역이 자식컬렉션필드가 빈 컬렉션 -&gt; 자식이 add안된 task라면, 이미 종착역 | . | . . . | 컬렉션데코객체의 컴포짓패턴은, 자신 내부출력사본 객체를 만드는 곳에서 재귀호출이 발생하며, 출력사본 객체 반환메서드를 작성도중에 not꼬리재귀로서, return이 아니라 for문 내부에서 자식들의 출력사본객체 만들 때 발생하며, 종착역은, 해당 재귀호출이 없게 되는 for문을 안거치는, 빈컬렉션으로 자식들이 없는 객체에 도달했을 때이다. . prev, next데코객체는 자신내부 계산처리 부분에서 prev필드나 next필드의 메서드를 호출해서 재귀를 호출하며 null을 가진 객체의 차례에서 종착역 터미네이팅했었다. | . . | 위에 두줄은 필요없으니 삭제한다. . . | . | composite패턴에서 composite객체를 실제 사용하는 것은 원본내부에서 외부에 제공할 출력사본을 만드는데, 출력사본 composite객체를 생성하는 과정에서 재귀를 사용한다. . 역할4개가 다 사용되었다. 참고 벨로그 | add + remove + getChild(getList) | getReport( getList + operation) | . | 파일+폴더를 합친 컴포지트객체는 if로 파일 or 폴더를 구분할 필요가 없다. | . | 이제 report생성시 정렬인자가 Task를 정렬하는 SortType이 아니라 CompositeTask를 정렬하는 CompositeSortType을 생성해야한다. . 기존 Task를 정렬하던 SortType은 그대로 두고 복사해서 생성한다. . | 기존 getReport . . | 인자를 변경하여 CompositeSortType을 새로 만들 건데, SortType내용을 복사해서 수정한다. . . . | 이 때, 사용하는 파라미터 형만 변경된다면 Task -&gt; CompositeTask 제네릭 적용을 생각해본다. . 만약 enum에 제네릭이 적용될 수 있다면, 기존 파라미터의 형을 SortType -&gt; SortType&lt;Task&gt; + SortType&lt;CompositeTask&gt;로 사용할 수있을 것이나, enum에서는 제네릭이 사용안된다. . enum은 내부적으로 class로 취급해주지 않는다는 말이다. | . | enum이 제네릭이 적용안되는 순간부터 enum을 추상클래스&lt;T&gt;제네릭조합으로 변경 + enum필드==인스턴스들(익클분신술) 4개의 훅구상체class로 변경해야하는 타이밍이기도 하다. . | 하지만, enum의 thread안전성을 이용한다. 추클+T조합으로 바꾼다면, 인스턴스 생성과 동시성(싱글톤)문제를 내가 처리해야한다. 일반적으로 기업코드는 동시성문제가 훨씬더 무섭다 -&gt; 코드중복을 허용해서라도 동시성 문제를 해결한다. . 반대로 안드로이드플랫폼에서 enum을쓰면 엄청느려지기 때문에 안쓰기도 한다. | . . | . | CompostieSortType의 인자를 Task -&gt; CompositeTask로 변경해준다. . . | . | 더이상, CompositeTask는 정렬된체로 외부에 제공하는 getList( sort )의 역할이 사라졌다. . 외부에 정렬된 상태로 자식들List를 반환하는 것은 TaskReport의 getList( )이므로 정렬방식 파라미터를 여기로 옮긴다. | CompositeTaks의 getReport는 사본객체만 만들어내는 역할. 파일+폴더정보를 묶어서 가지고 있는 사본객체가 외부에 list를 제공해준다. | 외부 컬렉션 제공부터는 사본을 만들어서 반환한다 각 요소가 외부에서 public메서드를 가져 조작가능한 객체라면, 요소들은 그대로 있고, 컬렉션 주소만 바뀌도록 얕은복사를 해준다. 컬렉션은 건들지말되, 요소들을 변경하고 싶으면 뽑아서 해라! | . | . | . . CompositeTask#getReport . . | TaskReport#getList . . | CompositeSortType -&gt; TaksReportSortType . . 래핑된 객체의 필드로 정렬되므로, getter 추가 및 내부객체-&gt;필드까지 . . | . | . | 파일 + 폴더 반환기능을 위임받는 출력사본 report객체는 파일반환도 해줘야한다. . . | Main에서 Composite객체 및 출력사본 CompositeReport객체 사용하기 . root를 만들고 자식들을 추가한다. 1개의 컴포지트 객체를 공짜로 받아와 add하는 순간은 지금 뿐이다. . . | sub1(자식)아래에 자식들을 넣으려면 list를 통해 반환받는 수 밖에 없으며, composite객체는 list제공기능이 없고, 출력사본으로서 자식list를 제공해주며, 얕은 복사를 통한 제공으로, 요소들을 꺼내서 조작가능하게 하는 것은 TaskReport를 통해 받아보는 수 밖에 없다 . sub들을 얻을 수 있는 유일한 방법: 현재객체의 출력사본 report생성 -&gt; list를 반환 -&gt; 꺼내서 씀 CRUD처럼, if addTask가 [실시간 외부조작 가능한 객체]를 추가한 것을 그대로 반환해주면, 추가된 객체를 list에서 받지 않고, 그대로 객체 조작할 수도 있을 것이다. . . | . | . . | 컴포지트객체는 폴더-파일구조를 바로 확인할 수없다. . 오여주는 애인 Renderer를 정의해서 봐야한다. | . | Renderer: 순회의 제어구조 -&gt; Visitor패턴으로 프레임웤 만들기 . 컴포지트 패턴은 결과물자체도 컴포지트하게 생겼다. 컴포지트 객체를 이용해 만든 Report도 컴포지트하게 생겼다. = 컴포지트를 순회해서 만들었다. 안에 모아놓을 수 있다. | . | 또한, Report를 소비하기 위해서는 또 컴포지트 패턴을 순회해야한다. | . | 컴포지트 패턴을 보려면, 컴포지트 패턴을 다시 순회할 수 있는 순회자를 만들어야한다. 하지만, Report와 달리 순회자는 제어구조다. | 순회의 제어구조는 라이프사이클을 정해두되, 해야할 일은 바깥쪽에서 위임하여 라이프사이클을 탈 수 있다. | 즉, 순회자=제어구조가 해야할일을 거꾸로 정의할 수 있다라면, 프레임웤이 된다. Visitor패턴은 처음 배우는 프레임웤이다. | . | . 출력을 담당하는 class(Renderer)가 제어구조를 가져야한다면, 제어구조에서 제어의 역전을 위해 Visitor를 입력받는다. . Renderer는 다양한종류의 할일을 하는 visitor(다양한 기능의 전략패턴)을 받아들이는 Visitable이지만, 여기서 renderer는 순회의 제어구조를 가지고 있는 프레임웤으로서 여러종류를 가지는 것이 아니기 때문에 전략패턴으로 생성하진 않는다. visitable이 인터페이스가 아니므로, 필드를 가지는 구상클래스로서 visitor을 생성자 주입 받는다. | . | 제어의 역전으로 라이프사이클을 타면서 일을하는 Visitor 종류만만 달라지므로 생성해서 그때그때 사용한 생성context로 간주하여 일반 클래스로 만든다. | . . | Visitor는 원래 인터페이스로 들어온다. 여러 종류의 할일(라이프사이클마다 그에 맞는 데이터가져다주는 기능)을 가진다. . . | Renderer의 역할은 TaskReport를 받아서, 결과물을 바깥에 주는게 아니라(public Item) 출력render(public void)만 해준다 . . | render내부에서는 컴포지트 객체를 만드는 방향과 동일한 방향으로 순회할 것이다. 문제는 순회하며 그릴 때 depth가 생겨난다는 것이 다르다. . **보이진 않지만, 인자가 더 필요하다. `누적되는 depth의 초기값을 밖에서 주는 꼬리재귀구조로서, ** 계층적, 재귀적인 구조는 구조객체 이외에 depth정보도 인자로 달고 있어야한다. | . | 컴포지트 구조도 순회하려면 정해진for가 아니다 더 깊이 들어가는 애도 있는 동적트리 순회 구조이다. | 실무에서는 정해진 트리구조만 다 도는 것이 아니다. 리프가 다양한 구조로 있는 여러구조체를 돈다. | . | 동적트리 순회시에는 최소한의 depth정보를 누적결과값으로 물고다녀야한다 **계층적, (꼬리재귀)적, 동적트리 구조의 순회는 누적결과값파라미터를 물고, 최초호출시 인자에서 주어진다, ** | . | . . | 최초 depth는 0으로 주어져야한다. 하지만, 사용자가 0으로 준다는 보장이 없다 -&gt; 이 때 꼬리재귀를 위한 private메서드 추출이자 최초(누적결과값변수의) 인자를 내부에서 상수로 주는 오버로딩을 드디어 사용한다. . **사용자(public)는 depth가 없는 render(TaksReport report)만 호출할 수 있게 한다 ** | 누적결과값 파라미터의 최초인자 0을 줘야하는 depth를 파라미터가 추가된 꼬리재귀 메서드는 직접 0을 주고 내수용으로 오버로딩해서 private(사용자 사용금지)으로 으로 생성-정의한다 **좋은 함수는 인자0~1개인 함수다. 더러운 것 = 인자 2개이상 &amp;&amp; 직접 초기값을 줘야하는 함수는 -&gt; 전부 private으로 내부에서 하는 오버로딩으로 정의 하면 된다. ** | 더러운 것은 안에서 하고, 바깥에는public 좋은 함수를 줘라 | . | . . . | Visitor패턴에서 visitor를 받는 visitable(Renderer)는 1개의 메서드 안에 라이프사이클에 맞는 제어구조를 작성해야한다. . render메서드 안에서 다 작성해주자. | . task부터 그려야한다. -&gt; visitor에게 task객체를 줘서 그리는 책임을 위임한다. . 내가 안한다. 라이프싸이클을 타고 있는 visitor에게 시킨다. | . . | | 근데, 객체지향에서 생각해야할 것이 있다. 협력인스턴스가 생성하는 context(동시성 문제가 발생할 수 있어서, 매번 새로 생성할지)인지 협력인스턴스를 소모하고 재활용하는 context인지 생각해야한다. . 협력인스턴스를 내부에서, 메서드호출마다 매번 생성하면 동시성 문제가 하나도 없어진다 . | 전략패턴의 visitor를 단일객체을 외부에서 생성된 것을 받아서 new때리지 않고 있다. | 그러나 제일 안전한 것은 언제나 협력 인스턴스를 생성하는 것이다. 그러려면 외부에서 생성된 협력 객체가 아니라, 외부에서 생성자를 받아야한다. | 생성자를 받는다는 것은, 인스턴스를 return해줄 수 있는 (인자있)Functional or (인자없)Supplier를 받는 것이다. 그래야 범용적인 Visitor를 매번 상태가 초기화된 협력인스턴스를 가질 수 있다. | my) 내부정보로 내부발행객체를 생성하는 것처럼, 협력 인스턴스가 추상체일 때 내부 발행하려면 외부에서 받아야하는 추상체변수로 new때리질 못한다. 외부에서 생성자 호출직전까지의 로직으로 받아야한다. | 생성자 로직을 받을 때, 생성자 로직이라면 return이 필요하므로 Supplier나 Functional을 받고, 제네릭에는 받는 협력인스턴스 형을 T로 준다. | 내부에서는 받은 로직을 실행하기 위해 .get() 나 .apply()를 통해 lazy evaluate의 연산지연실행 메서드를 사용한다 | 외부에서는 가상의 인자로 람다식을 통해 [생성자 로직]을 인자로 전달해 아~ 호출시마다 매번 해당로직이 지연실행되는 구나. 생성자호출이라면, 객체생성이, 매번 되는 구나라고 생각한다. | | . | . | 협력인스턴스의 추상체 visitor를 이미 생성된 객체가 아니라, render()호출시마다 내부에서 언제나 새로 생성해서 사용하기 위해 Visitor주입 -&gt; Supplier&lt;Visitor&gt; 주입으로 변경한다. . 변수명은 factory로 받는다. | . . . | visitor의 생성은, 꼬리재귀 호출전에 생성되어 인자로 줘야한다. . . 꼬리재귀에서 재활용하기 전에, 재활용될 visitor를 생성한 뒤, 오버로딩 된 꼬리재귀 메서드에만 인자로 추가한다. | . . . | java헛소리로서 즉시 인자로 반영될 값이라면, 지역변수로 빼놔야 가독성에 좋지 않나요? 라고 한다. . . 하지만, 인자에 넘어갈 변수 &lt;-&gt; 메서드 사이에 지역변수를 통해 트랜잭션(검증, visitor.타메서드() 호출 등)을 안할 거면, 그리고 어려운코드가 아니라면, inline으로 쓰는게 맞다 | 지역변수가 있다. == 해당 변수로 추가적인 일을 시키고 나서 인자로 넘기겠다. | 지역변수가 없다. == 만든 변수를 건들지않고 인자로 바로 넘기겠다. | . . . | 꼬리재귀 정의부에서는 최초호출시 인자가 넘어와서, 누적/재활용되기 전 제일 처음 변수로 어떤 조작이 될 것이다. . 생성되고 제일 처음visitor로 task를 그린다. | . . Visitor가 상태를 가지는 인스턴슨지 뭔지는 모르겠지만, 호출시마다 매번 생성되는 상태니 동시성 문제가 하나도 없으며, 찌꺼기 상태값을 고려안해도 된다. . | 우리는 gc를 믿고 개기는 것이다. 객체를 재활용할 생각 자체를 버리자 무조건 만들자. 객체지향은 new도는 것 . | . . | 파일(task)는 그렸으니, 자식들subtask들을 돌리 위해서는 반복문을 써야한다. . 자식들도 하나의 task로서, 반복문내에서 꼬리재귀render를 해야한다. . render해야 자신의 task를 그리고, 자식들마다 for문돌면서 task들을 다시 그린다. | . | **꼬리재귀 내부에서 자식들의 (return or 마지막문장의) 종착역설정은 render를 안타게 되는 == for문을 안타는 ==빈List를 가진 자식일 것이다. ** . | 데코객체가 아니므로 연결된 next/prev데코객체.꼬리재귀형태가 아니라메서드 수준에서의 꼬리재귀는 재귀재료에 [현재 주체]까지 모두 인자로 표현하여 다들고 다니므로, 호출인자만 업데이트된 인자로 [내수용 꼬리재귀 메서드 호출]로 재귀를 호출한다. . . | 주체자가 report -&gt; subReport로 바뀌었다. . visitor는 그대로 재활용된다. | depth는 1개 증가한 것으로 줘야한다. | . | . . . | 그렇다면, 자기자신을 그릴 때, 현재의 depth정보(자식은 +1)도 필요할 것이다. . . . | 라이프 싸이클에 따라, visitor에게는 end(depth)를 호출해서 task + 자식taks를 다 그린 [종결처리]를 해줘야한다. . 왜 꼬리재귀에서 따로 종결처리를 해줘야하지? 결과값을 누적하는꼬리재귀가 아니라 depth를 업데이트하며 출력만 하는 꼬리재귀이며, 마지막 node일 때 출력이 달라지므로? | . | . . . | 라이프싸이클에 따른 composite제어구조는 Visitable에 해당하는 Renderer가 다 가져갔다. visitor는 라이프싸이클에 따른 생명주기 함수들만 정복하고, composite제어에 대한 정보가 없다. . 제어와 실행을 분리하는 것이 visitor패턴이다. | 앞으로 3년간… 어려운 제어를 실행하는 놈 vs 제어를 통제하는 구조를 분리하는 연습해야한다. | . . | 이제 인터페이스 Visitor에 제어를 실행하는 [라이프싸이클 함수] 2가지를 추가해준다. . 라이프싸이클 함수가 생기는 이유 -&gt; 해당 인터페이스는 제어의 흐름에 들어가있는 visitor객체다 | . . . | ConsoleVisitor: 제어구조에 끼워넣을 제어실행visitor 구상체1 . . task1개를 표현하면, depth만큼 빈 padding문자열을 실제 padding으로 들어갈 문자열을 정해서 depth수만큼 누적합되어야한다. . depth만큼 반복문을 돌면서 정해진 padding문자열을 누적합한다. | . . . | padding이후 가장 먼저 표시해야할 것은 토글여부이다. isComplete 필드의 getter를 만든다. . 보통 isXXX boolean필드의 getter는 get을 뺀다고 한다. . 불린flag자체가.. return boolean변수이므로… 물어보는 것과 동일하다 | . . | isComplete()여부에 따라 [v] 나 [ ] 를 표시하도록 삼항연산자를 활용해준다. . . | . . | Main에서 render + consolevisitor로 visitor.taskDraw() 출력 확인하기 . Render를 만들되 생성자에서는 내부에서 라이프싸이클을 타는 visitor객체가 제어메서드 호출시마다 새로객체를 생성하도록 람다식으로 supplier제공해주기 . 라이프싸이클타는 객체를 생성해서 넣어주지 않고, 라이프싸이클을 가진 제어메서드호출시마다 생성하도록 하기 위해 supplier or functional을 통한 factory를 넣어줘서 생성한다고 표현한다. | . | render.render( )시, 위에서 만들어둔 root를 report로 만들어서 넣어주기 . . . | 출력해보기 . depth마다 -가 붙은 체로 출력된다. | 종결처리를 해주면 각 task마다 뭔가 표시를 해줄 것이다? | . . . | 정렬방식 고민하기 . 현재 문제는, 정렬방식을 내부에서 정하고 있다. 원래는 root task를 통해 report를 만드는 getReport()시 정렬방식을 인자로 줘야한다. . 내 코드(report의 자식들을 꺼낼 때만 정렬방식 적용해서 제공) . . | 되어야할 코드 . . | . | . | task -&gt; 내부에서 TaskReport만들때부터 정렬방식이 전해져야한다. . 정렬방식 받는 것을 추적해서, task#getReport에서 정렬방식 인자를 주입하도록 하기 . 현재는 report에서 꺼낼때만, 정렬방식을 인자로 주입받고 있다. . Main에서 Report의 자식들을 꺼낼때, 정렬된체로 꺼내기 . . | render시 내부에서 report들의 자식들을 꼬리재귀로 출력하려고 꺼낼때, 인자로 받는 중 . . | . | 하지만, report를 만들때(task#getReport()부터 이미 인자로 주어져서 정렬된 체로 report를 생성하도록 변경해야, render시, task -&gt; 정렬된 report를 만들어 report만 넘기기를 할 수 있다. . . . . . | . | JsonVisitor: depth를 가진 출력은 json형태라서 만들 수 있다 . 원래 json은 쌓아가야하는 drawTask시, string들을 쌓아가야하는 입장이다. sout이면 안쌓아도되고, 문자열을 원하면 쌓아야한다. | 여기서는 sout로 간다. | . | json은 taks정보 + sub task들정보 + 다끝나면 중괄호가 닫힌다. end에서 할일이 있다. | . | . ConsoleVisitor의 내용을 가져오되, 처음 작성할때 drawTask의 padding만큼 밀리고, end에서도 padding만큼 밀리니 -&gt; depth만큼 쌓이는 padding로직을 내수용(drawTask + end 공통으로 사용) 메서드 추출을 통해 class 내부로 빼낸다 . . . 이 때, padding은 ` - -&gt; “ “ 빈 문자열`로 바꾼다. | . | . 첫번째 줄은 padding + 중괄호{다 . . | 필드는 padding + ` 중괄호대신 공백 + 필드명: + 문자열이므로 “내용”으로 양쪽 큰따옴표가 나가야하므로 java내에선 &quot;를 사용하며 + 끝날때는 콤마까지 가지고 가야한다. &quot;,` . . 복사해서 date도 해결한다. | . | boolean은 내용에 큰따옴표가 필요없다. . true, false는 자동으로 문자열로 true, false로 바뀐다. | . . | 문제는 sub들이다. . sub: [ 내용으로 대괄호 + 공백인 상태로 주면, | 그담 task가, 자신의 패딩+ 중괄호로 열고 시작하게 된다. | 대신, end의 닫기역할만 잘해주면 된다. 자신은 자기닫기만 잘챙겨주면, 된다. **자식들을 가져, 1개의 누적결과값반환이 아닌, 반복문의 재귀에는 ** 자신은 시작만 해놓고, 자식들을 호출하며 | 자신과 자식들모두 각자의 end의 종결처리가 필요하다. | . | . | . . . 종결처리 | . . . | json의 괄호들은 내턴을 닫을 때, 중괄호뒤에는 }, 콤마를 반드시찍어준다. . 자식들끼리 콤마로 연결되어야하므로.. 안찍어주면 에러다 | . . root의 중괄호도 마지막이 콤마가 찍힌다. . . | js에서 object에 트레일링콤마를 허용하자라는 말이 나온다. . 트레일링 콤마(Trailing comma)는 여러 요소들을 쉼표(콤마)를 사용하여 나열할 때, 가장 마지막 요소 다음에 오는 쉼표를 말한다. . 위 트레일링 콤마는 생략하여도 아무런 변화를 만들지 않으며 단지 수정을 편하게 하기 위한 도구이다. . | 한편 Go의 경우 배열을 여러 줄에 나눠 입력할 때 트레일링 콤마가 강제 사항이며 이를 생략하면 다음과 같은 에러를 발생시킨다. . | . | . | 프레임웤을 visitor패턴으로 만들 때, 트레일링콤마를 허용안한다면, end종결처리 메서드와 꼬리재귀의 파라미터에 isEnd를 추가해줘야하고 + end에서 분기를 걸어줘야한다. . 프레임웤을 만드러보면, 트레일링 콤마를 쓰자고 한다. | . . . | . | Main에서 사용 . . 프레임웤은 visitor패턴과 템플릿메소드패턴으로 구성된다. . 몸통 : visitor패턴을 상속한 visitor객체들이 구현한다 | 가장 큰 프로세스(제어): templatemethod의 훅으로 통제한다. . | 스프링의 예 컨트롤러를 pojo로 만들면, 어노테이션(router)에 의해 visitor로서 작동한다. | 그에 비해 스프링 interceptor는 템플릿메소드를 만들어서, 구상은 before/after intercept를 만들어서 훅을 구현한다. | . | 큰 흐름은 템플릿메소드패턴으로 강제시키고, 안에 몸통의 유연성 + 다양한 라이프사이클은 visitor패턴으로 처리한다. 안드로이드 개발시 activity상속받으면 전부 라이프사이클함수 구현이다. 라이프싸이클을 타는 거대한 visitor객체였다. | . | . | 프레임웤에서 구현해야하는 것들은 모두 visitor다. 제어구조를 역전시키려고 | 우리는 rendner1개에다가, visitor를 전략객체로서 공급했다. 큰범위는 다 전략패턴이다. 전략패턴은 추상체로 소유하면 다 전략패턴이다. 더 큰 범위 | 그 중에 visitor패턴은, 제어역전으로 제어능력을 잃어버린 전략객체(라이프싸이클 함수만 구현)하는 것들만 visitor패턴이라 부른다. | . | 의존성 역전(DI) : 구상체를 알아야하는 애가 추상체를 알도록 바꾸는 것 전략패턴 | . | 제어 역전(IoC) : 제어구조는 미리 짜놓고, 라이프싸이클을 타는 애가 라이프싸이클함수만 구현 visitor패턴 | . | 다음시간에는 컴포넌트 패턴 패턴을 조합해서 새로운 패턴을 만드는 것 | 대표적으로 MVC패턴 -&gt; 옵져버 + @를 조합했는데 새로운 파워의 패턴이 나온 것 | . | .",
            "url": "blog.chojaeseong.com/object/2022/07/01/((object2-3)todo_1_todo%EB%A5%BC_%EB%A7%8C%EB%93%A4%EB%A9%B0_composite_visitor_%ED%8C%A8%ED%84%B4_%EC%A0%95%EB%A6%AC-%EB%B3%B5%EC%82%AC%EB%B3%B8.html",
            "relUrl": "/object/2022/07/01/((object2-3)todo_1_todo%EB%A5%BC_%EB%A7%8C%EB%93%A4%EB%A9%B0_composite_visitor_%ED%8C%A8%ED%84%B4_%EC%A0%95%EB%A6%AC-%EB%B3%B5%EC%82%AC%EB%B3%B8.html",
            "date": " • Jul 1, 2022"
        }
        
    
  
    
        ,"post33": {
            "title": "stream 스트림 사용예시 모음",
            "content": "Stream 기본 . 프리코스때 한 것 . String 역 출력 -&gt; new StringBuilder( string ) .reverse().toString() -&gt; split -&gt; stream -&gt; list -&gt; Collections.reverse( list )가 inplace 역순시킨다. -&gt; stream + reduce + get으로 문자열 모으기 . | arr 2개 합치기 -&gt; Stream.of( arr1, arr2) .flatMap(Stream::of) .collect(Collectors.toList()); . | list 2개 합치기 ( stream없이 할려면, 빈리스트에 addAll + addAll ) -&gt; Stream.concat( list1.stream(), list2.stream()) . | list 중복제거 -&gt; list.stream().distinct() + .collect(Collectors.toList()) . | list의 집계함수 만들기 by reduce().get() + Integer::sum -&gt; list.stream() .reduce(Integer::sum) .get(); . | 음수검사: IntStream만들어서 custom boolean식 만들고 filter에 넣기 -&gt; Arrays.stream(mathexpression.split(“,|:”)) .mapToInt(Integer::parseInt) .filter(i -&gt; checkNegative(i)) // .sum(); . | 숫자사이 연산자들의 연속입력 검사 : -&gt; if (Arrays.stream(removedSpaceInput.split(“[0-9]”)).anyMatch(operator -&gt; operator.length() &gt; 1)) { . | 객체속 변수2개로 -&gt; map key, value만들기 -&gt; list.stream() // .sorted(Comparator.comparingInt(Item::getId).reversed()) .collect(Collectors.toMap( Item::getId, Item::getValue, (OldId, newId) -&gt; OldId, // (OldId, newId) -&gt; newId, LinkedHashMap::new )); . | . .filter() 신기한 것 . anyMatch 류는 해당하는 것들만 필터링 된다. . | string을 돌고 있다면, str.indexOf(“특정문자”) == 2 등과 같이 특정문자열 1개의 위치로 필터링 가능하다 . Arrays.stream(input.split(&quot;#&quot;)) // 홍길동:100 , 이순신:90 .flatMap(str -&gt; Stream.of(str.split(&quot;:&quot;))) // {홍길동, 100} , {이순신,90} -&gt; 홍길동,100,이순신,90 .filter(it -&gt; it.indexOf(&quot;신&quot;) == 2) .findFirst() .ifPresent(s-&gt; System.out.println(s)); . | null아닌 것만 필터링 하려면 Objects.notnull()을 필터에 넣어주면 된다. . Collection&lt;String&gt; animals = Arrays.asList(&quot;Dog&quot;, &quot;Cat&quot;, null, &quot;Moose&quot;); String result = animals.stream() .filter(Objects::nonNull) .collect(Collectors.joining(&quot;, &quot;)); . | 이중반복문 . 이중반복문 + 조건식 -&gt; 요소1vs요소2 필터링 by .filter( .anyMatch() ) . java8이전 . final List&lt;String&gt; abcde = List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;); final List&lt;String&gt; abd = List.of(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;); // 8이전: 이중 for문 + 조건식 -&gt; 반복문내 조건만족값을 모을 결과값 가변변수에 add final List&lt;String&gt; result = new ArrayList&lt;&gt;(); for (final String str1 : abcde) { for (final String str2 : abd) { if (str1.equals(str2)) { result.add(str1); // 같으니까 둘중에 하나만 담기 } } } System.out.println(&quot;result = &quot; + result); //result = [a, b, d] . | java8 Stream . 바깥Stream.filter() + 안쪽Stream.anyMatch() | . //1. 첫번째 list를 돌 때, 2번째 list가 돌았다고 가정하고 둘이서 condition조건식을 비교하므로 // -&gt; .map()이나 .collect()가 아닌 .filter( 1stElement -&gt; )로 시작하는 것을 유의해야한다. // -&gt; my) 돌면서 조건식 -&gt; stream().filter() //.filter( str1 -&gt; str1) //2. 람다식 -&gt; 우측에는 1번째 요소 이전에 2번째 list가 먼저 stream으로 풀어져야하므로, list2부터등장하는 것을 유의해야한다. //.filter( str1 -&gt; abd.stream(). ) // -&gt; 2list.stream()이후 2번째 요소가 등장한다고 가정하면, 뭘 할 것인가 를 먼저 생각하고 .메서드()를 호출해야한다. // -&gt; .stream(). ??? ( 2번재요소 -&gt; 1번째요소랑 .equals()등의 조건식을 다룰 것)이므로 // --&gt; 2번째 stream의 요소는 조건식인 anyMatch/allMatch/noneMatch( ) 내부에서 1번째 요소를 맞이한다. // --&gt; 이후 filter( 내부에서 해당 조건식을 통과하는 것만 남겨진다.) final List&lt;String&gt; result2 = abcde.stream() .filter(str1 -&gt; abd.stream() // .( str2 -&gt; str2.equals(str1)) .anyMatch(str2 -&gt; str2.equals(str1))) // str1 1개에 대해, list2 중에 어느하나라도 만족한다면, 통과? // -&gt; filter( anyMatch( 조건식 )-&gt; 어느하나라도?(X) 만족하는 것만 필터링한다** // --&gt; filter( noneMatch( 조건식 ) -&gt;모두불만족시 true?(X) 불일치하는 것만 필터링** .collect(Collectors.toList()); System.out.println(&quot;result2 = &quot; + result2); //result2 = [a, b, d] //암기하자면 - list1 + list2 + 조건식이다? //list1.stream().filter()로 시작하여 e1은 결국 e2와 조건식을 비교해서 if필터링해서 모아야한다. //list2.stream().anyMatch( e2 -&gt; e1과조건식)으로 [조건을 만족하는 데이터만 true체크]한 뒤, filter로 넘어갈 수 있게 한다. //모은다. result2.forEach(System.out::print); . | . . 내부 Stream으로 바깥반복문Stream 입장에서 내부반복문or분신술에의한 Stream&lt;&gt;이 생겼다. 이 때, 바깥에서 flatMap()을 쳐주면, 내부 Stream을 바깥입장에서 동등하게 1개씩 보내줄 수 있다. | . | . 이중반복문 + 요소1,2를 재료로 새객체 생성 by .flatMap( .map() ) . map( .map( -&gt; 새객체 )) 이후 바깥쪽을 flatMap으로 고쳐주면, **Stream&lt;Stream&lt;&gt;&gt; 에서 e1당 list2의 분신술들이 1개식 동등하게 넘어가도록 펴진다.** . . //2중 for문 + 생성자 -&gt; e1, e2 1개씩 재료로 활용해서 새객체 모으기 // enum 2개가 반복문을 2번 돌 것임. Arrays.stream(Suit.values()) // 일단, e1이 결국엔 e2와 만나서 새로운 객체를 생성할 것이니 filter( e1-&gt;)이 아니라 map(e1-&gt;으로 시작한ㄷ) //.map(e1-&gt; ) .map(e1 -&gt; Arrays.stream(Denomination.values()) //e2도 결국엔 e1과 만나서 새로운 객체를 생성하니 map으로 시작한다. //.map(e2 -&gt;) .map(e2 -&gt; PlayingCard.of(e1, e2))) // 안쪽 stream은 collect를 하지 않고 -&gt; anyMatch의 true체크된 Stream&lt;Boolean?결과물&gt; or map의 Stream&lt;PlayingCard결과물&gt;로서 Stream을 유지한다. // 안쪽stream의 안모으고 중간연산만 했다면, Stream&lt; Stream&lt;&gt;&gt;일 것이다. -&gt; 바깥에서만 모은다면, 바깥만 list화되서 -&gt; List&lt;Stream&lt;PlayingCard&gt;&gt; Type이 된다. .collect(Collectors.toList()); Arrays.stream(Suit.values()) //e1 vs list2들이 돌면서, Stream ( Stream&lt;map된객체&gt; , Stream&lt;map된객체&gt; , Stream&lt;map된객체&gt; )형태로 // -&gt; 바깥 요소에 대해 Stream&lt; Stream&lt;객체&gt; &gt;가 된 상태이니, // -&gt; 안쪽Stream()에 의한 분신술을 개별 Stream으로 인정해주는 flatmap을 바깥에서 적용한다. // --&gt; Stream( &lt;map된객체1&gt;&lt;map된객체2&gt;&lt;map된객체3&gt; , &lt;map된객체4&gt;&lt;map된객체5&gt;&lt;map된객체6&gt; , &lt;map된객체7&gt;&lt;map된객체8&gt;&lt;map된객체9&gt; ] // 즉, flatmap은, [안쪽에서 분신술or반복되는 split이나 stream으로 쪼개진 것도 -&gt; 바깥Stream에 1개씩 전달되도록 이정해주는 것] .flatMap(e1 -&gt; Arrays.stream(Denomination.values()) .map(e2 -&gt; PlayingCard.of(e1, e2))) .collect(Collectors.toList()); . . | . 내부에서 분신술로 생긴 Stream&lt;컬렉션&lt;&gt;&gt; -&gt; Stream.of()로 Stream&lt;Stream&lt;&gt;&gt;으로 만든 뒤 -&gt; flatMap . . split으로 분신술로 갯수가 늘어난 단일요소는 배열String[]들이 stream으로 넘어간다. | . . 늘어난 분신술(배열)을 Stream.of()로 감싸면, Stream&lt;String&gt;들이 stream으로 넘어간다. | . . Stream.of(분신술)들을 map 대신 flatMap으로 변환후 뭉치면 힌트가 사라진다. . 분신술들도 개별 1개씩이 순서대로 1개씩 넘어온다 . . | . | java8이전 . // 8버전 이전 // 2번 split해서, 이순신인 경우 그 점수를 출력 final String input = &quot;홍길동:100#이순신:90&quot;; final String[] splitInput = input.split(&quot;#&quot;); for (final String nameAndScore : splitInput) { final String[] splitNameAndScore = nameAndScore.split(&quot;:&quot;); final String name = splitNameAndScore[0]; final String score = splitNameAndScore[1]; if (&quot;이순신&quot;.equals(name)) { System.out.println(score); } } . | stream . final String input = &quot;홍길동:100#이순신:90&quot;; Arrays.stream(input.split(&quot;#&quot;)) .map(str -&gt; str.split(&quot;:&quot;)) .collect(Collectors.toList()); Arrays.stream(input.split(&quot;#&quot;)) // .map( -&gt; 내부반복문or분신술) 로 Stream&lt; String[] &gt; 형태로 Stream &lt; 배열/컬렉션 &gt; 이 생겼다면, // -&gt; Stream.of()로 쏴서, Stream&lt; Stream&lt; &gt; &gt; 형태로 만들어줘야 .map(str -&gt; Stream.of(str.split(&quot;:&quot;))) .collect(Collectors.toList()); Arrays.stream(input.split(&quot;#&quot;)) // flatMap()으로서, 내부 쪼개진 것들이 1개씩 보낼 수 있게 된다. // -&gt; 즉, 안쪽에서 돌때 .stream()으로 도는게 아니라 split등 분신술을 썼다면, Stream.of()로 씌워줘야 바깥에서 flatMap을 맥일 수 있다. .flatMap(str -&gt; Stream.of(str.split(&quot;:&quot;))) .collect(Collectors.toList()); //홍길동 //100 //이순신 //90 . | . 외부List.of()를 배려한 가변인자(배열)의 내부처리는 stream보다는 List.of() . 배열 -&gt; .stream()의 POSFIX completion -&gt; .toList()를 해도 되지만 | 일괄처리 등 작업이 없다면 그냥 외부에서 쓰던 List.of( 가변배열 )을 그대로 쓰면 된다. | . //배열 -&gt; stream -&gt; toList public Cards(final Card... cards) { this(Arrays.stream(cards) .collect(Collectors.toList())); } //배열 -&gt; List.of(밖에서 쓰던 것 그대로 내부에서 쓰기) . 같은Type에 대해 일괄처리: List.of로 담아 + stream.일괄처리 —&gt; Stream.of().일괄처리 . 개별 Card객체에 대해 일괄적으로 isAce인지 물어보고 싶다. . 개별Card들을 List.of()의 컬렉션에 담고 -&gt; stream(). 일괄처리 | . final boolean hasAce = List.of(first, second) .stream() .anyMatch(it -&gt; it.isAce()); . intellij추천 같은형이면 `Stream.of( , , )에 담아서 한번에 일괄처리 | . final boolean hasAce = Stream.of(first, second) .anyMatch(Card::isAce); . | . 같은 도메인이라면 List.of()나 Stream.of()로 묶어서 메세지보내 일괄처리 or 내부변수 map변환 단순집계가 가능하며, 집계는 map + .getter()로 집계대상의 변수를 getter으로 변환하는 과정을 거쳐서 한다. . 개별로 getter를 써서 일일히 다 더하는 경우 . public static Object start(final Card first, final Card second) { final int sum = first.point() + second.point(); . | 같은형이라 묶어서 -&gt; 일괄처리or단순집계하는데, 내부 변수의 집계라면 getter로 변환해서 집계 . 같은형을 묶을 땐, List.of( , , )나 Steram.of(, , , ) | . Stream.of(first, second) .mapToInt(it -&gt; it.point()) .sum(); . | . 일괄처리가 2번이상 등장한다면, 무조건 List.of(, , )로 묶어놓고 변수로 뽑아놓고 -&gt; list.stream()으로 일괄처리 매번 적용한다. . public static Object start(final Card first, final Card second) { //1. 같은형의 [일괄처리/단순집계]가 2번이상 필요할 땐 -&gt; 무조건 List.of()로 일단 묶어 변수로 뺀다. final List&lt;Card&gt; cards = List.of(first, second); // final int sum = Stream.of(first, second) // 일괄처리1: 내부변수 단순집계 final int sum = cards.stream() .mapToInt(it -&gt; it.point()) .sum(); // final boolean hasAce = Stream.of(first, second) // 일괄처리2: 일괄처리로 메세지보내기 final boolean hasAce = cards.stream() .anyMatch(Card::isAce); if (hasAce &amp;&amp; sum == 11) { return new Blackjack(); } return new Hit(); } . 반복문iter와 forEach . iter . for (CarDto currentCar : currentCars) { System.out.println(currentCar.getName() + &quot; : &quot; + collectDash(currentCar.getPosition())); } . | forEach . currentCars.forEach(currentCar -&gt; { System.out.println(currentCar.getName() + &quot; : &quot; + collectDash(currentCar.getPosition())); }); . | . 반복문fori 과 IntStream . fori . StringBuilder track = new StringBuilder(); for (int i = 0; i &lt; position; i++) { track.append(&quot;-&quot;); } return track.toString(); . | Intstream . IntStream.range(0, position) .forEach(i -&gt; { track.append(&quot;-&quot;); }); return track.toString(); . | . 집계max( 숫자VO::compareTo ) . 값으로 변환한 뒤에 .max()는 인자없이 바로 사용가능 | . this.cars.stream() .mapToInt(car -&gt; car.toInt()) .max() .orElseThrow(() -&gt; new NoSuchElementException(&quot;최대값이 존재하지 않습니다.&quot;)); . 값 객체끼리 비교는 필요조건이있다. 숫자VO에서 Comparable 구현 | VO로서 기본 equals 가지기 | compareTo 오버라이딩후 구현 -&gt; Integer.compare( , ) | stream에서는 .max( 클래스::compareTo)로 비교하면서 집계 | | . //1. Comparable&lt;&gt; impl하고 implements Comparable&lt;$CLASS_NAME$&gt; //2. 오버라이딩 compareTo -&gt; Integer.compare( this.숫변.toInt() , o(인자).숫변.toInt() ); return Integer.compare( this.$INT_VALUE$.toInt() , o.$INT_VALUE$.toInt()); //3. VO라면 값같으면 같은객체 보장용 -&gt; equals &amp;&amp; hashCode 오버라이딩 //4. stream에서는 .max집계( 클래스::compareTo ) cars.stream() .max(Car::compareTo) .orElseThrow(() -&gt; new IllegalArgumentException()); . 참고) 제네릭메서드 + reduce로 max 집계 . private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;T&gt; list) { return list.stream() .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) .get(); } . list필터링- filter ( -&gt; 객체. t/f반환메서드 사용 ) . 조건에 부합하는 것만 골라내야한면, filter + 객체에게 시켜서 t/f반환하도록 한다. | . this.cars.stream() .filter(car -&gt; car.isSamePosition(maxPosition)) // 필터로 조건메소드 참인 것만 골라내기 .collect(Collectors.toList()); . 특정 문자열속성 joinning - (map+getString -&gt; joining) . cars.stream() .map(car-&gt;car.getName()) .collect(Collectors.joining(System.lineSeparator())); . 만족하는 총 갯수 카운팅(for+if+add -&gt;) by filter.() + (다모아서) count() . public int match(final Lotto other) { return (int) other.value.stream() .filter(it -&gt; contains(it)) .count(); } public boolean contains(final LottoNumber number) { return value.contains(number); } } . private int calculateAceCount() { return (int) playingCards.stream() .filter(PlayingCard::isAce) .count(); } . 역순 list . List&lt;Rank&gt; ranks = Arrays.asList(Rank.values()); Collections.reverse(ranks); . 역순 stream With comparable 상속 . .stream() .sorted(Comparator.reverseOrder()) . 누적은 mapToType + .집계 » .reduce(초기값, 해당Type::집계함수) 더 깔끔 . //수정전 return rankResults.entrySet().stream().map(Entry::getValue).reduce(0, Integer::sum) * Lotto.LOTTO_PURCHASE_MONEY; //수정후 return rankResults.entrySet().stream() .mapToInt(Entry::getValue) .sum() * Lotto.LOTTO_PURCHASE_MONEY; . toSet() / toMap() 등… 다른 것으로도 가능 . set | . numbers.stream() // 스트림을 열고 .map(Number::new) // 가공하여 .collect(Collectors.toSet()); // 결과를 셋으로 만든다. . map | . LOTTO_NUMBER_CACHE = IntStream.rangeClosed(MIN_LOTTO_NUMBER, MAX_LOTTO_NUMBER) .boxed() .collect(Collectors.toMap( number -&gt; number, //Function.identity() LottoNumber::new )); . map을 자기자신을 key, 0을 상수 value으로 초기화해서 생성 it -&gt; it : Function.identity()로 자기자신 그대로 반환 이용가능하나보다 | it -&gt; 0 : 숫자는 1단어로 바로 안되나보다. | . | . private Map&lt;Rank, Integer&gt; emptyRankMap() { return Stream.of(Rank.values()) .collect(toMap(Function.identity(), r -&gt; 0)); } . map을 자기자신을 key + key별(그룹별)로 누적 . return lottos.getLottos() .stream() .map(winningLotto::getRankByLotto) .collect(groupingBy(identity(), () -&gt; new EnumMap&lt;&gt;(Rank.class), summarizingLong(Rank::getPrize))); . | toMap으로 다른type의 맵을 만드려면 3, 4번째 인자 동시에 추가해줘야한다. . public static Map&lt;Player, Integer&gt; from2(final Players players) { return players.getGamblers() .stream() .collect(Collectors.toMap( Function.identity(), gambler -&gt; caculateProfit(players, gambler), (x, y) -&gt; y, // 3번재에는.. 올드,뉴 중에 뉴를 선택?? 머지? LinkedHashMap::new) // 4번째에.. 만들 타입 ); } . | . contains와 anyMatch or noneMatch &amp; equals(같은게 &amp; 하나라도 있냐) . 객체 속 특정필드에 대한 contains(boolean) -&gt; stream + map(필드) + anyMatch &amp; equals . 객체 속 필드가 아니라 객체list contains 객체라면 . stream + anyMatch &amp; equals(하나라도 같은게 있냐) | . private boolean containsSection(Section section) { return sections.stream() .anyMatch(value -&gt; value.equals(section)); } . | stream을 안쓴다면 . 빈list add getter로 필드list -&gt; contains ( 객체.getter ) | . | stream을 쓴다면 . map으로 필드list로 변환 -&gt; 같은게 하나라도 있나 anyMatch + equals | . | ! contains라면 . map으로 필드list로 변환 -&gt; 하나라도 같은게 없어야 noneMatch + equals | . private boolean isFirstSection(final Section section) { return value.stream() .map(Section::getDownStationId) .noneMatch(downStationId -&gt; section.getUpStationId().equals(downStationId)); // return !getDownStationIds().contains(section.getUpStationId()); } /* private List&lt;Long&gt; getDownStationIds() { return value.stream() .map(Section::getDownStationId) .collect(Collectors.toList()); }*/ . | . | . 중복검사도 contains와 같다. 같은게(equals) 하나라도 있냐(anyMatch) . 같은게 있으면 예외를 던지는데, ifPresent()는 예외던지는 용이 아니니 조심하자 . 잘못된 예 . private void validateDuplicateSection(final Section section) { values.stream() .filter(value -&gt; value.isSameSection(section)) .findAny() .ifPresent(value -&gt; { throw new SectionCreateException(SECTION_ALREADY_EXIST_MESSAGE); }); } . | anyMatch를 boolean으로 받아서 if문에 걸어 처리 . private void validateDuplicateSection(final Section section) { boolean exist = values.stream() .anyMatch(value -&gt; value.isSameSection(section)); if (exist) { throw new SectionCreateException(SECTION_NOT_CONNECT_MESSAGE); } } . | . | . 특정로직에 해당하는 것이 없느냐도 contains와 같다. 해당하는 게(compareMethod) 하나도 없나(noneMatch) . 비교메서드는 poisitive하게 작성하고 -&gt; 하나도 없느냐의 부정어를 noneMatch로 한다 | . private void validateSectionConnect(final Section section) { boolean isNotConnected = values.stream() .noneMatch(value -&gt; value.haveStation(section)); if (isNotConnected) { throw new SectionCreateException(SECTION_NOT_CONNECT_MESSAGE); } } . 해당(포함)하는게 있으면 -&gt; 찾아서 -&gt; 특정 로직 수행까지 진행된다면, anyMatch + 비교메서드가 아니라 filter + findAny 찾아놓고 -&gt; ifPresent( -&gt; 수행메서드() )로 다르게 작성한다. . 해당하는게 있느냐만 물어보고 끝난다(예외 던지기, 조건문용)면 . anyMatch/noneMatch -&gt; 비교메서드/equals | . | 해당하는게 있으면 -&gt; (찾아서) -&gt; 수행해라면 . filter &amp; 비교메서드/equals + findAny() + ifPresent( -&gt; 수행메서드()) | . private void cutInSection(final Section section) { values.stream() .filter(value -&gt; value.isSameUpStation(section.getUpStation()) || value.isSameDownStation(section.getDownStation())) .findAny() .ifPresent(foundSection -&gt; updateCutInSection(section, foundSection)); } . | . 로또 . shuffle후 subList -&gt; .limit(6)으로 를 통한 랜덤추출 구현 . public static Lotto issueLotto() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } . IntStream + boxed(Integer for Map 제네릭) toMap( it -&gt; key, value)으로 &lt;숫자, 숫자VO&gt;매핑 Map 만들기 . .map() 없이 . | .boxed() 수동 필수 . | toMap( -&gt; a, b)의 2번째 Value 자리에 생성자호출 -&gt; 메서드파라미터 필수! . . | . public synchronized static LottoNumber valueOf(final int number) { checkNumberRightRange(number); if (LOTTO_NUMBER_CACHE == null) { LOTTO_NUMBER_CACHE = IntStream.rangeClosed(MIN_LOTTO_NUMBER, MAX_LOTTO_NUMBER) .boxed() .collect(Collectors.toMap(lottoNumber -&gt; lottoNumber, LottoNumber::new)); } return LOTTO_NUMBER_CACHE.get(number); } . 가변 변수 제거 -&gt; 아직 list가 아닌 [stream상태로 모아서] -&gt; map변환 못한 경우 -&gt; 모아서 list만들면서 map collectAndThen( toList(), 변환메서드) . stream + stream -&gt; concat 하여 map할 기회를 놓친 체 .collect( toList()) 하여 이후 또 개별 stream + map해줘야한다? -&gt; 바로 할 수 있다. 2stream 을 1개 list로 변환해서 모으고 -&gt; 포장까지 할 수 있다.!! | 기존list.stream() + 새list.stream() -&gt; Stream.concat() -&gt; collect( collectingAndThen( toList(), 포장생성자::new ) | . | . public Lottoes combine(Lottoes other) { List&lt;Lotto&gt; result = new ArrayList&lt;&gt;(); result.addAll(lottoes); result.addAll(other.lottoes); return new Lottoes(result); } // 변환후 public Lottoes combine(Lottoes other) { return Stream.concat(lottoes.stream(), other.lottoes.stream()) .collect(collectingAndThen(toList(), Lottoes::new)); } . 블랙잭 . for for 객체 생성 -&gt; stream map -&gt; stream map -&gt; 앞에 map을 flatmap -&gt; toCollection( 모은 결과물stream -&gt; new 원하는 컬렉션 생성) . 앞에 것 suit 1개당 -&gt; 여러 denomination.values()들이 여러개의 결과물을 만들 것이다. | 앞에 것들 suit_1 + suit_2 + … -&gt; 각각에 해당하는 결과물들을 .flatmap()으로 다 모은다 | 모아진 stream을 toCollection( -&gt; )로 또 원하는 컬렉션(Stack)으로 변경생성 | . Stack&lt;PlayingCard&gt; playingCards = Arrays.stream(Suit.values()) //.map(suit -&gt; Arrays.stream(Denomination.values()) .flatMap(suit -&gt; Arrays.stream(Denomination.values()) .map(denomination -&gt; PlayingCard.of(suit, denomination))) .collect(Collectors.toCollection(Stack::new)); Collections.shuffle(playingCards); this.playingCards = playingCards; . Count Map 생성 . CountMap01 EnumMap -&gt; 결과list를 [ 직접 0 초기화후 map.put카운팅] . 제한된 key값들을 도는 Enum.values().stream + forEach put( , 0) + 결과List돌면서 개별 +1 | . private final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); // 카운트 0으로 초기화 { Arrays.stream(Rank.values()).forEach(rank -&gt; result.put(rank, 0)); } // 단일key를 돌면서 result.put(rankPrize, result.getOrDefault(rankPrize, 0) + 1); . [추천] CountMap02 EnumMap -&gt; 결과list를 [초기화없이 map.merge] . 미리 0 초기화 없이 알아서 직전value(없으면 0부터) 누적해주는 -&gt; map.merge( 객체key, 누적해넣을값, Integer.sum()으로 기존value와 누적방법 Bifunction ) | . result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after)) . final List&lt;Rank&gt; results = lottos.stream() .map(lotto -&gt; match(lotto, winningLotto)) .collect(Collectors.toList()); final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); results .forEach(rank -&gt; result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after))); . private Result(final LottoGroup lottos, final WinningLotto winningLotto) { for (Lotto lotto : lottos.get()) { Rank rank = Rank.of(lotto.countSameNum(winningLotto), lotto.contains(winningLotto.getBonusNumber())); value.merge(rank, 1, Integer::sum); } } . [추천] CountMap03 -&gt; 일급vs단일 [key처리와 초기화없이 counting을 동시에 ] by Collectors.groupingBy . 일급vs단일의 결과값list 바로 뽑은 뒤 처리하는 대신 처리 + counting을 동시에 -&gt; groupingBy(단일vs단일로 객체key로직, summingInt( count -&gt; 1))으로 한번에 로직처리 + Map만들기 | . | . this.value = lottos.stream() // 일급vs단일 -&gt; 단일vs단일 -&gt; 결과 List .collect(Collectors.groupingBy( lotto -&gt; match(lotto, winningLotto), // 단일vs단일로 결과객체 1개 Collectors.summingInt(count -&gt; 1))); // 없으면 0부터 1씩 count누적시킴 . 맵 타입 지정 가능 | . final EnumMap&lt;GameResult, Integer&gt; dealerResult = gamblers.stream() .collect(Collectors.groupingBy( gambler -&gt; getResultPlayer(dealer, gamblerResult, gambler), () -&gt; new EnumMap&lt;&gt;(GameResult.class), // Map타입 가운데서 지정 Collectors.summingInt(count -&gt; 1) )); . map 돌아서 처리하기 . key만 == 1개만 필요한 경우 : map.keySet().stream().map() -&gt; map.get(key) . key객체만 돌기 때문에 -&gt; map(value)을 내부에서 따로 호출(map.get( 도는 key)해야한다. key가 getter를 소지한 객체인 경우, 객체key 자체의 값과 map에 박혀있던 key의 값을 처리할 수 있다. | . | . public long getPrize() { long prize = 0; for (Rank rank : value.keySet()) { prize += (long) rank.getPrize() * value.get(rank); } return prize; } . value만 == 1개만 필요한 경우 : map.values().stream().map() -&gt; map.get(key) . private static long getTotalReturnByLottoResult(Map&lt;Rank, LongSummaryStatistics&gt; lottoResult) { return lottoResult.values() .stream() .mapToLong(LongSummaryStatistics::getSum) .sum(); } . key+value가 둘다 필요한 경우: map.entrySet().stream().map() -&gt; it.getKey + it.getValue . stream상 1개 값이 key, value를 다 가지고 있으며, map을 따로 호출할 필요 없이 뽑아서 쓰면 된다. cf) Long타입의 누적은 .reduce( 0L 로 시작하고, 집계함수자리에는 Long::xxx)를 넣어주면 된다. | . | . private Long calculateTotalReward() { return rankResults.entrySet() .stream() .map(result -&gt; Rank.calculateMoney(result.getKey(), result.getValue())) .reduce(0L, Long::sum); } . mapToType한 뒤, 정해진 .집계메서드() 쓰는게 젤 편하다. 어느 방식이든 default값은 0으로 쳐준다. | . //요렇게도 사용할 수 있을 것 같네요🙂 public double getRateOfProfit(Money money) { long totalMoney = result.entrySet() .stream() .mapToLong(entry -&gt; entry.getKey().multiply(entry.getValue())) .sum(); return money.getRateOfProfit(totalMoney); } . map을 돌며, 누적하기 . int (mapToInt -&gt; sum() ) . value.entrySet() .stream() .mapToInt(Entry::getValue) .sum() * Lotto.LOTTO_PURCHASE_MONEY; . long with Enum ( map -&gt; reduce( 0L , ) ) . rankResults.entrySet() .stream() .map(result -&gt; Rank.calculateMoney(result.getKey(), result.getValue())) .reduce(0L, Long::sum); . //Rank public static long calculateMoney(final Rank currentRank, final long count) { return currentRank.reward * count; } . 누적 계산( int vs Long ) . [추천] 누적 연산이 미리 정해진 계산: mapToType( -&gt; ) -&gt; .sum() . 최종결과가 21억이 넘냐 안넘냐에 따라서 애초에 자료형을 long으로 선언한다. . public enum Rank { FIRST(2_000_000_000, 6), SECOND(30_000_000, 5), THIRD(1_500_000, 5), FOURTH(50_000, 4), FIFTH(5_000, 3), NOT_THING(0, 0), ; private final long reward; private final int hitCounts; . 나는 단일 값이 21억이 안넘어서 default int로 선언했지만, 누적합에서 21억 넘을 수 있으니 미리 자료형을 long으로 해주자 . 내가 최종결과 간과 한 것 . . | 최종결과가 21억이 넘을 가능성 -&gt; 미리 long타입으로 선언해준 경우 . | 참고) long타입 표기를 위해 L붙일 경우 _ 끊음 표시 못넣는다. . | . | . 메서드 returntype도 long으로 자동으로 된다. . public long getPrize(final Integer count) { return this.prize * count; } . | 계산도 default값 생각하지말고 누적계산을 정해진 .sum()로 시키면 된다. . public long getPrize() { return value.entrySet() .stream() .filter(result -&gt; !result.equals(Rank.OUT)) .mapToLong(it -&gt; it.getKey().getPrize(it.getValue())) .sum(); //.reduce(0, Integer::sum); } . | | 누적 연산을 커스텀으로 할 경우, map( -&gt; ) .reduce( default값 , Long::sum) -&gt; 불편 . 변환되는 타입이 표기는 안되지만, type이 맞지 않는 경우, 알아서 누적연산 메서드 자리에서 에러 . . . | [비추] for 누적 + 매번 long 형변환하여 +=누적 . 그냥 자료형 자체를 1개를 long으로 선언했어도 됨. | . public long getPrize() { long prize = 0; for (Rank rank : value.keySet()) { prize += (long) rank.getPrize() * value.get(rank); } return prize; } . 로또 . [누적될 값을 반환하는 메서드]를 받아 가변변수 누적을 stream + map + sum으로 누적하기 . . 외적으로 가변변수의 누적은 스트림으로 대체할 수 있다. . 일단 누적될 로직은 리팩토링해서 1개의 메서드로 모은다. . . . | stream으로 가변변수에 값을 누적한다면 . 원시값 누적이면 .reduce(0 , 연산람다식 ) | 변환된 값 누적이면, mapToXXX( ) -&gt; .sum()을 때리면 된다. | . . . | . | 체스 . enum에서 filter(해당문자열 확인) + orElseThrow로 enum.of( input ) 검증포함해서 찾기 . 문자열로 확인시 정규식(다 equals인데 하나만 startsWith -&gt; 정규식 비교로 통일) 이 필요하면 그것으로 filter . . public static Command of(final String inputCommand, ChessGame chessGame) { // web등으로 갈 것 같으면, inputView대신 빈값 null검사를 여기로 // if (inputCommand.startsWith(MOVE.value)) { // return new Move(chessGame); // } return Arrays.stream(ChessGameCommand.values()) // .filter(it -&gt; it.value.equals(inputCommand)) .filter(it -&gt; Pattern.matches(it.value, inputCommand)) .map(command -&gt; command.function.apply(chessGame)) .findFirst() .orElseThrow(() -&gt; new IllegalArgumentException(WRONG_COMMAND_MESSAGE)); } . 일반 오리 . . public enum Command { START(Pattern.compile(&quot;start&quot;)), MOVE(Pattern.compile(&quot;move [a-h][1-8] [a-h][1-8]&quot;)), STATUS(Pattern.compile(&quot;status&quot;)), END(Pattern.compile(&quot;end&quot;)), ; Command(final Pattern commandPattern) { this.commandPattern = commandPattern; } public static Command toCommand(String input) { Objects.requireNonNull(input, &quot;command는 null이 들어올 수 없습니다.&quot;); return Arrays.stream(values()) .filter(command -&gt; isMatchPattern(command, input)) .findAny() .orElseThrow(() -&gt; new IllegalArgumentException(&quot;올바른 명령어가 아닙니다.&quot;)); } private static boolean isMatchPattern(Command command, String input) { return command.commandPattern.matcher(input).find(); } . 문자열 split된 것을 skip으로 처리 . 없었다면, 개별 substring했어야함 . public static Positions from(final String command) { return new Positions(Arrays.stream(command.split(SPLIT_DELIMITER)) .skip(1) // [move a2 a4]에서 -&gt; [a2, a4]만 추출 .map(Position::from) .collect(Collectors.toList())); } . | . noneMatch/ allMatch -&gt; (다모았는데) 특정조건은 하나도 없어야한다 / (다모았는데) 모두 만족해야한다. or [배반조건으로서 둘중에 한쪽만] 특정조건만 존재해야한다. . // king들을 다 모았는데, 특정조건 (black인놈은) 하나도 없어야한다 public boolean hasBlackKingCaptured() { return collectKing().stream() .noneMatch(Piece::isBlack); } // king들을 다 모았는데, white는 없어야한다 -&gt; 둘중에 black만 존재해야한다 public boolean hasWhiteKingCaptured() { return collectKing().stream() .allMatch(Piece::isBlack); } . 지하철 경로 . groupingBy로 일급컬렉션을 하위 객체 필드로 가지는 도메인의 findAll() 처리하기 . 상황 . Line 도메인에 response용 하위 도메인 Sections를 sql join으로 붙일 경우 . | 단건 조회(findById)임에도, Line(pk) &lt;—left join— Section(fk)시 line에 대해서는 1xm개의 데이터가 생긴다. . . | . | 해결 . sql join으로 line의 단건 조회 findById의 select절에 section정보를 붙여넣는다. . | queryForList를 통해 단건 조회임에도 여러개 생기는 rows들을 Map으로 반환받고 난 뒤 . | | | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/mission/stream/tdd/2022/06/29/stream_%EB%AA%A8%EC%9D%8C.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/mission/stream/tdd/2022/06/29/stream_%EB%AA%A8%EC%9D%8C.html",
            "date": " • Jun 29, 2022"
        }
        
    
  
    
        ,"post34": {
            "title": "Assertj 및 @annotation 모음",
            "content": "assertj 및 annotation with Junit5 . 학습테스트: 모듈 사용법 읽히기 -&gt; 다른사람이 만든 코드(api)를 검증 = 학습 테스트 | 단위테스트: 내가 짠 코드를 검증하기 위해 만드는 테스트 단위테스트부터 모든 코드를 설계하는 -&gt; TDD | . | . 의존성 추가 . @Test 대신 @ParameterizedTest for 여러case 를 쓰기 위해서 아래 의존성을 추가해야한다. // Assertions testImplementation &#39;org.assertj:assertj-core:3.22.0&#39; testImplementation &#39;org.junit.jupiter:junit-jupiter-params:5.4.2&#39; . Live template . | @Test 대신 @ParameterizedTest for 여러case 를 쓰기 위해서 아래 의존성을 추가해야한다. // Assertions testImplementation &#39;org.assertj:assertj-core:3.22.0&#39; testImplementation &#39;org.junit.jupiter:junit-jupiter-params:5.4.2&#39; . | as+all assertAll( () -&gt; assertThat(actual).isEqualTo(expected$END$), () -&gt; assertThat(actual).hasSize() ); . | as+that Assertions.assertThat(actaul).isEqualTo(expected$END$); . | as+notthr Assertions.assertDoesNotThrow(() -&gt; $WHEN$) . | as+thr Assertions.assertThatThrownBy(() -&gt; $WHEN$) .isInstanceOf($EXCEPTION$.class) .hasMessage(&quot;$MESSAGE$&quot;); . | given : option에 있는 reformat ~ style 체크할 것 //given //when $END$ //then . | methodSource: option에 있는 reformat ~ style 체크할 것 return Stream.of( Arguments.of($END$), Arguments.of() ); . | dynamicTest: 예시 블로그 @DisplayName(&quot;큰테스트이름&quot;) @TestFactory Stream&lt;DynamicTest&gt; collectionsOfDynamicTest() { return Stream.of( dynamicTest(&quot;테스트케이스1&quot;, () -&gt; { // given // when $END$ // then assertThat(actual).isEqualTo(expected); }), dynamicTest(&quot;테스트케이스2&quot;, () -&gt; { // given // when // then assertThat(actual).isEqualTo(expected); }) ); } . 예시 | . | . 용례 . VO . 숫자 VO . 2개를 뽑아서 일치 or 대소비교 . @Test void 로또_번호_일치_여부_검사() { LottoNumber lottoNumber = LottoNumber.getInstance(1); LottoNumber lottoNumber2 = LottoNumber.getInstance(1); assertThat(lottoNumber).isEqualTo(lottoNumber2); } . @Test void comparable() { final LottoNumber lowerLottoNumber = LottoNumber.valueOf(2); final LottoNumber largerLottoNumber = LottoNumber.valueOf(20); assertThat(lowerLottoNumber).isLessThan(largerLottoNumber); } . 캐싱 -&gt; 메모리 주소까지 같은지 . @Test void create2() { final LottoNumber lottoNumber = LottoNumber.of(1); final LottoNumber lottoNumber2 = LottoNumber.of(1); // 정펙매를 이용한 [같은 객체 다시 부를 땐] 완전히 동일한 캐싱 객체 가져오기 assertThat(lottoNumber).isSameAs(lottoNumber2); // true } . COUNT VO . 0까지 허용하여 음수 생성자 에러 . @Test void create() { assertAll( () -&gt; { assertDoesNotThrow(() -&gt; new LottoCount(1)); assertDoesNotThrow(() -&gt; new LottoCount(0)); assertThatThrownBy(() -&gt; new LottoCount(-1)); } ); } . 1개 뽑 + 감소된 것 뽑 -&gt; 감소된 로직후 동일한지 비교 . @Test void decrease() { final LottoCount lottoCount = new LottoCount(1); final LottoCount expected = new LottoCount(0); // 감소된 것 미리 뽑기 final LottoCount actual = lottoCount.decrease(); assertThat(actual).isEqualTo(expected); } . 단일객체 . 상수단일객체 .isSameAs( 실시간생성 단일객체 ) . 상수객체가 정상 단일객체럼 행동하는지 해당 객체 테스트에서 객체상수 isSamaAs 생성한 객체 테스트를 해보자 . 기존 테스트 . @Test void of() { final Card card = Card.of(Suit.HEARTS, Denomination.ACE); assertThat(card).isSameAs(Card.of(Suit.HEARTS, Denomination.ACE)); } . | 사용되는 단일객체를 -&gt; 상수객체로 뽑아서 옮겨놓고 상수로 가져오자. . | | . . . . . | . @Test void of() { assertThat(HEART_ACE).isSameAs(Card.of(Suit.HEARTS, Denomination.ACE)); } . 나머지 사용되는 단일객체들도 다 상수화 -&gt; Fixutre에 public 상수로 옮기기 해주자 | . 일급 . getValue()로 뽑아내고 한다. extracting은 assertThat() .extracting(“value”) 이후 추가 메서드를 못쓴다. list 그대로 비교해야됨. | . | . 숫자VO List . 갯수 + (수동) 개별원소 포함검사 + (랜덤)제한된 범위 경계값 대소 검사 . 갯수 -&gt; 꺼내서 size() . @Test void size() { //given &amp; when final Lotto lotto = LottoFactory.generateLotto(); final int lottoSize = lotto.getValue().size(); //then //일급 재료list구성에 랜덤이 있다면, 갯수 + 제한된 범위 -&gt; 경계값 대소 검사 assertThat(lottoSize).isEqualTo(6); } . | . assertThat( list ) .hasSize(n) or .isNotEmpty() . @DisplayName(&quot;4. findAll _by_select&quot;) @Test void select_findAll() { final MemberDao memberDao = new MemberDao();// 1. dao.crud()중에 final List&lt;Member&gt; members = memberDao.findAll(); //2.findall 메서드는? //3. list의 size를 검사할 때, 빈 것(null같은)에 대핸 비교는 isNotEmpty();로 해주면 된다. assertThat(members).isNotEmpty(); } . list의 순서까지 검사 .containsExactly () . 한번에 생성한 일급 -&gt; 개별원소를 안다면, 제대로 포함하고 있는지 테스트 . contains -&gt; 일부 포함 (중복가능, 순서틀려도 가능) | containsExactly -&gt; 순서+갯수 모두 일치해야하는 거의 equal | . @Test void contains() { final Lotto manualLotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); assertThat(manualLotto.getValue()).containsExactly( new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6) ); } . | 제한된 범위 -&gt; 경계값 대소 검사 . @Test void range() { //given &amp; when final Lotto lotto = LottoFactory.generateLotto(); //일급 재료list구성에 랜덤이 있다면, 갯수 + 제한된 범위 -&gt; 경계값 대소 검사 // 1. list Iterator 만들고 final ListIterator&lt;LottoNumber&gt; lottoNumberIterator = lotto.getValue().listIterator(); //then // 2. hasNext()로 돌면서 while (lottoNumberIterator.hasNext()) { // 3. actual란에 next()로 하나씩 떨궈주기 assertThat(lottoNumberIterator.next()) // 4. Comparable 먼저 impl안하면 아래 문장 2개 에러남 .isLessThanOrEqualTo(LottoNumber.getInstance(45)) .isGreaterThanOrEqualTo(LottoNumber.getInstance(1)); } } . | . list . 일부 필드만 추출해서 검사 .extracting(“”).containsExactly() . hasSize()에 이어서 chaining해서 검사할 수 있다. . | 해당 필드값 list로 변하게 되니 -&gt; .containsExactly( 1값, 2값, ...)로 검사한다 . assertAll( () -&gt; assertThat(response.statusCode()).isEqualTo(HttpStatus.OK.value()), () -&gt; assertThat(response.body().jsonPath().getList(&quot;stations&quot;)) // 최단거리 1-2-3-4-5(50) &lt; 1-5 (55) .hasSize(5) // list의 size와 숫자 비교 (완료됨에도 이어서 list 검증을 chaining할 수 있음) .extracting(&quot;name&quot;) // list의 특정필드 비교 -&gt; 콤마를 통해 2개를 뽑아낼 수 도 있음. -&gt; 이 땐, t .containsExactly(&quot;강남역&quot;, &quot;잠실역&quot;, &quot;선릉역&quot;, &quot;사당역&quot;, &quot;신림역&quot;) // contains -&gt; 일부 포함 (중복가능, 순서틀려도 가능) vs containsExactly -&gt; 순서+갯수 모두 일치해야하는 거의 equal ); . | . 일부 필드 2개이상 추출 containsExactly + tuple . 필드를 1개만 추출할 땐, containsExactly()의 힌트가 Object... values로 콤마로 값 1개만 입력하면 되었는데 . | 필드르 2개 추출하는 순간, 힌트가 Tuple… values로 바뀐다. . . 2개이상의 값을 tuple()에 씌우면 된다. | . . 특이한 점은 id가 long -&gt; json(string) -&gt; 뽑아오니 다시 int가되어있어서, int로 비교해야한다는 점 | . | . assertAll( () -&gt; assertThat(response.statusCode()).isEqualTo(HttpStatus.OK.value()), () -&gt; assertThat(response.body().jsonPath().getList(&quot;stations&quot;)) // 최단거리 1-2-3-4-5(50) &lt; 1-5 (55) .hasSize(5) // list의 size와 숫자 비교 (완료됨에도 이어서 list 검증을 chaining할 수 있음) .extracting(&quot;id&quot;, &quot;name&quot;) // list의 특정필드 비교 -&gt; 콤마를 통해 2개를 뽑아낼 수 도 있음. -&gt; 이 땐, t .containsExactly( tuple(1, &quot;강남역&quot;), tuple(2, &quot;잠실역&quot;), tuple(3, &quot;선릉역&quot;), tuple(4, &quot;사당역&quot;), tuple(5, &quot;신림역&quot;)) // contains -&gt; 일부 포함 (중복가능, 순서틀려도 가능) vs containsExactly -&gt; 순서+갯수 모두 일치해야하는 거의 equal ); . 일부 필드 제외 검사 usingRecursiveComparison().ignoringFields(“”) . entity(id필드 배정 전) -&gt; save -&gt; domain(id 배정후) -&gt; id를 제외한 필드를 비교해서 객체 생성 확인 . 그 전에는, id와 같은 기능을 하는 unique field를 꺼내와 검사함 | . @Test @DisplayName(&quot;노선을 저장한다.&quot;) void save() { //given final Line 이호선_그린_entity = new Line(&quot;2호선&quot;, &quot;green&quot;); //when final Line 이호선_그린_domain = lineDao.save(이호선_그린_entity); //then Assertions.assertThat(이호선_그린_domain).usingRecursiveComparison() .ignoringFields(&quot;id&quot;) // isEqualTo전에 객체에서 무시할 field를 지정 .isEqualTo(이호선_그린_entity); lineDao.deleteById(이호선_그린_domain.getId()); } . | 객체안에 비교하기 힘든 list필드 등을 제외하고 객체간 비교 . 다른 list까지 짬뽕된 reponseDto vs 예상값으로 핵심 필드(값)만 뽑은 reponseDto 비교 | . . | ENUM . 응답값인 상수Enum 객체 종류별로 정펙매 case Test -&gt; 혹은 정펙매로 찾은 Enum.추가로직() . @Test void rank_1() { final Rank rank = Rank.of(6, false); assertThat(rank).isEqualTo(Rank.RANK_1); } @Test void rank_2() { final Rank rank = Rank.of(5, true); assertThat(rank).isEqualTo(Rank.RANK_2); } @ParameterizedTest @CsvSource({&quot;5,false,RANK_3&quot;, &quot;4, false, RANK_4&quot;, &quot;3, false, RANK_5&quot;}) void rank_3_5(final int matchCount, final boolean matchBonus, final Rank expected) { final Rank rank = Rank.of(matchCount, matchBonus); assertThat(rank).isEqualTo(expected); } . 추가로직까지 더해진다면 | . @DisplayName(&quot;1등의 상금을 계산할 수 있다.&quot;) @Test void calculateFirstRankMoney() { final Rank first = Rank.FIRST; final long count = 3; assertThat(Rank.calculateMoney(first, count)).isEqualTo(6000000000L); } @DisplayName(&quot;2등의 상금을 계산할 수 있다.&quot;) @Test void calculateSecondRankMoney() { final Rank second = Rank.SECOND; final long count = 2; assertThat(Rank.calculateMoney(second, count)).isEqualTo(60000000L); } @DisplayName(&quot;3등의 상금을 계산할 수 있다.&quot;) @Test void calculateThirdRankMoney() { final Rank third = Rank.THIRD; final long count = 4; assertThat(Rank.calculateMoney(third, count)).isEqualTo(6000000L); } @DisplayName(&quot;4등의 상금을 계산할 수 있다.&quot;) @Test void calculateFourthRankMoney() { final Rank fourth = Rank.FOURTH; final long count = 2; assertThat(Rank.calculateMoney(fourth, count)).isEqualTo(100000); } @DisplayName(&quot;5등의 상금을 계산할 수 있다.&quot;) @Test void calculateFifthRankMoney() { final Rank fifth = Rank.FIFTH; final long count = 2; assertThat(Rank.calculateMoney(fifth, count)).isEqualTo(10000); } @DisplayName(&quot;맞은 갯수와 보너스 여부를 가지고 랭크를 반환할 수 있다.&quot;) @Nested class CalculateRank { @DisplayName(&quot;1등 반환&quot;) @Test void firstRank() { final Rank rank = Rank.calculateCurrentRank(6, false); assertThat(rank).isEqualTo(Rank.FIRST); } @DisplayName(&quot;2등 반환&quot;) @Test void secondRank() { final Rank rank = Rank.calculateCurrentRank(5, true); assertThat(rank).isEqualTo(Rank.SECOND); } @DisplayName(&quot;3등 반환&quot;) @Test void thirdRank() { final Rank rank = Rank.calculateCurrentRank(5, false); assertThat(rank).isEqualTo(Rank.THIRD); } @DisplayName(&quot;4등 반환&quot;) @Test void fourthRank() { final Rank rank = Rank.calculateCurrentRank(4, false); assertThat(rank).isEqualTo(Rank.FOURTH); } @DisplayName(&quot;5등 반환&quot;) @Test void fifthRank() { final Rank rank = Rank.calculateCurrentRank(3, false); assertThat(rank).isEqualTo(Rank.FIFTH); } @DisplayName(&quot;Nothing 반환&quot;) @Test void NothingRank() { final Rank rank = Rank.calculateCurrentRank(2, false); assertThat(rank).isEqualTo(Rank.NOT_THING); } } . 결과값 포장 (새응답) Map . [toMap로직의 생성자] &amp;&amp; getCountByKey( 객체key) 테스트 . Result( Enum Count Map ) 준비사항 | . public class LottoResult { private final Map&lt;Rank, Integer&gt; value; public LottoResult(final List&lt;Lotto&gt; lottos, final WinningLotto winningLotto) { this.value = lottos.stream() .collect(Collectors.groupingBy( lotto -&gt; match(lotto, winningLotto), Collectors.summingInt(count -&gt; 1))); } . 결과값 Map을 만들 재료 중 일부만 setup에 준비한다. 여러 재료라면 가변쉬운것을 테스트에서 -&gt; 많고 복잡한 것을 setup에 고정 . class LottoResultTest { List&lt;Lotto&gt; lottos; @BeforeEach void setUp() { //new LottoResult(lottos, winningLotto); //새로운 응답값 생성(결과값 포장 클래스 생성자)에 필요한 재료 먼저 선언 // -&gt; case별 변동이 쉬운 winningLotto는 놔두고, lottos를 미리 만들어놓자. lottos = List.of( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1, 2, 3, 4, 5, 7), new Lotto(1, 2, 3, 4, 7, 8), new Lotto(1, 2, 3, 7, 8, 9) ); } . | count Map이라면, 맘 편하게 .getCount( 객체key )를 맘편하게 만들자 . 뷰에서 쓸 일 있으면 쓰고, 없으면 삭제하면 된다. default를 0으로 해서 count인 value값을 가져오자. . public Integer getCountByRank(final Rank rank) { return value.getOrDefault(rank, 0); } . | . | 해당 key의 Count를 꺼내와서 정확한지 확인하기 . 할수 있다면, debug활용해서 내부값 까보면서 같이하면 될 듯. | . @Test void create() { //given -&gt; 1등이 1개 있도록 가정인자를 만들어줌 final LottoResult lottoResult = new LottoResult(lottos, new WinningLotto( new Lotto(1, 2, 3, 4, 5, 6), new LottoNumber(7) )); // map이 세고 있던 객체key를 넣어주고 -&gt; Count를 반환하는 메서드 개발 //when final Integer actual = lottoResult.getCountByRank(Rank.RANK_1); //then assertThat(actual).isEqualTo(1); } } . | [객체 응답]하는 메서드 Test . 추상체 변수로 받았어도 -&gt; 해당 구현체 객체 맞음 확인 .isInstanceOf( 특정객체의클래스.class) . @Test void blackjack() { // given &amp; when : hit final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); // then assertThat(state).isInstanceOf(Blackjack.class); } . 예외발생이 통과인 호출 -&gt; assert문내부에서 예외명시하며 호출 . 생성자 by assertThrows( 일레갈Argument익셉션.class, () -&gt; 메서드호출 ) . 메서드 by assertThrows( 일레갈State익셉션.class, () -&gt; 메서드호출 ) . @Test void blackjackDraw() { final Blackjack state = (Blackjack) Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); assertThrows(IllegalStateException.class, () -&gt; state.draw(Card.of(Suit.SPADES, Denomination.TEN))); } . 사용법 . StringTest . dependency . build.gradle에 assertj추가 -&gt; depenecies run or 우측에 gradle &gt; Reload All Gradle Project . testImplementation &#39;org.assertj:assertj-core:3.22.0&#39; . assertThat()메서드 사용안될 시 . import static org.assertj.core.api.Assertions.*; . | . | assertThat for 동일한지 검사 . given(data) -&gt; when(actual값) -&gt; then(expected넣어서 비교) 나눠서 코드를 짠다. . 배열 Test: .contains( ) or .containsExactly() + 콤마로 개별원소 입력 | . @Test void 숫자2개_분리() { //given String data = &quot;1,2&quot;; //when String[] actual = data.split(&quot;,&quot;); //then // assertThat(actual).contains(&quot;1&quot;, &quot;2&quot;); assertThat(actual).containsExactly(&quot;1&quot;, &quot;2&quot;); } @Test void 숫자1개_분리() { //given String data = &quot;1&quot;; //when String[] actual = data.split(&quot;,&quot;); //then // assertThat(actual).contains(&quot;1&quot;, &quot;2&quot;); assertThat(actual).containsExactly(&quot;1&quot;); } @Test void 괄호제거() { String data = &quot;(1,2)&quot;; String actual = data.substring(1, 4); assertThat(actual).isEqualTo(&quot;1,2&quot;); } . | contains, containsOnly, containsExactly . 참고블로그 | . contains: 순서틀려도, 중복해서 나열해도(갯수파괴해도) 포함만 되어있으면 통과 . containsvoid containsTest() { List&lt;Integer&gt; list = Arrays.asList(1, 2, 3); // Success: 모든 원소를 입력하지 않아도 성공 assertThat(list).contains(1, 2); // Success: 중복된 값이 있어도 포함만 되어 있으면 성공 assertThat(list).contains(1, 2, 2); // Success: 순서가 바뀌어도 값만 맞으면 성공 assertThat(list).contains(3, 2); // Fail: List 에 없는 값을 입력하면 실패 assertThat(list).contains(1, 2, 3, 4); . | containsOnly: 중복하더라도 순서는 틀려도, 중복 제외한 총 갯수가 일치해야 통과(contains가 아님) . /* * containsOnly 실패 케이스 * * assertThat(list).containsOnly(1, 2); -&gt; 원소 3 이 일치하지 않아서 실패 * assertThat(list).containsOnly(1, 2, 3, 4); -&gt; 원소 4 가 일치하지 않아서 실패 */ @Test void containsOnlyTest() { List&lt;Integer&gt; list = Arrays.asList(1, 2, 3); assertThat(list).containsOnly(1, 2, 3); assertThat(list).containsOnly(3, 2, 1); assertThat(list).containsOnly(1, 2, 3, 3); } . | containsExactly : 순서+갯수+중복불허 순서대로 모두 같아야 통과(contains가 아니라 일치) . /* * containsExactly 실패 케이스 * * assertThat(list).containsExactly(1, 2); -&gt; 원소 3 이 일치하지 않아서 * assertThat(list).containsExactly(3, 2, 1); -&gt; list 의 순서가 달라서 실패 * assertThat(list).containsExactly(1, 2, 3, 3); -&gt; list 에 중복된 원소가 있어서 실패 */ @Test void containsExactlyTest() { List&lt;Integer&gt; list = Arrays.asList(1, 2, 3); assertThat(list).containsExactly(1, 2, 3); } . | isSameAs . 메모리 주소까지 같은지 -&gt; 한번 생성했으면 캐싱된 것가져오는지 . @Test void create() { final LottoNumber lottoNumber = new LottoNumber(1); final LottoNumber lottoNumber2 = new LottoNumber(1); // isSameAs: 메모리 주소가 같은지, 오버라이딩된 VO도 같다고 안나옴. 더 엄격한 완전히 같은 객체일 때, True assertThat(lottoNumber).isSameAs(lottoNumber2); // false } @Test void create2() { final LottoNumber lottoNumber = LottoNumber.of(1); final LottoNumber lottoNumber2 = LottoNumber.of(1); // 정펙매를 이용한 [같은 객체 다시 부를 땐] 완전히 동일한 캐싱 객체 가져오기 assertThat(lottoNumber).isSameAs(lottoNumber2); // true } . | . assertThrows for 더 진행시 게임종료 . 지정한 에러가 나타나야 통과 . 여기선 에러메세지 등 확인은 없다. . | 예외발생시 통과하는 메서드호출을 테스트한다. . @Test void blackjackDraw() { final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); // 블랙잭상태에서 -&gt; 카드받는 메서드 호출시 예외발생하며 종료해야한다. assertThrows(IllegalStateException.class, () -&gt; state.draw(Card.of(Suit.SPADES, Denomination.TEN))); } . | . assertThatThrownBy . 지정한 에러가 나타나야 통과 . 에러 내는 테스트는 assertThatThrownBy( () -&gt; {} ).isinstanceof();에다가 예외이름.class를 인자로 줘서 해당 예외일때 통과된다. . **필요하다면, 해당에러 + 에러메세지까지 확인하기 위해 .hasMessageContaining( &quot;메세지&quot; );까지 체이닝한다. ** | . //원하는 에러을 안줬더니... 테스트 통과 못한다. @Test @DisplayName(&quot;문자열 인덱스 에러 테스트1&quot;) void 문자열_인덱스_테스트() { assertThatThrownBy(() -&gt; { &quot;abc&quot;.charAt(4); }).isInstanceOf(IllegalArgumentException.class); } // java.lang.AssertionError: // Expecting actual throwable to be an instance of: // java.lang.IllegalArgumentException // but was: // java.lang.StringIndexOutOfBoundsException: String index out of range: 4 @Test @DisplayName(&quot;문자열 인덱스 에러 테스트2&quot;) void 문자열_인덱스_테스트2() { assertThatThrownBy(() -&gt; { &quot;abc&quot;.charAt(4); }).isInstanceOf(StringIndexOutOfBoundsException.class); } . | assertThatThrownBy + hasMessageContaining . 해당 에러 + 해당 메세지까지 내어야 통과 . 도메인 생성자에 포함된 로직에서 메세지까지 같이 검사하자 | . @DisplayName(&quot;로또 번호가 유효하지 않는 경우 예외를 발생시킨다.&quot;) @ParameterizedTest @ValueSource(strings = {&quot;0&quot;, &quot;46&quot;, &quot;-1&quot;}) void input_lottoNumber_invalid(final String number) { assertThatThrownBy(() -&gt; new LottoNumber(number)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;로또 번호가 유효한 범위&quot;); } . | . 자동차경주 . assertDoesNotThrow . assertThatThrownBy와 달리 에러가 안나야 통과 . @ParameterizedTest @ValueSource(strings = {&quot;o&quot;, &quot;brown&quot;}) @DisplayName(&quot;1이상 5이하의 자동차 이름의 길이 확인&quot;) public void car_name_length_of_positive_name(String name) { assertDoesNotThrow(() -&gt; new Car(name)); } . | . assertThat().isNotNull(); . inputView에서 하는 null or Empty검사시 할 것 같다. | . final Car car = new Car(&quot;재성&quot;); assertThat(car).isNotNull(); . assertThat( service ).extracting(“내부 인스턴스 변수”) . service 내부에 존재하는 일급or객체List를 toDto로 가져오는 반면, VO나 단일 값 변수는 직접 가져와 객체-예상객체 / 값-예상값으로 비교할 수 있다. | . @Test void get_round() { racingService = new RacingService(carNames, 5); //when, then assertThat(racingService).extracting(&quot;round&quot;).isEqualTo(new Round(5)); } . 범위검사 . 값 1개: 랜던뽑기를 여러번 @RepeatedTest(100) + assertThat().isBetween(a,b) 랜덤응답의 범위 검사 . //사용할 객체 만들고 RandomNumberGenerator randomNumberGenerator; @BeforeEach void setUp() { randomNumberGenerator = new RandomNumberGenerator(); } //응답값의 범위 확인을 여러번 @RepeatedTest(100) void range_test() { assertThat(randomNumberGenerator.generate()).isBetween(0, 9); } . 랜덤값 List 원소들 : 매번범위 검사 : listIterator()를 만든 뒤, while( .hasNext() )동안 next()하면서, 체이닝으로 .크거나같(최소값 객체) .작거나같(최대값 객체) . @Test void Random_숫자범위_검사() { // 원래는 랜덤으로 차있는 list -&gt; iterator final ListIterator&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 44, 45).listIterator(); // 랜덤값들을 돌면서 검사 while (numbers.hasNext()) { assertThat(numbers.next()) .isGreaterThanOrEqualTo(1) .isLessThanOrEqualTo(20); } } . SetTest . @BeforeEach . 매번 초기화해야하는 변수는 Test안에서의 class &lt;빈&gt; 변수 + @BeforeEach로 정의한 setUp메소드에서 초기화 + 데이터삽입해준다. . public class SetTest { // [빈 변수] -&gt; 매 TEST마다 초기화+데이터 삽입을 반복해준다. private HashSet&lt;Integer&gt; numbers; @BeforeEach void setUp() { numbers = new HashSet&lt;&gt;(); numbers.add(1); numbers.add(1); numbers.add(2); numbers.add(3); } @Test void 사이즈_확인() { //given, when int size = numbers.size(); //then assertThat(size).isEqualTo(3); } } . | @ParameterizedTest for 여러case . @Test 대신 쓰려면 아래 의존성을 추가해야한다. // Assertions testImplementation &#39;org.assertj:assertj-core:3.22.0&#39; testImplementation &#39;org.junit.jupiter:junit-jupiter-params:5.4.2&#39; . | local varaible로 뽑힌 변수들을 ctrl+alt+p를 통해 테스트메서드의 인자로 올리면서 수행하면 된다. | CsvSource의 delimeter는 1개의 char기 때문에 &quot;:&quot;가 아닌 &#39;:&#39; 작은 따옴표를 활용한다. 알아서 변환되기 때문에 &quot;1L&quot;대신 &quot;1&quot;을 주면 파라미터 Long이 알아서 받아준다. | . | . @ValueSource: 인자 1개 변수 + expected 고정 . @ParameterizedTest로 중복해서 테스트할 필요없이, given으로 들어갈 메소드인자 or given + expected로 들어갈 메소드 인자들을 지정해서 여러 케이스를 테스트한다. . @ValueSource(ints = {1,2,3,4}) . 한가지 값만 뿌려줄 때 | . @ParameterizedTest @ValueSource(ints = {1,2,3,4}) public void set_contains(int number) { assertThat(numbers.contains(number)).isTrue(); } . | . @CsvSource: 인자 1개이상 변수 + expected 가변 -&gt; “arg1:arg2:expected”같이 주되 delimiter로 끊음 . @CsvSource(value = {“1:true”, “2:true”, “3:true”, “4:false”}, delimiter = ‘:’) . 여러가지 값 -&gt; 여러개의 인자로 뿌려 줄 때 | delimiter 옵션을 안쓰려면, 그냥 ,콤마로 데이터들을 구분해주면 된다. @CsvSource({“1:,true”, “2,true”, “3,true”, “4,false”}) | . | . @ParameterizedTest @CsvSource(value = {&quot;1:true&quot;, &quot;2:true&quot;, &quot;3:true&quot;, &quot;4:false&quot;}, delimiter = &#39;:&#39;) void set_contains2(int number, boolean expected) { assertEquals(numbers.contains(number), expected); } . | . @NullAndEmptySource . 테스트 메서드의 인자에다가 @어노테이션으로는 null을 넘길 수 없다. . @NullAndEmptySource를 달아주면, 인자에 1,2번째로 null과 emtpy가 전달된다. | 추가로 @ValueSouce를 주면 3번째 인자로 넘어간다. &quot;이 름&quot;를 주게 되면 blank까지 테스트가 된다. | . | . @ParameterizedTest @NullAndEmptySource @ValueSource(strings = {&quot;이 름&quot;}) void nullAndEmpty_or_blank(String name) { System.out.println(name); assertThatThrownBy(() -&gt; new Car(name)) .isInstanceOf(IllegalArgumentException.class); } . | . 로또 . .isSameAs : 캐싱된 객체는 식별자 감별 메서드로 확인한다. . @Test void of_정적팩토리메서리를_캐싱된_객체를_생성한다() { final LottoNumber actual = LottoNumber.of(5); final LottoNumber expected = LottoNumber.of(5); Assertions.assertThat(actual).isSameAs(expected); } . @MethodSource: 인자 list or 객체 or string으로 표현할 수 없는 인자 + expected 가변 . public static Stream&lt;Arguments&gt; provideOtherLottoAndExpected() { return Stream.of( Arguments.of(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;), 6), Arguments.of(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;7&quot;), 5), Arguments.of(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;7&quot;, &quot;8&quot;), 4), Arguments.of(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;), 3) ); } @ParameterizedTest @MethodSource(&quot;provideOtherLottoAndExpected&quot;) void compare_lotto_by_lotto(final List&lt;String&gt; otherLottoInput, final int matchedCount) { //given final Lotto lotto = Lotto.fromInput(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;)); final Lotto otherLotto = Lotto.fromInput(otherLottoInput); //when final int actual = lotto.compare(otherLotto); //then assertThat(actual).isEqualTo(matchedCount); } . 주로 일급 재료 1개에 대해서 비교할 &lt;&lt;여러&gt;&gt; 일급 case + expected를 테스트할 때 . //given final Lotto lotto = Lotto.fromInput(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;)); final Lotto otherLotto = Lotto.fromInput(otherLottoInput); . | @ParameterizedTest + @MethodSource 붙이면서 &quot;함수명&quot;을 string으로 적어준다. . 만약, expected의 case도 나누고 싶다면 함수를 2개를 제공하면 된다 . @MethodSource({ &quot;provideOther일급AndExpected1&quot;, &quot;provideOther일급AndExpected2&quot;}) . | . //1. 정해진 일급 1개에 대해서 vs &lt;비교에 들어갈&gt; others일급-정답의 비교가 필요한 순간에 MethodSource를 쓴다. //2. 쓰는 순간 &quot;provideOther일급And정답&quot; 메서드명만적어주고 -&gt; 생성 -&gt; 파라미터로 받아주자. @ParameterizedTest @MethodSource(&quot;provideOtherLottoAndExpected&quot;) . | 함수명을 주지 않고 @MethodSource만 붙인 상태에서 generate하면, 테스트메서드명과 동일한 명칭으로 생성된다. . . | string함수명에서 generate시키면 함수를 만들 수 있다. . 응답 형이 Stream&lt;Arguments&gt;가 자동으로 작성된다. | . //3. 메서드를 공짜로 만들면, 응답값이 자동으로 Stream&lt;Arguments&gt;다. public static Stream&lt;Arguments&gt; provideOtherLottoAndExpected() { . | return은 Stream으로 만들어줘야하니 method body를 return Stream.of( )형태로 일단 작성한다. . 테스트함수에 전달될 파라미터 갯수대로 Arguments.of( , , )에 순서대로 작성해준다. | . public static Stream&lt;Arguments&gt; provideOtherLottoAndExpected() { return Stream.of( Arguments.of(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;), 6), Arguments.of(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;7&quot;), 5), Arguments.of(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;7&quot;, &quot;8&quot;), 4), Arguments.of(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;), 3) ); } . | 테스트 함수에서 파라미터 정의를 위해, Arguments.of()에 들어간 인자들을 1개 복사해와서 변수추출로 작성하면 쉽다. . @ParameterizedTest @MethodSource(&quot;provideOtherLottoAndExpected&quot;) void compare_lotto_by_lotto(final List&lt;String&gt; otherLottoInput, final int matchedCount) { //Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;), 6 //final List&lt;String&gt; otherLottoInput = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;); //final int matchedCount = 6; //final List&lt;String&gt; otherLottoInput, final int matchedCount . | String표현불가 객체/list 등의 1개이상의 변수 파라미터를 actual에서 미리 빨간색으로 작성 -&gt; 파라미터 추출(ctrl+alt+P)로 파라미터를 채우면 쉽다 . . | 완성본 . @ParameterizedTest @MethodSource(&quot;provideOtherLottoAndExpected&quot;) void compare_lotto_by_lotto(final List&lt;String&gt; otherLottoInput, final int matchedCount) { //given final Lotto lotto = Lotto.fromInput(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;)); final Lotto otherLotto = Lotto.fromInput(otherLottoInput); //when final int actual = lotto.compare(otherLotto); //then assertThat(actual).isEqualTo(matchedCount); } . | 블랙잭 . .isInstanceof(특정.class) . 상황에 따라 여러종류의 객체가 응답될 수 있을 땐, Object형 변수로 받은 뒤, .isInstanceOf()를 통해 특정 클래스의 객체를 확인한다 | . java @Test void start_hit____2와5를_입력하면_hit상태를_응답한다() { // 카드 2 + 5 -&gt; hit상태의 객체 final Object actual = Game.start( Card.from(Suit.SPADES, Denomination.TWO), Card.from(Suit.SPADES, Denomination.FIVE) ); . assertThat(actual).isInstanceOf(Hit.class); } #### @Nested . setUp할 예시가 달라지는 경우 서로 다른 @BeforeEach를 가지게 할려고 기존 @beforeEach - setUp를 Nest클래스에 넣어주려고 사용한다. . 즉, 같은 상태값을 setup하는 경우만 묶어서 처리해준다. | . | @Nested 명시이후 @디플(&quot;&quot;)이후 ClassName이Test로 끝나야한다. . class GameResultTest { //1. 가변으로 셋업에서 초기화하는데 Dealer dealer = new Dealer(); Gambler gambler = new Gambler(&quot;돌범&quot;); CardDeck cardDeck; PlayingCard card1; PlayingCard card2; //3. @beforEach를 Nest에 넣어준다. @Nested @DisplayName(&quot;버스트가 없는 경우에 한하여&quot;) class GameResultWithoutBurstTest { @BeforeEach void setUp() { //given card1 = new PlayingCard(Suit.CLUBS, Denomination.FIVE); card2 = new PlayingCard(Suit.CLUBS, Denomination.SIX); Deque&lt;PlayingCard&gt; rawCardDeck = new ArrayDeque&lt;&gt;(); rawCardDeck.push(card1); rawCardDeck.push(card2); cardDeck = new CardDeck(() -&gt; rawCardDeck); } @DisplayName(&quot;카드 점수에 따라 승에 해당하는 객체를 반환하는지 확인한다.&quot;) @Test void win() { //given cardDeck.drawTo(dealer); // six to dealer cardDeck.drawTo(gambler); // five to gambler //when final GameResult result = GameResult.of(dealer, gambler); //then assertThat(result).isEqualTo(GameResult.WIN); } } //2. 갑자기 예시가 셋업데이터가 달라져야할 경우, @DisplayName(&quot;딜러가 버스트인 경우, 패배 결과 객체를 반환하는지 확인한다.&quot;) @Test void burst_dealer_lose() { //4. 원래 이후 새로운 예시도 -&gt; nest -&gt; 서로 다른 @beforeEach를 지정해서 사용해야한다. //given PlayingCard card = new PlayingCard(Suit.CLUBS, Denomination.KING); PlayingCard burst1 = new PlayingCard(Suit.HEARTS, Denomination.KING); PlayingCard burst2 = new PlayingCard(Suit.HEARTS, Denomination.JACK); PlayingCard burst3 = new PlayingCard(Suit.HEARTS, Denomination.QUEEN); Deque&lt;PlayingCard&gt; rawCardDeck = new ArrayDeque&lt;&gt;(); rawCardDeck.push(card); rawCardDeck.push(burst1); rawCardDeck.push(burst2); rawCardDeck.push(burst3); cardDeck = new CardDeck(() -&gt; rawCardDeck); cardDeck.drawTo(dealer); cardDeck.drawTo(dealer); cardDeck.drawTo(dealer); cardDeck.drawTo(gambler); //when final GameResult result = GameResult.of(dealer, gambler); //then assertThat(result).isEqualTo(GameResult.LOSE); } . | 그외 Assertj 메소드 모음 . isEqualTo(obj) obj 와 같다 . isNotEqualTo(obj) | obj 와 다르다 | . isEqualToIgnoringCase(str) | str 와 같다 (대소문자 무시) | . contains(str) | str 를 포함한다 | . containsIgnoringCase(str) | str 를 포함한다 (대소문자 무시) | . doesNotContain(str) | str 를 포함하지 않는다 | . startsWith(str) | str 로 시작한다 | . doesNotStartWith(str) | str 로 시작하지 않는다 | . endsWith(str) | str 로 끝난다 | . doesNotEndWith(str) | str 로 끝나지 않는다 | . matches(regex) | regex 정규식과 같다 | . doesNotMatch(regex) | regex 정규식과 같지 않다 | . isLowerCase(str) | str 은 소문자로 이루어져 있다 | . isUpperCase(str) | str 은 대문자로 이루어져 있다 | . isZero(n) | n 은 0 이다 | . isNotZero(n) | n 은 0 이 아니다 | . isOne(n) | n 은 1 이다 | . isPositive(n) | n 은 양수 이다 | . isNegative(n) | n 은 음수 이다 | . isNotPositive(n) | n 은 양수 또는 0 이다 | . isBetween(start, end) | start 와 end 사이의 값 이다 | . isStrictlyBetween(start, end) | start 와 end 사이의 값이 아니다 | . isCloseTo(n, within 또는 offset) | 주어진 within 또는 offset 에 가까운 값이다. | . isNotCloseTo(n, byLessThan 또는 offset) | 주어진 within 또는 offset 에 가까운 값이 아니다 | . isCloseTo(n, withinPercentage) | 주어진 백분율 내에서 주어진 숫자에 가깝다 | . isNotCloseTo(n, withinPercentage) | 주어진 백분율 내에서 주어진 숫자에 가깝지 않다 | . isTrue() | 참이다 | . isFalse() | 거짓이다 | . isNull() | null 값 이다 | . isNotNull() | null 값 아니다 | . isBlank() | 빈 값 이다 (공백 미포함) | . isNotBlank() | 빈 값 아니다 (공백 미포함) | . isEmpty() | 빈 값 이다 (공백 포함) | . isNotEmpty() | 빈 값 아니다 (공백 미포함) | . isNullOrEmpty() | null 값 이거나 빈 값 이다 (공백 포함) | . isLessThan(str) | str 보다 낮은 문자열 이다 (Ascii 코드) | . isIn(…obj) | 여러개의 obj 중 1개와 같다 | . isNotIn(…obj) | 여러개의 obj 와 모두 다르다 | . filteredOn(…) | list 필터 | . extracting(…) | list 프로퍼티 값 | . assertj string 예제 . assertThat(&quot;Hello, world! Nice to meet you.&quot;) // 주어진 &quot;Hello, world! Nice to meet you.&quot;라는 문자열은 .isNotEmpty() // 비어있지 않고 .contains(&quot;Nice&quot;) // &quot;Nice&quot;를 포함하고 .contains(&quot;world&quot;) // &quot;world&quot;도 포함하고 .doesNotContain(&quot;ZZZ&quot;) // &quot;ZZZ&quot;는 포함하지 않으며 .startsWith(&quot;Hell&quot;) // &quot;Hell&quot;로 시작하고 .endsWith(&quot;u.&quot;) // &quot;u.&quot;로 끝나며 .isEqualTo(&quot;Hello, world! Nice to meet you.&quot;); // &quot;Hello, world! Nice to meet you.&quot;과 일치합니다. . assertj number 예제 . assertThat(3.14d) // 주어진 3.14라는 숫자는 .isPositive() // 양수이고 .isGreaterThan(3) // 3보다 크며 .isLessThan(4) // 4보다 작습니다 .isEqualTo(3, offset(1d)) // 오프셋 1 기준으로 3과 같고 .isEqualTo(3.1, offset(0.1d)) // 오프셋 0.1 기준으로 3.1과 같으며 .isEqualTo(3.14); // 오프셋 없이는 3.14와 같습니다 .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/test/assertj/tdd/2022/06/29/assertj-test-example.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/test/assertj/tdd/2022/06/29/assertj-test-example.html",
            "date": " • Jun 29, 2022"
        }
        
    
  
    
        ,"post35": {
            "title": "Object) Theater 상호의존표 관계 정리",
            "content": "v1 (Ticket 단순구매) . v1 객체 상호의존표 . . | . theater_ticket.png . . theater_invitation.png . . theater_ticketoffice.png . . ticketoffice_ticket.png . . ticketoffice_seller.png . . ticketseller_ticket.png . . ticketseller_audience.png . . audience_invitation_ticket.png . . audience_theater.png . . audience_theater2.png . . v2 (Reservate 예매) . v2 객체 상호의존표 | . theater_movie_screening.png . . theater_movie_screening_2.png . . theater_ticketoffice.png . . theater_ticketoffice_2.png . . theater_customer.png . . customer_ticketseller.png . . ticketseller_ticketoffice.png . . ticketoffice_theater_screening.png . .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/relationship/2022/06/28/Object_Theater_diagram.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/relationship/2022/06/28/Object_Theater_diagram.html",
            "date": " • Jun 28, 2022"
        }
        
    
  
    
        ,"post36": {
            "title": "Object) [F2]Trigger Strategy to Factory",
            "content": "Trigger전략객체2의 로직을 위임된(주입되는) factory에게 위임하기 . 현재 DiscountPolicy in step5 시작는 2개의 전략객체를 받기(condition, trigger) + 주입(policy, action)받아 사용중 . 전략객체 Calculator를 구상Factory로 받아서 사용하며 | trigger전략객체 DiscountCondition은 외부에서 setter로 받고 -&gt; 내부에서 호출해서 사용한다. | . . . | trigger기능을 가진 condition전략객체를 위임된 Factory에서 받기+제공 책임을 위임해보자. . | . 사실상의 구상체들인 구상Factory들을 다시 strategy패키지로 이동했다. . 인터페이스는 전략인터페이스이나 전략객체 대신 구상Factory들이 주입됬었다. | . . | DiscountPolicy내에서 필드에 받아진 trigger전략객체들 -&gt; for문을 돌면서 trigger전략메서드를 사용하는 상태이므로 2번째 전략객체들 묶음을 getter로 제공하는 기능을 factory에 추가해야한다. . 받을 2번재 전략객체가 1개면, factory에서 생성 -&gt; 전략메서드까지 호출하는 메서드를 만들면 되는데, 현재는 사용처에 전략객체들 묶음을 먼저 제공해야 이후 전략메서드를 사용할 수 있는 상태기 때문에 . factory가 내수용 받기메서드로 받아놓을 전략객체 묶음을 제공하는 기능을 추상메서드로 가져햐아한다. | 기존: discountpolicy내에서 필드로 받아서 필드(보라색)으로 사용 | 수정: factory가 (내부에서 받아서) getter메서드로 제공 | . | 내부에서 보라색필드로 꺼내서 사용하는 로직을 옮긴다? . 로직이 옮겨간 곳에서는 getter로 제공해야한다. . | 로직이 옮겨간 곳에서는 필드의 변수형에 맞는 컬렉션으로 응답해줘야한다. . . | | Factory변수에서 생성해주면, 추상체인 Calculator에 추상메서드로 올라간다. . 1개 전략 인터페이스에 2개의 메서드가 정의된 상태로, 중간추상층의 추가가 요구 된다. | . . | . | 전략 인터페이스에 1개의 메서드만 갖으며 &amp; 최종구상체인 구상Factory들은 2가지 기능을 가지도록 중간추상층(2번째 전략객체의 인터페이스)를 추가한다 . 인터페이스를 extends하여 중간추상층 인터페이스를 만든다. . | 현재는 네이밍이 Calculator(전략객체) - AmountCalculatorFactory(구상Factory) 상태인데 . 중간 추상층은 trigger관련이므로 action + trigger의 의미를 다 담는 policy+Factory로 작성하고 1개 추상메서드를 위임한다. | . | . . | 최종구상층인 구상Factory들은 상위추상층이 아니라 중간추상층을 imple하여 2개의 추상메서드를 구상하도록 상태를 만든다. . . | 전략객체를 사용하는 DiscountPolicy에서는 2개를 구상하는 최종구상Factory를 포용할 수 있는 중간추상체인 PolicyFactory를 추상체 변수로 사용하도록 변경한다. . . . | 전략객체묶음을 제공하는 기능은 이관(안에서 필드 -&gt; factory.getter)되었으니 전략객체 묶음 받기를 이관해서 내수용으로 정의해줘야 제공getter도 정상작동한다 . 제공기능을 구현하는 곳인 구상Factory내에서 제공 기능을 작성하면서 필요한 재료들을 받기기능으로 구현하면 된다. . return 제공 변수(빨간색) | 내부에 가진 것을 응답하니 field | 내부에 field에 받기기능 1개를 객체생성과 동시에 받는다면 생성자주입 | 생성이후에 받는 것이라면, null초기화 필드에 setter 공짜로 생성 여러개를 받는 것이라면, null필드를 빈컬렉션으로 변경 | setter메서드의 이름을 addXXXX로 변경 + 인자를 객체1개로 변경 | | | . | 나머지 구상체들도 제공기능을 위한, 받기기능을 구현해준다. . . | . | DiscountPolicy에서는 위임된 전략객체 받는기능을 제거한다. . . | Main에서 policy적용을 위한 객체 생성시 . 기존 DiscountPolicy에 trigger전략객체인 Conditions를 추가 by 받기기능 | 변경 -&gt; Policy 전략 구상층인 구상Factory에 타 전략객체 condition을 추가 by 받기능 | . . . | factory에 getter로 인한, 전략객체 사용처(DiscountPolicy)의 디미터법칙 위반 확인 . . factory의 기능이 getter기능이라면, 전략객체 사용처에서 내에서 지역변수로 받거나 or getter.B()로 체이닝하거나 or getter를 for문으로 하나씩 돌릴 때, 응답을 받는 순간 의존성이 추가된다. but 의존성을 낮추려고 factory를 쓰는 것이다. 사실상 지역변수로 받거나 or 체이닝하거나 or for문에 돌릴 때, factory만 알아야할, 보호받아야할, 변하지 않는 [전략객체 사용처]가 의존성이 추가되므로 시켜서 = 위임해서 제거해야한다. | . | 구상Factory마다 모두 시키는 것이 적용되어야하므로 구상층 직전의 추상층이자 인터페이스 변수로 사용되는 PolicyFactory내부에 default 메서드로서 getter로직을 위임시켜야한다 getter로직을 위임할 땐, 기존 객체.getter()를 안으로 가지고 들어가 getter()으로서 사용하면서 .B()에 해당하는 메서드 내부에 다 포함시켜야한다 예를 들어 객체.getter().B() -&gt; 객체.B()로 변경 뒤, 내부에서는 getter()로 사용 | . | . | 전략객체를 내부에서 받아 사용하는 class는, 변화가 없고 의존성이 낮아야한다. | . | discountPolicy내부의 calculateFee()는 전략객체factory.calculateFee(fee)만 남기고, 전부 factory의 인터페이스 내부로 위임되어야한다. . F6으로 옮기면, 내부에 사용된 객체class 중 택1하면서 통째로 다 옮겨버리니, 옮기기 전에 복사해서 틀을 짜놓고 옮긴다. 응답메서드이므로 return factory.calculateFee(fee)를 남겨놓고 옮긴다. 이 때, 옮겨질 defatult 메서드를 활용하는 코드다. | default 메서드는 내부에서 구상factory들이 구현해야하는 2가지 전략메서드를 내부에서 사용한 method다. | . | 추상체이자 interface로 옮기면 자동으로 default메서드로 옮겨진다. | . | . . . 기존에 사용된 추상체.추상메서드()를 추상체 내부에선 상위추상층의 추상(전략)메서드를 그대로 내수용으로써 사용해도 deafult 메서드라면 괜찮은가보다. | discountPolicy의 context를 사용하지 않았는데, F6으로 따라온 파라미터를 제거한다. | . . 결과적으로 DiscountPolicy는 전략메서드2개를 내수용으로 사용하는 deafault메서드 1개를 호출해서 사용하게 된다. . . | 2개 이상의 전략메서드를 포함하는 추상체 변수에게 공통 로직을 위임할 때, 인터페이스의 default메소드로 위임되며, 내부에서는 내려받은 전략메서드를 내수용으로서 편하게 사용해서 정의된다. . | . . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/strategy/factory/2022/06/26/Object_strategy_plus_strategy.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/strategy/factory/2022/06/26/Object_strategy_plus_strategy.html",
            "date": " • Jun 26, 2022"
        }
        
    
  
    
        ,"post37": {
            "title": "Object) [F1]Strategy + Factory 패턴",
            "content": "실습1-전략패턴에 simplex Factory for 생성사용패턴 . 적용 직전 커밋코드 | . 전략객체를 사용하는 DiscountPolicy에게, 전략객체를 강제pushed(생성자를 통한 객체주입)하는게 아니라 전략객체Factory를 통해 원할 때 &amp;&amp; caching하며 생성하여 주입할 수 있도록 . Factory를 통해 원할 때 &amp; caching 적용하여 생성하는 것을 Lazy pulled라고 한다. | . 전략객체Factory 인터페이스를 만든다. . | 전략객체를 반환하는 오퍼레이터를 가진다. . | . | 전략Factory를 구현한 개별전략객체Factory를 구현한다. . 개별전략객체를 사용하고 싶은 곳(DiscountPolicy)에서는 전략객체 대신 전략Factory를 생성자주입한다. | . 전략Factory를 구현하고 | 전략객체getter에서는 cache(전략객체)가 적용된 생성을 위해 if (cache(전략객체) == null): cache라는 전략객체가 아직 생성안되었다면, new 전략객체()를 생성해서 할당해준다. private 전략형 cache; 변수는 애초에 null로 생성하는 것이 특징이다. | . | return cache : 전략객체가 들어갈 cache로 한다. | | 전략객체 생성 개별 구현에 필요한 Money amount는 필드로 추가해서 생성자에서 받아온다. 구현에 필요한 재료는 생성자에서 받아오기. | . | . . | 이제 전략객체를 pushed받던 DiscountPolicy가 전략Factory를 주입받아, 사용하던 곳에서 그 때 생성하는 Lazy pull을 사용하도 DiscountPolicy를 수정한다. . 생성자로 주입될 놈(CalculatorFactory)은 field를 미리 만들어놓는다. | 생성자에 파라미터를 추가해서 생성자 주입받는다. | 기존 전략객체 주입은 생성자에서 삭제한다(signature) | 기존 전략객체자리에 Factory를 통한 Lazypull된 것을 위치시킨다. Factory를 통해 생성하여 가져올 전략객체는 DiscountPolicy가 모르게 된다. Factory의 마법이다. | . | . . | 나머지 전략객체에 대한 구상Factory들을 생성해준다. . 영상에서는 Percent의 경우 synchronized 달아주는 것을 깜박함. | . . Nosale도 마찬가지 | . . | 실습2 - 위임된 Factory 적용 for Factory circulation . . 전략Factory에 존재하는 생성의 추상메서드 getCalculator를 추상메서드에서 제거하고, 전략객체의 전략메서드를 복사해서 위임받는다. . 생성 추상메서드를 단순제거하고 -&gt; 구상Factory들의 @Override만 지우고 + 내수용 private 메서드로 바꾼다 . 구상Factory의 생성책임이 생성용 추상메서드 개별구현이 아니라, 자기메서드가 되어버리며, public 전략메서드의 내수로 private으로 객체호출없는 메서드로 사용될 예정. | . | . . . 내수용 전략객체 생성메서드가 private으로 안바뀐 스샷임. | . | 각 구상Factory는 위임된Factory의 전략메서드를 구현하되 . 자신의 전략객체생성메서드(cache+원할때)를 사용해서 전략객체 생성 후 | 전략객체의 전략메서드를 호출하게 한다. | . . 이렇게 되면, Factory가 전략메서드 호출 -&gt; 내장된 구상Factory가 전략객체 생성메서드 호출 후 -&gt; 전략메서드 호출의 형태가 된다. | . | 전략Factory를 사용하다가 열차전복사고가 일어난 DiscountPolicy에서 Factor.전략메서드()호출으로 구상Factory내부메서드로 내장된 생성메서드를 생략할 수 있게 된다. . . | 위임된 전략Factory를 만들었더니, 전략인터페이스와 100%동일하다. . pushed 주입을 해결하기 위해 getter+캐슁해주는 Factory를 도입했다. | 열차전복을 해결하기 위해 Factory에는 전략메소드책임을 -&gt; 구상Factory에는 getter() 내수용 소유 -&gt; 전략메서드 구현시, getter()된 전략객체.전략메소드()호출해서 최종결과물을 반환해줘야한다. | 그랬더니 Factory는 전략인페와 완전히 동일한 놈이 되었다. -&gt; Factory자리에 전략인페로 교체함 | 전략Factory인터페이스를 삭제하고, 전략인터페이스를 imple하도록 한다. | . . . | 깨닮음: 전략인터페이스는 전략객체뿐만 아니라, 전략객체별 구상Factory를 구상할 수도 있다. . 구상Factory는 내부에서 caching하여 전략객체 생성메서드를 내수용으로 만들고, 전략메서드 구현시, 전략객체가 전략메서드를 호출하도록 한다. | . . | 전략Factory 주입후 사용처 DiscounPolicy는 . 전략객체 주입대신, 전략Factory를 주입했다가, 다시 전략객체를 주입(전략 인터페이스를 변수로 받는)하는 형태가 되었다. . 형태는 전략 인터페이스를 받아 전략객체를 주입하는 것 처럼 보이는 형태지만 . | 개별 전략객체의 구상Factory들 역시 전략인터페이의 구상체이며, 외부에서는 구상Factory를 실제로 주입한다. . | . | 전략인터페이스의 구상체가 전략객체가 뿐만 아니라 전략객체별 구상Factory도 같이 있다는 것을 생각해야한다. . 구상Factory의 전략메서드 구현내용에서 전략객체를 내부에서 생성하고, 전략메서드를 호출 | . | . | . . 주입되는 전략인터페이스의 변수명을 factory로 바꿔주기 . . | . | 생각해보기 . 위임된 전략Factory -&gt; 위임된 구상Factory -&gt; 전략Factory삭제의 과정에서 Factory circulation(회전풍차)가 사라지게 된다. . 기존 . | 위임된 후 추상Factory 삭제 . . | . | 보기에는 삼각형의 순환구조 같지만 . 생성된 전략객체는 구상Factory의 전략메서드 내용을 실질적으로 담당하기 때문에 순환표에서 구상Factory는 삭제하여 생각해도 된다. . . | . | . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/strategy/factory/2022/06/23/Object_strategy_add_factory.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/strategy/factory/2022/06/23/Object_strategy_add_factory.html",
            "date": " • Jun 23, 2022"
        }
        
    
  
    
        ,"post38": {
            "title": "Object) TemplateMethod to Strategy",
            "content": "전략패턴: 구상체 확장에 용이하다.(유연성). 템플릿메소드패턴에서 공통점이 없는 기능이 추가된다면 전략패턴으로 바꾼다. | 조합 -&gt; 전략객체들을 통해 서로다른 구현을 처리한다. 부모-자식들이 없이, 일반class-주입 전략객체 구성 | . | . | 템플릿메소드패턴: 중복코드를 제거한다. 전략패턴에서, 안정화되어 더이상 확장안된다면 템플릿메소드로 바꾼다. | 상속 -&gt; 자식클래스들을 통해 서로다른 구현을 처리한다. | . | . 전략패턴 핵심 요약 . 현재 상태: 추상클래스가 부모로 있고 + extends한 자식class에서 훅메서드만 구현(개별구현시 필요한 자신의 상태값을 같기도) . 종류별 개별구현을 위해 추상층 abstract class(부모)로 올라갔던 class(DiscountPolicy)를 일반 class로 낮추고 훅메서드 정의부를 삭제한다. . 공통로직은 일반class안에 template method로 그대로 소유할 것이다. | . . | | 개별구현을 상속한자식class의 명칭 + 훅메서드 구현으로 구현하던 것을 . 일반클래스 + 추상화된 명칭(DiscountPolicy)를 유지하되 | 개별구현의 전략객체의 전략메서드에서 할 예정이다. 전략객체들의 추상체 인터페이스를 (훅메서드명, 추상회된 메서드명) 전략메서드명를 바탕으로 -or을 붙여 만든다. 훅메서드명과 동일한 전략메서드명: caclulateFee() | 전략객체의 인터페이스명: Calculator | 개별 전략객체의 명: AmountCalculator, PercentCalculator 사용: new AmountCalcultor -&gt; Calculator.calculateFee() | . | . | | 공통로직을 담은 일반class DiscountPolicy는 훅메서드만 대신할 전략객체를 생성자에서 받아, 필드로 보유하고, 훅메서드 자리에 대신해서 전략객체.전략메서드()를 호출한다. . | 상속된 자식이, 개별구현을 위해 필드를 생성자로터 받아 사용 . -&gt; 전략객체들도 자기 생성자에서 받아서 쓰면 된다. . | 자식class나 전략객체들이나 구상체의 구조는 extends, impl빼고 완전히 동일하다. . 사실 훅메서드는 접근제한자 proected인데 public으로 오타인듯 . . | 사실, 추상클래스의 상속을, 프로토콜(약속)을 가진 인터페이스처럼 사용하고 있었던 것 . | . | 구조적 차이점 . 상속: 컴파일러가 알아서 2객체를 연결한다 | 합성: 직접 생성자를 통해 공급받아, 필드로 보유하면서 사용한다 | . | 현재코드(템플릿메소드 패턴) 설명 . 현재코드: 템플릿메소드 패턴으로 작성된 할인정책 . 추상체 . . public abstract class DiscountPolicy { private final Set&lt;DiscountCondition&gt; conditions = new HashSet&lt;&gt;(); public void addCondition(DiscountCondition discountCondition){ this.conditions.add(discountCondition); } public void copyCondition(DiscountPolicy discountPolicy){ discountPolicy.conditions.addAll(conditions); } public Money calculateFee(Screening screening, int count, Money fee){ for (final DiscountCondition condition : conditions) { if (condition.isSatisfiedBy(screening, count)) { return calculateFee(fee); } } return fee; } protected abstract Money calculateFee(final Money fee); } . | 구상체 중 1 AmountDiscount . 훅메서드 구현시 자식class에서 자신만의 상태값도 필요했다. | . . | 사용 in Movie . . | . | 실습 (템플릿메소드패턴 to 전략패턴) . 클래스 . 추상클래스: DiscountPolicy | 구상클래스: AmountPolicy, NosalePolicy, PercentPolicy step3 github 코드 | . | | 추상클래스를 일반class로 내리고, 추상메서드로 정의된 훅메서드도 삭제한다. . 훅메서드를 대신하여 그자리에 (소문자로)전략객체.전략메서드()를 작성한다 | 빨간줄로 전략객체 추상체를 field로 생성 전략객체명은 전략메서드명 + -or을 통해 생성한다. | . | 전략객체 인터페이스를 생성 이왕이면 전략객체명으로 package를 파서 한다? | 아니면 정책전략(DiscountStrategy?) | . | 필드에 적힌 전략객체 필드를 생성자로부터 외부에서 주입 | . | 템플릿메소드패턴의 구상체 &lt;-&gt; 전략객체 구상체 거의 유사하므로 . strategy 패키지를 만들어 옮긴 뒤 | 기존 추상클래스의 자식 구상체의 class명들을로 전략객체 명칭을 뒤쪽에 가지도록 바꾼다. AmountPolicy -&gt; AmountCalculator class명을 바꿀 땐 F2로 바꿔야지 다 적용된다.~! | . | . | 상속의 extends 추상클래스를 implements 전략인터페이스로 바꾼다. | 훅메서드 구현시 접근제한자였던 proected를 public으로 바꾼다. | . | Main에서는 . 기존 추상클래스DiscountPolicy 구상체 생성 -&gt; Calculator 전략객체 생성 | 전략객체를 생성자에서 인자로 받는 일반class DiscountPolicy 객체 생성 DiscountPolicy는 개별구상체를 안가지며, 대신 개별 전략객체를 주입받아 가진다. | . | 기존 policy구상체에 add condition -&gt; 일반 DiscountPolicy 객체에 add condition | Movie에 개별policy구상체 인자 -&gt; 전략객체를 머금은 discountPolicy객체 | . | 비교 . 서로다른 구현을 해주는 구상체 AmountCalculator vs AmountPolicy | . . 서로 다른 구현을 위해 좌: 전략객체 impl 전략인터페이스, hasA모델, compositio모델이 된다. | 우: 자식클래스 extends 추상클래스 | . | 전략패턴의 장점 . 의존성관계가 simple해진다. . 일반상속: 자식이 공통코드를 가진 부모를 앎 . . | 템플릿매소드패턴 상속: 부모가 자식의 추상메서드만 앎 . . | 전략패턴: 여러 전략객체들을 아는 전략인터페이스만, 1개 클래스가 앎 . . DiscountPolicy는 개별전략객체를 모른다. 상속이면, 최소 자식class들은 알아야했다. | . | 전략인터페이스가 중간추상층으로 끼어들어가, 외부공급개별 전략객체는 직접적으로 몰라도 된다. | 상속에 비해, 의존성이 1개 중간에 추가되었지만 각각이 다 1:1관계로 알고 있다. policy -&gt; calculator(추상체라 1) | AmountCaculator(N인데 시작점이라 1) -&gt; calculator | . | . | 무거웠던 부모의 역할을, 부모는일반클래스로 해방 + 전략객체 1개만 주입되어 더 가벼워진다. | 그러나, 중간에 전략인터페이스 자체를 바꾸는 것은 까다롭다. 개별구현을 원하는 DiscountPolicy도, 개별구현을 담당하는 전략객체들도 1개의 전략인터페이스를 바라보고 있기 때문 | 전략인터페이스가 무거워진다. | . | . | . | . | 전략패턴의 단점 . 처음에는, 확장가능성이 있으니, 템플릿메서드패턴의 상속을 쓰긴 어렵다. 처음에는 중간추상층으로 들어가는 전략패턴을 가지고 시작하여, 가운데서 각각이 의존하는 무거운 인터페이스로서 시작을 해야하지만, 수정시 여파은 존재한다. | . | 전략패턴의 추가 장점 . 전략인터페이스는 하나의 어댑터로 생각하고, 전략객체들을 바뀔 수 있다. . 전략객체들이 업데이트되어도, 업데이트 된 부분만 수정하고, 개별구현을 원하는 DiscountPolicy는 안변한다. | . | 어댑터로서, 외부의 변화에 대한 충격을, 사용처(DiscountPolicy)에게 안전해지게 흡수한다. . 그냥 꽂지않고 어댑터를 끼워 사용하면, 여러변화의 폭을 수용할 수 있다 . | 화살표를 받는 쪽 = 이용당하는 쪽 = 알고 있다 = 의존한다 = 다른 방향에서 오는 여러개의 화살표들을 먹어 충격을 흡수해준다 . . | . | 템플릿메소드패턴은 상속으로서 부모와 자식이 직접 통신하기 때문에, 방향을 역전시켜놓았어도 중간에서 여파의 충격을 흡수할 추상층이 없다. . | . | 만약 위(-Policy)/아래(-Calculator)로 변화가 심했다면? . 변화가 심한 쪽마다 인터페이스(중간추상층)로 충격을 흡수시켜야하므로 인터페이스끼리 대화하게 만든다. . . | . | 가운데 생기는 인터페이스는 충격을 흡수하는 어댑터이자 전략인터페이스이다. . 하지만, 개별구현 객체들을 다 감당해야하는 가운데가 무거워지는 관계. | 템플릿메서드패턴의 상속은 자식이 부모를 알고서 받아 사용하다가, 부모가 자식을 알고서 개별구현을 받아쓰므로, 가벼운 관계이다. 훅메서드만 알고있으면 되니, 무게가 가벼운 것들을 여러개 안다. | . | . | 다시 비교 템메(상속 역전): 여러 종류를 가진 class는 추상클래스로 바꾸고, 그것의 구상체를 사용하여 Type(형)을 만들고, runtime에 Type을 선택만 해주면 된다. new AmountDiscountPolicy()로 runtime시 선택하여 객체 생성 -&gt; amountDiscountPolicy.calculateFee()로 사용 runtime내에선 더이상 바꿀 수 없다? | 단순 포인터 1개 | . | 전략패턴: 여러 종류를 가질 class는 일반클래스로 유지하되, 중간추상층으로 의존성을 1개 늘려 runtime에 선택된 구상층을 합성하여 개별 구현함. new AmountCalculator() -&gt; Calculator -&gt; calculator.calculateFee() | Calculator자리에 다른 전략객체로 언제든지 바꿀 수 있다?? 포인터의 포인터 | . | . | . | . 각각의 단점 . . 템메: (아래층 생길 시 == 훅메서드 2개이상) 조합의 폭발 자식층이 점점 깊어지거나, 자식들이 병렬이 아닌 중첩구조인 경우 한 레벨 아래 여러개가 있는데 또 그아래 레벨이 생기는 경우 추상층 늘어난다 -&gt; 훅이 1개더 추가된다(기존 구상층은 중간추상층이 되어 1개를 가운데서 미리 구현하여 막아줌) | 훅(추상) 메서드가 2개다 -&gt; 자식이 2층이다. -&gt; 조합폭발이다. ex&gt; theater - step2의 DiscountCondition 중간 추상층(자식1층) with DiscountPolicy 훅메서드 calculateFee만 먼저 구현 | . | 최종 구상층(자식2층) 훅메서드 isSatisfiedBy 구현 | . | . | . | . | 부모Policy - 자식 3개의 Policy - 자식마다 2개씩 Policy 1 x 3 x 2 = 최소 6개의class | . | . | 경우의수만큼 계속 늘어난 class를 만들어야한다. | 그에 비해 전략패턴은? 외부에서 1개의 전략객체를 만들어 넣어주고, 필요하다면 바꿔서 넣어주면 된다. 전략객체를 만드는 것에 대해.. 생각안하고 있음.. | 전략객체는 미리 6개 class를 만들었다고 가정한다? | . | . | . | 전략: (전략메서드 2개 -&gt; 인터페이스를 2개)의존성 폭발 but 해결 가능 템매의 조합폭발(훅메서드 2개이상)은 못막는다. 훅메서드가 2개이상 들어갈 것 같다 싶으면, 전략패턴으로 구현하자. | . | 반면, hasA모델 = 합성 = 조합 = 전략패턴의 의존성 폭발은 해결가능 외부에서 들어오는 전략객체 2개의 다중합성 -&gt; 사용처 안에서 알아서 대화함. 형자체는 외부에서 결정되어 들어오므로 문제가 안될 것이다. | . | . | 구체적으로는 어떻게 해결할까? | . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/templatemethod/strategy/2022/06/22/Object_template_to_strategy.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/templatemethod/strategy/2022/06/22/Object_template_to_strategy.html",
            "date": " • Jun 22, 2022"
        }
        
    
  
    
        ,"post39": {
            "title": "Object)StrategyPattern for OCP(개발자의세계)",
            "content": "N개의 instanceof는 N개의 if -&gt; 1:N을 1:1로 만드는 전략패턴 준비와 적용 . 전략패턴 준비: if내에서 구상체들이 단독으로 하는 일을 찾아, 파라미터로 추출 후, 구상체내부로 옮겨주기 | 의존성 역전: 1:N : 일반class가 N개의 구상체를 알고 있는 관계 추상체로 받지만, 1:N관계라서, N개를 모두 다 확인하고, 개별로직을 수행한다. | . | 1:1: 추상체로 받고, 추상체에 시켜서 내부적으로 N개의 개별구현 구상체가 작동 후 1알아서 결과물을 제공하는 N관계가 1개의 전략(추상)메서드로 기능 제공하게 된 상태 추상체를 의존하는 것은 그대로이나, N개 구상체를 다운캐스팅해서 직접 까보지 않아도 되어, 1:1의 관계가 됨. 이것도 의존성 역전이라고 한다. | Director가 직접 N개 다 까보던 것 -&gt; Paper(추상체)가 전략메서드로 일을 하고 상황에 맞는 결과물을 반환해주는 일을 건네받음. 역할의 역전 | . | . | . | . 문제상황 . . Director는 Paper(추상체)에 대한 instanceof가 2개가 생겼다. . instanceof가 1개가 아니라면 제네릭으로 제거 불가다. 의존성 역전이 필요한 N개의 if로 봐야한다 | . | 의존성 역전을 하려면, Paper(N, 추상체에).시킨다( Director(1) )의 형태가 되어야하는데, . 추상층의 정보가 적어 한번에 일을 못시켜 if로 구상층들을 확인해야하는 OCP위반(부모형이 자식형들 대체를 못함)이 생긴다. 구상층의 정보들을 모아, 추상층에 올리기 위해 N개의if를 제거하는 전략패턴을 적용해야한다 구상층의 정보가 없다면? 구상층의 은닉화/역할책임 분배가 잘못된 것으로 구상층을 확인하고 사용하는 class내에서 -&gt; 구상층이 단독으로 사용되는 로직을 묶어 구상층 내로 가져와야 한다. | . | . | . | 추상체에 정보를 채울 구상체들의 공통로직+개별로직이 구상체 내부에도 없는 상황 . 각 if마다Director내에서 확인된 구상체들이 단독으로 하고 있는 일들을 구상체 내부로 일단 가져와야한다. . 단독으로 하는 일은, 구상체로 가져와도 서로 다를 인자가 안생겨, 전략메서드가 될 수 있다. . | 확인해보면, Paper의 구상체들 Client, ServerClient들은 getter/setter밖에 없다. 특별한 공통로직이 안보이는 상황 . . . | . | . | . | 적용순서 . if마다각각의 구상체가 현재Class내에 있지만, 단독으로 하는 일들을 살펴보고 메서드 추출 with 구상체만 필요한 인자 후 -&gt; 구상체 내부 public (예비전략)메서드로 옮긴다. . 구상체가 현재 속한 class(Director)정보 없이 단독으로 하는 일 -&gt; Director안에서 안 펼쳐져있어도 된다. 은닉화해서 내부로 들고와야 | 구상체만의 일을 찾아서 -&gt; 구상체내부로 넣어줘야 -&gt; 구상체들만의 공통로직을 추출할 수 있다. new 객체를 생성하는 일: 섭외한다고 표현하고, 의존하는 것이므로 Director와 무관하게 구상체가 단독으로 하는 일에 포함되는 일로서 다른 객체를 섭외(의존)할 수 있다. | 객체없는 private메서드 추출된 메서드(deploy) : 현class 정보를 사용해서 하는 일 -&gt; Director의 일이다. | . | 공통로직을 추출하는게 아니라 구상형들의 단독일을 찾아 올려 추상체.시킨다()할 통째로 1개의 메서드 추출 목적이므로 템플릿메소드 패턴은 생각하지 않고, 인터페이스의 전략메서드 1개로 만든다 전략메서드는 Director와 무관하게 인자 없이 정의되는 것이 좋으므로, 단독으로 하는일을 찾아서 -&gt; 추출후 -&gt; 추상체로 이동시킨다. | . | 단독으로 하는 일 정리 특정 Paper구상형를 아는 개발자(들)을 섭외 2개의 지역변수가 추출되는 순간 -&gt; 메서드 추출이 안된다. -&gt; 객체없는 private메서드로 생성 후 개별 로직 -&gt; 수동 이동 -&gt; 구상체만 필요해야하므로 구상체만 Parameter로 추출 -&gt; 구상체로 이동 | 가능하면, 먼저 1개의 변수 체이닝을 하는 if를 찾아가서 메서드 추출하고 해당 구상체로 move한 뒤, 복잡한 경우(2개이상 지역변수, 결과물 생성)하는 부분은 수동으로 처리하자 | . | Paper구상형에 개발자들을 set | 개발자들이 Paper구상형을 받아 Program(들) 생성 return 1개이상일 경우, new 형[]{ 1, 2}의 배열을 생성해서 반환한다 | . | Director가 Program(들)을 deploy | | 추출할 메서드명은 모든 구상체가 같아야할텐데, getProgram/makeProgram은 개발자들의 메서드라 되었기 때문에, 1~3의 과정을 (Paper의) generateProgram으로 하자. . 각 if마다 순차적으로 구상체단독일 추출 -&gt; 구상체로 이동을 반복해서 Move시켜준다. . | Client . . | ServerClient : 지역변수 2개 생성 체이닝 -&gt; 구상체만 사용하는 메소드의 자동추출이 안되므로 -&gt; 전략메서드와 동일한이름으로 메서드 생성 -&gt; 복붙 -&gt; 단독사용된 구상체만 파라미터로 추출 -&gt; Move시 파라미터의 사용된 구상체로 이동한다. . 예비 전략메서드들의 returnType을 1개이상 받을 수 있는 배열로 변환하여 통일하도록 구상체들을 Compare Files을 이용한다. | . . | . | . | 구상체 1개로 input/output이 통일된 예비전략메서드를 올린 뒤, 나머지 구상체들이 추상메서드를 구현하도록 수정한다 . . | Director내 if별로 존재하는 구상체들.예비전략메서드() -&gt; if를 제거후 추상체.전략메서드()로 변환한다. . . | | 전략패턴의 완성: 전략구상체들 역시 추상클래스화 -&gt; 분신술이 전략메서드 실시간 개별구현 . 이론 . 훅메서드 / 전략메서드는 추상메서드로서, if분기를 유발하던 로직이다. if분기마다 외부에서 구상class가 익명클래스로 class(java)파일 생성없이 생성될 수 있게 한다. . 객체지향 설계를 제대로 했다면 -&gt; if 유발 개별로직이 전략/훅메서드 -&gt; 구상class -&gt; abstract 화 -&gt; 익명클래스에서 구상하여 Main까지 밀려야 성공한 것 . if instanceof에 분기 선택으로 사용되던 Client, ServerClient도 class -&gt; abstract class된다. abstract만 달아줌으로써, Client, ServerClient의 본래 특징을 유지하되 &amp;&amp; if를 유발하는 수행방법(내부다른정보들 입력) -&gt; case에 따라서 외부에서 구현 &amp;&amp; 객체 생성(형 생성)해버리기 위해 | . | 그 전까지로만 밀렸다면, 어딘가에서 다운캐스팅 하고 있을 것이다 | . | Main까지 다 밀었으면 DI를 한다. . Main의 코드들을 싹다 일일히 만드는게 아니라 DI를 통해 주입하는 것으로 끝내야한다. | Main까지 다 밀어내야지만 DI가 정상작동한다. | . | 외부에서 익명클래스로 실시간 구현 &amp;&amp; case에 맞는 구상형 생성시 개별구현되는 전략메서드/훅메서드는 . 내부에서 분기문을 유발하던 곳에서 전략/훅메서드로 사용된다. | . . | . | 템플릿메소드 패턴의 Programmer의 구상층 FrontEnd와 BackEnd는 더이상 구상불가능한 하위도메인인 자신이 알아야하는 형이 많아져서 제네릭+추상클래스화를 통해 분신술마다 특정형알게+익클 분신술로 훅메서드 실시간 개별구현 case마다 훅메서드(들)의 개별구현을 외부에서 하도록 | (더이상 추가 하위구상층 만들기 불가한 자신class로) case마다 특정형 선택할 수 있게 | . | 전략패턴의 Paper의 구상층 Client, ServerClient는 분기를 유발하던 개별구현로직 전략메서드를 외부에서 필요에 따라 실시간 개별구현하도록 분신술 case마다 전략메서드의 개별구현을 외부에서 하도록 | 하위 구상층의 추가 가능성?? | . | . 적용 . 기존 구상체를 추상화(중간 추상층화)시키는 것은 먼저 작성한 generic관련 글에서 참고하자. | . 구상층을 abstract class화 . 익명클래스(분신술)이 생성과 동시에 여러형을 선택해서 알게하려면 제네릭 추가(여기선 X) | . . | 개별구현한 훅메서드(@Override+proected)/전략메서드(@Override+public)들을 새로운 구상층(익명클래스)에게 자동 양보하기 위해 . 로직 복사후 보존할 곳에 옮겨두기 . alt+F7로 객체로 생성되어 사용되던 곳에 붙여넣기 | . | 훅/전략메서드 삭제(해야 익클에서 imple가능) 후하여 새로운 구상층(익클-분신술)이 실시간 훅/전략메서드 외부 구현하는 곳에 implements하여 로직 양도 . Client . . | ServerClient . . | . | | 현재if분기를 유발하던 개별구현 훅메서드/전략메서드들이 구상체 추상화를 통해 Main에 익명클래스(구상체의 추상화된 classe들의 분신술) 실시간 구현 되도록 외부로 모두 밀렸다. . 이는 나중에 DI를 통해 코드를 수정할 수 있게 된다. | . . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98%EC%84%B8%EA%B3%84/strategy/ocp/2022/06/20/Object_stratge_pattern_for_OCP.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98%EC%84%B8%EA%B3%84/strategy/ocp/2022/06/20/Object_stratge_pattern_for_OCP.html",
            "date": " • Jun 20, 2022"
        }
        
    
  
    
        ,"post40": {
            "title": "Object)Generic for remove instanceof+@(개발자의세계)",
            "content": "추상층 + 제네릭 -&gt; 특정형을 아는 구상층을 만들어 1:1관계의 instanceof 제거 . 현재 Programmer의 구상체 FrontEnd, BackEnd의 개별구현 훅메서드(@Override, protected)들에서 추상체 Paper를 인자에 받았음에도 instanceof로 Paper의 구상체(Client, ServerClient)를 다운캐스팅해서 확인한다. | . instanceof 제거 전에 확인해야할 사항 . 추상체에게 각 구상체들을 물어보지말고 시키면 안되는가? 관계 확인하기 . Paper에게 알아서 하라고 this와 함께 시키면? | Paper : Programmer = 1: N관계 N(Programmer)이 1(Paper)을 받아 처리하는게 최적화된 상태로 현재 잘 맞는 상태다. | . | . | 제거할 instanceof 가 1개가 맞는가? . instanceof가 2개이상 사용되었다는 말은, 1에게 N을 넘겨주어서 일이 많아진 것이다. 1:N관계가 생긴 이유는, 1에게 N을 넘겨줘서 일이 복잡해진 것이다. | N에게 1을 넘기도록 바꿔야한다. (차후 Director - paper간 나옴) | . | 제네릭은 instanceof 1개만 가진상태에서 제거 가능하다. 추상층에는 T extends 타추상형 | 구상층이 T대신 1개의 타구상형만 알게할 수 있다. -&gt; instanceof 대신 구상형을 사용한다. | . | . . | 추상체를 왜 구상체로 다시 확인하는지 -&gt; 추상층 정보는 충분한가? . 추상체로 받았는데, 또 구상형으로 확인하는 이유는, 추상체에 정보가 작기 때문 확인해보니, 추상체에 공통로직으로 처리되는 템플릿메소드로 묶을 정보자체가 구상체들에게 존재하지 않는다. | . | . . | | 제네릭을 통해 각 구상층들이 instanceof 대신 추상형의 특정형을 미리 알게 하기 . 구조 추상층(Programmer) - &lt;T extends Paper&gt; 추상체 Paper를 받는 곳에서 추상체Paper 대신 -&gt; 메서드 인자(or변수)에 T형으로 받기 | . | 구상층들(BackEnd, FrontEnd) - T형 추상층 -&gt; 특정형 추상층으로 상속하여 T자리에 특정형을 사용하는 자식으로 태어나기 my) T형 추상층을 특정형으로 상속 -&gt; 특정형을 아는 구상class로 태어나기 | my) T형 추상클래스 -&gt; 자신class를 특정형을 아는 자신으로 분신술 (차후 나옴) | . | . | 적용 순서 . **구상층 1개에서 ** . 파마리터의 사용을 추상형(Paper) -&gt; 특정형(Client)으로 변경하여 특정형만 아는 구상층으로 만든다. . | 추상층에서 T extends Paper를 사용했다고 가정하고, 추상층(Programmer) 상속시 특정형 추상층인 Programmer&lt;Client&gt;을 상속한다 . | . . | **추상층은 구상층이 특정형을 사용할 수 있도록, ** . 사용 메서드를 추상형 파라미터(Paper) 를 T형으로 변경하고 | 기존 추상형의 구상층들로 제약 걸린 T형 파라미터 with &lt;T extends Paper&gt; 제네릭을 사용한다. | . . | 나머지 구상층(BackEnd)도 . 구상층에서는 특정형을 사용 + &lt;특정형&gt; 추상층을 상속 | (이미 되어있음)추상층에서는 T형 사용 + &lt;T extends 추상형&gt;제네릭을 달아주기 | . | | . | 구상층에 제네릭+추상클래스화 -&gt; 필요한 여러 특정형을 아는 자신의 개별구현분신술(익명클래스)을 만들어 1:N관계의 instanceof 제거 . 문제상황: . Client형을 아는 FrontEnd외에, ServerClient를 아는 FrontEnd도 필요하다. 특정형을 안다? -&gt; 개별구현로직이 다른 구상층이다. | . | 매번 구상class를 생성할 수 없으니, 제네릭 + 추상클래스화를 통해, 익명클래스로 분신술로 생성하면서 개별구현로직을 구현한다. | . . | 적용순서 in FrontEnd . 분신술(여러형을 알아야하는) 구상층(FrontEnd) class를 abstract class화 하여 추상층으로 만들고 . | 중간추상층이지만, 추상층으로서 제약걸린 T 제네릭을 걸어서, 구상층(익명클래스, 분신술)이 특정형을 알 수 있게한다. . | 상위 추상층(Programmer)의 특정형 추상층 상속되던 부분을 -&gt; T형 추상층으로 바꿔, 중간추상층인 FrontEnd가 T를 아는 구상층(중간추상층)이 되게 한다. . . | 구상층이 -&gt; 중간추상층이 되었으므로, 특정형마다 개별구현 로직 = 훅메서드 setData(@Override + protected)를 구상층이 구현하도록 사용처에 로직을 복붙 보존해놓고 추상층에서는 훅메서드를 삭제한다 . . | 기존에 구상층으로서 객체 생성하여 기능하던 곳에서 알 필요한 특정형마다 개별구현 분신술인 익명클래스를 구현해서 하나의 구상체로 사용 . 익명클래스는 일반 구상층이 상속한 extends 특정형 추상층상속 없이 바로 특정형 제네릭을 사용하여 implements로 훅메서드 개별 구현하기만 하면, 해당 특정형을 아는 구상층 익명클래스가 된다. 제네릭을 선택안하면 upperbound 추상형(Paper)를 아는 구상층이 되기 때문에, 제네릭을 정해줘야한다. | . | 익명클래스(추상클래스 구상층)에서 추상클래스내 필드를 안보이는 상태로 물려받기 때문에, 구상층에서 물려받은 필드 할당시 protected수준으로 만들어주기만 하면 편하게 자식이 사용해도 된다. | FrontEnd의 특정형을 아는 개별구현 분신술 만들기 | . . | BackEnd의 역시 여러특정형을 알 수 있는 훅메서드 개별구현 분신술을 만들어간다. . abstract 화+ 제약걸린 제네릭 + 상위추상층(제약T제네릭)을 T형 추상층으로 상속 | 추상형 파라미터 대신 T형으로 사용(분신술에서 특정형을 선택해서 앎) | 개별구현로직(훅메서드)를 삭제한 뒤, 분신술들이 개별 구현 | 추상클래스 필드를 자식이 사용시 proected로 사용 | | |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98%EC%84%B8%EA%B3%84/generic/instanceof/2022/06/19/Obejct_generic_for_remove_instanceof.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98%EC%84%B8%EA%B3%84/generic/instanceof/2022/06/19/Obejct_generic_for_remove_instanceof.html",
            "date": " • Jun 19, 2022"
        }
        
    
  
    
        ,"post41": {
            "title": "Object)TemplateMethod for DRY(개발자의세계)",
            "content": "구현체에서 템플릿메소드 패턴으로 추상클래스 만들기 . 맨땅에서 확인하기 . 카테고리로만 적용했던 마커인터페이스를 삭제한 상태이다 공통로직이 발견되었고, 개별구현 로직을 포함한 상태이다. | . | . 구현체에서 미리 템플릿메소드패턴으로 구성을 해놓아야한다. . 한번에 일 처리해줄(인터페이스 or 추상클래스) &amp;&amp; 자식은 물려받아 안보이면서 구현안해도 되는 public (템플릿)메소드 1개가 전체로직의 내부에서 개별구현로직인 private 훅메서드들(step메서드들을) 감싸고 있는 형태여야한다. | 구상체별 개별구현 될 로직(step메서드들, proteced abstact로 올라갈)들은 public 템플릿메소드 안에서 순서대로 private 훅메서드로 추출된 상태여야한다 private으로 추출된 메서드가 있어야, @Override로 superclass 추출할 때, abstract를 선택하고, 그 선택이 일반부모class 추출 -&gt; abstact class로 추출을 만든다. | 또한 그 훅메서드들(템플릿메소드안에 step들을 가지며 개별구현 될)은 메서드명이 통일되어있어야한다. | . | | 현재 코드 . BackEnd class와 FrontEnd class의 공통로직은 public 템플릿메소드 1개로, 개별구현 로직들은 private메소드로 만들어, Programmer라는 추상클래스로 추상화하고 싶다. . 백엔드 클래스 | . package developer.domain.progammer; public class BackEnd { private Server server; private Language language; public Program makeProgram(final Paper paper) { if (paper instanceof ServerClient) { final ServerClient pa = (ServerClient) paper; server = pa.getServer(); language = pa.getBackEndLanguage(); } return makeBackEndProgram(&quot;백엔드 프로그램&quot;); } private Program makeBackEndProgram(final String name) { return new Program(name); } } . 프론트엔드 클래스 | . package developer.domain.progammer; public class FrontEnd { private Language language; private Library library; public Program makeProgram(final Paper paper) { if (paper instanceof Client) { final Client pb = (Client) paper; language = pb.getLanguage(); library = pb.getLibrary(); } return makeFrontEndProgram(&quot;프론트 프로그램&quot;); } private Program makeFrontEndProgram(final String name) { return new Program(name); } } . | . | 구상체들을 템플릿형태로 변경해야할 부분 . 공통로직은 public 템플릿메소드 1개로 잘 나타나있다. . | 개별 구현로직은 . 서로 다르게 구현되는 if ~ return부분이 private 훅메서드(step메서드들)로 추출이 안되어있는 상태다. . // BackEnd.java if (paper instanceof ServerClient) { final ServerClient pa = (ServerClient) paper; server = pa.getServer(); language = pa.getBackEndLanguage(); } // FrontEnd.java if (paper instanceof Client) { final Client pb = (Client) paper; language = pb.getLanguage(); library = pb.getLibrary(); } . | 이미 추출된 훅메서드가 명칭이 통일이 안되어있는 상태이다. . // BackEnd.java return makeBackEndProgram(&quot;백엔드 프로그램&quot;); // FrontEnd.java return makeFrontEndProgram(&quot;프론트 프로그램&quot;); . | . | . | 변경해보기 . 이미 public 템플릿메소드가 존재하는 상황이다.(전체로직 &amp; 공통코드를 담는 public 메서드) . | 개별구현로직도 순서대로 이름이 통일된 private 훅메서드로 추출한다. . . | 구현체별로 이름이 다른 훅메서드들의 이름을 통일한다. . 추상클래스를 추출할 클래스에서만, 메서드명을 추상화해서 통일하고 | 나머지 구현체들은 그대로 두자. -&gt; 이미 동일한 메서드를 가지고 있으면, 자동implements가 인식안되서 직접 작성해줘야한다. 아래 영상에서는 FrontEnd의 메서드명도 수정하는데 그대로 두던지, 수정하고 주석처리해놓자. | . | . . | 1개의 구현체에서 템플릿메소드패턴을 적용한 추상클래스를 추출한다. . public 템플릿메소드를 추출하려고 하면, private메서드들이 빨간색 뜨는데, 이놈들을 abstract로 데려가면, 구상체별 개별구현 훅메서드가 된다. | . . | 나머지 구현체들은, 추상클래스를 상속한 뒤 . 공통로직을 담은 public템플릿메소드는 제거하여 추상클래스로부터 물려받아 쓴다. | 개별구현로직의 private훅메서드들은 주석처리해놓고 -&gt; implements해서 구현한 뒤 -&gt; 개별구현로직을 복붙하자. 메서드명이 추상메서드와 동일하면, implements에 안뜬다. | 메서드명이 추상메서드와 동일하게 그대로 두면, 접근제어자에만 빨간색떠서 직접 수정해줘야한다. | . | . | | Compare Files를 이용한 구상체클래스들 추상화 . Compare Files . **비슷한 파일 차이점 비교할 때 ** ex&gt; 구상체들의 공통로직(템플릿메소드) +개별로직(훅메서드로 추출) 만들어서 템플릿 메소드로 올릴 때 | . | 단축키 세팅 keymap &gt; compare file 검색 후 &gt; Ctrl+D로 지정 | . | . 템플릿 메소드 패턴 확인사항 . 모든 구상체에 대해 구조는 다 수정 . 구조 확인 . 공통 로직을 포함한 전체로직이 public 예비템플릿메소드 1개에 담길 것 . | 그 내부(1.)에서 개별로직들은 private 예비훅메서드들로 빠져있을 것 . 학습중 발견: private 예비훅메서드들은 개별구현시 달라질 인자는 소유하고 있으면 안됨. 훅메서드는 그 내부에서 달라지는 내용들을 개별구현한다. | . . | | 구조 확인 후 수정 . public 예비템플릿 메서드 내에 모든 로직이 담겨있느냐 private 메서드(내부에서 개별로직이 훅메서드로 빠진 것)는 보지말고, public 예비템플릿메서드 1개만 있고 모든 로직이 다 들어가도록하며, 없는 구상체는면 생성해서 넣어준다. | . | 템플릿내부 개별로직이 private 훅메서드로 빠져있느냐 달라서 highlight뜬 line들이 public 예비템플릿메서드 내에 보이면 안된다. | 템플릿메서드 내 hightlight(개별로직) -&gt; private 예비훅메서드로 추출해서 훅메서드안으로 보내야한다. 예비훅메서드의 명은 개별구상체들 다 쓸 것이니 추상화해서 추출해서 짓자. | . | . | . | 이름 확인만 . 템플릿메소드 이름이 추상화되어 동일하느냐 | 훅메서드 이름 역시 추상화되어 동일하느냐 | | | 올릴 구상체 1개만에 대해 추상화된 이름으로 수정 . public 예비 템플릿메서드 명와 내부 private 예비훅메서드명들을 모두 개별 구상체 통일 예정이므로 대표 구상체 1개는 추상화한 메서드명으로 수정해놓고 올리기 . 구상체들이 미리 이름을 통일시켜놓으면, implements 목록에 안보일 수 있다. 여기선 훅메서드와 템플릿메서드명이 겹쳐서 템플릿메소드명도 수정했다 | . | . . | . | 올릴 구상체 1개로 추상체를 만든다. . public메서드를 public 템플릿메소드로 올리려고 체크하면 . | private메서드들이 빨간색표시되며 abstract체크를 통해 protected abstract 메서드(훅메서드)로 올릴 수 있다. . public -&gt; 추상클래스에서 가져간다. (템플릿메소드 1개) | private -&gt; 구상클래스에서 개별구현한다. (개별구현 훅메서드들) | . . | . | 추상체가 만들어지면, 나머지 구상체들은 훅메서드들만 implements해서 개별로직으로 수정 . implements목록에 안보이더라도 public 템플릿메소드는 공통로직이라 구상체들은 안보인상태로 물려받아 사용 한다. . 구상체는 추상클래스를 상속한다 | 구상체의 public템플릿메소드는 삭제한다 | 구상체의 구현대상은 훅메서드들만 하면 된다. 만약 추상층의 prot abst훅메서드 &lt;-&gt; 구상층의 private메서드의 이름이 같아서 implements 목록에 안뜨면, 접근제어자를 protected로 수정해주면 된다. | . | 구상체는 외부에서 public 템플릿메소드만 사용하게 된다. | . . | . | 문제점 발견 . 템플릿메소드내 훅메서드들은 내부에서 공통으로 호출 -&gt; 외부에서 인자를 받지 않으면, 내부에서 주는 인자는 의미가 없다. -&gt; 템플릿메소드가 받는 인자가 아니면, 인자 없이 훅메서드를 만들자. 개별구현을 숨기는 객체없는 내부메서드일 뿐! . 개별구현하고 싶으면, 훅메서드의 호출 인자가 아니라, 훅메서드 내부에 개별구현에서 다른 값을 사용한다 | . . . | . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98%EC%84%B8%EA%B3%84/templatemethod/pattern/comparefiles/2022/06/18/Object_Template_method_pattern_1_dry.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98%EC%84%B8%EA%B3%84/templatemethod/pattern/comparefiles/2022/06/18/Object_Template_method_pattern_1_dry.html",
            "date": " • Jun 18, 2022"
        }
        
    
  
    
        ,"post42": {
            "title": "OBJECT 18 일관성 있는 설계협력과 rule객체를 통한 구간/범주별 처리",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . 설계의 일관성 . 14장의 내용은 학습비용이다 . | 설계의 일관성을 강조한다. . | 코드의 배치를 일관성 있게 했다. . 코드를 짜는 이유: 알고리즘을 만들기 위해 알고리즘: 어떤 문제를 변수와 제어를 통해서 순차적으로 해결해나가는 과정 | . | 설계: 알고리즘을 적절하게 배치하는 것 | 일관성 있는 설계: 알고리즘 여러갠데 배치는 비슷하게 만드는 것 | 서로 다른 알고리즘이지만, 1개의 함수에 담아버리면, 일관성 있게 된다. 둘다 함수에 감춰버리면, 바깥에서는 함수만 호출하는 똑같은 코드가 나온다. | . | . | 다양한 요금제에 대해 다양한 알고리즘으로 구현한다 . 하지만, 다양한 알고리즘은 calculateFee라는 인터페이스를 지키고 있다 지키고 있는데 뭐가 문제일까? | . | 각각 구현되어있는 구상클래스의 알고리즘이 제각각인 것이 문제라고 생각한다 안에 있는 클래스가 어떻게 짜여져있는지 왜 관심을 가져야할까? | 다르게 구현되어있어도 메서드의 시그니처를 인터페이스로 지키고 있어서 호출되는 모양은 같은데 | . | . | 왜 코드안에 있는 구현까지도 일관성 있게 해야할까? 그 이유는 학습비용 때문이다. . 다 공부하고 고쳐야하니 비용이 많이 든다. 개발 세계에서는 시간만 비용에 관여한다 | . | 고인물 효과가 일어난다. 회사에서 오래본 사람만 쉽게 잘만들고, 처음 들어온 사람은 출중할지라도 잘몰라서 비숙련자가 된다. 조직 전체에 대한 폐쇄효과가 나타나서 문제를 일으킨다. | 학습자체가 어려운게 아니라 학습하는데 시간을 많이 써야하기 때문에 비용이 증가한다 | . | 잘 안건들이려는 탄성이 생겨 그 부분을 폐쇄조치하고 격리하고 다른 것을 만들려고 한다. if로 막아버리고 작동은 하게 두되, 새로운 사람들은 다른 코드를 짜서 거기서 논다. | . | 제품의 수명이 짧아진다. 유지보수가 안되서 폐쇄되서 해마다 차세대 제품을 만든다. | . | . | 학습비용을 줄이는 방법은 설계일관성 밖이다. . 하나의 규칙을 가지고 있기 때문에, 전체를 이해하는 데 1개만 배우면 된다. | 학습비용이 늘어나지 않게 비슷한 형태의 설계로 반복해서 사용한다. 일관성: 어떤 context에서 지속되는 것 | 일반성: 아무 context에서 똑같이 사용할 수 있는 것 | . | 여러 상황에서 똑같이 사용할 수 있도록, 제네릭(일반성 있는)한 설계를 해야한다. 제네릭: 형에 상관없이 알고리즘에 사용할 수 있는 것 | . | . | 일반성 있게 짜면, 거꾸로 일반성에 대한 예외가 발생한다. . 일반성 있게 짜면, 적용범위가 줄어들고, 많은 기능들이 잃어버린다. +,-.x 기능은 정수라는 적용범위내에서 사용가능하지만, /기능은 적용범위에 대해 예외가 되어서 사용못하고 잃어버리는 기능이 된다. | . | 일반성의 도출은 case 수에 달려있다. | . | 우리가 해야할 것: 알고리즘들을 보고, 일반성을 추출해서 설계로 바꾸는 것이 목표 설계모듈간에 일반성을 추출하면 컴포넌트화가 된다. | 컴포넌트화간에 일반성을 추출하면 시스템화가 된다. | . | 책에서는 4가지 요금제별 새로나오는 요금제별 알고리즘을 각각 다르게 한 뒤 -&gt; 일반성을 획득 -&gt; 설계에 반영하는 예제가 나온다. | . 새로운 정책1: 시간대별 요금부과 정책(TimeOfDayCalc) 추가 . 시작커밋 | . 날짜구간 관련 DateTimeInterval객체를 구현한다. . 커밋 | . | 1번에 따른 Call을 재구현한다. . 커밋 | . | PricePerTimeCalc할인정책을 복사해서 TimeOfDayCalc를 만든다. . | 책에서는 4개의 list가 순서를 맞춰서 쌍으로 들어온다고 가정하고 이빨이 맞는지 검증 없이 사용하기만 한다. . 새벽0~아침11시, 아침11시~오후4시, 오후4~밤10시까지, 밤10시~밤12시까지 . | 우리가 이빨을 맞춰서 입력한다고 가정하는데, 검증없이 사람이 입력하도록 두면 당연히 이빨이 안맞는 4개의 list가 된다 . | . . | call속에 있는 날짜들DateTimeInterval list로 쪼갠 뒤, starts~ends에 대해 구간 vs 구간에서 시작 vs 시작 ~ 마지막 vs 마지막을 비교할 때 . 겹치는 시간이 존재한다면, 더 안쪽만 골라내면, 양 구간의 교집합으로 잡혀서, start~end구간내에서 걸리는 부분만 집어낼 수 있다. | 하지만, 겹치는 시간이 존재하지 않는다면, 더 안쪽만 골라내면, 크로스 안겹치는 구간이 잡힌다. 애초에 내가 넣어준 구간만 for문으로 돌아가므로, 넣어준 구간이 아닌 interval의 구간은, 계산도 하지 않는다. 내가 구간을 누락했다면, 추가적으로 interval중에 그부분만 빼서 base기본초당/기본요금으로 계산하도록 해야한다. | 하지만, 빠진 구간을 일일히 찾아서 처리하기 힘들다. | . | . | 하루 전체를 구간별로 쪼개서, 계산을 누적해나간다. 겹치는 구간이 아니라면, 해당 구간은basePrice, baseDuration으로 계산하도록 하는 로직이 빠져있다. | | 커밋 | 아래 그림에서 sum = sum.plus(tempResult)로 값객체 누적변수 sum에 재할당하는 부분이 빠졌음. 추가해야함. | . . | 하지만, 시간 구간에서 빠지는 놈들을 수거할 수있는 장치를 필드로 만들어놓는다. . 구간에 대한 예외를 처리하는 방법이다. | 필드명을 base를 붙여서 만든다. | . . | 왜 4개의 list로 짰을까?? index 0, 1, 2로 index로 묶여 이빨을 맞췄다고 생각해서 이렇게 l값context인 list로 짠 것이다. | 하지만, index로 묶여있다는 것은 코드로부터 알 수 없다 | 묶고싶은 것을 구조적으로 묶지않고, 암묵적으로 index로 묶일꺼야~라고 생각하고 있는 것이다. 이렇게 암묵적으로 묶으면, 일주일뒤에 짠 사람도 모른다. 코드를 보는 사람은 더더욱 모른다. | . | . | . list index로 암묵적인 묶음을 사용하지말고 형을 만들어서 구조체로 묶자. -&gt; 다음 정책에 반영 현재는 틀린 코드를 유지 . 교훈: list index로 암묵적으로 묶지말자. 묶음으로 가려면, 구조체로서 형으로 따로 만들어서 묶어야한다. | . 새로운 정책2: 요일별 요금부과 정책(DayOfWeekCalc) . DayPrice 행위하는 데이터 객체 생성 . 구상체용 데이터객체는, 구상체pacakge내부에 같이 넣고, internal로 접근제한자를 준다?! | DayOfWeekCalc에 사용될 모든 필드들을 모아서 만든 구조체 클래스(데이터 객체) DayOfWeekCalc는 TimeOfDayCalc처럼 index로 이빨맞춘 List필드들이 아니라 객체로 묶인 Set&lt;데이터객체&gt;을 알고 있으면 된다. | . | 책에서 요일당 요금은 1개만 . 화요일은 60초에 18원 1개 | 일요일은 60초에 12원 1개 변수도 price, duration 세트의 1개씩만 있으면, 요일별 n초당 가격1개씩을 인스턴스로 생성할 수 있다. | 나중에는 Set&lt;DayPrice&gt; = 형태로 여러개를 가지도록 사용된다. | . | . | 하지만 요일에 대해서는, 주중 vs 주말 여러개씩의 묶음으로 가지고 있어야, 들어오는 interval이 무슨요일인지 판단하기 편하기 때문에, 요일은 Set&lt;DayOfWeek&gt;으로 갖는다. . list로 하면 안된다. | . . | 객체지향에서 데이터객체라도, 데이터를 가지고 있는 이유는 행위를 하기 위해서이다. . 요일별 요금을 가져서 -&gt; 하나의 Call에 대해서는 스스로 계산을 할 줄 안다. . 기존 계산 구상체들의 계산메서드 시그니쳐를 복사해온다. | . . | Call은 여러 일에 걸쳐 이루어질 수 있기 때문에, call이 아닌 call이 가진 1일당 데이터인 DateTimeInterval을 받아야한다. . 책에서 하나의 call이 여러일에 걸쳐져있을 때는, 날짜별로 짤라서 start, end가 있는 interval이 나오며, 배열로 가져온다. | . | . | 요일별로 계산해주는 것이 DayOfWeekCalc전용 데이터객체 DayPrice의 목적이다. . 객체지향 세상이므로, 얘한테 물어보는 것이 아니라 스스로 행위를 한다. . | override와 proteced는 지우고, interval배열[]을 받는 시그니쳐로 변경한다. . . | . | . DayPrice를 이용하는 녀석 만들기 . PricePerTimeCalc를 복사해서 DayOfWeekCalc를 만든다. . | 필드라고는 Set&lt;DayPrice&gt; prices만 알면 된다. . . | 받은 calls를 돌면서 1개의 call은 날짜별로 intervals를 만드는데, 각 요일별 요금 Set을 돌리면서 . 개별 요일별요금DayPrice가 intervals를 받아, 각 interval이 어느요일에 해당하는지 확인되면, 계산해서 누적해서 반환해준다. | . . | list4개가 줄 지어서 있는 것에 대신에 도입한 데이터객체DayPrice에 훨씬 더 위임되어 있다. . 요일별 + 요금 Set필요 -&gt; 각 요일별 + 요금 = DayPrice 객체가 돌면서 요일별 요금 계산행위까지 다 처리한다. . | 즉, 요일별요금 계산행위 필요 -&gt; 요일별요금 객체를 만들고 요일별요금 계산행위정의(필요한 재료받아서) -&gt; 존재하는 요일만큼 요일별요금 객체를 컬렉션으로 보유 -&gt; 컬렉션을 돌리면서 요일별요금객체가 요일별요금 계산행위를 하게 함. . | . | . TimeOfDayCalc vs DayOfWeekCalc 비교해보기 . 난잡하게 list 4개를 가지고 -&gt; index로 암묵적으로 연결 | 미리 묶인, 데이터를 가진 형(데이터객체)를 만들고 -&gt; 행위까지 위임 | . 새로운 정책3: (통화)구간별 요금부과 정책 (DurationPriceCalc) . 통화를 10분만 했는데, 얼마일까? 구간 정책, duration정책 0~1분: 15원 | 1분~3분: 20원 | 3분~나머지: 30원 | 15분을 통화해도, 각 구간별로 다른 요금계산이 합쳐서 반환된다. | . | 시간대별 처럼, 구간별은 중간에 비는 구간이 생기는데, 이것은 어떻게 처리할까? . 62초부터 ~ 3분: 2초가 비게 된다. TimeOfWeekCalc에서는 basePrice, baseDuration 필드를 마련했다. | . | . | 애당초 구멍은 왜 생길까? . if를 넣어도, if도 사람이 짜는 것이기 때문에 구멍이 생긴다. . | 구멍의 근원은 start와 end 2개를 모두 같고 있기 때문이다. . . | 둘중에 하나만 가지면 구멍이 절대 생길 수 없다 . start를 없앴다면, 초기값으로 0초부터 시작하는데, end에 따라 구간만 나뉠뿐이지 구멍은 생기지 않는다. | baseDuration을 주면, 구멍을 근원적으로 막는 알고리즘으로 바꾼 것이다. 아무리 if를 걸어도 101번째에는 못막는 버그가 생긴다. | . | . | start, end를 포함한 list 4개 있는 코드는, 보는 순간 확정버그다 . start를 빼는 것이 정답이다. | . | . | 구간처리를 구멍안생기도록 연쇄되는 처리가 되도록 하려면, “얘 다음에는 얘가 처리할 거야. 얘 다음엔 얘가 처리할 거야”의 linked List처럼, 첫빠따는 얘가 먹고, 다음빠따는 연결된 노드가 처리하도록 짜야한다. . 빈틈이 없어지도록 다음타자를 가지게 하려면, 자료구조로 치면, LinkedList | 패턴으로 보면 데코레이터 패턴이, 다음타자가 다음처리를 하게 하는 것 데코레이터가 첫빠따를 받고, 다음 데코레이터한테 넘겨야한다. | . | . | . 데코레이터 객체(DurationPriceRule, 구간별 할인가격)를 만들어 빈틈없는 구간처리 하기 . 구간처리를 빈틈없이 처리하려면, cost는 start없는 다음타자를 가지는 데코레이터를 처리해줄 객체로서 1개만을 갖는 것이다. 데코레이터의 특징은, 처리할 구간에 대해 구간별 처리해줄 객체 1개만 가지면 되는 것이다. 데코레이터 객체 안에 나머지가 연결되어있고, 최종에는 마지막에 소유할 은 1개의 객체만 가지면 된다. | . | 데코레이터에는 prev를 연결하는 타입과 next를 연결하는 타입 2가지 종류가 있다. prev를 연결하는 것은, 생성자에서 이미 완성된 앞타자 prev를 받아서 넣으면 된고 next를 연결하는 것은, 생성자에서 다음 것을 생성해서 next자리에 넣어줘야한다. | . | 시간에 관한 것이므로, duration에 관한 것들은 무조건 뒤에다가 다음타자next를 연결해야한다. start없이. 왜냐면 우리는 세상의 끝을 모르기 때문 확실히 아는 값인 0을 기준으로 첫번째 duration 데코레이터 객체 등장 -&gt; 시간을 연결해준다. 중간에 시간을 0부터 3분까지, 5분까지, 10분까지 다음타자로 연결해주면 된다. | . | 이렇게 하면 빈틈이 안생긴다. | . | . | . 받와아야할 정보는 x초부터 ~ 내가원하는 초 까지 인데, 나는 from을 안가질 것이므로 0초부터 원하는 기간인to만 가지면 된다. . from(start)은 안가지고 자신이 처리할 수 있는 구간인 처음부터 end인 Duration to만 가지게 한다. | 해당구간의 가격 price를 가진다. | | 또한 현재 데코레이터객체는 이전 데코 객체값인 prev를 알고 있다. . . 최초에 데코레이터패턴을 소유할 DurationPriceCalc정책은 시간에 관련된 정책으로서 to가 0인 특이점 데코레이터 객체를 알고 있을 것이기 때문이다. 끝을 모르고 최초객체(시작)를 아는 데코레이터패턴은, 객체 소유클래스에서 시작객체 존재+ (다음타자한테는)prev(로 끼어주는 조합)으로 | 시작을 모르고 끝이 정해진 데코레이터패턴은, 객체 소유 클래스에서 시작생성 + next + null터미네이팅조합으로 생성자에서 끝날때까지 next의 새로운 데코객체를 넣어서 체이닝해줘야하고, 마지막에 null을 집어넣어 터미네이팅한다. | . | . | 새로운 타자를 prev로 끼워줘야한다. 반대로 이야기한다. | 최초의 것(데코객체, null or null객체)을 만들었기 때문에, 새로만든 것을 prev로 끼워넣어줘야한다. 다음타자는, 직전타자(시작타자)를 안고서 태어나야하므로 | 시작을 알아서 이미 확정된 데코객체가 존재하는 상황이라면, 확정된 객체에 next를 다시 추가할 순 없다. 다음객체에게 이미 확정된 객체를 prev로 추가해줘야한다. **next+null터미네이팅+생성자체이닝의 조합이 아니라 ** | . | . | . | 시간과 같이 end가 0인 최초 데코객체를 안고 태어나야한다면, 다음타자는 이미 만들어진 직전객체, null이 아닌 prev로 안고 태어나야한다. . 만약, 최초객체를 만들었는데, 그 객체의 next에다가 setter해주게 되는 것은 말이 안된다. . | 그에 비해 , 최초객체가 있으면, 다음타자는 null이 아닌 prev를 안고 태어나는 형태가 되어야한다. . . | 데코 레이터패턴의 행위시, 자신의 상태(price, to)로 처리하고, next or prev의 연쇄처리까지 해줘야하는데, 연쇄처리 행위에 있어서 특이점이 존재하며 null처리 or 특이점객체로 해결한다. . 바깥에서 체인 끊을 수 없기 때문에, 데코객체의 행위에서 터미네이팅을 해줘야한다. 만약 terminal코드를 없애줄려면, 그 형 객체(특이점 객체)를 따로 만들어줘야한다. | . | . | 최초데코객체를 가지는 구간처리의 경우, prev를 가져 전방으로 연결해시켜주며, 최초데코객체의 prev는 없으므로 null을 안고서 태어나도록 미리 정해놔야하며, 이 prev == null의 최초데코객체는 처리해야할 구간의 end가 0이므로, 초기값만 반환하고 끝내야한다. . . | 이제 나의 구간만 처리하도록 해야한다. . 애초에 직전타자prev의 상한선to보다 작거나 같으면, 내가 할일은 없다. | 이제 나의 시작점(prev.to)보다 큰 구간에 대해서 상한을 먼저 정해야, 내가 처리할 구간 prev.to ~ 상한만 골라낼 수 있다. 처리구간duration이 나의 상한 to보다 크면? to를 상한으로 | 처리구간duration이 나의 상한to보다 작으면?” duration을 상한으로 | | 이제 정해진 상한 - 하한(prev.to)을 잘라낸 뒤, getSeconds()로 몇초인지 변환하고, 부가할 요금을 반영한다 | . | . 01 DurationPriceCalc 정책을 만들고 최초시작 데코객체(특이점객체) 소유하기 . 데코객체를 이용해 구간처리해줄 구상체는, 구간 처리를 연결해서 해주는 데코객체 DurationPriceRule 필드를 1개만 속성으로 가지면 다 처리된다. . 시작이 정해져있는 시간등 구간처리의 prev로 연결되는 데코객체라면, 최초시작 데코객체 = 특이점객체를 소유해야한다. | 생성자 주입할 수도 있지만, [이미 정해져있는 것]은 내부에서 NULL객체 or 시작객체로 or [컬렉션으로 여러개 받는다면] 내부에서 빈컬렉션으로 필드초기화한다. | . . | 특이점 데코객체(최초시작 데코객체)는 자신의 생성자 시그니쳐를 복사해와서 그 정보들의 base정보(NULL객체, 초기값들)을 채워서 우리가 선택한 정보들로 초기화해서 가지고 있어야한다. . . base정보들을 가지고 있는 최초객체를, 다음타자의 prev로 추가해줄 예정이다. | 이 때, prev의 초기정보는 null으로서 이것이 특이점이다. 앞으로 연결하는 type은 prev자리에 제일 처음이 특이점 =null or 특이점객체을 넣어줘야한다. next로 연결한다면, next자리에 null을 넣어준다 | 진입점이기 때문에 어쩔수 없다, linkedlist는 다 똑같다. | . | . | . . . | 02 DurationPriceCalc 다음 데코객체를 만들어줄 정보(prev제외)를 외부에서 받아와 -&gt; prev를 저장하는 다음타자 생성 -&gt; 재할당으로 다음타자를 소유하도록 업데이트해주는 메서드 . 현재 데코객체의 필드는, 구간별요금price + 내가처리할구간duration + prev이므로, . 다음 타자를 받아들일 때는, prev를 제외한 필드들price + duration을 add받기기능으로 받아와야한다. | prev는 현재 데코객체 이용클래스(정책)이 소유하고 있는 상태다. 외부에서 받기기능은 public void로 받아온다. | . | . . | 다음 구간을 처리할 데코객체의 상한 to는 현재 소유데코객체 = 예비prev보다 구간이 더 커야지 의미가 있다. . . | 또한, 우리는 최초시작객체 = 구간끝이0인 객체 -&gt; 아무것도 구간처리 안할 때는 Money.ZERO의 NULL객체를 반환하고 있으므로 다음객체가 어떤일을 해야한다면, 구간별요금price는 [특이점객체의 반환값]인 Money.ZERO를 가지고 있을 수 없다로 설정해야한다. . 데코객체 내부에서는 최초객체라면, 구간to가 0이므로, 아무일도 안하여서 ZERO(NULL객체)를 반환했다. . . | 계산로직이 price * seconds인데, price가 zero가 되어버리면, 구간에 대한 계산값 자체가 zero가 되어버리니.. 아무일도 안하는 것과 마찬가지다? . . | . . | addRule은 다음 데코레이터객체를 생성해서 데코이용 정책클래스의 소유필드를 업데이트한다. . 이 때, 기존에 소유하고 있던 것을 다음 타자의 prev필드에 저장하고 | 생성한 다음타자를 소유하도록 재할당으로 업데이트한다. 기존 것은 다음것의 prev로 저장하고 -&gt; 다음것을 소유한다. | . | . . . 다음타자 데코객체를 만든다. prev는 현재소유한 데코객체인 rule을 집어넣어 만든다. -&gt; 데코객체이용클래스의 데코객체 변수는 값객체처럼 재할당이 운명이다. 동적으로 기능을 추가한 뒤 사용변수에 재할당해서 업데이트된 기능을 보유하게 한다. --&gt; 여기서는, 새로운 기능을 동적으로 추가하는 것이 아니라, 현재 소유 데코객체(prev)를 동적으로 다음타자로 업데이트한 것을 변수에 할당해준다. &gt; 동적으로 새로운 기능을 업데이트해주고, 그것만 호출하는 것이 아니라. prev(rule) 기능 사용 -&gt; [다음타자로 업데이트]addRule-&gt; [다음타자 사용]으로 사용 -&gt; 동적 업데이트 -&gt; 사용 -&gt; 동적 업데이트의 [실행기 분리후, 실행후 업데이트]를 가지는 것 같다 동적으로 소유객체를 prev속성으로 next객체로 업데이트하는 것도 데코레이터 패턴이다. 이 메서드에서는 나는 새로운 다음타자 rule만 만들어서 소유하면 된다. -&gt; 기존의 prev였던 rule은, 다음타자의 속성으로 들어가서 저장되어있을 것이기 때문이다. --&gt; 특이점데코객체(시작데코객체)를 소유했지만, 현재 메소드를 통해, [다음번 타자를 만들어서 필드로 소유] + [이전것은 속성으로 저장해놓기]의 형태가 반복된다. 맨 끝만 소유하게 될 것이고 -&gt; prev로 저장된 직전객체는, 소유객체 계산시 반복문을 통해 최초객체까지 불러오면서 계산시킬 것이다. 여기서 데코레이터는 메소드에서 직접 다음번 데코레이터를 부르진 않고, 단지 값을 계산할 때, 현재객체로 해당구간 처리후 prev를 불러 값을 처리한다. 왜냐면, 실행기가 따로 있기 때문이다. 실행기가 합쳐지면, next와 prev를 불러서 한꺼번에 취합을 할텐데, 이 경우, aggregate 객체로 분리해놓고 각각의 객체가 맡은 구간만 해결하도록 만들어놔서 -&gt; 나중에 한꺼번에 불러서 처리할테니, 현재는 다음타자만 가지고, 직전은 prev에 저장만 한다. 코드가 자유로워지면, (1) 데코레이터가 순환적인 재귀루프를 돌게 할 수도 있고 -&gt; 끝이 제한되는 경우, 스택오버플로우 위험 없을 때 *(2) 데코레이터를 재귀안돌리고, 자기일만 하고 빠져나오게 반복문을 돌린다.-&gt; 끝을 모르는 경우, 스택오버플로우 위험이 있을 때 데코레이터패턴도, *(1)loop로 처리하도록 실행기 메서드를 따로 빼고 -&gt; 메서드로 직전타자를 저장하며 다음타자로 업데이트하여 마지막타자만 소유하는 방법 (2) 데코레이터가 직접 다음루프로 가는 재귀의 방법 -&gt; 생성자에서 원하는 수만큼의 다음타자를 직접 생성하여 저장해놓고, 처음타자를 소유하되, 처리후 재귀로 다음타자를 부른다 -&gt; 만약, 데코레이터 타자들이 1000개가 넘는, 세밀한 구간처리 요금제를 만들었다고 가정하자 끝을 모르는..경우로서, addRule로 구간을 잘게쪼게해서 만들어넣을 수 있음. 다음타자를 재귀로호출하면, 스택오버플로우가 걸린다. --&gt; 기업코드들은, 모두 실행기를 불리해놓고 반복문으로 처리한다. . | . 03 DurationPriceCalc 소유한 rule처리 -&gt; prev 속 저장된 rule로 처리하도록, 소유된 마지막타자가 앞에 것들을 do-while문으로 순환하면서 call 속 duration구간을 나눠서 처리한다. . 현재의 소유한 마지막타자 rule를 시작점으로 do-&gt; 처리 + 처리자업데이트(prev를 처리자로) -&gt; while( 처리객체 != null)로 로직을 짜야한다. . 반복문속 처리자는 rule을 재할당하지말고, 반복문(dowhile)위에 지역변수를 만들고, 초기값으로 rule을 배정한 뒤, 업데이트 해준다. | . . rule -&gt; 반복마다 prev로 업데이트될 처리자는 target이라고 변수를 지어준다. | . . target처리자가, 현재 처리를 마치면, 저장한 prev를 꺼내서 그놈으로 업데이트시켜서 반복한다. 저장소 prev로 업데이트 시켰는데 그 target이 null이라면, 현재 최초객체이므로, 특이점 객체는 연산안하는 객체로서 종료되게 한다 | . | . . | 따로 외부실행기 + loop로 데코레이터객체를 전진시켰으니, 스택오버플로우에 안걸린다. | . | 데코레이터객체 본인이 재귀로 전진해도 되지만, 스택오버플로우에 걸릴 수도 있다. 반복문을 제거하고,return 문에 꼬리재귀형식으로target.calculate( )내부에 prev가 존재한다면, 재귀호출에서 전진해나가도 된다. | 그러나 안에 재귀를 두면, 망하는 경우가 많아 외부실행기 + loop로 분리한다. | . | . 새 정책 3개에서 추출할 수 있는 일관성(공통점)을 찾아볼 수 있을까? . 설계에서 공통점을 찾는 요령 . 설계: 객체간 협력모델 | . | 알고리즘에 휘둘리지말고, 각각의 요금제가 어떠한 협력모델을 가지고 있는지 살펴보자. . DurationPriceCalc이 할일은 calculate인데, 일을 직접하지 않고, 데이터를 가지고 구간별 처리해줄 외부에서 공급받은 데코레이터 객체와 협력해서 일을 처리하고 있다. 협력 객체(rule, 1개 같지만 n개)를 이용해서, 요금을 처리하는 객체라고 요약할 수 있다. | . | DayOfWeek도 협력 객체(prices, n개)를 이용해서, 내 할일을 처리하고 있다. | TimeOfDay도 n개의 start, ends, durations, prices 객체들을 이용해서, 내 할일을 처리하고 있다. | . | 각 요금제는 N개의 rule를 소유하고 있으며, 그것을 이용해서 계산하는 구조를 가진다. . 요금제는 껍데기인 것이고, 무슨 rule을 탑재하느냐에 따라서 요금제가 달라진다. 다른애들이 도와줘서 나의 일을 해줬어~ | 추상화를 이정도로 봐야한다. | . | . | 그렇다면, Calculator를 구상한 클래스를 새롭게 추가할 필요 없이, 협력객체공급 + 그 객체사용 코드만 새롭게 구상하면 된다는 사실을 알게 된다. . 3개의 역할을 도출했다. -&gt; 상속구조 or 소유모델로 만들 수 있다. 노예상은 다 똑같은 일들만 하고 있다. -&gt; 더이상 다형성을 가지지 않(더이상 자식X)으므로, Calc에게 직접 단일객체 합성으로 일을 위임하고, 필요가 없어진다. 상속이 전략객체로 바뀌는 과정과 같다. | **노예들 ListorSet을 가지게 한다. ** | . | 노예들: 종류별로 달라진다. | 프로듀서: 노예 종류별로 부리는 법이 달라진다. | . | . . 책들은 전부, 디자인패턴처럼, 상속을 합성으로 바꾸는 것이 목표이다. 상속은 조합폭발을 해결할 방법이 없기 때문 | 상속되어있는 자식들간에, 설계상 공통을 찾아서, 빼내게 되면, 소유모델로 바뀌게 된다. 상속의 자식들 -&gt; 더 세분화된 역할을 소유하는 객체로 일반화 | . | . | 여기서는 자식클래스들의 공통점(3개 역할의 일반화) 추출로 인해, Calc자식들을 삭제 3개의 객체(자식들)를 1개로 봐라보게 됨. | 역할들은 각각의 특성을 가진 객체로 나눔 노예 -&gt; 노예 인터페이스의 구상체로 감 | 부리는놈 -&gt; 프로듀서 인터페이스의 구상체로 감 코드는 어디 가지 않는다 | if의 제거방법은, 그 case만큼 객체를 만들고, 밖에서 주입하는 수 밖에 없다. | 2중if는 전략 인터페이스 2개를 만들어야한다. | . | | | 만든 class3개의 일반성을 획득하지 못한다면, 학습비용이 3배로 나간다. | 일반화에 성공했따면? new Calc()만 new때려서 만들고, 그 안에 노예, 프로듀서만 선택해서 넣어주면 된다. | | | . | 덩어리진 3개의 Calc구상체들을, 노예 + 프로듀서 + 일반화되어 상속할필요없는 Calc로 바꾼 바람에, 학습비용이 확 준다. . 역할을 통해 쪼개놨다면, 덩어리보다 더 학습비용이 났다. | . | . 상속의 자식들을 일반화해서, 템플릿메소드패턴의 추상클래스로 만들고, 전략패턴으로 바꾸자..?! . 자식들을 공통구조를 일반화해서 템플릿메소드로 올리는데 성공하면 전략패턴으로 변경가능해져서, 추상클래스가 전략주입 일반클래스가 되고, 덩어리졌던 훅메서드 자식클래스들은 전략메서드만 처리하는 전략객체가 되지만 | 이 경우, 전략메서드에 사용되는 협력객체또한 추가로 받아야한다.?? | . | .",
            "url": "blog.chojaeseong.com/object/2022/06/15/((object2-2)%EC%9D%BC%EA%B4%80%EC%84%B1_%EC%9E%88%EB%8A%94_%EC%84%A4%EA%B3%84_%ED%98%91%EB%A0%A5_rule%EA%B0%9D%EC%B2%B4%EB%A1%9C_%EA%B5%AC%EA%B0%84%EA%B3%BC%EB%B2%94%EC%A3%BC%EB%B3%84%EA%B2%BD%EC%9A%B0%EC%9D%98%EC%88%98_%EB%8F%8C%EB%A9%B4%EC%84%9C_%EC%B2%98%EB%A6%AC-%EB%B3%B5%EC%82%AC%EB%B3%B8.html",
            "relUrl": "/object/2022/06/15/((object2-2)%EC%9D%BC%EA%B4%80%EC%84%B1_%EC%9E%88%EB%8A%94_%EC%84%A4%EA%B3%84_%ED%98%91%EB%A0%A5_rule%EA%B0%9D%EC%B2%B4%EB%A1%9C_%EA%B5%AC%EA%B0%84%EA%B3%BC%EB%B2%94%EC%A3%BC%EB%B3%84%EA%B2%BD%EC%9A%B0%EC%9D%98%EC%88%98_%EB%8F%8C%EB%A9%B4%EC%84%9C_%EC%B2%98%EB%A6%AC-%EB%B3%B5%EC%82%AC%EB%B3%B8.html",
            "date": " • Jun 15, 2022"
        }
        
    
  
    
        ,"post43": {
            "title": "의연방14) 과제 정리",
            "content": "&#44284;&#51228; &#53580;&#51060;&#48660; &#44536;&#47532;&#45716; &#53596;&#54540;&#47551; . table template . &#49324;&#47581;&#47456;-direct age adjustment (&#44284;&#51228;1-2) . // Direct-age adjusted mortality rate table template // 안적혀있으면 인구수보고 대충 10만명당으로 k 계산 |나이별그룹||집단A|||집단B||표준집단|집단A|집단B| ||||||||||| ||인구수|사망자수|**k명당 사망률**|인구수|사망자수|**k명당 사망률**|인구수|**기대사망자수**|**기대사망자수**| |나이그룹a|l|d1|d1/l X k|l&#39;|d1&#39;|d1&#39;/l&#39; X k|l+l&#39;|k당사망률 X 표준인구 / k|k당사망률 X 표준인구 / k| |나이그룹b|m|d2|d2/m X k|m&#39;|d2&#39;|d2&#39;/m&#39; X k|m+m&#39;|위와 동일|위와 동일| |나이그룹c|n|d3|d3/n X k|m&#39;|d3&#39;|d3&#39;/n&#39; X k|n+n&#39;|위와 동일|위와 동일| |합계|l+m+n|||l&#39;+m&#39;+n&#39;|||(l+m+n)+(l&#39;+m&#39;+n&#39;)|계산 후 총합|계산 후 총합| . 각 집단별 / 나이그룹별 10만명당 사망률 계산 -&gt; 표 삽입 | 두 집단의 인구수를 더해서 표준집단 인구수 계산 -&gt; 표 삽입 | 각 집단별 / 나이그룹별 기대 사망자수 계산 -&gt; 표 삽입 | 각 집단별 기대사망자수 합 각 계산 -&gt; 표 삽입 | 각 집단별 총 사망자수 / 표준인구 총합 X 10만 = 각 집단별 10만명당 age -adjusted mortality rate 계산 | RR, OR (&#44284;&#51228;1-3&#48264;) . //노출여부그룹별 n수 + 질병환자수를 각각 줘서, risk를 a/n으로 계산할 경우 |노출여부| 전체n | 질병 O | (Absolute) risk | Odds| |||||| |흡연|n|a| a/n |r1/1-r1| |비흡연|m|b|b/n|r0/1-r0| //노출여부그룹별 risk를 바로주거나, risk소수점을 없애려고 x k 해놓은 경우 |노출여부| k명당 발생자수(risk에 k곱) | (Absolute) risk | Odds| ||||| |흡연|rr1| rr1 / k |r1 / 1-r1| |비흡연|rr0|rr0 / k|r2 / 1-r2| . &#44284;&#51228;1 . &#54400;&#51060; . 1&#48264; incidence&#50752; prevalence . a. 10만명당 1년간 결핵의 incidence rate = 30 . 1년간 새롭게 결핵이 발병한 환자 수 / 1년간 결핵에 노출된 인구 수 X 100,000 . = 54 / 180,000 X 100,000 . | . b. 10만명당 2010년 12월 31일 결핵의 prevalence rate = 200 . 12월 31일 결핵을 가진 모든 환자수 / 집단 내 모든 인구 X 100,00 = 306+54 / 180,000 X 100,000 | . 2&#48264; &#49324;&#47581;&#47456; . table-&#49324;&#47581;&#47456;-direct age adjustment (&#44284;&#51228;1-2) . // Direct-age adjusted mortality rate table template // 안적혀있으면 인구수보고 대충 10만명당으로 k 계산 |나이별그룹||집단A|||집단B||표준집단|집단A|집단B| ||||||||||| ||인구수|사망자수|**k명당 사망률**|인구수|사망자수|**k명당 사망률**|인구수|**기대사망자수**|**기대사망자수**| |나이그룹a|l|d1|d1/l X k|l&#39;|d1&#39;|d1&#39;/l&#39; X k|l+l&#39;|k당사망률 X 표준인구 / k|k당사망률 X 표준인구 / k| |나이그룹b|m|d2|d2/m X k|m&#39;|d2&#39;|d2&#39;/m&#39; X k|m+m&#39;|위와 동일|위와 동일| |나이그룹c|n|d3|d3/n X k|m&#39;|d3&#39;|d3&#39;/n&#39; X k|n+n&#39;|위와 동일|위와 동일| |합계|l+m+n|||l&#39;+m&#39;+n&#39;|||(l+m+n)+(l&#39;+m&#39;+n&#39;)|계산 후 총합|계산 후 총합| . 나이별그룹 A도시 B도시 표준집단 A도시 B도시 . | 인구수 | 사망자수 | 10만명당 사망률 | 인구수 | 사망자수 | 10만명당 사망률 | 인구수 | 기대사망자수 | 기대사망자수 | . 0~40 | 600,000 | 72 | 12 | 300,000 | 30 | 10 | 900,000 | 108 | 90 | . 40~60 | 400,000 | 520 | 130 | 400,000 | 480 | 120 | 800,000 | 1040 | 960 | . 60+ | 200,000 | 800 | 400 | 500,000 | 1900 | 380 | 700,000 | 2,800 | 2,660 | . 합계 | 1,200,000 | | | 1,200,000 | | | 2,400,000 | 3,948 | 3,710 | . 각 집단별 / 나이그룹별 10만명당 사망률 계산 -&gt; 표 삽입 | 두 집단의 인구수를 더해서 표준집단 인구수 계산 -&gt; 표 삽입 | 각 집단별 / 나이그룹별 기대 사망자수 계산 -&gt; 표 삽입 | 각 집단별 기대사망자수 합 각 계산 -&gt; 표 삽입 | 각 집단별 총 사망자수 / 표준인구 총합 X 10만 = 각 집단별 10만명당 age -adjusted mortality rate 계산 A도시의 10만명당 age -adjusted mortality rate : 3,948 / 2,400,000 X 100,000 = 164.5 | B도시의 10만명당 age -adjusted mortality rate : 3,710 / 2,400,000 X 100,000 = 154.58 | . | 2020년 사망률은 A도시가 더 높다 | . 3&#48264; Relative risk, Odds ratio . table2-RR, OR (&#44284;&#51228;1-3&#48264;) . //노출여부그룹별 n수 + 질병환자수를 각각 줘서, risk를 a/n으로 계산할 경우 |노출여부| 전체n | 질병 O | (Absolute) risk | Odds| |||||| |흡연|n|a| a/n |r1/1-r1| |비흡연|m|b|b/n|r0/1-r0| //노출여부그룹별 risk를 바로주거나, risk소수점을 없애려고 x k 해놓은 경우 |노출여부| k명당 발생자수(risk에 k곱) | (Absolute) risk | Odds| ||||| |흡연|rr1| rr1 / k |r1 / 1-r1| |비흡연|rr0|rr0 / k|r2 / 1-r2| . 위험요소 인구수 질병 O (Absolute) risk Odds . 비만 | 500 | 150 | 0.30 | 0.429 | . 정상 | 500 | 100 | 0.20 | 0.250 | . a. RR = 1.5 . b. odds ratio = 1.716 . &#44284;&#51228;2 . . &#54400;&#51060; . 1&#48264; &#50948;&#54744;&#50836;&#49548; 2&#44060; incidence rate without interaction . interaction이 없다면, model별 각 요소가 어떤질병에 끼친 효과의 변화량을 합 or 곱해주면 된다. a. 2 + 4(A에 의해 증가된 B가 어떤질병에 끼치는 효과) + 6(B에 의해 증가된 효과) = 12 | b. 2 x 3 x 4 = 24 | . | 2&#48264; Case-control study&#50640;&#49436; unmatched data OR . OR = ad/bc = 80x60 / 40x20 = 6 | . 3&#48264; Case-control study&#50640;&#49436; matched data OR . macchted case-control study에서 OR은 n12/n21과 같으므로 80 / 20 = 4 | . | . 4&#48264; cohort study &#45436;&#47928; &#48516;&#49437; . a. 연구질문 : 예상한 산전요인 혹은 산후요인들이 산후우울증에 영향을 주는가? . b. 산후우울증 . c. measure: OR . 산전요인 산전우울감: OR=5.19, 95% CI : 1.41-19.0 | 임신의도 점수가 1점 증가: OR=1.57, 95% CI : 1.09-2.27 | 사회적 지지 점수 1점 증가: OR=1.27, 95% CI : 1.06-1.53 | . | 산후요인 모성우울감: OR=4.22, 95% CI : 1.60-11.12 | . | . d. 결론 . OR이 가장 높게 측정된 산전우울감으로 미루어, 산전부터 산후우울증에 노출될 위험이 큰 집단을 선별하고 중재하여 산후우울증을 예방할 수 있기를 제언함. | . 5&#48264; RCT study &#45436;&#47928; &#48516;&#49437; . a. 심리적 지지가 고위험 임산부의 예상되는 주요 고위험출산 결과들에 영향을 주는가 . b. 저체중아출산 . c. 심리적지지 없이 일반적인 케어만 받는 임산부 . d. 결과변수가 이분형 변수들인데 비해, count와 proportion을 적절하게 제시하지 않았다. 효과 크기에 대한 검정결과를 카이제곱이나 회귀분석을 통해 적절한 검정결과를 보여주지 못했다. . &#44284;&#51228;3 . &#54400;&#51060; . 01&#48264; . 두가지 수술방법의 합병증 비율을 비교하는 임상시험을 하려고 한다. 수술방법 A는 15%의 환자에게 서 합병증이 발생할 것이고 수술방법 B는 5%의 환자에게서 합병증이 발생할 것으로 예상되는 상황 이라고 하자. 두 수술방법의 합병증 비율에 차이가 있다는 것을 유의수준 0.05에서 80% 파워(검정력) 으로 보이려면, 총 몇 명의 환자를 모집해야 하는가? (단, lost-to-follow up이나 결측은 고려하지 않는 다. 계산을 위한 R 코드와 출력결과를 답안에 포함한다.) . n = ? | α(유의수준) = 0.05 | β = 0.2 | p0 = 0.15 | p1 = 0.05 | . power.prop.test( p1 = 0.15, # 수술방법A p2 = 0.05, # 수술방법B sig.level = 0.05, power = 0.8, # b=0.2 alternative = &quot;two.sided&quot; ) Two-sample comparison of proportions power calculation n = 140.0951 p1 = 0.15 p2 = 0.05 sig.level = 0.05 power = 0.8 alternative = two.sided NOTE: n is number in *each* group . 총 280명이 필요하다 | . 02&#48264; . 두가지 수술방법의 합병증 비율을 비교하는 임상시험을 하려고 한다. 수술방법 A는 15%의 환자에게 서 합병증이 발생할 것이고 수술방법 B는 5%의 환자에게서 합병증이 발생할 것으로 예상되는 상황 이라고 하자. 두 수술방법의 합병증 비율에 차이가 있다는 것을 유의수준 0.05에서 80% 파워(검정력) 으로 보이려면, 총 몇 명의 환자를 모집해야 하는가? (단, lost-to-follow up이나 결측은 고려하지 않는 다. 계산을 위한 R 코드와 출력결과를 답안에 포함한다.) . n = 200 +200 | α(유의수준) = 0.05 | β = ? | p0 = 0.15 | p1 = 0.05 | . # sample size가 고정(n=400)된 경우, power 계산 power.prop.test( p1 = 0.45, p2 = 0.3, sig.level = 0.05, n = 400, alternative = &quot;two.sided&quot; ) Two-sample comparison of proportions power calculation n = 400 p1 = 0.45 p2 = 0.3 sig.level = 0.05 power = 0.9928852 alternative = two.sided NOTE: n is number in *each* group . power 99.3%를 가지고 유의수준 0.05에서 두 군간의 차이를 detect할 수 있다. | . 03&#48264; . Propensity score matching을 사용한 연구결과를 보고하는 논문 1편을 조사하여 다음에 답하시오. . a. 연구질문(research question)이 무엇인가? 한국인/연길거주 조선족의 체형은 체질별 체형에 여향을 주는가 | 논문 | . | . | b. 연구에 사용한 결과변수의 정의가 무엇인가? 체질별(태음인, 소음인, 태양인, 소양인) 체형 | . | c. 연구에서 비교한 그룹이 무엇인가? 한국인 vs 연길거주 조선족 | . | d. Propensity score 분석 방법을 사용한 이유가 무엇인가? 치료군과 대조군간의 confounding을 제거하여 RCT 같은 데이터를 만들기 위해서 | . | e. Propensity score를 어떤 방법으로 추정하였는가? - **matching의 방법을 사용함** . | f. 매칭된 데이터의 밸런스를 어떻게 평가하였는가? - **이분형 변수의 SMD를 활용하여 0.2 미만일 때, balance가 잘 맞는 것으로 판단함** . | g. 매칭 이후 분석은 매칭된 데이터라는 점을 반영하였는가? 반영하였다면 어떤 방법으로 반영하였는가? - **매칭된 데이터는 서로 독립이 아닌데, 이를 반영하기 위해서 `logistic regression with correlation structure (GEE)`**를 사용함 . | h. 연구의 결론이 무엇인가? 연길거주 조선족의 체질별 체형은 한국인과 유사하다 태음인 &gt; 소양인, 소음인 체질 순으로, 연길거주 조선족과 한국인 체형이 차이가 났지만, 거시적으로는 비슷하다. | . | . | . &#44284;&#51228;4(&#44592;&#47568;) . 메타분석의 결과를 보고하는 논문 1편을 조사하여 다음에 답하시오. . 링크 . | 연구질문(research question)이 무엇인가? PICOS 형식에 맞추어 답하시오. . P: 허리수술 후 급성 수술후 통증 환자 | I: 침치료 | C: 가짜 침치료 | O: visual analogue scale (VAS) | S: Randomized Controlled Trials | . | 문헌검색에 사용된 데이터베이스는 무엇인가? . pubmed | . | Risk of bias를 평가하였는가? yes | . | 결과를 요약하기 위해 사용한 요약통계량이 무엇이었는가? standard mean difference | . | 이질성을 평가하였는가? 평가하였다면, 어떤 방법으로 평가하였는가? using the chi-square test and the Higgins I2 test. | sub group analysis | . | Reporting bias를 평가하였는가? 평가하였다면, 어떤 방법으로 평가하였는가? Cochrane handbook에 의해 리뷰어2명이 평가했다고 나와있으나, 구체적인 방법은 명시되지 않음. | . | 민감도 분석을 수행하였는가? 수행하였다면, 내용과 결과를 요약하시오. no | . | 이 연구의 결론은 무엇인가? 수술 후 통증의 침 치료에 대한 결과는 수술 후 24시간의 통증 강도에 대한 VAS에서, 가짜 침술과 비교할 때 효과가 있다.(SMD -0.67(-1.04~-0.31), P=0.0003) | . | . | 본인이 관심있는 주제에 대하여 아래 질문에 따라 임상연구 계획을 세워 보시오. (관심있는 주제를 떠 올리기 어려울 경우 1강 강의록의 ‘Research Question’ 슬라이드에 있는 예제 중 하나를 이용하여도 좋다.) . 연구질문(research question)이 무엇인가? P: 허리수술 후 만성 통증 환자 | I: 도침 치료 | C: 가짜 도침치료 | O: VAS | S: Randomized Controlled Trials | . | 이 연구는 descriptive studies, analytic studies, clinical trials 중 어느 단계에 속하는가? descriptive studies - Meta-analysis | . | 이 연구의 주요 결과변수와 주요 독립변수(위험요소 또는 치료법)은 무엇인가? VAS - 도침치료 | . | 이 연구의 디자인은 무엇인가? (case-control, cross-sectional, cohort study, trial, meta analysis 등) meta analysis | . | 이 연구에서 발생할 것으로 우려되는 bias는 무엇인가? 대응책은 무엇인가? publising bias | 대응책 Trim-and-Fill method 사용 | Largest study anaysis | . | . | 이 연구에 작용할 것으로 우려되는 confounder는 무엇인가? 그것을 어떻게 다룰 것인가? 연령, 성별, 소득 수준 | 대응책 디자인 단계에서 랜덤화 | 데이터 분석단계에서 confounding 보정 Stratification or Adjustment or Propensity score analysis | . | . | . | (Extra credit) 이 연구에 알맞은 통계분석계획을 세워 보시오 요약통계량 선정 연속형 type의 outcome 사용 -&gt; MD로 선정 | VAS는 scale이 다를 수 있다 -&gt; SMD로 선정 | . | summary measure를 RR로 선정 | 통계모형을 fixed effect model로 선정 후, 이질성이 보이면 Random effec model로 변경 | sub group analysis 시행 | | publication bias 확인 funnel plot을 그려보고 확인 될 경우 | 대응책 Trim-and-Fill method 사용 | . | . | | . |",
            "url": "blog.chojaeseong.com/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EA%B3%BC%EC%A0%9C/2022/06/12/%EC%9D%98%EC%97%B0%EB%B0%A914)-%EA%B3%BC%EC%A0%9C-%EC%A0%95%EB%A6%AC.html",
            "relUrl": "/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EA%B3%BC%EC%A0%9C/2022/06/12/%EC%9D%98%EC%97%B0%EB%B0%A914)-%EA%B3%BC%EC%A0%9C-%EC%A0%95%EB%A6%AC.html",
            "date": " • Jun 12, 2022"
        }
        
    
  
    
        ,"post44": {
            "title": "OBJECT 17 정책적용 객체들의 계약관계",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ . | 참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ . | 책 12장은 range bind 개념으로 여기선 건너띈다. | 13장 contract와 관련된 개념을 다룬다. | . 계약에 의한 설계 . 계약은 짠 코드가 장난감인지 vs 제품인지 판가름하게 된다. 계약하지 않는 코드는, 돌아가게 스냅샷만 짜서, 장난감 코드가 대부분이다. | . | 단위테스트를 안걸어도 안정적인 코드를 짜려면?? 계약에 의한 프로그래밍으로 경우의 수가 없어야한다. | 경우의 수가 있는 코드들은, 그만큼만 커버해서, 다른 경우의수에 불안정하다 | . | . 계약의 조건 4가지 . . 객체지향의 세계에서는 메세지를 통해 계약한다. 메세지를 보내는 sender | 메세지를 받는 receiver사이에 더 상세한 내용이 계약으로 있다. 범위, 시간, 등 다 계약으로 정해놔야한다. | . | . | . 전달받은 메세지의 규격 = precondition을 지켜줘야한다. sender가 규격을 지켜서 보내진 않는다. | precondition검증은 receiver가 한다. | 우리는 receiver가 메세지를 전달받아 규격(precondition)을 검증하는 것을 기본정책으로 하고 있다. 안맞으면 안받는다. | . | 전달할 메세지의 규격(postcondition) receiver가 받아 검증했지만, 자기가 보낼 것도 receiver 안에서 검증해야한다. | receiver는 내 결과물을 상대방에 전달하기 전에 검증해야한다. | . | 객체 자신의 규격(class invariant) 객체는 원래 상태를 가지는데, 메세지를 받았을 때, 특정 필드값을 만족할 때만 제대로 메세지가 처리된다. | 메세지를 받기 이전에, 불변성invariant 검증이 되어있어야한다. 내 상태조건이 변하지 않도록 확정되어서 메세지 처리가 가능한지 검증 | . | . | 위임된 책임의 context 내가 하는 짓이 이 context가 맞는지 | . | 4가지 조건이 다 만족되어야 계약이 가능하다. | . 01 불변성(invariant) 검증 . . 메세지를 주고 받기 전에, (setter등으로 상태가 변화한다면 thr로) 객체 자신은 불변성 검증을 통해 불변성을 확보해야 메세지 처리가 가능하다 | 객체 초기상태, 객체 메세지 수신 전 상태가 확립되어야한다. 메세지와 무관한 객체의 상태는 필드값이다. 메세지는 인자값(pre) or 리턴값(post) or 지역변수들(post)로 이루어진다. | . | 필드값들을 제대로 갖고 있는지 상태 점검 해야한다 | 초기화 할당해서 확보 or DI로 위임해서 꽂아서 확보하던지 해야한다. 객체 초기화는 프로그래머 역량에 달려있어서 믿을 수 없다. solution, computer에게 DI로 맡기자 | . | . | . Plan . 기존 . . 하나의 요금제를 감당하고 있는 Plan은 set으로 calls통화기록를 받아서 가지고 있다. | 이 calls를, 전략주입 구상클래스에게 넘겨줘서 계산책임을 위임하고, 결과를 받는다. | private필드, final을 준수하고 있으니 확장가능(상속을 해줘도) 안전하다 | . | . 문제점과 해결(객체 필드 상태null -&gt; setter호출 이전에 빈값으로 초기화) . 주입받을 calculator필드는 초기값이 null이다. . setter를 호출하지 않았따면, calculateFee호출시 NP에러가 날 것이다. | 그러나 대외적인 인터페이스(class signature)를 보면, thr가 안달려있어서, 예외가 발생할 것이라 예상도 할 수 없다.(보고서 정상작동 하지 않을 것이라는 생각을 할 수도 없다) | Calculator 내부를 보면, 부분적인 계산체인을 위한 calcs라는 전략객체 컬렉션 필드를 소유하고 있고 | 위임받은 책임인 calcCallFee를 보면, calls는 한꺼번에 받고, 초기값을 받아서, 누적해서 결과물을 낸다. | 즉, 자신이 계산하는 것이 아니라, 자신 소유 전략객체들을 계산합으로 결과물을 내어준다. | | | calculator는 생성자에 받아야하는 조건이 없으므로 null초기화로 인해 없는 상태를 방지하기 위해서 객체를 미리 넣어주는 방법으로 안정성을 확보할 수 있다. . . 또한, calculateFee()의 calls 역시 미리 초기화된 상태라, 에러날 일이 없다 | . | 필드에 대해 유효한 초기화 방법은 필드 초기화 or 생성자로 할당하여 NULL대신 NULL을 대신할 수 있는 empty객체를 할당해주는 것이다. . | 02 사전조건(precondition) 검증 - 인자값 검증(전처리) . . 사전조건은 일반적으로 validation이라 부르며, 다른 언어들에서는 required라고도 부른다. 넘어가기전에 위에서 검증하고 가 | white list 이론: 38선을 경계로 위에서 방역/검증하고, 밑에서는 valdiation로직 없이 깨끗한 white list영역으로 취급한다. 모든 인자들이나 검증되지 않는 값들을 위에서 검증하여 white list를 만든 뒤, 로직을 전개한다. | if로 return으로 짤라버리는 쉴드패턴 | . | . | 메세지로 받는 값을 스스로 검증한다. | 내가 직접검증안하고, 형으로도 검증할 수 있다. VO Money가 대표적인 예. Money클래스를 브릿지로 써서, integer를 중간에 형을 더 만들어서 안정성/불변성을 확보하는 형태 | 검증때문에 한번더 감싸는 것 | . | . plan . . 문제점과 해결(인자null or 인자의 상태null -&gt; if로무시With불린flag토하기with기존값사용가능확인 or if thrWith메세지로통보) . java는 모든 객체형에 대해 null이 가능하므로 NULL인자로 호출가능한 메서드들의 인자로 넘어온 객체메세지를 null검사안하는 것이 맘에 안든다. . 제임스고슬링이 java에서 null을 만든 것을 실수라 한 것처럼, null은 모든 메서드의 시그니쳐를 무력화시킨다. null이 값이 없다는 것이 문제가 아니라, null이 만능키라서 문제 | . | | 첫번째 해결책: 언어나 컴파일러의 기능을 이용하여 인자에 @NonNull같은 어노테이션을 쓰자 . . 컴파일시, 컴파일러가 모든 코드를 조사해서 null이 생기면 컴파일에러로 거른다. 컴파일 때가 아닌, 런타임상에서 null이 아닌 실제 인스턴스가 들어갈 수 있으며, 컴파일러는 런타임시점을 모르므로 제한이 있다. | 다른 필드나 지역변수들은 null이 허용되기 때문에, @NonNull인자외에 다른변수들이 runtime시 null을 만들어서 인자에 null이 들어갈 수 있다. | . | typescript, swift, kotlin 등과 같이 애초에 null이 올수 없는 변수를 쓰는 경우에는 해결이 되는 방법이다. | . | 두번째 해결책: null이면 if로 무시 with 외부에서 알수 있는 boolean flag + 무시하고 기존값 써도되는지 확인 . null이면 if로 무시하고 해당로직은 슬그머니 넘어가되 최소한 boolean값으로 결과를 응답해준다. 우리가 많이 하는 선택지 | 나빠보이지만, 자바컬렉션들은 add나 put시 if로 슬그머니 null을 넘어가며, 넘어간 여부를 boolean으로 대답을 해준다. 그렇다면, void가 아니라 최소한 boolean형으로 return하도록 수정해야만한다. 외부에서 알수 있는 flag를 세워줘야한다. | 또한, if로 무시할 수 있는 상태 == 실패시 기본값(add시 빈컬렉션) 이미 존재하며 그대로 사용해도 되는 상태인지 확인도 해야한다. 실패해도 기본값이 이미 초기화되어있으며, 그 것을 사용해도 되는지 | 예를 들어, setCalculator에서 if로 무시해서, 기본calc를 사용하게 되는데, 요금이 250만원 넘게 나와버리면, 기본calc는 사용하면 안되는 상황이다. 이럴 경우, if로 무시하고 넘어가면 안된다. | . | 근데, boolean으로 응답해줬다면, 밖에서 기존값 쓰면 안되어서 따로 처리하게 될 것이다. | | | 세번째해결책: 예외로 처리 . if로무시하며 boolean flag하는 것보다 더 강력하게, null이면 예외메세지로 통보하고 있다. 참고로 if로무시하며 불린flag를 바깥에 토하는 것과 if thr로 멈추는 것둘다 runtime에서 조치할 수 있는 2가지 모든 것이다. | . | 한번 null에 대한 정책을 thr로 태웠으면, if무시with불린flag토하기는 더이상하지말고, 다른 로직도 모두 thr를 태우도록 통일해야한다. 어떤 것은 불린flag토하고, 어떤 것은 thr토하면 괴롭다 | 정책을 세우면, 통일해서 일관성을 만들어야한다. | . | | 사전조건 검증(null인자)에 대한 정책 3+1가지 정리 . 언어를 바꾸거나 애노테이션을 쓴다. . | if를 통해 불린flag를 리턴하거나 . | 명시적인 thr로 멈춘다. . 우리는 3번을 중심으로 한다. . | 모든 인자를 가진 함수에 다 써야한다. 그래서 인자가 많은 함수가 귀찮다. . | . | 객체 메세지라면, 객체의 사용될 상태 검사(null/empty) . . Calculator는 전략객체들을 컬렉션필드에 담고 있으므로, 컬렉션 필드가 비었으면, null이나 마찬가지인 놈으로서 해당필드 empty검사를 해줘야한다. | 객체는 자기자신에 대한 validation의 책임을 외부에 제공해야하므로 객체가 메세지로 사용된다면, 책임수행 중에 자기자신의 상태에 대한 validation책임도 늘어난다 validation때문에 main/client에서 보이지 않는 메서드들이 늘어나는 경우로서, 메세지로 들어가는 타class의 메서드 내부의 인자 사전조건 검사에 쓰이는 자기 상태검증용 메소드들이 늘어난다. | . | . | 03 사후조건(postcondition) 검증 - (받아온) 결과값 검증(후처리) . . 일반적으로 결과값 검증이라고 한다. 재고처리 시스템 등은 사후조건 검증을 빡빡하게 찬다. | . | 보내줄 값이 올바름을 검증한다. | return하는 형에 대해, 그 형을 만드냐 못만드냐로 검증을 미룰 수도 있음. | . plan . 문제점과 해결(결과값 검증 -&gt; 도메인의 영역이다.) . 사후검증 대상은 calculateFee()이다. . . 일반적으로 객체는 자기의 일을 직접수행하지 않고, 메세지를 통해 책임수행이 적합한 객체에게 위임해서 결과값을 받아온다. 받아온 결과값은 내가 한 것이 아니므로 반드시 검증한 뒤 반환한다 | 계산책임을 위임받은 calculator가 결과를 반환해주는데, 받아서 다른 데 반환하기 전에 다시, 내가 검증을 해야하는데 사후조건 검증은 로직이 아니라 도메인의 영역이다. Money를 반환할 예정인데, 0원이나 음수를 보내줘도 되는지 확인 -&gt; call이 있다면 0원이하일 수 없다. | . | 위임해서 받아온 값은 반환하기 전에 내가 검증한다. . 계산재료인 call이 없었으면 모르겠는데, call이 있는데도 불구하고 &amp;&amp; 돈이 0원이나 음수가 되면 thr . | 도메인지식을 if에 올려 죽여버린다 . | . . | . | . 계약별 책임할당 . Plan이 현재 모든 계약조건을 다 검증하고 있다. | 하지만 Plan은 Calculator에게 계산책임은 위임한 상태이므로 같이 일하고 있는데, 모든 계약조건을 Plan이 다 검증해야할까? | . 사전계약조건 책임할당 . 인자로 넘어왔을 때, 인자가 null인지 체크하는데, 인자의 상태체크는 물어보지말고 스스로 죽도록 위임할 수 있음. | . precondition1) 자신의 상태null, 인자null체크는 상대방에게 위임할 수 없다. . 참고로, 인텔리제이는 precondition으로 인자 null체크를 넣어둔 메서드에 대해, null을 넣으면, 코드힌트에서 알려준다. . . | . precondition2) 인자의 상태null/emtpy체크는? 해당 객체인자가 자신상태validation메소드를 제공해주는데? . . . isEmpty()는 간접적으로 내장을 까는 메소드. &lt;물어보고 행동하면, 변화(시)의 여파가 찾아온다. 검증도 스스로 죽어라고 시킨다(위임)&gt; . 간접적으로 내 안의 컬렉션필드의 size를 알려주는 코드라서 getter나 마찬가지다. . 메소드가 캡슐화하는데 실패한 코드다 . . if로 물어보고 어떤 행동을 했기 때문이다. | 물어보고 check를 시켜서 스스로 thr로 죽여야한다. | . | . | my) 인자로 넘어온 특정 객체에 대한 상태검사는 내가 하지말고 시켜서 스스로 죽게 만들자 . 자신에 대한 검증메소드가 추가될 때, 스스로 죽도록 하는 메소드로 만들 것 | . . 각 객체의 상태검증은 본인이 하도록 위임해서 스스로 죽게하고 나는 호출만 한다. 객체도 구조가 바뀌면 다 바뀔텐데, 니가 알아서 검증하고 스스로 죽고 오세요. | . | . | . if로무시with불린Flag보다 thr로 멈추게하면 좋은 점 . 만약 if로무시했다면 불린flag를 받아서 내가 thr를 처리해줘얗나다. | thr로 처리했다면, 스스로 죽게 검증을 완벽하게 위임할 수 있다. | . 사후계약조건 책임할당 . postcondition1) this가 필요없는 결과값 검증(this조차 받아가는 객체)은, 결과계산 위임객체에게 계산후 검증도 위임한다. . . 객체는 적합한 객체에게 책임을 위임하고 결과값을 받아오며, 그 결과값을 반환하기 전에 내가 직접 검증해야한다고 했다. . | 하지만, 메소드 내부에서 결과값(result) 검증 로직을 보면 Plan 자신의 의존성(this)이 존재하질 않아, plan이 검사할 이유가 1개도 없다 . this가 존재하는지 유무는 보라색 변수를 확인하면 되는데, 사용되는 보라색 변수는 calls하나가 있긴 하지만, 이미 계산메서드의 인자로 던져준 상태이므로, 계산로직 위임 객체calc가 이미 가진 의존성이다. | . | 빨간 박스안에는 this가 나올 요소가 하나도 없는 상태이다. . this가 안나오면 나의 메서드가 아니다라는 증거이다. | . | 즉, 쉽게말하면 result는 내가 가진 정보(this)로 와서 검증받을 대상이 아니라, result를 반환해주는 책임객체에서 검증을 끝내고 와야하는 대상이다. . . 위임한 객체 calc에서 알아서 결과값을 검증하고, thr로 스스로 죽어라고 검증책임을 위임한다. | . . | 계약조건의 준수는, 한쪽에 모는 것이 아니라 섬세하게 누구에게 책임이 있는지 판단해서, 그쪽에 위임해야한다. . | . 사전/사후계약조건 검증 중에 내 context(this, 보라색변수)를 통한 검증이 아니면, 검증도 물어보지말고 스스로 죽도록 시킨다.(위임) . 인자 calc의 상태검증을, isEmpty()로 물어보고 검증한다면? calc가 변할 때, 변화의 여파가 여기까지 온다. . 내 정보this가 필요한 것도 아닌데, 물어보고 행동하면, 변화의 여파가 온다. | . . | 결과값 result의 검증을, 0이냐/음수냐를 물어보고 행동한다면, 결과값계산로직이 바뀐다면 변화시 여파가 온다. . 내 정보(this)를 이미 결과계산로직에서 받아갔다면, 결과값 검증은 물어보지말고 결과값 계산하는 객체가 스스로 죽도록 시킨다. | . . | pre/postcondition 검증책임은 대부분 위임받은 객체들이 가져가야하며, 인자/결과값로직의 검증 코드가 안보인다면, 이미 계약관계라고 판단한다. . . 상태값이나 결과값에 대한 검증을 물어보지말고, 위임된 객체에게 시킨다. 인자 객체의 검증코드없이 나는 검증된 값임을 메소드로 증명하고있다면 이미 계약관계라고 판단한다 | 결과값에 대한 검증로직이 안보인다면, 사후조건 검증을 가져간 상태로서, 이미 계약관계라고 판단한다 | . | precondition은 인자에 대한 precondition조건을 명시적으로 호출하는 것이 필요하지만, postcondition은 위임한 메소드안에 지 스스로 보장해서 줘야한다. | . precondition은 내가(받은쪽이) 발동할게, postcondition은 니(위임객체)가 처리해와 . 처음에는 Plan에 precondition과 postcondition을 모두 두었다가, precondition도 옮기고, postcondition도 옮겼지만 둘의 옮긴다는 같은 의미가 아니다 preconidtion의 책임은 받은쪽이 호출해야하는 책임을 가지며 | postcondition의 책임은 위임받아 주는쪽이 책임을 가져서 다 처리하고 준다. | . | **일반적으로 calc를 받아들인 쪽인 plan이 precondition을 명시적으로 호출한다. 그에 비해 postcondition은 위임받은 쪽이 검증까지 다 처리하고 주는 책임이 있다. ** . precondition은 내가(받은쪽)이 처리할게, postcondition은 니(위임객체)가 처리해와 | . | 회사에서 룰로 짜야한다. postcondition은 return하는 쪽이 다 책임지고 줘야해 | precondition은 잘못된 값줬다고 뭐라하지말고, 받은놈이 검증해 이것을 안지키면, 제품이 어떤쪽에선 되고, 어떤쪽에선 안되고가 발생한다 | 일관성있게 검사해야한다. | . | 70%가 validation코드가 되기 때문에, 스프링 등에서 애노테이션으로 제공해준다. | . | . 협력을 통한 책임분할 . 지금까지는 precondition은 받은쪽이 발동, postcondition은 return주는 놈에게 정도로만 나눴지만, 더 세밀하게 나눠야한다. | . postcondition검증인 결과값 검증에 외부인자 검증이 포함되어있는데, 검증 통과못하면 계산의 의미가 없는 경우, 애초에 오염되지 않은 인자만 넘어오는게 더 좋다. . . precondition으로서 내부에서 책임진다는원칙을 적용할 수도 있겠지만 | calls는 외부에서 인자로 오는데, 왜 내부에서 검사하지? 내 책임이 아니라서 외부에서 넘어올때부터 검증된 것만 넘어오게 한다. | . | 메세지에 white list만 흐르게 하면, 내부 검증 로직이 제거된다. . | 외부 재료call이 1개이상일 때, 결과값이 0원이나 음수면 -&gt; 결과값 반환없이 스스로 죽는다. . 외부 재료call이 0개일 땐? 0원인데, 그대로 두어도 0원으로 반환된다. 하지만, 1개이상이 아니라면, 계산의 의미가 없어진다. | . | 애초에 외부재료call(인자)이 1개 이상일때(특정 검증 통과해야)만 결과값계산이 의미를 가지는 경우라면, 외부에서 인자를 넘길 때, 미리 검증하고 넘기고, 아니라면 아예 안넘어오도록 삼항연산자를 활용해서 검증을 옮긴다 . . | 계약관계에 있더라도, 위임된객체.메서드()의 시그니쳐가 보여주는 것은 아주 일부분이며, 코드로 계약관계를 명시한다. . 결과값 검증없이 책임객체의 결과값 반환하는 계야관계 -&gt; 계약서 중 제목밖에 차지 안하는 부분이다. . | 나머지 계약내용들은 위의 삼항연산자 코드처럼 계약내용이 명시되는 것이다. . . . | . | 계약서의 내용으로 인해 계약의 의미가 달라졌다. plan은 나의 calls을 보내는 것이 아니라 내것(this)와 다른 1건이상의 calls을 보낸다. 더이상 plan의 calls이 아닌 calls. | 코드만 보고 계약내용을 모를 경우, OneMoreCalls라는 형을 만들어서 인자로 보내기도 한다. | . | . | . 런타임에 의한 계약조건 . 방금 봤던, size가 0보다 더 큰 것을 검증하는 것도 섬세한 문제였지만, 런타임은 더 큰 문제다 | . setter가 있어 생성시점에 불변을 보장못하는, 상태변화하는 객체 인자는, 인자의 상태검증 발동을 precondition에 위치시켜선 안되고, 실제 계산에 사용될 때마다 매번 스스로 검증하도록 메세지 처리전, invariant를 스스로 걸어야한다. . 즉, setter를 가진 객체는, pre나 post가 아니라 메세지처리전, 실시간 자신의 불변성 검증으로 돌려야한다. . . | . Calculator, Plan . . 전략객체들을 실시간으로 받는 calculator는 Plan에 들어가는 runtime(시점)에는1개이상인지 상태검증을 제공하는데 check()메서드의 가정: 생성시점에 가지고 있는 전략객체 컬렉션이 확정되어있으며, 내가 plan에 들어갈 때, 내가 전략객체가 없으면 잘못된 놈이야. | . | **runtime상에서 상태변화를 언제든지 변화시키는 setter받기기능이 존재하고 있다. ** 전략객체를 추가하는 것은 생성시점이 아니라 runtime시 자유롭게 추가할 수 있다. | . | . | 상태가 시간(타이밍)마다 달라지는 것이 어렵다 Calculator 생성시점에는 아무것도 없다 | Plan에 집어넣을 때도 아무것도 없다. 근데 검사는 여기서 이루어진다. | 근데, plan에 들어가서 검사 이후에 얼마든지 setter로 전략객체를 추가할 수 있다 | 나중에 추가될 수 있으면, plan에 집어넣을 때 검사하면 안된다. | . | 생성시점에 확정되지 않는 애들(setter를 가진 필드)은 runtime에 의존성이 있고, 시차가 생기는데, 특정시점(plan에 들어가는 시점)에 검사하고 마치면 안된다. | . . calc.check()는, 나중에 계산시 전략객체가 없으면 안되니까 미리 검사하는 것이었다. . calc.check()는 precondition으로서 들어갈 때 인자의 상태검사를 할 것이 아니다 -&gt; plan에서 삭제한다. . . | setter를 가져 상태변화하는 calc인자의 상태 검사는, 자신이 사용될 때 실시간 스스로 검증해야한다. . . | | 다시 보니, 내가 메세지를 처리하기 전에 내 상태를 검증하고 있는 invariant검사다. 메세지 처리전에, 상태변화가 가능한 자신부터 thr로 불변성 검증하는 01 불변성 검증이다. | precondition으로 봤던 calc인자의 상태 검증은 알고 봤더니, 상태가 수시로 변하므로, 계산할때 상태 검증 -&gt; 스스로 불변성 검증하는 invariant였다 | . | 상태가 변하는 객체는, 실행될 때마다 자신의 상태를 검증해야한다. . | 불변식이라는 것은, 1번만 검사하고 끝나는 immutable이 아니라, 특정 조건하에서만 메세지를 처리하는 것이 invariant이며, 변하지 않는 필수조건을 의미한다 . 메세지 처리를 하기 전에, 확인해야하는 필수조건 = invariant | 메서드내에 인자나 지역변수와는 상관없이 먼저 깔려야한다 | . . | 메서드호출인 실행시점보다 앞 시점은 생성시점밖에 없다. 생성시점에 1번만 보장하면 되는 immutable이 아니라 상태변화를 하는 상태값이라면 | 실행시점마다 == 메서드호출시마다 보장해야하는 invariant다 | . | 생성 -&gt; initialize -&gt; calculate 순으로 메서드를 생성했다. client에서는 initialize를 호출해준다는 보장이 없다. 컴파일러는 메서드 순서를 빼먹은 것을 걸러주지 못한다. | . | 런타임에 와서야 뭔가 부족해서 에러가 난다. 런타임으로 올라간다면, 단위테스트로 모든 경우를 테스트할 수 밖에 없어진다. | . | 컴파일타임에 확정지으려면, 생성자에서 확인할 수 밖에 없다 | 메서드의 순서로서 런타임으로 미뤄진다면, 호출시마다 invariant를 확정하는 방법 밖에 안남았다. 스프링은 라이프사이클(순서)로 객체를 만들던데? | 스프링은 자동으로 자신이 순서대로 객체를 다 만들어서 빼틀일 일이 없다 = 상태가 에러나는 쪽으로 변하지 않는다 = 런타임 에러가 안난다. | . | . | 불변상태로서 생성시점에 검사를 한다면, 컴파일러에 걸려서 에러를 미리 잡을 수 있으나, setter로 변하는 상태를 가졌다면 -&gt; 생성시점에 검사는 의미가 없고, 호출시점마다 매번 invariant를 확정하고 메세지를 처리하는 수 밖에 없다 | . 다시 precondition . Calculator . . setter도 인자의 null검사를 precondition으로서 검사해줘야한다. | . 계약의 전파 . . 지금까지 이것을 배우기 위해 공부했던 것 | 계약은 전파된다. 한번 앞에서 검증했다면, 또 검증해야할까? | 독립성을 위해서, 확인하기 귀찮으니, 무조건 다시 검사할까? | 갑-을만 계약할까? 어디에서 계약이 이어질까? | . | . package(가시성)으로 precondition검증을 생략하기 . 좋은 인자들이 검증없이 전파 유지되기 위해서는,,, 이미 앞에서 검증이 끝난 인자라면, 호출하는 주체가 계약 맺는 놈만… public이 아니어야.. . PricePerTime . . 1분당 18원을 계산하기 위해서, 1분을 60초 Duration으로 받고, 분당가격을 Money로 받는다. . | 문제점: invariant / pre / post 검증을 아무것도 안하고 있는 전략객체 . . 생성자에 만능키인 null이 들어올 수 있으므로 invariant 만족이 안되는 상태다 | . . contract의 문제때문에, 인자2개를 아무것도 안하고 있다. 인자null/인자상태검사인 precondition도 검증안했고 | 반환해줄 결과값인 result도 검증안했다. | . | . | 이렇게 짜면, 제품세계에서 장난감이 되는 것이다. 확정 버그 클래스로 보면 된다. pre/post condition/invaraint가 안걸린 class는 테스트도 필요없는 버그클래스다. . 보자마자 병균. 3가지를 만족하지 않으면, 아무리 단위테스트를 많이 짜도 101번째에 버그가 발생한다. | . | . precondition(메서드 인자)이 검증이 없어서 찾아보는 원천 인자 . . 전략객체calc의 전략메서드 calc를 호출하는 주체는 전략객체를 소유하고 있는 Calculator다 . PricePerTime에 precondition이 되는 인자를 준 놈은 Calculator이고 . | calc.calc()의 인자는 Calculator의 calcCallFee( , )의 파라미터에서 받아온다. . . | 따라서, 넘어가는 파라미터에 대한 책임은 Calculator를 소유한 Plan에서 넣어주는 인자들이다. . . | 원천 인자를 찾아보니, Plan은 1건이상의 calls + 누적결과값변수의 초기값이라는 최초 인자가 계약을 잘지킨 좋은 인자를 Plan과 Calculator사이에는 확신할 수 있다. . 이렇게 되면, Calculator로 넘어간 파라미터는 precondition계약을 잘 지킨 좋은 인자라고 확신할 수 있다. . . | . | . | . 좋은 인자로 전파가 시작됬다면, 문제는 package와 접근제한자에 있다 . Calculator의 calcCallFee()는 좋은 인자를 받았다고 했지만, public 메서드는 계약 맺은 Plan이 아닌 놈도 호출할 수 있는 문제점이 있다 precondition을, 앞에서 호출하는 놈이 계약내용을 코드로 책임을 지어주었는데, public 메서드라 precondition의 계약내용을 책임을 안지어주는 놈이 나쁜 인자를 넣어서 호출할 수 있는 문제가 생길 수 있다. | . | 우리가 계약을 믿으려면, Calculator의 메서드는 Plan만 호출할 수 있어야하고,Calc의 메서드는 Calculator만 호출할 수 있어야한다. 이것을 확정지어야 좋은 인자를 처음에 검사했다면, 더이상 precondition검사를 할 필요가 없게 된다. | . | java의 package는 계약관계때문에 쓰는 것이다. java같은 패키지언어에서는, 가상화경로를 가지는 package를 통해서 물리적인 위치의 불편함을 해소했다. c의 manifest의 물리적인 파일위치용 package가 아니라 , 물리적 위치가 달라도 같은 패키지로 링킹 | . | 계약관계로 인해서 package를 만들어 어떤애가 호출하지 못하게 만들려고 한다. | . | plan은 calculator호출시 안전하다. 왜? plan에 계약서 내용이 명시되어 있어서 calculator가 calc를 호출하는 것도 안전하다. 왜? 이미 안전한 인자를 받아서 내부에서 호출하기 때문에 | . | 계약의 체인을 확정하기 위해서는 package 구성를 통해 외부호출을 차단하고, 내부에서 좋은 인자로 체인이 가능하도록 해야한다 | . 계약체인을 보장하는 방법은 package구성을 통한 가시성 밖에 없다. . . 외부에서 간섭할 수 없게하려면, 오직 Plan만이 인식할 수 있는 영역안에서만 Calculator를 호출할 수 있게 하고 싶다 . . | . plan을 일단 package plan에 집어넣는다. . . | 계산위임을 받아 내부에서 호출되며, 계약된 인자를 받는 합성객체 Calculator도 package plan안으로 집어넣는다. . . Calculator자체는 client코드에서 new때려서 만들어야하기 때문에, public class여야한다. | 하지만 계약된 메소드calcCallFee 는 접근제한자 없는 internal로서 패키지 안에서만 호출된다. 이것으로 외부에서 더이상 계약된 메소드를 호출할 수 없음을 보장할 수 있다. | package내부에서는 plan밖에 호출하지 않도록, 우리가 통제하고 있다. | . | internal메서드를 통해서, 계약을 체결하고 있는 객체만 호출되도록 계약서에 추가명시된 것과 마찬가지다. internal가시성을 통해 calcCallFee()메소드는Plan에 독점공급된다는 계약내용이 추가되었다. | . | . | 문제는 Calculator에 주입되는 전략객체들을, Calculator만 호출할 수 있게 만드는 것이다. . . 일반 구상클래스들 합성에서는 같은 package에 넣고 호출되는 쪽 메서드를 internal로 만들면, 외부호출을 막을 수 있었음. | 여러개의 합성객체들 및 전략메서드(인터페이스 오퍼레이터)를 internal로 막을 수 있을까? . | 일단 같은 pakcage안에 위치시킬 것인데, plan안에는 calc를 호출할 순 없다. 우리 통제권안에 있는 상태 = calculator만 호출할 수 있는 상태인데 . . | java의 인터페이스는 가시성 누수 때문에 무조건 public으로 만들어야한다는 제한이 생긴다. . 그렇다면, public외적인 가시성을 가지려면 인터페이스를 포기해야한다. | 인터페이스를 포기해도 두려워할 필요없다. 우리는 좋은 부모를 만드는 방법을 알기 때문에 | . | . . 가시성 확보를 위해, internal Calc 추상클래스와 internal calc추상메서드를 만들었다. 뿐만 아니라, Calc는 internal class기 때문에, 외부에서 상속도 할 수 없다. | . | 전략객체들도, 훅메서드 구현구상체들도 변경해준다. | . . 훅메서드구현시 internal로 만들어, calculator만 Calc의 구상체들을 호출할 수 있도록 바뀌었다. 이렇게 calculator나 calc에서 precondition을 걸 필요가 없게 된다. | 처음에 계약된, plan이 주는 깨끗한 인자를 보장할 수 있게 되었으므로 | . | . | 무조건적으로 precondition이 없다고 나쁜코드가 아니다. 계약만 잘되어있다면, precondition은 보장되어서 걸 필요가 없게 된다. . 계약내용으로 코드만 있는게 아니라 가시성 조정도 계약의 일부였다. . | 짬이 생기면, package구성만으로도 어떤 계약을 맺고 있는지 보이게 된다. my) 어?? precondition이 없네? -&gt; 같은 package내에서 계약관계로 보장되는가보네? | 얘네들이 어떤 관계로 연관관계 계약관계를 맺고 있는지 보이네? 한쪽에만 집어넣으면, 나머지는 다 안전할 것이네 | . | 정상적으로 설계를 잘했다면, package별로 역할이 분리되어있고, package에 public으로 노출되는 메서드 인터페이스가 1개씩으로 구성되고, 안에서는 체인으로 막아줘야한다. | . | . 가시성을 위해 포기한 인터페이스로 인해 등장한 안좋은 부모 . . 좋은 부모클래스는 abstract가 아니라 템플릿메소드 +protected abstract 만 있어야한다. | 좋은 상속구상체는 @Override가 부모의 자체메소드가 아니라 protected만 있어야한다. | . 문제점과 해결 . . 부모가 internal의 abstract만 가지는게 아니라 public템플릿처럼 (internal)템플릿을 가져야한다. . | 그리고 그 내부에, 자식들이 개별구현해야할 로직이 전체로직이라고 할지라도 protected abstract 훅메서드로 빼서 줘야한다. . . | 자식은 부모의 abstract메서드를 오버라이딩하는게 아니라 protected abstract 훅메서드만 오버라이딩 해야한다. . . | . . 계약관계라 할지라도, 좋은부모자식의 protected관계라면, 패키지를 이동시킬 수 있다. . 계약관계로 internal로만 호출되게 하기 위해 같은 package에 위치시켰었는데 . Calculator와 calc는 이제 인터페이스&lt;-&gt;전략객체의 관계가 아닌 부모&lt;-&gt;자식관계이므로 package의 위치와 상관없이 protected범위인 자식이 어디서든 호출될 수 있다. | . . plan &lt;-&gt; calculator: 같은package의 internal관계 | calculator &lt;-&gt; calc구상체들: protected관계로서 아무package나 위치해도 가능 . | 부모만 바깥의 상투클래스로 나가있고, 자식들은 내부의 다른 패키지에 위치시켜놓는다. | . | package구성은 카테고리만 할 것이 아니라 계약관계에 달려있다. . 전략인터페이스였던, 구상체들의 부모 Calc추상클래스만 Calculator와 계약하는 것이고 구상클래스들은 Calc와 proected로서 따로 계약하여 따로 위치하고 있다. | . | . 계약관계에 의한 package 최종 구성 . package구성을 끝내면, calc안에는 구상체들만 구성되어있고 나머지 계약관계의 주인공들은 밖에서 같은pacakge내 internal로 통신하는 병행package를 구성되어있다 . . ​ . 노란색들은 외부호출이 안되서 보호됨. -&gt; 따라서 앞에 계약만 확실하다면, 아래부분은 검증하지 않아도 된다. precondition은 plan에서만 처리되고 다른 곳에서는 안했다. | . | . | . postcondition검사는? . 아래 파란색 인자는, precondition검사는 더 상위레이어에서 계약을 체결해서 생략되었다. precondition 검사는 반드시 명시적인 validation코드가 있어야만 하는 것이 아니었다. 가시성으로 계약을 체결해서 해결된다. 특히 condition체인들이 해결된다. | . | . . condition검사할 때, 메세지 처리전 상태(필드)들의 invariant뿐만 아니라, postcondition검사 이전에, 로직에 사용된 보라색 필드들에도 주목해야한다. . 결과값 검증하기 전에, 내 필드값들이 눈에 밟혀서 invariant검증이 안된 것이 눈에 밟혀야한다. . . | result를 검증하기 전에, 사용되는 필드들 invariant부터 안정화되어야한다. . | . . **해당 invariant들을 보니 생성자 type이다 -&gt; 컴파일타임에 1번 null + 상태검사해서 invariant를 1번에 확정지을 수 있겠다. ** . setter로 상태가 변해서 런타임검사시 호출될때마다 매번 검사안해도 되겠다. | . | null체크 뿐만 아니라, 하한을 가지는 객체는 하한선도 같이 섬세하게 검사하는 도메인검사도 같이 한다 . **price의 상태검증은 물어보면 변화의 여파가 오니, 스스로 죽도록 시켜서 price.check()로 변경할 수 있다. ** . 게다가, ||로 연결되어야하는 상황이니 불린flag를 반환해주도록 .isChecked()로 만들어줘야한다? | . | Money라는 형은 언제든지 바뀔 수 있는 객체라서, 충격을 감당하려면, 처음부터 OverZeroMoney라는 형을 새로 만들어서 받아도 된다. . 검증만큼 형을 만들어주면 다 해결 된다. 형을 안받은 만큼, 형 안받은 포괄쪽인 곳에 코드로 나오게 되고 하드코딩이 되고 변화가 생기면 하드코딩해야한다. 그러나 형을 만들면, 그 형만 바꾸면 된다. | . . | 하지만, Duration 타입은, 외부객체라서 내가 시킬수 없다. . Duration을 상속받은 &amp;&amp; isChecked()를 가진 새로운형을 이용해서 처리해도 되긴한다. | 새로만든 형만 오면 검증을 안해도 되는 로직으로 만들어도 된다. . | 형으로 해결하는 것이 코드가 줄기 때문에 더 우아하다 | . | . | . 다시 postcondition검사로 . . calls는 1건이상으로 들어도록 해놨고 call마다 먼저 계산을 한다. 최종반환 전에, for문의 개별 결과값도 만든 뒤 postcondition검사를 한다. | . | . | sum을 다 계산한 나만의 계산이 맞는지 result이전에 지역변수 sum을 만들어 계산한다. result는 건너온 메세지로서 객체context로, postcondition검증이 다 끝난 후에야 업데이트해줘야한다. | 그러기 위해 초기값 ZERO result를 바로 사용하지 않고, 지역변수에 새로 할당해서 나만의 계산을 먼저 한다. | . | 기존에는 그냥 객체context(파라미터 result)에 바로 더했던 것에 비해서, 나만의 계산부터 먼저할 수 있도록 한다. postcondition을 고려하지 않고, 바로 context에 때려박으면, 디버깅도 X 추적도 X | . | 반드시 끊을 수 있게 지역변수를 선언해서 짜야한다. sum단계 | r단계 | sum다시 검사(여긴 없는데 sum이 0이상인지도 검사해야하는데, 암묵지로 생략해버린 것은 문제점이다.) | . | **단계별로 postcondition검사를 할 수 있는 로직으로 짜야한다. ** 그렇게 짜지 않았더라면, 테스트를 안하고 짠 것이다. | 지역변수로 받아서, 중간상태를 볼 수 있는 상태/검사가능한 상태로 바꿔줘야한다. | . | 코드로 계약을 짜야하고, 단계별로 검사할 수 있도록 짜야한다. . 계약내용(pre, post, invariant) vs 로직을 구분해서 확인가능하도록 짜여져야함 . | 코드의 70%는 계약서내용이고, 중간에 지역변수 쓴 것도 다 계약내용 때문이다. 알고리즘은 아주조금만 들어가있다. | 코드로 명시하는 것은, thr의 제어문으로 만들 수 도 있지만, 형을 만드는 것으로 바꿔서, 그 코드를 형으로 그대로 옮겨줘도 된다. | . | .",
            "url": "blog.chojaeseong.com/object/2022/06/11/((object2-1)%EC%A0%95%EC%B1%85%EC%A0%81%EC%9A%A9%EA%B0%9D%EC%B2%B4%EB%93%A4%EC%9D%98-%EA%B3%84%EC%95%BD%EA%B4%80%EA%B3%84-%EB%B3%B5%EC%82%AC%EB%B3%B8.html",
            "relUrl": "/object/2022/06/11/((object2-1)%EC%A0%95%EC%B1%85%EC%A0%81%EC%9A%A9%EA%B0%9D%EC%B2%B4%EB%93%A4%EC%9D%98-%EA%B3%84%EC%95%BD%EA%B4%80%EA%B3%84-%EB%B3%B5%EC%82%AC%EB%B3%B8.html",
            "date": " • Jun 11, 2022"
        }
        
    
  
    
        ,"post45": {
            "title": "의연방13) 메타분석3(revman 실습)",
            "content": "&#54617;&#49845;&#47785;&#54364; . RevMan 5 소프트웨어를 설치할 수 있다. . RevMan 5 소프트웨어 사용법을 이해할 수 있다. . 실제 데이터로 메타분석을 수행할 수 있다. . &#47785;&#52264; . RevMan 5 설치 | RevMan 5 사용법 | RevMan5 &#49444;&#52824; . 구글에서 Review Manager를 검색하거나 아래 사이트를 통해 가서 설치한다. . Available from https://training.cochrane.org/online-learning/core-softwarecochrane-reviews/revman | . | Revman 5 download &gt; For Academic use . 아래 항목 작성 | . | 실행시 Non-Cochrane mode로 실행할 것(only 메타분석만 시행) . Standard mode는 코크란에 SR이나 메타분석 출판을 위한 목적으로 나중에 설정에서 바꿔주면 된다. | . | create new Review &gt; Type of Review 선택(기본:intervention review) . | Title은 작성안하고 넘어가도 되고 작성해도 된다. . | Stage만 유일하게 Protocol -&gt; Full review로 변경해준다. . 메타분석은 SR에 포함된 것으로서 프로토콜만으로는 할 수 없다 | . | Outline Pane으로 작업 수행/ Content Pane이 Output창으로 생각하면 된다. . | RevMan5 &#49324;&#50857;&#48277; . Example Data . 사용하기 전에 데이터가 있어야한다 | 가상으로 만든 2가지 outcome에 대한 4가지 연구들의 데이터를 확인해보자. . Headache(binary type outcome) | Physical activity(Continuous outcome) | | caffeine 커피가 두통을 더 많이 일으킬 것이다로 검색시 4가지 연구 . 각 군마다 환자수(total)와 두통발생수(events)를 조사한다 binary type의 outcome인 경우: 각 군당 n수와 event수 2가지 조사 | . | . | caffeine과 decaffeine 커피에 대해 생리 활동이 다를 것이다 검색시 3가지 연구 . 연속형type의 outcome이므로 각 군당 n수 + Mean + Sd 3가지 조사 | . | . Add study . 임상연구 시작시, 각 환자마다 subject_id를 생성하듯이 | . 각 study에 대한 Study ID를 생성한 후, 관련된 개별 연구(문헌)들을 추가함. Cochrane review의 경우 추천하는 규칙이 따로 있다. -&gt; 제 1저자 + 출판연도 Study ID : the name of the lead author + the year of publication (예: Stephens 1996) | 만일 동일한 저자명과 연도를 가지는 study가 하나 이상 존재하면 알파벳 문자 추가 예 : Stephens 1996a, Stephens 1996b | . | . | . | outline pane에서 Studies and references &gt; references to studies &gt; included studies &gt; RMB &gt; Add study를 클릭해서 Study_id들을 추가해줘야한다. - 오타: next버튼을 마지막전까지 . 각 study들을 추가하다가 맨 마지막 study의 경우 Nothing을 선택해서 Finish한다. | . | Data &#51077;&#47141; &#48143; &#48516;&#49437; . Step 1. Intervention과 control간의 비교 정보를 입력한다. ex) Caffeinated coffee vs. decaffeinated coffee | . | Step 2. 각 비교에 대해, 측정된 outcome 정보를 입력한다. ex) Dichotomous outcome: Headache | . | . outline pane에서 Data and analyses를 선택 &gt; RMB &gt; Add comparison 여기서부터 메타분석이 시작된다. | . | Name에 Caffeinated coffee vs. decaffeinated coffee을 입력 한 후 Next를 클릭한다 | 2번째에 있는 Add an outcome under the new comparison을 선택한 후, Continue를 클릭한다 . | outcome 종류에 따라 Data Type을 선택한다. . binary(두통) -&gt; Dichotomous | 연속형(생리 활동) -&gt; Continuous | . | Name에는 Outcome명칭을 쓴다. ‘Headache’을 입력한다. . | Group Label 1에 ‘Caffeinated coffee’를, Group Label 2에 ‘Decaffeinated coffee’를 입력한 후, Next를 클릭한다. . 각 군의 이름을 쓰는 것이다. 기본적으로 중재군을 group 1, 대조군을 group 2로 쓴다. | . | Outcome에 대한 statistical method를 선택한다. . Statistical Method (가중치 부여 방법) : Mantel-Haenszel Inverse Variance는 total n수만 의지하는 것 | Mantel-Haenszel는 total n수 + event수까지 반영하는 것으로 binary(Dichotomous) outcome에 추천됨. | . | Analysis Model (통계 모형) : Fixed effects 아직 이질성에 대한 것을 모르므로 기본으로 Fiexed effects모형으로 선택함 | . | Effect Measure (요약 통계량) : Risk Ratio 연구가 RCT나 코호트(전향적)인 경우, RR을 이용함 | 그외 OR?! | . | . | 메타분석 결과 세부사항 -&gt; 신뢰구간 95%로 둔다. . | 메타분석 그래프에 대한 세부사항 정보를 입력한다. . outcome이 안좋은 것인 경우, (ex&gt; 두통) -&gt; RR가 1을 넘길 경우 안좋은 것. 1이하일 경우 좋은 것인 상황이라면 그래프 왼쪽 = RR이 1보다 낮은 것: 안좋은 결과를 일으키는 군의 이름을 입력 | 그래프 오른쪽 = RR이 1보다 높은 것: 좋은 결과를 일으키는 군의 이름을 입력 | scale은 나중에 조정하면 되서 default로 준다. | . | . | raw data를 입력하기 위해 Add study data for the new outcome을 선택한다. . | Included Studies(SR대상) 중 에서 메타분석에 포함될 study들만 선택한다. Ctrl or Shift key를 누른 상태에서 마우스로 해당되는 논문들을 직접 선택 | or year를 이용한 Filter 기능을 이용 | . | 데이터 입력칸만 하얀색으로 활성화 된다. Headache outcome을 입력하기 위한 data table이 생성됨 | Dichotomous outcome의 경우, number of events (= number of headache) 및 total number (= number of participants or patients)을 입력해야 함. | . | . | &#47700;&#53440;&#48516;&#49437;&#44208;&#44284; &#54644;&#49437; . 3번째, 1번째 study가 환자수도 많고, event수도 많아서 weight가 높게 잡힌다. | 모든 스터디들이 RR이 1을 넘었다 -&gt; outcome headache -&gt; 중재군(카페인커피)가 대조군(디카페인 커피)보다는 두통을 좀 더 일으키는 것 같다고 해석한다. | 그런데, 개별 결과들은 신뢰구간이 모두 1을 포함한다 개별 스터디들은 통계적으로 유의하지 않다고 해석한다. | . | 그러나, 통합된 결과는 RR이 1을 넘으면서, 신뢰구간이 1을 포함하지 않아 통계적으로 유의하다 카페인커피가 디카페인커피보다 두통을 1.69배 더 일으킨다.(통계적의 유의) | . | 메타분석의 이유 각각의 study들은 통계적으로 유의하지 않으나, 방향성은 카페인이 더 두통을 일으킨다고 나오고 시그널을 주고 있다. | 통합된 결과를 봐야한다. | . | . &#47700;&#53440;&#48516;&#49437;&#44208;&#44284; &#8211; plot . 상단의 버튼들로 plot을 볼 수 있다. | . Forest plot . | Funnel plot . publication bias를 볼 수 있는 유일한 것 | 연구가 4개 뿐이라 대칭형인지 알 수는 없는 상태임. R등에서도 test도 10개이상 연구만 테스트가 가능함. | . | . | &#50896;&#54616;&#45716; &#44221;&#50864;, outcome property(&#50836;&#50557;&#53685;&#44228;&#47049;)&#47484; &#48148;&#44992; &#49688; &#51080;&#51020; . RR버튼 : 요약통계량을 RR에서 다른 것으로 바꿀 수 있다. | FE버튼 : Fixed Effect 모형에서 Random Effect 모형으로 바꿀 수 있다 이질성 평가시 Heterogeneity Chi제곱 부분을 보면 되는데 P value = 0.62 / I^2 = 0%로 이질성이 없다 -&gt; FE모형 결과를 그대로 받아들이면 된다. | 만약 이질성이 나타나면 FE버튼을 눌러서 바꾼다. | . | . | Continuous outcome&#51032; &#52628;&#44032; . 추가적인 outcome이 존재할 때 추가해주면 된다. | . 기존 분석의 중재군vs대조군을 그대로 사용할 것이라면 Caffeinated coffee vs. decaffeinated coffee comparison에서 RMB &gt; Add Outcome을 클릭한다 . 군이 바뀌면 새롭게 해야함. | . | Data type 중 Continuous을 선택한 후, Next를 클릭한다. . | Outcome 이름으로 Physical activity에 이라고 입력한 후, Next를 클릭한다 . 기존 군은 그대로 사용한다. | . | 가중치 부여 방법, 통계 모형, 요약 통계량 등을 선택한다. . 연속형 outcome에 대한 가중치부여방법(statistical method)는 1가지 Inverse Variance 밖이다. 표본수만 근거한 가중치 부여방법(각 그룹의 환자수가 많은 것에 가중치 많이 부여) | . | 분석모형은 Fixed로 일단 시작 | Effect Measure에서는 측정단위(scale)가 동일하면 MD / 다르면 표준화시키는 Std MD를 사용한다. | . | 결과 및 그래프에 대한 세부사항은 앞과 동일하다. 마지막 finish전에 데이터를 입력하는 add study data for the new outcome을 선택하고 finish해준다. . | 이미 추가된 4개의 study중에 3개 study에만 데이터가 존재하므로 3개만 선택한다. . | 데이터를 입력할 땐, 칼럼 순서를 잘 확인하자(환자수가 제일 마지막) . | 결과 확인 . 3번째 연구가 가중치가 제일 크다. | MD에서는 0을 포함하지 않아야 통계적으로 유의하다고할 수 있다. total MD가 0을 포함하고, test에서도 p-value가 유의하지 않기 때문에 physical activity에 대해서는 2군간의 평균 차이가 없다라고 말할 수 있다. | . | 이질성을 확인해보니, P-value랑 I^2에 의해 이질성이 크다라고 나온다. 이질성이 있을 경우, FE -&gt; RE모형으로 바꿔줘야한다. FE버튼만 한번 클릭해주면 된다. 가중치가 바껴서 -&gt; MD(effect size)가 아예 바뀐다.(음수 -&gt; 양ㅅ) | 신뢰구간도 넓어진다. | total effect의 p-value로 바뀐다. | . | 최종적으로 MD가 0보다 크기 때문에 카페인 &gt; 디카페인 커피가 physical activity가 약간 큰 것 같긴한데, 통계적으로 유의한 차이는 없다 | . | . | Standardized Mean Difference . 연속형 변수에 대한 raw data(Mean, SD, n)을 봤더니 첫번째 연구의 mean만 너무 높다 -&gt; scale이 다른 것으로 측정됬을 것이다. . 연속형 type의 outcome을 가지는 study를 모을 때 꼭 확인해야한다. | . | 동일한 outcome을 different scale로 평가한 자료들의 입력 . Different scale로 측정된 outcome들의 경우 이들의 표준편차에 기초해 표준화 한 뒤 결합할 수 있다. | . | . 요약통계량을 MD -&gt; SMD로 변경해줘야한다. weight도 %가 다 비슷해진다. | 하지만, total MD나 test p-value로 봤을 땐, 통계적으로 유의하진 않다. | . | . Subgroup Analysis(&#52628;&#44032; &#50672;&#44396;) . Outcome을 먼저 생성한 후, 생성된 outcome에 대한 subgroup을 정의할 수 있음. | . Headache에 대한 결과가 이미 나온 상태에서, 별도로 subgroup을 나눠서 분석하려면 . 기존 Headache 결과를, comparison에 그대로 Copy해서 붙여넣는다. | . | 복사된 outcome에 RMB &gt; introduce subgroup을 클릭한다. . 하위에 New Subgroup이 추가된다. | . | RMB &gt; Rename Subgroup을 통해, subgroup 중 1개의 이름만 명시해준다.(나머지 이름은 추가해서 나눌 것임) . 원래는 study수가 적기 때문에 subgroup을 나누는 것을 추천하지 않지만 연습이라서 해본다. | Subgroup으로 출판년도를 고려해보자. (1998년 vs 2004년) -Subgroup에 대한 이름으로 ‘year 1998`으로 입력한다. . . | . | 두 번째 subgroup 지정: ‘1.2 Headache’ outcome을 RMB &gt; Add Subgroup을 선택한다. 그러면 New Subgroup Wizard 창이 열린다. 두 번째 subgroup 이름으로 year 2004라고 입력한 뒤, Next를 클릭한다. . | Edit the new subgroup을 선택한 뒤, Finish를 클릭한다. . | 기존 그룹에 속해있는 2004 study를 잘라내기 해서 가져온다 . | 결과 확인 subgroup별로 결과 및 그래프가 나온다. | 각 그룹별 결과 뿐만 아니라 2그룹간의 차이가 있는지도 나온다. 여기선 P=0.22로 차이점가 없다고 나온다. | . | effect는 1998년도가 더 effect가 높으니, 연구간 이질성을 해결해보거나 특정한 서브그룹 결과에 집중해본다. | . | Risk of bias(Rob) graph &amp;summary . 메타분석 전단계인 문헌에 대한 질 평가 = 비뚤림 위험성 평가를 그래프로 만들어주는 기능을 Revman에서 제공한다. risk of bias는 코크만에서 만들었으며, revman 역시 코크만에서 만들었다. | . | . Figure를 만들건데, 먼저 Tabe &gt; Chracteristics ~ &gt; Chracteristics ~내려간다 . | 2가지 연구에 대해 각 스터디들 정보를 기입해야한다(원래는) . 밑에 보면 Risk of bias table 탭이 보인다. | 원래 Rob는 RCT를 평가하는 것이기 때문에, RCT관련 항목들이 나온다. | 각 스터디마다 risk를 판단해서 평가한다 Unclear risk (잘모르겠다)를 선택할 경우 -&gt; 우측 Support for judgement를 클릭해줘야한다. 안해주면 그래프가 안그려짐 여기서는 blank를 넣어줬는데, 이것도 graph에서 누락되니 꼭 적어줘야한다. | . | . | . | Tables에서 각 risk 판단을 해줬다면, Figure로 내려와서 Add Figure를 클릭한 뒤, Risk of bias graph 혹은 Risk of bias summary를 선택한 후, Next를 클릭한다. caption이 필요하면 적어준다. | . | Unclear risk에 대해서 안채워졌더니, 노란색이 아예 안나타난다. | &#50672;&#49845;&#47928;&#51228; . 01 &#45796;&#51020; &#51473; RevMan 5 &#49548;&#54532;&#53944;&#50920;&#50612;&#50640;&#49436; &#51648;&#50896;&#54616;&#51648; &#50506;&#45716; &#48516;&#49437;&#48169;&#48277;&#51008; &#47924;&#50631;&#51064;&#44032;? . Forest plot . | Funnel plot . | Trim and Fill method . | Subgroup analysis . | 정답:3 | 해설: RevMan 5은 Trim and Fill method는 지원하지 않으며, Trim and Fill method는 STATA 또는 R 프로그램으로 수행할 수 있다. | . 02 &#45796;&#51020; &#51473; RevMan 5 &#49548;&#54532;&#53944;&#50920;&#50612;&#50640;&#49436; &#51648;&#50896;&#54616;&#51648; &#50506;&#45716; &#44536;&#47000;&#54532;&#45716; &#47924;&#50631;&#51064;&#44032;? . Forest plot . | Contour-enhanced funnel plot . | Risk of bias graph . | Study flow diagram (PRISMA) . | 정답: 2 | 해설: RevMan 5은 Contour-enhanced funnel plot을 그릴 수 없으며, 이 plot은 STATA 또는 R 프로그램으로 그릴 수 있다. | . 03 &#47700;&#53440;&#48516;&#49437; &#49688;&#54665; &#51473; &#51060;&#51656;&#49457;&#51060; &#51080;&#45716; &#44163;&#51004;&#47196; &#54869;&#51064;&#46104;&#50632;&#45796;. &#51060; &#46412; RevMan 5 &#49548;&#54532;&#53944;&#50920;&#50612;&#47196; &#51060;&#51656;&#49457; &#47928;&#51228;&#47484; &#54644;&#44208;&#54624; &#49688; &#50630;&#45716; &#48169;&#48277;&#51008; &#47924;&#50631;&#51064;&#44032;? . 변량효과 모형의 사용 . | Subgroup Analysis . | 메타 회귀분석(Meta Regression) . | 해당사항 없음 . | 정답: 3 | 해설: RevMan 5은 메타 회귀분석(Meta Regression)은 지원하지 않으며, 메타 회귀분석(Meta Regression)은 STATA 또는 R 프로그램으로 수행할 수 있다. | . &#51221;&#47532;&#54616;&#44592; . 메타분석은 체계적 문헌 고찰 수행과정에서 2개 이상의 개별 연구의 요약 통계량을 합성함으로써 해당 중재법의 통합된 가중평균 요약 통계량을 정량적으로 산출하여 임상적 효과성을 평가하기 위해 사용되는 통계적 기법이다. . 메타분석을 수행할 수 있는 통계 소프트웨어 중 RevMan 5(Revman Manger)은 코크란 그룹에서 무료로 제공하며 설치하기 용이하다. . RevMan 5은 요약 통계량을 결합하기 위한 메타분석의 통계모형으로 고정효과 모형과 변량효과 모형을 제공하고 있다. . RevMan 5은 이질성(Heterogeneity) 평가를 위한 통계분석방법을 제공하고 있다. . RevMan 5은 출판 비뚤림(publication bias) 평가를 위한 funnel plot만을 제공하고 있다. .",
            "url": "blog.chojaeseong.com/r/revman/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EB%A9%94%ED%83%80%EB%B6%84%EC%84%9D/metaanalysis/2022/06/10/%EC%9D%98%EC%97%B0%EB%B0%A913)-%EB%A9%94%ED%83%80%EB%B6%84%EC%84%9D-(Revman-5-%EC%8B%A4%EC%8A%B5)-copy.html",
            "relUrl": "/r/revman/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EB%A9%94%ED%83%80%EB%B6%84%EC%84%9D/metaanalysis/2022/06/10/%EC%9D%98%EC%97%B0%EB%B0%A913)-%EB%A9%94%ED%83%80%EB%B6%84%EC%84%9D-(Revman-5-%EC%8B%A4%EC%8A%B5)-copy.html",
            "date": " • Jun 10, 2022"
        }
        
    
  
    
        ,"post46": {
            "title": "OOP2 객체지향프로그래밍(python)",
            "content": "참고 유튜브 | . 01 You can combine FP and OOP . processor.py에는 class(OOP) 뿐만 아니라 class내 메서드가 아닌 bottom에 function(FP)도 정의해서 사용한다 . . | payment.py에서도 class + function을 사용함 . . | . 02 Make classes either behavior-oriented or data-oriented . 같이 돌아다니는 데이터의 묶음도 class CreditCard의 명사로 class명을 뽑는다. . 꼭 method가 아니어도 된다. | acess하기 편하기 위해서다! 나같으면, 상위도메인과 묶어서도 쓸 것 같다. | . | . . | 이 class PaymentProcessor는 data-oriented하진 않다. behavior-oriented하여 클래스명도 ~or로 지은 것 같다. . api-key를 생성자로 받아서 체크하는 기능만 가진다. | . . | Order class는 데이터 지향적이면서, 상태값을 바꾸는 메서드가 있다. . . | . 03 Be careful with inheritance . 상속해서 새로운 level을 만들면, 부모의 변화가 자식에게 번지게 되어 복잡해진다. . 인터페이스를 위한 Protocol (typing)상속이나 추상클래스(ABC, abstract based class)를 제외하곤 상속을 사용하지 말자. | . | 인터페이스를 Protocol을 상속해서 만든 뒤, 어느 라이브러리나 class가 확장성있게 사용하도록 한다. . . | . 04 Use dependency injection . 의존성 주입하지 않고, 의존해서 사용하면? 사용되는 객체가 바뀌면 -&gt; 사용하고 있는 놈에게도 변화가 미친다. (상속(부모)도, 의존(구현클래스)도 영향 미치는 것의 문제) | . | 자바에서는 인터페이스로 추상화한 뒤 주입받는다. 다양한 의존성이 주입될 수 있음. 테스트하기 좋아짐 | . | 구현클래스와의 결합도가 낮아짐. | 가독성 좋아짐 | . | 사용하지 않은 예 . . | 의존성 주입으로 바꿈 . . 복잡한 클래스를 test시 쉬운 fake객체로 대체해서 한다. | . | . 05 Don’t abuse Python’s power features . python 내부에서 작동을 컨트롤할 수 있는 메서드를 사용할 수 있다는 장점을 가지는데, 예를들어, 매직 메서드나 인스턴스변수 등이다. 전문가가 아니라면, 재정의해서 쓰지말고, factory method를 통해 객체를 생성하자 | . | 잘못된 예시: 들어오는 string인자 값에 따라, 각 Class객체를 만들도록 한다. . 호출은 Payment(&quot;string_payment_type)으로 Payment의 생성자를 호출하지만, Payment객체는 아예 생성이 안될 것이다. | . . . | 잘된 예시 . 제한된 종류의 string은 Enum을 상속한 class로 정의여 각각을 객체로 만든다. . | 생성될 제한된 종류의 객체class들을 Protocol을 상속한 하나의 인터페이스로 만든다. . . | 각각의 class들은 인터페이스를 구현(상속)해서 정의한다. . . | Enum (key) - 구현Class(value)의 쌍을 dict로 정의한다. . class를 ()없이 value로 넣어놨다면, dict에서 get한 뒤 ()만 붙여주면 생성자가 호출된다. | . . | 사용할 때는, string대신 enum을 -&gt; dict에 넣어 -&gt; 원하는 구현체를 꺼낸다. . | | .",
            "url": "blog.chojaeseong.com/oop/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/python/2022/06/08/oop_python.html",
            "relUrl": "/oop/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/python/2022/06/08/oop_python.html",
            "date": " • Jun 8, 2022"
        }
        
    
  
    
        ,"post47": {
            "title": "OOP1 객체지향프로그래밍(java)",
            "content": "java . 참고영상:얄코 유튜브 . | 학생들에게, 교실, 청소시키기 . 청소시킬 때, 소모품들이 있다. 일정수치 이하로 떨어지거나, 용량이 일정수치로 꽉 차면, 비우는 행위를 해야함. | 타겟교실이 깨끗해졌으면 -&gt; 다른 교실로 시켜야함. | . | . 절차적 프로그래밍: 반복되는 일을 메서드추출 . 사람마다 재료를 주고 일 시키는데, 종료될때까지 매번 재료 확인해주기 . 영수에게는 새 _행주와 새 _ 윈덱스로 창문닦기()를 . 행주 _ 깨끗함이 10이하면 빨아오기() | 윈덱스 _ 리터가 1이하면 리필해오기() | 101호 다 닦았으면 -&gt; 103호로 | . . | 철권는 새 _ 쓰레받기로 바닥쓸기()를 . 쓰레받기 _ 채움이 0.9이상이면 쓰레받기비우기()를 | . . | 변수는 새 _ 지우개로 칠판닦기()를 . 지우개 _ 깨끗함이 10이하면, 털기() | . . | 혁순이는 새 _ 행주와 새 _ 윈덱스로 (102호) 창문닦이()를 . 행주 _ 깨끗함이 10이하면 빨아오기() | 윈덱스 _ 리터가 1이하면 리필해오기() | . . | 새 청소도구를 지어보내놓고, 청소()를 시켰는데도, 하나하나 if문으로 신경써줘야한다. . . | . 일이 하나가 끝날때까지, 특정 조건마다 해주는 일을 반복문 + if로 처리 . . 반복되는 역할 + 재료을 메서드(재료)로 추출하여 재사용하기 . . . 여기까지는 절자척 프로그래밍으로 가능하다. 규모가 크지 않은 곳에서는 괜찮다. | . | . 객체지향 프로그래밍 . 좀 프로페셔널하게 일하기 위해서 | . [기능과 재료만 존재 -&gt; class로 재료(필드)와 주체(인스턴스변수) + 역할까지 하는 객체로 추출] 역할에 따른 주체를 게임처럼 class를 만들고, 같은 역할을 하는 개별 사람들은, 변수명만 다른 개별변수들로 사용하자. 역할은 그 class의 method로 수행한다. -&gt; 캡슐화된 자원의 묶음 = 객체 . 창문닦을 닦던 영수, 혁순 -&gt; 창문닦이class로 뽑아서 . 역할: 창문닦기() class내 method | 창문닦이 영수, 창문닦이 혁순 같은 역할 = 같은 class = 같은 형 -&gt; List에 add후 for문 안에서 한꺼번에 일시킬 수 있음. | . | 초기재료들 상수(행주 _ 깨끗함, 윈덱스 _ 리터)-&gt; 상수 필드 | 달라지는 재료(교실) -&gt; 생성자에서 받아 초기화하는 필드 | . | . . . . | my: class는 기능의 추출 뿐만 아니라 기능에 필요한 재료(필드) + 주체(인스턴스)도 정의할 수 있다. . | . [은닉성으로 외부오류X, 외부 깔 필요X] 재료(필드)들은 private하게 class안에서 운영되니, 공개된 public의 기능을 통해 내부 private재료들을 control시킨다. . 밖에서 선생님이 행주가 깨끗한지, 윈덱스가 떨어졌는지 직접 확인하지말고, 밖에서 명령만 내려주면 내부에서 컨트롤하게 한다. . . . | 은닉성(private재료-상태값-필드 vs public으로 공개된 기능) . 바깥의 간섭으로 인해 오류가 발생할 수도 있다. | 바깥이 일일히 객체 내부를 뜯어볼 필요가 없다. | . | . [interface로 추상화한 메서드명과 형을 통일로 -&gt; 한번에 명령] 같은 class는 list에 넣어 for + 일괄명령 가능한데, 다른class의 기능까지 일괄 명령해야한다면? (전부 청소하는 기능이니) . 다른 class의 다른 기능(method)지만, 한번에 다 명령을 내리고 싶다면? . 비슷하여 일괄명령이 가능한, 서로 다른class기능들의 명칭(클래스명)을 추상화하여 인터페이스의 메소드로 정의하고, 인터페이스를 구현한 copy class(v2)들의 구혀넴소드에 -&gt; 각자의 기능이 호출되게 한다. | . | . 서로 다른 class의 서로 다른 method지만, 묶여서 한번에 호출가능한 메서드들의 method명을 1개로 추상화한 뒤, 인터페이스내에 정의한다. . 생성자로 받던 외부재료의 주입도, setter역할을 시킨다면, 생성자 대신void 메서드로 공통 추상화 가능할 수 있음. | . . | 기존 class(직업)들은 그대로 두고 copy한 class(class_v2)를 만든 뒤, 추상화한 메서드명세를 가진 인터페이스를 구현하고, 그 추상화된 메서드 내부에는 비슷하지만, 명칭과 기능이 다른 자신의 메서드를 호출해준다. . . | 이제 서로다른class지만, 자신의 기능을 수행하는 동일한 메서드명(명세)로 호출 가능해지며, 인터페이스 구현으로 인해 동일한 list에 모을 수도 있어진다. . . . | 메서드명만 통일한다고 해서, 한번에 묶을 순 없다. 메서드명을 추상화한 인터페이스 | 그 인터페이스를 변수로 사용하면 한번에 묶을 수 있다. | 같은 메서드명 + 묶여진 상태 -&gt; 한번에 일을 내릴 수 있다. | | . [인페구현 객체들을 모아 그룹을 만드는 class] 기존 재료를 모으고 주체를 나누던 class가, &lt;같은 인터페이스를 구현하여, 모을 수 있고 + 한번에 일 시킬 수 있는 객체들&gt;(인스턴스)을 모아 그룹을 만들때도 class로 모은다. . my) 동일한 객체들을 list로 모으는 일급컬렉션 뿐만 아니라 같은 카테고리 아래(구현, 상속)의 객체들을 모으는 group class도 뽑아낼 수 있다. group으로 모으고 일을 한번에 시키려면, 같은 인터페이스 구현 class들의 객체들을 모아야할 것이다. | . | 개별 학생 -&gt; 역할이 같은 학생 by list -&gt; 전체 학생 by 인터페이스 -&gt; 그룹별 학생들에게 한번에 일을 시킬 수 있다. . | 각 청소인원들(class로 역할이 다를 지라도 인터페이스 구현 객체(변수)들)을 그룹을 지어보자. . 창문닦이들, 바닥쓸이들 객체들을 생성자에서 초기화해주고, 필드아래 배열로 묶어놓았음. | 외부에서 그룹인원 전체에 대한 청소완료를 물어볼 수 있음 | 그외 묶어서 그룹 객체들에게 일을 한번에시킬 수 있다. | . . . | . [상속을 통해 기존기능에 일부기능 추가하기] 새로운 재료와 역할이 추가된 class를 만들 때 상속을 이용한다. . 기존 재료(필드들)은 안보이지만 쓸 수 있다. . 대신, 자식생성자에서 super()로 안보이지만 부모생성자를 이용해서 초기화해줘야한다. | . | 새로운 재료는 필드로 선언해주고 생성자에서 추가해줘야한다. . . | . [공통재료를 묶어 카테고리만 만드는 추상클래스] 추상클래스는 객체를 못만들기 때문에 카테고리만 만들어, 공통 재료 or 기능만 묶어준다. . my) 메서드 공통이 아니라 재료 위주의 공통일 때도 추상클래스로 뽑아서, 상위 카테고리를 만들 수 있다. 인터페이스는 같은형 &amp; 추상화한 메소드명으로 한번에 일 시키기의 기능method 위주의 목적이지만, 1개의 class에 대해 메소드명 추상화로 인터페이스 추출 후 -&gt; 쉬운 class로 대체하여 test or 다른 class로 확장 가능성에 쓰이기도 한다. | . | 여기의 예에서는 창문닦이/바닥쓸이/칠판닦이의 객체class들이 이미 같은 인터페이스 구현으로 상위카테고리를 가진 것 같은데도, field(재료) = 청소할 ClassRoom의 공통으로 추상클래스 = 상위카테고리를 추출하고 있다. . | 공통 인터페이스: 청소담당 창문닦이/바닥쓸이/칠판닦이 | . | 공통 필드로 추출한 추상클래스: 교실_청소당번 창문닦이/바닥쓸이/칠판닦이 | . | . . . . 공통 필드를 추상클래스로 옮겨야한다. . | 해당 필드 관련 기능들도 옮긴다. . 인터페이스에 있던 청소()와 교실_이동() 역시 옮겨야한다. | . . | 추상메서드로서 비워놓고, 상속class마다 서로 다른 자신의 기능을 구현하면 된다. . . | 인터페이스처럼 한번에 일 시킬 수도 있다. . . | 한번에 일 시키기 상속 vs 인터페이스 차이 . 상속은 1부모 밖에 안된다. . 한번에 일시키는 놈들이 제한된다. | . . | 인터페이스는 구현만 하면 어느클래스든지 같은형으로서 한번에 일시킬 수 있다. . 인터페이스는 해당class에 장착만 시키면, 부모여부, 상속여부 다 필요없이 어느 class든 같은형으로 묶여서 한번에 일시킬 수 있다. | . . | . 느낀점 . 인터페이스는 다른class를 메서드명만 통일시켜 구상체로 사용할 수 있게끔, 확장을 위해서 사용했다 test를 위한 쉬운 코드를 또다른 구상체의 기능으로 만들면 됬다. | . | 하지만, 인터페이스를 어느class든 장착하면 같은형으로 모아 한번에 일시키기 위한 목적으로도 사용된다. 또한, 자신의 원래 메서드명을 통일시킬 필요없이 추상화된 메서드명을 구현한 뒤, 그 내부에서 자신의 메서드를 호출만해줘도 된다. | . | 추상클래스는 필드의 공통 -&gt; 그 필드가 사용되는 기능들과 함께 카테고리를 만들 수 있다. 그게 아니라면 인터페이스를 장착시키면 될 것 같다. | . | .",
            "url": "blog.chojaeseong.com/oop/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/java/2022/06/08/oop_java.html",
            "relUrl": "/oop/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/java/2022/06/08/oop_java.html",
            "date": " • Jun 8, 2022"
        }
        
    
  
    
        ,"post48": {
            "title": "excel shortcut & HorizontalScroll",
            "content": "상단 메뉴에 빠른 도구 모음 사용자 지정 버튼을 눌러서 리본 메뉴 아래 표시를 선택한다. . | 다시 한번 선택한 뒤, 사용자 지정 도구모음을 위해 기타 명령(M)을 선택한다 . | 모든 명령으로 표시해놓고 아래 목록(가나다순)으로 하나씩 추가한다 . 가운데 맞춤 (개체 아님) | 굵은 바깥쪽 테두리 | 글꼴 색 | 글꼴 크기 작게 | 글꼴 크기 크게 | 병합하고 가운데 맞춤 (그냥 병합 아님) | 서식복사 | 열 너비(추가) | 왼쪽 맞춤 (개체 아님) | 채우기 색 | 테두리 없음 (모든 테두리) | 행 높이(추가) | | 명령을 아래 그림 순서대로 배열한다. 열 너비(08) | 행 높이(07) | . | 엑셀에 횡 스크롤을 shift + wheel로 할 수 있게 해주는 프로그램 설치 링크 | . | 센스 . 데이터 붙여넣기 insert into values의 내용 복붙 후 | 우클릭 -&gt; 선택하여 붙여넣기 -&gt; 유니코드 텍스트(쉼표 분리도 자동으로 됨) or 텍스트 -&gt; 데이터탭-텍스트 나누기 | 찾아바꾸기(ctrl+H)로 쓸데없는 문자들(괄호, 따옴표) 제거 | |",
            "url": "blog.chojaeseong.com/excel/shortcut/horizontalscroll/2022/06/07/excel-setting-for-DataAnalysis.html",
            "relUrl": "/excel/shortcut/horizontalscroll/2022/06/07/excel-setting-for-DataAnalysis.html",
            "date": " • Jun 7, 2022"
        }
        
    
  
    
        ,"post49": {
            "title": "OBJECT 16-2 여러 전략객체를 위한 상속과 다시 합성으로변경",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . 구상체들이 다음 타자를 가지는 방법(next 외부체이닝 받기 -&gt; 내부체이닝 메서드 호출) . 달라진 부분 2가지 확인하기 . . result라는 재료를 받았지만, 전략객체는 여러개의 call을 돌면서 result에 누적하여 파라미터 result는 값이 아닌 상태 변화하여 다음 caclulator한테 가고 반환되는, 부수효과가 있는 context객체라는 증거를 확보하여 연결되는 합성객체임을 확인할 수 있다. 인자가 똑같은 값이 아니라 변하는 인자는 delegate(위임) = 부수효과가 있는 context가 공유되는 것 | . | context인 result는 현재 전략객체에서 다음 전략객체 next에게 넘아갈 수도 있다. 다음 할인이 있다면, 생성자에 다음전략객체가 | 다음 할인이 없다면, 생성자에null이 올 수 있다고 생각한다. | 현재 전략객체의 calls돌면서 전략 적용후 next == null? result(리턴) 아니라면 : 다음 전략객체.전략메서드( calls, result)로 바통 넘겨주기 | . | . 전략객체가 동일형 다음 타자를 받고 꼬리호출로 다음타자의 전략메서드를 호출할 수 있다. . PricePerTime . . 재귀함수처럼, 마지막에 다음 n에서 내일 을 이어받을 함수를 호출한다. 같은 전략메서드 = 주체가 같은형.반환이 같은 전략메서드()의 꼬리 호출인 마지막 return에서 종착역(null터미네이팅) &amp;&amp; 반환값이 같은 전략메서드()로 내부 체이닝하는 것이다. 외부에서 체이닝할라면, VO처럼 반환값과 다음 주체가 같은형이어야함 | 내부 체이닝은, return문에 재귀함수처럼 종착역(null터미네이팅) + 같은 반환값의 메서드를 호출해야한다. | . | . NightDiscount . . 마찬가지로, 다음 타자를 가지고 있으면 전략메서드로 넘겨주고, 아니면 결과값을 return . | Plan은 1개의 Calculator만 알고 있지만, 발동만 시키면, 시작 Calculator(전략객체)가 옆 친구전략객체를 알고있는 것 유무에 따라 더 전진될지 안될지가 결정된다. . 동적으로 연결된다고 한다. | 객체지향은 linked List밖에 없다. next node가있으면 가고 없으면 스탑이다. | . | . | . Tex (마찬가지) . . calls 전체에 영향을 안받아서, result context만 갱신시킨다. | . AmountDiscount (책: LateDiscountPolicy) . . Main . . plan에 맨 처음 적용될 전략객체는 PricePerTime이고 나머지들이 이어진 다음 전략객체들이 생성자 next자리로 들어온다. 재귀의 마지막 부분을 터미네이팅시키는 null을 생성자에 넣어줘야 끝난다. | . | . 데코레이터 패턴은 이상한 모양 . . 생성자에서 다음 타자를 받는 이상은 장풍모양이 된다. | . 중복제거 및 고도화 . . 모든 전략객체들이 next를 받아서 저장하고, 관리하는 코드가 똑같다. 부모로 묶어야한다. | . | 부모로 묶을 때 조심해야할 부분: 공통 상태(next)를 가지고 있으면 얄쨜없이 abstract로 묶어야 한다. | . abstract Calculator . . 부모 -&gt; 전략 인터페이스에서 -&gt; 추상클래스로 추출해야한다. | . . 구상체(전략객체)들은 다음타자를 생성자로 받았으나 좋은 부모는 생성자로 받질 않는다 -&gt; 초기화없는 필드에 setter받기기능으로 받아야한다. . | null터미네이팅이 존재하는 필드기 때문에, 다음 타자가 없으면 안넣어주고 그대로 null을 유지하면 된다. . | 또한, 외부 체이닝을 통한 여러개 받기기능을 위해 받기기능 주체자와 동일형의 context인 this를 반환하여 외부에서 받기기능을 체이닝 할 수 있다. . 내부 체이닝: 재귀함수 -&gt; return에 반환형이 똑같은 메서드로 호출 **(구상체)매번 다음 타자를 받거나, (추상체)외부체이닝을 통해 여러개를 받은 다음타자들을 -&gt; null터미네이팅과 함께 return꼬리호출부에 다음타자들을 호출시킴. ** | . | 외부 체이닝: 메서드내 상태 변화 후 메서드를 호출한 주체와 동일한 형(아직 안생긴 객체면 new 생성자() , 이미 존재하는 객체면this)을 반환 내부체이닝을 위해, 외부재료를 외부체이닝(return this)하면서 여러개 받기기능 | . | . . | my) 추상체에서 this는 구상체가 사용하며 구상체 자기자신이다. . next구상체를 받는 메서드 내부라서 헤깔릴 수 있지만, 추상체는 구상체가 쓸 내용만 제공하므로, 추상체 속 this는 호출하는 순간은 구상체 자신이다. | . | . . 전략메서드 구현의 다른부분은 다시 훅으로 뿌려주고, 전략 메서드 및 내부 공통 부분을 템플릿 메서드로서 담는다. | . 좋은 부모인지 확인 . 자식들을 위해 생성자가 없다 | public, final 아니면 abstract proteced 메서드만 있다. | Plan(전략 적용객체)는 코드가 바뀐게 없음. . . 전략객체 받기 -&gt; 템플릿 구상체들 받기 | . 중복제거된 구상체들 확인 . PricePerTime . 기존 | . . 중복제거 by 추상클래스 | . . 다음 타자받는 로직이 부모로 넘어간 덕분에, calls + result 계산기능 외에는 본인의 책임만 가진다. | . 좋은 자식인지 확인 . 상태들 모두 자기것 (부모 것X) -&gt; 부모변화와 무관 | 훅메서드구현으로 부모에게 정보 제공만 함. (부모를 몰름) -&gt; 부모 변화와 무관 result만 갱신해서 넘겨주는 service 제공 | . | NightDiscount . . Tex, AmountDiscount . . Main 사용법이 바뀜 . . Plan은 확장(상속) 가능성 있는 class로서 받기기능으로 첫번째 템플릿구상체(구 전략객체)를 받기기능으로 받아들이게 된다. | 첫번째 들어가는 Calculator템플릿구상체는 외부 체이닝 받기기능 in 추상클래스 받기기능에서 return this(메서드 주체를 반환)을 통해 체이닝으로 2번째 Calculator구상체를 받을 수 있다. this가 반환되면 또 Calculator이며, Calculator는 원래 setNext(체이닝 받기기능)이 존재한다. | . | . 상속을 다시 합성으로 . 상속이 나오면 무조건 합성으로 다시 바꾸기 | . . 좋은 상속은 기계적으로 합성으로 바꿀 수 있다. . | Calculator자체가 구상클래스화 -&gt; 훅메서드 부분의 전략객체화 . | . 합성(전략)으로 변경되는 Calculator . . 추상클래스의 this반환을 활용해서 다음 타자를 외부체이닝으로 구상체별 다음타자 받기를 구현했지만, 합성으로 변환하는 순간 추상클래스 -&gt; 구상클래스가 되므로 추상체this를 이용한 구상체별 외부체이닝으로 다음타자 받기가 불가능해진다. | 추상클래스에서 다음타자next를 소유하는 방법 정리 자식이 물려받아서 쓸 next 필드는 초기화없이 null상태로 선언 | 받기기능으로 받되 없으면 null그대로. 있든 없든 추상체this를 return해서 사용 구상체 자기자신 반환 | 사용처에서는 null터미네이팅이 적용된 내부체이닝으로 연쇄호출 개별 다음타자 소유 -&gt; 재귀함수 호출 | . | | next로 소유하는 방법을 버림 -&gt; 위 3가지 다 버림 . 다음타자의 전략메서드 호출을 내부 체이닝 - 재귀함수처럼 호출했지만, 재귀함수는 forloop로 바꿀 수 있다. | 개별로 다음타자 소유 -&gt; 재귀함수처럼 호출이 무의미하다 | . | 상속-재귀로 다음타자 호출 -&gt; 합성-forloop로 모든 타자 컬렉션을 호출 . 개별로 다음타자를 가짐 -&gt; 구상클래스가 모든 타자를 컬렉션으로 가짐으로 변경 cf) HashSet은 순서가 보장된다. | . | . . 여러개 받기기능이라도, 구상클래스이므로 필수 1개를 받도록 생성자 주입후 add 하나는 필수이며, 나머지는 list로 받아들이는 경우가 많기 때문에, 이렇게 sample로서 구현 | . | 이후 여러개 받기기능처럼 setter받기기능으로 add하되, return 구상체this는 개별 외부체이닝이 아닌 자신 상태를 외부체이닝 | . . 개별 다음타자 재귀호출이 아니라 복잡한 객체간 통신 | . | 모든 타자 forloop돌면서, result상태 업데이트 | . | . 훅메서드 대신 태어난 Calc전략인터페이스 . . . . 또 달라진 Main 사용법 . 상속 -&gt; 개별로 다음타자 가지기 -&gt; 재귀호출 . 첫번째 구상체객체부터 시작하여, 개별로 다음타자 체이닝해서 받기 | . . | 합성 -&gt; 모든 타자 받기(체이닝 유지) -&gt; forloop호출 . 구상class 1곳에서, 모든 다음타자 체이닝해서 받기 | . . | 상속 모델의 호스팅 -&gt; 구상클래스가 전략객체들을 소유모델로 소유 | 원래 Plan도 Calculator들을 전략객체들을 소유모델이었음. 하지만 전략객체들이 중복코드로 상속모델이 됨 다시 한번 상속모델을 구상클래스 + 전략객체들 소유모델로 변경 | . | . | 기존: Plan &lt;- 전략Calculator들 소유 변경1: Plan &lt;- Calculator부모 &lt;- 자식들 변경2: Plan &lt;- Calculator &lt;- 전략Calc들 | . | . | 그럼 Plan도 단일객체고, Calculator도 단일객체니 2개를 합치면 안되나? . 합성과 상속을 반복해보면, 처음 설계한 역할이 명확하지 않다는 것을 알게 된다. | DB상 1:1상태 -&gt; 합치면 되는 비정규화 상태 | . . | 의사결정 Plan이 또다른 계산방식 추가(멤버등급별 요금계산)이 없이, 오로지 Calculator에 의해서만 요금계산이 끝나면, 합쳐도 된다. Calculator는 정확하게는 CallsBasedCalculator 전략객체로 개별 계산해주되, 큰 로직은 계산의 재료를 calls만 받아서 처리하기 때문이다. | . | **개별계산방법이 오로지 전략객체의 전략메서드 특성상 1개의 로직 재료 calls에 대해서만 개별 처리해주는 것이기 때문에 ** | . | 하지만, calls이외에 다른 로직에 의해 요금계산도 추가된다면? Plan과 Calculator(calls로 요금계산)을 1:1이라고 합치는 순간 Call에 기반한 요금계산만 Plan에서 이루어지게 된다. 전략객체들을 직접적으로 Plan에 주입하면, 카테고리 1개의 개별처리밖에 못한다. | . | Plan는 calls이외에 회원등급기반 요금계산도 전략을 통한 개별처리로 처리되어야한다 | . | . | 개별처리를 위한 적용대상(Plan) + 구상클래스 + 전략객체들형태를 유지하면 다른 카테고리의 개별처리도 적용대상에게 구상클래스로 주입할 수 있다. 다른 카테고리의 개별요금처리를 위해서라도, 적용대상 &lt;-&gt; 전략구상클래스를 합치지말자. 요금계산에는 멤버쉽, 국가유공자, 나이별, VIP(충성고객) 여러 카테고리가 남아있다. | . | . | 의사결정하는 가운데, 실제이름도 알게 된다. Calculator는 포괄적인 이름이다. 전략패턴이 담당하는 카테고리가 있다. ~Based 전략메서드가 처리담당하는 메서드 인자로 판단하여 ~기반의 개별처리밖에 안된다. Plan과 Calculator가 단일class라고 해서 동급의 레벨이 아니였다. Plan 한참 아래의 Call기반의 Calculator: **Plan이 골라야하는 메뉴중 1개 ** calc들 | . | . | . | . | . . 다시 메인을 보면 plan에 들어가는 Calculator는 일반명사처럼 생겼지만, 콜 기반의 요금 계산만 해주는 콜 카테고리 계산기로서 1개의 계산기일 뿐이다. | Calculator는 plan입장에서는 여러가지 요금계산 계획중에 1개의 요금계산을 위임한 녀석이다. CalculatorBasedOnCalls call에 따른 3가지 전략(개별처리)들을 처리해주고 있다. | . | . | new Calculator(콜기반요금계산) 외에 | Plan은 new CalculateBasedMemebr()와도 결합할 수 있을 것이다. | . | Plan - Calculator - 전략Calculator의 3단이 맞냐? 이름에 현혹되지마라. 3단이 맞다. Plan + Call기반 구상클래스 + 주입되는 전략객체들 | . | Calculator라는 추상화된 좋은 이름을 가질 수있냐 의심해봐야한다. 계산하되 call기반으로만 계산하고 있으며 다른 카테고리의 CalculateFee도 할 수 있다. | 일반명사로 만들었다면, 의심해라 나는 자격이 없다. Calculator정도의 이름은 팀장아니면 실장만 달 수 있다. | . | . | . 합성(구상클래스 + 전략객체들)했을 때의 유혹 . . Plan이 Calculator와 직접적은 결합은 하지 않지만, 내부결합의 유혹을 많이 받는다. 왜냐면, 다른 카테고리의 Calculator가 나오기 전까지 plan만들 때마다 new Calculator()가 반복된다. | 어차피 plan만들면, setCalculator( new Calcuator())를 할 것이니 내부에 감추고 싶다. + 나머지 추가 전략객체들을 받는 것도 뻔하게 나머지 전략객체들을 setNext하겠지의 유혹 성급한 최적화다. | . | . | . 성급한 최적화(전략객체를 받아주는 구상클래스를 내부로 통합) . . 일반명사를 가지며, 바뀌지 않을 것 같고 반복되는 -&gt; 전략주입용 구상클래스 Calculator를 변하지 않는 것으로 간주하며, 반복된다고 생각하여 Plan내부로 넣는 성급한 최적화를 하고 싶은 유혹에 빠져든다. 하지만, Calculator는 사실 CalculatorBasedCalls이며, 전략주입 구상클래스는 다른 전략으로 바뀔 수 있는 클래스임을 망각한 것이다. | . | . setCalculator가 아니라, 전략객체들을 가변배열로 받는 setCalculators()로 주입한다. new Calculator()부분을 client에서 제거함. | . | 전략객체들을 for문으로 돌되, 첫번째 요소를 지나면 flag를 false로 놓고 작동안하게 하는 isFirst플래그를 만들어놓고 for문을 돌면서 . 첫번째 전략객체만 -&gt; 전략주입 구상클래스의 필수 1개 생성자로 주입되고 | 2번째부터는 구상클래스.setNext( 다음 전략 ) 외부체이닝으로 받아준다. | . | 그러나 전략패턴이 구상클래스 + 주입전략객체들 + 전략인페의 구성이 이루어졌다면 보통 같으면 구상클래스 없이 전략인페 + 주입전략 객체들이지만 | 구상클래스를 둠으로서 여러 전략객체들을 여러개 적용할 수 있는 구조를 마련했다면 그 구상클래스도 전략의 일부분일 뿐이며, 일반명사로 쓰고 있다고 해서 바뀌지 않는 부분이 아니다. 전략적용 객체에 주입될 때, 언제든지 다른 카테고리의 전략주입 구상클래스로 대체될 수 있음을 생각하자. | . | . | .",
            "url": "blog.chojaeseong.com/object/2022/06/03/((object1-16-2)%EC%97%AC%EB%9F%AC_%EC%A0%84%EB%9E%B5%EA%B0%9D%EC%B2%B4%EB%A5%BC_%EC%93%B0%EA%B8%B0%EC%9C%84%ED%95%9C_%EC%83%81%EC%86%8D%EA%B3%BC_%EB%8B%A4%EC%8B%9C%ED%95%A9%EC%84%B1.html",
            "relUrl": "/object/2022/06/03/((object1-16-2)%EC%97%AC%EB%9F%AC_%EC%A0%84%EB%9E%B5%EA%B0%9D%EC%B2%B4%EB%A5%BC_%EC%93%B0%EA%B8%B0%EC%9C%84%ED%95%9C_%EC%83%81%EC%86%8D%EA%B3%BC_%EB%8B%A4%EC%8B%9C%ED%95%A9%EC%84%B1.html",
            "date": " • Jun 3, 2022"
        }
        
    
  
    
        ,"post50": {
            "title": "window terminal 단축키 매핑",
            "content": "Window Terminal 단축키 설정 . vscode와 비슷하게 추가 매핑해준다. . actions 부분에 추가해주면 된다. | . { &quot;command&quot;: &quot;find&quot;, // 검색키 매핑 // &quot;keys&quot;: &quot;ctrl+shift+f&quot;, &quot;keys&quot;: &quot;ctrl+shift+f&quot; }, // 수직분할 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;vertical&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+plus&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;vertical&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;ctrl+ &quot; }, // 수평분할 매핑(추가) //{ &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;horizontal&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+-&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;horizontal&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+0&quot; }, // 탭 끄기 매핑(추가) { &quot;command&quot;: &quot;closePane&quot;, &quot;keys&quot;: &quot;ctrl+w&quot; }, // 포커스key 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;down&quot; }, &quot;keys&quot;: &quot;alt+down&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;down&quot; }, &quot;keys&quot;: &quot;ctrl+alt+down&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;left&quot; }, &quot;keys&quot;: &quot;ctrl+alt+left&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;right&quot; }, &quot;keys&quot;: &quot;ctrl+alt+right&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;up&quot; }, &quot;keys&quot;: &quot;ctrl+alt+up&quot; }, // 창이동 단축키 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 0 }, &quot;keys&quot;: &quot;ctrl+alt+1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 0 }, &quot;keys&quot;: &quot;ctrl+1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 1 }, &quot;keys&quot;: &quot;ctrl+2&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 2 }, &quot;keys&quot;: &quot;ctrl+3&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 3 }, &quot;keys&quot;: &quot;ctrl+4&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 4 }, &quot;keys&quot;: &quot;ctrl+5&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 5 }, &quot;keys&quot;: &quot;ctrl+6&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 6 }, &quot;keys&quot;: &quot;ctrl+7&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 7 }, &quot;keys&quot;: &quot;ctrl+8&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 8 }, &quot;keys&quot;: &quot;ctrl+9&quot; }, // Rename a tab to &quot;Foo&quot; { &quot;command&quot;: { &quot;action&quot;: &quot;renameTab&quot;, &quot;title&quot;: &quot;server&quot; }, &quot;keys&quot;: &quot;f1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;renameTab&quot;, &quot;title&quot;: &quot;jupyter&quot; }, &quot;keys&quot;: &quot;f2&quot; }, . | .",
            "url": "blog.chojaeseong.com/configuration/windowsterminal/shortcut/2022/06/02/windows_terminal_shortcut.html",
            "relUrl": "/configuration/windowsterminal/shortcut/2022/06/02/windows_terminal_shortcut.html",
            "date": " • Jun 2, 2022"
        }
        
    
  
    
        ,"post51": {
            "title": "screen to gif(짤 생성)",
            "content": "screen to gif를 검색해서 프로그램을 다운 받는다. . | 설정 프로그램: 수동으로 시작 + 복수의 프로그램 허용 | 처음화면: 화면녹화기 | 색 설정: 중간 | 모든 창이 닫혀 있어도 프로그램을 종료하지 않습니다. | 트레이 &gt; 종료 체크해제 | 업데이트 확인 2개 체크해제 | . | 녹화기: 새 버전 체크 | 녹화모드: BitBit -&gt; DirectX 체크 -&gt; BitBit 체크유지(DirectX 체크시 에러남) | 기타: 이전 녹화구역 저장 체크해제 | 기타: Ask me before discarding the recoding 체크해제 이것을 체크해제해야 F7 -&gt; F9(취소)시 종료메세지 안물어본다. | . | . | 편집기: 색 설정: 중간 | 일반: 확인하기 3종 체크 해제 | 인코딩을 별도 창에 표시합니다 체크 | . | 기타: FFmpeg 다운로드후 경로 지정: 동영상 &gt; screentogif폴더생성 &gt; 저장 | . | 단축키: 화면 녹화기:ctrl+alt+shift + F12 이 설정을 해주고 직전 편집기(캡처 후 저장하는 창)상태에서 하나 더 켜놔야, (편집기 종료 -&gt; 프로그램 종료) 추가로 gif촬영을 지속할 수 있다. | 만약 편집기를 [닫기]하면, 프로그램 자체도 종료되어버린다. 만약, 녹화기가 추가로 열리면, 편집기 닫아도 프로그램 안꺼진다. | 편집기 상태에서 다음 촬영할거면, 하나 더 켜두자. | . | 종료: ctrl+alt+shift + F4 | 녹화 취소 &gt; F9 녹화 취소할 때, 중지(F8) -&gt; 취소(F9) 연타 치면 된다. | . | . | 편집기-저장탭(첫 녹화 종료F7-&gt;F8시 설정 가능) 파일종류: 2번째를 screentogif -&gt; FFmpeg - high qualyity 선택 | 중복 픽셀 감지 체크해제 | 지정 경로에 파일 저장하기 체크해제 | 클립보드에 복사하기 체크 &gt; 파일 선택 | 세팅이 끝난 뒤, autosave 탭 &gt; +해서 저장시키기 | . | | 단축키 사용하기 ctrl+alt+shift + F12: (프로그램 킨 상태)화면 녹화기 바로 켜기 활용은, 첫번째 촬영 후, 편집기를 닫기 전에, 추가촬영을 이어가야할 때, 미리 하나 켜둔다. 안켜두면 프로그램 종료 | . | F7 : 녹화 시작 -&gt; 일시 중지 | F8: 녹화 종료 및 편집기 열기 | F9: (F7 2번 눌러 일시중지 상태시) 녹화 취소 F7 녹화 중에 F7-&gt; F9 연달아서 사용 | . | Ctrl+S: (편집기 열린 상태) 녹화한 것 저장 | (편집기에서 저장까지 끝난 상태)Ctrl+N: F7 -&gt; F8로 편집기 -&gt; 저장후 다시 녹화기로 돌아갈 때 안하면, 편집기 껐다가 녹화기 다시 켜야함. | . | ctrl+alt+shift + F4: 프로그램 종료 | . |",
            "url": "blog.chojaeseong.com/configuration/windows/git/screentogif/%EC%A7%A4/2022/06/02/screen_to_gif.html",
            "relUrl": "/configuration/windows/git/screentogif/%EC%A7%A4/2022/06/02/screen_to_gif.html",
            "date": " • Jun 2, 2022"
        }
        
    
  
    
        ,"post52": {
            "title": "OBJECT 16-1 좋은 상속을 합성으로 변경(코드스핏츠)",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . 상속과 확장(11장) . 11장에 대한 코드의 변형이 많을 것이다. 코드가 많이 나올 것이다. | . | 11장의 앞부분은 solid원칙 or solid원칙 확장 이야기 객체지향을 위한 억지스런 코드들도 등장함 | . | . point of point . 11장부터 끝까지 후반부 실제 JVM, c++컴파일러가 어떤 형식으로 실제 컴파일 결과를 만들어내는지 | 그 시스템을 우리가 어떻게 이용해서 객체지향을 구현하는지 | 주 기법은 포인터의 포인터 = 레이지 바인딩 직접 그 대상을 알지 않고, 그 대상을 알고 있는 놈을 알고 있어서 물어봐서 알기 | . | 메모리에 올라갈 때는 linked list 그 이상도 그 이하도 아니다. 인터페이스 - 추상클래스 - 구상클래스 - 메서드로 찾아들어간다는 것 찾는 메소드가 얘한테 없으면 쟤, 쟤한테 없으면 얘 등 찾아들어가는 linked list다 | . | 우리가 개발할 때는, 사람들이 이해할 수 있는 블럭들을 줘야한다.(linked list로 일렬로 연결하면 안됨) 객체지향적으로 사고할 수 있는 공통적인 사고의블럭(틀)을 먼저 줘야, 그 안에서 블록을 이용해 자유롭게 구현이 가능해진다. | . | . | . 상속(inherit) . 유산을 물려 받는 것 | 상속은 이미 사망한 사람한테만받을 수 있다. 객체지향에서 상속이라는 말이 어울리지 않는 이유 | 살아있는데 물려주는 경우 = 증여 | . | 상속했다? = 유산은 가지고 있지만, 망자와는 교감을 할 수 없다 | . 증여(bestowal) . 증여 해준 쪽과 외적(» 내적) 상호작용할 수 있다. 상속과 증여는 모두 40% 세금을 뗀다 증여가 아까울 것 같지만, 아파트의 경우, 가격이 오른다고 가정해서 아들이름으로 증여후 사면 40% 세금은 아무것도 아니다. | . | . | 증여받고도 괴롭히면 싫다. 오피스텔 물려줬는데, 또 와서 용돈달라고 하는 자식.. 증여한 것으로 먹고 살아야하는데… | . | 재산 외적으로 교감은 환영한다 자식이 놀러가자고 하면 좋다. 근데… 위에처럼 증여해줬는데도 내적으로 상호작용하면 싫다. | . | . 확장(extend) . 원래 A가 있었는데, 상속받은게 아니라 덧붙여야 확장이다 . 프로그래밍에선 확장이 extend 외에 + overriding, overloading도 있다. | 확장 : 덧붙이기외에 뜯어내기 등 구조변경, 용도변경 등을 다 포함한 단어 | . | 프로그램 짤 때, 자동차에 날개를 달면 안된다. 확장수준이 아니다. . 처음부터 따로 작성되어야한다. 이게 힘들다. 어느 순간 따로 만들어야겠어가 나와야한다. 이 판단을 할 줄 알아야함 | 확장은 점진적인 변화만 인정해준다 | . | . 유산을 물려받지 말 것 . 점진적인 변화만 인정한다. 부모로부터 물려받지 마라 오버라이드 하지말라는 뜻이다. | 물려받을 수 있는 유산 2가지 프로텍티드 하지말라는 뜻이다. | super 쓰지말라는 뜻이다 | public은 논외다. | . | . | . 대리역할을 하지 말 것 . Type만, 한 카테고리에 있음만 나타내면 된다. | . 오히려 확장하는 쪽이 부분 책임만 질 것 -&gt; 가장 이상적인 extends관계 -&gt; 점진적이면서 부수적인 주인공이 아닌 놈이 되어야함 . 수동적인 관계처럼 보이지만, 원래 그놈이 모든 일을 다하고, 확장하는 쪽은 딱 1가지 일만 하도록한다 | 객체지향에서 확장된 쪽은 굉장히 부수적인 책임만 가져야한다 점진적 + 부수적이어야한다. 주인공이면 안된다. | . | . 2가지 나쁜확장 . 나쁜 확장 1: (생성자, 기능)super는 나쁘다. . super는 다 나쁘다 super의 구체적인 작동 생성자: 생성자 체인으로 바로 super를 사용 | 나머지: super.으로 사용 -&gt; 부모의 메서드를 부르는 것 | . | . | . 약간만 보태면 될 것 같아서… . result를 해결하기 위해 base라는 클래스를 만들었다. . | result2라는 문제를 다음날 받았는데, 어제만든 base에서 약간만 보태면 될 것 같다 -&gt; extends . 문제점: result2를 result의 부분집합으로 판단했다 | 문제점2: result를 불변한다고 본 것 | . . **어떤 문제의 부분집합문제라고 봤던 result는, 현실에서 불변이 아닐 수 있다. ** | . . 문제가 변했다고 base를 바꾸려할 것이다… | . . 이 순간 result2는 base가 달려저서 더이상 문제해결이 안된다. | . . | super를 쓰면 반드시 망가진다. 기존 문제는 불변이 아니다. -&gt; 확장을 부분집합형으로 해결하는 방법은 다 망가지게 되어있다. (약간만 보태서 확장하면 해결될 것 같은 사고방식은 망가진다) -&gt; 점진적+원래 역할외 부수적인 역할만 해야한다. . 나쁜 확장 2: (기능, 메서드)override는 나쁘다 . 미묘해서? 나쁘다. 내가 여보를 사랑해 | 나의 자식이 여보를 사랑해?? 깔려있는 어마무시한 context를 알고 있기 때문에 | . | . | . base의 기능호출 -&gt; 동그라미 모양(=Type ex&gt; integer)으로 나온다. . 객체지향은 Type으로 말을 하므로 작동결과를 Type으로 알 수 있다. . . | . | base를 @Override하면, 응답값 = Type = 나오는 모양은 같다. . 오버라이딩하면, 네모 모양으로 나오지 않을 것이란 것을 안다 | . . 동그라미형으로 Return될 것이다. | . . 개발자들은 여기서, 나는 오버라이딩해서 부모의 context를 유지할 수 있을 것이라고 생각한다. 부모의 응답Type을 보고서, 나도 오버라이딩한 다음 응답Type만 맞춰주면 될 것이라고 생각한다. | . | . | Type모양, 카테고리만 맞춰준다고 해서, 부모의 context를 다 충족한 하며 + 추가 확장기능이 생긴다고 말할 수 있을가? . 예를 들어, 과목 전체 평균을 내주는 base에 대해, override이후 과목 전체 평균 + 과목별 평균도 내어주도록 확장했다? base는 보안성 때문에 일부러 과목별 평균 안내고 있던 상태인데? | base의 최종 Type만 override한다고해서, 내부 context와 다른 것들과의 관계를 다 알수도, 재현할 수도 없기 때문에 override를 쓰면 안된다. | . | . | 바보가 아니므로 부모(응답)Type을 맞춰줄 순 있지만, 내부 사정 + 외부여파의 context를 정말 다 파악해서, 같은 context를 유지할 수 있을까? 못한다 -&gt; 오버라이드가 성공하는 경우는 없다 -&gt; 어느 모듈은 나혼자가 아니라 내 내부 + 외부 관계된 context들로 정의되기 때문에 -&gt; extend는 override하지말고 써라 . 좋은 확장 . 조건1: super 대신 부모생성자는 인자받지X + 부모메서드는 final, private, abstract protected를 써라 . . final, private으로 자식이 못쓰게 하거나 | abstract면서 protecetd으로 자식이 쓰되 부모는 동작X -&gt; 기능X -&gt; context X면서 Type만 정해준다 super function 사용X | super Type만 사용됨. | . | super는 메서드외에 부모생성자 호출로도 사용되는데 부모생성자가 인자를 안받으면, 자식은 호출할 일이 없어진다고 한다. | . | 인터페이스는 이 조건1의 2가지를 강제한다 추클을 쓸 뗀, 이 2가지 제약을 걸어주자. | . | . 조건2: 부모 메서드에 3가지 . . 조건1에서 메서드에 걸어둔 3가지를 고수하면, 오버라이드를 할 수도 없다. | . 부모메서드에 final + private + abstractprotected 3가지를 외우자. 모던랭귀지(코틀린)는 내장하고 있다. . 우리가 상속을 사용하려면, 부모메서드가 final or private or abstract protected로 만들고, 생성자는 인자를 받지마라 -&gt; 만약 지킬수 없는 상황이라면? -&gt; 이때서야 상속을 포기하고, 합성해라 -&gt; 지킬 수 있다면 상속을 많이 써도 된다. . . 상속을 쓰면, 저번 수업 마지막 템플릿메서드vs전략패턴의 차이 -&gt; 상속을 쓰면, 클래스조합폭팔은 피해갈 수 없다. -&gt; 피하기 위해서는 has-a모델 = 합성으로 바꿔야한다. -&gt; 합성은 끝없는 확장을 위해 열어두는 방법이다. 대충 상속 + 3가지 처리만 해주자. . 코드로 좋은 확장 보기 . Plan . . 부모가 자식용으로 열어줄 메서드는 abstract proected를 만들어야하므로 부모클래스는 abstract class만 가능하다. . 3가지 조건(final, private, abstract protected) 중에 마지막 조건인 abstract protecetd를 쓰려면, 부모클래스는 abstract class일 수 밖에 없다. final, private만으로도 해결가능하면 abstract클래스 아니여도 된다. | . . | . | plan이라는 요금제도 안에서 call을 생성자가 아니라 final 메서드로 받도록 병합시키도록 하고 있다. . 부모클래스는 생성자로 인자를 받으면 안된다. -&gt; 따로 final, private 메서드를 파서 받아라 . plan에서 생성자로 받으면 더이상 상속구조를 못만들고 끝난다고 생각해야한다. 생성자가 인자가 없으면 그래도 괜찮다. 하지만, 인자를 받는 생성자인 순간 상속구조를 못쓴다고 생각하자. | . . | . | calculateFee()라는 메서드는 바깥쪽에 템플릿 메서드로 제공하고 내부에서 같은이름으로 자식이 개별 구현할 abstract protecetd추클을 사용함으로써 (여러)자식이 부모를 쓰는게 아니라 부모가 자식을 알고 쓰는 구조가 된다. . my) 템메패턴을 쓰면, 자연스럽게 의존성이 역전된 좋은 상속이 된다. | 자식들은 내부에서 전체 calls가 아니라 개별 call별로 작은 역할로서 수행해주는 부분적인 역할만 가져 내려간다 . | 확장에서는 상속받는 자식들은 작은역할만 하도록 계산하도록 해줘야한다. 되독이면 쪼여야한다. 확장시 최소한으로 줄여서 시켜라 | . | . | 속성은 다 private 메서드는 final + abstract protecetd + 인자받는 생성자 안 존재함. . | . PricePerTime (extends Plan) . . 정책을 확장하여 일정 시간별로 금액을 부여하는 정책 인자로 얼마를 부여할지, 몇초마다 부여할지를 입력받는다 예, 1분에 18원 | . | . | 본인의 상태만 관리한다. 부모가 인자받는 생성자가 없기 때문에 -&gt; 좋은확장으로서 super에 대한 의존성이 없다 | 자기자신의 상태외에는 관리하고 있찌 않다 | . | 상속받은 메서드는 (abstract protected) 템플릿 &amp; 추클 메서드라서 -&gt; super.에 대한 의존성이 전혀 없다 . | 즉, 자신의 필드관리만관리(no super) + 추클구현으로 넘어오는 인자1개만 결합한 메서드만 있어서, 상속써도 사고가 안난다 | . 좋은 확장의 자식메서드 판별법: @Override protected인지 확인하여 -&gt; 부모의 템메 + abstract protected 메서드를 구현했는지 확인한다. . . @Override protected에 실패했다면 -&gt; 상속패턴을 쓰면 안된다. . 부모에서 private필드+final or abstract protected / 자식에서 @Override protected가 아닌 이상엔 확정버그라고 판단하면 된다. . 단위테스트도 필요없다. | . NightDiscount (extends Plan) . . 낮가격, 저녁가격, 몇초에 한번 부과할지를 받는데, 22 시간도 받아야하는데 하드코딩했음. | . | 자기자신의 상태만 생성자로 받아서 관리한다 | 하나의 콜에 대해 자신의상태 + 넘어온 call로만 계산함 부모의 의존성을 줄였다. | 할게 조금이니까 부모의 사정이 안궁금하다. | . | . 확장의 요령이자 상속의 경우의 수: 자식이 조금만 참여하도록 -&gt; 부모가 대부분을 끌어안고, 자식한테 쪼금만 위임할 수 있는 경우만 상속이 유리 -&gt; 그외에는 상속을 쓰면 안된다!! . 차이가 굉장히 쪼금해서 자식별로 조금만 구현하고, 대부분은 부모가 먹는 경우에만 상속이 유리하다. | . 나머지는 class를 쓰면 안된다. class에는 역할(메서드)이 들어가기 때문에 -&gt; 인터페이스를 쓰는 항목으로 바뀌니 이왕할거 구현체가 다 역할을 하도록 해야한다. 즉, 추클이 거의 다하고 일부만 자식에게 주던지 vs 아예 배째고 인터페이스 쓰든지 . 추클인데, 어중간하게 일하면서, 어중간하게 넘길 때 문제가 발생한다. 다 넘긴다 -&gt; 인터페이스 | 안넘기고 조금만 준다 -&gt; 추클으로 상속 | . | . 객체지향에서는 극단적으로 책임을 넘기만, 우리는 그 책임을 열라게 잘게 쪼개서 안정적으로 만들어야한다. . 합성 . 템플릿메서드는 기계적으로 전략패턴의 전략객체로 만들 수 있으며, 그 방법이 상속모델 -&gt; 합성모델로 바꾸는 것과 마찬가지다 . 판단은 조합폭팔이 일어날 것 같을 때 기계적으로 바꾸면 된다. . | 연습은 상속이 보이면 조합으로 바꾸기(합성)를 해보면 된다. . 평소에 조합으로 바꾸는 연습을 많이 하자. . | 재귀함수를 for루프로 &lt;-&gt; for루프를 재귀함수로 맘대로 바꾸듯이 말이다. . | . | . | . 코드로 좋은 확장(상속) -&gt; 조합으로 변형해보기 . Plan . 기존: abstract class를 상속한 자식들은 템메 내부의 calcCallFee(call)의 작은 책임만 나눠가지도록 되어있었다. . . | 소유모델: 상속해서 자식들이 처리할 문제들을 전략객체가 처리해줄 것이다. . . | . [부모] 소유모델=전략패턴, 합성으로 바꾸면서 변하는 부분 . abstract class -&gt; 그냥 normal class로 돌아간다 | 자식들로 위임되는 메서드 (abstract protected)의 역할 -&gt; 선택되어 받아와, 소유하게 될 전략객체가 역할을 한다. | . normal class vs final class 선택해야한다. -&gt; 상속대신 조합써놓고, 상속가능하게 부모를 final class가 아닌 normal class로 열어두었다? . . 상속(확장) 대신 합성을 적용한 상태지만, final을 쓰지 않았다 -&gt; plan를 확장한 다양한plan을 만들 수 있게 상속을 허가한 상태다. 미래의 이 class는 상속될 가능성이 있다.고 본 것이다 하지만 아까 말했던 좋은 상속 3가지 조건이 만족되고 있어야한다. | . | . final을 안달았다 = 다양한 xxx로 확장될 상속가능성( extends Plan을 할 class생성 가능성)을 열어두었다 -&gt; 좋은상속 3가지 조건이 지켜지고 있는지 확인해야한다. -&gt; 규칙 1개라도 못지키면 그냥 final을 class에 걸어야한다. . 만약 좋은 상속의 3가지 조건인 private + final + abstract protected + 인자안받는 생성자의 조건이 안지켜지고 있다면, final로 막아야한다 | . 얘는 normal class인데 final걸지 않아도 된다? 왜? . . 부모에 (인자받는) 생성자가 없다 | 모든 필드, 메서드가 private, final을 만족하고 있다. | 아니면 메서드는 abstract protected여야한다. | final을 안달아줘도 되는, 다양한 확장가능한 클래스다. . 우리가 class에 final 안걸고 열어두는 것이 버릇인데, 그럴려면 사실은 좋은확장 원칙3가지를 지킨 애들만 final 없이 열어 둘 수 있다. . 우리가 짠 class들을 검토해서 좋은 확장 원칙을 안지키면 final을 걸어두자. 기계적으로 걸어도 된다. 에러의 원인은 그곳이다. 상속(확장)됬는데, 그 전 것의 context를 못지키거나 불변취급했는데 변해서 문제가 생긴다. . Plan은 좋은상속의 조건/원칙을 만족시키는 클래스라서 열어둔 것이다. . | 이제 상속없이, calc를 runtime시 주입만 해주면, 상속없이 알아서 처리된다. . | . 전략객체를 받는 인터페이스는 내부에 전메/추클 1개가 Type만 지정해주면, 함수형인터페이스로서 완성된다. . . pricePerTime (extends plan -&gt; impl 전략인페) . 좋은상속의 자식은 -&gt; 구현체(전략객체)로 바꿀 때 변화가 거의 없다 . 좋은상속일 때 자식(구현체) 코드 . . 전략패턴에서 전략객체(구현체) 코드 . . [자식] 소유모델=전략패턴, 합성으로 바꾸면서 변하는 부분 . extends 부모 -&gt; implement 전략인페 | @Override protected 메서드 -&gt; @Overried public 메서드 바뀌는 부분이 거의 없다 | 원래 impl될 때 필요한 안전성이 좋은 상속 원칙 3가지에서 확보된 상태였기 때문 | . | . NightDiscount . . . 역시 마찬가지다. | . 포워딩 . . 여기서 컨텍스트란 this or 변수 or 어떤 상태를 공유하는 것 상태공유의 대표적인 예 ex&gt; 꼬리무는 재귀함수 여태껏 곱했던 것들을 넘겨주는 -&gt; 업데이트된 상태를 외부생성자로 넘겨 받아 공유됨(어그리게이션) | . | 합성객체에 아무것도 공유 안하는 경우 : 포워딩이라 부른다. 공유도 안하는데 뭔가를 시킨다? 위임(델리게이션)이라고 부른다. | . | . | . my) 위임: 전략객체에게 중요 상태값(컨텍스트)이 아니라, 유틸함수에 필요한 재료 넘겨주는식만이루어진다. . plan . . 전략객체는 일을 위임받아서 하는데, result(결과)를 합쳐가고 있다. 하지만, result를 공유하진 않고, this도 안준다. call이라는 상태만 넘겨준다. . . 하지만, 이 call이라는 것은, plan이 연산이나 업무처리시 공유되는 context는 아니다. 값으로서 참조데이터만 넘어간 것뿐이지, 공유되는 컨텍스트 없이 유틸함수처럼 전략객체를 호출하고 있다. | . | . | . 연결되는 합성객체 . 데코레이터 패턴이라고도 부른다. . 하나의 객체 -&gt; 인스턴스화 될 때, 자기만의 메모리를 가진다. 인스턴스의 객체 속 필드만큼 메모리를 가진다. | 필드는 얼마나 가질 수 있을까? 클래스 정의하기 나름이다 | 팔드를 컬렉션으로 정의했다면? 배열&lt;Object&gt;라면, 하나의 인스턴스는 메모리는 무한인가? | . | 많은 사람들이, 컨설팅시 객체를 하나의 작은 컴퓨터라 부른다. 우리가 남발하는 인스턴스 1개가, 옛날컴퓨터보다 용량(메모리)가 클 수 있다. | 우리는 캡슐화와 추상화를 통해 문제를 해결하기 때문에, 컴퓨터 1대가 문제를 해결해주는 식으로 생각한다. | . | 그렇다면, 객체 2개 -&gt; 컴퓨터2대(서버2대)를 가지고 협력하면서 문제를 해결하려면? 독립적으로 부르면 상관없지만, 협력해서 한다면? | 완전히 독립된 메모리공간에 있는 2 객체(컴퓨터2대)의 어떻게 협력할지, 협력관계를 정의해줘야한다. 나는 너의 뭘 쓸거야, | 너는 어떤 경로로 나에게 리턴해줘. 나는 그것을 가지고 또 뭘 쓸거야 | . | . | . | 연결된 합성객체 -&gt; 독립되어있는 모듈끼리지만 병합된 결과를 주고받기 위한 인터페이스를 정한다는, 행위+개념이다. 2개를 연결했다면 -&gt; 또 다른 것과 2개씩 연결할 수 있다. | LinkedList와 연결된 합성 객체or데코패턴or체인오브리스폰서빌리티or composite패턴or …으로서 하나의 context를 공유해서, 공유된 context를 계속진행시키는 개념을 계속 쓴다. | . | . | 중급 개발자를 가르는 기준이 된다. | . 재귀함수와 객체의 연결 차이 . . 일반적인 재귀함수의 구조 네모1개 = 함수 인자를 받아들이는 곳 | 리턴 포인트 | . | 2번함수가 3번함수에게 리턴한 인자로 호출 -&gt; 3번 함수는 인자를 받아들여서 수행 | . | . . 객체지향에서는 객체 != 함수이므로 위와 같은 모습을 보인다. 하나의 객체속 특정메소드에서 -&gt; 다른 객체가 발생하는게 아니라 다른 객체의 메소드로 보낸다. | 리턴할 때도 특정메소드의 위치로 가서 보낸다. 그냥 인자/리턴으로 보내는게 아니라, 객체 속 메소드들끼리 보내고 받고 한다. | . | . | 연결되는 합성객체는 재귀함수의 확장판이라 볼 수 있다. . 재귀함수: 다 같은 함수들이라서, 부르는 함수의 포인터를 알고 있다. a,b,c,d 다른 함수여도 상관없다. | 연결된 합성객체들: 같은타입 객체의 같은 메소드들 서로 불러도 된다. | 다른타입 객체의 특정(다른) 메소드들 서로 불러도 된다 -&gt; 우리가 배웠던 객체간 메세지 | . | . | 중요한 것은 시작객체의 메서드가 -&gt; 다른 객체의 메서드를 정확하게 알고 있다는 것이다. . . 객체가 메소드를 통해서 메세지를 보내려면 최소한 지식은 메세지 받을 객체 Type과 그 메소드에 대해서는 알고 있어야한다. 객체는 형으로 말해서..? | . | . | . . 가장 왼쪽의 클래스는 특이한 클래스(객체)다. 진입하는 entry point 클래스(진입점 클래스) . . 애초에 모양자체가 특이함. 왼쪽에서 오는 것을 받지도 않고, 오른쪽으로 주기만 함. | 바깥쪽으로 return도 안함. | . | java의 main함수처럼 진입점은 어디든 존재한다. | . | 진입점에서 -&gt; 메세지를 주고 받기 시작하는데, 재귀함수처럼 연결된 객체들이 다 같은 Type의 객체임을 인식후 메세지를 주고 받는 경우를 배운다. 다 같은 Type으로 인식되어 메세지를 주고 받으면 뭐가 좋을까? 연결된 4개 객체에 대한 지식이 1개의 지식만 있으면 된다. 원래 4개 서로 다른 객체라면 객체Type과 해당메서드를 최소한의 지식으로 알아야했으니 X4배의 지식이 생겼다. | . | 다 같은 형이니까 형끼리 통신시 -&gt; 1개의 지식만 필요한 데코레이터 패턴이다 | . | 데코레이터 패턴에서는 같은Type을 상속 or impl하고 있는 모든 객체들(my)구현체들)이 통신에 참여하면 이 객체는 뭔지 모를지라도, 데코레이터 인터페이스를 따른 객체(구현체)다 == 특정메서드를 특정할 수 있다 == 연속으로 대화할 수 있다 | . | . 코드로 보는 데코레이터 패턴 . Calculator . 기존 좋은상속 -&gt; 합성으로 바꾼 전략 인터페이스 | 데코레이터 패턴을 적용한 전략 인터페이스 | . 부수적 책임(모) -&gt; (아니면 도로서) 포괄적 책임으로 승격시켰다. . 상속계층을 잃어버린 이상에 -&gt; 부모역할을 하던놈이 더 많은 역할을 가져봤자 책임만 분산된다. . 따라서, 적은 책임의 좋은상속자식 -&gt; 그대로 책임만 합성한 전략패턴 -&gt; 객체에 책임을 부을 수 있을만큼 전략객체에 부어넘겨주는 데코레이터패턴 | . | call1개에서 Set&lt;Call&gt; 콜집합으로 책임이 늘어난 것이다. . | 갯수에 따라 무게가 증가한다. 1개 알고 있는 것이랑 그 컬렉션, 여러개를 알고있는 것이랑 무게가 다르다. 책임이 늘어난 것이다. . | aggregation용 context(my)누적, 업데이트되는 값)의 전달이 추가되었다. . 기존 Plan -&gt; 보니 결과값들을 모아주는 변수도 넘어간다. . . | 책에서는 afterCalculator와 그냥 Calculator로 2개를 통해서 aggregator를 수집하도록 설명해놓았지만, 여기선 귀찮아서 합친 것이다. . 메서드 2개 -&gt; 메서드1개 인자2개로 바뀔 수 있다. | 인자가 적은 함수가 좋은 이유 -&gt; 인자가 많아지면, 거기에 aggregator가 개입될 가능성이 높아진 것 | 여러인자를 쓰는 것도 싫은데, 함수 2개를 쓰는게 더 싫은 이유: 순서가 지식이 된다. 메서드의 순서는 컴파일러에 안걸려서 에러를 못찾는다. 순서형 메서드들 분할 -&gt; aggregator를 합쳐서 메서드1개로 만들어서 트랜잭션을 자꾸 만들려고 노력한다. 학습용 코드라서, 순서형 메서드로서 2개가 나온 것이시지, 컴파일에러에 잡히게 만드려면, 1개의 메서드에 인자 2개를 넣어서 처리해야한다. | . | . | . | . | . Plan . 기존의 plan과 바뀐 plan . . calulator가 1개의 call만 처리하는 부분적인 역할을 가지고 있었으나 | . . 이제는 니가 하다하라고 전체 call를 다 밀어넣고, 누적을 시작하기도 전에, 누적 aggregator의 초기값을 넘겨줘서 모든 책임을 위임받는다. my) 넘겨받은 전략객체 속 특정 메서드로 누적연산의 초기값 + 상태값 전체를 메서드로 넘겨주면, 책임이 많이 줄어든다. | 이제부터는, 전략객체를 구상한 구상클래스가 모든 책임을 진다. | . | plan의 줄어든 책임을 call 컬렉션(상태값)을 관리한다. 관리한 상태값을 넘겨줘서 연산은 전략객체가 시행하지만, 넘겨주기전까지 관리는 plan이 | . | 전략객체.특정메서드()에 call컬렉션을 전달해주는 것 | | 계산하는 모든 책임은, 이름 그대로 Calculator가 다 가져갔다. my) 연산 값 1개만 전메로 만들지말고 -&gt; 상태값/누적연산의 초기값 등 모든 연산필요 값들을 파라미터로 넘겨받아 모든 로직을 전메로 넘긴다. | . | . 책임을 다 넘긴 후에는, 문제 발생시 2가지를 나눠서 볼 수 있다.(올인된 책임으로 잘개 쪼개기 SRP) . 계산이 잘못이 잘못되면 Calculator를 보면 된다 | 계산기의 투입이 잘못됬거나 or 잘못된 계산기가 투입됬다면, Plan쪽을 보면 된다. . | 설계란, 큰 책임을 졸라게 쪼개되, 쪼갠 책임마다 각각이 올인되도록 만들어 SRP(단일책임원칙)만 준다. my) 전략패턴, 합성으로도 모든 책임을 넘길 수 있다. | 전략당한 부모쪽 = 업데이트되는 calls를 상태값 관리 + 전략객체 Calculator를 관리 원래는 calls관리가 내 책임 | Calculator는 위임을 위해, 참조포인터로서 알고 있는 것임. | . | plan이 가지고 있던 책임을 쪼개서 전략객체 Calculator가 계산에 관련된 모든 책임을 먹었다. | . | .",
            "url": "blog.chojaeseong.com/object/2022/06/01/(object1-16-1)%EC%A2%8B%EC%9D%80%EC%83%81%EC%86%8D_%ED%95%A9%EC%84%B1%EC%9C%BC%EB%A1%9C%EB%B3%80%EA%B2%BD_plan.html",
            "relUrl": "/object/2022/06/01/(object1-16-1)%EC%A2%8B%EC%9D%80%EC%83%81%EC%86%8D_%ED%95%A9%EC%84%B1%EC%9C%BC%EB%A1%9C%EB%B3%80%EA%B2%BD_plan.html",
            "date": " • Jun 1, 2022"
        }
        
    
  
    
        ,"post53": {
            "title": "의연방12) 메타분석2(메타분석 4단계)",
            "content": "&#54617;&#49845;&#47785;&#54364; . 메타분석의 과정을 이해할 수 있다. . 메타분석의 원리를 이해할 수 있다. . 이질성과 Publication bias를 이해 및 평가할 수 있다. . &#51452;&#50836;&#50857;&#50612; . 메타분석 : 체계적 문헌 고찰 수행과정에서 2개 이상의 개별 연구의 요약 통계량을 합성함으로써 해당 중재법의 통합된 가중평균 요약 통계량을 정량적으로 산출하여 임상적 효과성을 평가하기 위해 사용되는 통계적 기법 . | 고정효과모형 : 각 연구들에 있어 중재효과의 참값은 단 하나만 존재(common true treatment effect)한다는 전제 하에 관찰된 치료효과 값들의 차이는 표본추출의 오차 때문이라는 가정에서 출발하는 모형 . | 변량효과모형 : 각 연구들에 있어 중재효과의 참값은 단 하나만 존재하는 것이 아니라 각 연구들에 있어 중재법의 효과는 어떤 중재효과의 평균 참값(true average treatment effect)을 중심으로 정규분포를 따른다고 가정하는 모형 . | 이질성(Heterogeneity) : 메타분석에 포함된 개별 연구들의 결과간 변동(variation)이 표본추출 오차 이상으로 관찰되어 우연으로 설명할 수 없는 것 . | 출판 비뚤림 (publication bias) : 연구결과의 통계적 유의성과 출판 가능성간의 관련성이 있을 때 나타나는 비뚤림이며, 통계적으로 유의한 긍정적인 연구결과인 경우 더욱 더 잘 출판될 가능성이 있기 때문에 발생하는 비뚤림 . | . &#47785;&#52264; . 분석 단계 I – 요약통계량 선정 | 메타분석 단계 II – 통계모형 선정 | 메타분석 단계 III – 이질성 여부 확인 | 메타분석 단계 IV – Publication bias 확인 | &#47700;&#53440;&#48516;&#49437;&#51032; &#51208;&#52264; . outcome 변수의 자료의 종류에 따른 요약통계량선정 통계분석 자료type에 따라서 t-test, 카이제곱-test 할지 정한 것 처럼 | . | 통계 모형 선택 | 헤테로지나이티? 평가 | publication bias 평가 | 01 &#50836;&#50557;&#53685;&#44228;&#47049;&#49440;&#51221; . 결과(outcome) 타입의 종류는 총 3가지이다. 이분형변수: event가 있었다/없었다 평가되는 경우 | 연속형 자료 | 생존형 자료 | | . &#51060;&#48516;&#54805; &#51088;&#47308;(Binary outcome) . summary measrue로서 3가지 중 1개를 선택해서 메타분석의 main result로 제시한다. Risk Ratio/Relative Risk (RR) 두 군간 사건이 발생 비율에 대한 비 | . | Odds Ratio (OR) : 가장 많이함. 코호트나 RCT세팅일 땐, RR을 제시하는 것이 summary measure로서는 더 적절하다. OR는 대안일 뿐이다. 두 군간의 사건의 승산에 대한 비 | . | Risk Difference (RD) 두 군간 사건 발생 비율의 차이 | . | | 계산하기 위해서는 각 군에 배정된 환자 수에 대해 사건이 일어난 수를 이용한다. 표에서 각 row별 3가지 데이터 중 2가지만 추출하면 메타분석이 가능하다. | . | . 2015 논문 예시 뇌졸중 환자에 대해 Cilostazol이 Control(위약, 아스피린 등)에 비해 뇌졸중 발생 event가 줄어들어 예방하는지를 RR로 summary method로 제시함 | 각 군의 환자 수 -&gt; 대부분 RCT연구이기 때문에 치료군/대조군 수가 비슷함. | 각 군의 event수를 확인해봤더니 2번째 논문에서는 Event(뇌졸중 발생)수가 0다 가장 안좋은 예임. 두 군에서 1건도 발생안하면 -&gt; RR 추정이 안되어 -&gt; 메타분석 논문에서 빠지게 됨. | . | RR 전까지 각 군의 N수 + event 수를 raw data라고 한다. | . | . &#50672;&#49549;&#54805; &#51088;&#47308;(Continuous outcome) . 가장 대표적인 연속형 자료의 summary measure는 평균이다. 이분형 변수는 각 군의 N수 + event수 2가지만 필요했지만 | 연속형 변수는 각군의 N수 + M(평균) + 표준편차 3개가 필요하다. 선택적으로서 baseline대비 Change를 볼 것인지, 최종값(Final)을 볼 것인지 선택한다. | . | . | 평균의 차이를 보더라도, 각 논문마다 측정 단위가 다를 수 있다. 1.Mean Difference (MD) . - 동일한 측정도구로 측정되었을 때 . Standardized Mean Difference(SMD) 동일한 결과를 다양한 측정도구로 측정하였을 때 | . | | BMJ 논문 예시: MD를 썼다. +면 체중 증가 / -면 체중 감소를 의미 . MD를 썼다 = 각 논문마다 측정단위가 동일했다. | raw data에는 N + 평균 + SD 3가지가 들어간다. | . | 논문 마다 baseline + final 값을 제시할지 / change값(follow - baseline)을 제시할 수도 있다. . 만약, baseline + final 값을 제시한다면 -&gt; change값으로 환산하는 노력이 필요하다 | . | 논문마다 N + Mean + SD 가 아니라 Mean대신 중위수 or 4분위수 등을 줬다면, raw data로서 못쓸까? . Mean + SD로 변화하는 도구(R)가 있다. | . | 결과적으로 outcome이 연속형 변수의 논문인 경우, N + 평균 + 표준편차를 추출해야 raw data로 쓸 수 있다는 것을 기억하자 . | . &#49373;&#51316;&#54805; &#51088;&#47308;(Time-to-event outcome) . 생존분석 논문에서 가져와야할 raw data는 HR 1개 + 제시한 95% 신뢰구간이다. 이것을 ln() + 표준오차SE( ln()) 로 씌워 값을 환산해야한다. | . | Hazard Ratio (HR): 대조군에서 사건이 발생(사망)할 위험(hazard)와 중재군에서 사건이 발생할 위험(hazard)에 대한 비 | . 02 &#53685;&#44228;&#47784;&#54805; &#49440;&#51221; . 데이터 추출된 상태(summary measure결정 + raw data확보)라고 가정하고 결합해서 메타분석시 사용할 통계모형을 선정해야한다. 결과적으로 RR이나 MD가 논문마다 나올 것인데, 이것들을 결합해서 총합된 요약통계량을 제시해야한다. | . | . Combining study results . 각 연구자료 내 요약 통계량 선정 후 이를 어떻게 취합하는가? . 마치 한 개의 연구인 것처럼 취합 – 치료군은 치료군대로, 대조군은 대조군대로 합산? 흔하게 하는 실수로, 논문별로 칼럼별로 event수를 단순하게 다 더해서 통합된 RR을 구하는 것 | . | 무작위 배정 위반으로, 잘못된 결과 도출됨 | . | 단순 평균? . 모든 연구자료가 동등한 비중인 것처럼 간주하는 것 | MD를 평균내는 행위 -&gt; 모든 스터디들이 N수가 다름(2000명 vs 30명 -&gt; 동일한 비중을 가지게 만들어버림. 2000명 논문저자는 억울하다. 신뢰성.) | . | 가중치가 부여된 평균 (weighted average) . 더 많은 정보를 주는 개별연구에 보다 많은 가중치 부여 | 가중치 주는 기준 더 많은 참여자: 자료추출시 n수 추출은 WEIGHT를 더 주기 위함이다. | 많은 사건 수: n수가 비슷할 경우 capture한 사건 수가 비슷할 때 | 보다 좁은 신뢰구간: 경우에 따라 quality에 따라 weight | . | 효과 추정 및 변이(variation) 를 사용하여 계산 | . | . 2&#44032;&#51648; &#53685;&#44228;&#47784;&#54805; . &#44256;&#51221;&#54952;&#44284;&#47784;&#54805; (Fixed effect model) . 실제 효과는 고정되어있다고 보고, study마다 다른 결과를 나타내는 이유는 sampling variation(모집단이 아닌 표본추출로 인한 변동)에 의한 것이라고 보는 모형 . 대규모 연구일 경우, sampling이 많아 모집단에 가까운 연구결과를 내고 적으면 그 반대 | sampling variation이 기반으로 하는 N수기반으로 weight를 주는 모형 small study -&gt; variation 크다. | large study -&gt; variation 작다. | weight를 variable의 역수를 주어 반대로 반영한다. | . | . | 고정효과 모형에서의 가중치는 연구 내 변이(within-study variation)만을 고려 . 고정효과 모형에서의 가중치(weight) = 1/ (연구 내 변이) | . 역-분산(Inverse Variance) 추정법: 결국 표본수n이 클수록 많은 가중치를 반영한다는 뜻. 작은 표준오차를 가지는 큰 규모의 연구일수록 가중치를 많이 받음 | sample size is key (n ↑ = precision ↑ = SE ↓) 표준오차 = 표준편차 / 루트(n) -&gt; n수가 커질수록 표준오차는 작아진다. | . | 예시: bmj논문 n수가 제일 큰 3번째 연구 -&gt; SE(표준오차)가 제일 작다 -&gt; 역수의 제곱을 취했더니 제일 크다 -&gt; weight 제일 크다. | . | . | 멘텔-헨젤(Mantel-Haenszel) 추정법: binary outcome중에 n수도 있지만, + event수가 많이 capture된 연구일 수록 weight를 많이 주겠다. OR, RR, Rate Ratio와 같은 2×2 표를 만들 수 있는 자료에서 사용 | 사건 발생률이 낮거나 연구의 규모가 작지만 메타분석에 포함되는 연구의 수가 많을 때 효과적인 방법 | OR 또는 RR의 분산(2x2 table에서 n수로 역수를 취해서 분산을 구함 -&gt; n수 뿐만 아니라 event수가 반영됨)의 역수를 개별 연구의 가중치로 사용 | 예시: 뇌졸중 환자 논문 RR을 summary measure로 쓰기로 약속한 상태로, RR의 분산은 2x2 table에서 역수를 취해서 분산을 구하므로 N수도 중요하지만, event수도 중요하다 5번째 연구가 50%를 차지하게 된다. | . | . | . | | . &#48320;&#47049;&#54952;&#44284;&#47784;&#54805;(Random effect model) . 각 연구들은 어떤 평균적인 처리효과(average treatment effect)를 중심으로 퍼져있는 모집단 내 연구들로부터 무작위로 추출된 연구들이라고 가정 | 따라서 처리효과들간에 variation이 관찰되는 이유는 표본추출 변동(within-study variation)과 연구들 간의 변동(between-study variation)이 함께 나타났기 때문으로 간주 . | 고정효과모형의 경우처럼, n수나 event수 기반으로 weight를 부여했었던 것은, 결과적으로 동질화된 연구들로 세팅이 됬을 때 가능한 경우다 . 모집단이 유사하게 세팅된 상태로, 안정적인 상황이다. | . | 동일한 모집단에 대한 동일 연구가 아니라, 비슷한 연구들을 넣다보니 . study간/study내에서 variation도 존재해버린다. study간: 각각의 스터디들(●)이 실제공통효과 (▼)와는 다르게 개별적으로 존재하는 상황에서 고정효과모델은 각 스터디들 효과(●) = 실제공통효과(▼)의 공통효과 중심이었음. | . | study내: sampling variation -&gt; 표본추출변동 = within-study variation | . | n수 event수 뿐만 아니라 스터디간 변동(스터디마다 세팅이 다름)도 반영해서 weight를 줘야한다. | . | . &#48320;&#47049;&#54952;&#44284;&#47784;&#54805;&#51032; &#44032;&#51473;&#52824; &#52628;&#51221;&#48169;&#48277; . 변량효과 모형에서의 가중치(weight) = 1/(연구 내 변이 + 연구간 변이) . 연구내 변이: 고정효과모델의 변동 = 표본추출 변동 = n수+event수 반영 | 연구간 변이: 비슷한 연구들 = 모집단이 조금씩 다름 = 세팅이 다른 연구들간의 변동도 반영 | . | Methods to estimate the between study variance . DerSimonian-Laird estimator (default method in many statistical software) 가장 많이 사용. 메타분석 전용 툴인 Revman에서는 이 방법만 제시한다. | . | Paule-Mandel estimator | Restricted maximum-likelihood estimator 최근에는 advanced한 방법인 2,3번째를 추천하는 경향이 보인다. | R에서 제공한다. | . | Maximum-likelihood estimator | Hunter-Schmidt estimator | Sidik-Jonkman estimator | Hedges estimator | Empirical Bayes estimator | . | . 예시: 왜 변량효과모형을 사용할까? . 임신중독증 환자들에 이뇨제의 효과 메타분석 스터디가 오밀조밀 모여있어야하는데, 퍼져있다. | population이나 이뇨제 세팅이 달라서로 추정 | . | 스터디 간의 varation을 반영하지 않는 Fixed-effectes모형의 경우 효과가 있는 것 처럼 보인다. Odds Ratio가 1을 포함하지 않아서, 통계적으로 유의하다로 결론 | . | 문제는 스터디가 너무 다양해서 바로 결론을 내릴 수가 없다. 그래서 DerSimonian-Laird의 방법(by Revman)을 썼는데도 통계적으로 유의하다는 결론이 나왔다. | 그럼에도 불구하고, 더 advanced된 방법인 방법들by R)을 썼더니, OR이 1을 포함하여 통계적 유의성이 없다는 결론이 나왔다. | 더시모니안-레이어드 method방법으로 썼다면, advance로 한번 더 하라고 권고를 하는 상황이다. | . | 우리는 메타분석 초보이다 -&gt; 스터디가 퍼져있으면, Fixed-effects말고 Random-effect모형(varied 모형?)을 쓰는 것만 생각하자. . | . Software for Meta analysis . Review Manager 5.4 (RevMan 5.4) . https://training.cochrane.org/online-learning/coresoftware-cochrane-reviews/revman | 학술적 사용은 무료, 상업적 사용은 유료 | 코크만(체계적 문헌고찰을 전문적으로 하는 큰 집단)에서 무료로 제공함 | . | Comprehensive Meta-Analysis (CMA) Version 3.0 ($) . http://www.meta-analysis.com/ | 유료 프로그램 | . | Statistical software . STATA, R (‘meta’, ‘metafor’ package) | . | Forest plot (&#49714; &#44536;&#47548;) . &#50672;&#49549;&#54805; outcome &#50696;&#49884;(weight loss) . 메타분석의 기본적인 result다. | 구성요소 . 개별적 연구 목록들 | raw data 입력값들 | weight 그림을 보면 IV(역분산 방법), Fixed(고정효과모형)을 선택한 것으로 보이니 N수 + event수 기반으로 weight가 결정됬을 것이다. | 그림상 초록색 box의 size를 결정하 | . | Mean Difference raw data를 입력하면 역시 자동으로 계산되는 값 | . | 척도 그림의 아래 부분에서 확인한다. 어느 방향으로 가면 효과가 좋은 것인지 생각하고 본다. | . | total Mean diffrence . 이 예시에서나오는 0.32의 weighted Mean Difference를 얻기 위해 메타분석을 한 것이다. | OR가 다르게 유의한지 안하지 보려면 1이 아닌 0을 포함하는지를 보면 된다. totla MD가 0을 포함하고 있지 않기 때문에 유의한 결과를 냈다. | . | 그 밑에 나타내는 P-value값을 봐도 된다. | 그림상으로는 큰 다이아몬드가 나타내고 있다. MD가 +방향에 있다 -&gt; 우측(아침식사X 군)이 outcome(weight loss)에 효과가 더 좋다 | . | . | 결과적으로 아침식사 먹지 않는 것이 체중감량에 더 좋다. . | . | . &#50672;&#49549;&#54805; outcome&#51064;&#45936; md&#44032; &#50500;&#45772; smd&#47484;&#49324;&#50857;&#54616;&#45716; &#44221;&#50864; . 측정도구가 달라 측정단위가 다를 때 standardised mean difference를 써서 표준화후 MD를 사용한다. | . &#51060;&#48516;&#54805; outcome . raw data가 연속형 outcome에 비해 다르다. 프로그램 format에 마다 다르기도 하다. | . | 입력하면 Relative risk(RR)이 자동 계산 된다. | 연속형 -&gt; MD가 아니라 이분형 -&gt; RR의 summary measure인 경우, 유의한 결과인지 확인은 total RR이 1을 포함하는지를 확인하면 된다. | . &#49373;&#51316;&#48516;&#49437; outcome . MD(연속형), RR(이분형) 대신 HR을 각 연구마다 모은다 | RR처럼 1을 포함안해야 유의한 결과이다. 1보다 작으니 사망확률을 줄여주는 것이 유의하다는 결론 | . | . Meta-analysis of single proportions . 최근에는 전통적인 메타분석의 2군(치료군(중재군) vs 대조군)의 비교가 아니라 single group내에서 proportion을 통한 메타분석을 시행하기 도한다. | 단순히 summary(각 proportion의 평균) 내는 것이 아닌 weight를 주고 통합한다. | . | . 03 &#51060;&#51656;&#49457; &#54869;&#51064; . 일반적인 통계와 달리 p-value가 나오더라도 2가지 평가를 추가해서 확인해야한다. 그 중 하나가 이질설 평가 | . | . &#51060;&#51656;&#49457;(Heterogeneity) . 뭐가 다르다 -&gt; 뭐가 다르냐? . 스터디마다 뭔가가 다르다. | . | 메타분석에서의 이질성(Heterogeneity) . 메타분석에 포함된 개별 연구들의 결과간 변동이 표본추출 오차 이상으로 - 관찰되어 우연으로 설명할 수 없는 것을 뜻함. | . | 이질성 발생원인 임상적 다양성 : 연구집단, 중재법, 결과 등의 다양성 | 방법론적 다양성 : 연구유형과 bias 위험의 다양성, 치료효과 크기의 방향과 크기의 다양성 등 | . | 이질성 평가방법 . 그래프 이용 : 숲그림(forest plot), L’Abbe plot, Galbraith plot . 일반 통계보다 데이터수가 작으므로 그래프로 나타내는 것을 선호함 | . | 통계적인 검정 : 카이제곱 검정법(Q statistics)과 Higgin’s I2 statistic . | . | . &#51060;&#51656;&#49457;: &#44536;&#47000;&#54532;&#47484; &#51060;&#50857;&#54620; &#49884;&#44033;&#51201;&#54217;&#44032;(1) - &#50672;&#49549;&#54805; outcome . Forest plot을 통해 개별 연구들의 치료 효과값의 방향성과 신뢰구간이 겹치는지를 검토할 수 있음 . | 왼쪽 그림은 combined된 결과에 오밀조밀 잘 모여있지만, 오른쪽 그림은 퍼져있다. . 오른쪽 그림은 이질성이 발생했다고 의심한다 | . population을 넓게 설정했거나 | invention을 다양하게 설정했거나 등 | | . &#51060;&#51656;&#49457;: &#44536;&#47000;&#54532;&#47484; &#51060;&#50857;&#54620; &#49884;&#44033;&#51201;&#54217;&#44032;(2) - binary outcome . binary outcomt에 대해 이질성을 의심할 때, L’Abbé plot(라비 플랏)을 활용할 수 있다. . | 대조군 vs invention군에 대해 사건 발생 비율을 계산할 수 있다. . 발생 비율을 scatter plot으로 그렸을 때 45도 곡선에 있으면 괜찮으나 | 아래 그림처럼 placebo군인데 사건발생율이 너무 다양해버린다. (intervention군이면 이해를 하겠는데) intervention을 안한 군인데 사건발생율이 천차만별로 다양해버린다면 -&gt; population이 다양했을 것이다. -&gt; 이질성이 존재할 것이다. | . | . | . &#51060;&#51656;&#49457;: &#44536;&#47000;&#54532;&#47484; &#51060;&#50857;&#54620; &#49884;&#44033;&#51201;&#54217;&#44032;(3) . Galbraith plot: 이질성이 드러나는 연구(outlier)를 찾기 위함. 찾으면 그 연구를 빼고 다시 분석한다. | 연구들 간의 이질성 정도를 평가하기 위한 것 | 모든 연구결과들이 회귀선 위의 ±2이내의 위치하면 이질성이 없는 것으로 해석 | 이질성을 높이는 outlier를 보이는 연구를 찾는데 유용 | . | . &#51060;&#51656;&#49457; : &#53685;&#44228;&#51201; &#44160;&#51221;&#48169;&#48277; . 그래프의 해석은 주관이 들어갈 수 밖에 없다. 내가 보기엔 outlier아닌 것 같은데? 등... | . | 이럴 때, p-value가 나오는 이질성 평가를 할 수 있다. . forest plot 그릴시 무조건 따라오는 결과다. | . | 2가지 요소가 있다. . 카이제곱 검정 | I^2 | | . &#52852;&#51060;&#51228;&#44273; &#44160;&#51221;(Q statistics) . 우리가 아는 카이제곱 검정은 아니다. 카이제곱 분포를 이용한다고 해서 붙여진 이름이다. . | 각 개별 연구들의 중재효과가 산출된 공통 중재효과값으로부터 얼마나 멀리 떨어져 있는지 검정하는 방법 . | H0 : 각 연구들은 동질하다. vs H1: 각 연구들은 이질적이다. 검정력이 부족해서 0.05가 아닌 0.1로 잡는다. | . | P-value &gt; α=0.10 ➔ 귀무가설 채택 ➔ (이질적인 내용 반영 없는) 고정효과모형의 메타분석 수행 | P-value &lt; α=0.10 ➔ 귀무가설 기각 ➔ (이질적인 내용 반영하는) 변량효과모형의 메타분석 고려 . | 카이제곱 검정의 단점 . 연구들이 작은 규모이거나 포함된 연구의 수가 적을 때 검정력이 부족하게 되어 유의하지 않은 결론을 도출하기 쉬움. | 카이제곱 검정을 시행할 경우 유의수준을 5%보다는 10%로 설정하여 동질성 검정을 시행하는 것이 일반적 | . | . Higgin&#8217;s I2 statistic . 정형화된 통계량이 따로 있다. | 제곱이라서 마이너스값은 없다. 범위 0~100(%)사이 | 100에 가까울수록 이질성이 큰 상황이다. | 대략적으로 30%를 경과하면 이질성이 발생하다고 본다. | . &#51060;&#51656;&#49457; &#54869;&#51064; . forest plot으로 보면, 약간 퍼져있어 보인다. | 헤테로지나이트를 평가해봤더니 . p-value가 0.07으로 0.1보다 작다 -&gt; 귀무가설 기각 / 대립가설(이질성 있다) 채택 | I^2이 43%로 30%이상이다 -&gt; 이질성 있다. | . | 이질성 발생했으니 plot에 명시된 Fixed-effect모형으로는 결과는 받아들일 수 없다. . random-effect 모형으로 바꿔서 분석해야한다. | . | &#51060;&#51656;&#49457;&#51060; &#51080;&#45716; &#44221;&#50864;&#51032; &#54644;&#44208;&#52293; 3&#44032;&#51648; . 변량효과 모형의 사용 . 주로 설명될 수 없는 이질성에 대해 일차적으로 시도될 수 있음. | 연구들간의 이질성을 통합하기 위해 사용될 수 있지만, 이것은 이질성의 원인을 밝히는 철저한 조사방법은 아님. | . | Subgroup analysis: study가 굉장히 많은 경우, sub group으로 나눠서 분석 . 연구들간의 이질성을 해석하기 위해서 동질할 것으로 예상되는 subgroup analysis을 나누어 분석함. | . | 메타 회귀분석(Meta Regression) . 각 개별연구들의 효과크기를 종속변수로, 이질성을 일으키는 연구수준의 공변량을 독립변수로 고려한 회귀분석 | 이질성을 일으키는 공변량을 파악하거나 이를 보정한 통합 효과크기를 추정하기 위함 | . | &#48320;&#47049;&#54952;&#44284; &#47784;&#54805;&#51032; &#49324;&#50857; . Fixed -&gt; Random 효과 모형으로 바꾸니 total MD가 더 커졌다. | . | 똑같은 data지만 이런 효과가 발생하는 이유는? . study간의 변동 반영 -&gt; 더 보수적인 결과가 나올 수 밖에 없다. -&gt; 신뢰구간이 더 넓어진다. | 더 board한 상황에서도 결과가 유의하게 나오면 신뢰할 수 있다. | . | 요즘은 이질성 없을 경우 FE = RE이니 RE만 제출해라. 보수적으로 볼 것이다. 라는 경향이 있다. . 하지만, 초보인 우리는 이질성 발생시 FE -&gt; RE로 바꾸는 연습을 하고 있다. | . | FE -&gt; RE로 바꿔서 봤는데도, 결과는 유의하다 -&gt; 아침식사 안하는 것이 체중감소에 더 효과적이다(MD차이 커짐) . | . Subgroup analysis . 연구가 많다보니 normal &lt;-&gt; obese인 사람으로 sub group을 나눠서도 메타분석을 했다. | normal 대상의 연구는 이질성이 없었다.( I^2 = 0 %) | 비만인 사람은 이질성이 발생했다 -&gt; 비만이 연구의 이질성을 발생시킨다. | . 04 Publication bias &#54869;&#51064; . 환자 데이터를 직접 다루는게 아니라 이미 발표된 자료를 가지고 분석하다 보니, 연구 결과가 어떻게 출판되느냐에 따라서 발생하는 것이 리포팅 바이어스이고 그 중 대표적인 것이 퍼블리싱 바이어스 | Reporting bias : 연구 결과의 확산이 결과의 특성과 방향에 영향을 받을 때 발생하는 bias . 가장 대표적인 종류 : publication bias | . | location bias: 2개 검색엔진(mebdline + embase)을 다 이용하면 미국+영국 다 반영되서 없어진다. . | language bias: 영어 출판 한정 문헌 검색 -&gt; 한/중/일 연구가 바뀐다. . 한의학이면 한/중/일 검색엔진 다 검색해야한다. | . | publication bias: . 아무래도 positive result가 나와야 출판될 가능성이 높으니, negative result가 나올 데이터들을 빼버리고 메타분석 하게 된다. | . | . Publication bias&#47484; &#44160;&#53664;&#54616;&#45716;&#48169;&#48277; . 그래픽 vs 테스팅 | . Funnel plot(깔떼기) . weight가 큰 large study들이 깔데기부분에서 무게를 잡고, small study들이 좌우로 positive/negative result의 대칭을 보이는지 좌우대칭이 잡히면 bias가 없다 | . | 오른쪽 그림처럼 오른쪽이 뻥 뚫리면 publication bias가 있다. positive result로만 분석해서 비대칭형이 발생한다. | . | . | Contour-enhanced funnel plots . 통계적으로 유의한/유의하지 않는 영역을 나눠서, 혹시 유의한 결과만 존재하지 않는지 확인 | 그래프로 보는 방법은 study수가 10개이상으로 많아야한다. + 주관적 해석이 들어간다. | . | Tests for funnel plot asymmetry Rank correlation test (Begg and Mazumdar, 1994) - lack of power 상관계수를 계산해서, 상관관계가 없으면 좌우대칭 | 상관관계가 존재하면 bias가 존재한다고 한다. | 전용 프로그램을 사용해야만 됨. | 보통은 그래프만 이용함 | . | Linear regression test (Egger et al., 1997) - lack of power | . | &#50696;&#49884; &#45436;&#47928;&#51004;&#47196; &#54869;&#51064; . 왼쪽그림: weight loss) / 오른쪽: enery intake 왼쪽은 대칭에 가까우며, test에서도 significant 하지 않아 -&gt; 상관관계가 없다고 나옴. -&gt; publication bias없다. | 오른쪽은 그림상으로 비대칭이다. energy intake는 아질산을 먹으면 월등하게 positive result밖에 보일 수가 없다. | . | . | . Publication bias&#51032; &#52376;&#47532; &#48169;&#48277; . Largest study들만을 분석 study가 아주 많을 경우, 깔데기 손잡이 부분의 논문 수가 많을 때.(사실상 못 쓰인다.) | . | Cumulative meta analysis 누적시키면서 | . | Rosenthal.s .file-drawer. method (fail-safe N ) | 미출판 논문의 수를 예측하는 모형사용(Glesser &amp; Olkin, 1996) | Trim-and-Fill method 사용 (Duval &amp; Tweedy, 2000) | Copas 선택 모형(Copas, 1999) | 회귀기반 접근법(Stanley, 2008) | . Trim and Fill method . 제일 많이 사용하는 방법 | a) 는 굉장히 비대칭형이다 | b) 대칭형이 될때까지 잘라낸다. | c) 다시 잘라낸 스터디들을 채우면서 &amp; 데칼코마니로 아직 출판되지 않은 가상의 negative study들을 채워서 메타분석한다. | . 예시 스테로이드 vs 안티바이러스제 비교 논문 | 여기서도 가상의 negative study 2개를 fill했다. 통계적 유의성은 더 사라졌다?! | . | . | . Summary for meta analysisprocess . outcome type에 따른 summary measure를 선택 | fixed로 갈지 or random effect로 갈지 선택은 Heterogeneity로 점검하고 | Heterogeneity이 있을 경우 forest plot이나 라비 plot + Q 통계량이나 I^2으로 test로 확인 | sub group 분석 / 메타 회귀 등 이용해서 해결 | . | publication bias는 funnel plot(깔데기 그림) | trim-and-fill method로 해결 | . | Network Meta-analysis(&#44032;&#48333;&#44172;) . evidence를 만들어야하기 때문에 왠만한 연구는 전통적 메타분석이 다 이루어졌다. | 2군의 메타분석 -&gt; 간접적인 중재도 대조군과 비교해서 여러 연구를 네트워크 메타분석 . | 예시: 코로나의 치료제는 다양하게 있는데, 어떤 치료제가 mortality나 ventilation에 효과가 좋은지 네트워크 메타 분석을 시행함 . - 초록색 2가지 study가 효과가 좋고 - 빨간색들은 효과가 별로 없다. . | . &#51652;&#45800;&#44160;&#49324;&#50640; &#45824;&#54620; &#47700;&#53440;&#48516;&#49437; . 진단의 정확도가 얼마나 정확한지 . 민감도+특이도를 결합시킨 메타분석 | summary Roc를 이용해서 종합적으로 봄 | . | 예시 . 위쪽 민감도/ 아래쪽 특이도 | 특이도는 비슷한데 민감도는 3번째 검사의 민감도가 제일 좋다고 밝힌 메타분석 | . | . 중재군vs대조군 -&gt; 여러가지 치료군에 대해.. 확대된... | . &#50672;&#49845;&#47928;&#51228; . 01 &#45796;&#51020; &#51473; &#51060;&#48516;&#54805; &#44208;&#44284;&#47196; &#49688;&#54665;&#46108; &#44060;&#48324; &#50672;&#44396;&#50640; &#45824;&#54644; &#51201;&#51208;&#54616;&#51648; &#50506;&#51008; &#50836;&#50557; &#53685;&#44228;&#47049;&#51008; &#47924;&#50631;&#51064;&#44032;? . Risk Ratio/Relative Risk (RR) . | Odds Ratio (OR) . | Risk Difference (RD) . | Standardized Mean Difference(SMD) . | 정답: 4 | 해설: Standardized Mean Difference(SMD)은 연속형 결과로 수행된 개별 연구에서 확인할 수 있는 요약 통계량이다. | . 02 &#45796;&#51020; &#51473; &#48320;&#47049;&#54952;&#44284; &#47784;&#54805;&#50640;&#49436;&#51032; &#44032;&#51473;&#52824; &#52628;&#51221;&#48169;&#48277; &#51473; &#44032;&#51109; &#47566;&#51060; &#49324;&#50857;&#46104;&#45716; &#48169;&#48277;&#51008; &#45796;&#51020; &#51473; &#47924;&#50631;&#51064;&#44032;? . DerSimonian-Laird estimator . | Paule-Mandel estimator . | Empirical Bayes estimator . | Hedges estimator . | 정답: 1 | 해설: DerSimonian-Laird estimator은 변량효과 모형에서 가중치를 추정할 때 일반적으로 사용되는 방법이다. | . 03 &#47700;&#53440;&#48516;&#49437;&#51032; &#44208;&#44284;&#51064; &#49714;&#44536;&#47548;(forest plot)&#50640;&#49436; &#54869;&#51064;&#54624; &#49688; &#50630;&#45716; &#44208;&#44284;&#45716; &#45796;&#51020; &#51473; &#47924;&#50631;&#51064;&#44032;? . 모든 개별 연구 결과의 통합 효과 추정치 . | 각 개별 연구에 부여된 가중치 . | Publication bias 평가 결과 . | 이질성에 대한 통계적 검정 결과 . | 정답: 3 | 해설: Publication bias 평가는 funnel plot으로 확인할 수 있다. | . &#51221;&#47532;&#54616;&#44592; . 메타분석은 체계적 문헌 고찰 수행과정에서 2개 이상의 개별 연구의 요약 통계량을 합성함으로써 해당 중재법의 통합된 가중평균 요약 통계량을 정량적으로 산출하여 임상적 효과성을 평가하기 위해 사용되는 통계적 기법이다. . | 메타분석은 메타분석이 가능하다고 판단되는 경우에 수행하는 것이지 체계적 문헌고찰에서 필수적으로 수행하는 것으로 생각해서는 안되며, 연구 대상군, 중재법, 중재결과가 충분히 동질한 경우에 수행하는 것이 바람직하다. . | 메타분석은 개별 연구의 요약 통계량을 계산하며, 각각의 연구에 가중치를 부여한다. 가중치는 많은 정보를 제공하는 개별 연구에 더 많은 가중치를 부여하며, 가중치가 부여된 평균(weighted average)을 계산하여 통합 요약통계량을 산출한다. . | 요약통계량을 결합하기 위한 메타분석의 통계모형에는 고정효과 모형과 변량효과 모형 두 종류가 일반적으로 사용된다. . | 이질성(Heterogeneity)이란 메타분석에 포함된 개별 연구들의 결과간 변동(variation)이 표본추출 오차 이상으로 관찰되어 우연으로 설명할 수 없는 것을 의미하며, 이에 대한 확인 및 평가가 이루어져야 한다. . | 메타분석은 출판된 연구들만을 통합할 경우 치료효과를 과대 추정할 위험이 있기 때문에 출판 비뚤림(publication bias)에 주의를 기울여야 한다. . | .",
            "url": "blog.chojaeseong.com/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EB%A9%94%ED%83%80%EB%B6%84%EC%84%9D/metaanalysis/2022/05/28/%EC%9D%98%EC%97%B0%EB%B0%A912)-%EB%A9%94%ED%83%80%EB%B6%84%EC%84%9D-II(%EB%A9%94%ED%83%80%EB%B6%84%EC%84%9D%EC%9D%98-4%EB%8B%A8%EA%B3%84-%EA%B3%BC%EC%A0%95).html",
            "relUrl": "/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EB%A9%94%ED%83%80%EB%B6%84%EC%84%9D/metaanalysis/2022/05/28/%EC%9D%98%EC%97%B0%EB%B0%A912)-%EB%A9%94%ED%83%80%EB%B6%84%EC%84%9D-II(%EB%A9%94%ED%83%80%EB%B6%84%EC%84%9D%EC%9D%98-4%EB%8B%A8%EA%B3%84-%EA%B3%BC%EC%A0%95).html",
            "date": " • May 28, 2022"
        }
        
    
  
    
        ,"post54": {
            "title": "github codereview PR comment",
            "content": "commit link 복붙 . 현재 PR의 커밋을 복붙한 경우: commit번호으로 표기된다. 링크: https://github.com/woowacourse/java-racingcar/pull/330/commits/a1815b89cf878c8e92a27f274e0f857605aa40ff | 표시 | 직접 commit번호를 입력하면 링크가 안된다. | . | 다른 PR의 커밋을 복붙한 경우: upstream레포@commit번호으로 표기된다. 링크: https://github.com/woowacourse/atdd-subway-path/commit/89e7df5a653dc1109b2c18f261a9ee7f81582708 | 표시 | . | comment link 복붙(위 empty line유무) . 현재 PR의 comment를 복붙한 경우: commit번호으로 표기된다. comment link위에 글이 있는 경우(PR 이쁘게 + (comment) text 나옴) | comment link위에 글이 없는 경우(#PR번호 comment text만 나옴) | | 다른 PR의 커밋을 복붙한 경우: upstream레포@commit번호으로 표기된다. comment link위에 emptyline 유무는 똑같이 반영되지만 | emptyline을 줘서 text만 표기 될 때, 앞에 upstream레포url이 붙게 된다. | . | #은 upstreamREPO 속 PR들 탐색 / @는 사용자 탐색 . # upstream PR들 탐색 . | @ 사용자 탐색 . |",
            "url": "blog.chojaeseong.com/git/github/comment/pr/codereview/2022/05/27/github-comment.html",
            "relUrl": "/git/github/comment/pr/codereview/2022/05/27/github-comment.html",
            "date": " • May 27, 2022"
        }
        
    
  
    
        ,"post55": {
            "title": "Microsoft Whiteboard",
            "content": "설치 . 시작메뉴에서 Microsoft or store 검색 | whiteboard 검색 |",
            "url": "blog.chojaeseong.com/configuration/ms/microsoft/whiteboard/%ED%99%94%EC%9D%B4%ED%8A%B8%EB%B3%B4%EB%93%9C/2022/05/26/windows_ms_whiteboard.html",
            "relUrl": "/configuration/ms/microsoft/whiteboard/%ED%99%94%EC%9D%B4%ED%8A%B8%EB%B3%B4%EB%93%9C/2022/05/26/windows_ms_whiteboard.html",
            "date": " • May 26, 2022"
        }
        
    
  
    
        ,"post56": {
            "title": "OBJECT 15 PART1 전체 요약(코드스핏츠)",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . 01 기본 소양 . 퀜트백의 4가지 원칙: 정해놔야 예외상황을 즉각 처리할 수 있어 비용을 아낀다. . L: 로컬변수를 사용하자 (local consequences) . | M: 중복을 최소화하자 (minimize repetition) . | S: 짝을 맞춰 생성하자 (symmetry) . | C: 컨벤션을 지키자 (convention) . | | 패턴: 정해진 원칙하에 반복되서 나타아는 유형을 베스트로서 패턴화 시키면, 비용없이 즉각 적용 가능하다 . | 역할모델: (요구사항)변화에 따른 격리에 성공하는 유일한 방법 역할모델별로 entity를 나누고 객체를 설계해야, 격리에 성공할 수 있다. | 객체지향 프로그래밍이 어려운 이유 역할 모델을 사용하기 위해서는 모든 추상화 기법을 동원함. | 그 중에 일반화를 가장 대표적으로 씀(가장 머리가 많이 필요) | 수련하는데 시간이 오래걸려서 실패를 많이 한다. | . | . | 추상화: 역할모델을 만들기 위함. 데이터의 추상화 modeling: 목표에 따라 기억해야할 것만 필드로 추리는 것 | categorization: 1개의 객체를 카테고리별로 맞게 작동시킨다. ex&gt; 아빠이자~ 사장이자~ | grouping: 공통점 없어도 묶어둘 수 있다. | | 프로시져 추상화: 싸여진 함수에게 데이터 처리를 맡기는 행위 generalization: 일반화된 방법을 사용해서 함수를 적게 만든다. | capulization: 은닉화의 느낌보다는 복잡한 로직을 내부로 감추어, 사용자에게 간단한 인터페이스만 제공하는 것 | . | 객체지향적 추상화: UML에서 class간 연결방법 Generalization: 일반화 - 인터페이스 or 추상클래스를 만듦 | Realization: 구상화 - 인터페이스 or 추상클래스에서부터 파생된 클래스 | Dependency: 함수의 인자를 받거나 부분적으로 참조해야할 때 | Association: 단짝, 나의 영혼에 각인된 친구, 필드에 정의된 dependency | Directed Association | Aggregation | Composition | | | Program &amp; Timing(프로그램 실행 시간) language code: 언어로 코드 작성하는 시간 with lint time 컴파일 이전의 시간으로서 코드품질을 위해 lint라는 것을 이용한다. 프로그램 작성시 lint time을 이야기한다. ex&gt;그거 왜 lint time에 못골라냈어. lint를 바꿔봐. | . | machine language: compile time | file: 컴파일 후 결과물. 메모리 올리기 전에 파일로 만들어, 영구보존을 시도함 | . | load: 파일로 만든 뒤에야 메모리에 적재 | run: 메모리에 올라간 후 실행. runtime load(적재) -&gt; run(실행)이 반복된다. | . | terminate : 종료 | | script program &amp; Timing . language code: lint time . | file . | load: 컴파일 전에 파일이 되고 메모리에 적재 . | machine language: compile time . | run: runtime . | terminate . | | error의 종류 context error: 미리 못 잡아낸다. ex&gt; instanceof . | runtime error: 앵간하면 미리 못잡아낸다 . 못잡아내는 것들을 lint time에 미리 잡아내고 싶다. | . | compile error: 미리 빨간줄로 잡힌다. . | | runtime in java . file -&gt; load -&gt; run: 파일로 보존되는 코드들은 메모리에 적재되어 실행된다. | . load . 메모리에는 명령세트/값세트가 로딩된다. . 아직 cpu로 가진 않았다 . . | . | . | insturction fetch &amp; decoding . 명령(instructino)세트 중 1개를 가져와(fetch) cpu의 디코더(decoding)로 가서 디코딩 된다. . . | . | execution . 명령코드가 cpu의 디코더에서 디코딩 된 이후에는 연산 유닛으로 가서 명령을 실행한다 . . | 명령이 실행될 때, cpu의 데이터유닛이 명령에 필요한 값세트들을 가져와서 받아온다. . . | 명령+값으로 실행된 결과를 다시 연산유닛으로 보낸 뒤, 결과물을 데이터유닛에 반환해준다. . 여기까지를 execute라 한다. | . . | cpu의 데이터유닛은 연산결과데이터를 메모리에 돌려준다. . . | 이제 명령2를 가져와서 디코딩하고(instruction fetch &amp; decoding) 연산후 처리(execution)후 메모리에 돌려주는 행위를 반복하는데, 이 시간을 runtime이라고 한다. . . | . | 메모리에 load된 순서대로 execution되는 과정을 sync(동기화)라고 부른다. . | 명령세트들이 다 소모되면 terminate한다 . | runtime을 정리하면 . loading | instruction fetch &amp; decoding | execution의 반복이라고할 수 있다. | | 하지만 runtime에는 추가 로직이 남아있다. . Essential definition loading . 프로그램마다 다 가지는 최초 로딩 과정으로서, 메모리에 적재되는 순간 최초에 하는 행동은 이 프로그램 구동을 위한 기초적인 정의부터 로딩 ex&gt; 기저에 있는 print함수, console 등의 필수 정의들을 로딩.하도록 컴파일러안에 짜여져 있다. | . | 그 다음으로VTABLE MAPPING을 한다. . 코딩: 우리는 text만 짰음 | 컴파일러: file을 만드는 애 일 뿐이다. | 우리가 쓴 변수와 메모리공간은??? 이미 compile time에 변수마다 가상의 메모리가 있다고 가정하고, 컴파일 한다 | 이미 변수-가상의 메모리가 컴파일된 상태에 맞춰서 vtable mapping을 표로 만들어, 진짜 메모리와 매핑을 시켜, 진짜 메모리주소로 바뀐다. | . | vtable mapping으로 진짜 메모리를 얻은 상태이므로 실행가능해 진다. | . | 이제서야 RUN이 일어난다. . . 하지만 실행이후에 모든 랭기지는 끝나지 않는다. | . | RUNTIME DEFIFITION LOADING을 통해 실행이후에도, class 및 함수 정의 등 많은 정의를 로딩한다. . 최초 프로그램 실행시만 class등이 로딩되는 것이 아니다. | java만 해도 실행도중 새로운 class들을 계속해서 로딩할 수 있다. | java가 대단한점 : 업계최초로 runtime loading을 적용한 것 jar파일이 1~2기가 되는데, 실행시 왜 안뻗을까? 필요한 파일들은, 필요시 최초로 file에서부터 loading을 시작해서 ~! | c나 c++은 프로그램 시작시, 우리가 정의한 모든 class가 시작된다. | . | java는 사용자가 만든 것은 하나도 로딩X 필요시에 파일로부터 로딩 | . | . | RUN다시 로딩된, 새로운 class 등의 정의를 실행시킨다. . | 같은 runtime임에도 불구하고, essential definition loading과 vtable mapping은 한번만 일어나지만, run -&gt; runtime definition loading -&gt; run 은 계속해서 일어난다. . | | | runtime in script program file -&gt; load -&gt; compile -&gt; run ? | 스크립트의 생명주기를 생각해보면, 컴파일되거나 최초로딩(essential definition loading과 vtable mapping)없이 실행부터 된다. | 일단 실행된 이후 내가 만든 class와 함수가 loading이 된다. 예를 들어, 브라우저 시작 -&gt; run -&gt; jquery를 로딩 -&gt; jquery를 쓰는 코드 실행 | 같은 runtime이지만, jquery쓰는 코드(run time)에 대해 상대적으로 jquery 정의 코드(static time)를 정적타임으로 보여진다. | jquery외에 다른 class 등을 사용할때도 상대주의적으로 나뉜다. | runtime은 정의되어있거나 확정적인 것이 아니라고 생각해야한다. runtime안에서도 runtime이 쪼개지며, 각 코드에 대해서 확정타임이 상대적으로 정해진다. | . | . | runtime 요약 : runtime은 확정적인 무엇이라고 가정하지 말아라 유연하며, 언어에 따라 애매할 수도 있음. | . | | Pointer of Pointer(간접참조) . 어떤 값을 얻기 위해서 특정 포인트를 직접 가르키지 않고 포인트를 찾은 뒤 .쩜을 통해 다시 포인트를 찾아서 얻겠다. . | 변수에는 값과 &amp;메모리주소값 2가지 속성이 있다. . 값도 메모리격자판에 / &amp;메모리주소값(포인터)도 메모리격자판에 박히게 된다. | 포인터( &amp;메모리주소값)는 값의 시작메모리번호(첫번재 값의 위치)만 가리킨다. | . | 타 원시변수(A)의 메모리주소값만 값으로 가지는 변수를 직접 참조 포인터(Bad)라고 한다. 반면, 원시변수의 메모리주소를 한번 감싸서 가지고 있는 = 쩜을 이용해 원시변수에 접근할(가리킬) 수 있는포인터를 간접참조(Good)라고 한다. . 직접 참조 포인터의 예 B = &amp;A | . | 간접 참조 포인터의 예 B = { key: &amp;A} B.KEY로 A에 접근 | . | class B { int A } B.getA()로 A에 접근 | . | . | . | 문제는 직접 참조 포인터(원시변수의 메모리주소를 값으로 바로 가짐)를 가 A의 메모리주소값을 가지고 있다고생각하여, B를 할당하는 사용하는 C, D에게 참조의 전파를 실패하게 만든다 . 처음 코드를 작성할 때, C와 D는 B가 가진 A의메모리주소값을 가지고 있다 . | 하지만 runtime시 B가 다른놈을 가리키게 된다면? . C와 D에는 여전히 &amp;A만 존재하고 | B는 다른 변수인 K의 메모리주소값 &amp;K를 가리키기 바꼈다면? B = &amp;A | C = B, D = B | B = &amp;K B는 K를 | C,D는 A를 여전히 가리키고 있다. | . | . | 이후 C와 D를 사용할 때, K의 값을 가리키는 것처럼 보이지만, 중간에 setter에 의해 B가 K를 가리키게 바뀌고, C와 D는 여전히 A를 가리키게 된다 | . . | . | A의 포인터변수 B는 포인터로서 가리키는 놈이 바뀔 수 있다고 항상 생각하고, 그 C와 D는 B를 가리키는 놈으로서 값이 아니면 절대 할당X 포인터(B)의 포인터를 가리키게 해야한다. . B = { VALUE: &amp;A } | C = B, D = B C와 D는 B를 할당해서 사용한다. | . | B.VALUE = &amp;K B가 간접적으로 한번 감싸서 K를 가리키도록 변화시킴에 따라, C와 D도 B.VALUE를 통해 똑같이 결국 K를 가리키게 된다. | . | . | 외부에 노출된 참조 = 원시변수의 메모리주소 값으로만 가지는 직접 참조를 지양하고, 타변수의 메모리변수는 한번 감싸서 가지고 있음(B with map or class)으로써, 이를 사용하는 변수들(C, D)도 변화에 대응되도록 하자 . 참조가 바뀔 가능성이 있는 B같은 변수들은 한번 상대방을 한번 감싸서 가지고 있는 간참조를 이용하자. | . | 나의 정리 . my) runtime시 레퍼런스(한 변수가 참조하는 주소)가 바뀌는 경우가 있고 그럴경우, 일반 변수로 받아보던 또다른 참조변수들은 업데이트가 안되니 | 바뀔 예정이 있는 애들은 map안에 변수가 포인터가 되도록하고 받아보던 또다른참조변수들은 map을 할당받고 | 바뀌는 것은 map안의 .변수가 reference를 할당받으면서 변경가능하게 하자 | . | . | 직접 메모리 참조시, 걔를 참조하는 애들은, 업데이트가 자동반영안되 문제가 된다. | 참조하는 애들은 껍데기를 참조하도록하고, 변경가능한 놈은 내부에서 바뀌게 한다. 대신 참조하는 애들은 껍데기-&gt; .점을 통해 -&gt; 업데이트되는 내부에 접근하게 한다 | . | **이 원리(참조에 참조, 점을 통한 다시 한번 참조 찾기)는 객체지향에서** 직접참조X 위(바깥) 참조를 통해 아래(내부)로 내려오는 구조로서 | 인터페이스를 정의시, 추상클래스 메소드호출 -&gt; 그 함수가 구상클래스 메소드를 호출할 수 있는 원리이며 | 링크드리스트의 원리 | 데코레이션 패턴의 원리 | . | 책에서는 동적 바인딩이라고 표현한다. 우리는 직접참조는 지양하고, 참조에 참조를 이용해야, 런타임변경에 안전해진다. | 그래서 객체지향에서는 값을 이용하지 않고, 모든 곳에 참조를 이용한다. | . | | | 02 식별자와 다형성 . 객체는 값이 아니라 식별자(메모리주소)로 식별 . 식별자(identifier): 객체를 구분 지음. runtime시 load된 메모리주소 값이 같아도 같은 객체가 아님. | 객체가 같다 = 메모리주소가 같다 = 식별자가 같다 만약, 객체가 아닌 값만 사용하는 context(원시변수 등의 값 contetxt)가 있다면, 값이 같다 = 같은 것이다 | . | java에서 equals를 사용하는 이유: java에서는 ==비교는 default로 무조건 식별자(메모리주소)를 비교한다. 문자열 비교시 식별자(메모리주소)대신 비교하라고 equals | 객체 비교시 식별자(메모리주소) 대신 비교하라고 equals/hashCode 재정의 | . | . | . | 다형성(polymorphism)이 지원되어야 진짜 객체지향 . 다형성의 2가지 요소 . substitution(대체가능성) | internal identity(내적 동질성) | | 대체가능성: 구상형 객체 생성시, 변수를 추상형 or 구상형 선택해서 받을 수 있다. . 다 미리 생성되지만, 하나의 형을 변수로서 선택했다면, 해당형에 포인터를 배정하며 동적바인딩된다. | . . . 추상형(Runnable)에 정의된 기능만 사용할 수 밖에 없다. | 하지만 포인터(Runnable, 추상형)의 포인터(Worker)를 통한 .run()의 실행이라 구상형이 구현된 로직을 실행한다. 한번 거쳐서 구상층의 내용이 실행되므로 비용이 크다. | . | 자세히 보면, Woker()객체 생성시 추상형 Runnable객체가 먼저 생성되고 | 구상형 Worker의 객체가 생성 미리 생성된다. | 어떤 변수를 쓰냐에 따라서 2개 중 1개의 형에 포인터를 배정한다. | . | 추상형인 Runnable변수에 배정했다면, run()실행시 Runnable부터 찾아 들어간다음 | run(추상메서드)를 찾아간다음 | 실제구현부인 Worker.run()으로 들어가서 실행된다. | . | 이 모든 것은 runtime에 시행되어 동적바인딩이라 부른다. | . | 내적 동질성: 추상형으로 받았어도, 구상형 생성자로 객체 생성했다면, 구상형(출신지)의 메소드가 호출된다. . 메서드 참조는 출신지가 제일 중요하다 추상체의 worker.print()를 호출했지만, 객체 생성자가 호출된 HardWorker()가 물려받은 print()가 HardWorker내부에서 호출된다. | . | 변수선택으로 인해 형은 달라지더라도, 내적동질성 = 출신지메소드가 호출된다. | . | | object(객체)가 갖춰야할 2가지 . 기능의 캡슐화(Encapsulation of functionality) 복잡한 기능, 상세기능은 객체 내부의 메서드로 가져 사용자에게 쉬운 인터페이스를 제공하지만 | 궁극적인 목표는 수정/추가시 발생하는 변화에 따른 여파를 격리 쉬운기능 노출 = 복잡한 기능 내부에 갖힘 -&gt; 캡슐화 = 로직의 격리 -&gt; 외부에 영향 줄어듦 | . | . | 상태 관리(Maintenance of State) 관리의 대표가 은닉화다. | 상태값들을 감춰서 내부에서 관리해라는 뜻. 변화에 대한 여파가 오지못한다. | . | . | | 03 theater(객체의 설계) . 상호의존표 . 책(error 빨간색): 잘못된 객체지향 설계 . . | 수정본 . . 받아오되, 필드객체로 값으로 저장하고 있어야 의존성이 보인다. 메서드인자로 받아오되, 그 class를 필드값으로 저장없이 다른 것을 위해 사용만 한다면 의존성은 보이지 않는다. | . | . | . | . Theater . theater(시작점)는 . &lt;-&gt; 자신이 가진 가격정보를 넘겨주어, 만들어 파는(찍어낼) ticket을 서로 안다 . 내부 발행(생성)객체는, 반드시 this로 정보를 줘서, 현재 발행 주체를 객체=식별자로 알려주면서가 정보를 제공하여 생성하게 한다. . theater.fee의 필요한 값만 넘겨주어선 안된다. 객체는 식별자로 이야기한다. | class내 생성이므로, 여러 인스턴스가 각자의 정보를 가지고 있기 때문에, 인스턴스 theater마다 서로 다른 정보를 가지고 있고, 서로 다른 정보의 Ticket이 발행된다. | . | 내부 메서드안에서 new Ticket( this:현재인스턴스의 정보 )로 바로 생성할 재료객체를 앎. . 정보를 this로 현재instance의 정보를 제공하여 내부 생성객체는 서로 안다고 표현한다. . . | . | 자신이 만든 ticket을 office에게 맡기니 . office는 -&gt; ticket을 안다 재료객체를 받은 것은 안다고 표현 | . | . | office는 받은 ticket을 seller에게 표 팔기 위해 . seller -&gt; ticker을 앎 받은 것을 안다고 표현 | . | . | . | -&gt; 내가 내부에서 만든 ticke 재료객체를 발행과 동시에 받아갈(줄) N개의 office(들)을 안다 . 내부 생성객체를 받아갈 객체(들)는 외부에서 인자로 들어온 뒤, 자기가 add메서드기능 제공해서 받아가야하므로 안다고 표현한다. . 뭔가를 받는 놈도, 받을 준비가 되어있어야한다( 받는놈.add( ), 받는놈.set( )) | 정해진 수를 받아갈 땐, 받을놈 + 그 갯수를 함께 인자로 받는다. | 안 상태 = 인자로 받아온 상태에서, 들어온 객체의 기능을 통해, 내가 가진 재료객체를 건네줄 수 있다. 받아온 객체.add( 재료객체 ) 형식으로 객체에게 건네준다. | . | 받아온 객체 목록은 List필드값으로 저장해서, 확인용으로 쓸 수 있다. | . . | . | -&gt; 자기가 발행하는 내부(발행)생성객체 invitation을 서로 안다 . 내부 발행객체는, 현재instance의 정보를 받아가므로this를 건네준다. . 여러 개를 받아가면, add기능을 제공받고 | 1개만 받아가면, set기능을 제공받자 | . | 내부 생성객체는, 메서드인자를 통해 들어와 자기의 기능으로 받아가야하므로, 안다고 표현 . . | . | -&gt; 자신이 발행하는 invitation을 발행과 동시에 받아갈 audience를 안다 . 내부 생성객체를 넘겨받을 객체는, 인자로 들어와서 받을준비=지 메서드로 받아갸므로, 또한 안다고 표현 . . | . | -&gt; 자신의 기능(.enter( ))의 대상인 audience를 안다 . (여기선 검증) 기능의 대상 객체를 메서드의 인자로 받아와야하기 때문에 안다고 표현 . theater.enter( audience ) | Ticket자체로도 .isValid()를 확인하는 기능을 할 수 있지만(객체세상) 하지만, theater 인스턴스마다 서로 다른 정보로 발행을 하니, 발행한 theater정보가 필요하므로, 발행시 정보를 준 this가 필요하다 | . | . . | . | . | . Ticket . ticket(시작점theater이 아는 3 중 1)은 . &lt;-&gt; theater가 ticket을 발행(안다)할 때, 현재 theater instance(발행주체)로부터 정보를 받아서 생성하므로 theater를 서로 안다 . 생성자에서 외부 인자로 받아올 때 안다고 한다. . 특히, 발행주체는 fee정보 대신 불변하도록 final field로 가지고 있는다. | . . | 추가 . getFee(): 정보를 객체로 받아왔다면, 객체내부정보를 getter를 통해 중개해서 제공한다. . final로 불변이지만, 발행주체의 정보(원시값 fee)가 변하더라도, 원시값(fee)을 포장한 (theater)를 통해 정보를 가져온다 | .을 통한 포인터의 포인터 정보는 해당 값이 바뀌어도, 실시간 변화된 정보를 받아온다. | 값의 변화가 반영되려면, 참조의 참조로 얻어와야한다! 그래야 참조의참조 업데이트가 runtime에 반영(이후에도 반영) 내 고유정보가 아니면, 값으로 받아오지 말자! | 포인터의 포인터를 비용으로 치루더라도 -&gt; 변화가 바로 반영되도록 하는 원리를 가지게 한다. | . | . . | isValid(Theater theater): . 발행되는 소모되는 재료객체로서 있다/없다 존재 확인이 필요할 때 null객체를 가지고 있는다. . | 이미 쓴 표인지 검증할 때, flag변수를 상태값으로 가지고 있는다. . | 그외에, 발행주체에 대한 검증 + 잘못 생성된 null객체인지도 추가한다. . 발행되는 재료객체로서 null객체를 가진다. | . . | . | . | . | . | . Invitation . Invitation(시작점theater이 아는 3 중 2)은 . &lt;-&gt; theater가 invitation을 발행(안다)할 때, 현재 theater instance(발행주체)로부터 정보를 받아서 생성하므로 theater를 서로 안다 . 생성자에서 외부 인자로 받아올 때 안다고 한다. 특히, 발행주체는 fee정보 대신 불변하도록 final field로 가지고 있는다. | . | . . | 추가 . 발행되는 소모되는 재료객체로서 있다/없다 존재 확인이 필요할 때 null객체를 가지고 있는다. | . | . | . TicketOffice . office(시작점theater이 아는 3 중 3)는 . -&gt; 받는 ticket을 안다 . 메서드의 인자로 받는 재료객체를 (저장도 해야하니) 안다고 표현 . 받을 때는, 주는 객체한테 들어가서 받는 기능을 제공해야만 한다. 이 때, 재료객체를 인자로 받는다. | . . | . | (심화) 의외로 주는 theater를 모른다. . office는 주는 주체는 모른 상태에서 받는 기능만 제공한다. my) 주는 주체 내부로 들어가 받는 기능만 제공할 땐, 주는 쪽을 몰라도 된다. 넘어가 기능 제공하는 쪽은 몰라도 된다. | . | . | office는 theate에게 주는 것이 없기 때문에, 인자로 받아올 필요가 없다. 화살표 방향: 주는쪽이, 줄때는 받는 쪽을 알고서 인자로 받아와, 자기 기능으로 받아가게 하여, 준다. | 이 때, 받는 쪽이, 들어와서 자기 기능을 open(제공)해 줄때만 주는 것이 가능하다 화살표 나가는 쪽이 많이 알고 있고, 줄 수 도 있지만, 받는 쪽이 기능 제공(오픈)해줄 때만 줄 수 있다. 거만한 것은 화살표를 받는 office다. 주는데도 안받을 수 있으니 | . | . | 화살표 나간다 = 알고 있다 = 줄 수 있다?(X) = 알고서 인자로 받아왔지만, 받은 객체 = 화살표 받는 쪽의 받기 기능을 제공한다면, 이용할 뿐이다. | 화살표 받는다 = 화살표 쏜놈이 나를 받아or생성해서 쓰려고하여, 화살표 받는 쪽으로서 기능을 제공한다. | . | . | &lt;- 가지고 있는 ticket을 팔라고 seller에게 주는 데도, 역으로 안다.(= 주는 객체들이 이미 완성된 것이니, 니 상황에 맞게 빼가라고 기능 제공할테니, 나를 알아서 가져가, 기능 이용해) . **준다고해서, 화살표가 나가면서 알아야하는 것은 아닌가보다. ** . 줄 것이내부 생성해야하는 객체라, 내부에 와서 받아감으로 줘야할 때는 화살표가 나가서 알고 (Theater -&gt; Office) | 줄 것이 이미 생성된 객체라, 외부에서 빼갈 때는, 화살표를 반대로 받아서 상대방이 알고서 받아가 빼가는 제공 기능을 이용하도록 빼가는 기느응ㄹ 제공해서 준다.(Office &lt;- Seller) theater는 -&gt; office에게 내부발행해야하는 ticket을 받아가라고 할 때, 화살표가 나가면서 알고 있어야만 = 받아와야만 했다. | . | . | office는 -&gt; seller에게 ticket을 줄 때(이미 완성된 객체라 seller상황에 맞게 빼갈 때) . seller를 받아와, seller의 받는 기능을 이용해서 주는게 아니라 | seller가 이미 완성되어 가지고 있는 tickets를 알아서 빼갈 때는 seller가 office를 받아가서(알고서), 내부 재료객체(tickets)를 빼가는 기능을 seller내부 상황에 맞게 빼간다. seller상황에 맞게 빼가는 기능이니, 빼가는 놈의 상황에 맞는 여러 빼가는 기능을 제공할 수 도 있다. 초대권을 가진 audience을 만난 seller의 상황: 무료로 빼가게 한다. | 일반 audience를 만난 seller의 상황: 돈 주고 빼가게 한다. | | 빼가는 기능을 상황별 제공할 때, invitation여부를 몰라도 되나?? invitation를 받아가는 audience도 알아야한다. | 상황별 빼가는 기능만 제공하고, 상황 판단은 빼가는 놈인 seller에서 분기별로 알아서 결정해서 기능을 쓰게 한다. | . | . | . . | my) 정리 . 발행주체가 내부 생성 재료객체를, 받아가라고 할 땐, 화살표가 나간다 받아가는 기능을 제공하는 놈을 알고서, 메서드 인자로 받는다. | . | 갖다 쓴놈이, 창고에서 완성된 재료객체를, 빼갈 때도, 화살표가 나간다 상황에 맞는 빼가는 기능을 제공하는놈을 알고서, 메서드 인자로 받는다. | 결과적으로 빼가는 기능을 제공하는 office는 seller의 소속기관으로서 seller의 setter의 메서드 인자로 받아서 알게 된다. 즉, 빼가는 기능을 이용하는 상황의 메서드에서 인자로 받는게 아니라, 미리 알게 된다. | . | 소속기관이면, 생성시부터 정해지니, 생성자의 인자 -&gt; final로 박아두면 안될까 싶지만, 소속기관은 불변하지 않고 바뀔 수 있어서, setter -&gt; 정보field로 박아둔다. | . | . | . | 추가 . ticket과 다르게, 생성재료 정보를 가진, 발행주체 객체(Theater)가 따로 있는게 아니라면, 생성시 필요한 재료를 값으로 받아 필드로 가지고 있는다. . . | 받는 기능 제공시, 여러 번 받아와 저장한다면, 저장필드로 빈 리스트 필드를 가진다. . . | 외부에서 재료객체(ticket)을 빼가기도 하는데(By seller), 빼가기 전에 그 객체의 정보를 먼저 조회하기도 한다 . . | . | . | . TicketSeller . TicketSeller는 . -&gt; office에서 돈을주고 빼온(사온) 재료객체 ticket을 안다(모르고 팔 순 없다) . 알고서, 창고객체(office)의 기능을 이용해 빼온 재료객체를 return값으로서를 안다고 표현 | . | -&gt; office에게 고용되는 소속기관 = 상위도메인으로서 안다. + 재료객체를 빼오는 기능제공 대상을 안다 . 프리랜서 소속기관으로서 setter의 인자로 받아와 정보필드에 박아둘 프리랜서 소속기관, 상위도메인 객체를 안다고 표현 . 소속을 setter로 받을 것인지 / 생성자에서 받을 것인지는 신중하게 생각해야한다. 태어나서 불변하는 발행주체, 소속기관 -&gt; 생성자에서 태어날때부터 받기 | 중간에 계속해서 바뀔 수 있는 프리랜서의 소속기관 -&gt; setter로 받기 | . | . . | (창고로부터) 빼오는 기능을 제공하는 놈을 받아와, 상황별로 빼오는 기능을 이용해야해서 안다고 표현 . | . | -&gt; 재료객체 ticket을 거래할(받아갈) 거래대상 audience(고객)을 서로 알아야한다. . 서로알기 . 발행주체(정보보유, theater) &lt;-&gt; 발행재료객체(Ticket) | 거래대상: seller &lt;-&gt; audience seller: 빼가는 기능 제공시, audience를 알고서 거래가능한지 검증 -&gt; 물건양호시 사는놈의 돈 차감까지 해야한다 | audience: 들어가서 검증을 당하기도 하지만, 최종적으로 seller를 알고 seller가 거래물건을 주는 기능을 이용한다. | . | . | 메서드명만 getTicket(거래 대상)이지, 거래메서드다. . | 받는 놈기만 하는 놈(theater-office)은 갑으로서 받는 기능을 제공하기도 하지만, 거래에서는 사는 객체(audience)는 파는 객체(seller)에게 메소드 인자로 들어와, 거래가능한지 검증 -&gt; 물건양호시 돈 차감까지당해야해서 알아야한다. . 거래를 하는 상대객체를 서로 안다고 표현(트랜잭션 관계) | . . | . | (심화) theater-office의 관계에서 받기 기능을 제공하는 받아가는 office가 갑이었다면 . 여기(seller - audience) 거래관계에서는 받기기능이 없이, 검증당하고, 돈차감당하는 audience보다, 최종적으로 getter의 return으로 거래재료객체를으로 건네주는 기능을 가진 seller가 갑이다. . 최종 기능을 제공하는 쪽이 갑이다. | audience는 거래정보를 검증당하고, 돈을 차감당하는 기능만 제공하는데, 최종적으로 중요한 기능은 seller의 거래물건 제공기능이며, 그 안에서 audience가 들어와 검증/차감 당한다. | 파는놈 seller는, 사는 놈인 audience를 메소드 인자로 받아서 자기 기능으로 audience에게 거래 검증/돈차감기능을 활용하여 return으로 거래객체를 줄지/안줄지를 결정하는 기능을 제공해서 갑이다. | . | my) 거래관계에서 Seller와 Audience는 서로 알지만, 파는놈 Seller가 갑으로서 사는 놈.buy기능( 파는놈 )의 인자로 들어가지만, seller에게 제공하는 기능이 아니며, 그 내부에서는 사는놈(을)이 seller(갑)의 .getTicket( 파는놈this )의 거래메소드의 인자로 들어가서, 돈검증/물건양호시 돈차감까지 당한다. . 아래서 할 내용 . . | . | . | . | . Audience . audience는 . -&gt; 거래하여 받아와 나한테 저장하는 재료객체 ticket의 존재를 미리 안다 . 거래후 받아와 내 상태(field)로 저장(setter)해야한다면, 객체필드로서 미리 알아야한다. | . . (심화) 소모성 재료객체를 상태(객체필드)로 가질 땐, setter전 default상태를 null객체를 사용한다. | . | -&gt; 상대방이 줘서 상태로 저장하는 객체 Invitation은 미리안다. . setter 역시 받기기능으로, 받기후 내 객체필드로 저장하려면, 미리 알아야한다. . | (심화) 받기기능으로 받을 준비가 되어있는 객체는, 주는 놈이 일방적으로 알기만 하면 된다. . my) 받기기능 제공 -&gt; 주는놈이 setter or add로 일방적으로 알아서 꽂아주기만 한다.(소통은X) | theater -&gt; ticketoffice | theater -&gt; audience | . . | . | -&gt; ticket을 판매하는 주체이자 거래대상은 seller를 서로안다 . 파는놈이 갑으로서 팔기 기능을 제공하니, 알고서 받아와 기능을 이용해야한다. | (심화)사는놈은, 스스로 구매 기능을 가지나(제공하는게 아님), 파는놈을 인자로 받아와, 파는놈의 기능을 이용해서 물건을 받아와 저장한다 파는놈의 기능 내부에는, 사는놈을 검증/돈차감 해야하기 때문에 인자로 받는다. | . | . . 거래해서 받아오는 객체(Ticket)뿐만 아니라 파는놈(seller) 역시 알아서 그 기능을 이용해야한다. | . | 추가 . 고객(사는놈)은 태어날때부터 값 amount(돈)를 자신의 상태로서 가지고 태어난다. . . | 물건을 사는 놈은, 파는 놈이 알고서 이용할 기능 2개를 제공해야한다. . 거래가능한지 검증당하기 hasAmount | 물건양호시 돈차감당하고 성공여부 minusAmount | . (심화) seller(갑)에 의해, 검증/돈차감에 대한 최소한의 노출(boolean)만 해준다. getAmount로 내 정보를 직접 가져가서 하는 것이 최고의 노출이며 안좋은 것이다. | . | . | (심화)갑이 파는놈(seller)가 요구하는, 검증(거래가능한지 검증, 초대권 잇는지 검증) 및차감후 성공여부(돈 차감, 초대권 차감)메서드들은 파는놈(seller, 갑)이 사는놈(audience, 을)에게 요구하는 스펙들(조건들)이며 거래(트랜잭션)을 위한 조건들이다.. . hasAmount(거래가능한지 물어봄), getInvitation(직접 정보가져가서 검증) | minusAmount(돈차감후 성공여부), removeInvitation(성공여부 없이 바로 초대권 차감만) 트랜잭션 조건들만, 인터페이스(카테고리)로 빼서 책임을 분리할 수 도 있다. | TransactionCondition 어렵다.. | . | . | . | 상대방이 나에게 시키지 않고, 내 정보를 물어보고 내 외부에 직접 판단/검증할 때 getter주기기능을 제공한다. . 최고수준의 노출이라 딱히 좋다고 할 수 없다. | my) 내생각에는 NULL객체로 바로 확인 가능할 경우, 직접 가져가서 != Null객체 으로 바로 확인가능하니까, 시키지 않고 받아가는 것 같다. | . . | (심화) 사는놈은 스스로 사용하는 기능은 buyTicket밖에 없고 . 다른 메서드들은 전부, 다른 클래스들을 접대(기능제공)해주는 메서드들 밖이다. setter도 상대방이 일방적으로 알고서 꽂아주는 것이기 때문에, 상대방용이다. 상대방이 안다 = 상대방 내부에서 사용한다. | getter도 상대방이 정보를 직접 받아가 상대방 내부에서 사용한다. | 4개의 트렌잭션 스펙들은 seller가 알고서, 자기내부에서 이용하는 것이다. | . | . . 알고서 필드를 가져오되, 상태값(필드)로 해당class 객체를 저장하지 않으면, 의존성은 안보인다. . . | . | . | . | . Main . main은 . . 원래 Main부터 짜야한다. 절대 class -&gt; Main 순으로 짤 순 없다. | 내 도메인에 맞는 시나리오부터 main에서 짜면서 객체들의 협력상황을 보면서 | class들을 만들어나간다. | | 테스트코드부터 설계에 반영하려면, 테스트코드가 실제 설계에 사용되는 client코드와 닮아있어야하는데 클래스를 완성되었다고 가정하고, 클래스를 객체로 어떻게 사용할 건지 먼저 짜보는게 훨씬 낫다 | 상상속으로 class를 짜봤자, 어떻게 사용되는지는 모른다. | . | | . 04 Type, condition, 책임기발 개발 . type 변수명 = 메모리주소의 별명 = my) 1개 class라면, 개별 인스턴스명 a = 3; : a라는 메모리주소에 a을 할당 | . | data type = 변수명이 가리키는 메모리주소를 시작으로 차지하는 데이터의 길이 java의 data type = 데이터의 길이 | . | 객체지향의 형(type) : data type(원시형)이 뿐만 아니라 모든 것을 type(형)으로 생각 | . | 객체지향의 Type: 4가지 개념을 구현 가능한 유일한 것 role : 역할을 type(형)으로 묘사 역할 interface | 역할 class | 역할 enum | . | responsibility: 로직(책임)을 type(형)으로 표현 ~할 수 있음 : ex&gt; Reservationable의 인터페이스의 형 | 람다식도 형(function형) | . | message: 특정 역할들끼리 or 특정 책임들끼리의 협력을 위한 메세지도 type(형)으로 되어있음 string, integer로 넘기면 형이 아닌 값이다. 값: 불변하며, 보낼 땐 복사해서 간다. 협력하거나 동등한 대상이 아니다. | 상태관리 책임이 없음. 책임위임이 안됨. | 캡슐라이즈가 안되서 객체지향에서는 못쓴다. | . | 형: 객체의 주소(변수)을 보낸다. ex&gt; list는 복사안되고 참조주소가 넘어간다. | . | . | 프로토콜: 마커 인터페이스. 합의된 공통요소도 형(type). 몸체가 없어도 형을 가짐. | | jvm에서 동원 가능한 3가지 context type . static: 단 1개의 인스턴스를 생성시 but 동시성 문제는 따로 해결해야 함. . jvm에는 동시성 보장 장치가 없으므로 싱글톤을 보장하는 코드로 직접 짜야한다. | 책에서 static context를 완전히 버리길 권유 왠만하면 instance context만 사용하길 권유 | . | . | enum : 제한된 여러 개의 인스턴스 묶음이 필요시 + 제네릭 사용 불가 . static하지만, 생성에 대한 동시성 문제가 없음. static보다 더 빨리 만듦. . | enum으로 만드는 게 일반 instance보다 유리 | 많은 경우, 무제한 인스턴스(by class)가 아닌 경우가 많아서 class를 enum으로 대체할 수 있는 경우가 많다. | but 제네릭 사용이 불가하여, 형 대체 = 여러형을 알고 시을 때 or 추상층에 T로 구상층이 특정형만 알고 싶을 때 사용이 불가능하다. 제네릭 사용불가의 문제 때문에, enum 대신 마커인터페이스 + class 조합을 쓴다. | . | . | class: 무제한 인스턴스가 필요시 변수로 받아 만들어냄 . | 정리 . 동시성 문제(static)가 없고 제네릭(enum X)이 사용가능한 class + 인터페이스를 주력 형으로 사용하게 된다. | 확장없이 제한된 instance는 enum으로 대체하자 | static은 적이다. 쓰지말자. 사용한다면 Factory클래스( 생성만 해주고, 사용 은 안하니 상태값 X -&gt; 동시성 문제 없음 ) | 사용한다면 Utility함수(원래 사용시, 변할 수 있는 상태값 X) | | | | class 속 인스턴스메소드 vs 유틸리티 함수 this나 this.의 내부 상태값을 쓰지않는다? -&gt; class에서 빼내야하는 유틸리티 함수 메서드파리미터 + 지역변수 + 전역context변수만 가지고 정의되는 메서드 | . | this나 this.필드의 내부 상태값을 쓴다 -&gt; 인스턴스 메서드 | | condition 조건 분기: 특정 변수나 필드의 변하는 상태값에 대한 연산을 처리하기 위해 생기는 것 상태값(필드, 변수) = runtime이 바뀔 가능성을 가진 것 -&gt; 분기를 만들게 된다. | . | 조건 분기에 대한 전략 2가지 내부에 if를 나열하는 내부 응집성으로 모아두기 switch문을 이용하는 것 | if와 마찬가지로, 조건 분기 증가시 -&gt; 내부 코드 전체를 변경(추가)해야함 | . | **외부에 위임하여 if수만큼 외부처리기를 생성하고, 외부에서 분기를 선택하여 입력해주는 방식 ** 조건 분기위 위치를 내부 -&gt; 외부로 옮기는 방식이다. | 외부에서는 1개 분기에 대한 처리기만 넣어준다. | 대부분의 패턴이 이 방식을 이용 전략패턴: if 5개 -&gt; 추상체 + 5개의 전략객체(외부 처리기) 생성 | . | | | . | 내부 응집성(Cohesion) 있는 코드: 한 눈에 보이는 코드 but 안좋은 말 . . | 분기를 외부에 위임하여, 외부에서 선택한 분기를 주입하는(Injection) 코드: 내부에서는 처리기만 실행해준다. . . 내부에서는 처리기 실행안한 체로 받아와서, 실행만 해준다. | 외부에서는 그만큼 형(익명클래스 구현도 형)이 생긴다. | 내부 응집성을 줄인 코드 장점 내부 코드 수정이 없어진다. : 변화가능성은 전부 외부로 위임한다. 내부 코드 수정 없다 = 재사용 가능한 코드가 된다. 변화율이 큰 코드(if유발 = 확장/변화 되는 코드)는 외부로 | 변화율 적은 코드(처리기 실행등 사용만하느 코드)는 내부로 | . | . | | . | 책임기반 개발 - &gt; 추상화해서 역할이 나온다. . 사용자 기능 = 가치 = 시스템의 책임 . | 책임 = 가치 있는 기능 = 구상클래스의 메서드 . 인터페이스 등의 껍데기가 아닌, 실제 로직을 구현하는 메소드가 책임이다. | . | 책임인 메서드를 더 작은 단위의 책임으로 분할하자 . 예매 기능 = 너무 복잡하다 예매가 잘되어야한다 -&gt; 방대한 책임이 물려서 더 쪼갠 뒤, 개선해야한다. ex&gt; depth 2이상의 if -&gt; 분리 | . | . | 응집성이 높으면서도 (한눈에 보이면서도) | 결합도가 낮은 (의존성이 낮음) 코드로 쪼갤 수 있는 것이 실력 | . | 쪼개진 책임(메서드들)들을 추상화한 것이 역할이라고 정의한다. . 역할이라는 것은 여러개의 책임(메서드)들을 말하는 게 아니라, 책임(메서드)들을 추상화한 것 | 쪼개는 과정에서 공통점 / 공통의존기능이 발견된다. | 이것으로 추상화에 성공했다면, 또다른 쪼개진 책임 추가도 쉽게 된다. 1개의 책임만 있어도, 더 높은 수준으로 추상화해서 역할로 승격해놓고 만들어놔야, 이후 또다른 책임의 확장이 쉬워진다. | 연역법 성공 -&gt; 귀납법으로 다른 사례를 만들 수 있음. | . | . | 책임과 역할을 따로 생각하긴 어렵다 . 다양한 책임들(메서드들) -&gt; 공통코드 or 공통 의존기능을 뽑아서 -&gt; 역할로 추상화 하는 것이 굉장히 어렵다. | . | my) 전략패턴이나 추상클래스 -&gt; 익명클래스 분신술 구현의 전략메서드/훅메서드는 공통점을 찾기 어려운 분기속 개별구상체들의 코드들을 -&gt; 구상체만의 로직들만 모아 1개의 책임(메서드)으로 묶고 -&gt; 명칭을 추상화하여 -&gt; 인터페이스로 역할을 만든 것이라고 보면 될 것 같다. . 역할 = 추상체가 가진 전략메서드, 훅메서드 | **책임들 = 구상체들의 개별 구현 전략메서드/템플릿메서드 or 익명클래스의 실시간 개별구현 전략/훅메서드 ** | 만약, 전략메서드/훅메서드가 인자를 받는 경우라면? 내부 라이브러리 레이어들도 다 바뀌어야한다. 추상화 능력이 떨어지면, 수시로 라이브러리가 업데이트 된다. | . | . | . | 객체간 협력은 구상체의 책임(메서드)들이 아니라 추상체의 역할(전략메서드, 템플릿메소드)로 해야한다. 협력 구축은 보다 높은 단계인 역할단계(추상층)에서 협력해야한다. | 책임단계(구상층)에서의 협력은, 책임(메서드)의 추가/변경시마다 협력시스템에 위험이 전재힌다. 책임 추가 -&gt; 협력도 깨진다. | . | . | 정리 값(전달시 불변값이 복사, 실시간 변동 반영안됨)이 아니라 형Type(참조를 건네줘서 연결, 변화가 반영되는 포인터의 포인터)을 써야한다. | 조건 분기를 제거하는 방법은 2가지인데 내부 응집도(한 눈)보다는 외부로 분기를 보내야한다. 그러려면 책임들 -&gt; 역할로 추상화한다. | . | . | . 05 theater with reservation and discount policy(객체의 설계2) . 최종코드 . | step1의 모델 . . . . theater가 재료객체 ticket, invitation을 내부에서 발행(생성)하였는데, 그 이유는 발행시 theater를 생성자의 인자로 받아가 정보를 필드에 저장하도록 내부에서 넘겨줬기 때문이다. | theater가 발행한 ticket 판매의 복잡한 책임은, 책임(메서드)이 커지기 때문에 직접 하지 않고, ticketOffice에게 가져가게 위임했었다. ticketOffice에게 와서 받아가라고 하여, 발행과 동시에 넘겨줬다. | ticketOffice는 ticketSeller를 통해 판만큼의 가진 티켓은 차감 + 그만큼 Fee를 얻었다. | . | ticketOffice는 티켓 창고역할만 하고, 실제 판매는 프리랜서인 ticketSeller를 고용(하위도메인으로서 소속기관Office를 필드로 가짐)하여, Seller가 판매를 한다. | . | step2의 새로운 모델(책) . Fee &lt;-&gt; Amount의 판매(물물교환)로직이 사라진다. invitation도 사라짐 | 대신 reservation을 하게 한다. | . | 책에서는 Screening이라는 상영정보 객체가 .reserveSeat()을 예약 책임을 가지고 있다. 정보전문가 패턴에 의해 정보를 가장 많이 가진 객체가 책임을 지는 구조이다 -&gt; 말이 안된다. | 상영정보는 real domain에서는 자리번호/순서/시간을 가진 단순 시간표정보일 뿐이다. | 게다가 현실에서는 1개의 상영정보(1 Screening)는 여러 영화(N Movie) 가지는 구조를 가진다. 10시 - 스타워즈 | 10시 - 인디아나존스 | 10시 - 아이언맨 | 영화들은 1개의 상영정보만 알아서 fk로 참조하면 되는 것이다. | N을 1의 필드로 넣으면 복잡해진다. 상영정보에 movie제목을 넣지말자. | 일부만 다른 값을 가져 중복 문제가 발생할 때, 다른 값을 가지는 그 필드(영화제목)은 정규화 대상으로서 N table로 옮겨야함. | . | . | 그렇다면, 상영정보는 movie 제목도 없어야하고, 시간만 가지고 있어야한다 -&gt; 예약을 스스로 할 수 없다. 현실에서는 여러개의 극장 : 극장마다 여러개의 영화 :그 영화마다 여러개의 상영정보 형태를 가짐. | . | . | 책에서는 할인 정책도 소개한다. 어떻게 할인하는 가 -&gt; DiscountPolicy AmountDiscountPolicy: 돈을 깍아서 | PercentDiscountPolicy: 퍼센트로 깍아서 | . | 언제 할인하는 가 -&gt; DiscountCondition TimeDiscountCondition: 시간이 언제인지 기준으로 할인 | SequenceDiscountCondition: 몇번째 상영인지를 기준으로 할인 | . | 책에서 소개한 것 처럼 연관관계가 수직관계로 할인정책이 나오진 않는다. 각 정책들은 교차조건이다. 서로간의 부모 자식간은 상관없다. | . | . | . | . Main . 객체 설계시 Clinet코드부터 시나리오에 맞춰 짜야한다. . . | . client에서 극장객체를 만드는데, Theater은 Ticket 발행에 필요한 정보인 fee를 Long 값 -&gt; 값 객체 Money를 사용하게 한다. (책에서 요구함) . 값 객체는 일반 참조형과는 다른 성질을 가지고 있다. | . | client에서 영화객체를 만드는데, . 제네릭으로 upperbound T형(추상형)의 구상형들 중 1개 구상형인 특정할인정책 아는 상태의 영화이다. . 왜?? | 책에서 영화는 무조건 DiscountPolicy 2개(Percent or Amount DiscountPolicy) 중에서 1개의 policy는 movie에 필수 정책 적용해야하는 제약조건을 주었다. 1:1제약조건의 적용은 값으로 적용X / 생성자에서 객체로 주입하여 적용 X / 제네릭을 통해, 추상체로 정의된 정책을 &lt;형&gt;으로 1:1 제약조건을 적용한 SubType을 만들어낼 수 있기 때문이다. 참고) FrontEnd &lt;Client&gt; FrontEnd&lt;ServerClient&gt;의 경우 1:1 제약조건이 아니라 들어오는 구상체마다 구현이 다른데, 여러 구상체를 받아야할 경우 추클-&gt;익클 분신술 SubType으로 1개의 구상체가 여러 특정형을 상황에 맞게 SubType을 만들어내야하는 상황이였음. | 근데, 현재 구상체Movie에 타 추상체(DiscountPolicy)의 구상체들을 택 1일해서 적용하려면, 인자로 받더라도, 그 구현체에 따라 다르게 작동한다. 더이상 구상화할 수 없는 Movie에 대해 N개의 추상체가 택1로 들어와야한다면 instanceof로 확인해서 쓸 수 밖에 없을 것이다. | my) 구상불가능한 최하위 구상체 vs N개의 구상체 택1의 1:1매칭은 instanceof와 마찬가지로서, 제네릭으로 적용한다. 여러 구상체가 매번 인자로 들어와도, 추상체로 들어올거라, instanceof 써서 그에 맞게 적용하는 수 밖에 없을 것이다. | . | . | . | 이 때, Movie는 더이상 구상형Movie가 아니라 Movie를 추상층으로 한 Movie&lt;특정형&gt;의 Movie의 Subtype Movie이며 Movie보다 더 구상형이 된다. | Movie는 SubType을 가질 수 있는 Class라고 인식해야한다. | . | . | Movie의 제네릭을 통해 1:1 제약조건 적용된 SubType이 정해졌으면, 4개의 정보를 받아서 생성한다. . 3) 실제로 영화가격은, 바로 안정해지고, 상영정보(Screening)에 있는 상영시간에 의해서 차후 정해진다. | 4) AmountDiscount의 1:1 필수 제약조건의 policy가 적용된 SubType Moive 상태에서, SequenceAmountDiscount라는 더 구체적인 when?의 condition policy의 추가 정책은 먼저 지정된 제약조건policy Type에 맞게 + 생성자 인자에 객체로 주입해서 정책 적용하였다. PercentDiscount ?? | ?? | . | AmountDiscount SequneceAmountDiscount | ???AmountDiscount | . | condition policy(when)의 적용을 인자로 하려면, 제네릭으로 먼저 적용된 제약조건 policy에 맞게, 객체로 적용한다. | . | . | 생성된 영화는 theater가 받기기능으로 받아가 저장한다. . 각 극장(1)마다 걸릴 영화(N)에 대해 매칭을 받기기능으로 1쪽에 저장하였다. 각 영화(1)마다 걸릴 상영정보(N)또한 극장 안에다가 매칭시켜줘야한다. | . | . . | . | theater에 생성된 영화에 딸린 상영정보들(Screening)도 넣어 저장한다. . 하위도메인으로서, 상위도메인인 영화_id(fk) 대신 영화객체를 매번 넣어준다. . | 상영정보에 예매제한이 있어야하는데, 원래는 상영관을 사용하나, 상영관 대신 가용좌석수를 통해 무한예매를 방지한다. . . | 여러개를 넣을 것이므로 변하는 변수들은 변수로 지정한 뒤, 밖에서 반복문을 돌린다. . seq, hour은 같이 같은 제한갯수로 도니까, 3시간마다 돌리면서 24시전까지의 제한이 있는 hour에만 제한을 주고, 안쪽에서 같이 돌려준다 | 매번 하루의 제한이 끝날때마다 day를 바깥에서 돌려준다. 8일부터 31일까지 돌릴 예정이다. | . . | . | theater와 협력할 ticketoffice와 계약을 맺되, office에게 떼줄 수수료(fee)인 계약조건도 같이 인자로 받아서계약한다. . 기존에는 티켓을 팔아줄 협력 ticketOffice들을 받아와서 setter로 나에게 꽂아넣어서 리스트만 저장했었다 . theater.setTicketOffices(ticketOffice); . | 지금은 서로 알아서 계약을 한다. . 계약시 들어가는 수수료10.0도 사실 객체로 메세지를 보내야한다. 인자에 값을 쓰면 객체지향 위반이다. | . . | . | seller는 main코드 변화가 없다. . . | audience - buyTicket 대신 Customer가 상태값(변하는 변수)으로 자본금을 가지고 태어나, reserveTicket()의 예매를 하도록 바뀌었다. . . | theater가 client코드 -&gt; 외부 -&gt; 나중에는 UI로 저장하고 있는 영화 / 상영정보드을 보여줘야할 책임이 있기 때문에 Main에서 getter(주기)기능을 제공한다. . for + break;로 첫번째 것만 선택했다고 가정하고 한다. . | Customer는 스스로 예매.reserve()를 하지만, 사는 놈은 을의 위치이다. 가지고 있어 파는 놈(seller)와 산 것을 검증하는 theater의 을 인자로 받아서 내부에서는 그들의 기능을 이용한다. . 구매할 때, Ticket 1개만 구매하는 것이 아니라, 어떤 영화의 어떤 상영정보를 골랐는지 살 재료객체도 같이 인자로 받는다. 추가로 제한을 확인해야하는 구매 수량도 인자로 받는다. | reverse(): 예매 특정 seller에게 | 이 theater의 | 특정 movie를 | screening일 때 | 2명이서 보고 싶다고 예약을 한다. | . | . | . | Customer는 내부에서 파는놈/산것 검증하는 놈을 인자로 받아서 이용하는 이유는 산 것을 반환받아 내부 필드에 꽂아넣기 위해 + 산 것을 검증하기 위해서 갑들을 인자로 받는다. 그외에 구매수량도 들어간다. . 내부에서 갑인 thater가 theater.enter ( customer )로 예매 성공한 customer의 예매 정보를 검증한다 | 예매좌석수 2도 객체지향 위반이다. 실제론 SeatCount.of(2)가 들어가야할 듯 | isOk의 불린형도 원시값이라 객체지향 위반이다. 객체로return되어야한다. 위에 반복문으로 돌악는 seq도 SequenceNumber.of(seq)의 객체로 들어가야한다. | 영화제목도 Title.of()로 객체로 들어가야한다. | . | . . | . | 원시값을 메세지로 넘기면 안된다. 객체만이 역할을 수행한다. Type만이 책임을 수행한다. . 가능좌석수를 100으로 확신하고 썼어도… 확장가능성이 없다고 확신하면 안된다. 중간에 바뀔 수 있으면, 다른데 전파를 제대로 하기 위해서는 객체껍데기로 한번 쏴서 포인터(변수)의 포인터(갖다 쓴놈)이 대응을 할 수 있다. | . | DiscountCondition . 일단 책에서 나오는 수직구조의 policy연관관계는 틀렸다고 한다. . . | Condition Policy는 최소화된 2가지 역할을 공통적으로 가지는 인터페이스다. . my) 추상메서드는 공통을 모은 것이므로 책임(메서드) -&gt; 역할(추상메서드)이라고 승격해서 불러야한다. 아래 2가지 역할은 iterator패턴과 동일하다. hasNext -&gt; next() 보다는 2가지 역할이 중요 | . | . | . 조건을 만족하는지 액션 발동조건 검증 역할 isSatisfiedBy() 여기선 상영정보객체 + 관객수를 받음 | . | 조건 검증 통과시 할 정책적용 액션역할 여기서는 calculateFee( )로 discount 적용 액션 | . | . | 외부 조건에 의해 변화/발동하는 경우, 2가지 인터페이스를 가져야한다. 발동조건 검증 메서드(trigger) : is~ has~ (외부조건 파라미터) | 액션 메서드(action): 발동(외부조건 파라미터) DiscountCondition에서도 있고 외부 조건에 따라 정책 발동 | . | Screening의 seat필드에 대해서도 사용례가 있음. 외부 조건에 따라 필드변화 | . | . | | 인터페이스 제일 좋은 것은 마커 인터페이스 | 책임/역할이 1개인 인터페이스가 2번째로 좋다. | 여기선 역할이 2개인데?? 인터페이스가 충분히 추상화되지 않았다. | 2개 정도도 책에선 만족한다. 메서드를 1개로 하면, layer가 그만큼 깊어지고, 이해하기 힘들 수 있다. 너무 깊은 추상화는 팀원들의 화를 불어일으킬 수 있음. | . | . | 메세지 인자가 없는 함수 = 프로시져 = 혼자서 스스로 책임 수행 결합이 약해지는 단점. | 우리 수준에서 못짠다는 단점 | . | 인자가 1개인 함수 2번째로 좋은 함수로서 우리가 짜야하는 함수 | . | 어떻게 좋은 함수(인자 1개)를 짤 수 있을까? 여러개의 인자들을 객체화 시켜서 객체 1개로 전달한다. 언제나 옳은 객체지향 메세지가 된다. | . | 인자가 2개이상이다? 메세지가 충분히 추상화, 객체화, 형이 되지 않았다. | . | . | . DiscountPolicy . 책에서는 enum으로 적용하지만, enum은 형Type이 될 수없다. (제네릭도 적용 불가?!) . | policy 자체는 마커 인터페이스이지만, 그 내부에 policy종류별로 policy 마커 인터페이스를 상속한 인터페이스로 정의한다 . . inner interface의 정의는.. 부모interface를 중괄호로 구현해서 상속시켜야한다. | policy 자식의 종류에는 NONE policy도 포함시킨다. | . . 차후 자식 policy는 아래와 같이 적용할 예정이다. . . | . | 차후 상세 정책은 . policy 자식 중 1개를 구현하면서 . | condition policy(중간추상층, 1개의 메서드를 중간에 미리 구현)를 상속한 . | 구상class를 만들어 쓸 예정이다. . . | | . Condition -&gt; Policy 순으로 정책 적용해보기(시행착오) . DiscountCondition은 어쩔 수 없이 2개의 메소드를 가진다. 구상체를 추상클래스(중간 추상층)로 만들고 발동조건 메서드 1개를 중간에서 막고, 액션메서드는, 2번째 정책(마커인터페이스)를 구현하되, 개념을 액션메서드에 녹여서 구현한다. class는 내려온 2개의 추상메서드들을 반드시 개별구현해야하지만 | abstract class는 상위추상층의 추상메서드들을 중간 추상층으로서 중간에 @Override개별구현하여 fix해놓으면 최종 구상class들은 안보이지만, 갖다쓰는 물려받은 메서드가 된다. 많은 추상메서드들 중에 선택해서 중간구현할 수 있다. | . | my) 추상클래스 사용례 전략패턴: 구상체들의 개별구현을 자신의 분신술로 Main으로 끝까지 미룰 때 | frontEnd: 최하위구상층이 여러특정형을 알아야하고 다 개별구현해야할 때 제네릭+분신술 쓸 때 | movie : 여러특정형(policy)과 필수로 1:1매칭되어 적용되어야할 때 | DiscountCondition: 인터페이스의 2개 메소드 중 1개를 중간추상층으로 구현해야할 때 | . | . | 2개의 메소드를 가진 Condition Policy 인터페이스 처리 전략 원래는 특정형의 구상체class가 2개의 메소드를 구현 | 특정형 기반으로 제한(추상클래스로 받을 기존 구상형)하여, 추상클래스 중간추상층으로 만들어, 1개의 메소드만 중간에서 선택구현하여, 자식은 안보이지만 물려받아 갖다쓰고, 떠내려간 1개의 추상메서드만 구현하게 한다. 중 간추상층에서 개별구현할 때는, 구현에 필요한 정보를 생추상클래스의 생성자로 받게 한 뒤, final로 불변화시켜, 자식은 못건들게 한다. | . | . | 2개 중 왜 발동조건 메서드를 중간층에 개별구현 미리 했을까? 액션을 미리 구현하면 안되나? 액션과 나머지 2번째 적용 정책과 관련이 있다. | 액션부터 구현하면 4 x 2 = 8개 다 만들어야한다. | . | 요구사항에서 도메인과 1:1매칭을 이루는 기준 정책을 더 나중에 구상층에서 구현하는 방향으로 설계해본다???. 조건을 만족해야 액션하므로, 조건부터 중간추상층에 구현한다? | . | . | . SequenceDiscount(조건 정책) + AmountDiscount . Condition 정책 인터페이스의 2개 메서드 중 중간 추상층에서 미리 구현할 메서드 1개를 선택한다. . 발동조건 검증여부 역할(추상메서드)를 개별구상체마다 막아놓을 것이다. . . | . | condition policy정책인 DiscountPolicy를 구현한 구상체를 일반class구상화 대신 추상클래스로 구상화하여 중간 추상층을 만들고, 발동조건 메서드만 개별 구현하되, 개별구현시 필요한 인자를 추상클래스의 생성자로 받아 final필드에 박아준다. . . return 문 빠진 스샷 | . | 이제 중간추상층에 한번 더 나머지 액션 메소드 1개만 정의하는 구상층을 낼 수 있는데, 이 때 DiscoutPolicy의 자식policy 중 1개인 AMOUNT(Discount)를 구현하고, 그 2번재 정책의 내용은 액션메서드를 개별구현 할 때, 로직에 적용한다 . 중간추상층 SequenceDisCount(추상클래스)를 상속한 구상체를 만든다. . 추상클래스가 생성자를 새롭게 정의했다면(for 중간에 미리 개별구현을 위한 인자 받아오기) 자식의 생성자도 부모의 생성자 인자를 똑같이 받는 생성자를 최초 재정의해줘야하며, 받은 인자를 부모의 생성자가 쓸 수 있게super()에 넣어준다. 이로 인해 부모 생성자처리 -&gt; 부모 필드 채우기 가 부모에서 이루어진체로 내려오도록 위임해야한다. | 이후에는 자식의 생성자에, 자식구현을 위해 필요한 정보를 생성자 인자로 받아올 수 있다. super()의 부모생성자호출에 필요한 것만 먼저 필수로 받아줄 뿐이다. | . | . . | condition policy의 추상메서드 중 1개 액션역할 의 구현이 아직 안되어서 넘겨받아 구현해야한다. 여기에 2번째 정책(마커인터페이스지만)의 개념을 구현과 동시에 첫번째 정책 개별구현 메소드 내부에 개념을 녹인다.해버리면 된다. . AmountDiscount정책을 적용할 것이므로, 요금계산은 원래요금 - amount만큼 뺀 것을 반환해주면 된다. 값객체는 값을 상태값으로 가지고 있으며 스스로 연산책임을 가진다. 인자로 똑같은 값객체가 주어진다면, ** 내부에서 편하게 계산되며, **연산값으로 new 새로운 값객체를 생성해서 반환한다. | . | class 내부 개별 구현로직에 필요한 정보들은, 생성자를 통해 받아오게 한다. | . . | | SequenceDiscount(조건 정책) + PercentDiscount . SequenceDiscount(조건 정책) + AMOUNT(2번째 정책)이외에 나머지 정책조합을 구현해보자. -&gt; SeqeunceDiscount(조건정책) + PercentDiscount . 조건정책을 발동조건메서드만 개별구현하는 추상클래스로 구상화하면서 조건메서드만 중간추상층에서 구현한다. . 이미 구현된 SeqeuenceDiscount . . | . | 만들어진 조건 정책 추상클래스를 상속하면서 &amp;&amp; 2번째 정책 마커인터페이스를 구현한 최종 구상체에서 액션메서드에 2번째 정책을 반영한다. . Percent로 할인되는 2번재 정책을 반영할 것이다. 원래 요금 fee에 .minus를 할 것인데 | 원래 요금 fee에 percent(double형)만큼 .multi한 가격을 .minus해야한다. | . | . . | | 먼저 적용되는 조건 정책을 구상층의 이름에 먼저 나타나게 수정 . . | 실패 돌아보기 . Main에 있는 정책이 적용되는 도메인 Moive입장에서는 특정Discount만 알도록 설계되어있다. . . movie입장에서는 1:1매칭되어야하는 DiscountPolicy가 추상체로 묶였으면 좋겠다 | . | 하지만, DiscountCondition 정책을 먼저 적용하다보니 . 발동조건1 Sequence or 발동조건2 ???를 기준으로 묶이게 된다. | 정책은 다시 Sequence 정책1, Sequnece 정책2 , 3, 4로 분리되어버린다. 추상화가 잘못된 상태다. | | | 결과적으로 도메인이 묶이길 원하는 인터페이스부터 중간추상층으로 추상화하도록 2개의 인터페이스를 조합해야한다. . 메서드 2개를 가진 인터페이스를 중간추상층 화 해서 메서드 1개 막는 전략을 썼더니, 중간추상층화 한 인터페이스의 구상형 기준으로 나머지 인터페이스가 묶이게 되며되. | 중간추상층의 구상형갯수2 x 같이구현할 구상형 갯수 4 = 8개의 모든 경우의수를 다 class형으로 만들어야한다. | . | | Policy -&gt; Condition 순으로 정책 적용하기 . 2개 인터페이스 중 먼저 구현(중간추상층화)한다 -&gt; 그 인터페이스의 구상형들을 기준으로 최종정책들이 묶인다. . 즉, 묶이길 원하는 인터페이스부터 먼저 구현(중간추상층)한다. | . | 마커 정책의 구현은 조건 정책의 액션메서드구현과 밀접하므로, 중간추상층에서는 액션메서드를 먼저 구현하여 최종정책들은 1개의 발동조건 메서드만 구현하게 한다. . | 마커인터페이스와 조건정책인터페이스를 동시구현한다. . 그래야 액션메서드를 개별구현하도록 내려온다. | . ​ . . | . AMOUNT + Sequence . 묶이길 원하는 정책인 DiscountPolicy의 개별 마커인터페이스부터 구현하되, 액션메서드에 같이 구현하기 위해, 정책조건 인터페이스도 콤마로 같이 구현한다 . | 아직 1개의 인터페이스만 구현한 중간추상층으로서, 정책조건의 액션메서드에다가 정책(마커) 구상형의 실제 내용을 구현한다. . Policy자체는 이제 추상화 된 것이다. AmountDiscount로 2번째 정책까지 구현한 최종 구상체를 묶을 수 있다. . | 액션메서드 1개만 구현하기 위해 abstact class(중간추상층)화 한다 발동조건 메서드는, 이후 구현될 최종구상체의 Sequnece/Time Discount의 영역으로 남겨둔다. | . | class내부 개별구현을 위해 필요한 정보들은 생성자에서 조달한다. | . . | 이제 조건정책의 발동조건 메서드 1개를 구현하는 최종 구상체를 만들어보자. . 2개의 발동조건(Sequence/Time) 중 Sequence를 구현해본다. | . . | AMOUNT + Time . 나머지 정책조건 중 1개인 Time으로도 구현해본다. . . | PERCENT + Sequence . 마커 정책 PERCENT를 구현 &amp; 액션메서드 구현를 위해 DiscountCondition을 구현한 중간추상층(추상클래스)를 만들고, . 다시 구상화하여 남은 발동조건메서드를 구현하며 SequnecePercenDiscount를 만든다. | . . | PERCENT + Time . 마찬가지로 순서대로 구현 . . | 돌아보기 . 중간추상층은 implments에 여러개 인터페이스를 구현 할 수 있다. . implements 마커정책, 조건정책 with 액션메서드+발동조건메서드 | 여러개 구현안됬으면, 중간추상층 1개 미리 메서드 구현을 위해 무조건 조건 정책부터 구현했어야 한다. | . | 최종 구상층은 extends에 1개의 부모만 상속할 수 있다. . 중간추상층 1개만 필수로 상속할 수밖에 없다. | 만약, 구상층들간에 공통로직이 생겨도 코드중복제거를 위한 추상클래스(템플릿메소드패턴) 추가가 불가능하다 | 필수 추상클래스를 상속한 자식이라면, 코드 중복하려면 extends가 아닌 implments를 위해 전략패턴을 적용한 인터페이스로 해야한다 외부에 발생할 별도의 전략객체들을 밖에서 받아와야한다 | . | . | 왜 정책을 먼저 구현했냐? . 도메인인 Movie에 condition이 아닌 policy구상형을 1:1매칭이 필수였기 때문이다. . 정책은 2가지가 반영되어야하니, 2번째 정책이 반영된 최종구상체들이 policy를 추상층으로 가져서 묶어야만 한다 | . . | . | . Movie (제한된 정책 객체들만 받기 with 제네릭) . . Movie는 제약조건이 있다. 2종류의 할인정책(Amount, Percent) 중에 1가지와 1:1 매칭된 체로 생성되어야한다. 하지만, 정책적용은 policy와 condition을 조합해서 class 생성하고, 그 객체를 받아들여서 사용한다. | condition 종류는 상관없이 policy기준으로 붙여야한다? policy를 정책조합의 중간추상층으로 조합하여, 정책들을 생성한다. | movie는 특정형이 아니라 중간추상층 policy 2종류를 알아야한다. 제네릭은 특정형을 알게 하지만, 최상위 추상층을 T의 제약으로 주, 특정추상층을 알게할 수 있다. 제네릭은 객체생성시 특정형을 알게하고, class를 T로 정의한다. | 제네릭을 익클-분신술구현시 특정형을 알게 구현한다면, 추상클래스를 T로 정의한다. 익클말고, 추상클래스의 구상class도 특정형을 알게 구현할 수 있을 것임. | . | 제네릭을 객체생성시 추상형을 알게 하고, class를 T로 정의한 뒤, 메서드(생성자) 파라미터도 T로 정의해서 쓰면, 객체 생성시 메서드(생성자) 인자에 구상형들을 받아들일 수 있다. | . | movie마다 중간추상층(추상체)을 알게끔 만들면, 그 구상체들이 건네오게 알게 만들 수 있다. 구상체들이 들어와도, 공통메서드로 처리되는 구상체들을 가지고 있다면, if나 istanceof가 없이 바로 처리될 수 잇을 것이다. | . | . | | . | Movie를 요구사항에 따라 정리하며 만들어본다. . movie 생성시, 정책의 최종구상형객체를 생성자 인자로 받아들여야한다. . | movie 정의시, 생성자 파라미터 정의부에는 여러구상체들이 올 수 있도록 추상체가가 와야한다. . 추상체를 어느레벨로 정해야할지가 문제다 . . 중간추상층 AmountDiscount를 주면, PercentDiscount 구상체들이 못온다. | 중간추상층은 상위추상층으로 Policy와 Condtion 2개를 다 구현했기 때문에 1개만 선택을 못하는 것도 문제다. | . | . | 제약걸린 제네릭 T을 통해 객체 생성시에만 특정형을 알고 쓰세요할 수 있다. . 제약조건upperbound를 상위 추상층으로 주면, 어떤 형이든 아는 객체가 생성될 것이다. . 2개 인터페이스를 2개의 상위추상층으로 보는 방법은 &amp;를 써서 연결하면 된다. | . . | . | 상위추상층을 upperbound로 하면 -&gt; 객체 생성시 특정 중간추상형을 알게 만들 수 있고 -&gt; 구상층의 추상체로서 생성자 인자에는 특정 중간추상형의 최종구상체들을 넣을 수 있게 된다. . 제네릭의 사용 = 특정형을 안다 = 파라미터나 변수, returntype의 T자리에 특정형으로 정의된 상태의 객체가 생성된다. | . . 제네릭의에 넣은 특정 중간추상형(파라미터,변수,returntype)과 사용되는 인자가 매칭이 안되면 에러가 날 것이다. . . | . | 이제 외부에서는 제네릭에 요구사항에 따른 특정 추상형을 아는 Movie객체들을 만든다. . 영상으로 보기 | . . | 응용 생각해보기 . 제네릭의 upperbound는 if 분기를 처리하는 각 전략객체(구상체)들의 추상체(들)가 대상이다. | if분기를 구성하는 조건이 2개다? -&gt; 인터페이스 2개로 추출 -&gt; 2개 인터페이스를 implements하는 추상클래스(중간추상층) 1개 생성 -&gt; 제네릭으로 변경하여 특정중간추상층을 사용시, 상위추상층으로 uppperbound에 A &amp; B 각 if를 구성하는 조건이 3개다? -&gt; 인페 3개 추출(개별 전략객체생성) -&gt; 3개를 imp하는 추상클래스(중간추상층) 1개 생성 -&gt; 제네릭으로 변경사용시 upperbound에 상위추상층으로 A &amp; B &amp; C를 놓고 사용 | . | if는 추상체 -&gt; if 갯수만큼 구상체class 정의후, 외부에서 객체 처리기를 만들어서 주입 그 객체class -&gt; 객체 생성을 형으로 대신해주는 것이 제네릭 | . | . | | Movie 2(구성과 정책 적용) . Movie가 제네릭을 쓰고 있는 이유는? . 정책 구상체 객체를 받아가서 사용하면 안되나? | 정책 구상체가 2개 인터페이스 조합인데, 요구사항에 movie마다 1개 인터페이스(policy)에 대한 1종류씩만 적용하라는 제약이 있어서 그 하위 구상체만하라는 제약이 걸림. 2개 인터페이스를 조합하되, 1종류 제약이 걸린 인터페이스를 종류마다 중간추상층으로 구상화한다. | 제네릭이 upperbound는 2개인터페이스를 다 걸어놓되, movie생성시, 특정 중간추상층의 하위 구상체들만 알도록 -&gt; 인자로 받도록 제약을 준다. | | 제네릭을 사용할 때, (중간)추상체를 넣어서 추상체를 알도록 할 수도 있다! | . | 제한된 1개종류 policy의 정책들도 여러개가 들어올 수 있다고 가정하고, 1개 인자 -&gt; ...가변배열 인자로 받아준다. . | 여러개가 들어와도, 중복허용 없이 종류별 1개씩만 있으면 된다면, 생성자 내부에서 빈 hashSet필드에 배열-&gt; list -&gt; addAll기능으로 빈 Set&lt;T&gt; = new HashSet&lt;&gt;(); 필드에 넣어준다. 영화별로, 적용된 할인정책을 1개씩만 소유하고 있으면, 꺼내서 돌면서 적용만 하면 된다. | list는 index가 관여한다 -&gt; 결국엔 값으로 식별된다. 객체지향에서는 list에서 필수인 index인 값context보다 객체context = 식별자로 식별해야한다 | . | set은 index없이 들어간 객체로만 식별할 수 있다. | . | movie는 정책을 적용할 수 있는 할인정책 객체와 정책적용 대상인 movie 1개의 요금 fee를 가지고 있기 때문에, 정보전문가패턴에 의해서 정책을 적용할 수 있다. . my) 정책적용대상(fee)를 가진 곳에 정책객체를 생성시 넣어주는 것 같다. . | 정책의 액션메서드인 calculateFee가 똑같이 Movie에서도 동일한 네임으로 적용해보자. . | 가지고 있는 할인정책은 종류별로 여러개이지만, 외부에서 받아온 해당영화의 상영정보(screening)에 의해, 맞는 것 1개만 isSatisfiedBy 된다고 가정하고, ealry return시킨다. . 순서를 고려하지 않는 set이기 때문에, 돌면서 해당하는 정책 객체는 1개라고 가정한다. | . | 돈계산시, 액션메서드가 Money값객체를 반환하므로, 메서드체이닝이 가능해진다. . 할인된 요금에다가 audienceCount만큼 곱한 해당 영화 상영 전체 금액을 구한다? movie는 할인된 1개 영화가격이 아니라, 할인된 가격 x 전체 인원수의 총 매출을 계산하는 것으로 가정한다 | . | . . 그럼, 할인요금 적용 안될 때도, 인원수만큼 곱한 금액을 반환한다. . . | . | . | Money(final 필드 1개의 데이터 객체 - 1개의 final 필드가 연산기능 제공으로 변할시 -&gt; 새 객체로 반환하는 불변의 값객체) . . 값에 class라는 껍데기를 씌우고, 상태값으로 값을 가진다. | 상태값인 값이 자신의 메서드에 의해 연산되며, return시 껍데기를 씌운 새로운 객체로 를 생성해서 반환한다. 연산 전 상태값+껍데기는 불변성이 유지된다. 모든 필드는 final이다. | 값객체에서 상태값의 값 필드는 private으로 외부노출 안된다. | . | 자신의 기능의 결과가 자기자신type이라면, 자신의 메서드들을 체이닝할 수 있다. | . | 재화 등 0이상이어야하는 상태값을 가진다면 return 하한선을 확인한다. . | 자신에 대한 연산 기능(메서드)는 인자로 똑같은 값객체를 주는 것이 가장 좋으나 값이 들어오는 경우도 있는데 . 이는 다른 데서 객체 대신 값을 써서 스노우볼이 굴러서 오는 것 . | 어떤 객체context라도, 1개의 원시형(값)을 썼다면, 전역적으로 값context를 만든다. . 되도록이면 인자든 뭐든 싹다 객체를 써야한다. | . . | 값들을 객체로 썼다면? 어느 순간 abstract numbers라는 추상화가 가능할지도 모른다. . 숫자도 객체로 만들어야 추상화될 가능성이 있다. | 객체로 만들어야 -&gt; 구상체들의 2개이상의 책임 -&gt; 추상체의 1개의 역할 -&gt; 한번에 처리된다. | primitive가 온 순간 -&gt; 확장 = 추상화는 없어진다. 반드시 객체로 메세지를 주고 받아야한다 | . | . | 연산 뿐만 아니라 비교까지 모두 값객체의 메서드로 하자. . . | 장점 정리 번거로워도 값을 private + final 필드로 데이터 은닉화 -&gt; 외부에서는 값을 제공된 기능으로만 변경할 수 있다. | 스스로 연산후 새 객체로 return -&gt; 기존의 상태값에 간섭못함 -&gt; 동시성 문제가 없다 확정되어있는 도메인이나 연산 -&gt; 값객체로 바꿔서 동시성 문제를 없애자. | . | | 값 객체를 필드로 가진 객체들은 . 그 필드가 자기 기능으로 변화하면, 새 객체를 반환하므로 값객체 필드는 재할당 할 수 밖에 없어서 final이 불가능하다. . 아래는Theater가 가진 Money amount 필드가 재할당 되는 것 . . | . | 재할당되어 변하는 (no final)필드(값객체 필드 포함)는 반드시 private으로 외부노출을 막아서, 동시성 문제를 없앤다. . 포인터의 포인터 중, 포인터 자체가 바껴서.. 못찾아갈 수 있다. | 재할당되는 필드는 외부에서 아예 사용 못하게 막아야한다. | . | . | . Reservation(여러 final 필드의 순수 데이터객체 - 연산없는 값 객체) . . Ticket을 대신하는 재료객체이다. data-oriented class라고 볼 수 있다. | 정보의 묶음인 재료객체, 데이터객체는 null 대신 public static final 로 상수로 선언한 NULL객체를 쓰자. -&gt; 데이터객체는 생성/조회 전 검증 실패시에 null대신 NULL객체를 반환해준다. 값객체 class내부에 선언한다. | public static - 돌려쓴다. | final - 불변이다. 돌려쓰는 + 불변 -&gt; 상수 | 데이터객체는 반환되는 경우가 많아서, 검증 실패시 등에서 NULL객체를 만들어주는데 EMPTY or NONE이라는 변수명을 사용한다. 데이터객체Class.EMPTY 혹은 데이터객체Class.NONE으로 static한 상수로 사용됨 | . | . | . | 재료객체, 데이터객체는 모두 순수한 데이터정보로서 final필드를 사용한다. 극장 | 영화 | 상영정보 | 예매한 인원수(count) | | 데이터 객체도 값객체다. . 연산을 제공안하는 값객체 = 재료객체, 데이터객체 with final . | 값객체는 NULL객체를 고려한다. . | . | 전체가 final필드를 가진다면, 스레드 안전이다. | . Screening(final필드 + 외부조건에 따라 변하는 필드의 데이터객체 - 변하는 필드만 final떼고 trigger+action기능을 제공하여 새객체 반환없는 값객체) . . 대부분이 final필드로 박아지면, 데이터객체로서 값객체라 부를 수 있다. . final필드라도, 외부 할인정책의 개별구현시 에서 인자로 받아 내부 sequence와 whenScreened를 getter없이 조회할 수 있게 public final이다. . . | . | 여기서 seat 필드는 . final이 아니다 -&gt; 나중에 변한다. by setter(받기기능) or 연산기능 등 | private이다. -&gt; 변하더라도 외부에서 제공된 기능을 통해서만 변한다. 예매하는 사람이 예매를 했을 경우, 나 자신을 검증하고, 그만큼 가용좌석수가 까여야하기 때문이다. | 예매한 좌석수: count(외부에서 들어옴) | 가용 좌석수: seat(검증되면, count만큼 까야됨) | 외부의 인자에 의해 검증시 사용되고(trigger)되고, 차감(action)되는 필드다. trigger : count이상 seat를 현재 가지고 있니? | action: trigger를 이용해 만족할경우, count만큼 좌석수를 seat에서 빼라. | . | . | . | seat가 변하는 것은 외부(count-예매좌석수)에 의해 변하는(예매권 발행시 차감되어야하는) 필드다. . seat의 변화(차감)는 외부에서 예매를 발행(in theater)할 때 작동하며, 현재 인스턴스에 반영되어야한다(차후 setter나 다른 기능으로) -&gt; final이면 안된다. . trigger만족시, 예매권 발행전, 자리수 차감 | . | 외부 인자라는 조건에 따라 변하는 필드는, 그 내부에서 1) trigger(변화조건) + 2) action(변화) 메서드를 가져서 외부에 제공(외부에서 예매발행시 작동할 것임)한다. . hasSeat(int count) : 외부조건에 따라 변화조건 검증 기능 | reserveSeat(int count) : 외부조건에 따라 변화 + 내부에서 trigger사용함 액션메서드는 항상 내부에서 if trigger메서드를 사용해 검증후 액션로직을 구현한다. 내부에서 사용하지 못하는 경우(trigger가 나중에 작성될 경우)는 외부에서 trigger -&gt; action순으로 사용하면 된다. ex&gt; 정책객체는 적용객체 내부로 들어가서 외부에서 사용됨. | . | . | trigger 조건을 만족하지 못할경우, thr RuntimeException을 내면 된다. | . | . | . | . Theater . . . 일단 자본금이 값객체Money로 대체되었다. . | theater의 저장정보 추가 . 모든 정보들이 theater생성후 저장되며 여러개(Collection)으로 저장될 예정이면 빈컬렉션을 default값으로 초기화해서 저장한다 | 기존에는 ticketOffices들만 저장 ticket을 받기기능으로 가져가던 ticketOffice들 목록저장을 List에서 하다가 객체지향으로서 index = 값이 없는 Set으로 저장한다. | . | 상영할 movie와 movie에 딸린 상영정보들을 Map으로 저장 movie만 저장한다면 set으로 했을 것인데 | movie별 screening도 저장해야하므로 상위1 당 하위도메인들N을 Map에 한번에 저장한다. 이 때, 하위도메인상영정보들을 map의 value자리에 List가 아닌 Set에 중복을 허용없이 여러개를 저장한다. | . | Set&lt;Screening&gt;은 map의 value값인데 없을 수도 있다. value가 없을 수도 있는 key값을, key값만 저장가능하게 하기 위해 value의 default NULL값도 값객체처럼 static final로 만들어놓는다. | . | . . | 상위도메인movie를 key로 받기기능 . 받기기능에 중복 확인시 false로 알려주기 위해 return이 boolean형이다. | key등록시 value인 Set&lt;Screening&gt;은 빈 set로 넣어서 초기화한다. | . . | 하위도메인screening을 value로 받기기능 . 하위도메인의 CRUD는 항상 상위도메인과 같이 인자로 받는다. | 상위도메인이 key로 등록안됬다면, false로 반환한다 | 등록된 상위도메인key가 존재하는 상황이라면, 이미 default로 빈 set을 value로 생성된 상태 만들어놨기 때문에 map.get(상위도메인)으로 꺼낸 상태에서 add만 해주면 된다. put이 아니다. get한 뒤, 빈 셋에 add다. | . | . . | client가 정해준 rate를 가지고, ticketOffice와 계약 후, 성공시 저장목록에 추가 . step1에서 기존에는, 일방적으로 theater만 -&gt; ticketoffice을 알고 목록을 list에 저장만 했었다. 내부생성되는 티켓도, 와서 받기기능으로 받아가기만 했다. | . | 지금은 쌍방 계약이라 서로 알아야한다. 계약조건에 해당하는 외부인자 rate도, 계약할 ticketOffice와 같이 받는다. ticketOffice도, this로 현재 theater 인스턴스를, 커미션율을 같이 들고가서, 계약을 저장한다. 차후 나오지만, 여러극장과 계약할 수 있기 때문에, theater별 rate를 따로 필드로 저장한다. | ticketOffice가 이미 계약한 theater일 경우 계약메서드 returndmf false를 반환해줘서 계약이 무산된다. | 계약 성공시 계약ticketoffices의 set에 추가해주고, 성공여부를 client에 알려준다. 성공/실패가 있는 트랜잭션 메서드의 경우, boolean형으로 작성하자! | . | . | . | . . | 계약을 취소할 수 있다. . 이것도 ticketOffice가 허락을 t/f로 알려줘야 진행된다. | my) 계약도 거래처럼, 계약을 해줄지말지 결정하는 사람(ticketOffice)가 갑이고, 을에서 인자로 받아서, 내부에선 this와 함께 갑의 기능에 계약 가능한지 물어본다. | 저장목록에서 삭제와 마찬가지이므로, 존재여부부터 검사한다. + 갑이 계약취소를 해줘야한다. 취소가능할 시, set에서 remove로 객체를 제거한다. | . | . . | 딸린 하위도메인(Screening) 전체 조회 . 상위도메인 객체(fk대용) 로 전체 조회한다. | 상위도메인 존재여부 -&gt; 해당도메인 존재여부를 확인부터 한다. 없으면 빈값을 보내야하며, 자주 반환되니 매번 생성하지말고, 컬렉션의 NULL객체로서 EMTPY의 상수로 만들어놓는다. | . | . . | 유효한 screening인지 -&gt; 상위도메인 존재 및 상-하위도메인 연결확인 . 아래, 예매권 검증에서 사용될 예정이다. | 예매권의 영화, 상영정보가 제대로 된 정보인지. | . . | 예매권 발행주체로서, 고객이 산 예매권을 검증하는 책임도 가진다. . 예매권의 정보가, 발행한 theater가 맞는지부터 시작해서 내 정보들로 비교해서 반환한다. | 예약좌석수count는 theater가 아니라 client에서 지정해주기 때문에, 외부에서 사용했던 것을 그대로 받아온다. | 내부에 존재하는 상-하위도메인 정보는 위에서 정의한 메서드로 검증한다. | . . | Customer와 거래는 TicketSeller가 하는 데, 예매(reserve)의 책임은 Seller -&gt; Office -&gt; Theater까지 요청이 들어온다. . . 사는 놈 Customer가 스스로 예매하지만, 갑인 Seller의 예매(거래)기능 이용 . . | TicketSeller-&gt; TicketOffice로 예매권 생성 요청 . | TicketOffice는 -&gt; Theater에게 예매 생성 요청 . . | Theater는 발행정보를 통한 검증을 거쳐 예매 생성하여 office -&gt; seller -&gt; customer에게 반환함 . . | . | 예매발행 검증(trigger포함) 통과 &lt;-&gt; 예매권 발행 사이에서 특정 이용가능좌석수가 차감 action이 Screening 객체에 필드에 적용되어야한다. . screening 객체 속에 이용가능자석수가 field로 담겨있으며, 거기에 trigger와 action메서드를 제공하니, 이용해서 차감시켜야한다. | 외부인자에 의해 액션이 들어가는 객체screening은 trigger와 action을 제공한다. trigger는 if (! trigger성공) -&gt; early return형태로 사용하고, 이 조건문 아래에서는 trigger성공 상황으로서 action한다. | . | . . | 데이터객체의 발행은, 새객체를 생성해서 반환해준다. . . | . TicketOffice . . . 자본금을 값객체로 가지고 태어난다. . | Theater와 계약을 하며, 계약취소 기능도 있다. . 트랜잭션 관계라서 서로 안다. . 여기선 office를 거래의 갑으로 보고 먼저 처리하고, 성공여부를 을(theater)에게 boolean 메서드로 t/f여부를 전달해줘야한다. 을(theater)는 갑의 성공여부를 확인한 뒤, 계약/계약취소를 한다. | . | . | 계약은, 계약조건(rate)와 함께, theater를 빈 값으로 초기화된 map field에 add(put)하는 것이다. . 1theater는 여러office와 거래하여, office목록을 set에 저장하지만, | 1office도 여러theater와 거래 가능하여, theater목록 + 거래 theater에 딸린 거래조건rate을 map으로 저장한다. | . | 거래란, 서로의 컬렉션 field에 거래대상을 저장해놓는 것이며, 거래조건을 제시하는 office가 갑으로서, 을theater에서는 office목록만 vs 갑office는 theater목록을 + 거래조건rate과 함께 저장한다. . . | 을(theater)는 갑의 계약/계약취소 성공시에만 진행된다. if !성공으로 실패시, 을도 실패를 반환한다. . . | . | 기존에는 Theater에게 데이터객체(Ticket)을 받기기능(빈 컬렉션필드에 add)으로 가져와 창고처럼 list필드에 모으고 있다가 Seller가 소속기관으로 생각하고 필드로 받아와(setter) -&gt; seller 내부상황에 office에서 office의 주기기능(getter)을 이용해 받아왔지만 창고 역할은 사라졌다 . 기존 . . . | 지금은, 발행주체인 Theater에게 받아와 -&gt; Seller에게 반환해주는 기능을 제공해, 검증 후 생성된 것을 받아 전달만 역할만 한다. . 창고역할은 사라짐. | . . | . | office는 창고역할은 사라지고, seller가 예매발행 요청을 theater가 아닌 연결된 office에게 먼저 발행 요청한다. . 내부에서는 궁극적으로 실제 발행을 해주는 theater에게 발행요청을 또 보낸다. . | 하지만, seller(판매자)에게 발행 요청을 받고나서, theater(생산자)에게 발행 요청하기 전에 office가 하는 일이 있다. . 왜냐면, customer가 사는 예매권에 포함된 정보들이, 거래하는 seller의 소속기관인 office와 계약된 theater가 발행가능한지부터 시작해서, 사려고 선택한 정보들이 유효한지를 확인해줘야한다 | 즉, office-seller의 생산자(theater)로부터 판매자(seller)까지 중개자 역할을 하므로, 중개자와 계약된 생산자가 발행가능한, 데이터객체를 요청하는지를 검증해줘야한다. | . | 요약하면 seller(판매자)가 생성요청하는 데이터객체(Reservation)의 정보가 . 나와 계약된 생산자로 요청하는지 by theater 인자 | 중개자와 계약된 생산자가 만들 수 있는 것인지(유효한 정보인지) by movie, screening 인자 | 생산 가능한지(이용자석수 남아있는지) by screening 인자 중개자로서 검증후에, 생산자에게 생산 요청한다. | . | . | 또한, 중개자로서, 생산자theater가 올바르게 데이터객체(예매권)을 생성했으면, seller에게 넘겨주기 전에, 생산자와 계약한 거래조건으로 나의 commission을 챙기고, 나머지를 생산자에게 준다. . 중개자는 판매금 계산 by 정책적용가능한 movie객체 . | 중개자는 거래조건대로 커미션 계산 | 커미션은 중개자의 자본금에 plus | 판매금 - 커미션을, 생산자의 자본금에 plus 후에 seller에게 예매권을 넘겨준다. | . | . . | . | . TicketSeller . . Customer와의 거래에 대한 갑으로서 판매할 물건을 NULL객체로 만들어놓고(변수재활용) | 물건 가격을 계산한다 movie가 정보전문가패턴으로서, 정책도 가지면서 태어나, 계산의 책임이 있었다. | . | 상황이 사는놈(Customer)가 돈을 가지고 있는지 검증하여 사는놈이 돈이 있으면, 중개자 office에게 예매권을 받아온다. 외부에서 받아온 객체는 NULL객체인지 검사를 꼭 한다. 받아온 물건이 제대로 되었다면, 사는 놈(Customer)에게 돈을 차감한다. | . | . | if 돈 검증 -&gt; if 물건 확인의 과정에서 애초에 돈부터 없으면, NULL객체 그대로 반환하게 한다. early return이 아니라, 상황마다 return해야할 객체 값이 재할당 될 경우, 미리 제일 쉬운 상황인 NULL객체로 만들어놓는 것 | . | . | . | 기존 Ticket을 팔 때도 마찬가지 로직이다. . seller는 돈계산을 하지않고, 소속기관이자 중개자인 ticketoffice가 커미션 + 생산자에게 커미션 뺀 금액을 챙긴다. | . . | 현재는 Ticket대신 Reservation으로 바꼈다. . 거래는 중첩if를 만족할때만 성공(특수) &amp; (그외 대부분의 코드분기) 중첩된 if의 else마다 매번 실패값을 return해야하므로 애초에 실패값인 null객체를 반환 변수에 할당해놓고 -&gt; &lt;중첩if성공시에만 바뀌는 else없는 + earlyReturn없는 코드&gt;를 짠다.한다. . 여러 조건을 통과(중첩if)해야 성공이고, 그외 실패(NULL객체반환)일 경우 . 중첩if의 else마다 발생할 실패값를 미리 변수에 담아두고 | 중첩if의 성공만 변수에 성공값 재할당 else는 코드를 안짜고 무시하면 -&gt; 그대로 default 실패값 | . | 마지막에 변수만 반환하면 else 실패 코드의 중복없이 성공만 고려하는 코드가 된다. | . | . | 만약, 중첩if의 else마다 실패코드를 작성한다면? . . return 실패값이 if의 else마다 반복된다. | . | 만약, 중첩if시 성공을 드모르간 법칙을 적용한 ealry return으로 짠다면? . . not A시, not B시 실패값을 return하는 것이 중복 것은 마찬가지다. | . | . | 물건의 가격을 받아오고 . | if 사는 놈이 그만큼 돈이 있다면 . 그때서야 외부에서 물건(Ticket)을 받아온다. . 돈 있는 것을 확인한 뒤에야, 중개자 office가 돈 계산하며 theater에게 만들라 시킨다. . | 바깥의 Ticket 변수에 채운다. . | . | if 물건이 제대로 되었으면(not null객체) . 외부 물건을 가져왔는데, 내부 사정에 의해(이용좌석수 제한 등) 생산이 안될 수 도 있다. -&gt; 생산 및 내부 돈계산이 안됬을 것이니, 사는 놈의 돈 차감(피해) 전에 처리된다. | . 사는놈의 돈을 차감한다 가져온 물건이 제대로 되었을 때만, 돈을 차감함. | . | | | 3에서 if 2개(돈있냐/물건제대로됬냐)를 다 통과했다면, not null ticket vs if 통과 못했다면 default null티켓을 받는다. . | | my) else없는 중첩if문 -&gt; 미리 else에 해당하는 코드가 위에 세팅되어있어야한다. . | 물건의 값은 ticketOffice(중개자)가 물건 떼올 때 미리 커미션 -&gt; 생산자(theater)는 커미션 뺀 금액을 함께 챙기고, seller는 고객의 돈을 차감만 시킨다. . . | . Customer . . 자본금을 값객체로 가지고 태어난다. . | 사서 받아올 물건을 저장할텐데, 태어날 때부터 없는 물건으로서, 거래후 void setter처럼 받아오니, 필드를 null대신 NULL객체로 초기화 해놓는다. . . | 사는놈은 을로서, 갑인 파는놈에게 거래를 요청하길, 스스로 기능을 호출하되, 인자로 갑(파는놈) + 사고 싶은 물건의 정보을 데리고 와서 갑의 기능을 이용하여 this로 자신을 보낸다. . my)을인데, 자기가 안가고 스스로 기능 호출 해서갑을 데리고 오는 이유? 갑의 거래기능을 이용해 데이터객체를 받아서 저장해야하므로 시작을 먼저 자기가 스스로 void(setter)로 호출한다. | . | seller, office, theater의 .reserve()와는 다르게, 누구에게 데이터객체를 반환해주는게 아니라, 받아서 자기가 가져야하니(필드에 박아야하니) void로 reserve()를 정의한다. | . . | 상태값으로 not final 값객체를 가졌다면, 외부에서 값객체를 변화시킬 api를 제공한다. . 을로서, 파는놈에게 돈 가졌는지 검증 당한다. . 값객체끼리의 비교는 내부 기능으로 정의해서 처리한다 | . . . | 을로서, 돈 차감을 파는 놈에게 맡긴다. . . | . | . Main 다시보기 . Movie가 중간추상층을 특정형으로 알도로 제네릭을 사용 . 그 특정형이 T대신 생성자/메서드 인자, 변수형으로 사용되었을 것이니 -&gt; 추상층의 구상층들을 생성자의 인자로 주입 가능해졌다. . . | AmoutDiscount냐 vs TimeDiscount냐의 if분기를 제네릭으로 제거한 것으로 볼 수 있다. . 2개의 정책이 적용된 최종 정책객체를 DI주입만 해주면 되는 것이다. 현재 사용된 정책: sequence가 1일 때, 1000원을 깍아주는 SequenceAmount정책 | . | . | . | Theater에 movie를 add한다. . . setter는 1개의 데이터를 필드에 바로 박도록 받기기능 | add는 1개or여러개의 데이터를 빈 컬렉션으로 초화된 필드에 추가하도록 받기기능 | . | Theater에 screening을 add한다. . . screening은 movie에 딸린 하위도메인들이다. fk로서 movie객체도 같이 넣어준다. | . | 상-하위도메인들을 연결하면서 받기기능은 내부 빈 Map필드에 put하는 것이다. | . | Theater는 ticketoffice와 계약한다. . theater내부에 저장해야하므로 인자로 받아서 계약한다. office도 계약한 theater을 내부 저장하기 위해, this로 받는 과정이 내부에 있다. | . | . | TicketSeller는 ticketoffice를 소속기능으로서 받아서 내부에 저장한다. . 계약관계가 아니라서 일방적으로 알아서 박기만 한다.? | seller 내부에 저장해야해서 seller가 office를 인자로 받아온다. | . | customer가 seller에게 거래를 요청한다. . theater가 상영하는 것들 여러 상영정보중 첫번재 것을 선택했다고 가정하기 위해 for + break; | 을이지만, seller에게 최종적으로 받은 데이터객체를 받아 저장해야하기 때문에 받기기능을 이용하기 위해, seller를 인자로 알고 데려온다. | . . | theater는 발행권자로서 정보가 많으므로, customer가 가진 데이터객체(예매권)을 검증해준다. . | . 06 객체간 통신 . 오브젝트 5장(1~4장 정리) 내용 객체간 책임을 주고 받을 때, 메세지로서 객체인자를 사용 | 책임은 누구에게? 유지보수하기 쉽게 설계한다. | 구동코드를 배치한다. | | 설계 : 역할(추상메서드)책임(구상메서드) 모델을 통해 책임을 객체별로 나눠서 배치한다. | 책임을 나눠가지려면, 메세지를 주고 받아야한다 | | 객체간 통신 . 메세지를 주고 받는 이유 : 객체별로 책임(메서드)을 나눠가지려고 | 객체망: 역할책임 모델기반의, 객체별로 코드가 잘 분리된 형태 | . | 객체는, 정보은닉을 위한 캡슐화를 통해 내부사정은 내부에서 변경할테니, 외부에서는 제공되는 메서드로 소통만 해라.(시켜라) . 내장을 까지 않는 객체 -&gt; public interface(메서드)로 메세지를 주고받는다. for 객체별 책임분리가 가능해지기 위해 | . | 현실은 다르다 . 역할과 책임이 서로 다름 . 객체의 책임: 수행하는업무 by 메서드 | 객체의 역할: 당면한 어떠한 측면 by 인터페이스 | . | 같은 객체라도, 소속된 공간이나 측면에 따라 역할이 달라지며 역할에 따른 책임이 외부에 노출되어 소통한다. . 같은 객체라도, 역할에 따라 책임을 가지니, 한 객체는 다양한 책임이 존재할 수 있다. 역할 = 인터페이스 = 객체가 당면한 어떤 측면 | . | . . | 책임인 메소드는 객체가 가진 내부 데이터에 따라 이미 정해진다. 그러나 역할인인터페이스는, 데이터와 무관하게, 다양한 측면으로 여러가지를 구현되며 -&gt; 다양한 인터페이스를 가진다면, 다양한 메서드를 가질 수 있게 된다. | 예를 들면 데이터 = 돈 | 책임 = 돈을 지급 (데이터인 돈에 의해 정해짐) | 역할 = implements 사장, 아빠, 남자 등 여러가지 구현 가능 | 역할이 생김에 따라 책임이 늘어난다. (역할이 없으면 데이터가 메서드를 한정해놓는다) 책임1: 월급 지급 | 책임2: 용돈 지급 | 책임3: 데이터 비용 지급 | . | . | . | 요점: 1개의 객체는, 어쩔 수 없이 여러 역할(인터페이스)를 implements해야하고, 그 역할에 따른 책임들(메서드들)을 수행하고 있다. | . | 객체간 통신이 어려운 이유 . 객체 1개도 역할에 따라 다른 책임을 수행하고 있는데, 그러한 객체들이 여러개다. . . | **다른 객체들도 객체망 내에서 나처럼, 중이다.** . . | 하지만, 객체간 통신은, 역할별로 주고 받는게 아니라 1개 역할의 1개 책임 vs 다른 역할의 다른 책임 형태로 책임 단위로 주고받아 복잡한 과정이다. . 같은 역할의 책임만 통신하진 않는다. | . . | 데이터에 의해 책임이 나오고, 역할에 의해 다양한 책임으로 구현된다. . 책의 screening은 자기 가진 데이터 때문에 -&gt; reserve()의 책임을 가지기도 했다. (정보전문가패턴: 데이터를 아는 놈이 책임 구현) 인터페이스A: 상영정보 데이터를 가지는 책임(메서드X) | 인터페이스B: 상영정보를 바탕으로 예매를 하는 책임 | . | 책대로라면, reserve()의 책임 -&gt; reservator라는 역할 인터페이스를 imple후 구현해야한다. 메서드 = 책임 -&gt; 역할안에서 나옴 -&gt; 인터페이스도 만들어서 역할에 따른 책임으로 써야함. | 한다면… Screening implements Reservator | @Override reserve() { }; | screening.reserve() ?? 상영정보가 예약을 하는 모순점이 그대로다.. | 정보정문가패턴 + 역할책임모델이 모순 나중에 해결됨. | . | . | . | 원래는 new Reservator(screening)으로 데이터를 받은 뒤, reservator.reserve()를 해야한다. | . | . | . | 통신망의 구성 . 객체는 통신하며, 다른 객체에게 도움을 받는다. 2개 이상 도움을 요청했다면, 내부에서 1개로 도움을 합체시켜, 다른객체에게 다시 도움을 요청할 수 있다. | 비동기적인 도움 요청도 있기 때문에 더 복잡하다. | . | 도메인들을, 협력하는 객체망 + 메세지로 연결할 수 있어야한다. 코드를 분산시켜 객체를 만들고, 메세지로 연결만 할 수 있으면, | 통신의 목적: 객체별로 책임을 나눠 가질 수 있게 된다. | . | 잘못된 순환 통신망(오른쪽) . . 2객체 이상 통신하더라도, 서로 아는 구조 = 순환 참조만 없으면 된다. 순환구조 문제점: 의존성 제거가 안됨. 설계 자체가 안됨 단방향화(simplex) 시켜야한다. | . | . | . | . | 객체 설계의 난점 . 인터페이스의 그룹화 . 메서드 1개만 가진 인터페이스가 제일 좋다고 가정하자. . | 인터페이스는 (구상체별) 책임들을 추상화한 역할이며 측면이다. . | 1개 도메인이 가진 여러 측면 -&gt; 여러 역할 -&gt; 여러 책임을 가진다. . | 각 객체들은 자기만의 역할들(측면들)을 다 가지고 있을 것이다. . . | 객체망은 여러측면(역할)마다 발생하는 책임들끼리 소통한다 . 같은 역할(인터페이스)끼리의 소통도 있고 | 다른 역할(인터페이스)끼리 소통하기도 한다. | . . 다른 역할끼리 소통한다면, 인터페이스의 그룹화를 다시 변경해야한다. 계속 서로 상호작용해야한다. . . | . | . | | . 07 SOLID 와 GRASP . SOLID . SOLID 5원칙 . SRP: 단일책임원칙 책임: 코드를 수정하는 이유가 1개되는 객체가 되도록 짜라 이 때 + 이래서 변해를 찾으면 분리해라 | seller vs office: Theater가 다 하면 안되나? seller: 사는놈의 돈을 차감해주는 책임 이 때는, 돈을 차감해야하는 놈이 따로 필요하다. | . | office: 돈을 정산하는 책임 이 때는, 돈을 정산해주는 놈이 따로 필요하다. | . | . | class를 변경하는 이유: 도메인에 관련된 이유 1개 일반로직, 공통로직이 들어가서 이것으로 변경되면 안된다. | 공통로직은 유틸클래스로 빼자. | . | 만약, 코드 수정하는 이유 1개로 시작해서 class를 고치는데 다른클래스까지 타격 -&gt; 잘못짠 설계로산탄총 수술 | . | . | OCP: 개방폐쇄원칙 open: 확장에는 열려있고 close:코드수정시에는 닫혀있다. | 다형성, 인터페이스 참조로 생각한다. 내부코드는 close되어 확장시 수정이 없도록 다형성(추상체)를 인자로 받고 | 외부에서는 open되어 여러 구상체를 추가해도 된다. | . | . | LSP: 리스코프 치환 원칙 . 부모형이 자식형을 대체할 수 있다. . | 자식들에게서 추상메서드를 추출하여 부모가 일할 수 있게 한다. . | 공통로직으로서 추상메서드를 추출할 때, 앞으로의 추가 구상층으로 확장도 가능하도록 교집합만 가지게 짜야한다. . 현재보이는 구상층만의 공통점으로 X 추가될 구상층까지 다 고려해서 추상화시켜야해서 어렵다 | . . | 일부 구상층들만의 추상층은?? . 인터페이스로 만들어 빼고, 추가implements하면 된다. | . . | . | ISP: 인터페이스 분리 원칙(interface segregation) . 구상형 대신, 접근할 메서드를 가진 인터페이스를 만들어, 엉뚱한 권한접근(메서드호출)을 막는다. . | 접근할 메서드별로 모듈(class)을 만든다면, 잘못된 것이다. . 객체 1개에 모든 메서드들이 모여있으면 엉뚱한 접근을 못막음. | . . | 인터페이스 모델방법: . 인터페이스별로 메서드를 분리한다. | 모든 인터페이스를 객체가 구현한다. | 자체 메소드는 객체내부에서 개별구현한다. | 필요에 따라 해당 인터페이스를 인자로 받는다? | . . | . | DIP: 의존성 역전 원칙(Dependency inversion) . 추상화된 것에 의존해야한다. + 다운캐스팅 금지 | 구상체 = 저차원의 모듈, 추상체 = 고차원의 모듈 | 구상체가 사용되었다면, 추상형으로 바꿔서 사용한다. 그러려면 ISP인터페이스분리원칙에 의해 인터페이스가 잘 나누어져있어야한다. | 그러려면 LSP(부모형이 자식형을 대체가능)하도록 추상메서드 추출해야한다. | . | . | | DDHL . 머리나쁜 우리를 위해 만들어준 추가 4원칙 | . DI: 의존성 주입 너흰 추론 불가능이니까, 받아서 써 | . | DRY: don’t repeat yourself 너흰 까먹고 또 쓰네. 중복 하지마 | . | Hollywoord principle: 의존성 부패 방지 너흰 나한테 물어보지마 변질될 수도 있어.(getter) -&gt; 잘 아는 놈에게 그냥 시켜 | 물어보는 순간(getter) 일반적으로 부패된다. 일반적으로 물어보면(getter)후 대답해야해서(return 응답객체) -&gt; 새 의존성이 추가될 수 도 있다.(값getter가 아니라 객체getter면) | . | . | Law of demeter: 디미터 법칙 = 최소 지식만 요구한다. classA 안에서 methodA가 가질 수 있는 최대지식은? classA필드들 + 내부에서 만들어진 응답객체 / 인자로 넘어온 객체 / 지역변수 | 그외 새로운 것을 알면 안된다. 1차적으로 관계된 것들만 알자. | 그외에는 직거래를 유도하거나 래핑메소드를 만들어서 1차원적으로 만들자. | 타고가서 return응답객체를 받아오지말자.(간접거래) 간접적으로 아는 것은 모르는 것이나 마찬가지다. 머리가 나빠서 기억 못함. | . | . | 열차전복사고(. 2개이상)을 방지하면 된다. 새로운 의존성(응답객체)이 올 수 있다. | . | . | . | 헐리웃원칙(의존성부패방지) &amp;&amp; 디미터법칙(최소지식) -&gt; 무책임? 모순? . 헐리웃원칙 = 의존성 부패방지 . getter로 물으면 응답객체가 와서 의존성생기고 부패되니 시켜라 | . | 디미터법칙 = 최소지식만 요구 . | 1차원적인 관계만 유지하고, 열차전복사고를 방지해라 . | 헐리웃원칙 + 디미터법칙 . 1차원 관계만 유지(쩜1개) 하면서 시킨다.(no getter, no 응답객체) | 메세지만 주고 받으면서 객체간 통신은 가능하다 | . . | 시켰을 때, 내부 메서드가 제대로 작동했는지 / 현재 던진 것의 성공여부(boolean) 등은 어떻게 알까? 시키기만 하면 되나? . 무책임?? | 안의 내용은 확인하지 말고 메세지가 잘 수신되었는지를 하는 하는 코드만 작성한다. | . | 메세지를 확인하는 코드는? . 원래 내장까지 까주는 객체들(Mock or 내부 log찍는 인터페이스를 구현한 객체)로부터 메세지를 수신 확인한다 | 생략 | . | mock객체 활용 시키는 것을 검증 . 단위테스트시 mock객체 . 실환경의 객체를 대신하진 못한다. | . | 우리는 객체망을 통해 문제해결 but 해당 객체의 내부를 추론할 수 없으므로 객체망검증을 위한 mock객체가 필요하다 . | 모조객체(mockery) vs 목객체(mock) . 모조객체 : 목객체의 우두머리 = 테스트 관리 객체이자 context | 목객체: 테스트용 모의 객체 | . | Mock객체를 통한 검증 . mockery(context)부터 배치 | mockery의 context를 안고서 mock객체 회/파/빨 생성 mock객체는, 객체망을 검증해주는, 내장까주는 주변객체 | mock객체는 mockery객체로 보고하는 로직이 내부 구현 | . | 실제 테스트 대상 객체 생성하여 객체망 구성 . 보통 DI로 구성 | . | trigger를 통해, 회색mock객체에 첫번째 메세지 통신 . | 회색mock객체로부터 목객체에서 대상으로 메세지 송신을 mockery에 보고 . | 파랑/빨mock객체로부터 목객체에서 메세지 수신을 mockery에 보고 . . | 이 목 시스템 외에 객체 메소드 단위테스트로는 정상작동객체를 증명할 수 없다. . 객체는 오직 메세지를 주고-&gt; 받고할 때 의미가 있으므로 | 전/후의 주변객체(mock객체)들을 통해 적시에 그자리에 있는지 | setter로 세팅한 것이 적시에 이루어지는지 확인할 수 없다. | . | 객체는 오직 객체 통신으로 책임이라는 메세지를 호출하는 것만으로 의미를 가지며, 목 테스트를 통한 방법의외에 검증할 방법이 없다. | . | | . | . GRASP의 9가지 패턴 . 참고블로그 - 한빛미디어-김대곤님 . | General Responsibility Assignment Software Patterns 책임을 부여하는 원칙들을 말하고 있는 패턴. | 구체적인 구조는 없지만, 철학을 배울 수 있다. | 총 9가지의 원칙을 가지고 있다 | . | SOLID 5 + DDHL 4를 base로 하였지만, 더 민간용으로 쉽게 나온 설계요령 . 다른 관점에서 SOLID법칙, 헐리우드법칙, 디미터법칙을 인식하는 좋은 계기가 된다. | 거성들의 원칙(5+4)보다 객체지향 적용의 약한 레벨에 적용할 수 있게 좀 풀어놓은 버전 | 응용범위는 더 좁을 수 있다. 패턴은 특정상황에서 쓰는 것 | . | 9가지 패턴 . . | . 정보전문가 패턴 . 객체지향의 은닉성을 의미하는 것 | 데이터를 많이 아는 객체가 책임(메서드)도 가지는 것이 좋다. 은닉성이 잘지켜지니까 그놈이 책임=메서드를 가지자 | . | . | Creator 패턴 . 은닉성과 연결되는 것 | 객체의 생성도 데이터를 많이 알고 있는 놈 or 친밀한 놈이 하는게 좋다. 실제로 지키기 힘듬. 정보전문가패턴과 같을 때도/아닐 때도 있다. | . | reservation의 생성 책: screening이 많이 알고 있어서 예매권 생성 | (반례) 개선: 생성해서 검증에 이용(친밀한 놈?)할 theater가 예매권 생성 이용할 놈이 생성도 담당하기 위해 위해, 관련 정보를 theater에 모으는 사전 작업이필요했음. | . | . | . | controller . 중개자가 직접 접촉 or 간접 접촉 | 어댑터 패턴 + 미디에이터 패턴을 동시에 적용하고 싶을 때, 컨트롤러 패턴으로 퉁친다. 어댑터 패턴: (자주변하는 것은) 내가 직접아는 것보다, 중간에 어댑터를 두어, 간접적으로 아는 것이 훨씬 유리하다. model이 view를 직접아는 것보다 controller(어댑터)를 통해 간접적으로 아는 것이 더 좋다 | . | 미디에이터 패턴: 1객체가 다수의 객체를 알아야한다면, 객체망이 너무 복잡해지니, 중심에 미디에이터를 두고, 미디에이터가 다 알게 한다음, 객체는 미디에이터 1개만 알게 한다 사람 - 모든 case를 다 아는법원 - 판례1, 판례2 … | 어댑터가 여러 시스템을 알고 있다면, 미디에이터 패턴에 해당한다 model - controller - view / console ... | . | . | | 나온이유: 외부에 대해선 어댑터역할을 하고, 내부에선 미디에이터 패턴이다. | . | Low Coupling(낮은 결합도) . 결합도 낮다 = 알고 있는 객체가 적다 = 양방향 참조를 제거한다 = M:N을 제거하듯이 형1개가 추가되지만, 두려워하지마라 | 알아야만 하는 객체만 알고, 단방향 의존성을 가지는 것이 목표 양방향 순환참조 : 상태를 보고 버그확정이 불가능해진다. 디버거들이 무력화 | 주고 받기 때문에 값을 모른다. + 누구책임인지 모른다 + runtime에서 못잡는다. | 100% 제거해야함 | RDB의 기술 MN -&gt; 1M으로 바꾸는 것처럼 중간테이블과 같은 중간객체가 들어와야지 제거가 가능하다. 형이 1개 늘어난다. | 어댑터 패턴에서도, 연결할 놈 1개가 추가되면, 어댑터인터페이스 + 어댑터구상체 set로 1개씩 늘어난다. | . | . | . | . | High cohesion(높은 응집도) 방법이 이미 정해져있다. | SRP에서의 책임처럼이 때 + 이래서 변해의 변화율에 따라 코드를 나누고, 변화시 다른 곳의 영향이 안가게 격리시키는 것 | . | Protected Variations 인터페이스 분리 원칙을 적용해라 | 공통점을 찾아 인터페이스로 추상화해서 가능한 추상체로 소통 | . 공통점을 찾는 이유: 인터페이스로 노출해서 -&gt; 책임을 할당한다 | . | Polymorphism 전략패턴을 의미한다. | 인터페이스로 추상화하 비슷한 얘기 같지만, 추상체를 인자로 받아들이고, 달라지는 부분은 구상체들이 나중에 구현 | . | Pure Fabrication 공통된 기능/순수기능객체는 따로 모아서 작성한다 | 수정의 여파가 다른 곳으로 가지 못하게, 공통기능은 따로 분리해서 처리한다. 추상층으로 따로 분리하라는 얘기 or | 공통클래스로 빼라는 얘기 | . | 추상화가 끝난 객체 = 완성판 객체는? 인터페이스(역할)을 구현한 추상클래스에 공통기능이 public 템플릿 메소드로 정의 개별구현은 public 템플릿메소드 내에 protected abstract 훅메서드로 구현 | . | . | 전략패턴 &lt;-&gt; 템플릿메소드패턴을 밥먹듯이 바꿀 수 있어야한다. 템플릿메소드패턴: 고정 구상층을 가진 추상클래스 | 전략패턴: 확장성에 유리한 인터페이스 | . | . | indirection 직접참조관계를 피하고, 중계객체를 이용하면, 개별객체의 충격을 흡수해준다. | 포인터의 포인터 다른 의미로는 인터페이스의 추상형 사용 | 데코레이터패턴 or 어댑터 패턴으로 간접 명령 | . | 간접참조를 하게 된다면, 직접참조의 대상(value)를 변화시 수동으로 바꿀필요없이 참조만 하면된다. | . | 08 Theater with SOLID(객체의 설계3) . 최종코드 | . . Movie . . T형(Amount or PercentDiscount) 할인정책 객체 여러개를 받던 것을 1개만 받도록 설계됨. . | 정책조건 만족시, 총 요금을 movie내부에서 fee를 이용해 movie내부에서 계산 -&gt; 정책 객체에게 movie의 fee를 넘겨서 알아서 정책객체가 알아서 계산하도록 계산 위임하도록 바뀜. . . | . DiscountPolicy . . 기존에는 인터페이스내부에 policy종류별 마커인터페이스들 담고 있었으나, caculateFee()에 대한 템플릿메소드 패턴이 적용된 추상클래스로 바꾸었다. . 물려지는 public은 다 템플릿메소드라고 부른다. addCondittion, copyCondition, calculateFee | . | 자식(구상클래스)에 위임된 protected abstract 메서드를 훅메서드라고 부른다. calculateFee | . | 템플릿메소드패턴은 언제??? 구상형의 수가 한정된 상태 | 구현층에 공통 로직이나 공통 필드가 존재할 때, 중복제거용으로 | . | 전략패턴은 언제??? 구상형이 확장가능성이 있으면서 | 개별로직들이 공통점이 없어서 -&gt; 1개 메소드로 인터페이스를 정할 때 | . | 만약, 공통로직이 존재하여 템메패턴써야하는데, 전략패턴을 써버린다면? 공통로직 -&gt; 수정시 일일히 다 수정해야함. | . | 한정된 추메패턴에서, 구상체가 추가되었는데, 공통로직이 안보인다? 전략패턴으로 싹다 다시 바꿔줘야한다. | . . | 또한, 내부에 정책조건을 빈컬렉션 필드에 모아서, 할인 정책 적용시 사용한다. . 생성자에서 받지 않고, 이후에 유연하게 받아들일 수 있게 setter처럼 받기기능을 제공한다. | . . | 특이하게 같은 policy를 받아서, 내부 정책조건들 필드을 복사해서 가져오는 기능도 존재한다. . 이는, movie에 적용될 policy가 다른 policy로 대체될 때, 기존 policy의 정책조건을 가져와서 물려받을 수 있게 만든다. . AmountPolicy에서 PercentAmount로 할인정책을 바꿀 때, 기존 AmountPolicy가 가진 conditions를 물려받는 기능 | . | 다시 conditions객체를 만들어 넣으면 안되나? . 객체는 식별자로 판단되기 때문에, 다시만들면 다른 객체가 된다. | 같은 종류의 객체비교는 내장을 깔 수 있기 때문에 쉽게 가능해진다. | . . | 이런 방식을 택한 이유는 . Movie의 지식을 줄이기 위해, policy만 알고, policy가 conditions를 알게 하는 방식으로 변경 | 기존: SequenceAmountPolicy로 둘다 적용된 조건+정책 구상체를 받아들였었다. | 원래는 Movie가 가졌던 condition들인데, policy가 가지게 하였다. policy교체시 -&gt; 딸린 conditions들도 옮겨줘야하는 책임을 가지게 된다. | 객체에서는 이렇게 소유권을 맘대로 옮겨선 안된다. | . | . | . | . AmountPolicy, PercentPolicy . . 템플릿메소드패턴의 구상체들은, 훅메서드만 개별구현해주면 된다. 추상클래스에서 안보이지만 다 물려준다. | 훅메서드 구현시 혹시, 다른 정보가 필요하면?, 생성자에서 받아서 처리해주면 되는데, 부모 생성자도 super로 재정의해서, 부모레벨에서 다 처리되고 내려오게 하면 된다. | . | 할인요금을 계산할 때, 넘어오는 fee에 대해, 얼만큼의 amount만큼 깎아줘야하는지 정보가 미리 태어날 때 정해져있어야한다. 값객체 amount를 생성자에서 받는다. | . | . . DiscountCondition . . . 기존에 가지던 action메서드는 DiscountPolicy에게 위임하고 1개의 메서드를 갖는 인터페이스가 되었다. 전략패턴 | . Period(Time)Condition, SequenceCondition . . 정책조건의 전략객체로서, 개별적으로 조건을 만족하는지 구현한다. 필요한 내부정보는 생성자에서 조달한다 | . | . TicketSeller . . reserve()의 인자(파라미터)가 5개나 된다. . 객체를 메서드의 인자로 받았다 -&gt; 그 객체를 알고 의존하는 dependency를 가지고 있다. . 5개의 묶음을 형(type, class)로 강제하면 좋으나 상위도메인이자 소속기관인 ticketOffice에게 customer를 제외하고 4개의 인자를 다시 넘겨줘야한다. . . | 또한 customer는 예매시, seller인 나에게 5개의 정보를 다 넘겨준다. . | . | . | 나는 비록 5개의 인자를 받았지만, 이 dependency 중 theater, movie, screening의 객체을 나(seller)는 사용하면 안된다 . 왜? . 나는 ticketOffice에게 정보 전달의 책임(의존성을 중개만)만 있다. | . | 원래 의존성을 가지던 ticketOffice만 사용해야한다. . | 원래 의존성이 없었는데, 메서드의 인자로 넘어온 의존성에 대해서는 그 의존성을 사용하고 끝낼 것이 아니면 사용하면 안된다. . 보통 받으면 사용하면 되지만, **seller는 해당 의존성의 전달 책임만 있고, 사용하고 끝낼 놈은 ticketOffice다 ** | 내가 사용하고 끝낼려면, ticketOffice에게 전달하면 안된다. | . | 현재 코드에서 오류 잡아보기 . 인자로 받은 의존성을, 내가 직접 사용하는 movie . . | 이미 사용했지만, 내가 의존하는 객체에 다시 넘겨주는 오류 . . | . | . | 이렇게 전달만 할 것인지 vs 직접 사용할 것인지를 선택하는 것은 디미터원칙(최소지식 원칙)을 지키려고 하는 것이다. . . 빨간줄이 디미터 원칙을 위배한다는 것을 알아야한다. ticketOffice에게 넘겨줘야할 것인데, 중간에 직접 사용하는 오류 | 내가 사용하지말고, 나와 직접적인 관계가 있는 1차원적 관계의 ticketOffice에게 책임을 위임한다. my) 그대로 놔두면, 나도 사용, office도 사용 -&gt; movie입장에서는 적어도 1가지는 디미터원칙 위반(건너고 건너는?) | movie가 변하면 -&gt; seller(나)도, office도 바뀐다 | . | . | 나와 1차원 관계가 있는, 직접적인 관계의 ticketOffice에게 movie를 사용하는 것을 위임하자 | . | 의존성(movie)의 변화는 한 곳에서만 나타나도록 1차원 적인 놈에게만 의존성 사용을 몰빵하자. 여러 객체가 쓰지말자. . 메서드의 인자로 받아도, 직접 사용하지 않으면 의존관계가 없다 . | ticketOffice는 원래 movie를 전달받아 사용했었다. . 이미 메서드인자로 전달받은 객체를 내부에서 사용 -&gt; 직접적인 관계, 1차원적인 관계, 의존성 가진 상태 | . . | 이왕 받는 거, 미리 한번 더 받아서, 책임을 위임받는다. . ticketSeller 코드변화 . 직접의존성이 있는 객체가 대신 기능해주는 것을 wrapping method라 한다. | . . | . | . | . TicketOffice . . seller가 직접 호출해서 의존성이 추가되는 것을 방지하기 위해 office는 **이미 직접 의존성을 가지므로, 대신 기능해주는 wrapping method를 제공했다. ** . | 내부에 코드(메서드)가 추가되었을 때, 항상 기존 코드와 비교해서 &lt;메서드가 대신 차지할&gt; 중복코드는 없는지 확인해야한다. . 빨간색의 코드가 중복이다. 추가된 메서드로 대체한다. | . . | . Main . 한번에 policy + condition 합쳐진 구상체에서 -&gt; condtions를 채워서 가지고 있는 policy로 사용법 변화되었으니 코드 수정 . . | . 09 LSP . object 6장 디미터의 원칙: 최조지식 요구 = 1차원적 관계, 아는놈이 직거래하도록 시키자 | 헐리우드 원칙: 변하는 놈에게 물으면(getter) 나도 여파가 생기니, 묻지말고 그냥 시켜라 | . | 객체지향 실패 이유 변하는 놈에게 물어보기 때문에 실패한다 -&gt; 시키자 getter = 값(변함), 응답객체(의존성 생김)를 return하는 method를 만들지말자 | 물어봐서 받아오는데, 변하는 놈이면? 나도 변화의 여파를 받는다. 물어볼 시, 실시간 업데이트가 안됨. | 객체는 계속 변하여, 내가 알고 있던 걔가 아니다. | . | . | . | 디미터 + 헐리우드 원칙 2가지는 객체지향보다 수정에 강한 코드(변화의 여파가 없는 코드)를 만든다. SOLID원칙으로 따지면, LSP, OCP가 변화여파가 없는 코드다. | . | . 확장시, 스펙(공통메서드)가 줄어드는 경우 . 리스코프치환원칙(LSP): 부모형으로 자식을 안전하게 대치할 수 있다. . 구상층의 공통메서드를 추상층 + 추상메서드로 뽑아낸다. . . 그러나 성급한 추상화이다. 보이지 않는 확장 구상체의 메소드를 고려안함 . | 대부분의 개발자들은, 확장으로 인해 공통이 아닌 것으로 밝혀져도, fake c()를 만들어 에러를 내는 방식을 많이 취한다. . 하지만 fake c()가 context버그를 만들어낸다. 공통도 아닌데, 추상메서드를 개별구현해버리는 경우가 리스코프 치환원칙 위배이다. | . . | . | 이 때, 공통점이 없는 놈에게 억지로 공통점을 만들어주는 것이 아니라, 100% 공통로직만으로 구성된 중간추상층을 구상층 가장 가까이 추가하고, 일부 공통로직은, 일부구상체들만 더 위에서 상속한다 . 중간추상층 . 기존에는 2개의 메서드 중 1개 메서드를 먼저 개별구현하기 위해 썼었다. 예) 정책조건 인터페이스 = 1trigger + 2action을 가지는데, 2action메서드만 중간에서 먼저 구현해서 막고 -&gt; 개별구현체들은 1trigger만 구현 | . | LSP에서는 구상체 확장했을 때, 공통메서드 일부를 안가지는 경우, 100% 공통메서드만을 위한 추상층을, 다같이 붙이게 만든다. 일부 공통메서드는 더 상위에서, 해당하는 것들만 상속한다. | . | . | 공통의 범위(스펙)가 줄어드는 경우, 줄어든 공통메서드를 가지는 중간추상층을 만들어 구상층에 가까이 붙여준다. . 일부 공통로직은, 그것만 모아서 추상층을 만들고, 해당하는 것들만 더 상위추상층에서 구현해준다. . . | . | . | | . 확장시 스펙은 그대론데, 단독메서드가 생기는 경우(확장형 LSP) . . 줄어들 때 처럼 공통메서드a,b,c만 추상화한 중간추상층이 구상층에 가장 가까이 붙어있다. | 그렇다면, d만 빼서 concrete3의 상위추상층으로 올리면 안되나? 내가 만든 예시 | d는 일부 공통도 아니기 때문에, 중복코드가 아니면 추상화할 이유가 없다. 추상화는 공통점만 하는 것이다. 일부라도 공통이어야 한다. | . | . | 혼자만 가지는 메서드는 instanceof의 다운캐스팅을 유발하여 LSP위반하는 코드다 LSP위반 2가지 내가 가지지도 않는데 억지로 공통이라 올린 fake c()를 구현하는 경우 | 나만 가져서, 나만 확인해서 d()를 사용하는 경우 | . | . | . | 추상체를 파라미터로 하여 부모형으로 대체해야하는데, 구현체 1개만 자신만의 메서드를 가져서 확인해야하는 경우, 다운캐스팅을 방지하는 제네릭을 이용한다. 제네릭 이용 2가지 특정형(중간추상층도 가능)을 1:1로 인식해야하는 경우 예) movie는 AmountPolicy, or PercentPolicy 둘 중에 1개형만 인식한다 | . | 구상층의 확장시, 단독메서드가 생겨 instance가 발해아는 경우 | | . | 추상체를 그대로 쓰면, d()를 인식할 방법이 없다 제네릭을 통해 특정형(d()를 가진 concrete3)알게 하면서, 익클을 통해서 외부에서 d()를 구현하도록 하게 한다 | 즉, 제네릭을 통해 구현을 외부 클라이언트로 미루어서, 와서 인식하지말고, 미리 인식한 상태로 구현으로 선택해서 들어오도록 개발자의 세계 예시 d()가 아니라, 해당 개별 구상체마다 특정 구상체만 제공해주는 필드로 인해 instanceof의 다운캐스팅을 해서 데이터를 받아온다. | . | . | . | . 10 개발자의 세계-문제점 . Programmer . . 추상층이며, director가 개발자+들(추상층)을 도구로 보고, program을 제공해주라고 시킨다. 이 때, paper+들(추상층)을 재료로 던져준다. Program을 return으로 ~(Director내부= 외부)에게 제공해야하므로 return값이 있는 오퍼레이터(추상메서드)를 제공한다. | . | . Paper . . paper는 외부에서 제공해달라고 시키거나(return제공기능), 외부에서 주거나(void받기기능)이 없는 마커인터페이스다. 구상체들이 impl하면 범주만 나타내준다. | . | . Client . . void 메서드로 받기기능(외부에선 주는 기능)만 있다. 외부에서 Programmer+들(추상체)를 주면, 내부에 상태값으로 저장한다. | 참고) void는 제공 기능9return)을 제외한 받기기능뿐만 아니라 처리기능(deploy, print) 등 다양한 곳에서 쓰인다. | 참고) return 받기기능도 성공여부를 전달해야한다면 boolean으로 받기기능을 정의하기도 한다. | . | 마커인터페이스를 구현했으면, 내부에서 필드(데이터, 상태값 저장) + 메소드(기능, 책임)를 모두 채워야한다. clinet나에게 필요한 데이터들을 필드로 정해진 데이터는 초기화된 필드로 | 나중에 받을 데이터는 setter(받기기능)로 채울 것이니 null로 초기화 | . | 내가 제공해야하는 기능은 메서드로 나는 기획서들 중 1개로서, 이후 나한테 맞는 개발자를 받아 저장(받기기능 for 변하는 필드값)한다. | . | . | . ServerClient . . Client기획서와 다르게, 2개의 데이터를 받기기능을 외부에 제공한다. 개발자 2명은 나중에 받는다. 그들이 사용할 language도 숫자에 맞춰 2개를 가진다. | . | . FrontEnd(instanceof 등장) . . 외부에서 시키는, paper를 받아 Program 제공 기능을 구현해야한다. . | 기획서를 받을 때, . 나(FrontEnd, 특정구상체)에 맞는 특정Paper구상형을 인지 확인한다. | 재료로 들어오는 추상체의 구상체별로 각각 다른 정보를 제공하여 확인 by 다운캐스팅(instanceof)할 수 밖에 없다. Paper에 추상층 정보가 작아서, 개별(Client vs ServerClient)로 확인해야한다 | Paper가 공통메서드(오퍼레이트)가 없는 정보가 작은 마커인터페이스이기 때문이다. 그렇다고 Client, ServerClient의 공통메서드는 찾을 수 없다. | Clinet, ServerClient의 로직은 1개의 메서드가 아니라 서로 다른 필드로서 인터페이스에 오퍼레이터로 추상화할 수 없기 때문 | . | . | . | . BackEnd(instanceof) . . 역시 마찬가지로, Program을 외부에 제공해주는 기능을 만들 때, Paper기획서들을 재료(인자)로 받지만, Paper의 정보가 적어서, 어떤 Paper인지 확인해서 나에게 맞는 정보만 가져와야한다. | . instanceof의 문제점 . Paper구상체마다 확인해서 사용한다. 구상체가 추가되면? 또 instanceof로 확인해야한다. 다운캐스팅 = 확장에 막혀있다 = 구상체 추가시 내부코드가 추가된다(변한다)= OCP위반 | . | if분기는 goto를 통해 runtime, compile error를 유발하지 않는다. -&gt; 못찾아낸다. | . Director . . 여러 paper들을 소유하기 위해선 -&gt; 데이터필드를 빈컬렉션 초기화 -&gt; add기능으로 받기를 사용했다. 특히, 상위도메인처럼, name과 매핑해서 저장하기 위해서, map을 이용했다. 여러개를 저장하면 add(받기)외에 C(add)RU(edit)D(remove)를 다 구현할 수있는데 생략 | . | . | director내부에서 저장된 paper을 paper로 꺼내더라도 paper구상형마다 처리 로직이 다르므로 확인을 해야하는 문제점이 있다. 추상화 후 개별구현 메서드 기능이 없다. | 마커인터페이스의 문제점: 한번에 처리할 수 있는 오퍼레이터가 없어서, 꺼낼때마다 확인할 수 밖에 없다. 인터페이스: 인터페이스에 정의된 오퍼레이터 외의 기능을 이용하려면, 다운캐스팅으로 확인해서 써야한다. | . | . | 구상형 종류마다 다 instanceof로 확인해야한다. | . | . 문제점들 . 추상체(Programmer)가 추상체(Paper)를 넘겨받을 때, 특정구상체(FrontEnd)는, 특정구상체(Client)만 알아야만 하는 상황이다. ServerClient를 받으면, 그 순간 필요한 정보(library 등)가 없어서 context에러가 난다. | . | . | **인자로 받는 추상체 중 특정형만 알아야한다면? ** 제네릭을 통해, 받는 놈이 인자(재료)로 오는 추상체를 특정형만 알게 한다. 조건: 받는 놈의 추상층이 제네릭 T extends 재료의 추상형으로 정의되어있어야한다. | . | | LSP문제로 보면? abc -&gt; d() 추가가 아니라 | 마커인터페이스 0 -&gt; d() 추가의 상황이다. | . | 추상층(부모형) 정의되지 않는 정보 d() 는 물어서 확인(instanceof)해서 써야하니 . 확인 = 묻지말고 시켜라? -&gt; 헐리웃원칙?(부모형에 적용) . 1개 메서드로 묶어서 추상층에 올려 -&gt; 추상층에 시킨다. 시킨다 = 상대방에게 물어보고나서 하던 일들을 메서드를 만들어 기능을 제공해줘야 시킨다. 엥? 확장성LSP의 자기만하는 메서드d()는 올리면 안될텐데?? | 중복코드가 없은 것을 1개 메서드로 올릴 경우, 전략패턴 | . | 올릴 때는, 해당 구상체만의 로직을 찾아서 메서드로 묶고 올려야한다. 만약, 물어보던 놈의 내부정보(필드등)이 사용되었다면, 반대로 시킬 때는 메서드의 this로 들어가게 된다. | 물어보던놈이 추상체 중 1개였다면, this -&gt; 파라미터로 받을 땐, 추상체로 올려야한다. 모든 것을 추상화 | . | . | . . | (Paper말고 반대쪽으로 보면)backend도 마찬가지로 paper에게. setData(this)로 시키면, 공통 코드가 생긴다. . 공통코드가 생기면 Programmer인터페이스 -&gt; 추상클래스 + 템플릿메소드 패턴으로 바꾼다. | . . | | . Paper에게 this -&gt; 추상형 인자로 시켰더니, 거기서도 확인해야하는 문제가 발생함. . 시키기 전에 N(추상):M(추상)의 관계인지 확인해야한다. . | 추상형(programmer)이 추상형(paper)을 받았을 때 생기는 instanceof의 문제 . instanceof를 if처럼 묻지말고 시키기 위해 로직을 모아서 -&gt; 메서드 1개로 추상화해서 제거할 수 없다. 물어보고 사용될 때, 현재 내부가 추상체의 구상체라면, this로 넘길 때 추상체가 넘어가서 반대쪽에 instanceof가 생긴다 | . | 원래는 구상체들을 확인하는 class -&gt; if 제거 방법인 추상화로 의존성 역전을 쓴다(전략패턴) 구상체를 물어 사용되는 내부 로직을 모아서 메서드로 만들어, 구상체.시키기()로 만들고 | 그 메서드를 추상체에 올린 뒤, | 내부에 필요한 구상체를 외부에서 주입한다. | | 여기서는 구상체확인하는 class가 추상체이며 시키기 위해 모을 때, class내부 field에 set하는 로직이 포함되므로 this로 로직을 모은 메서드에 인자 this가 생기고 | 그 this는 추상체 중 1개의 구상체라, 추상체로 받고 | 추상층에 올라간 메서드의 파라미터는 추상체다. 메서드 1개로 모아서 시키는 예비추상메서드의 인자가 생길 수 밖에 없으며(호출부내에서 호출부 정보 이용-setter) | 하필이면 그 this로 넘어간 인자가 추상체여야만 한다. | . | | pingpong으로 문제가 왔다갔다만 한다. 참고) 2개이상의 오페레이터를 가진 추상층 -&gt; 성급한 추상화 | 참고) 개별로직 밖에 없는데 추상화 -&gt; 성급한 추상화 | . | . | my) 메서드 추출시 내부context가 사용되어, this로 추출되었을 때, 그 context(class)가 어느 추상체의 구상체라면, 넘어가서 this를 추상체인자로 받으니, instanceof가 발생할 각오를 해야한다. . . | . 정리 | instanceof를 if제거 방법으로 제거하려면 구상체에게 시키는 메서드를 만들고, 그 메서드를 추상화할텐데 | 추상메서드의 인자에 this가 발생하고, 그 this역시 추상체라면, instanceof는 반대쪽으로 가서 생긴다. | . | . | ServerClient는 Client와 다르게, this(programmer)자리에 2개의 구상층이 다 들어올 가능성이 있다. . Paper에게 시켰더니, 구상체 갯수만큼 instanceof가 늘어난다. . . | 다시 반대로, BackEnd가 Paper에게 묻도록 롤백하면, 다시 Paper중에 serverClient 만 처리하면 된다. . 1paper는 여러N Progammer를 가질 수 있고 in field | 1programmer는 1paper밖에 못가지므로, 1에 해당하는 paper를 N에 넘겨서 처리하는 방향이 맞다. in 추상체vs 추상체 | . | . | . | 외부에서 받아온 인자에 대해, if를 제거해야하는 이유 . 지금 보이는 if의 case가 다가 아니다. 보이는 것만 짜려고 해서 놓친다. | if를 외부로 돌려서, 확장가능한 모든 case를 외부선택에 맡긴다. 내부는 코드변화가 없이 추상체로 대응한다. | . | 메서드로 추출하는 이유: 외부에서 시키는 것에 대하 기능제공을 해준다. 내부에서 if의 모든 case를 고려하지말고, 외부가 시키는대로만 하자. | . | . | 11 개발자의 세계-제네릭 적용 . 추상화 -&gt; instanceof가 아니라 if를 제거한다. 전략패턴: 추상체 인자를 유지한 체, 구상체는 형으로 만들어서 외부에서 선택 | . | 제네릭 -&gt; instanceof ( if와 호출처와 엮여 인자가 달린 추상메서드로 추출 )를 제거한다. 외부 추상체 인자를 유지한 체, 구상체는 형을 만들고, 외부에서 특정형 전용의 구상체를 만들도록 밀어낸다. | . | 둘다 if를 통해 발생하는 runtime, context에러를 형을 통해 발생하는 compile에러로 옮긴다. | . Paper와 Client . . 추상층은 T형 + upperbound(업캐스팅)의 제네릭을 주고, 추상체 인자(메서드/생성자/변수)를 T형으로 준다. . | 구상층은 T형대신 알아야하는 특정형을 제네릭으로 주고, 추상체 인자 대신 특정형으로 정의한다. . 구상층의 instanceof가 사라진다. . | 구상층마다 특정형(FrontEnd or BackEnd)를 알게되어 -&gt; 인자의 형들이 추상체가 아닌 특정형 을 받으므로 instanceof 대신 사용할 수있게 된다. . 추상형에 제네릭T를 쓰면, 구상형들의 T자리에 특정형으로 정의되도록 지원된다. | . . 현재 추상체인자를 사용하는 클래스의 추상층에 제네릭으로서 upperbound로 T형을 꽂아주고, 추상메소드 정의시 T를 사용해서 정의 | 구상시, 특정형의 부모를 상속/구현하면, T자리에 특정형으로 물려받음. | . | . . | ServerClient . 그러나, instanceof가 2개가 등장 -&gt; 제네릭은 특정형 1개만 T대신 정의되도록 해주므로 불가능 . 1:N관계에서 등장한 N개의 instanceof는 제네릭으로 제거 못한다. | 관계를 롤백해야한다. Paper에게 시켰다가 문제만 더 커졌다. | 시킬 때는, 추상체vs추상체가 아닐때만 시켜서 넘겨라. | . | . . | . Paper, Client, ServerClient 롤백 . . 관계도상, programmer는 paper를 알지만, 이것은 1:N관계에 대한 근거는 안된다. Paper가 가진 필드를 보면, programmer front / back 둘다 받는다. 1:N관계라고 할 수 있음. | . | programmer는 paper에 1개에 대한 정보만 추출한다. | . | 이상적인 관계는 N(child)가 -&gt; 1(parent)를 알고서 받아들여, 내부에서는 1:1 관계가 발생하는 것이다. RDB에서도 MANY테이블에만 One테이블의 id를 fk로 가지고 있다. | 1(paper)에게 N(this, programmer)을 던져 1내부에서 일 시키지말자!!! | . | . . 마커인터페이스므로 공통로직abc는 없다 개별 구상체에 잇는 내용들 전부가 d()에 해당하는 내용들이다. | 확장성LSP는 instanceof를 유발하므로 **공통로직 유무에 따라 템매 or 전략패턴으로 추상화해놓고 -&gt; 사용/의존class인 Programmer에 제네릭을 적용한다. ** | . | . Programmer, BackEnd, FrontEnd . 그 전에 사용/의존 class(FrontEnd, BackEnd)의 추상층(Programmer)의 upperbound로 얹을 수 있게 기본적인 개별로직 추상화 마커인터페이스에 적용해줘야한다.를 시켜야한다. . 사용class에 공통로직이 보이는지 본다. . | **템플릿메소드패턴은, 흐름만 비슷해도 ** . 공통로직은 그대로 &amp; 개별구현 private예비 훅메서드들 추출한 뒤, step별로 나열하는 public 템플릿메소드로 감싼다. 구상체에서는 private으로 빼놓고 훅메서드로 올리면 된다. | | 개별사용 메서드들이 따로 존재하면, 메서드명을 추상화해서 정한다. | . | . | backEnd는 Programmer을 상속하면, T자리에 특정형을 받아 사용할 수 있는데 . backend는 Client이외에 ServerClient 특정형 즉, 여러paper형 T를 받을 수있게 다시 한번 추상화한다. . | 추상클래스로 중간추상층화 해놓으면 . 실제로 구상층을 만들 수 있으나, 그만큼 class파일을 만들어줘야하므로 | 외부에서 익명클래스로 분신술- 실시간 구현하며 구상체가 됨. + 그 구상체는 제네릭 특정형을 알 수 있게 됨을 이용한다. | 추상클래스로 추상화했기 때문에, 안바뀌는 공통로직은 추상클래스에서 해결하고, 개별구현 훅메서드만 외부구현으로 맡긴다. | . | . | frontend도 여러형의 paper를 알 수있게 다시 한번 T형 + 추상화으로 만든다. . . | . Director와 Main (구상체들의 제네릭+추상클래스화 -&gt; 이용하는, 직위가 높은 외부에서 실시간 선택해서 구현) . 가장 위쪽 추상체인 Programmer, Paper에서 개별구현을 논하지말고, 구상체들도 추상클래스화 시키며, 더 바깥인 Director에서 선택&amp;구현하게 한다. . 상대적으로 더 외부에 있는 Director에게 내부에 들어갈 로직 구현해서 결정해서 들어가게 한다. | 클라이언트 쪽, 서비스를 이용하는 쪽 = 더 훌륭하고 돈 많은, 직위가 높은사람 = 구체적인 상황의 분기를, 바깥ㅔ 직위가 높은 사람에게 맡긴다. | . | 클라이언트방향에 책임이 떡질까 걱정하지마라. | 역할-&gt;책임 모델에 의해 if분기를 외부로 돌려 선택이 필요한 부분만 직위가 높은 사람에게 맡길 뿐이다. | . | 여러형을 받을 수 있는 중간추상층 FrontEnd와 BackEnd는 이용하는 직위가 높은 외부의 Director가 선택 및 구현하면서 이용(객체 생성)한다. . 형을 결정하면, 그 형마다 instanceof로 개별구현해야만 했던 로직만 익명클래스에서 구현한다. | . . | 아직 DIrector도 instanceof를 가지고 있다. . 이 때, 2개 이상의 instanceof는 if제거 방법을 써야한다(제네릭X) . | 의존관계 역전은 되나? . Director는 1에 해당하고 paper가 N이다. 서로 아는 관계가 아닐 땐, 의존관계 역전은 생각하지말고, 최대한 구상체들 단독일만 뽑아서 추상화하자. | . | Director가 하던 일을 paper.시키기(this)로 시킬 수 있나? paper구상체들을 추상화하는 것 자체가 -&gt; paper.전략메서드()의 시키는 작업이 되므로 의존관계는 생각할 필요 없다. | . | . | 의존관계 역전은, Director내부에서 director의 context를 사용하는 경우만 넘겨서 준다. . 하지만 Paper구상체들이 하는 일 가운데 director의 내부정보를 이용하진 않는다.( 추상화시 메서드 인자로 넘어가진 않는다) | . | 서로를 알아야할 때는 의존관계 역전을 하지만, 1:N은 그냥 if의 문제로 보고 구상체들을 추상화하여 if문 처리만 하면 된다. . 추상화시 director의 context가 안엮이는 부분 = 구상체 단독의 일만 추상화하여, 서로 아는 관계 = 추상화지 인자로 넘겨주는 관계가 안되도록 하자. | . . | . | director내부에서 하던 일들을 추상화 이후에, 구상체들 역시 중간추상층화하여, 이를 이용하는곳 = 외부에서 개별구현을 선택해서 case에 맞게 구현하도록 결정권을 넘긴다. . . . | 익명클래스는 바로 자식인데, 내부필드에 받는 것을 setter로 할 필요 없어진다. . protected 수준으로 필드를 만들고, 할당만 하자. 자식인데! | . . | 만약 Director가 추상형이었다면, N:M으로서 제네릭을 통해 instanceof를 제거했어야함. . 사용하는 쪽의 구상형 -&gt; 사용되는 놈의 특정형을 알도록 | . | . 정리 . 추상체vs추상체라면, N에게 물어보더라도 , 1에게는 시키지 않아야하는 구나 N(programmer)에서 1(Paper)를 받은 상태에서 1:1관계를 유지한체로 다른처리(제네릭)가 되어야하는구나. | . | 추상체vs추상체에서 instanceof를 제거하는 방법은 제네릭을 써야하는 구나 | 12 도메인분해 와 분해 3가지 방법(FLOW, ADT, OOP) . object 7장 정리 . | 조립(composition): 하나하나 의미가 있는 부속들을 모으는 것 컴포지션 되었다 -&gt; 모듈별로 격리가 잘 되었다. | . | 분해: decomposition 1개의 도메인을 여러개의 의미있는 모듈로 격리 나중에는 다시 composition시켜서 소프트웨어를 만들 것임 | . | . | 목표: 도메인을 어떻게 잘 디컴포지션 할 것인가 . | 도메인은 시간 순으로 만들어지기 때문에 비논리적 결합이 된 상태로 만들어진다. 논리적으로 디컴포지션시켜야한다. | 분해를 안하면 복잡성폭팔=인지과부하가 되어 이해할 수 없다. 복잡성 폭팔 = 인지과부하의 예 depth 3이상의 if | for안에 if : for자체가 if로서 하나씩 도는 것이나 마찬가지다. | | if의 case들을 쪼개는 것이 분해의 시작이다. 하지않으면 복잡성이 폭팔한다. | . | . | . | . Functional decomposition . 시작과 끝이 있는 flow를 따라가며 분해함 . 그러나 변화가 생긴다면 flow는 취약해진다. . | 예를 들어, 중간에 데이터가 추가되면 -&gt; flow는 흐름이므로 시작부터 미리 있었어야했다. -&gt; 첨부터 다 수저해야한다. . 이것을 피하려면 scope(지역변수, 메서드인자, 중괄호)를 이용한 격리를 써야한다. | 피했지만, 이후에 또 새로운 데이터가 발견된다면 -&gt; 격리된 로직을 포함해서 첨부터 다시 수정해야한다. | . . | 사람은 중간에 추가될 데이터/변동사항을 처음부터 알 수 없으니 flow방법으로 분해하면서 짜는 프로그램은 좋지 않다. . | . | . ADT(Abstract Data Type) . 데이터를 바라보면서 기능을 만든다. . | 데이터마다 기능들을 만들다보니, 비슷한 기능들이 눈에 들어온다. . . | 기능들을 추상화하고, 조금씩 다른 데이터만 처리해주면 된다. . 그러나 조금씩 다른 데이터 때문에 if가 발생한다. | . . if로 모든 기능을 한 군데 모으면 응집성이 좋아진다. | . | 문제는 ADT는 내부if를 품고 있기 때문에 데이터 추가(확장)시 취약하다 . 작업량이 엄청나게 늘어난다. . . | 또한, 기능의 추가가 특정데이터에만 발생(LSP에서 d())한다면, 나머지 데이터들은 null외 예외값을 내놓아야한다 . . | . | ADT가 성립하는 경우는 2가지를 만족해야한다. (변수, 데이터)가 더이상 확장되지 않고 | 안에 소속된 메소드들이 모든 상태들에 대해 결과값을 가지는 메소드일 때만 | | 우리는 대부분 ADT 데이터를 보고 코드를 짜기 때문에, 구상체의 확장 + 기능의 추가에 대비하지 못하는 코드가 된다. 대비하려고 instanceof를 쓰게 된다. | 그러나 내부 if를 머금은 ADT타입의 코딩은 짜면 안된다. | . | . OOP . 상태값(데이터)과 무관하게 기능만 추상화를 먼저하고, . 상속된 자식들이 알아서 데이터 + 기능을 구현하는 방식 . . | . | 데이터 없이 기능만 추상화하면, 구상체(형)의 확장이 자유롭다 . 데이터로 인한 if가 없기 때문에 | . . | 추상체의 메서드만 호출하면, 알아서 range binding된 구상체의 메서드가 호출된다. . | if로 발생하는 복잡성 폭팔을 방지한다. . 2중 if -&gt; 전략객체 (필드) 안에 전략객체(총 2개)를 가져 대체함. | 전부 외부에서 조달해주도록 미룬다. movie가 policy + condition을 전략객체 2층으로 가져간다. movice는 전략객체 policy만 안다.(if 1개를 대체한다.) | 전략객체 policy는 내부에 추메패턴의 condition객체들을 가지고 있고 내부에서 가진 condition으로 if를 대신한다. | main -&gt; conditions -&gt; policy에 꽂아줌 -&gt; movie에 꽂아줌 | . | . | . | OOP의 문제점 . 기능 d()를 단독 추가해버리면.. 추상화가 깨져 성급한 추상화 상태가 된다. | 이 해결방법은 다시 한번 추상화 후, 제네릭+구상체들의 중간추상층화 -&gt; 외부에서 익클을 구현해서 인식하게 한다. | . . | . 14 합성과 의존 그리고 템플릿메소드 패턴 . object 9장부터 이어지는 템플릿메서드패턴이 왜이렇게 복잡하게 일어나며, 의존성과는 어떤 관계가 있는지 살펴본다. . | 합성과 상속: 둘다 의존성과 관계되는 것 . 합성: 전략패턴에 사용되는 것 | 상속: 템플릿 메소드 패턴에서 사용되는 것 | 객체망을 구성할 때, 객체가 다른 객체를 안다 = 인자로 가져와서 사용(전달X) or 내부에서 생성해서 사용 의존성 없이는 객체망이 생성이 안되므로, 양방향 의존성을 갖지 않게 의존성을 관리하는 것이 목표 | . | . | . 템플릿메소드패턴 . . 좋은 상속인 이유 . 공통로직만 물려받고 자식의 개별로직은 개별구현함 | 부모가 변해도 -&gt; 자식들은 공통로직만 변하는 것으로서 변한 것을 그대로 물려받으며 부모코드를 직접적으로 내부에서 사용하질 않음. 자식마다 다른 내용은 훅메서드로 추상화되어있어서 -&gt; 자식만의 로직은 부모의 변화에 격리된 상태 | 자식들은 class구현시, 부모가 물려준 내용을 사용하지X. 갖다쓰기만 함. 내부에서 인자로 받아 사용하거나 생성하지 않음 내부에서 사용안한다? 의존성X | . | . | . | 상속이 문제를 일으키는 이유 . 여러자식들이 -&gt; 하나의 부모를 의존(알고서 사용)하고 있기 때문 | . | 추상클래스-템플릿메소드를 통한 상속은 괜찮은 이유 . 부모가 자식(의 필수인 훅메서드 = 추상메서드)을 알고 사용한다 | **부모가 자식의 추상메서드만 알고 사용한다면, 의존성은 추상체를 가진 부모에게 넘어가는 의존성이 역전된다. ** 부모가 자식들의 세부구현 모름. = 세부구현과 격리 = 부모를 수정해도 자식에게 여파가 안감 | . | . . 자식내부는 부모의 어떤 것도(필드, 메서드)알지도 못하고, 사용도 안한다. = 부모에 대한 의존성이 없다 | . . 왜 부모 -&gt; 자식으로 여파가 없을까? . 자식이 부모를 알고(인자 or 내부생성) 사용하지 못하는 이유 | . 부모는 private 필드를 사용한다. (자식이 알지 못한다) | 부모는 템플릿메소드만 public이다 -&gt; 자식뿐만 아니라 의존성 가지는 놈들이라면 누구든지 사용할 수 있다. | 만약, 자식도 받아쓰는 public을 수정했다면? 여파아닌가? 자식만의 여파가 아니라 기능을 사용하는 모든 외부에게 여파라서 상속의 문제가 아니다. | . | | public템플릿메소드 모두 private으로 만든 부모는 -&gt; 자식에게 여파주는 일이 없다. . | . | 반대로 부모는 자식을 알아야햐한다. by 추상메서드 . 자식이 개별구현하는 훅메서드는 부모가 알고서 사용할 수 있게끔 proected abstract수준으로만 통신한다. | . | 자식이 부모의 것을 알고서 쓰는 순간 -&gt; 여파가 전에지기 때문에 . 템플릿메소드, 훅메서드외에 다른 부모의 메서드를 받아쓰지마라 | 부모의 필드를 private이 아닌protected/public 필드가 있어도 자식은 쓰지마라 부모의 public 템플릿메소드 외는 어느것도 자식이 받아선 안된다. | 필요하면 자식 스스로 만들어서 써라. | . | . | **객체망에서는 부모 &lt;-&gt; 자식은 서로 다른 객체일 뿐이며 약속된 훅메서드로만 소통하는 객체망이다. ** . 상속의 모양만 갖추었지, 부모의 속성과 메서드는 아무것도 쓰지마라 | 이미 부모 -&gt; 자식의 훅메서드를 추상화해서 사용 -&gt; 자식이 쓰면 양방향이 된다 | . | . 15 Theater with 템메 to 전략패턴 (blog 링크 걸기) . 16 전략객체의 생성사용패턴적용을 위한 팩토리 . 객체생성코드와 객체 사용코드를 분리해서 관리하는 것이 유지보수에 더 좋다. 코드 사용주기의 차이점 객체생성코드는 1번만 만들고 끝난다. | 객체사용코드는 계속 사용된다. | . | 코드사용 타이밍의 차이점 객체생성코드는 지금 써서 만들었지만 | 객체사용코드는 한참 뒤에 객체가 사용될 수 있다. | . | . | 객체생성 코드와 객체사용 코드를 나누는 법 생성코드는 client쪽으로 밀어라 | 사용코드는 service쪽으로 가져고 들어오라 | Client쪽에서 생성한 객체를 주입을 통해 service에서 사용해라 | | 생성과사용을 동시에 나열한 나의 떡진 코드는 일부를 형(type, class)으로 바꿔서, 생성따로 하고, 이용해야한다. | . | 전략객체는 외부생성 -&gt; 생성자를 통한 주입 -&gt; 내부 사용의 생성사용패턴이 적용된 패턴이다. 하지만, DiscountPolicy입장에서는 강제로 pushed당한 것이다. 생성자주입은 받아서 사용하는 쪽이 제어권을 잃은 상태 | . | . | 내부의 주인인 DIscountPolicy가 **원할 때 전략객체가 pull**되어야한다. | . 제어권 역전을 위한 생성자주입 전략패턴에 Factory 달기 . . 전략패턴처럼 1개의 오퍼레이터를 가진 전략객체Factory 인터페이스 만들기 . 전략객체 자체를 pushed당하지말고, 전략객체Factory를 pushed당한 상태로 만들 예정이다. 이렇게 구성하면, policy가 원할 때 Factory를 통해 전략객체를 주입받게 된다. | . | Factory만 미리 알고 있은 체, 내가 원할 때 Factory를 통해서 pull하여 주입받기 전략패턴 적용처에 주기기능(getter)로서 전략객체를 반환하도록 한다. | . | . | 매 전략객체의 종류마다 구상Facotry를 만들어야한다. . 재료인 Money는 생성자로 미리 받아야하지만 | 개별전략객체의 공급은 getter로 받아오게 한다. | 추가적으로 synchronized를 걸어서, 멀티스레드에 대처하며, cache를 적용한체, 없으면 생성 있으면 그냥 반환한다. 생성시 cache 적용할 객체를 private 변수 null초기화하여 선언 | getter에서는 없으면 ( == null(초기값)) 생성하여, 변수에 할당한 뒤(cache에 넣기) | 반환은 무조건 cache객체로 | | . . 이렇게 하면, 미리 생성된 전략객체를 받는 게 아니라, Factory가 없으면 생산, 미리 생산되어있으면, 그냥 가지고만 오는 cache를 이용해서 가져온다. | . . 이렇게 Factory를 통해 원할 때 &amp; caching 적용하여 생성하는 것을 Lazy pulled라고 한다. | . | Factory가 pushed된 상태면 Lazy pulled 할 수 있게 된다. 하지만, 그대로 사용하면, 디미터법칙의 위반(최소지식=1차원관계=직접적으로 아는 놈만 쓰자)이 발생한다. . supplier.getCalculator()를 통해 포인터의 포인터라 현시점에서 생성되어 메모리에 올라간 개별전략객체를 얻는다.( 그전까지는 메모리에X) DiscountPolicy입장에서는, 어느전략객체가 왔는지 모른다. | 또한, 포인터의 포인터라서 supplier(Factory)에 다른 전략객체Factory가 왔어도 왔어도 업데이트된 Calculator를 받을 수 있게 된다. 혹시나 runtime상에서 바뀐 , 업데이트된 Calculator된 것을 받게 된다. | . | . | Factory의 마법으로 사용처는 무슨 개별전략객체를 가져왔는지 모르게할 수 있지만, 원래부터 추상체(전략인터페이스)를 인자로 받았기 때문에, 원래도 몰랐었다.ㅋ | . | . | 위임된 Factory로 일반Factory의 문제점() (.)getter 후 (.) 체이닝해서 사용) 해결 . 이렇게 사용하면 디미터법칙위반으로서, 열차전복사고가 생긴다. . . | 클래스는 원래 field에 있는 지식(+인자/지역변수까지)만 알아야한다. . 즉, . 한번만 이용해서 사용하며, 포인터의 포인터를 다시 사용해서는 안된다. 사용가능한 지식: 필드 / 필드들의 형 / 자기가 만든 객체 / 인자로 넘어온 객체 / 지역변수들 | . | Factory가 getter로 단순객체만 return하는 상황이면, 무조건 디미터법칙을 위반한다. 단순 객체 return하는 팩토리는 팩토리.getter() .메서드()를 사용하니까.. | . | . | Factory의 디미터 위반 해결 방법 2가지 . 사용처class가 Factory가 getter로 return하는 객체도, field or 지역변수 미리 안다. . getter로 받은 것을 체이닝없이 지역변수로 선언해서 받아 쓰기 . | getter를 지역변수로 받아도, 응답객체에 대한 의존성이 생긴다. . . | 이렇게 되면, (사실 이렇게 Factory를 유지하면)순환참조가 생긴다? . . 일반적으로 전략객체를 생성하는 전략Factory를 simple Factory로 구상체들과 함께 회전풍차의 순환참조가 생길 수 밖에 없다. 디미터법칙과 별개로 추상체에 대한 심플팩토리는 회전풍차(Factory Circulation) 때문에 사용하면 안된다. | . | . | . | | 위임된 팩토리로 지역변수 없는 체이닝 simple Factory의 전복사고 해결하기 . 사용처DiscountPolicy는 Factory객체안에 구상Factory를 가지므로, 아래와 같이 구현하면, factory인터페이스는 개별생성 from 구상체내부 + 개별전략메서드 from 추상체구현 형태를 가질 수 있다. | . Factory가 전략메서드(추상메서드)를 위임받고, 생성의 책임을 없앤다. . 사용처에서는 factory.전략메서드()로 바로 호출가능해진다. | . | Factory의 구현체(구상Factory)들만 LazyPull(cache적용된 전략객체)가능하도록 생성의 책임을 가지며 + 전략메서드의 개별구현 안에서 &lt;내부 생성책임이용해서 전략객체 생성&gt; .전략메서드() 호출을 동시에 한다 . 전략객체getter가 더이상 추상메서드의 구현(@Override)가 아니라, 구상class의 instance method로서 자신의 것으로 구현한다. | factory안에 들어있는 개별구상Factory가 내부에서 자신의 전략객체 생성메서드호출 개별구현된 전략메서드() 호출까지 담당한다. | . . | 사용처(DiscountPolicy)는 Factory만 알고서 factory.전략메서드()호출로 정의해서 끝난다. . . | | . 위임된Factory는 알고봤더니 전략인터페이스?? . 전략메서드가 위임된 팩토리만이 factory의 디미터법칙위반을 해결한다. . . . | 근데, 전략메서드를 사용하는 위임된 Factory의 책임이 이상하다. . DiscountPolicy내부에서는 Factory인데, 전략객체처럼 사용된다. | . . 전략Factory는 인터페이스명을 제외하고, 전략인터페이스와 완전히 동일하다. 실제로 구상Factory가 전략객체만 imple해서 구현해도 동일하다. | . | . . 구상Factory들은 전략Factory를 삭제하고, 전략인터페이스를 구현해도 똑같다. | . . | 전략객체 주입대신, 전략Factory를 주입했다가, 다시 전략객체를 주입(전략 인터페이스를 변수로 받는)하는 형태가 되었다. . 형태는 전략 인터페이스를 받아 전략객체를 주입하는 것 처럼 보이는 형태지만 | 개별 전략객체의 구상Factory들 역시 전략인터페이의 구상체이며, 외부에서는 구상Factory를 실제로 주입한다. | . . 변수명을 factory로 바꿔준다. | . . | 위임된 전략Factory -&gt; 위임된 구상Factory -&gt; 전략Factory삭제의 과정에서 . Factory circulation(회전풍차)가 사라지게 된다. . 기존 . | 위임된 후 추상Factory 삭제 . . | . | 보기에는 삼각형의 순환구조 같지만 . 생성된 전략객체는 Factory의 전략메서드 내용을 실질적으로 담당하기 때문에 순환표에서 구상Factory는 삭제하여 생각해도 된다. . . | . | . | . 위임된 구상Factory에서 trigger전략객체 받아와 제공해주는 책임 위임 . 현재 DiscountPolicy는 policy 적용 전략객체 -&gt; 전략인터페이스를 구상한구상factory가 전략객체 생성 후 전략메서드 적용 | condition 조건 전략객체들 -&gt; 외부에서 넣어주면, 받아서 저장 전략객체 condition의 의존성을 DiscountPolicy가 가진다. | . | . | 변경 하고싶은 DiscountPolicy . 정책조건 전략객체들의 생성까지 정책 구상Factory 내부로 위임하고 싶다. 구상Factory가 정책전략 + 정책조건전략까지 전략객체 2개를 담당하도록 하고 싶다. | Factory가 의존성 2개를 담당(생성+사용, 받기) Factory에 의존성 폭발을 유발 | . | . | . . 전략패턴의 의존성 폭발을 일으키도록(의존성 1개 추가 -&gt; 전략메서드가 2개) DiscountPolicy(사용처)가 저장만 해서 알던 의존성 Factory가 추가로 알게 됨. | . | . | 전략객체를 1개 더 받아들이고, 전략메서드를 1개 더 추가하는 전략패턴의 의존성폭발을 어떻게 유발할까?? . 기존 DiscountPolicy가 담당하던 전략객체 setter로 받기 ( 생성이후에 선택해서 받음. 여러개 받을 경우, default 빈컬렉션 -&gt; add메서드 ) | 저장한 필드를 내부에 (this.)필드로 제공 내부에서 필드사용 -&gt; 외부로 옮긴다면, getter가 된다. | . | . | . . 로직을 옮기려면, 받기기능 + 제공기능을 다 옮겨가야한다. | 받기기능은 내수용으로서 class라면 어디든지 내부에서 구현 가능하지만, 제공기능은 getter로서 외부에서 사용하는 메서드라서 추상메서드로 제공 -&gt; 구상체들 개별구현 해야한다. | . | . 현재 위임된 구상Factory는 1)내부전략객체 생성 + 2) 전략메서드호출를 시행하며 기존전략 인터페이스에서만 구상된 상태다. . Factory로만 다 로직을 옮겨가면, Calculator 인터페이스 변수를 그대로 사용해도 된다. 하지만, Factory에 옮겨가서 getter로 제공되어야할 새 기능 추가가 필요하다 | 이것을 기존 전략인터페이스에 위임하면, 메서드2개의 인터페이스가 되어버린다. 1개 인터페이스에 2개의 추상메서드?? | . | . | 이 전략인터페이스 &lt;-&gt; 구상Factory 사이에 중간추상층(인터페이스)을 추가 하여 인터페이스당 1개의 메서드만 제공하게 한다. . 최종 구상층은 기존 전략메서드 + 중간층에 추가된 추상메서드 1개를 다 구현해야해서 2개의 추상메서드를 구현해야함. 이는 문제가 안된다?! | . | 어차피 최종에서는 상위추상층의 기능을 구현하니, 바로 위 추상층만 주입용 인터페이스 변수로 바꾸면 된다. . 어차피 주입되는 것은 외부에서 최종구상층이 생성되어 주입되며, 중간추상층이 그것들을 다 포용할 수 있을 것이다. | 중간추상층에서도 추상메서드를 1개 추가한다. 제공기능은 이렇게 구현하게 하더라도, 받기기능은 어디서? | 제공기능이 전략(추상메서드)일 때, 내수용 받기기능은 추상층(인터페이스)가 아닌 개별 구상체에서 구현할 수 있다. | . | . . | . | 이제 전략인터페이스 대신 최종구상층 직전의 추상층인 중간추상층 PolicyFactory를 주입받는 추상체 변수로 둔다. . . 만약 제공기능이 DiscountCondition의 추상체를 가진 것이 아니라, 다양한 type을 제공해야한다면, 그만큼 중간추상층이 늘어나서, 조합이 폭발된다. . | 최종구상층인 구상Factory가 2개의 기능을 다 제공한다. . 기존 전략객체생성후 전략메서드호출 기능 | 추가 trigger전략객체 제공메서드 기능 | . . | . | 구상Factory는 2개의 전략 메서드를 구현 + 그 중 제공기능을 위해 타 전략객체 받기기능을 내수용으로 자체 구현한다. . 2번째 전략객체는, 구상class에서 주입받는다는 것이 원칙이다. | 2번째 전략객체의 기능을 도입하려면 전략객체를 받기기능은 구상Class에서 | 받은 전략객체의 기능제공은 중간추상층을 추가해서, 구상층이 다 가질 수 있게 | | . . | 생각 정리하기 . conditions의 상태가, 원래는 사용처 DiscountPolicy에 편하게 있다가 -&gt;Factory가 공급받는 식으로 바뀌어서 -&gt; 구상Factory로 이동 | VO가 아니라 포장만 해서 그런지, 내수용 받기기능 외에 내수용 add/remove기능도 구상Factory에 정의해줘야한다. | 구상Factory의 주 목적인 getter getConditions를 제공한다. | 이제 Factory의 구상Factory마다 수출품은 2개가 된다. Calculator -&gt; 직접 getter로 제공하지 않고, 메소드위임받아서 결과값을 주고 | conditions(set) -&gt; getter로 직접 제공 2개 이상 수출품을 가지는 Factory가 추상 팩토리메서드 패턴의 대상들이다. | . | . | DiscountPolicy -&gt; 구상Factory로 몰빵된 의존성 -&gt; 최종구상층인 구상Factory를 class로 계속 찍어내는 만큼, 알고리즘(if , if의 조합)을 바꿀 수 있게 된 것이다. 안에서 if로 처리하던 것을 class로 바깥으로 밀어낸 뒤, 바깥에서 공급 받을 수 있게 된 것 | 생성사용패턴으로 바꾸게 된 것 | Factory패턴의 진정한 의미 내 원래 코드 -&gt; 인터페이스로 바꿈 -&gt; 각 case마다 형(class)로 만들고 -&gt; 바깥에서 생성하도록 밀어냄 | . | . | . | 우리들의 코드에서 추상팩토리 or 팩토리가 등장하지 않는 이유: 코드를 형으로 바꿔서 바깥에서 공급받도록 개조하지 않았기 때문 -&gt; 형을 통해서만 공급받아야한다. 그냥 주입하는게 아니라 Factory를 통해 주입 -&gt; lazy Pull 땡기는 타이밍을 정할 수 있게 되었다. | . | . | factory가 trigger제공 + action 기능을 각각 제공하다보니 디미터법칙 위반 . . factory만의 로직인데, DiscountPolicy에서 getter로붙 펼처진다. . getter기능을 제공한다면, 디미터법칙위반을 생각하고 위임=시키기를 생각해야한다. | . | getter가 for문에 쓰일 때, 내부적으로 개별요소들은 의존성이 추가된다. . 개별 전략객체들은 추상체인 factory만 알고서, 기능만 이용하도록 책임을 위임했는데, 의존성이 추가되는 문제가 발생한다. 인터페이스가 getter를 추상메서드로 제공한다면, 그 추상메서드 getter를 내수용으로 쓰고, 실제 일을하는 메서드를 default메서드 추가 정의해서 바꿔야한다. | default메서드는 사용처에서 어차피 추상체변수가 쓰게 되어 구상층에서는 생각하지말자. | . | . . | 디미터법칙위반( 점2개 or 점1개 + for문)는 위임시켜서 -&gt; 앞에 .이 getter일 가능성이 높고, 그 것을 마지막 . 메서드 안에 포함시켜지도록 변경해야한다. . 기존에 위반은 객체.getA().B()였는데 . **B()내부에 넣어서 해결 ** | . | 현재는 객체.get복수객체들() + for문 .B()을 상태다. . DiscountPolicy는 몰라도 되는 부분 하늘색박스 전체를 factory내부로 가져가야한다. | . . | . | get복수객체들() + for문까지를 B() 내부로??? . 추상체 변수가 하는 공통의 일은 -&gt; 구상class가 아닌 inteface로 올려야한다. default메서드를 이용하면, 일반method를 인터페이스에 정의할 수 있다. | 현재 중간추상층 PolicyFactory factory가 하는 일이므로 중간추상층, 인터페이스 변수로 사용되는 추상층에 B()에 해당하는 calculateFee()를 default메소드로 정의한다. | . . getter는 추상메서드지만, 내수용으로 사용되게 된다. | 추가되는 default메서드는 어차피 추상체변수가 사용되게 되니, 구상쪽에서는생각안한다 | . | DiscountPolicy내부에서는 getter가 없어지고, 복수의 객체를 for문 속 지역변수로 받아 의존성추가가 안되어도 된다. . . | . 최종 전략패턴이 적용된 DiscountPolicy 살펴보기 . . 생성로직이 관여되어있나? 전략패턴이라도, 생성/사용 코드는 따로 존재하도록 위임된 factory를 적용해 lazy pull되게 한다. | . | 중복로직이 있나? | 전략객체를 2개이상 소유하고 있나? 혹은 엉뚱한 곳에서 몰라도 되는, 지역 의존성 by getter 후메서드or getter+for문이 사용되나 전략패턴은, 개별구현로직마다 의존성하고 있는 전략객체가 늘어나는 의존성 폭발의 문제점 | 전략인터페이스의 구조에 중간추상층 with 전략메서드을 추가하는 방식으로 factory에 의존성을 몰아주면, DiscountPolicy는 1개의 전략인터페이스만 알면된다. | . | 전략패턴에 Factory를 사용한 이유 전략패턴 사용처에 1개의 전략객체인 factory객체만 알게 한다. 의존성은 factory에서 폭발한다. | getter이후 로직들도, factory에게 넘겨 최종결과물만 내게 한다. | . | | . 왜 전략패턴이 적용된 DiscountPolicy에게 의존성을 낮추려는 보호를 할까? . DiscountPolicy는 누굴 상속하지도 않은 변하지 않는 class . 설계요령: 변하지 않는 class에다가, 변하는(전략객체 등)을 주입한다. . 계속 변하지 않는 이유: 변하는 부분은 factory와 같은 전략인터페이스가 위임해준다. | . | 왜 DiscountPolicy가 변하지않는, 보호대상일까? . 포인터의 포인터에 있어서 . 뒤쪽은 변하지만 추상체가 충격흡수하는 포인터 : DiscountPolicy 내부 전략객체를 사용해주는 메서드 . Movie에서 policy.calculateFee() . . | policy에 따라서 calculateFee방식은 바뀐다. . caclulateFee()내부에는 변하는 전략객체를 사용하는 부분이 내장되어있다. | . . | . | 앞쪽은 변하지 않는 포인터 : DiscounPolicy - 전략객체를 사용하는 곳이며, 변하는 뒤쪽 포인터(전략메서드)를 변하지 않고, 굳건하게 앞에서 잡아주는 역할을 해야한다. . 변하지 않는놈을 -&gt; 확정포인터로 기준 코드를 쫘났기 때문에, 내가 알고 있는놈은 절대 변하지 않게 된다. . | 변하지 않는 사람에게 &lt;– 가짜 가면을 제공하고 &lt;– 가면을 계속 바꿔준다. . | 그래서안정적으로 포인터의 포인터 안정적으로 사용하려면, 전략객체를 주입받는/사용하는 discountPolicy 자체는 의존성이 낮게 보호해야한다. . 의존성이 높아지면, 변화에 여파를 받게 되며, 그러지 않기 위해 변하지 않는 class를 먼저 만들고(discountPolicy), 변하는 것들(전략객체1,2,3 -&gt; factory 1개로)을 주입한다 | 그러기 위해 여러개의 전략객체에 대해 factory에 몰빵시켰다. | . . | . | . | . | . | 변하는 코드를 짤 때, 의존성을 생각해서 상대적으로 짠다. . 내가 어떤 코드A를 수정하는데, 의존하는 객체B가 있더라 변하지 않으면서 의존되는 객체B부터 빨리 확정지어야 -&gt; my) 거기에 전략인페orFactory만만 걸어놓고 변하는 코드A를 짤 수 있다. | 도움을 받아야하는 객체들 -&gt; 모두 변하지 않게 만들어버려야한다. by 팩토리로 다 넘기고, 포인터의 포인터로 이용하게 | 포인터의 포인터(Factory)에게 싹다 넘기자. | 포인터(DiscountPolicy)는 변하지 않으니 -&gt; 이놈을 의존하는 코드들은 (내가 짤 코드 포함) 안전해질 것이다. | 내가 의존하는애들부터 확정시키자. | . | . | .",
            "url": "blog.chojaeseong.com/object/2022/05/25/(object1-15)object_part1_summary.html",
            "relUrl": "/object/2022/05/25/(object1-15)object_part1_summary.html",
            "date": " • May 25, 2022"
        }
        
    
  
    
        ,"post57": {
            "title": "OBJECT 14 템플릿을 전략으로 + Factory(코드스핏츠)",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . ch6. 합성과 의존성 . . 디자인패턴에서 가장 중요한 패턴이 무엇이냐 물어보면 추상 팩토리 메서드 패턴이라고 답할 것이다. . 그것과 더불어 커맨드 패턴 정도 이다. 이 2가지가 가장 중요한 패턴이다. | . 책 9장부터 이어지는 템플릿(추상 팩토리 메서드) 패턴이 왜 복잡하게 일어나는지 의존성과 어떤 관계가 있는지 한번 살펴보자. . 책에선 합성과 상속에 대해 나와있다. . 디자인 패턴에서 합성과 상속의 차이를 패턴으로 알아보는 방법은 템플릿 메소드 패턴과 전략 패턴이 문제를 해결해나가는 패턴을 생각해보면 된다. 합성과 상속의 장단점을 살펴보면 된다 | . | 합성과 상속을 하던 가장 큰 과제는 의존성이다. 책에서는 의존성을 3장을 할당한다. | 그 이유는 우리는 객체로 문제를 해결할 때, 객체망을 구성하는데, 다른 객체가 또다른 객체를 안다 = 안다는 의존성이 생긴 것 의존성없이는 객체망이 성립하지 않으니까, 설계상의 핵심은 의존성을 적절하게 관리하는 것 but 적절한 것은 없다. 오직 관리하는 방법은 의존성을 양방향이 되지 않게 관리하는 것 | 단 방향으로 만들자! | . | . | . Template method . 개념 . . DiscountPolicy에 대해 Template method를 적용해보자. 현재는 discountpolicy를 set으로 소유 | calculateFee라는 메소드가 템플릿메소드로 작동하면서 my) 인자1+2를 받는 메소드가 -&gt; 가지고 있는 list를 돌면서 if + 인자1 -&gt; element가 만족 -&gt; 인자2로만 다시 호출하는 같은이름의 추상메소드를 호출 | calculateFee라는 훅을 다시 내려주고 있다. | . | 템플릿 메서드 -&gt; 위에서 내부에 인자가 다른(줄은) abstract메소드를 호출 + 아래서 사용되는 abstract메소드가 훅 | . | 템플릿메소드를 좋은 상속의 예로 소개하는 이유는? 의존성의 방향이 역전(여러자식들 -&gt; 부모 에서 부모-&gt; 자식들로 역전)되기 때문(보다 추상화된 쪽을?쪽으로? 역전) | 책에서 말한 상속의 약점: 부모&lt;자식 : 자식이 부모를 쓴다 = 안다 = 의존한다. 일반적으로 상속으로 퍼져나갈 때, 자식이 부모를 안다. 부모는 자식을 모른다. | 객체지향에서 자식이 부모를 안다?( 부모를 다운캐스팅해서 사용) 다운캐스팅이라 부르며 그것은 잘못 된 것. 다운캐스팅 = 리스코프 치환원칙 | 업캐스팅을 통해 자식은 부모를 대신할 수 있지만 부모는 자식을 대체할 수 없는 것 | 상속을 하면 자동으로 자식 &gt; 부모를 가리키게 됨. 의존성의 방향이 자식이 부모를 가리키기 때문에 상속은 쓰면 문제가 되는 나쁜놈이다. | . | . | 왜 상속이 문제를 일으킬까? 여러개의 자식들이 —&gt; 하나의 부모를 가리키기 때문에 | 부모를 건들이면 여러군데가 영향을 받는다. 상속을 썼더니 의존성이 넓게 퍼져버린다. | 상속구조를 가진 이상, 부모를 건들이면 모든 자식이 영향 | 부모레이어의 수정여파가 모든 자식한테 가서 겁나서 부모를 건들이지 못하는 상황이 된다. | . | . | . | . abstract class DiscountPolicy { private Set&lt;DiscountCondition&gt; conditions = new HashSet&lt;&gt;(); public void addCondition(DiscountCondition condition { conditions.add(condition); } public Money calculateFee(Screening screening, int count, Money fee){ for(DiscountCondition condition:conditions){ if(condition.isSatisfiedBy(screening, count)) return calculateFee(fee); } return fee; } protected abstract Money calculateFee(Money fee); } . 근데 템플릿 메소드 패턴은 부모(DiscountPolicy)가 자식들(이 반드시 가질 abstract protected메소드)을 알고 있다 자식들의 반드시 가질 수 밖에 없는 추상메소드만 알고=의존하고 있다.(의존 역전) | 부모의 수정은 자식에게 영향을 끼치지 않는다.(상속 문제점 해결) -&gt; 부모와 상관없이 자식만의 독립된 인터페이스만 구현하도록 시키고, 자식의 메소드명만 의존한다. | **일반 상속은 자식이 —&gt; 부모의 메소드명 속성+메소드의 세부 구현까지 알고서 이용하도록 구현된다. 하지만 템플릿 메소드 패턴에서는 역전이되어 부모가 일처리 + 자식이 미래구현하도록 확정된 오퍼레이터명만 것을 의존하여 부모 로직 정리 ** 자식은 제한되어있는 자기 책임(abstract메소드)만 구현하고 부모을 몰라도 된다. | . | 실제 처리는 부모가 자식의 메소드명만 의존한 체로 처리한다. | . | 자식은 부모를 몰라도 되며, abstract에 따른 책임만 구현하면 된다. 추상메서드로 이름만 정해주니까, 자식의 어떻게 구현/수정하든 여파가 부모로 올라오지 않는다. (독립된 인터페이스를 구현하는 자식) | 그외 부모의 세부구현은 모름 -&gt; 수정해도 상관없음 | . | | 상속을 사용할 때는, 부모의 변화가 자식에 여파를 일으키지 않는 스킬=템플릿메소드을 사용해야 좋은 상속이 된다고 책에서 소개한다. | . . 역전된 상속을 만들어내는 훅 -&gt; 훅을 사용하는 메서드 = 템플릿 메서드 미래에 자식들이 구현해야만하는, 제한된 책임 = 훅을 이용해서 부모쪽에서 로직을 구현함 | . | . 이용(자식 구현) . . 템플릿메소드를 사용한(훅을 가진) 추상체를 상속한 자식들을 보자. 어떻게 관계의 역전을 사용했을까 훅을 가진 부모를 상속해서 자식을 구현한다 | 자식은 부모가 처리해줄테니까 이것만 구현해라고 지어준 책임을 구현한다. | **자식의 나머지 모든 구현은 super(X) 부모속성(X) 부모메서드(X) ** | | . 부모 -&gt; 상속 자식으로의 여파가 없는 이유 . . 부모에 있는 훅 제외의 나머지를 보자. . 부모 private 변수 -&gt; 자식이 부모 속성에 접근할 수 없다. | 부모 public 메서드 -&gt; 자식(protected)가 아니라 자식포함 대외적 아무나 쓸 수 있다. 부모가 외부에 공개하는 것 | 부모 public 은 자식들만 사용하고 있는 부모만의 유일한 것이 아님. | 부모 public을 수정하는 안건 —&gt; 자식에 여파주는 안건에 포함이 안됨 —&gt; 자식포함 public을 사용하는 모든 애들에게 여파를 각오하고 수정하는 안건 부모수정 -&gt; 자식들 모두 수정 되는 일반상속과는 조금 다른 안건이다. | . | . | 외부공개 인터페이스(public 메서드)외 모두 private으로 만든 부모 -&gt; 자식은 부모의 내용을 사용할 수 없다 -&gt; 부모의 수정이 자식에게 여파를 끼치지 않는다. | . | 근데, 자식도 다 private으로 구현하면? . 부모는 원래 자식을 모름(=사용안함. 그리고 자식이 public으로 외부공개 아닌이상 못씀) . | 근데 템플릿메소드는 부모가 자식을 알아야함(protected추메를 주고 자식public구현메만 당겨쓴다.) . 미리 약속된 protected추메는 자식들이 나한테 public으로 제공해줄 의무도 포함되어있다. | . . | 자식들은 . 자기의 사정(필드, 생성자, 메소드)을 구현하면서 + | 부모와의 통신은 부모의지식사용X 미리 확정된 프로토콜(protected abstract)만 이용해서 대화를 주고 받는다. | 그 덕분에 헐리웃 원칙(tell, don’t ask)을 지키고 있다. 자식은 훅을 사용해서 말하기만 함 통신대상인 부모에게서 getter로 뭐 읽어들이지 않음 | . | 부모가 원하게 있으면 말을 검 통신대상인 자식에게서 getter로 뭐 읽어들이지 않음. | . | . | . | . | 상속을 쓰는데 템플릿 메소드가 아닌 [부모가 상속한 메서드]이나 private이 아닌 [protected/public부모속성들]을 쓰고 있다면 이미 꽝 상속 = 상속된 부모클래스를 안 건들여야 한다. 건들이면, 여러 자식들이 와르르 다 무너지니까 | cascading으로 여파가 안미치려면, 자식들이 부모의 상속한 속성+메서드를 쓰지말고 약속된 메서드만 제공해주고, 부모가 일을 처리하도록 역전 | . | . | 객체망에서는 부모객체와 자식객체는 서로 다른 객체일 뿐이다. 부모객체 만들고 자식객체 만든다. . 원래는 new AmountPolicy하면, 자식객체 뿐만 아니라 부모 객체도 먼저 만들놓고, 부모객체-자식객체 2개를 묶어서 포인터로 관리된다. . 캐스팅이 가능한 이유는.. 부모 객체를 먼저 만들기 때문. 어느 형으로 갈지만 선택해주는 것 | . | 하지만, 객체망에서는 부모객체, 자식객체 서로 다른 것이고 따로 통신을 해줘야한다 . 템플릿 메소드는 부모-객체의 대화 패턴 중 서로 약속되어 있는 abstract메서드를 통해서 프로토콜(인터페이스)만 가지고 대화하도록 도아주는 패턴이다. . . | . | 부모를 사용하면 할수록, extends한 수많은 자식들에게 여파를 끼치니 . 상속 모양은 갖추되, 부모의 속성+메서드는 하나도 쓰지마! 꺼꾸로 부모가 자식을 알아서 쓸게! . | 단일 의존 포인트 . 하나의 객체를 너무 많은 객체가 알고 있으니, 생기는 문제 . | 여파가 너무 쌔니까 이제 더이상 부모를 못 고친다. | 부모를 복사해서 새로운 class를 만들기도 | 상속말고도 의존하는 것이 많아지는 것 자체가 문제 | . | 부모를 (부모꺼 상속받아 써서) 많이 알고 있는 자식보다, 자식의 1개 프로토콜만 아는 부모로 관계를 가볍게 만든다. . | . | . | 부모 —– 자식들의 선 5개 에서 - 자식들의 공통 - 부모 - 자식이 늘어나도 메소드 1개만 가지면 관계를 유지함. . | 템플릿메소드를 잘쓴다 = 상속의 요령을 익히는 것 | . 똑같은 코드를 전략패턴으로 짜보자. . 상속 -&gt; 템플릿 메소드 -&gt; 전략으로 짜는 것은 밥 먹듯이 할 줄 알아야한다. . 보통 확장 가능성으로 유연하게 더 연결될 것 같다? -&gt; 전략 패턴 | 안정화되어서 더이상 확장안될 것 같다? -&gt; 상속 구조를 가진 템플릿 메소드로 바꾼다. | . Strategy . . public class DiscountPolicy { private final Set&lt;DiscountCondition&gt; conditions = new HashSet&lt;&gt;(); private final Calculator calculator; public DiscountPolicy(Calculator calculator){ this.calculator = calculator; } public void addCondition(DiscountCondition condition { conditions.add(condition); } public Money calculateFee(Screening screening, int count, Money fee){ for(DiscountCondition condition:conditions){ if(condition.isSatisfiedBy(screening, count)) return; } return fee; } . 전략패턴은 우리가 계산을 할 때 상속이 아닌 합성의 원리를 이용해야하므로 외부공급 객체를 받아줄 변수를 소유를 해야한다. 부모였던 DiscountPolicy가 private final Calcuator calcuator라는 객체를 소유하게 되는데 | DiscountPolicy를 상속해서 처리해줬던 자식의 구현을 가지고 있는 외부의 객체의 도움을 받게 된다. 해당 외부객체가 템플릿 메소드의 자식구현 역할을 해줄 것이니까 받아준다. | . | 상속을 이용했던 이유? . 서로 다른 구현을, 자식들에서 구현하기 위해 . | 하지만, 서로 다른 구현을 하는 자식클래스가, 서로 다른 구현을 하기 위해 자신만의 상태도 가지고 있어야함 . | . | 전략 패턴은? . 서로 다른 구현을 위한 상태를, 자식클래스가 아니라, 상속이 아닌 다른 클래스에서 -&gt; 외부 객체로 제공로 제공받으면 되지! 객체 통신을 위해 메모리에 객체 2개가 생길 것인데, 꼭 상속으로 만들어야 하나? 상속의 장점: 두 메모리간의 연결을 컴파일러가 해준다. | 합성: 두 메모리간의 연결을 우리가 직접 해야한다. | . | . | . | 외부에서 서로 다른구현을 공급해줄 객체를 생성자를 통해 공급받고 . | 공급받은 객체로, 서다구현을 직접 구현한다. 이 때, 필요한 상태도 상속계층이 아닌 외부객체의 클래스 내부에 위치되어있다. . . | 이 외부객체Calculator는 사실 인터페이스였으며, 서다른구현 메소드를 구현할 추상메서드를 가지고 있으며, 상속이 아닌 impl구현으로 서로다른구현이 가능해진다. . Calculator.java . public interface Calculator { Money calculateFee(Money fee); } . | 서로다른구현1: AmountCalculator.java . public class AmountCalculator implements Calculator { private final Money amount; public AmountCalculator(Money amount) { this.amount = amount; } @Override public Money calculateFee(Money fee) { return fee.minus(amount); } } . . | . | . 코드 비교 . 템플릿메소드가 했던 일을 전략패턴으로 바꿀 수 있다. 2개를 비교해보자. . . 우: 템플릿 메소드 패턴을 이용하기 위해 상속레이어사용 | 좌: 전략 패턴을 이용하기 위해 hasA모델 = composition모델을 사용 impl 과 extends를 제외하고 코드가 완전히 동일하다. 부모를 상속 extends DiscountPolicy는 Calculator라는 인터페이스 역할을 수행하고 있었던 것이다. | 추상클래스를 인터페이스처럼 프로토콜로 사용하고 있었다.는 말이다. | 상속을 잘쓰려면, 처음 부모를 짤 때 프로토콜의 근간을 두고 있는 인터페이스처럼 짜자!! | . | . | 추상레이어(부모)를 잘짰는지 확인하는 방법 -&gt; 전략패턴으로 바꿔본다. 추상층(부모)을 hasA모델(전략패턴)로 바꿀 시 잘바뀐다 | 잘 안바뀐다? -&gt; 뭔가의 context를 넣어줘야한다 -&gt; 부모 오염시 자식들 다 오염되 구조의 상속 말이 부모지, 인터페이스에 준하게 상속을 짜야한다. | . | . | . . 의존성 관계가 simple해진다. (관계도가 작다) . 등장인물이 2명 밖에 없다. . | 의존성을 역전시켰다. . | 만약, hasA모델(전략패턴)으로 바꾸면 아래와 같다 . . 의존성을 해결하는 방법이 서로 다르다. | 전략패턴: DiscountPolicy가 AmountCalculator는 모르도록 하기 위해(순환참조X 단방향으로 만들기 위해) | 중간 레이어(전략 인터페이스?)를 끼워넣어 (공급받을 외부객체가 될 예정) 단방향 의존성으로 해결해버렸다. 템플릿 메소드(상속)에 비해서는 의존성이 1개 추가되었지만 하지만 의존관계는 다 1:1이다. 각각의 라인은 가벼워졌다. | . | 끼워넣은 중간레이어Calculator(전략 인터페이스)는 무거웠던 템메패턴(상속)에서 일처리하던 부모역할 DiscountPolicy가 짊어지던 짐을 -&gt; 전략패턴 인터페이스 객체 Calculator가 짊어지게 된다. | 따라서, 전략패턴을 사용하면 중간에 끼워넣은 전략인터페이스를 바꾸기는 굉장히 힘들어진다. | 추가적으로 **전략인터페이스를 구현한 구현체자식들도 다 이쪽으로 의존하게 된다. ** 양쪽으로 무거워진다. | . | . | 전략패턴 주의점: 프로토콜에 대한 확신이 없다면(전략 인터페이스 수정 가능성 있다면), 한번 전략패턴 도입후 수정시 엄청난 여파가 생긴다. (위/아래로 다) 모든 곳에 여파가 생기는 전략패턴 | 상속의 부모자식관계보다 더 무거워 위험해진다. | . | . | . | . | 전략패턴의 주의점(단점)을 생각해보면, 제한된 목적으로 꼼짝못하게 할 때는 . 상속이라는 위험이 있음에도, 템플릿 메서드를 통해 관계 단순화 + 방향성 고정을 시키려고 하지만, 처음에는 고정시킬만큼 도메인파악이 안되니, 가운데 전략인터페이스 수정의 위험을 가지고 있지만, 처음에는 관계도를 분리해서 여파를 흡수해주는 놈으로 먼저 쓴다. | . | 전략패턴을 통해 우리는 의존성 1개 끼워넣을 때마다 어댑터를 끼워넣었다고 생각해야한다. . 벽면에 있는 콘센트 &lt;— 노트북을 충전 . 콘센트 — 어댑터 — 노트북 충전 여러 Volt 대응가능 | 추가 기능으로서 충전시간 조절가능 | 추가 기능으로 밧데리파워 어댑터 추가 꼽을 수 있음. | . | . | 그냥 콘센트에 꽂지 않고 어댑터를 끼워서 사용하면 할 수록 여러 변화의 폭을 수용할 수 있다. . 스프링을 그냥 사용하는게 아니라 래핑된 클래스를 사용함 | jquery를 그냥 사용X -&gt; 한번더 감싼 함수를 사용함. | 스프링, jquey가 업데이트되면, 래핑클래스의 대부분내용은 그대로고 업데이트 된 부분만 수정해서 그대로 사용 | . | 위아래의 변화(여파)충격를 어댑팅해줄 수 있다. 얼마나 변화가 많냐에 따라 충격흡수해줄 중간층을 몇개 끼워줄 지 결정된다. . 가운데 Calculator(전략인페)가 충격을 흡수해준다. . 위아래 모두 전략인페 만 바라보고 있다 = 알고 있다 = 의존한다 -&gt; 변화에 대한 충격은 이용당하는 = 화살표받는쪽에서 흡수한다. . | . | 반면에 템플릿메소드 패턴은 부모-자식이 직접통신하기 때문에, 상속의 방향은 역전시켜놨지만, 중간에 여파 충격을 흡수할 층이 없다. . | 위/아래 각각의 변화가 서로 심하다 . 1층의 쿠션(Calculator)으로는 충격완화가 안될 것 같다. | Policy의 변화를 잡아줄 Policy전략인페 + 각종 Calculator의 변화를 잡아줄 Calculator인페 -&gt; 인페끼리 서로 대화하게 만든다. | . . | . | 전략패턴을 쓰면, 템메(상속역전)과는 비슷해보이지만, 2가지 차이점이 생겼다 . 프로토콜로서 공용 인페가 가운데 생긴다 -&gt; 무거워진다. 템메에서는 자식들과의 관계가 가볍다. | 템메는 자식을 늘려도, 프로토콜에 의해 부모가 -&gt; 자식을 거꾸로 알게되는 가벼운 관계 1개씩 생긴다 | . | 템메의 무게 = 본인(DiscountPolicy) 클래스에 존재하는 추상메서드(calculateFee)에 대해 -&gt; 무게가 아주 약간씩 느는 것 전략의 무게 = 중간에 끼어드는 인터페이스가 다 감당해야하는 무게 | . | . | . 비교 . . 템메(상속 역전): 런타임에 타입 선택 if를 통해 AmountDiscountPolicy냐 RateDiscountPolicy냐 형을 선택 Type을 선택하는 순간, 그 안에 종합선물세트를 가지고 있게 된다. 해당 형인 동시에 DiscountPolicy이기도 하니까 | . | 원리: 추상메소드를 통해서 의존성을 역전 | . | 전략: 런타임에 합성 DiscountPolicy는 그 자체(인페)로 존재하고, 새로운 인페 구상체를 붙인다 = 합성한다. | 원리: 추가 인터페이스로 (중간에 끼워넣어서) 의존성을 분산 | . | 클라입장에서는 템메 if를 통해 원하는 class선택해서 생성 / 전략 if없이 class를 생성후 -&gt; 합성하고 싶은 객체를 if를 통해 선택하여 생성 if의 대상이 서로 달라진다. 세트 전체 컨택하여 if vs 추상체 - if각구상체 | . | DiscountPolicy의 안전성은 전략패턴에서 유지된다. 초반부터 확정되어있거나 안정화되어야하는 객체다? (반대인듯?) -&gt; 선택의 여지없이 전략패턴을 사용해야한다. | 중간에 교체할 수 없는, 초반부터 물고 있어야하는 것이라면 -&gt; 상속 계층을 가지고 있더라도 무조건 전략패턴으로 바꿔야한다.(전략패턴은 런타임시 포인터의 포인터 연산으로 선택하게 할 수 있으므로) runtime = 포인터의 포인터 연산이 가능한 곳 = 전략패턴 -&gt; Rumtime시 calculator자리에 ` 구상체로 언제든지 바꿀 수 있다`. | 전략패턴: DiscountPolicy.calculator는 런타임시에도 포인터의포인터로 계속 바꿀 수 있다. 포인터의 if포인터 | . | 템메패턴: new AmountDiscountPolicy()로 만들어버려서 더이상 바꿀 수 없다. 포인터의 포인터 전략X if 포인터로 끝남 | . | . | . | . 각각의 단점 . . 템메: 조합 폭팔이 일어난다. 상속계층이 깊어지거나, 역할수행하는 자식들이 병렬구조가 아니라 중첩구조인 경우, 조합의 경우의가 계속 늘어난다. 책에서는 요금제의 문제가 있다. 요금이 결정될 때, 중첩이면서 병렬이다. 같은 레벨에 여러개가 있음에도 불구하고 그 밑에 또 다른레벨이 있어서, 경우의수 계산시 조합폭팔이다. | . | 템메의 경우, 조합 폭팔(경우의 수)만큼 자식의 class를 만들어야한다. 상속을 이용한 세트를 만들었기 때문에 조합 폭팔이 일어난다. 3가지의 박스 -&gt; 각각에 120가지 과자를 선택해야한다면? -&gt; 그만큼 class만들어야한다. | 그에 비해 전략은 그 경우의 수만큼 들어갈 수 잇게 비워두고 외부에서 선택해서 1개를 받으면 된다. 런타임에서 바꿔 꽂아주기만 하면 된다. | . | . | . . 전략: 의존성 폭팔이 생긴다. 선택해서 넣어줄 120개의 과자를 미리 알아서 내부에서 받아줘야한다. class를 만들진 않았지만, 만들어진 class들을 알고서 내부에서 받아서 사용 | . | . | . . 그럼에도 불구하고, 템메는 역전된 상속임에도 상속의 근본적인 문제가 해결되지 않는다. . | hasA모델 = 합성 = 조합 = 전략패턴을 사용하라고 추천하는 이유는 의존성 폭팔은 해결가능하기 때문이다. . 조합 폭팔을 일으키지 않을 곳 -&gt; 템플릿메소드 패턴 or 전략패턴 사용가능 | 내부에 여러 개의 (자식의존)구성요소를 가지고 있고, 그 만큼 class를 분산해야한다면 -&gt; 전략패턴 사용 calculateFee메서드 뿐만 아니라 다른 메서드도 추상메서드를 사용해야하는 템메라면? 조합 폭팔 | 조합 폭팔은 막을 수 없다. | 세상에서 제일 좋은 팩토리메서드 패턴 -&gt; 훅이 1개만 있는 것( 훅 2개이상부터는 이미 조합폭팔로 들어가고 있는 것) 클래스로 따지면 XXX DiscountPolicy -&gt; 훅 2개부터는 AAA BBB DiscountPolicy | 오직 calculateFee() 추상메서드 1개 때문에 -&gt; AmountDiscountPolicy가 됬었음. | 훅 늘어날때마다 이름에 훅이 들어가면서 조합폭팔로 class가 폭팔 | 템메패턴 주의점: 훅 메서드 2개이상 사용하지마! | . | . | 템메는 훅(자식에게 구현시키는 추상메서드)을 1개만 가져야하고, 2개이상 들어어가야할 것 같다 싶으면 전략패턴으로 바꿔야한다. | . | 템메의 2개의 상이한 asbtract method(훅)를 정의하는 대신 -&gt; 2개의 전략객체가 나타났다면? . 2개의 다른 인페를 가졌으며, 조합을 짜도록 2개가 안에서 서로 대화할 것이다. | 그러나 형이 밖에서 확정되서 들어오기 때문에 대화는 문제가 안된다. | . | 의존성폭팔 차악으로 선택했는데, 어떻게 해결할 것인가? . 템메 훅의 갯수 == 내부 if의 갯수 -&gt; 코드안에 if속에 if를 해결한 것 상속구조에서는 if AAA if BBB들을 각각 따로 떼어서 AAABBBDiscountPolicy로 class를 만드니 class 내부는 단순하다. | . | 외부 전략객체 갯수 == 외부 if의 갯수 외부에서 선택된 객체 -&gt; 내부에서 받아줄 때, 각 경우를 어떻게 쓸지를 작성하는 복잡한 코드. == 의존성 폭팔(코드가 각 객체에 따라 복잡해짐.) | . | 너무 많은 전략객체는 어떻게 해결할 것인가? 합성모델 사용했는데, 다중 합성 객체를 가질 경우의 의존성폭팔은 어떻게 해결할 것인가? | 객체지향 목적의 1/2 | . | . | . 생성사용패턴과 팩토리 . 책 9장에서 나오는 의존성 폭팔을 해결해보자. . . 코드를 자세히 바라보면, 객체 생성코드가 있고 만들어진객체 사용코드 따로 있다. 이 2 코드를 병행해서 쓰지마라.분리해서 관리하는 것이 훨씬 더 유지보수에 좋다. 생명주기가 다르다.(만드는 것은 1번만 만들고 끝. 사용은 계속) | 쓰는 타이밍도 다르다.(지금 만들었는데, 쓰는 것은 10년 뒤 ) | . | . | . . 변화율에 따라 따로 코드관리를 하는 것이 객체지향의 목표다. 객체지향이 변화율을 나눠주는 것이 아니라 책임기반 프로그래밍이 변화율을 나눠준다. 생성(책임)코드 vs 사용(책임)코드 : 그 사이에 38선을 그어라 | . | . | 둘을 나누자. 책에는 생성코드 -&gt; client쪽으로 밀어라 | 사용코드 -&gt; service쪽으로 들고와라 | . | . . clinet에서 -&gt; service쪽으로 객체를 injection(주입)할 수 밖에 없다. 원래는 service안에 뭉쳐있던 생성코드를 무조건 client쪽으로 더 밀어내자. 상대적인 것이기 때문에, main메서드가 아니더라도 보다 더 밀어내면 된다. | 안타까운 얘기지만, 생성코드 밀어내는 것은 실력에 비례한다. | . | 사용쪽은 점점 service안쪽으로 데려오자. 생성코드를 client쪽으로 밀어내는 것은 어렵다. | . | 생성사용패턴을 이용해서 코드를 리팩토링해야한다. 알고리즘이라 생각했던 것(생성코드가 없던 것)-&gt; | Type(형)으로 바꿔서 생성한다.(생성 코드로 바꿔서 형을 만든다.) (by 인페 -&gt; 구현한 class?) -&gt; | client를 밀어내서 생성하도록 알고리즘을 바꾼다.(인페를 받도록 하고 인페호출하도록 코드를 짠 뒤, 외부생성한 전략객체를 받아준다?) | . | 나의 떡진 알고리즘 -&gt; 일부를 형(Type)으로 바꾸는데 성공해야한다. -&gt; 생성해서 이용하는 코드로 바꾼다. -&gt; 생성한만큼 바깥으로 밀어낸다. 책 11장에서 설명함. | . | . 전략의 Injection . . (전략객체는) 생성자를 통해 외부에서 생성되어 주입되고 있다. my) 전략객체는 외부에서 선택생성하여 주입되는데 -&gt; 생성자를 통해 외부에서 주입된다 | . | 주입되는 것은 실무적으로 불만이 많다고 한다. 주입 = 바깥(Client생성코드)에서 주도적으로 여기(Service사용코드) 다 넣었다. clinet는 자기가 원해서 주입했으니 능동적 | . | 하지만, 독립된 책임과 역할을 가진 DiscountPolicy입장에서는 달갑지 않다 왜 바깥에서 내 입에 단팥빵을 확 쑤셔넣지? | 내 역할과 책임은 어디갔지? | . | injection은 외부에서 쑤셔넣는 것 -&gt; 생성자로 받아주는 쪽의 역할과 책임은 약화된다. | 나는 pushed를 당하고 싶지 않다. 내가 원할 때만 pull 해줘 헐리웃 원칙 위배. &quot;&quot;내가 단팥빵 먹고 싶을 때 말할 거야. 니가 왜 쑤셔넣어&quot; | my) 생성자를 통해 주입하는 방식 = pushed하여 제어권을 잃는 방식 | 나쁜 코드 | . | . | . 전략의 Factory . . 제어권 역전을 위해 Factory를 만들어보자. . 함수형 프로그래밍에서 지연 함수와 같은 역할을 한다. . | Factory: 외부에서 생성코드를 받을 때, 내가 원할 때 pull해올 수 있도록해주는 인터페이스를 가지고 있다. . 외부에서 setter와 유사하게 new 생성자()로 강제로 &lt;이미 외부에서 생성된 전략객체&gt;를 pushed하게 주입하는 경우 -&gt; 무조건 받아놔야한다.. = pushed . . | Factory을 미리 알고 있은 체 내가 원할 때 pull하여 주입 받기(단팥빵 먹기) . 전략인페 + 전략객체-메소드호출용 추상메소드 -&gt; 외부에서 전략객체 생성하여 공급 전략 Factory인페 + 전략객체-반환용 추상메소드 -&gt; 외부에서 전략객체 supplier 공급 | . | . | . | . . 재료인 money는 생성자를 통해 미리 받아야하지만, (Calculator를 사용하는 DiscountPolicy입장에서)원하는Calculator(전략객체)를 원할 때 + 캐쉬정책까지 사용해서 싱크로나이즈까지 걸어서 멀티쓰레드도 대처하여 전략객체 반환한다. . 전략 객체가 pushe당하면 -&gt;그에 따른 메서드 호출만 정의해준 중간 전략인페 -&gt; 메서드 구현만 달리해주던 전략객체의 구상체class . | Factory는 기본적으로 구상클래스를 모르게 감춰주는 역할 뿐만 아니라 (DiscountPolicy는 전략패턴 사용하면 client에서 만들어서 공급되므로 어차피 구상클래스를 모름) . pushed가 맘에 안들어서, 외부에서 어캐 공급하든 간에 get전략객체()메소드를 사용처(DiscountPolicy)에 재공하여 필요할 때 외부객체를 pull하도록 한다. | . | . | my) 전략패턴의 전략객체 외부공급은 손(Factory) 쓰지 않으면 사용을 위해 &lt;이미 외부생성&gt;-&gt; 생성자를 통해 무조건 &lt;전략객체를&gt; 받아쳐먹어야하는 pushed 상황이었다. . | Factory를 사용하는 이유는, 전략객체를 받아서 바로 사용해야 하는미리생성된 전략객체 pushed 공급이 맘에 들지 않기 때문에 Factory를 먼저 pushed해주는 작전이다. . . 물론 주입 pushed되긴 한다. 하지만 호출하는 전략객체(단팥빵)을 입에 쑤셔넣는게 아니라 원할 때 전략객체(단팥빵)을 생성 할 수 있는 supplier(리모콘) 인페객체을 생성자를 통해 pushed받을 뿐이다. . my) 전략객체용-메서드호출 전략인페만 가지고 있다가 -&gt; 전략인페 반환 supplier 인페를 추가 구현후 -&gt; 구상체supplier를 외부에서 pushed받는다. | my) 전략객체 생성을 사용처(DiscountPolicy) 필요시 내부 supplier.getter().전략객체용메서드호출로 사용한다. | . . | Factory를 통해서, 조금 더 늦게 + 원할 때 + 캐슁까지 써서 pushed되는 것이 Lazy pulled라고 한다. . | . | . . Factory로 pushed됬으면, 이제 Lazy pull할 찬스가 생긴다. . 원할 때, supplier를 통해 원하는 전략객체(XXXCalculator)를 얻을 수 있었다. 그 전까진 메모리에 생성X + 그이후론 supplier.getter() 정의부 = 해당전략 class의 변수에 캐슁된 전략객체를 사용하게 된다. | Factory의 .체이닝을 이용한 포인터의 포인터 getter()는 supplier.getCalculator()만 보면, 캐슁된 것(?) 다른 전략객체(?) 어느 것을 공급받을지 모른다. -&gt; DiscountPolicy는 Calculator만 알게 되는 Factory마법 | lazyPulled는 지연연산을 통해 런타임에서 다른 Calculator를 받을 수 있는 가능성을 가진다. supplier.메서드()가 아니라 supplier(포인터) .(의 포인터)를 통해 얻어서 .메서드()호출 | 포인터의 포인터는 정적바인딩이 아니라서, 런타임에서 얼마든지 바뀔 수 있다. | . | . | . | Factory는 의존성을 역전하진 않지만, push -&gt; lazy pull의 사용성을 역전시킨다. . Factory 사용이유는 다양한데, 구상XXXX는 모르게 하는 이점도 있긴한데, . 현재 상황(전략패턴)에서 DiscountPolicy는 Calculator는 알지 구상Calculator는 원래 모르는 상황이다. . 먼저, 사용성 역전(전략객체 바로 pushed -&gt; Factory의 supplier로 캐슁+필요시 생성하는 lazyPull이 가능해졌다. | . | . | . 단순객체return Factory의 문제점(열차전복) . . 클래스는 field에 있는 지식만 알아야한다. 즉, 포인터의 포인터에서 사용하면 안된다. . . 열차전복사고 = 디미터의 법칙 위반이다. 내 필드에는 factory= supplier팩토리만 있고 팩토리만 사용해야하는데, getter()로 구상(포인터의포인터)Calculator를 불러와 그것을 사용하고 있기 때문에 사용가능한 지식: 필드 / 필드들의 형 / 자기가 만든 객체 / 인자로 넘어온 객체 / 지역변수들 | 이렇듯, 단순 객체 return 팩토리는 무조건 디미터 법칙을 위반한다. 단순 객체 return하는 팩토리는 팩토리.getter() .메서드()를 사용하니까.. | . | . | . | . . 디미터법칙 위반 상황에서 2가지 선택지가 있다. . factory뿐만 아니라… field or 지역변수로 Calculator를 선언하여 Calculator까지도 알도록 한다. | . | 열차전복사고는 어쩔 수 없이 포인터의 포인터도 필드or지역변수로 알게 명시해줘야한단다. 근데 그렇게 되어도.. 순환참조가 발생할 수 밖에 없다. - CalculatorFactory는 아래쪽의 구상CalculatorFactory가 알고 있고 - CalculatorFactory는 객체return할 때, 추상클래스인 Calculator를 return한다. - 구상CalculatorFactory는 객체return할 때, 구상클래스인 구상Calculator를 을 알고 있다. - 팩토리 - return객체간에 회전풍차(Factory Circulation)도 무조건 생긴다. . | 요약: Calculator도 알게 하면 답이 없다. simple Factory는 무조건 사용하지말라는 이유가 된다. . | 사용처가 factory만 아는 것을 고수해도 열차전복사고가 안나도록 설계를 바꾸는 방법?? . | . 위임된 팩토리 . simple Factory의 전복사고 해결 . simple Factory의 전복사고 해결 방법 Factory에 전략메소드()를 위임 -&gt; | 구상Factory에 getter()정의 -&gt; getter()사용 -&gt; 전략객체가 됨 -. 전략메서드호출()까지 하여 최종결과물을 반환 | 사용처(discountPolicy)에서 더이상 getter().전략메서드()의 연쇄는 안해도됨 | . | . . 사용처(DiscountPolicy)가 Factory만 알아도, 열차전복이 안일어나는 방법이 있을까? . get으로 물어보지 않고 factory에게 &lt;최종 호출메서드 calculateFee&gt;를 내부로 위임을 하는 것이다. . 사용처 내부에서 -&gt; factory(supplier)가 getter로 꺼낸 뒤, 사용처 내부에서 메서드호출 . . | factory에서 getter로 꺼내지않고 factory 내부에서 메서드 호출 . . | . | . | . . my) 전략Factory도 추상인페라서.. 구상Factory가 있으며, 구상Factory에서 해당 전략객체를 반환하는 getter가 정의되어있었다. . | 이제는 구상Factory에게 메서드호출()의 책임이 위임되었다. ** **my) 중간에 getter로 토해내지말고 -&gt; 뒤에 연결된 것도 다 해결해서 반환 . . 구상Factory 내부에서 Factory의 기본역할인 캐슁+getter이외에 전략메서드()까지 호출한 결과값을 반환하도록 수정 my) getter()로 중간값을 내뱉던 (구상Factory)놈에게, 니가 정의한 getter를 내부에서 사용 -&gt; (runtime에선 전략객체 상태) 전략객체의 전략 메서드호출()하여 최종결과물까지 반환 (하도록 전략메서드를 Factory에서 정의하여 책임부여) | 구상Factory안에서 getter-&gt;(전략객체)-&gt;전략메소드까지 호출 되도록 Factory에 getter가 아닌 전략메소드의 책임 위임 이 되어야, DiscountPolicy는 Factory만 알고 Calculcator를 몰라도 되는 상황이 된다. Factory에 getter의 위임만 보통있다. -&gt; getter는 구상Factory로 옮기고 거기서 사용하게 한다. | . | . | . | . . 사용처(DiscountPolicy)는 Factory만 알면된다. factory.전략메서드()호출로 정의해서 끝난다. | . | 위임된 팩토리가 아니면 디미터의법칙을 해결할 방법이 없고, | 만약에 어겨서 2개(Factory + 전략인페)를 다 알게 해도 무조건 순환참조의 상황이 되게 한다. . | 전략패턴에 + pushe주입해결을 위한 팩토리를 쓰는 순간 -&gt; 위임된 팩토리를 쓸 수 밖에 없다. | . 위임된 팩토리의 정체 . . . 위임된 팩토리의 정체는 원래 전략 인페(Calculator) 그 자체구나!! 위임된Factory -&gt; 전략인페로 수정해야한다. | . | 전략 인페는 Factory로 구상할 수 도있고, 구상클래스들로 구상할 수 도 있던 것이었다.! pushed 주입을 해결하기 위해 getter+캐슁해주는 Factory를 도입했다. | 열차전복을 해결하기 위해 Factory에는 전략메소드책임을 -&gt; 구상Factory에는 getter()이외에 전략메소드()호출해서 최종결과물을 반환해줘야한다. | 그랬더니 Factory는 전략인페와 완전히 동일한 놈이 되었다. -&gt; Factory자리에 전략인페로 교체함 | . | . . Factory대신 전략인페를 넣어주면 된다. 사용처 DiscountPolicy는 Factory대신 전략인페를 아는 것으로 돌아가버렸다. | 위임된 팩토리의 특징은 팩토리가 안보인다는 것 전략인페의 책임(전략메소드)을 위임받았다면 -&gt; 전략인페 == 위임된팩토리 똑같기 때문 | . | . | . . . 보기에는 삼각형의 순환참조가 남아있는 것 같다. . 하지만, 구상Calculator인 AmountCalculator가 AmountCalculoatrFactory의 역할을 대신할 수 있기 때문에 AmountCalculoatrFactory는 사라진다고 한다. . | 위임된 팩토리를 사용하면 기존 3개층만 남게된다. -&gt; 원래 인터페이스를 수정하여, 회전풍차 4각형을 쳐내서 기존 형태로 만들면서 구현하게 된다. . . | . | . 추상 팩토리 메소드 패턴 for 의존성폭팔 . . 전략 -&gt; 의존성 폭팔을 해결하기 위한 패턴 위임되든, 위임되지 않은 팩토리건 간에 여러 계층의 객체를 반환할 수 있는 능력을 가지게 되는 패턴이다. | 위에서는 객체 1 종류만 반환해도 디미터법칙 위반 했었다. 객체 2종류를 반환하면 어떻게 될까 | . | . | . Factory에 의존성폭팔 만들어보기(2종류 전략 공급으로 늘리기) . 아직까지 의존성 폭팔이 발생하지 않았다. Factory에서 공급받는 외부전략의 종류 1개(Calculator) 뿐이기 때문 | . . conditions들을 Factory에 위임해서 -&gt; Factory에서 받아올 예정이다. 변수 + 기능을 일단 없애준다. | 우리는 (전략인페 -&gt;) 전략인페동급Factory만 일단 알고 있으면 된다. | . | . 기존에 의존성 1번째 전략객체getter -&gt; 전략메소드인 getCalculator -&gt; 전략메소드 calculateFee()에 추가하여 2번쨰 공급 전략객체getter인 getConditions()를 받아온다. . Conditions도 getter()로 팩토리에서 공급받게 되는데, Calculator도 원래는 getter()로 공급받으나 위임된팩토리로서 메서드까지 호출하게 되었다. 그래도 2종류를 공급하는 팩토리가 되었다. . 더이상 Calculator가 될순 없다. -&gt; PolicyFactory라는 별도의 추상레이어를 만들어 기존 전략인페(위임된팩토리) 이후 2번째 전략을 공급받아줄 2번째 전략인페만들어서 중간에 끼워넣을 필요가 있다 . . | . | . | . Calculator이면서, getConditions() - set객체를 반환해주는 getter를 가진 Factory여야한다. 전략1종류 - 전략2종류를 가진 구상체의 코드를 (아래 그림에서)보면, 지금은 괜찮아보이긴한다. 외부에서 2종류만 받으니까… | 하지만 여러 종류의 객체를 반환하는 경우가 되면, 그 반환 객체마다의 추상(전략)인페가 존재하게 되고, 그만큼 구상 조합의 수가 많아지게 된다. | . | . conditions의 상태가, 원래는 사용처 DiscountPolicy에 편하게 있다가 -&gt;Factory가 공급받는 식으로 바뀌어서 -&gt; 구상Factory로 이동 my) Factory는 getter() or 전략메서드명만 명시하는 인페일 뿐, 상태+기능은 구상Factory에서 | . | VO가 아니라 포장만 해서 그런지, add/remove기능도 구상Factory에 정의 | 구상Factory의 주 목적인 getter getConditions를 제공한다. . | 이제 Factory의 구상Factory마다 수출품은 2개가 된다. Calculator -&gt; 직접 getter로 제공하지 않고, 메소드위임받아서 결과값을 주고 | conditions(set) -&gt; getter로 직접 제공 2개 이상 수출품을 가지는 Factory가 추상 팩토리메서드 패턴의 대상들이다. | . | . | . 우리는 추상 팩토리메서드 패턴를 왜 쓸까? . 사용처(DiscountPolicy)가 의존성 화살표를 줄일려고 -&gt; 의존성을 구상Factory로 몰아줄려고 Set | DiscountCondition | calculator -&gt; 의존성이Factory 1개 아는 것으로 바뀌게 되었다. | -&gt; 내부if에 해당하는 case를 구상Factory로만 구현만 할 수 있으면, 생성사용패턴으로 바꿀 수 있게 되었따. | . | . | DiscountPolicy -&gt; 구상Factory로 몰빵된 의존성 -&gt; 구상Factory를 계속 찍어내면, 알고리즘(if , if의 조합)을 바꿀 수 있게 된 것이다. 안에서 if로 처리하던 것을 class로 바깥으로 밀어낸 뒤, 바깥에서 공급 받을 수 있게 된 것 | 생성사용패턴으로 바꾸게 된 것 | Factory패턴의 진정한 의미 내 원래 코드 -&gt; 인터페이스로 바꿈 -&gt; 각 case마다 형(class)로 만들고 -&gt; 바깥에서 생성하도록 밀어냄 | . | . | 우리들의 코드에서 추상팩토리 or 팩토리가 등장하지 않는 이유: 코드를 형으로 바꿔서 바깥에서 공급받도록 개조하지 않았기 때문 -&gt; 형을 통해서만 공급받아야한다. | 그냥 주입하는게 아니라 Factory를 통해 주입 -&gt; lazy Pull 땡기는 타이밍을 정할 수 있게 되었다. | . | . . 이제 Factory만 받아오면 된다. factory에게 getConditions new HashSet의 생성코드도 Factory에게 다 넘어갔다. | . | factory에게 Calculator역할의 메서드 호출 | . | 하지만, 문제가 남아있다. | . . forEach를 쓰고 있다. -&gt; 열차 전복사고가 안에 내장되어있다. . set.iterator() 호출이 생략된 for문 -&gt; 열차전복사고 중 | . | DiscountPolicy는 &lt;Set&gt;Conditions가 무엇인지 모른다 -&gt; 무엇을 반환하는지도 모른다. . 만약, 뭘 가지고 있는지 안다? == 디미터 법칙에 의해 필드로 잡아서 받아줘야한다. | . | &lt;Set&gt;Condition뿐만 아니라, DiscountCondition도 뭔지 모르는 상태 -&gt; 디미터법칙이 2중으로 일어나고 있다. . . 디미터법칙은 위임을 통해 해결한다. | . | . . Factory에게 하늘색 박스 == DiscountPolicy가 모르는 부분을 모두 위임시켜야한다. 모든 Factory마다 동일한 policy의 공통로직이다. | 인터페이스의 공통 로직은 Factory라는 인터페이스의 default메소드로 구현하면 된다. | . | . . 상속한 Calculator 것들은 구상Factory에서 구현하도록 두고 공통로직 위임받은 것을 default메소드로 새로운 calculateFee()를 정의해준다. | 이 때, getConditions()로직은 본인안에서 쓰게 된다 == getter()를 자기가 써서 최종결과물을 반환하는 디미터 해결 | Factory는 원래 DiscountCondition을 알고 있었다.(원래 공급해야할 놈) -&gt; 사용해도 괜춘 디미터법칙위반X DiscountPolicy는 몰라서 문제가 됬었음. | . | return calculateFee( fee )의 부분은 이 인페를 구상할 구상클래스가 만들어주는 템메(상속역전)패턴도 사용된다. | . | . 전략 2종류를 공급하기 때문에, 2개의 훅이 생겼을 것이다. . Calculator 상속으로 인해 -&gt; 구상Calculator에서 받아오는 템메 훅 | getCondtions라는 훅 | 원래 훅 2개의 문제점 == 템메의 조합폭팔의 문제점들을 —&gt; Factory에게 밀어버렸다. —&gt; 외부에 밀어놓으 전략+Factory . . 최종 DiscountPolicy를 보면 Factory를 받아서, factory에게 calculateFee()를 위임하는 끝난다. | 진정한 사용코드 밖에 없다 | 생성코드밖에 없다? | . | . . DiscountPolicy에 생성이 관여 or 중복 로직 or 더큰 문제는 의존성 폭팔을 일으키는 &lt;내가 모르는 것&gt;이 있나? 살펴보자. Factory입장에서, 내가 알고 있는 애들끼리의 관계 -&gt; 의존성폭팔(공급받아 가지고 있지만, 애들 사용법 지식을 다 알아야한다) | DiscountPolicy입장에서, Factory로 부터 공급받은 &lt;Set&gt; Conditions와 Calculator에 대해 사용법 지식을 알려줘야한다. 보통은 공급받았다? -&gt; field(변수)에 잡아놨다. -&gt; 사용하는 지식은 어떻게 알아야하나? | DiscontPolicy가 set conditions -&gt; loop -&gt; if 걸리면 -&gt; calculateFee()의 지식을 다 알아야할까? | . | Factory를 만든 이유(지식 줄이고 Factory만 의존시키기)를 위해서 의존하던 모든 것들을 Factory에 이동시켜야한다. | Factory -&gt; 공급하는 2종류의 사용법도 Factory가 지식을 알도록 거기서 다 사용해서 최종결과물만 공급하도록 -&gt; 이사시킨다. | . | . | 추상 팩토리 메서드 패턴도 위임된 팩토리패턴을 가지게 된다. 팩토리 패턴이 어려운 이유: 위임의 시작 + 1종류보다 더 많은 것(공급하는 것들)을 가져오게 됨. | calculator와 condition만 공급해서 위임받을려 했는데, screening에 대한 책임까지 떠넘겨졌다. Factory가 screening에 대한 의존성도 생기게 됨 | DiscountPolicy의 의존성을 낮추려는 것이 목적. 보호하게 되었음. | . | . | 따라서, 아키텍쳐 상으로 가장 먼저 결정해야할 것은 변화에 가장 강하게 대응할 수 있게끔 보호해야할 객체가 누군지 알아야한다. 가장 변화가 생기는 부분부터 챙긴다. -&gt; 추가/변화/늘어나는/미정의 부분을 먼저 찾고 -&gt; 상속도 받지않는 안변하는 클래스를 먼저 만든다. -&gt; 이것을 기준으로 책임, 역할이 이 class로 향하도록 짠다. | 설계요령: 의존성을 주입할 때, 변하지 않는 class에다가 의존성(factory 등)을 주입한다 DiscountPolicy가 변하지 않는 이유 -&gt; 모든 DiscountPolicy의 변하는 부분을 Factory(다른 놈)이 받아가서 | . | 왜 DiscountPolicy를 보호할까? 포인터(DiscountPolicy)의 포인터(변하지 않는 놈에게 주입하는, 향하는 모든 것들, Factory포함)를 이용하려고 Factory는 포인터(DiscountPolicy)의 포인터기 때문에, runtime시 바꿔끼워넣을 수 있다. | 하지만 변하지 않는놈을 -&gt; 확정포인터로 기준 코드를 쫘났기 때문에, 내가 알고 있는놈은 절대 변하지 않게 된다. | 변하지 않는 사람에게 &lt;– 가짜 가면을 제공하고 &lt;– 가면을 계속 바꿔준다. | . | . | . | 코드를 짤 때, 의존성을 생각해서 상대적으로 짠다. 내가 어떤 코드A를 수정하는데, 의존하는 객체B가 있더라 | 변하지 않으면서 의존되는 객체B부터 빨리 확정지어야 -&gt; my) 거기에 전략인페orFactory만만 걸어놓고 변하는 코드A를 짤 수 있다. 도움을 받아야하는 객체들 -&gt; 모두 변하지 않게 만들어버려야한다. by 팩토리로 다 넘기고, 포인터의 포인터로 이용하게 | 포인터의 포인터(Factory)에게 싹다 넘기자. | 포인터(DiscountPolicy)는 변하지 않으니 -&gt; 이놈을 의존하는 코드들은 (내가 짤 코드 포함) 안전해질 것이다. | 내가 의존하는애들부터 확정시키자. | . | . | .",
            "url": "blog.chojaeseong.com/object/2022/05/23/(object1-14)%ED%85%9C%ED%94%8C%EB%A6%BF%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4%EC%9C%BC%EB%A1%9C_%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4%EC%97%90%EC%9C%84%EC%9E%84%EB%90%9Cfactory%EC%A0%81%EC%9A%A9.html",
            "relUrl": "/object/2022/05/23/(object1-14)%ED%85%9C%ED%94%8C%EB%A6%BF%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4%EC%9C%BC%EB%A1%9C_%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4%EC%97%90%EC%9C%84%EC%9E%84%EB%90%9Cfactory%EC%A0%81%EC%9A%A9.html",
            "date": " • May 23, 2022"
        }
        
    
  
    
        ,"post58": {
            "title": "windows xbox record in chrome",
            "content": "windows xbox 녹화 단축키 . win + alt + R : 빠른 녹화 . | win + g : xbox 녹화 설정 . | 크롬 소리 녹화가능하게 하기 . 게임+마이크 기반으로 녹화되는 것이 기본 설정이다 . | 아래 그림과 같이 설정을 바꿔야한다. . | . . win + g를 눌러 xbox 기능으로 들어간다. | 우측 상단의 톱니바퀴 &gt; 캡처 중으로 들어간다 | 아래 2가지를 체크한다. 게임 플레이 중 백그라운드 녹화 | 게임(게임, 사용가능 마이크) 옵션을 -&gt; [x] 모두(게임, 사용가능 마이크, 앱, 시스템)로 변경한다 | . |",
            "url": "blog.chojaeseong.com/configuration/windows/xbox/record/2022/05/22/windows_xbox_record_setting.html",
            "relUrl": "/configuration/windows/xbox/record/2022/05/22/windows_xbox_record_setting.html",
            "date": " • May 22, 2022"
        }
        
    
  
    
        ,"post59": {
            "title": "OBJECT 13 개발자의세계 with ADT(코드스핏츠)",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . ch13. 개발자의 세계3 ADT버전 . . 이미 OOP로 만들어 놓은 상태에서 -&gt; ADT로 바꿔서 그 차이를 이해하는 시간이다. . 왜냐면 우리는 습관적으로 ADT를 만들고 있기 때문 | . | 하지만, ADT는 현실에서 쓸 수 없다. . 형(상태, 변수, 분기)가 확장되는 것은 프로젝트 진행상 당연한 것이기 때문 상태가 추가하든, 메소드가 추가되든 ADT는 취약하다. | . | . | . 저번시간까지 모델 . . OOP를 통해, (추상화 -&gt; ) 형이 뿌러나는 형태로 전개된다. 왜? 내부if로 먹던 것을 -&gt; 외부에 형으로 치환했으니 with 추상화, 전략패턴 | . | . . OOP에서는 형(해당 데이터)을 기준으로 -&gt; 연산을 확장해나간다. 자식/구상체마다 상속/구현해서 연산을 다르게 구현해나간다는 뜻 이 연산은 이놈에서는 이런 뜻 / 저놈에서는 저런 뜻 | . | . | . Paper 통합 . . 저번시간까지, Paper 인터페이스는 아무것도 없지만, Paper를 확장해서(상속, 구현) -&gt; 여러 속성과 메소드를 가지는 Client/ServerClient를 뿌러나면서 형을 만들었다. | . | 이것을 ADT로 합치면 어떨까? . &quot;이건 뻔하게 플젝 종류가 2개 밖에 없으니, 굳이 형으로 나눌 필요가 있나?&quot; | &quot;내가! 공통점을 Paper 1개로 다 처리되게 묶을 수 있어. 뿌러나도록 하지말고 고도로 추상화된 Paper 1개로 끝내자.&quot; | . . | . . 최소 구상체로 추상화부터 -&gt; 점점 뿌러나가는 방식의 OOP가 아니라 내부if로 먹어버린 1개 형의 ADT으로 구현한 Paper는 뒤에 아무것도 없어졌다. . Paper가 극단적으로 보이는 이유는, 인터페이스가 메서드(Operation)가 하나도 없었기 때문이다. . 따라서, Clinet/ServerClient 전체 속성+메소드들을 copy해와서 붙혀넣었다. . 만약 Paper에 메소드가 있었다? -&gt; 공통메서드이다 -&gt; 2 구상체는 똑같은 메소드를 구현했을 것이다 -&gt; 합치면 겹쳐서, 로직을 통합(힘든 과정임)하는 정도로 됬을 것이다. | 공통기능이 Paper에 별로 없다? -&gt; 복붙만하면되고, 2구상체의 공통 로직을 통합(빡셈)하는 과정이 없어서 쉽다. | . | ADT는 내부if와 함께 통째로 은닉화한다고 했으니 -&gt; 2가지 분기 -&gt; 1가지만 가지고 client이다/client아니다(=serverclient다)의 boolean으로 결과값만 반환으로 나타내보자. . 2case밖에 없으니 -&gt; flag로서 if분기를 만든다. | . | ADT의 문제점 -&gt; 통째로 집어넣으니, 특정분기가 아닌데도, 데이터들을 담을 속성을 모두 가지고 있다. . 정규직 근무자임에도 불구하고 시간제 근무자가 아니다 boolean flag변수 | 시간제 근무자가 가지는 해당분기용이 아닌 변수들 다 가지고 있어야함. | . | . | . | . . 문제는 분기를 담고 있는 flag변수의 여파가 끝나질 않는다는 것 . 오버라이딩메소드가 없어서 -&gt; 메소드내 코드 통합(빡셈)은 없었지만 | 모든 코드는 모든 상태를 커버하도록 바꿔야한다. 모든 메소드는 client든 serverclient든 누가오든지간에 다 커버가능한 상태로 변경 | . | 은닉화된 내부if분기에서 분기마다 서로 다르게 사용되는 메서드들은 (외부에 노출되지 않으니) 외울 수 밖에 없다. client일 때 -&gt; setProgrammer사용 (해야 된다고 외워야한다) | serverclient일 때-&gt; setBack/setFrontProgrammer사용 (해야 된다고 외워야한다) | 각각의 분기마다 사용메서드를 외워야한다. 통째로 집어넣고 은닉화해서. ** **추상화하면 다 공통이라.. 외울필요 없는데 | 뉴비 context들을 어떻게 인식? 처음에는 모른다. 팀내에서 지식 노하우라 부르면서 외워야함 지식과 노하우는 다르다. | . | . | . | ADT 내부 메소드들은 추상화되어있다 = 형을 인식안해도 된다. -&gt; BUT 실제로 사용되는 메소드들은 내부if분기마다 달라진다. . | . Programmer 통합 . . paper와 달리, 인터페이스에서 메소드(Operation)을 가짐 | 프론트 language와 library를 가짐 | 메소드 오버라이딩함. paper를 (자식들 다 받아주는) 인스턴스로서 인식했었는데, 지금은 paper가 ADT로서 하나의 추상형으로 통합되었므로 못쓴다. | . | . | . | . . 백엔드 마찬가지로 오버라이딩 메소드 및 paper인스턴스 못쓴다. | 그외 것들도 못쓴다. | . | . . 프+백 -&gt; Programmer로 로직 통합(빡세다고했음)을 살펴보자. . 프론트인지 아닌지로 상태가 flag로 나눠졌다. 뿌러났던 class형 2개가 —&gt; flag변수가 들어와 2가지 상태를 나타낸다. | . | language는 둘다 가지고 있던 것 인터페이스의 공통기능 메서드operation이 아닌 코드를 통합할땐, 첫번째로 이름 충돌이 일어난다. | ADT 통합시, 이름 정하는 규칙이 문제를 발생시킨다. | . | . . 통합하는 순간부터 이름 충돌난 변수를 —&gt; 분기별로 표시를 하는 나쁜이름(긴)의 변수를 써야한다 frontLanguage, backLanguage | . | 추상화도 layer(단계)가 있다. 변수간 서로 단계에 맞게 추상화를 해줘야한다. library는 front만 가지고 있음에도, language와 추상화단계를 맞춰주기 위해 library -&gt; frontlibrary로 변수명을 변경하였다. | . | server는 backend만 가지고 있지만, 추상화단계를 맞춰줘야한다? backendServer? -&gt; (가만히 두어도 추상화단계가 맞아서?? )중립적인 이름이라서 그대로 남겨두었다. 망설인 것이다. (frontServer라는 것이 존재했더라면 변경해줬을 것이다.) | 위에서 보는 것처럼, ADT의 통합시 사람이 손으로 이름충돌을 다 계산해서 변수명 재설정해줘야하는데, 문제는 상태 추가가 시간순으로 일어나므로 -&gt; 매번 통합해줘야한다 -&gt; 평소에도 이름을 나쁜이름으로 방어적으로 짓고 있게 된다 농담이 아니라 SI회사들 중에 변수명을 20자이내로 못짓게 하는 회사들이 진짜 많다고 한다. 형 추가하여 뿔려나가는게 아니라 고도추상화로 ADT 한곳에 때려박다가, 새롭게 추가된 것은 변수충돌을 일으키므로.. | . | 현재 ADT로 하나로 통합된 Programmer는 boolean flag를 통해 프or백인지 알 수 있게 된다. | . . makeProgram은 이제 코드수준(쉬운편)의 결합을 해야한다. 상태에 따라 프론트코드 or 프론트엔드 아닌거(백엔드)코드만 가져오면 된다. | if를 통해 하나의 함수로 모여들게 됨 -&gt; 지식의 통합 -&gt; class마다 분산되어있던 지식 2개가 -&gt; 1개 노하우로 통합되어, ADT주장하는 사람들이 지식통합으로 착각하는 경우가 많다. | . | paper를 받아와서 프론트의 language+library를 정하거나 or 백엔드의 server+language를 정해야하는데, ADT기 때문에 paper에서 뿌러나는 형의 다형성을 쓸 수 없음 -&gt; 같은 context를 가질 수 밖에 없음상태이다. 프로그래머가 이미 ADT다. paper도 ADT다. ADT의 2번째 문제점은 형을 결합할 수 없다.는 것이다. OOP에서는 나=다형성 쓴다 -&gt; 받아온 paper도 다형성을 쓰려고 한다. | 하지만, ADT는 상태를 내부에 감춤 -&gt; 바깥에서 볼 수 없으니 내 상태를 이용한 분기만 사용가능하다 -&gt; 들어오는 paper가 뭐든 간에, 내 상태=프론트엔드 이므로 -&gt; 프론트엔드 분기로서 paper에게 그에 맞춰서 기능을 제공해주도록 기능 추가 의도하게 된다. | 즉, ADT에서는 외부의 paper에 대해 if paper == client 인지알 수 없다. 내부에서 감추고 paper스스로만 알고 있기 때문에 외부에서 paper만 받아서는 client인지/severclient인지 확인 불가능 -&gt; 니가 누군지는 모르겠지만, 추상화된 paper니까.. 나에게 맞춰서 front내용(frontlanguage + frontlibrary)을 전달해줘 | OOP는 다형성을 쓸 수 있다. = paper를 받으면 누군지 알고 있다. | . | . | 프로그래머의 내부if분기 -&gt; 상태(프or백)에 따라 사용되는 paper의 메서드가 나눠져버린다. ADT그림을 보면, 분기에 따라 한 메서드가 다르게 구현되도록 통합적이 메서드 구조가 되었다고 했는데 | 여기서보니.. paper는 client일때랑 serverclient일때랑 서로 다른 메세드를 부르게 된다. | 그럼에도 불구하고 paper는 구분이 외부에서 안되니… 통합처럼 부를 수 밖에 없다. | ADT에 의해 만들어진 paper의 메서드들 -&gt; 내부적으로 더 심각한 문제에 당면하게 됨.. if가 중첩될수록 ADT에서는 중첩을 더 만들어낸다. | . | . | . | . . flag변수를 도입 -&gt; ADT가 되어 내부 상태를 관리한다는 것은 내부에서 if를 더 만들어낸다. | 또한, 외부에서 상태를 판단못하는 다른 ADT paper에 대해서 내부 if에 의해 메서드 확장도 만들어낸다. | . | 이 때, ADT를 만든 사람은 &quot;걱정마. ADT는 기능확장은 잘돼&quot;라고 이야기를 한다. . . 위와 같이 만들어준다. ADT는 정해진 3개 상태에 있어서, 상태확장이 아니라 기능확장은 껌이라고 하면서 위와 같은 코드를 만들어준다. 다시, client인지/아닌지에 따라서 -&gt; frontlanguage를 주는 방법이 달라지고, library는 null을 반환하기도 -&gt; context가 달라짐. 그림상으로 다 ADT는 내부if 분기별 다 커버하는 함수(세로방향)를 만들어낸다고 했는데, null반환하는 순간 커 버 못하는 것이 되어버린다. 전용함수 | . | . | ADT는 자동으로 그림과 같은 함수를 만들 수 없게 될 수 밖은 구조이므로 형(3개 상태)이 확정되고, 프로세서가 확정되어도 ADT는 쓰면 안된다!! | . | . | ADT판단 방법: 내부if분기에 따라 다른 context가 다르다. . | ex&gt; 한쪽 분기에서는 null을 return한다. . | ADT회피 방법: 차근차근 만들어가면서 연산부터 -&gt; 구상체(형)을 뿔려나가는 식으로 …? | . Director . 기존 Director . . ADT버전 Director . . 더 무서운 점은, Director코드가 많이 달라지지 않고, 이상해보이지 않는 다는 것이다. paper의 형에 따라서 여러 장치들을 걸고 있다. | Director에서 접근하려면 누가 뭐래도 paper의 내장을 까는 수 밖에 없다. paper의 타입(c/s)모르고서는 director의 분기를 할 수 가 없다. | ADT의 상태를 외부에다가 내장을 까지 않는 이상, 분기조차 안되게 된다. 프로그래머가 정의했던 setXXX를… 더이상 paper가 가져갈 수 없으므로 | paper는 get시리즈만 가능. set시리즈는 못가져간다. Director가 하는게 setXXX이므로 | . | . | ADT는 기껏해야 내부상태를 은닉할 수 있는게 get밖에 안된다. set자체는 디렉터가 해야하는 일이다. 디렉터의 존재의미니까 paper를 옮길 수 없다. -&gt; paper의 내장(상태 = isClient를 외부 메서드로 제공)을 까서 분기를 시킬 수 밖에 없다 | . | . | ADT의 결말: adt를 활용한 context(Direct의 context)에서 작동할 때, setter를 만들면, ADT의 내장이 다 까지게 된다. . | ADT의 폐단 캡슐화 및 은닉화 다 깨먹게 됨(ADT를 이용하는 형에서 setter를 쓸 때?) | 분기별 context가 일치하지 않는 getter를 양산 | 결과적으로 본인의 상태를 추상화하는데 실패함. | . | .",
            "url": "blog.chojaeseong.com/object/2022/05/21/(object1-13)%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98%EC%84%B8%EA%B3%843_ADT.html",
            "relUrl": "/object/2022/05/21/(object1-13)%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98%EC%84%B8%EA%B3%843_ADT.html",
            "date": " • May 21, 2022"
        }
        
    
  
    
        ,"post60": {
            "title": "의연방11) 메타분석1(SR, PICOS)",
            "content": "&#54617;&#49845;&#47785;&#54364; . 체계적 문헌고찰의 정의에 대해 설명할 수 있다. . 체계적 문헌고찰의 단계를 이해할 수 있다. . 메타분석의 정의에 대해 설명할 수 있다. . &#51452;&#50836;&#50857;&#50612; . 체계적 문헌 고찰 : 특정 연구 질문에 답하기 위해 사전에 정해진 선정기준에 맞는 모든 근거를 수집하여 분석하는 연구방법 . | 메타분석 : 체계적 문헌 고찰 수행과정에서 2개 이상의 개별 연구의 요약 통계량을 합성함으로써 해당 중재법의 통합된 가중평균 요약 통계량을 정량적으로 산출하여 임상적 효과성을 평가하기 위해 사용되는 통계적 기법 . | 비뚤림(bias) 위험 : 비뚤림은 체계적 오류이며, 비뚤림 위험은 비뚤림이 발생할 위험 정도를 말한다. . | . &#47785;&#52264; . 체계적 문헌고찰 소개 | 체계적 문헌고찰 과정 | 메타분석 소개 | &#52404;&#44228;&#51201; &#47928;&#54732;&#44256;&#52272; &#49548;&#44060; . 메타분석의 목적 | 의학적 방법론은 evidence로 결정되는데, 가장 높은 부분이 체계적 문헌고찰이다. | 하나의 방법이 아닌, 여러 방법을 통합해서 전반적인 치료효과에 대한 evidence를 연구 | . &#52404;&#44228;&#51201; &#47928;&#54732;&#44256;&#52272; &#55120;&#47492;&#46020; . 무슨 목적으로 시작했냐?의 질문으로 프로토코(연구계획서)를 작성한 뒤 | 여러 문헌들 검색 -&gt; 주 데이터로 자료 추출 -&gt; 질 평가 및 통계분석(메타분석) | 메타분석은 쳬문고의 한 방법으로서, 시행 못할 수 도 있다. 통계 분석이다보니, 어느정도 데이터가 나와야 함. | 문헌은 고찰됬는데 자료추출이 안될 수도 있음. | . | . &#52404;&#44228;&#51201; &#47928;&#54732;&#44256;&#52272; &#44284;&#51221; . PICO&#51032; &#49444;&#51221; . 관심있는 주제를 gogole, pubmed 검색으로 나오는 문헌으로 자료로 데이터 x -&gt; 미리 사전에 계획한 프로토콜을 만들어야한다. | PICO를 설정하고, 검색어도 결정된다. . | P: patient(환자군) or target population(관심집단의 모집단) . | I: evidence를 보이고자하는 중재법 or 치료법 or (위험요소)노출 | C: 위약군(plaebo) or 활성대조군(현재 표준치료 등) (이 있어야 intervention의 효과가 극명하게 나타남) | O: 확인하고자하는 결과치, 1개 이상이 될 수 있음. | S: study design 피라미드에서 문헌고찰이 top인 상황은, 모두 RCT를 바탕으로 한 문허고찰일 경우를 말함. | 어떤 연구들은 RCT불가 -&gt; 어느 범위까지 study design을 넓힐 것인지도 포함시킴 | . | . PICO예시 살펴보기 BMJ(high Impact)에 실린 논문 | 정말 아침밥 먹는 것이 체중조절 or 에너지 섭취에 도움이 되냐? | . | . P : People living in high income countries 선진국 인구 | 후진국일 경우, 식사에 대한 여러 confounder issue들이 존재할 것임. | 치료가 아니니 일반인들 대상으로 P를 잡음. | . | I : Breakfast eaters 아침식사 함 | . | C : Breakfast skippers 아침식사 안함. | . | O : Weight loss (kg), Energy intake (kJ) outcome이 2개임 | . | S : Randomized controlled trial RCT로만 국한함. | . | . PICO + S를 결정해놔야 주제어라 든지 등이 만들어진다. | . &#47928;&#54732;&#44160;&#49353; . 앞의 PICO 설정에 의해 주제어가 나온 상태다. | 제일 쉽게는 구글이나 펍메드를 생각할 수 있으나 COSI 모델안에서 검색을 한다. | COre에서 검색을 가장 추천한다. MED LINE(pubmed 관련) | EM BASE | Cochrance CENTRAL | 최근에는 구글스칼라도 추가된다. | 경우에 따라서는 주제에 특화된 검색엔진을 쓰기도 한다. | . | . MEDLINE은 미국의학도서관 base / EMBASE는 유럽 base . 2 엔진에 다 검색하는 것을 추천한다. | 하나만 선택하면 selection bias가 있을 수 있기 때문에 2가지 검색엔진은 무조건 하기를 권장함. 중복 안되는 비율 30%이상 된다고 알려짐 | . | . | Mesh와 EMTREE라는 term을 서로 다르게 사용하기 때문에, 도서관 사서분들에게 부탁해도 된다고 한다. . | . 주먹구구 검색이 아니라 철저한 계획아래 PICO 설정 -&gt; 주제어로 검색했따는 증거를 Search strategy로 appendix에 제출한다. | . &#47928;&#54732; &#49440;&#53469; . 임상연구의 첫번째 figure가 환자flow chart처럼, 문헌고찰에서도 flow chart를 먼저 그리는데, 그것을 PRISMA flow diagram이라고 한다. . 아래는 2009년 버전 | . 최소 2개이상의 검색엔진에서 검색 | 중복 제거해서 남는 것 | 제목과 초록만으로 1차 배제 | 원문 확인후 2차 배제 | 체계적 문헌고찰에 사용된 연구 수 | 데이터 이용가능한 연구 수 | | 예시 논문(prisma flow diagram 2019) . pubmed만 포함되고 embase는 검색안했다. 영양쪽 검색해서 3개 검색엔진 사용했다. | 604개 논문 시작 | 제목과 초록으로 552개(90% 이상) 날라감 | 프로토콜에서 제시한 Exclusion criteria를 적용했떠니 39개 날아감 | 체계적 문헌고찰용 13개 | 메타분석용 12개 (아마 1개는 데이터이용 불가였을 것) | . | Prisma flow diagram 2020 버전 업데이트 . 기존에 나온 체계적 문헌고찰 포함 가능 | publishing안된 다른 method의 연구도 포함 가능 | R패키지와 사이트가 생김 | . | . &#51088;&#47308; &#52628;&#52636; . 자료추출 시 고려할 수 있는 항목들 (Cochrane handbook, 2011) . | 예시 논문에서 13개의 논문을 추출했는데 . Results에 있는 메타 분석 뿐만 아니라 | 앞 단의 모든 내용들도 추출해야한다. . 2번째 figure에 선정한 논문들의 characteristic을 싣어야하기 때문 | 어떤 스터디디자인, rct method, 대상자 몇명, 평균 나이-성비 등, 인터벤션의 종류(ex&gt; 약재 종류, 같은 약재라도 용량, 용법), outcome 정의 및 내용 등 | . | 예시 논문에서 제시한 13편 논문의 characteristics를 table2로 제시 . 환자수, 평균나이, 인터벤션 정의, 컨트롤 정의, outcome 정의 및 어떤 것을 측정, duration 등 제시 | . | . | 메타 분석에 들어가는 13개 중 10개 논문에서 뽑아낸 weight loss raw data . 2군에 들어가는 환자 수 / outcome(weight loss or enery intake)의 평균과 표준편차 | . | 만약, 데이터 추출이 2~3개 논문에서 밖에 불가능하다? 연구자가 메타분석을 할 것인지 고민해야한다. 질적 합성만 하기도 한다. | . | . &#47928;&#54732;&#51032; &#48708;&#46756;&#47548;(bias) &#50948;&#54744; &#54217;&#44032; . 자료 추출후 바로 메타분석을 해도 되지만, 그 전에 수행해야할 것이 문헌의 비뚤림 위험 평가이다. . 자료 추출시 같이 평가하면 된다. | . | 일반 임상연구에서는 하지 않지만, 체계적 문헌고찰에서는 반드시 시행해야한다. . 문헌에 발표된 데이터들을 믿어야할까? | 의심되는 bias, confounder 평가를 해줘야한다. | RCT는 잘 수행되었지만, randomization이나 outcome평가가 잘되었는지 등을 평가해야한다. | . | . 문헌검색 및 선정과정을 통해 포함가능성이 확인된 연구에 대하여 비뚤림 위험 평가가 수행되어야 함. . 선정기준 적합 여부 PICO 중 P: target population이 정한 것과 맞는 것인지 | . | 보고된 내용의 적합 여부 | 수행된 연구의 질 | 선정된 연구로부터 추출하게 될 정보에 따르는 bias의 정도 등 | | 비뚤림 위험 평가 도구 ▪ RCT : Cochrane group(체계적 문헌고찰 연구 그룹)‘s Risk of bias도구 사용하기 ▪ 비무작위 연구(관찰 연구 등): Risk of Bias Assessment tool for Non-randomized Study (RoBANS) . | . Cochrane : Risk of bias 도구 RCT를 잘 수행했는지 평가하는 도구: 핵심은 무작위 배정이니.. 평가 bmj논문 예시 한눈에 잘 안보이니 그래프로 나타낸다. | . | 결과적으로는 3번째 항목(블라인드 유지가 되었는지) 이 논문에서 intervention과 control은 아침밥을 먹냐/안먹냐인데, 다 blinding하는 것이 말이 안되므로 다 open trial이었을 것 -&gt; 다 빨간색 high risk로 표기된다. | 여기서 중요한 것은 data 및 평가 부분이지만, 다 초록색은 아니다. 그러나 Other bias부분이 100% low risk라서 risk of bias를 잘 평가했다고 볼 수 있다. | . | . | . | . &#47700;&#53440;&#48516;&#49437;(Meta Analysis) . 정량적 합성 (Quantitative synthesis) vs 정성적 합성 (Qualitative synthesis) 데이터 추출이 가능한 문헌 수가 몇개인지 | 질 평가했더니 너무 risk of bias 높았는지 | . | 정량적 합성의 특성 -&gt; 3개의 목적을 가진다. 효과의 방향은 어떠한가? 아침식사 하는 게 좋은 것인지? 안하는게 좋은지? | . | 효과의 크기는 어떠한가? 크게 좋은지, moderate하게만 좋은지? | . | 효과가 연구들 사이에 일관성이 있는가? 결과가 일관성이 있는지? | . | 3개의 목적을 종합적으로 제시해주는 것이 메타분석 | . | 체계적 문헌고찰 결과 최종 선정된 연구들을 대상으로 정량적 근거 합성을 하고자 할 때 메타분석을 실시함. 전통적 메타분석 | 베이지안 메타분석 기존의 정보를 추가해서 | . | 네트워크 메타분석 (간접비교 및 혼합비교) 이미 많은 연구들이 많이 수행된 상태라서, 새로운 메서드 적용 | . | | . &#47700;&#53440;&#48516;&#49437;(&#51204;&#53685;&#51201;) . 전통적 메타분석의 원리 문헌 검색( raw data -&gt; 효과 측정) raw data는 거의 볼 수 없다. | . | 측정된 효과들을 통합한 효과 추정 | | . &#47700;&#53440;&#48516;&#49437;&#51060;&#46976;? . 기존 연구에서 발견된 결과들의 통합을 목적으로 가지고 일련의 개별 연구들로부터 수립된 다양한 연구 결과들을 통계적으로 분석하는 방법 “분석의 분석(analysis of analysis)” | . | 두 개 이상의 연구자료 결과를 결합함 2개 가지고 가능하지만 추천X, 적어도 10개 이상 데이터 추출 가능하는 것이 좋음. | . | ‘평균’ 혹은 ‘공통 (common)’(통합된) 효과를 추정함 | 체계적 문헌고찰의 부가적 요소 안하고 그냥 문헌고찰 후 case report처럼 보고만 하고 문헌고찰을 끝낼 수 도 있다. | . | . &#50780; &#47700;&#53440;&#48516;&#49437;&#51012; &#54616;&#45716;&#44032;? . 치료 효과 및 효과의 불확실성을 정량적으로 측정 논문마다 값마다 조금씩 다 다른데, 그것을 통합하여 정량적 측정 | . | 검정력 증가 여러 연구가 통합되면 표본수 증가되어 검정력이 향상됨 각 스터디들은 positive result로 가긴 하지만, 환자수가 작아서 통계적 유의성이 없을 수 있음. | . | . | 정밀성 향상 중재법에 대한 효과추정치에 보다 많은 정보가 있을 경우 정밀도가 향상 될 수 있음. | . | 연구자료 간 차이점 탐색 | 연구자료들 간 상반된 결과에 대한 논란을 해결 종합적 결과에 대해서는 논란이 없어짐 | . | 새로운 가설 제기 생각치 못한 결과로 나왔을 때 | . | . &#47700;&#53440;&#48516;&#49437;&#51012; &#54616;&#47732; &#50504;&#46104;&#45716; &#44221;&#50864; (1) . 데이터만 추출되었다고 시행할 순 없는데... | 사과와 오렌지의 혼합(사과는 사과끼리만) 선정된 각 연구자료는 동일한 연구질문을 다루어야 함(비슷하다고 포함X) 군 간 대조, 결과평가를 고려 | 체계적 문헌고찰 저자들의 주관적 판단 필요함 | . | 광범위한 종류의 연구자료들이 결합되면, 광범위한 연구질문에 대한 대답을 얻게 됨 | 연구자료들의 성격이 지나치게 폭넓을 경우, 분석결과의 의미가 없어지거나 참 효과값 (true effects)이 불명확해질 수 있음 | . | . &#47700;&#53440;&#48516;&#49437;&#51012; &#54616;&#47732; &#50504;&#46104;&#45716; &#44221;&#50864; (2) . 연구자료의 비뚤림(bias)이 너무 심하면, 메타분석 결과를 신뢰할 수 없게 됨 (garbage in – garbage out) 질 평가를 했을 때, risk가 다 높으면 하면 안된다. | 메타분석 결과는 분석에 포함된 연구자료에 좌우됨. | 연구자료의 bias 위험이 높다면, 메타분석 결과 역시 부정확함. | 특히 심각한 reporting bias (특히 publication bias)가 있다면: 전체 연구결과를 대표하지 못하는, 일부 연구자료들만의 조합으로 인해 결과가 오도될 수 있음 | . | . | . &#47700;&#53440;&#48516;&#49437;&#51012; &#49688;&#54665;&#54624; &#49688; &#51080;&#45716; &#44221;&#50864; . 2개 이상 문헌에서 효과 측정이 이루어졌을 때 | 의미 있고 유용한 결과가 도출될 만큼, 문헌들이 충분히 유사할 때 | 결과 측정이 유사한 방식으로 이루어졌을 때 | 분석 가능한 형태의 자료를 추출할 수 있을 때 Sufficient number of studies (≥10) | 경험에 의하면 5개 이상이면 할만은 하다. 그 이하는 메타분석 없이 문헌고찰만 | . | . &#50672;&#49845;&#47928;&#51228; . 01 &#45796;&#51020; &#51473; &#52404;&#44228;&#51201; &#47928;&#54732;&#44256;&#52272;&#51032; &#45236;&#50857;&#51004;&#47196; &#47582;&#45716; &#44163;&#51008;? . 명백하게 구조화된 질문을 가진 종설로, 체계적이고 엄격한 방법에 따라 관련된 연구를 모두 찾고 선택하여 연구에 포함된 자료를 수집분석하는 연구방법이다. . | 메타분석은 체계적 문헌고찰 과정에 반드시 포함된다. . | 진단검사의 정확성에 대한 체계적 문헌고찰은 수행할 수 없다. . | 무작위배정 임상시험으로 수행된 문헌들로만 수행할 수 있다. . | 정답:1 | 해설 : 메타분석은 체계적 문헌고찰 과정의 필수요소는 아니며, 진단검사의 정확성에 대한 체계적 문헌고찰도 수행가능하다. 또한 관찰연구도 포함할 수 있다. | . 02. &#45796;&#51020; &#51473; research question&#51012; &#51221;&#54616;&#44592; &#50948;&#54620; PICO &#51221;&#51032;&#50640; &#47582;&#51648; &#50506;&#45716; &#44163;&#51008;? . P : 연구하고자 하는 질환이나 대상자 . | I : 연구하고자 하는 중재법 또는 노출(exposure) . | C : 체계적 문헌고찰에 포함할 연구설계 . | O : 관심 질문을 통해 확인하고자 하는 결과 . | 정답: 3 | 해설: C는 위약(placebo) 또는 활성 대조군(active control)과 같은 비교군을 말한다 | . 03 &#47928;&#54732;&#44160;&#49353; &#48143; &#49440;&#51221;&#44284;&#51221;&#51012; &#53685;&#54644; &#54252;&#54632;&#44032;&#45733;&#49457;&#51060; &#54869;&#51064;&#46108; &#50672;&#44396;&#50640; &#45824;&#54616;&#50668; &#48708;&#46756;&#47548; &#50948;&#54744; &#54217;&#44032;&#44032; &#49688;&#54665;&#46104;&#50612;&#50556; &#54620;&#45796;. &#51060;&#46412; &#47924;&#51089;&#50948;&#48176;&#51221; &#50672;&#44396;&#50640; &#45824;&#54620; &#48708;&#46756;&#47548; &#50948;&#54744; &#54217;&#44032; &#46020;&#44396; &#51473; Cochrane group&#50640;&#49436; &#44060;&#48156;&#54620; &#44163;&#51008; &#47924;&#50631;&#51064;&#44032;? . Scottish Intercollegiate Guideline Network (SIGN) . | Risk of bias (RoB) . | Jadad scale . | van Tulder scale . | 정답: 2 | 해설: Risk of bias (RoB) 도구는 무작위배정 연구의 근거문헌의 평가를 위하여 6개 영역 즉, 순서 생성, 배정 은닉, 눈가림, 불완전한 결과변수, 선택적 결과보고, 그리고 타당도를 위협하는 기타 잠재적 편견으로 구분하여 평가하기 위해 Cochrane group에서 개발하였다. | . &#51221;&#47532;&#54616;&#44592; . 체계적 문헌 고찰은 특정 연구 질문에 답하기 위해 사전에 정해진 선정기준에 맞는 모든 거를 수집하여 분석하는 연구방법이다. . | 체계적 문헌 고찰은 일반적으로 연구기획과 프로토콜 개발, 체계적 문헌고찰 수행, 보고서 성, 개정(update)의 과정을 거친다. . | 프로토콜의 연구방법에는 PICO를 포함한 포함/배제기준, 문헌검색 전략, 문헌 선택, 문헌 분류, 비뚤림 위험 평가 방법, 자료추출 및 분석방법, 근거수준 평가를 포함할 수 있다. . | 체계적 문헌고찰에서 정성적 합성(qualitative synthesis) 방법과 정량적 합성(quantitative synthesis) 방법 등의 자료분석방법이 있으며, 이 중 정량적 합성을 메타분석이라고 한다. . | 메타분석은 체계적 문헌 고찰 수행과정에서 2개 이상의 개별 연구의 요약 통계량을 합성함으로써 해당 중재법의 통합된 가중평균 요약 통계량을 정량적으로 산출하여 임상적 효과성을 평가하기 위해 사용되는 통계적 기법이다. . | .",
            "url": "blog.chojaeseong.com/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EB%A9%94%ED%83%80%EB%B6%84%EC%84%9D/metaanalysis/sr/picos/2022/05/20/%EC%9D%98%EC%97%B0%EB%B0%A911)-%EB%A9%94%ED%83%80%EB%B6%84%EC%84%9D-(PICO-%EB%93%B1-%EC%B2%B4%EA%B3%84%EC%A0%81-%EB%AC%B8%ED%97%8C%EA%B3%A0%EC%B0%B0).html",
            "relUrl": "/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EB%A9%94%ED%83%80%EB%B6%84%EC%84%9D/metaanalysis/sr/picos/2022/05/20/%EC%9D%98%EC%97%B0%EB%B0%A911)-%EB%A9%94%ED%83%80%EB%B6%84%EC%84%9D-(PICO-%EB%93%B1-%EC%B2%B4%EA%B3%84%EC%A0%81-%EB%AC%B8%ED%97%8C%EA%B3%A0%EC%B0%B0).html",
            "date": " • May 20, 2022"
        }
        
    
  
    
        ,"post61": {
            "title": "OBJECT 12 도메인분해 3가지 방법(코드스핏츠)",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . ch12. 3가지 도메인 분해 방법 . 오브젝트 책 7장 (다음엔 9장~10장) | 코드스피츠 84에서 나머지를 나갈 수 있다. 조영호님의 오브젝트 책 쓰면서 고생한 것은 통신사 요금 부분 | . | . 분해의 개념 . 모으거나 합체, 조립에 대한 영어단어는 많다. assembly, composition, … 책에서 프로그래밍을 조립하는 것은 composition이라고 많이 부른다. 컴포지션: 하나하나 의미가 있는 부속들 -&gt; 모아서 하나의 결과물로 만드는 것 | 어쎔블: 의미없는 부속들 -&gt; 정확히 모아야 의미있는 1개의 결과물이 됨. | . | 완성된 소프트웨어는 어쎔블?? 컴포지션?? 어쎔블 상태로 만들어졌다? -&gt; 빼거나 더하면 망가진다. like 레고 | 컴포지션 상태로 만들어졌다? -&gt; 하나 고장나면 다른 것으로 끼워넣으면 된다. | 소프트웨어가 컴포지션 화 되었다 -&gt; 모듈화/격리가 잘 되어있다.는 뜻 | . | . | 분해 -&gt; 책에서는 디컴포지션 -&gt; 소프트웨어 만들 때, 컴포지션화 한 사람들에게만 쓸 수 있음. 소프트웨어에서의 디 컴포지션 -&gt; XXX(도메인)를 모듈화/격리 -&gt; 결국 컴포지션된 소프트웨어로 만들기 | 현실 세계의 복잡한 상황인 도메인 -&gt; 디 컴포지션 (각개격파) 하여 컴포지트를 만듬 -&gt; 컴포지션 -&gt; 소프트웨어 | 우리의 목표: 도메인을 어떻게 디 컴포지션 할 것인가 for 컴포지션화된 소프트웨어를 만들기 위해 | . | 대부분의 도메인은, 사람의 하는 일이라, 감성적+충동적+비이성적으로 일어나서, 도메인이 엉망진창으로 결합되어있다 . if가 30개씩 나와있다. 왜? 시대 순으로 만들어졌기 때문 android core API 뒤에는 숫자가 붙어있다 -&gt; 0 1.. 시대순으로 아닌 것 같은 것을 버릴 수 없으니 엉망진창으로 결합하고 숫자를 붙여놨다. | java에서는 decrecate된 것이 많다. 엉망진창으로 되어있어서 | . | 사람이 만드는 도메인은 시간 순으로 만들어지기 때문에, 절대로 예쁘게 컴포지션 되어있지 않다. 비 논리적으로 결합되어있다. | . | 우리는 어떻게 비논리적인 도메인의 디컴포지션을 -&gt; 논리적으로 컴포지션(분해) 할 수 있을까 . 분해를 꼭 해야할까? -&gt; 모델링하려면 분해후 일부만 추출해야 할 수있다. | 분해를 안하면, 복잡성 폭팔(책에서는 인지과부하)가 되어 사람은 이해(감당)할 수 없다고 한다. 일반적으로는 if가 2단계(중첩if 3단계-if안에 A and B and C도)의 를 넘어서면 무조건 복잡성 폭팔이 생긴다. | for안에 if도 감당 X -&gt; for 자체가 if기 때문에 감당할 수 있으려면, 기계가 되어, 진입표 -&gt; 상황별 모든 상태의 조합수를 표를 그려서 코딩으로 옮기는 방법 밖에… | . | . | if문 경우의 수만큼 쪼개서 다르게 만드는 것이 분해의 시작 그렇지 않으면 복잡성이 폭팔한다. | . | . | . Functional decomposition . . 기능(시작과 끝이 있는 flow)적으로 분해한다. (수학적)함수적으로 분해한다라고도 해석해도 된다. | 기능 = 액션 = behavior = 행위 = 어떤 알고리즘 수행 명령단위로 수행할 수 있다. = a -&gt; b까지 실행 후 c-&gt; d까지 수행할 수 있다. = 수행 업무는 시작과 끝이 있는 하나의 flow로 바라볼 수 있기 때문에 쪼갤 수 있다고 생각했다. 우리는 도메인을 로 나눌 수 있을까? 핸드폰 개통해야한다 -&gt; 우리는 flow를 떠올린다. -&gt; 매장 가기 -&gt; 상담 -&gt; 가입신청서 -&gt; 절차 -&gt; 핸드폰 개통의 flow : 중간에 빠꾸 맞으면 돌아가는 과정도 있음. | . | 데이팅앱: 복잡한 연애절차를 우리 앱을 통해 flow로 해결할 수 있다 라고 생각한다. | 메뉴결정앱: 복잡한 점심메뉴 고르기 -&gt; 단계별로 flow로 결정함. | . | flow를 흐름도를 그리지 않아도 flow다 ex&gt; todo list(적고 해결한 순대로 체크) 쪼갤 수 있는게 중요함. | 할일을 쪼갤 땐, 어떻게 쪼갰나? functional하게 = 시작과 끝이 있는 flow형식으로 쪼갰을 것이다. | . | 문제점: 인간이 학습하기 때문에 변화가 일어난다 -&gt; flow는 변화에 취약하다. | . | Flow Chart 기법 . . 우리는 어떤 행위를 처리할 때, flow로 처리한다. | . . flow는 가만히 있을리 없다, 주황색 상태를 같이 처리한다. flow란 상태를 처리하기 위핸 flow다 | . . 다음flow에서도 해당 상태를 처리하려고 할 것이다. 첫번째 flow가 상태의 initialize였다면, 두번재flow는 네트워크 동기화 등 | . | . . 여기서, 주황색 상태를 처리하려면, 애초에 (하늘색)다른 상태도 있어야함을 깨닮는다. . 처리해야할(주황색), 필요한 상태(하늘색)의 데이터들은 flow바깥의 전역변수들이다. . | 책으로 비유하면, 주황색=직원에 대한 데이터만 있으면 될 줄 알았더니, 직원들의 세금을 계산하다보니, 하늘색=시간제근무제를 분리할 수 있는 데이터가 추가로 필요하다. . | 추가로 필요한 데이터는 여기 뿐만 아니라 처음부터 존재해야함(전역변수는 첨부터)을 깨닮는다. . . 이 때, 처음flow는 주황색만 있다고 가정하고 짠 flow기 때문에, 전역데이터 하늘색이 등장한 순간 오염된 flow다. -&gt; 해당 로직은 새로 만들어야한다. | . | . | . . flow를 새로 만들다보니, 해당 flow에서는 분기 flow가 생겼다 . | 살펴보니, 초록색에 따라서 주황색만 처리하거나 하늘색만 처리해야하는 분기라는 것을 알게 되었다. . . 특정조건 초록색은 분기처리에만 사용되고, 다른데서는 사용 안되기 때문에 -&gt; 절차적 변수(상태) 격리 기법인 변수의 유효범위(scopre)를 정할 수 있다. . 지역변수로 선언하거나 or 인자를 함수로 격리 or 중괄호를 통한 block scope를 주는 방식으로 변수(상태)를 격리 by scope . . | . | 절차적인 flow에서 변수(상태) 격리 방법은 scope밖에 없다는 뜻이 된다. . | . | scope에 의한, 격리된 변수(상태)를 추가하는 경우에는 기존 flow들을 수정할 필요 없게 된다. . | flow 시스템에서 우리가 변수(상태)로 인한 회귀테스트를 피하는 유일한 방법은 scope밖에 없게 된다. . 되도록이면 scope를 짧게, 라이프싸이클을 빨리 끝내도록 코드 작성하는 조언을 많이 들었을 것이다. 왜? 유일한 수단이다. | 우리가 초록색(변수, 상태)를 도입했을 때, 이전 코드들을 건들이지 않아도 되는 유일한 수단, 쓸 수 있는 방법이 하나밖인 scope지정이다. | . | . . 최종적으로 마무리 flow를 한다. | . 하지만 맨 마지막에 빨간색(변수, 상태)가 필요하다는 것을 깨닳는다. 사람이란 그런 것. 시간순으로 학습해서 발견 . 빨간색이 필요하다면, 첨부터 가지고 있어야할 것이다. | . . 모든 flow가 오염되고 맨날 밤을 센다. | . . 사람이기 때문에 어쩔 수가 없다. 맨 늦게 깨닮는다. | 회귀테스트를 다 만들어놓고 하기 때문에 팀의 분위기가 안좋아진다. 처음부터 파란색, 빨간색을 알았다면… 불타지 않았을 것 | 처음부터 알려면, 내가 마틴 파울러이나 퀜트 백이 되는 수밖에 없는데… 그런데 이런 사람이 있으면, 어떻게든 돌아가는 프로그램을 만들어버리니.. 독이 될 수가 있다. | . | . | . | 마틴옹이나 퀜트백이 아니라면, flow로 디컴포지션하여 프로그램을 짜면 안된다. 잘못된 것라고 확정적으로 말할 수 있다. . 우리는 이렇게 짤 수 없다. | 무조건 상태(변수)가 새롭게 나타난다. 무조건 오염되어 회귀테스트가 생긴다 | . | 나머지 개발론이 안먹히는 사람이다. 혼자서 다 만든다. 코드양이 적어서 혼자서 만들긴 다 만든다. | . | 복잡한 도메인에서는 불가한 방법 고인물인 게임이나 쇼핑물에선 가능하다. | . | 이직시 고려해야한다. 10년간 회계시스템, 오피스를 짠 회사 -&gt; 도메인 파악이 너무 확실함. | 어떤 새로운 구조도 도입안할려고 함 이렇게 짜는게 가장 짧고 회사에 돈을 많이 벌게 해주니까 | . | . | . | . ADT(Abstract Data Type) . 추상 데이터 타입부터는 데이터를 기준으로 세상을 바라보기 시작한다. flow(절차적, 기능적 디컴포지션)은 절차(뭐할지를 보고) -&gt; 절차에 필요한 데이터를 깨닮으면서 디컴포지션 -&gt; 마지막에 아차..하고 떠오르게 되어 -&gt; 회귀테스트 반복 절차지향 -&gt; 행위를 통해 데이터 추출 -&gt; 나중에 깨닮은 과정이 많아 -&gt; 앞의 과정의 무시된다. | . | . | LSP 치환원칙 언급 전까지, 객체지향이 제대로 발전하지 못한 시대였다. 지금 우리가 보기에는 잘못된 방식이지만, 당시에는 혁명적인 데이터기반 알고리즘 구현 논문이었다. | . | ADT . . 뭐할지(절차)부터 보고난 뒤 데이터가 아니라 데이터부터 먼저 바라보자고 한다. 시간제근무가 아니라 급여를 가지고 있는 직원들(데이터)를 먼저 바라본다면, -&gt; 그 뒤에 내가 해야할일들이 생겨난다. | . | . . 데이터 -&gt; 해야할일(샐러리, 택스 계산하기 등)들을 보고서 데이터에 맞춰서 함수를 만들어내면, 우리가 관찰이 가능하다. | . . 각 데이터에 따라 할일들이 만들어진다. 구조체(자료구조) -&gt; 그에 대한 함수들 | . | 여기서는 각 데이터마다의 함수 시리즈 —&gt; 방향이 중요한게 아니라 어느날 발견하게 되는 &lt;각 데이터마다 비슷한 기능을 하는 함수&gt;가 중요하다. | 즉, 각 데이터—&gt; 함수시리즈들을 놓고보니 하려는 일은 비슷한 데이터만 다른(↓ 방향)것의 공통점을 발견할 수 있다. 정규직, 시간제, 다른 형태고용자 ↓ 데이터들 모두 세금을 계산하는 것은 비슷하다 | . | 하지만, 데이터들은 다른 것들이기 때문에, 약간의 차이는 있을 뿐이다. | 따라서, 데이터모양의 차이점만 있고, 개별 flow가 아니라해야할 일(flow)의 공통점 인식해야한다. 데이터의 차이점 -&gt; if로 데이터를 나눌 뿐이지 flow는 추상화 단계에서 인식가능하다 | 예를 들어, if문만 있으면, 어떤 데이터(직원)을 넣어도 세금을 계산해주는 함수를 만들 수 있다. 내부에 if문만 넣어서 하늘색/주황색/빨간색으로 나눠주기만 하면 된다. | . | . . 리스코프는 데이터 -&gt; 함수시리즈를 나열하되, 들어오는 데이터가 다르면, 내부 if로 나눠주되, 중요한 것은 공통점으로 추상화이다. . | 데이터에 따라 세금을 계산하는데, 세금계산만 공통점이므로 이러한 함수에는 필연적으로 내부if문이 들어간다. . **[세금을 계산]** ↓ | **[월급을 계산]** ↓ 바깥에서는 [~을 계산] 공통점만 노출 | **내부에서는 ** | . | . | 내부에서 if로 차이점을 가진 데이터들을 먹어서 공통점 추상화가 가능해졌다. . . | 내부에서 if문/swtich문을 이용해서 서로 다른(차이점) 데이터를 먹으면 뭐가 좋을까? . . 서로 다른 데이터들임에도 불구 하고 모든 기능들이 모을 수 있어 응집성(-&gt;유지보수)이 증가하게 된다 코드 응집성의 증가로 관리가 편해진다. 각 직원(데이터마다) 세금계산 방법을 나눠서 함수를 만들면 유지보수가 어려움 | . | 단점: case(데이터)가 늘어나면 그만큼 추가해줘야한다 | 장점: 지식을 모아둘 수 있다. 지금도 선호하는 회사가 많다. 잘 구분도 안된다. ADT가 맞는지 확인도 쉽지가 않다. | . | . | 이제부터는 **외부에는 ADT를 `하나의 형`으로 노출하고 싶다** 하얀 네모를 통째로 하나의 형으로 부르고 싶다 | 네모의 메서드 중 1개 를 호출하면, 내부에 차이점을 먹은 형태기 때문에 외부에서는 이쁘게 나올 것이다. 각 변수(상태)들을 모두 수용가능하며, 외부에는 결과값만 던져주는 이쁜 형태이다. | . | 각 데이터별 특성을 안에 다 감춘 형태 고도 추상화가 된다. 외부에서는 아무런 지식없이 Employee만 인식하여 좋은 얘기 같아보인다. | 팀내에 ADT를 쓰는 사람들은 이렇게 설득한다. | . | . | 장점: 안에 등장 가능한 상태(변수) 모두를 내부if로 먹고 있어서 메소드 추가가 외부노출없이 안에서 가능 (case를 모두 알고 있음?!) . 해결메서드를 4번재 gray로 추가했는데, 내부에 이미 모든 상태(변수)들을 알고 있기 때문에 딱 알고 있는 갯수(3개)의 분기만 해주면, 메소드 추가가 가능하다. 확실하게 모든 분기를 알고 있으면, 메서드 추가가 쉽다. | . | . | . | . ADT를 깨는 로직 . ADT를 깨기는 쉽지 않다. 바깥에서 보면 고도로 추상화되어있다. | 내부 기능(메서드) 확장도 쉬워서 유연한 것처럼 보인다. | . | 메서드 추가는 쉬웠지만, 데이터 추가는 큰 문제를 발생시킨다. . . ADT는 데이터(상태) 추가에 쥐약이다. | . . 상태 하나 추가할 때마다, 모든 메서드가 if로 먹을 수 있게 분기하는 코드를 추가해야한다. 작업량이 엄청 늘어난다. | 클래스 내부 모든 메서드를 불태워야한다. | . | ADT를 주장하는 팀원을 이기는 방법은 = OOP를 선택하게 하려면 우리회사는 Employee의 다양한 고용형태를 수용해야한다. | 만약, 20년간 새로운 고용형태는 회사에 없었다고 말한다면 못이긴다. 책에서도 기능만 추가되고, 데이터는 변화가 없다면 ADT는 나쁘지 않는 선택이다.라고 얘기하고 있다. | my) OOP에서 자식이 늘어나지 않는다고 가정하면…? | . | . | . | 데이터 추가외에 공통이 아닌 메서드 d()의 문제도 못푼다. 즉, 특정 데이터(상태)의 전용메서드 추가가 어렵다. . 리스코프 치환원칙에서 d()메서드는, 하늘/주황/빨간(상태)의 분기에서는 작동안해야한다. -&gt; 초록색 외의 상태가 들어오면 임의의 예외값을 내어놓아야한다. -&gt; 특이해지는 상황 . if a if b … if d 의 context만 있다가 | if d (else) 예외값을 내어놓는 이질적인 context 바깥에서는 d or null이기 때문에, D객체로 볼수 있다고 봄. instanceof를 이용하여 디텍팅용으로 쓸 수 밖에 없다. | . | . | . | ADT가 성립하는 경우는 2가지를 만족해야한다. 상태(변수, 데이터)가 더이상 확장되지 않고 | 안에 소속된 메소드들이 모든 상태들에 대해 결과값을 가지는 메소드일 때만 | | 그럼에도 불구하고 ADT를 쓰는 회사가 있다? 전체 구성원이 d()의 경우를 미리 알고 있어서, 그거는 원래 그래 라고 할 경우, 굉장히 힘들어진다. | . | ADT는 굉장히 제한적이라고 할 수있다. . | 안타깝게도, 우리가 객체지향을 짤 때, 대부분 ADT로 코딩을 한다. 따라서 남이 유지보수할 때, ADT의 문제점에 봉착하게 된다. 우리는 이것을 legacy라고 부름. | 남들은 legacy로 안보는게 문제 | . | . | ADT를 알아야하는게 핵심이다. 알아야 ADT가 아닌 코드르 짤 수 있기 때문 my) ADT: 내부 if로 모든 상태를 분기로 먹어서, 서로 다른 데이터의 공통기능들도 모은 것. | . | . OOP . . ADT와는 완전히 다른 접근방식의 추상화이다. . 상태없이 미리 &lt;해야될 연산만 추상화&gt;해놓고 . | 추상화된 연산이 &lt;상속&gt;받는 무언가를 만드는 방식 . . | 뒤늦게 상속하는 이유는 바로 연산이 달라지는 &lt;서로 다른 상태&gt;에 따라 &lt;형을 새롭게 만들어 나가기&gt; 위해서 . | . | 따라서 객체지향은 상태마다 형을 늘려가는 구조다. . ADT는 내부if로 서로 다른 상태를 먹어서 하얀색 박스 안에 때려박은 형을 줄여가는 구조였다. | 객체지향을 사용하면, 상태에 따라 -&gt; 형이 늘어난다. | 게다가 상태에 따른 형을 통합하는 추상형이 먼저 정의되므로 +1로 엄청 늘어난다. | . | 연산 정의 -&gt; 상태에 따라 다른 연산을 가지는 형을 정의 -&gt; 구상형들이 많아진다. . 대표적인 것이 추상형이지만, 구상형이 주인공들이고 점점 늘려나가는 방식 | 인터페이스(추상형) 메소드를 호출하도록 코드를 짜면 -&gt; 레인지 바인딩되어있는 구상형의 메소드가 호출된다. | 레인지 바인딩을 이용해서 형을 늘려가는 OOP | . | ADT vs OOP 한눈에 보는 방법 . 형이 줄었다? ADT | 형이 늘었다? OOP 추상형 + 1 -&gt; 구상형 으로 최소 ADT보다 1개의 형을 더 가짐 | . | . | 상태가 늘어날 때 OOP 압도적으로 유리하다. . . ADT는 상태(초록색) 증가 -&gt; 내부 메소드 전체가 불탐(메소드마다 초록색 분기 처리 다 넣어줘야함.) | OOP의 상태(초록색) 증가 -&gt; 해당 초록색의 형이 추가하고 -&gt; 메소드를 정의하므로 타 상태의 타 형에 영향을 주지 않는다. | 메소드가 상태마다 함수안에 if분기를 만들었던 것에 비해, 상태마다 객체의 클래스형을 만들어버림. | . | . | 저번시간부터 배운 것, . ADT에서는 [공통메서드]에서 상태만큼 함수안에 if분기 . | OOP에서는 상태만큼 class(형)을 만듬 -&gt; [별도의 메소드] . if를 사용자client쪽으로 옮길려고 . | 함수안에 if(ADT)를 없애는 방법은, 사용자client쪽으로 밀어내면서, if분기수만큼 (형 -&gt; )객체를 만드는 수 밖에 없다. . | 그림상으로는 안보이지만, if -&gt; 클라쪽에서 객체 생성을 선택하는 것으로 밀려났다. . . | . | . | OOP는 복잡성 폭발을 제거하려 한다. . if 2단계 -&gt; 전략객체가 2층으로 필요함. cf) if 1단계 -&gt; 전략객체가 1개 필요함. . 전략패턴안에 있는 전략객체가 또다시 전략객체를 가져야함. | 2개다 바깥에서 공급해야한다. | Movie가 2단계 전략class를 쓰는 예이다. policy가 condition을 갖는 것으로 | 원래는 if 2단계였을 것이다. if policy if condition | . | 마지막 클라코드: policy &lt;- 생성된 condition을 꽂아줌 | movie &lt;- policy를 꽂아줌 | . | . | . | 그냥 공식: 클라쪽으로 if를 옮기고, 그 분기(상태)만큼 형을 만들어서 객체생성으로 선택한다. . | 아래 그림처럼, 함수안에 있던 원래 if는 4가지 상태에 따른 4가지 분기를 가질 것이다. -&gt; 하지만 내부if분기수 만큼 -&gt; 추상형에 따른 구상형을 4가지 형을를 만들어놓고, 바깥에서 객체 생성으로 선택하게 하여 if를 제거 . . | . | 이렇게 OOP를 쓰면 상태 추가에 강하다. 나머지 회귀테스트가 안일어난다 . 앞으로 우리는 Employee 고용형태에 재택근무자, 자유시간제 등 class(형)을 추가함으로써 -&gt; 내부if분기를 대신하여 상태 추가를 할 수 있다. | . | . OOP의 문제점 . 상태 추가(-&gt; 형 추가 생성)이 아닌 기능 추가를 하면 다같이 불타버린다. . . 객체지향에서 기능 추가시 굉장한 비용이 든다. 같은 말로 객체지향에서 성급한 추상화시 굉장한 비용이 든다. | my) 기능 추가는 추상체에서부터 시작하나보다. | . | 다른말로는 아직 추상화가 제대로 되어 있지 않으면 함부러 상태를 늘리면 안된다. 상태가 1개일 뿐이라면 추상체 기능 추가 1실험을 -&gt; 구상체 1개에서만 하면 되지만. | 많은 상태 = 형 = class가 있는 상황에서 기능 추가시... 모든 기능을 추가해줘야한다. | . | . | **성급한 추상화 하지마 라고 말했지만, 우리가 퀜트백이 아닌 이상 한번에 다 추상화 못한다. -&gt; 더 생각해보고 추상화해 라는 말이 아니다. 생각해봤자 한번에 다 못한다. ** . 대신, 기능 추가/삭제는 초반에 자주 일어나니 깨닮음이 발생하기 전까진, 상태를 추가하지말고 최소한의 상태(구상체)로만 테스트하자 기능 추가시 , 확인을 해야하는 key case까지만 구상체를 늘려 테스트 | . | 추상화를 계속 반복해서, 정교하게 만들어가는 과정 중에, case를 확인할 수 있는 애들만 구상class를 만들자. 확장은 나중에 하자. | . | . . 여기도 리스코프 치환원칙에서의 d()가 추가되는 문제는 똑같다. 외부에서 abc()만 가지고 있는 추상체(인터페이스)로 통신시 -&gt; d()를 인식할 수 있는 방법이 없다. | 하지만, 저번시간에 배운 것처럼 제네릭을 이용해 d()를 외부에서 구현해서 인식한다. 제네릭말고 다른 해결방법도 있다. | 제네릭을 통해 구현을 클라이언트 쪽으로 미루는 방법 | . | . | .",
            "url": "blog.chojaeseong.com/object/2022/05/19/(object1-12)%EB%8F%84%EB%A9%94%EC%9D%B8_%EB%B6%84%ED%95%B4_3%EA%B0%80%EC%A7%80%EB%B0%A9%EB%B2%95(FLOW,-ADT,-OOP).html",
            "relUrl": "/object/2022/05/19/(object1-12)%EB%8F%84%EB%A9%94%EC%9D%B8_%EB%B6%84%ED%95%B4_3%EA%B0%80%EC%A7%80%EB%B0%A9%EB%B2%95(FLOW,-ADT,-OOP).html",
            "date": " • May 19, 2022"
        }
        
    
  
    
        ,"post62": {
            "title": "vscode markdown link shortcut",
            "content": "keybindings.json 열어 아래 코드 복붙하기 . F1 &gt; keyboard 검색후 &gt; 바로가기 키 열기 (JSON)을 선택한다. . | 아래 코드를 맨 위에 붙여넣는다. // 스니펫 참고: https://code.visualstudio.com/docs/editor/userdefinedsnippets // 마크다운일 때, 링크 삽입 태그 추가 { &quot;key&quot;: &quot;ctrl+k&quot;, &quot;command&quot;: &quot;editor.action.insertSnippet&quot;, &quot;args&quot;: { &quot;snippet&quot;: &quot;[${TM_SELECTED_TEXT}](${CLIPBOARD})&quot; }, &quot;when&quot;: &quot;editorHasSelection &amp;&amp; editorLangId == &#39;markdown&#39;&quot; }, . | 이후 clipboard에 url을 복사한 상태에서, markdown 내 텍스트에 ctrl + k를 눌러서 링크를 바로 건다 |",
            "url": "blog.chojaeseong.com/configuration/vscode/2022/05/18/vscode-markdown-ctrl-k.html",
            "relUrl": "/configuration/vscode/2022/05/18/vscode-markdown-ctrl-k.html",
            "date": " • May 18, 2022"
        }
        
    
  
    
        ,"post63": {
            "title": "jetbrain(intellij, pycharm) bin register in variable",
            "content": "toolbox로 설치한 제품 위치 . pycharm : C: Users is2js AppData Local JetBrains Toolbox apps PyCharm-P ch-0 | intellij : C: Users is2js AppData Local JetBrains Toolbox apps IDEA-U ch-0 버전 업데이트마다 bin 폴더까지를 환경변수에 넣어준다. intellij: idea | pycharm: pycharm | . | . | . intellij bin 폴더를 Path에 등록하여 idea .으로 실행 . 탐색기 &gt; 내컴퓨터우클릭 &gt; 속성 선택 win + R -&gt; sysdm.cpl | . | 환경변수 클릭 . | 사용자 변수 &gt; Path(기본으로 인식될 경로 모음) 선택 . | 새로 만들기 선택 후 intellij의 bin폴더까지의 경로 입력 intellij의 파일위치 열기 -&gt; bin 내부 폴더임 C: Users cho_desktop AppData Local JetBrains Toolbox apps IDEA-U ch-0 221.5591.52 bin . | . | 프로젝트 폴더 경로에서 idea .으로 실행 . 빠지면 기존 실행중이던 것만 깜빡이는 것 같다. 항상 붙여주자. | . | pycharm도 bin 등록하여 pycharm .으로 실행 . Path에 pycharm의 bin경로를 걸어준다. C: Users cho_desktop AppData Local JetBrains Toolbox apps PyCharm-P ch-0 221.5591.52 bin . | 터미널에서 pycharm .명령어로 실행한다. |",
            "url": "blog.chojaeseong.com/configuration/intellij/pycharm/cmd/terminal/bin/%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98/2022/05/18/jetbrain_varaible_register-setting.html",
            "relUrl": "/configuration/intellij/pycharm/cmd/terminal/bin/%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98/2022/05/18/jetbrain_varaible_register-setting.html",
            "date": " • May 18, 2022"
        }
        
    
  
    
        ,"post64": {
            "title": "vscode image uploader(picGo+token)",
            "content": "vscode picGo setting . typora picGo 설정을 참고할 준비를 한다. . { &quot;picBed&quot;: { &quot;current&quot;: &quot;github&quot;, &quot;github&quot;: { &quot;repo&quot;: &quot;is2js/screenshots&quot;, &quot;token&quot;: &quot;ghp_&quot;, &quot;path&quot;: &quot;&quot;, &quot;customUrl&quot;: &quot;https://raw.githubusercontent.com/is2js/screenshots/main&quot;, &quot;branch&quot;: &quot;main&quot; } }, &quot;settings&quot;: { &quot;showUpdateTip&quot;: true, &quot;autoStart&quot;: true, &quot;uploadNotification&quot;: true, &quot;miniWindowOntop&quot;: true }, &quot;needReload&quot;: false, &quot;picgoPlugins&quot;: {} } . | vscode 확장에서 picGo를 검색하여 설치한다. . . | 설정(ctrl + ,)로 들어가 picGo를 검색한다. . Pic Bed: Current를 github로 선택 . | Branch를 main으로 선택 . main . | Custom Url을 계정/내 스크린샷폴더/branch를 입력한다. . https://raw.githubusercontent.com/is2js/screenshots/main . | Path는 생략 . | Repo는 계정/내 스크린샷폴더를 입력 . is2js/screenshots . | Token은 typora설정시 받아왔던 github token을 가져온다. . ghp_ . 그외 설정은 비워둔다. | . | | 내 대문자변환 단축키c+a+U과 겹친 기본 붙여넣기 단축키를 따로 설정한다. . ctrl + k + s 으로 단축키 설정으로 들어간다 . | upload를 검색하여 해당 picgo 업로드 단축키를 ctrl + alt + v로 설정해준다. . . | | 단축키 . ctrl + alt + v(클립보드 그림 붙여넣기) . [ctrl + k] + v (측면 미리보기) -&gt; shift+alt+0 (아래로 내리기) . . . .",
            "url": "blog.chojaeseong.com/configuration/vscode/picgo/github-token/settings/2022/05/17/vscode-image-uploader(picGo+token).html",
            "relUrl": "/configuration/vscode/picgo/github-token/settings/2022/05/17/vscode-image-uploader(picGo+token).html",
            "date": " • May 17, 2022"
        }
        
    
  
    
        ,"post65": {
            "title": "OBJECT 11 객체설계5_개발자의세계2_제네릭(코드스핏츠)",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . ch11. 제네릭으로 LSP위반 극복 . 객체지향의 추상형 —&gt; instanceof가 아닌 if를 제거 | 객체지향의 제네릭 —&gt; if instanceof를 제거할 수 있다. 2가지를 섞으면 모든 종류의 if를 제거할 수 있다. | . | . instanceof to 제네릭 . 알렉산더르 아저씨가 쓴 책: 수학적 근거로부터 만들었음 | 객체지향적 의미: LSP위반을 해결할 수 있는 언어적 수단은 제네릭이다. 제네릭: 추상형을 유지하면서 &amp; 구상형은 클라코드에서 결정하게 해주는 것 if문과의 차이점 : 형으로 결정함 | 즉, if instanceof를 제거하려면 제네릭을 써야한다 | . | . | 제네릭 사용 판단은 기계적으로 &lt;내 코드에 instanceof가 있는지&gt;로 판단해도 된다. runtime, context에러 -&gt; compile에러로 옮길 수 있는 수단이다. 형 체크시 compiler를 이용하므로 | 우리가 할 수 있는 if제거 수단: 형 | . | . | . . . if instanceof가 보이면 -&gt; 제네릭를 쓰면 되는데 if instanceof -&gt; 다운캐스팅을 하고 싶어서 확인하는 것 -&gt; LSP, OCP 위반 | 매핑의 과정은 아래와 같다. Client의 추상층인 Paper인터페이스에 &lt;다운캐스팅이 일어나는 것을 추상형으로 제네릭&gt;추가 programmer 다운캐스팅(FE or BE) -&gt;T | programmer 추상형 -&gt; extends 추상형 | . | . | 다운캐스팅한 문법을 제네릭을 이용해서 업캐스팅한 문법으로 바꿨다. | 즉, 제네릭을 통해 &lt;T형의 규정을 extends 추상형&gt; == 업캐스트(upper bound, 상위 bound)를 이용해서 규정한다. cf) 다운캐스트 == 바닥의 lower bound == 구상층 == FrontEnd로 정의하는 instanceof | . | . | 제네릭을 이용한 순간 -&gt; LSP, OCP를 회복했다고 생각할 수 있다. my) instanceof -&gt; lowerbound(구상층)을 사용한 다운캐스트 -&gt; LSP,OCP위반 | my) &lt;T extends 추상형&gt; 제네릭 -&gt; upperbound(추상층)을 사용한 업캐스트 -&gt; LSP,OCP회복 | . | . Client 수정 . . LSP, OCP 위반 = 다운캐스팅이 일어나는 Client 클래스 -&gt; 그것의 추상층인 Paper 인터페이스에 제네릭인 T형 (extends 다캐일어나는 FE/Programmer의 추상형) 을 받았다고 생각해보자. . | **추상클래스 레벨에서 추상형upperbound 제네릭의 T형을 받았다면 구상클래스 Client가 impl시 단순Paper가 아닌 -&gt; Paper&lt;FrontEnd&gt;를 받을 수 있다. ** . my) 제네릭이 달린 추상층은, 구상클래스 구현시 impl 추상층이 아니라 impl 추상층&lt;T형의 구상형&gt;으로 받을 수 있다. . . | . | 추상층의 메소드정의시 인자를 제네릭을 이용한 T형(upperbound의 구상형 입력가능)을 인자로 받았기 때문에 -&gt; 구상층 메소드 정의시 인자에는 직접적으로 (구상형으로 메소드 인자)를 받을 수 있다. . 추상층에서 제네릭을 통한 T형으로 정의 -&gt; 구현클래스에서 upper bound의 구상형들로 정의 가능 | . . . instanceof 없이 구상형d()를 가져다 쓸 수 있게 된다. 제네릭이 해주는 것은 instanceof를 제거하는 것 | . | . | Client의 setData()의 인자에 구상형으로 정의했다 -&gt; 제네릭을 통한 형으로 좁혀서 막았다 -&gt; compile시 에러가 난다. . 이제 Client 프로젝트에 데이터를 꽂을 때는, 아무것이나 못 준다 -&gt; 제네릭을 통한 형으로 제한하면 -&gt; 형은 compile에러를 내서 오류를 잡을 수 있게 된다. | 과거에는 다운캐스팅한 코드 속에서 if backEnd로 갈지도 모르는 가능성이 runtime코드 어딘가에 숨겨져있었는데, 지금은 제네릭을 통해 하위형으로 확정시켜서, 형 에러시 compile time에 걸린다 | 제네릭을 사용하면, 추상형 -&gt; T자리에 구상형을 지원 -&gt; 형으로 용도를 확 줄임 | . | 제네릭은 기계적으로 사용할 수 있다. 매핑하는 것처럼 현재 클래스의 추상층에 제네릭으로서 upperbound로 T형을 꽂아주고, 추상메소드 정의시 T를 사용해서 정의 | 이 추상층을 -&gt; 구현이나, 메소드정의시 T자리에 구상형을 직접 입력해서 정의 | instacneof 제거 -&gt; LSP, OCP 위반 제거하게 됨 | . | if를 제거하려면, 분기에 해당하는 수만큼 객체를 만들 수 밖에 없고, 선택은 클라코드에 위임한다. Client가 범용(FE or BE or 추가될 개발자) 이었다가 | 제네릭을 통해 if instanceof제거 -&gt; 1개 분기(FE)에 대한 객체(Class)만 생성 BE용 Client도 새롭게 정의해줘야한다. | if case 1개(FE)를 담당하도록 FE전용 class가 정의되버렸다. class를 if case만큼 생성해하며, 그 선택은 바깥에서 한다. | . | . | 제네릭 / 전략패턴 / 인터페이스 -&gt; 다 if를 이런식으로 제거한다. if는 제거되었지만, 그만큼 객체/class가 생성되며 -&gt; 선택은 클라코드에서 한다 | . | . | . ServerClient: instanceof 2개는 제네릭은 기계적 매핑 안됨 . . [Paper쪽]에 시킨 버전은 더 무겁다는 것이 여기서(ServerClient) 드러난다. programmer를 2 case를 if + else if로 모두 다운캐스팅해서 받아줘야한다. | if 2개를, 제네릭으로 T형+R형으로도 매핑할 수 있을까? if가 3개면,, 그것도 불가능.. 안됨. | . | if가 2개(2개이상일 가능성 높음)부터는 instanceof -&gt; 제네릭 매핑이 불가하다 | . | 이것을 보니까 [Paper쪽] instanceof가 훨씬 무겁다는 것을 알 수 있다. 그렇다고 다시 [Programmer쪽]으로 옮길수 도 없는 노릇이다.??? | . | . OCP와 제네릭을 통한 LSP위반 해결 . . 우리는 LSP위반을 해결하기 위해 제네릭을 통해 해결해보려했지만 신통치 않았다 | 그래서 헐리우드 원칙(묻지말고 시켜=던져)를 이용해서 OCP+제네릭을 결합한다 물어보다: if instanceof 로 맞는지 물어본다. | . | . Paper(N) 및 자식들 원상복구 . 추상층 paper한테 묻지말고 시켰더니, 어떤 구상층에서는 2개를 묻는 더 무거운 경우가 생겨버렸다. paper는 안되니 다시 롤백하자. paper는 programmer와 1:N관계에서 N이며, N쪽에서 구현(시키기)하면 언제나 일반화시킬 수없다 -&gt; 시키면 안된다시키는 것을 1쪽에 구현해야한다. programmer(1)에 시키고 + 제네릭 | paper(N)을 원상복구(제네릭X + 시키지도X) | . | . | 이상적인 객체관계에서는 항상 child(N) -&gt; parent(1)을 알게한다. parent(1) -&gt; child(N)을 알게하면 더 불리하다. 많은 것들을 알아야한다. 많이 알아야한다 -&gt; 의존성의 무게가 크다. | . | child -&gt; parent를 아는 것은 1:1매핑이 된다. sqlalchemy에서도 N테이블(FK테이블, Song)에서 1테이블(PK, Album)reference(relationship변수)를 거는 것이 단수로 나와서 편했다. | 부모가 자식을 알땐 1:N &lt;-&gt; 자식이 부모를 알 땐 N출발이지만 1:1 | . | 여기 문제에서는 Prgorammer(N) -&gt; Paper(1)를 알게 하는 것이 더 낫다 | . | . . 1에 해당하는 Paper에 구현X 시키지X 원상복구 하니, 메소드 없는 제일 좋은 인터페이스로 돌아갔다. . 1paper당 - programmer - 2종류의 개발자가 매칭되더라. -&gt; if가 1개에서 2개로 늠. -&gt; 원상복구 | programmer(N) -&gt; paper(1)쪽에 시키지말고, programmer가 감당하게 가야한다. N에서 1만 안다 == 시키는 것을 1에게 몰게하고, N은 아무것도 안하고 1만 의존하게 한다. | . | Paper는 메소드가 비어있다 -&gt; abc(구상층의 공통로직)이 없는게 정상이다. | Client(Paper 구상체) 전체가 d다. (paper에 abc자체가 없었다) | . | . . ServerClient도 돌아갔다. Paper(1)에 시키지X -&gt; 구상체들 다 원상복귀함. 마커 인터페이스 이하는 다 d()이다. | . | . Programmer(n)에서-&gt;Paper(1)를 알게한다 = 그 쪽(N)에 시킨다 = 그쪽에 제네릭을 붙여 instanceof 제거 . . 중간 코드들은 생략한 상태 | 기존 Programmer 인터페이스 —&gt; FE와 BE의 공통로직을 추상화한 추상클래스였다 Paper쪽에 시킨 기존 버전 템플릿메소드패턴자리에 paper에 개발자정보를 .setData 해놓고 | 그 paper로 makeProgram한 Program반환 -&gt; makeProgram의 만드는 과정은 구상층이 구현 my) Paper는 밖에서 입력되는데, paper에 개발자 정보를 set박아놓은 뒤(no..N:1에서 N이 paper에게 일 시키는 중..), 각 자식 프로래머들이 알아서 Paper를 받아-&gt;프로그램을 만들어서 -&gt; 반환 | . | . | 현재 버전 | . | 달라진 점 구상클래스들의 instanceof 제거를 위해 -&gt; 추상층에 제네릭을 T형 + extends Paper(upperbound)로 붙히고 메소드 인자를 기존 Paper paper -&gt; T paper로 정의한다. | **더이상 paper.setData( 개발자 )으로 paper에게 시키는 것(책임을 미루는 것)이 아니라 ** setData()의 책임을 내가 가져간다. 타 객체에게 시키는 것이 아니라 내가 한다 = (this.) 그냥 setData(paper) 호출 제네릭 T형 paper 정보를 받아서 내가 처리한다 -&gt; 정의는 setData(T paper) | . | T형 paper의 처리 -&gt; 자식(구상층)에게 알아서 if instanceof분기마다 1개씩 &lt;해당 paper구상체&gt;를 받아들이는 Class생성하도록 맡김 | . | 내가 해줄 수 있는 것은 makeProgram()호출 전에 setData()를 호출하면서 T형 paper를 넘겨줄게 T paper의 처리는 구상층 자식들아 너네들이 분기별로 한개씩 T를 사용해서 만들도록 해라 | . | . | | 착각해선 안되는 점: (객체)메세지 -&gt; Don&#39;t ask + tell!인데 템플릿메소드를 구성하는 부모-자식간에도 마찬가지로 적용된다. setData( paper ): tell한 것(물어보지 않고 말해서 시킴) getter처럼 값이나 객체를 받아오질 않음 | &quot;내가 줄건 paper고, 나한테 얘기하지말고 알아서해&quot; | . | . | abstract setData(paper)메소드 = 자식꺼라고 생각한다. 자식꺼인 setData(paper)를 호출할 때도, 부모(템플릿메소드getProgram)은 묻지않고 = return없이 -&gt; set시킨다 | . | . | . BackEnd . . 수많은 종류의 BackEnd개발자가 있을 것인데, 종류만 FE/BE로만 나눠놓은 상태다. 수많은 BE개발자(instance)들의 공통점을 찾자라면 Server와 Language는 정해줘야한다. | . | BE개발자들 중에서도 기존 추상층의 상속 extends Programmer&lt;T&gt;에 추가하여 BackEnd에도 &lt;T extends Paper&gt; 제네릭 붙혀 어떤 T형의 paper를 받았느냐에 따라 같은 BackEnd개발자라도 다른 BackEnd개발자로 본다. 기존(원상복구) | **BackEnd -&gt; 제네릭을 받는 추상클래스로 변화 ** 그 위 추상층 Programmer 은 이미 제네릭 붙인 상태함 | . | . | . | . | 기존까지 class의 관념에서 보면 수많은 BE개발자(instance)들 -&gt; BackEnd 일반 class로 추상화해놓은거 instance들을 추상화해놓은 class에 제네릭이 개입하면 추상화가 깨지는게 아니라 &lt;if분기에 걸릴 것들이 -&gt; 각 T형으로 &lt;제약&gt;이 걸린다. + my) 추상클래스가 된다. class : BE개발자들 | class + 제네릭 ** -&gt; **abstract class -&gt; &lt;a Paper&gt;를 가진 BE개발자 class로 각각 한정된 class로 여러개 구현해야함 | &lt;B Paper&gt;를 가진 BE개발자 class로 구현해야함 | &lt;C Paper&gt;를 가진 BE개발자 class로 구현해야함 | if 대상이 되는 분기들을 T형에다 옮겨놓은 것이므로 if case만큼 새로운 class를 만들어야한다 | . | . | . | if를 코드안에서 제거하는 유일한 방법 -&gt; if case만큼 class를 만들어주는 방법 밖이다. 함수도 만들어도 되지만, 우리는 형(class)으로 만들어야지 compile에러를 낼 수 있다. | if case만큼 class를 만들어주는 방법은 제네릭을 사용하는 것이다. my) 그러려면, 기존 class 1개를 -&gt; 제네릭달린 추상class + 각 if case만큼 구현한 일반 class들로 구현 | 일반class BE의 추상화 -&gt; public abstract class BackEnd 는 추상화는 깨지지 않았지만 | Backend&lt;T extends Paper&gt;로 인해 각 if case 1개(instanceof)로 사용범위가 제한된 class가 각각 구현된다 | . | . | 각 한정된 BackEnd마다 case마다 다른 값으로 들어올 T를 **-&gt; extends **Programmer&lt;T&gt;에 공급해준다 | T를 공급받은 Programmer에는 추상화된 공통로직이 올라가있도록 설계되었다. . | 이제 각 case별 BackEnd들의 공통로직(어느 paper종류를 가진 backend라도 똑같은)을 구현해주면 된다. . 대표적인 것이 makeProgram()으로, 어느paper를 받는 BackEnd class일지라도 다 공통되는 로직으로서 추상클래스 BackEnd에서 구현해주면 되는데 | . | 추상클래스 BackEnd에는 추상층(Programmer)에 있던 setData(paper)의 구현은 빠져있다. | 이건 각 case별 = 들어오는 T paper별 BackEnd마다 서로 다르게 구현해야하는 내용이므로 클라 코드에 위임시키기 위해 BackEnd&lt;T&gt;가 추상클래스가 된 것이다. . | 아까는 Prgrammer -&gt; Paper로 밀어냈는데, 클라코드(Main)방향으로 밀어낸 것이 아니라서 문제가 해결X(협력관계 도메인 레이어(같은 책임 레이어)에서 문제를 떠넘길뿐이었음) 자기보다 클라방향으로 밀어내야지 LSP, OCP위반을 해결할 수 있다. if제거를 밀어내기를 클라방향으로.. | 클라코드에서는 경우의수만큼 더 만들어내게함 -&gt; 객체로 보내주면 내부 객체랑 대화함 | . | . | my) paper마다 다르게 구현해야하는 Programmer의 setData(paper)를 받아버리면 paper마다 다르게 구현해야하는 내용 -&gt; 어쩔수 없이 if문을 써서 구현해야한다. | **setData(paper) -&gt; paper가 다르게 들어오는 것의 결정 -&gt; 클라 코드(main)으로 넘기고 싶다 ** BackEnd가 Programmer를 상속하면, 어쩔수 없이 setData(paper)를 구현해야하니 -&gt; FE/BE class를 추상클래스로 바꾸고 -&gt; setData를 구현안하고 -&gt; 클라코드(main)에서 FE/BE를 추상클래스를 구상클래스로 구현 &amp;&amp; 객체 생성하도록 한다. | . | . | my) 매번 달라지는 paper -&gt; 추상층에 제네릭붙혀 if instanceof 제거 -&gt; 구상층에 paper땜에 달라지는 paper달린 메소드 -&gt; 구상층도 추상class로 변경해서 paper달린 메소드 구현X 클라코드에 추상class구현을 미룸 | . . FrontEnd도 클라방향(외부)로 밀어내서 편안하다 부모제네릭T지만, 바뀌는 것들을 -&gt; 자식이 구현X -&gt; 안바뀌는 공통로직만 구현한 추상클래스로 만듬 -&gt; case에 따라 바뀌는 것을 클라에서 구현하게 함 | . | . 클라아이언트(주체Director -&gt; Main)의 변화 . . 여기 배운것에 따르면 가장 위쪽 추상레이어인 Programmer와 Paper를 괴롭히지말고, 더 외부방향인 Director를 괴롭혀라 현실에서도 임원이 시키면 개발자한테 던져서 if로 분기하면 -&gt; context에러로 망한다. | . | 팀장이 다 해체한다음, 개발자들한테는 1개 case들만 각각 정의하도록 던져준다. 너는 aws | 너는 유닉스 세팅 | 너는 버플리쉬 | . | . | . | 추상층이 아니라 클라이언트 층 = 서비스를 이용하는 층 = 더 훌륭한/돈많아서 시킬 수 있는/위에 있는 사람에게 구체적인 상황을 나누는 분기를 던져줘야한다 서비스층이 안정화되고 -&gt; 클라이언트 층은 hell이 되었다고 생각할 수 있다. | . | . | 클라이언트한테 던져줘도 클라이언트에서 hell = 책임이 떡지지 않는다. 우리는 역할책임모델기반으로 책임을 분산하면서 짰기 때문 | 코드에 if를 가지지 않고, 형 with 제네릭으로 해결한다 | . | . 상대적 클라방향 Director . Director내부에서 if ServerClient와 if Client를 처리하던 코드를 비교해보자 . 기존 코드 . . Server와 Client 프로그램 각각을 따로 만든 뒤, deploy하는 책임을 가지고 있다. | 프로그램 만들어서 deploy하는 책임을 가지고 있었다. | . | 기존코드를 보면, ServerClient와 Client 처리코드가 중복된 로직을 처리하는 중복된 코드를 가지고 있다 . | . | 현재는 if instanceof제거를 위해 Programmer를 특정 paper를 알고 있는 programmer로 구현되도록 제네릭으로 한정지은 상태다. . 기존 Director속 programmer는 특정paper를 알고 있는 프로그래머가 아니다. 범용 프로그래머 = 아무 paper나 받아들이는 frontEnd개발자, BackEnd개발자인 상태다. | . | 지금은 제네릭으로 -&gt; 특정 paper만 받아들이는 prgrammer로 제약을 걸었다. Director 속의 코드 -&gt; ServerClient 처리 코드가 바뀐다. | . | . | . . Director속 ServerClient paper인 경우, 처리코드가 어떻게 바뀌었는지 확인해보자. 범용 FrontEnd 개발자가 아닌, ServerClient만 아는 FE를 만들어야한다. 그래야 if가 바깥쪽으로 빠져나온 효과를 누린다. 제네릭이 if없이 case를 [형]으로 한정지어서 if문이 없다. my) new Class&lt;형으로 확정&gt;지은 class의 객체는 if제거하고 외부로 돌린 제네릭이라고 생각하자 | . | ServerClient(paper)를 알면, 아는 것의 내장을 깔 수 있으므로, 그 속의 language만 물어봐서 역할책임에 넣어준다. | . | BE도 범용이 아닌 &lt;ServerClient&gt;만 알 고 있는 BE -&gt; setData시 &lt;확정된 paper -&gt; ServerClient 문서&gt;로 여기로부터 확정된 데이터를 가져와 setData | 나머지는, project에 FE, BE개발자들 세팅해주고, program 얻고, 정리해서 deploy에 준다 | . | 기존까지는 Paper or Programmer에 있던 if instanceof를 —&gt; if문에 해당하는 수만큼의 class를 정의하고 -&gt; 외부 클라코드(Direcotr, main)가 어떤class-&gt;어떤객체를 만들어낼지 선택하게 한다 Director가 선택하는 모습이 안보인다고 할 수 있는데, [if문 -&gt; 하드코딩]을 통해 &lt;선택한 객체를 새로 생성&gt;하는 것이 if분기 중 1개 선택한 것돠 동일한 것이다. if case만큼의 class = 형을 만드는 것으로 대체함. 어려우면 반복하자. | 클라이언트에 밀어내자 | 클라이언트는 if문분기 대신 본인이 선택(객체 하드코딩으로 new생성해서 선택) 가장 외부에서 객체를 새로 생성하는 것으로 선택 | . | . | . | . | . . 우리는 FrontEnd개발자를 &lt;제네릭으로 paper -&gt; ServerClient로 확정&gt; 짓는 것을 통해서 개발자들이 각각의 개발자들이 어느 paper에 반응할지를 가장 클라이언트(외부, Director, Main)에 가까운 쪽으로 밀어내서 클라에 가깝다 = 추상레이어 -&gt; abstract class -&gt; 구상class in Director = 추상화 레벨 가운데 가장 밑 레벨까지 밀어내서 == 가장 마지막 구상층까지 밀려나와 객체를 new새로생성으로 if를 대신할 수 있게 된다. | . | . | Director 프로토콜 수행 전 구간에 걸쳐서 LSP, OCP위반이 없어졌다. 프로그래머 , 페이퍼 -&gt; 추상층?인 FE/BE, Client/ServerClient 전부 다 if가 없어지고 LSP, OCP위반이 없어졌다. 형으로서는 가장 마지막 구상층까지 밀어냄으로써(거기서 객체 생성하여 선택하게 함으로써) | . | . | . . Client paper는 더 쉽다. Client형 전용으로 만들어서 if를 없앤다. 범용 FrontEnd가 아니라 Client paper전용 FrontEnd를 만들어서, 그 내부에서 받은 client paper로 setData해주고 | 그 FrontEnd개발자를 project에 set한 뒤 deploy | if는 다 사라졌다. | . | 아직까지 Director수준의 instanceof를 가지고 있어서 아직 남아있다. 그러나 Director에게 형을 주는 것은 불가능하다. Director가 N개의 paper를 가지고 있기 때문 -&gt; N개짜리는 제네릭으로 처리할 수가 없다. Direct가 2개이상 종류를 가진 paper를 추상화하는 것은 불가능하다. | . | 의존성 역전을 시켜야한다. director가 —&lt; N개의 paper를 가지고 있다? | 반대로 1paper가 —ㅡ1Director에게 서비스를 제공해서 추상화하면 된다. 아까 1Programmer —ㅡ&lt;2 paper 에서는 paper선택시 무거웠지만 | 여기 director —ㅡ&lt; N paper에서는 paper—ㅡ director가 더 가벼워진다. | . | . | . | 어려워보이지만, 재귀 &lt;-&gt; loop바꾸듯이 자연스러워야한다. 회사에 가면 거의다 다운캐스팅해서 쓰기 때문에… 연습을 해서 익숙해져야한다. | . | . | . | . . 다시 Director 전체 코드 레이아웃를 한번 살펴보자 기존처럼 addProject, runProject 하는데, runProject시 가져온 paper(project)에 대해 if instacneof 분기를 하고 있다. | Director 레벨에서도 OCP위반을 하고 있다. OCP를 해소하는 방법으로 if문을 해소해보자. if문이 보이면,공통로직 추상화 —&gt; 구상화를 클라이언트 방향으로 옮겨야한다. | **거기서 경우의 수만큼 형을 생성해놓으면 -&gt; if대신 선택을 해당 형 객체 생성으로 하게 한다. ** | | . | . | . OCP위반 1: if분기대상에 공통로직 추상화 . . 클라방향으로 옮기기 위해서는 if분기들 내부 공통로직을 추상화부터 먼저 해야한다. if instanceof 분기마다 공통되는 로직들을 추상화해야 -&gt; 클라쪽에서 구상화할 수 있게 된다. | . | . . 공통로직(빨간박스): 특정paper -&gt; project -&gt; project 개발자 -&gt; project 세팅완성 -&gt; 개발자+project로 getProgram deploy()를 보면, 앞에 공통로직에서 programs를 받는 표준인터페이스이므로 공통 로직들은 programs를 return하도록 감싸면 된다. | . | 공통 로직을 구성하는 programs return로직으로 —&gt; if 분기를 만드는 Paper를 감쌀 수 있다.(추상화?) 아까도 caseA caseB를 감쏴서 -&gt; abstract class를 만들었다. | 코드(공통로직)를 보고서 -&gt; 추상화한다. 빨간박스는 programs배열을 토해내면 된다.(자바 …은 1개씩 보내도 되고 배열로 보내도 됨) | 추상화의 대상: 공통로직(빨간박스, programs를 return)를 -&gt; paper (추상층)에 올리는 것이다 | . | . | . . if분기를 만들던 Paper는 추상층에서 인자 없이 run()을 때리면 Program[]배열을 return해야한다. case A, case B를 본 결과, 추상화하여-&gt; Program[]배열을 return하는 인자없는 메소드run()을 만들면 된다. 실행만해주면 된다. | 책임: Director가 project를 실행하는 것에서 -&gt; &lt;여러 if분기를 유발하는 추상층&gt; paper가 project를 run하도록 추상화를 통해 넘어갔다. 역할책임모델은 도메인과 일치하지 않는다. 적당한 역할을 하는 사람이 가져간다. | . | . | . OCP위반 2: if분기대상의 자식들(특정분기들)을 abstract화 -&gt; 클라에서 new 자식(특정분기) 객체 생성하며 &amp;&amp; 분기대상의 공로메소드 case에 맞게 구상화 . . 분기속 공통로직을 분기만드는 paper로 추상화한 run()을 -&gt; 상세 구현은 client방향으로 밀어야한다. . 공통로직의 틀 = paper는 Program[]배열를 return만 추상화한다 . 기존에는 ServerClient나 Client paper는 완전한 paper(일반class)였는데 . . | . | 이제는 분기를 만드는 paper에 [공통 로직의 틀]를 &lt;클라이언트에서 구현하면서 객체 생성으로 선택&gt;하기 위해 . 이제는 paper의 run()을 외부에서 최종구현할 수 있게 자식들 SeverClient paper, Client paper 을 구상클래스가 아닌 [중간의 추상클래스]로 만든다. 가장 바깥 = 외부에서는 이 추상클래스를 구상하면서 객체생성하여 선택 왜냐면… 외부 최종 선택 -&gt; if case마다 다 하나씩 생성해야함 -&gt; 구현하면서 객체 생성하여 최종선택하면 한번에 해결 나중에 볼 코드지만, new Client()로 if분기 중 1개인 Client특정paper를 선택하면서 &amp;&amp; 타 내부정보들도 Paper의 run() -&gt; 자식인 Client도 추상클래스 -&gt; 객체생성하며 클래스처럼 구현하여 선택해버린다. | . | . | . | . | if문(paper)을 제거하려한다? 그만큼의 형(class)를 만들어야한다. . 그 형을 담는 그릇이 interface Paper이다. | 그렇다면 자식들이 ServerClient / Client는 구상클래스 같지만, 추상클래스로 남겨놔야한다 | 외부에서는 new ServerClient() or new Client()로서, 객체를생성 하면서 case에 맡게 구현하며 추상클래스 구상화를 해버리는 전략이다. | if instanceof에 분기 선택으로 사용되던 Client, ServerClient도 class -&gt; abstact class된다. abstact만 달아줌으로써, Client, ServerClient의 본래 특징을 유지하되 &amp;&amp; if를 유발하는 수행방법(내부다른정보들 입력) -&gt; case에 따라서 외부에서 구현 &amp;&amp; 객체 생성(형 생성)해버리기 위해 | . | . | . OCP위반 3: 외부 선택 by 특정분기 객체생성 with 공통로직 메소드 구상화 —&gt; 다시 내부로 받아온다. . . OCP위반 4: 내부에서 받은 특정분기 객체의 호출 . . 위 코드는, Director의 if instanceof관련로직을 다 클라이언트 방향으로 밀었다. if 분기대상(Paper)에 공통로직 메소드(run()) 추상화 | Paper자식들 = 특정분기들(Client, ServerClient)의 absrtact class화 | 외부에서 특정분기(자식) 1개 new 객체 생성 &amp;&amp; 분기대상의 공로메소드run() case에 맞게 구상화 | | deploy의 인자 중 projects.get(name).run()이 case에 맞게 외부에서 구상화한 공통로직 메소드를 호출한 것이다. -&gt; &lt;공로메소드 추상화 직전 틀&gt;에 의하면 programs 배열을 return할 것이다. | Director의 if instanceof 제거 -&gt; 앞으로 수정안해도 됨 Programmer, paper를 이용하던 Director보다 —&gt; 더 클라방향인 Main으로 밀렸다. | Director는 상대적으로 Programmer그룹, paper그룹에 비해 host방향이었다. | 객체지향 설계를 제대로 했다면 -&gt; Main까지 밀려야 성공한 것 그 전까지 어딘가에서 다운캐스팅 하고 있을 것이다 | . | . | Main까지 다 밀었으면 DI를 한다. Main의 코드들을 싹다 일일히 만드는게 아니라 DI를 통해 주입하는 것으로 끝내야한다. | Main까지 다 밀어내야지만 DI가 정상작동한다. | . | Director -&gt; 분기대상인 Paper가 책임을 가지게 되었음. Director는 코드가 줄었다. | . | . OCP위반 5: Main에서 여기까지 밀려난 특정분기Paper를 case에 맞게 객체생성&amp;&amp; 익명클래스로 구상화(형 생성) . . Director를 만든다. | Director에 project(특정Paper 중 1 case)를 “name”과 함께 add한다. 프론트 작업이라서 -&gt; 특정 paper들(자식들) 중 Client paper를 만들고 있지만, 범용Client paper가 아니다. 수행방법을 그 자리에서 구상화하면서 객체를 생성한 Client paper이다. 구상화(abstract class를 구현)한 것이니 -&gt; 해당 수행방법을 가진 형이 case에 맞게 생성된 것이다. | **() { } 괄호 담에 중괄호 -&gt; 익명클래스로 형을 선택한 자리에서 새로만든다. ** 이게 바로 if를 제거하는 원리 | . | . | . | 수행방법을 보니 Client용 FE개발자 1명 섭외 개발자도 [객체생성으로 선택]으로 섭외하는, 익클로 구상화와 동시에 객체 생성하여 특정 개발자(개발자의 특정자식(중간abstract))면서 &amp;&amp; 수행방법(case에 맞게 abstract를) 구상된 개발자를 선택한다. | 여기에도 if대신 형을 생성하는 문법으로 바뀌어있음. | . | 개발자한테서 program을 받아냄 | deploy용으로 program반환 | runProject | . | . | DI주입은 객체생성 &amp;&amp; 익클 구상화하는 부분을 주입으로 바꾼다. | . OCP위반 6: Main(외부)로 밀었다면, 구상화에 있는 setter를 제거해서 구상화시 은닉성을 높이자. . Client: No 제네릭(필요없음) . . FE에 한정된 이야기지만, 중간에 있는 setProgrammer()라는 인터페이스를 보자. . Client(abstract class) paper에서 자신의 속성을 갱신시켜주는 [외부 객체 메세지]를 허용해주기 위해 받은 메소드다. . | 지금은 Client 본인이 Main(외부)에서 익클 구상화를 통해 case맞는 형으로 확장된 상태이기 때문에 . 외부 객체 메세지가 필요 없게 되어 —&gt; 안쓰면 보안성이 더 높아진다. | 클래스의 은닉성을 높이려면 —&gt; 외부 객체를 인자를 받는 메소드가 없는게 좋다. | . | setProgramer( )는 전형적인 setter의 노출이다. —&gt; 클래스의 은닉성을 깨먹는 것 . 상태관리를 본인이 아닌 사람에게 맡기고 있다. | . | Main까지 밀어낼 수 있다면 == 익클로 구상화하면서 객체 생성하여 선택 할 수 있다면 . Main속 익클 내부의 속성은 setter로 외부에 시킬 이유가 없다 | 내가 내 속성을 갱신하도록 바꾸면 된다. | . . setter()는 여긴 안보이지만, abstract class Client에 선언된 programmer변수에 set하는 public 메소드다 | . . programmer는 말만 private 변수지 public method인 setter()로 공개되어있던 상태였다. | . | . | . . public과 연동되어있는 getter/setter만 봐도 설계가 잘못되어있음을 알수도 있다. 제대로 설계했다면, 안보이지만 추클에 있는 변수에 &gt; 익클 구상화(자식)하여 직접 상태(변수)를 갱신시켜주는 class로 설계 | 익클 구상화 -&gt; 자식에서 추클의 변수를 사용? -&gt; protected 수준의 보안성을 가진다. 나만 내 프로그램을 관리한다. : private 수준 | 나(추클) &amp; 자식(구클or익클)만 내 프로그램을 관리한다. : protected 수준 | . | . | . ServerClient: with 제네릭 for 1:N . . if분기로 나올 그냥 ServerClient paper가 아니라 **case맞게 수행방식을 가진(익클 구상) &amp;&amp; ServerClient paper를 [객체생성 &amp;&amp; 익클구상화]로 선택한다. ** | 지금까지는 메소드위임만 했다 -&gt; 제네릭을 안 썼다. Director(구상형, 1) - paper(N=추상형 이지만 화살표 시작점이라, 1)가 1:1관계라서 제네릭을 안통했어도 됬었다. 즉, Director가 추상형이 아닌 == 구상형 -&gt; 자식으로 분기X 무조건 1 –&gt; 1:1이면 if instanceof를 쓸일 X –&gt; 제네릭 쓸일X —&gt; 자연스럽게 공통로직만 추상화해서 [인터페이스의 츠상메소드]로 올릴 수 있었다.` | . | 만약 Director가 A Director or B Director로 분기되는 추상형(자식으로 분기가능한 N)이었다면 Main에서 로직이 Director별 분기로 인한if instanceof를 잡아주기 위해 —&gt; 제네릭이 관여해서 Paper &lt;T extends Director&gt;로 정의했어야했다. paper를 받을 때, paper를 가지게 될테고(?) | T Director에 따라 run()을 바꿔주는 경우의수를 또 나눠야함.(?) | 해당 메소드 T에 있는 메소드로 넘어가게 된다고 함(?) | 구상형을 받으면, 구상형을 제네릭으로 나눴기 때문에, 나눈 추상층에서는 구상형에 대한 수용방법을 알 수 없다. 형만 알고 있다. 그렇기 때문에 다시 개별형으로 다시 토스를 해줘야한다. 지금은 Director가 구상형이기 때문에, 보다 추상형인 Paper에게 run()의 구현을 넘겼다.(?) | . | . | 지금은 Director:구상형 —&gt; run()의 구현을 보다 추상형인 Paper(N)에게 공통로직 메소드run()을 구현하도록 넘겼다. 그러나, Director가 추상형이 되면, Director + Paper 둘다 추상형으로 N인 경우, 무게가 가벼웠던 Director에게 run()의 구현을 넘길 것이다. | 설계를 해보면 == 코드배치방법은, 어느쪽이 무거운지 vs 확장적인지에 따라서 바뀐다. | 지금은 압도적으로 Paper가 가볍기 때문에 구상클래스에 대한 분기를 Paper쪽에서 구현할 메소드를 올린다. 진짜 수용해야할 코드는 아래코드이며, 이 코드만 왔다갔다 하는 중이다. | 아까는 Programmer안에 있었다가 -&gt; Paper안에 있었다가 -&gt; 지금은 Director안에 | . | . | . | . . 마찬가지로, 익클구상과정에서 은닉성을 깨먹는 public setter를 —&gt; 자신이 갱신(할당)하도록 바꾸면, 보안성을 높일 수 있다. | . 2종류의 if -&gt; 제거방법 . 객체지향의 추상형 —&gt; instanceof가 아닌 if를 제거 | 객체지향의 제네릭 —&gt; 1개만 가지는if instanceof를 제거할 수 있다.(2개이상일 땐, if를 제거하는추상화) 2가지를 섞으면 모든 종류의 if를 제거할 수 있다. | . | addProject후 runProject if는 어디 가지 않는다 —&gt; 마지막 클라코드, 정확히는 Main까지 밀어내고 싶다. | . | . 반복 복습하면 . 보자마자 미래에 문제가 일어날 것이다. | 아무코드를 보면, 구조상 분기했을때 버그가 일어날걸 | 이건 코드상 context에러를 내장하고 있는데? | 단순매핑 + 훈련으로 극복할 수 있는 내용들이다. | . LSP위반(추상체로 처리 안됨)을 헐리웃원칙으로 시킬 땐 확인부터해야한다. . 추상체에게 일을 시킬 때, 나도 추상체냐? | 추상체vs추상체면 -&gt; 상위(1)에서 하위(N)으로 시키는게 맞느냐? 현재는 paper가 1이면서 상위라서.. paper에게 시킬 때, 나또한 추상체로 넘겨줘야하고, 그 개별구현체를 확인해야한다. | . | 헐리웃원칙을 적용하기 전에 추상체vs추상체와 관계까지 확인한 뒤 적용시켜야한다. | . | 시행착오를 한번 겪어보기 위해 1쪽인 Paper추상체에게 알아서 하도록 시켜보자. . 일단 FrontEnd내부에서 Paper-Client에게 시켜본다. . 시킬일을 메서드로 추출 | Client로 메서드 이동 | FrontEnd(구현체)가 인자로 잡힘 넘길 때, this가 FrontEnd가 아닌 추상체Programmer로 넘어가야, BackEnd도 일을 시킬 수 있게 되니, backEnd처리시 처리해본다. | . | . . | Backend내부에서 Paper-ServerClient에게 시켜본다. . Paper는 이제 추상체Programmer를 받아서 일을 하긴 하지만, 파라미터로 온 Programmer도 역시 한번에 일시키는 메서드가 없어서, 각 구현체(FrontEnd, BackEnd)마다 서로 다른 필드 -&gt; 서로 다른 Setter을 가질 수 밖에 없다 . 인터페이스에서 안쓰는 기능도 올려주거나 . . | instanceof로 물어보고 개별setter만 사용하도록 처리할 수밖에 없다. . Programmer추상체를 파라미터로 받았는데, 개별setter를 사용해야하니, 물어보고 다운캐스팅 할 수 밖에 없는 구조 | . . | | . paper(1)에게 일을 시키면서, Programer(N)을 건네주었지만, 1:N관계가 유지되는 한, . . . | | | 시행착오 끝에 . 추상체vs추상체라면, N에게 물어보더라도 , 1에게는 시키지 않아야하는 구나 N(programmer)에서 1(Paper)를 받은 상태에서 1:1관계를 유지한체로 다른처리(제네릭)가 되어야하는구나. | . | 추상체vs추상체에서 instanceof를 제거하는 방법은 제네릭을 써야하는 구나 | |",
            "url": "blog.chojaeseong.com/object/2022/05/16/(object1-11)%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98%EC%84%B8%EA%B3%842_%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%9C%BC%EB%A1%9CLSP%EC%9C%84%EB%B0%98%EA%B7%B9%EB%B3%B5_%ED%81%B4%EB%9D%BC%EC%95%84%EC%9D%B4%EC%96%B8%ED%8A%B8(Director%EC%97%90%EC%84%9CMain%EA%B9%8C%EC%A7%80).html",
            "relUrl": "/object/2022/05/16/(object1-11)%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98%EC%84%B8%EA%B3%842_%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%9C%BC%EB%A1%9CLSP%EC%9C%84%EB%B0%98%EA%B7%B9%EB%B3%B5_%ED%81%B4%EB%9D%BC%EC%95%84%EC%9D%B4%EC%96%B8%ED%8A%B8(Director%EC%97%90%EC%84%9CMain%EA%B9%8C%EC%A7%80).html",
            "date": " • May 16, 2022"
        }
        
    
  
    
        ,"post66": {
            "title": "OBJECT 10 객체설계4_개발자의세계1_LSP위반(코드스핏츠)",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . ch10. 개발자의 세계 . 개발자의 세계 . . 개발자는 IT회사내에서도 극히 희귀한 존재다. 개발자를 도구로 바라본다. (생각을 주면 프로그램으로 바꿔줄거야) | . | . Director . 디렉터가 하는 일을 추상레이어로 . . 악의 축 Director: 한국에선 잘 안쓰는 용어. 일본Director 미국, 한국PM | . . 디렉터가 하는 일: . Paper: 어디선가 지령서(기획서, Paper)를 받는다. Paper안의 사양서는 2가지 범주(Class)가 있고, 범주에 해당하는 프로젝트들을 수행할 것이다. . ServerClient : 1건, 서버+클라이언트 다 만든다. | Client: 2건, 클라이언트만 만든다. | . | Programmer: Director는 기획서 안의 사양서(1건, 2건)을 다 살펴본 뒤, 개발자들을 섭외해온다. . Programmer는 Paper(의 사양을 알아야 개발)를 기준으로 개발한다.(아는 관계 성립) 디렉터는 Paper와 Programmer를 잘 연결해서 프로젝트를 수행하는 것이다. | . | Programmer는 FrontEnd | BackEnd로 나뉜다. | . | . | . | . . Director가 바라보는 추상레이어는 Paper와 Programmer가 될 것이고 Paper와 Programmer가 각각 바라보는 추상레이어는 ServerClient/Client와 FrontEnd/BackEnd가 될 것이다. | . | . | . Paper . . Paper는 형으로서 아무것도 메소드가 없는 인터페이스로서의 형이다. 책에서는 인터페이스에 정의된 시그니쳐(추상메소드)를 오퍼레이터라 부름 그 오퍼레이션이 구상클래스에서 구현되는 것을 메소드라 부름 | 그렇다면, 인터페이스는 메소드를 가지는게 아니라 오퍼레이터를 가지는 것 | . | . | . Programmer . . Programmer는 외부에 프로그램을 만드는 인터페이스를 제공한다 . my) 인터페이스 속 오퍼레이터, 메소드는 외부에 인터페이스를 제공하는 역할을 한다. . | 팀장(PM, Director)이 &quot;()(Paper paper)기획서를 던져주면서) 프로그램 만들어!&quot;라고 명령할 수 있게끔 . 프로그래머들은… 팀장에게 기능을 제공해주는 책임을 가지므로 메소드makeProgram()을 제공한다. 이 때, 팀장이 기획서를 던져주면서 만들라고 하니, 인자를 던질 수 있게 기능 제공 | . | my) 인터페이스든, 클래스든, 외부에서 나를 쓰는 놈에게 기능을 제공하기 위해 메소드를 정의한다. | . . | . | . Client . . Paper라는 추상클래스를 기반으로 구상클래스 Client를 구현해보자. my) Paper나 Programmer는 각각의 공통점을 뽑아놓 상위개념 -&gt; 추상층이다. my) 실존하는 것들은 범주별로 impl해서 구현하고, 그 공통점을 가진 윗 개념은 추상클래스or인터페이스로 만들자. | . | . | Paper는 메소드가 없는 마커 인터페이스다. Client용 프로젝트를 만들고 싶어서 Class로 구현한다. | client의 사양서에 들어있어야하는 내용들을 필드와 메소드로 채운다. library와 language를 지정해주고 | 프로젝트 담당할 programmer를 할당받을 변수도 미리 만들어놓자. 개발자는 프로젝트 사양서 나오고, 나중에 할당되니, 초기화 없이 변수만 | . | 추후 투입될 programmer를 박아줄 특정필드setter인 setProgrammer(프로그래머객체)도 만들어준다. | . | 나중에 수십개의 필드가 추가 되어야할 것이다. | 나중에 생성자에서 만들어도 되는데, 지금은 일단 대입해서 필드 초기화 | . | . ServerClient . . 마찬가지로 server + client를 다 개발할 수 있도록 하는 사양서의 내용을 채운다. . 사용할 server | 랭귀지 앞/뒤 2개 | 프로그래머 앞/뒤 2명 프로그래머 setter 2개 | . | . | . FrontEnd . . language와 library를 인식해서 자기만의 프로그램을 만든다. Programmer를 구현해서 -&gt; makeProgram을 제공하는데, makeProgram내부에서 -&gt; 자신만의 makeFrontEndProgram ( Program )을 만드는 기능을 제공한다. | . | 던지는 paper를 받아들여서, paper속에 있는 language와 library를 세팅해준 다음 -&gt; 자신만의 프로그램을 만든다. 이 때, Paper는 마커인터페이스이므로 paper로부터는 어떠한 정보를 얻어낼 수 없다 | 마커인터페이스 paper를 구현한 Client에서 정보를 얻기 위해 다운캐스팅(=OCP어김)할 수 밖에 없는 상황이다. 다른 방법이 생각이 안날 것이다… | 대부분이 여기서 설계를 포기한다. 오늘의 핵심은 이 문제의 해결이다. 리스코프 치환 원칙을 어김 | OCP를 어김(부모자리에 자식이 들어갈 수 있다? 부모를 자식으로 바꿔야하는 상황에선.. 어기는 것이라고 함…) | . | SOLID원칙이나 설계원칙들을 배운다고 해서 이 문제를 해결할 순 없다. 저자가 강조하듯 코드로서 익혀야햐한다 | . | . | . | 마커인터페이스 paper를 객체로 받을 때 paper 구현체인 Client일 수도 있고, ServerClient이 들어갈 수도 있다. 바깥에서 Paper 구상체들이 늘어날때마다 if instanceof -&gt; (다운캐스팅) 분기 가 늘어나도록 코드수정해야하는 문제점 발생할 것이다. | else의 처리가 지금은 생략되어있지만, 필요하며.. 또 그 밑으로 추가될 수도 있다. | . | . | 그래도 paper -&gt; 구현체속 정보가 세팅되어야 -&gt; 자신만의 프로그램을 만들 수 있는 상황이다. | . BackEnd . . 백엔드 개발자도, 사정이 똑같다. 마커인터페이스 -&gt; 택1 구현체를 받아서 정보 받기 -&gt; 확인용으로 다운캐스팅 해야하는 상황 + else 등 코드 추가 수정이 이루어질 예정임 | . | 그래도 paper -&gt; 구현체속 정보가 세팅되어야 -&gt; 자신만의 프로그램을 만들 수 있는 상황이다. . | 개발자의 세계 핵심문제: Paper받아서 구현체로부터 정보 빼내야하는 상황 리스코프 치환 원칙을 어김 | OCP를 어김 = 다운캐스팅 해야함 프로그램이 굳어서 paper의 자식class(구상체)를 겁나서 못만들게 됨.(코드 수정해야함) Programmer를 구현한 모든 세부개발자들의 코드마다 if instanceof 분기를 수정해줘야함 | . | . | if를 제거해서 외부쪽 클라이언트쪽으로 옮기는게 좋다. | . | 여기서 문제 발생 paper가 다운캐스팅을 시도하고 있다. 그러면 이 클래스는 확장에 막혀있게 된다. 이런 문제를 해결하기 위해서는 코드로서 문제를 해결하기 위한 방법을 모색해야 한다. if는 goto를 일으켜서 런타임, 컴파일에러를 일으키지 않아 그래서 if나 swich를 쓰면 정적타입의 안정성을 잃어버리게 된다. | . | . Director . . 디렉터는 특정 프로젝트 이름(String)으로 특정 기획서 객체(Paper)들을 소유하기 위해 hashmap에 소유하고 있다. 빈 hashmap에 addProject 메소드로 더한다. (remove나.. edit 등은 일단X) | . | runProject()는 name으로 project의 paper를 꺼내는 데 **Paper는 마커인터페이스로 -&gt; 자식구현체Class들로 범주의 여러 종류가 정해져있으며 ** | paper로 꺼냈다면 -&gt; 구체적으로 어느 종류 사양서(client or serverclient)인지 모른다. if instanceof 분기로 종류마다 하나씩 분기를 만들어줘야하는 수고로움 -&gt; 유지보수시 수정 많음. | 만약, 해당종류라고 분기가 되었으면 (해당종류로 다운캐스팅)해야 마커에는 없던 기능들을 쓸 수 있다. ServerClient project = (ServerClient)paper; | . | . | 만약, ServerClient 사양서를 가졌다면 FE/BE 각각 프로그래머 변수를 만든 뒤 -&gt; set으로 세팅해준다. (프리랜서 seller개념? 차후 세팅할려면 빈변수-&gt;setter) | . | 각각의 개발자들한테, 자신만의 프로그램 만들라고 마커인터페이스를 다운캐스팅한 (ServerClient)project를 넘겨서 만들게 한다. 각각의 개발자들의 완성품이 Program으로 같다 | . | deploy해준다. | . | 만약, client프로그램이라면 (해당종류로 다운캐스팅)해야 마커에는 없던 기능들을 쓸 수 있다. Client project = (Client)paper; | . | 개발자 1명만 변수 만들고 -&gt; setter로 세팅해주고 -&gt; (자신만의X, 공통적인) 프로그램만들라고 시키고 -&gt; deploy | . | . Error . 추상체인 paper를 받아도, 특정 구상체인 Client paper만 내부분기(if instanceof)로 받아 세팅하던 FrontEnd개발자에게 ServerClient paper인 project를 넘겨봤자, language와 library를 세팅 못하기 때문에 엄한 결과(context에러)가 나온다. . Programmer중 FrontEnd 종류가 된 이상, Client로 다운캐스팅된 paper만 받아 처리(lang, lib 세팅)하도록 정의되어있다. FrontEnd | . | paper 종류에 따라 project가 가진 필드가 다르며, FE/BE개발자는 Client가 아닌 ServerClient paper만 처리하도록 설계된 상태다. . Client . . | ServerClient . . | . | if를 썼기 때문에 -&gt; 컴파일 에러가 안나고 내부에 문제가 숨어있게 된다. 모든 에러가 context에러로 빠져버렸다. | if -&gt; OCP원칙 파괴(다운캐스팅)로 끝나지않고 대부분의 에러가 context에러로 숨어버린다. goto를 써서 runtime에 죽지도 않고, compile에 걸리지도 않는 context에러 | 여러 case로 사람이 따로 판별해볼수 밖에 없다. | . | if -&gt; 다운캐스팅들이, 바깥에서 context에러를 일으킴. | . | SOLID 원칙 중에서도 설계상에서는 LSP와 OCP를 더 신경써야한다. . LSP와 OCP를 지키면, 나머지 3개도 다 지켜진다 | LSP는 지키기가 너무 힘들다. 심지어 Paper는 마커인터페이스로, 구상체들은 다 자기만의 메소드를 가질텐데, abc -&gt; abcd 확장성LSP가 어렵다고 했지만, 여기서는 구상체들 각각이 0 -&gt; d에 해당하는 경우이므로 | d의 문제를 해결하도록 습관적으로 연습하자 | . | . | . | LSP위반 시행착오 . . 1. LSP위반 지점- 일반적으로 정보없는 추상층Paper에 의해 시작: FrontEnd . . LSP를 위반하는 곳은 빨간네모코드이다. 이것에 의해 다운캐스팅 할 수 밖에 없었다. LSP: 우리는 자식형을 &lt;— 부모형이 대신해도 충분해 부모형이 충분하지 못해서LSP위반 -&gt; if -&gt; 다운캐스팅 -&gt; OCP 위반 부모가 자식에게만 있는 d가 없거나 | 부모가 아예 메소드가 비어있는 마커인터페이스 등 자식이 확장형일 때 | 왜 OCP위반(다운캐스팅)했냐? -&gt; 항상 선행되는 LSP위반(부모가 자식을 대체못함) | . | . | paper(부모)가 충분했으면 = LSP 만족시켰으면 -&gt; 다운캐스팅 할 일이 없는데 paper가 paper로서 충분치 않았다.(부모가 자식 대신하는 역할 = LSP 만족X) -&gt; if instanceof -&gt; 다운캐스팅 -&gt; OCP 위반 | . | . | . . 확장형LSP -&gt; d()의 문제해결은, 6장에서 배운 헐리우드 원칙 = 묻지말고 시켜라이ㄷ다. . &quot;얘가 다운캐스팅 하는 이유는, 얘가 추상형(paper형)에 대해 구상 지식(client형의 지식)을 가지려 했기 때문이야&quot; 복잡한 상황은 내가 아닌, 외부로 추상화를 떠밀어야하는데, 그 방법이 헐리우드 원칙 | . | 내가 Paper한테 너무 많이 물어봤다 -&gt; 물어보지 말랬는데, 첨부터 다 물어보고 있다. &quot;paper야 너 혹시 Client형이니?&quot; &quot;Client라면 이런 Data들 가지고 있지 않니?&quot; | . | 물어보는 순간부터 OCP위반(다운캐스팅 시작) | my) paper 에게 물어보다 = if절 (주체로 들어가) paper야 instanceof Client 이니? + 가지고있으면 변수로 꺼내줄래? | . | . | 물어보지 않으면 OCP 위반(다운캐스팅) 안할 수 있다. + 시킬때 는 나(this)만 들어가는 것 같지만, 그 외에 같은 레벨의 구상체(BE)도 들어가야하는 공통코드라면 -&gt; 추상체인 (Programmer)로 정의될 것이다. . &quot;paper야 &lt;~이니? 맞으면 변수에 꺼내줄래?&gt; 대신 니가 [나에게] 데이터를 set해줘&quot;를 set으로 시킨다. -&gt; paper.setData( this ) . | my) if + 변수로 정보꺼내보며 물어보지말고, setXXX( this )로 나에게 세팅해줘(XXXX(this))를 set으로 시킨다. . . 나에게 ( this ) | 시킨다. setXXXX (this) | cf) 시키려면 해줄 사람이 메소드로 기능을 제공해줘야한다 -&gt; 메소드로 만들기 개발자야, paper 던져줄테니, 프로그램 만들어줘 Program makeProgram(Paper paper) | . | . | . | setData( this ) 의 인자는 나에게 자리에는 FrontEnd(구상적인)가 오든지, Programmer(추상적인)가 올 것인데, 딱히 관심없다. -&gt; 미뤘다. . paper가 뭔가를 하는데 this = 나에게 = 언어 특징상 상위(추상적인) Programmer든, 하위(구체적인) FE/BE이든 누구든지 올 수 있으며, 참고적으로 return은 부모(상위, 추상적인) Programmer로 받아야한다. | 인자로 this를 사용한 순간 형(Type)이 무엇인지 물어보던 것도 미뤘다. -&gt; 알아서 인자의 특성상 상위-&gt;하위 모든 구상형들 모두 사용가능이므로 | 원래는 “if 너 무슨형이니?”부터 물어봤었고 + 속성값들도 다 물어봤었는데 | . | . | . | . . 물어보지 않고 시켜서 -&gt; paper에게 미룬 것들 정리 . paper에게, 무슨형인지 물어보는 것을 -&gt; this로 미룸 . | paper에게, 무슨 데이터가지고 있는지 물어보고 세팅하는 것 -&gt; setXXX로 미룸 . | | 앞으로 더 많은 paper(Programmer인듯?)의 자식class들이 생겨나도, this에 들어갈 수 있기 때문에, FrontEnd 클래스는 더이상 안고쳐도 된다. . | . 2. BackEnd와 같이볼 때 DRY위반으로 추상층에 공통로직올린: Programmer . . paper로 가기전에, backend를 보자. . 수정된 makeProgram() 내부에 있는 makeBackEndProgram()은 BE만의 특성이다. . . | 하지만, paper를 이용해서 [물어보지 않고 시키는] .setData( this )는 FE/BE 공통코드다 . | . | 인터페이스였던 Program을 -&gt; 추상클래스로 upgrade { 템플릿메소드 + 훅 }으로 변경해줘야한다. . 두 하위(자식)범주(클래스)에 공통코드 + 각자의 코드 -&gt; 템플릿메소드 + 훅으로 각자코드 | DRY원칙에 의해 공통코드가 반복되는 것을 막기위해 &lt;로직없는 인터페이스&gt; —&gt; &lt;공통로직을 가진 추상클래스&gt;로 upgrade 왜 우리가 처음엔 인터페이스로 시작했다가 -&gt; 중간에 추상클래스로 바뀌는 이유는 DRY원칙 때문이다. | . | 로직이 없던 인터페이스 | 공통코드는 템플릿메소드 + 각 구상코드의 고유 코드가 들어가도록 훅을 가진 추상클래스 FE/BE 공통코드 getProgram() | 개벌 고유코드를 정의해줄 들어갈 (코드없는 메소드)훅 makeProgram() | . | . | 공통코드를 중복제거 하기 위해서는 인터페이스 -&gt; 추상클래스 공통템플릿 + 훅으로 바뀌는 경우가 많음을 생각하자. . 템플릿 메소드 패턴은 객체지향에서 중복발견시마다 쓰이니, 엄청 자주 쓰인다. 인터페이스로 설계 -&gt; 중복발견해서 템플릿메소드를 가진 추상클래스로 바꾸는 것은 밥먹듯이 하는 일 | . | 만약, 공통코드가 아니다. (어떤 프로그래머Class는 paper.setData안한다 ) -&gt; 다시 인터페이스로 바꾸면 된다. | . | . 3. 추상층에겐 말고 로 떠넘긴: Paper . . 추상레이어 = 공통로직에서 .setData( 나에게 )를 호출하는 이상은 공통로직을 그대로 가져가는 구상층인 FE에서 .setData( 나에게 )로 , BE도 .setData( 나에게 )로 부를 것이다. | 그러려면, setData()의 인자는 추상형(FE/BE의 추상형 -&gt; Programmer)으로 정의해야한다. 하위(FE)를 받으면.. 다른 하위(BE)는 사용못함.. | . | . | programmer도 abc(공통로직)은 거의 없었다. -&gt; 구상층의 공통점은 아주 조금이다. paper도 마찬가지다. 추상층으로서 abc공통로직은 아주 조금이이며 이게 정상이다. 추상층인 인터페이스, 추상클래스가 하는일은 진짜 극 소수이다. | 구상층(FrontEnd, BackEnd)의 대부분은 d()코드로 차이점 코드들이 대부분이다. | . | . | paper도 마커 인터페이스라서, 정보가 없다( 추상클래스라도 공통로직은 조금인데 이건 아예 없다) 다운캐스팅해서 -&gt; 구상층으로 가서 정보를 물었었다. | **Programmer쪽에서 OCP를 지키려고, 정보물음의 대상인 Paper에게 시켜서 ** Paper내부에서 정보를 받으라고 밀어버렸다. Paper도 정보가 없는 놈이라 -&gt; Paper의 구상층들에게 구현하도록 다시 민다. | . | . | . | . 4. 시 모든 대상에게 하기 위해 을 줬더니, 정의시 전과하여 발생: Client . . programmer가 물어봐서 받기( if instance + 변수받기)를 paper에게 시켜서 꽂기 떠넘겼는데 paper도 정보가 없는 인터페이스다 -&gt; 자연스럽게 구상층 Client에게 `물어봐서 떠넘긴다. . 물어보는 로직자체는 안사라진다 -&gt; Programmer - Paper - Client로 넘어왔다. | .setData(Programmer programmer)가 makeProgram(Paper paper)가 일어켰던 context에러를 일으킬 것이다. 이쯤에서 개발자들이 포기한다. 끙끙거리면서 Programmer를 개선시켰으나, 다음날 Paper에서 같은 문제가 또 발생해서 포기함 | if instanceof 로 다운캐스팅하면서 물어보기 &amp; 구상층은 절대적으로 n개로 정해졌다고 합리화해버린다.(더이상 안늘어나므로 물어보기 써도된다고 합리화) | . | . | . | LSP 해소방법이 시켜서 꽂기라서 시켰더니 . 꽂을 때도 &lt;다운캐스팅해서 꽂는기능이 있는지 물어보기&gt;의 문제가 생겼다. . . | 추상층끼리만 대화하고, 구상층끼리는 완전히 격리되서 모르게 설계 = 잘 설계되었음에도 불구하고, **가 계속 떠넘겨진다.** . . 추상층이 포함하는 내용(공통로직)이 일반적으로 적어서 -&gt; 추상층에 정보가 적다 -&gt; 다운캐스팅해서 물어볼 수 밖에 없는게 일반적이기 때문이다. | . | 추상층인 discountPolicy와 discountCondition의 메소드 = 공통로직 abc() . 구상층도 abc() 공통로직만 가지고 있음 -&gt; 추상층이 구상층을 풀커버 가능(비현실적) 원래는 구상층에 d()가 대부분이어야한다. | . | 여기 예제에서 구상층 ServerClient와 Client의 공통로직은 아예 없다 setFE+setBE vs set프로그래머 | 우리가 알 수 있는 공통점이라고는 == 공통 추상층 == 형(Programmer를 구현, 상속한 구상층들) 밖에 없다 이게 정상이다. | 자식들의 공통점은 없다고 보면 된다. | 가장 좋은 인터페이스(공통점을 올려 추상화한 것)은 메소드(공통로직)가 없는 것이라고 이야기 할 정도.. | . | . | . | . | 공통점이 없을 게 뻔한데, 여기다 메소드들을 다 정의했다? -&gt; 성급화 추상화 -&gt; 그냥 공통로직(점)을 올린 추상층 인터페이스or추상클래스는 메소드가 없어야 or &lt;메소드 1개이하&gt;여야 정상 . 2개이상의 메소드가 있는 인터페이스, 추상클래스 -&gt; 성급한 추상화 | 근데, 성급한 추상화를 안하려고 &lt;공통로직&gt;=메소드가 적게 만들었지만 -&gt; 그로 인해 LSP위반으로 -&gt; 공통로직이 너무 정보가 없어서 다운캐스팅해야하는 상황이 발생 | 어쩌라는 거지? | . | 물어보는 애를 LSP, OCP를 없애기 위해서 시켰더니 -&gt; 핑퐁으로 주고받는 결과밖에 못얻었다 . | . 5. 더 심각한 문제: ServerClient . . setData( this )로 시켜서 (Programmer programmer)를 꽂을 때, . 구상층 ServerClient입장에서 들어오는 programmer가 무조건 2개이상(n개를 대응해야한다)이다. . 관계역전 후 시킨 paper쪽에서, 다 받기 위해 progammer를 알게 시켰더니(그림 설계상 위배된 화살표 반대방향) | . . | 관계역전 전에는 . 구상층 BackEnd입장에서 들어오는 paper가 1개만 들어온다. | . | . | Client와 비교해서는 . Client는 programmer 한명만 대응하는 setData였지만 | ServerClient는 여러명의 programmer를 if로 나눠서 대응하여 책임이 훨씬 높아진 상태가 된다. | 결론적으로, 관계역전 전(programmer가 해결)보다 난이도가 높은 일이 되어버렸다. 1:M 책임(Paper에게 전과하여 다운캐스팅) 보다 1:1 책임(Programmer가 해결)이 더 쉽다 1:M 매칭은 더 일반화된 코드가 필요해서 더 어려운문제가 된다. | 다운캐스팅은 안하는게 좋지만, 누가 다운캐스팅을 가져가냐에 따라 난이도가 결정된다. | . | . | . | . 6. 외부 객체 메세지를 받는 이상, if 분기는 외부context관점의 case들까지 다 처리해야하는데: Client . . Client 프로젝트는 Paper의 setData()를 받아서 . set시킬 메소드를 제공하는 FrontEnd 개발자인지 만 확인한 뒤 처리했다. 얘는 지금 BackEnd 개발자는 처리를 아예 안하고 있다. | . | if로 짜지말라고 하는 이유는 -&gt; 우리는 모든 Case를 다 알 수 없다. 매 case를 if분기에 다 넣어야하는데 | Client 클래스를 짜다보면, Client관점에서 FrontEnd만 챙기는 오류를 범하기 때문 작성중인 Class관점만 생각 -&gt; 다른 case를 안다루어도 된다고 생각하는 오류 | . | . | java를 비롯한 모든 랭기지들은, 함수의 위치에 따라 메소드들이나 context가 다뀌는 문법을 사용한다 특정 위치 (Client class내부)에 함수를 넣음으로써 -&gt; 그 instance.(내부this.)에서 호출할 것이라고 생각하고 짠다. | 즉, 보다 일반적인 상황이 아니라, 위치상의 context에 맞게 짜려고 한다. | . | . | 그러나, 인자에 메세지로 넘어온 객체 (Programmer programmer)로서 외부와 통신하고 있는 이상 -&gt; 외부에 영향 받는 이상 . client코드에서 호출하는 외부 context까지 다 파악한 상태여야만 내부 if 모든 case를 파악할 수 있다 Client class입장에서만 짜지말고, 외부에서 호출할 때 외부 context까지 다 생각해야한다. 측, FrontEnd만 들어온다가 아니라, BackEnd로서 programmer가 들어올 수도 있으며 그 경우에도 처리를 해야한다. | . | . | 메소드의 생성 이유: 남(외부 클라코드)이 시키도록 서비스 제공하는 것 **외부 클라 코드가 이 메소드를 어떻게 쓰는지, 모든 경우의 수를 생각하면서 메소드 짜기 ** 형태가 특정 class안에 있다고 해서, 그 class관점에서만 짜면 안된다. | . | . | . | 가둬지는 문법체계는 조심해라 . test case를 최대한 많이 짜낸다. | 외부 클라이언트 측면에서 이렇게 많이 부르는구나를 알고나서 | 메소드를 짠다. | . | . 7. 시행착오 교훈 . 한쪽 Class(Programmer -&gt; Paper로 문제 넘김)를 LSP, OCP지키도록 바꾼다 하더라도 추상페이퍼까지 이쁜데도 불구하고 | . | 받아준 쪽에서 문제가 옮겨갔을 뿐이지 해결되진 않았다. |",
            "url": "blog.chojaeseong.com/object/2022/05/15/(object1-10)%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98%EC%84%B8%EA%B3%841_LSP%EC%9C%84%EB%B0%98%EC%8B%9C%ED%96%89%EC%B0%A9%EC%98%A4.html",
            "relUrl": "/object/2022/05/15/(object1-10)%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98%EC%84%B8%EA%B3%841_LSP%EC%9C%84%EB%B0%98%EC%8B%9C%ED%96%89%EC%B0%A9%EC%98%A4.html",
            "date": " • May 15, 2022"
        }
        
    
  
    
        ,"post67": {
            "title": "OBJECT 09 LSP 위반(코드스핏츠)",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . ch9. 리스코프 치환원칙 for 헐리우드 원칙(묻지말고 시켜) . 책 추천: 객체 지향과 디자인 패턴(최범균 저) 오브젝트에서 배운 내용을 더 얇게 잘 정리함 | 뜬그룸잡는 코드없이 실무적으로 잘 가르켜 준다고 함 | . | 오브젝트 책 6장의 내용 나갈 것임 디미터의 원칙(최소지식 = 아는 놈으로 직거래만 하자) | 헐리우드 원칙((걔는 계속 변하니까)묻지마(받아서 할려고하지마) 그냥 시켜) | . | 객체지향에 실패하는 이유: 헐리우드원칙: 물어보기 때문에 실패한다 -&gt; 최대한 시키려고 하자 | 즉, 객체return을 요구하는 method()를 만들지말자. 받아서 뭐 하려고하는 주도권을 버리자. 물어본다 = 받아서 처리한다 -&gt; 변화시 필연적으로 나도 영향을 받는다. | 알아서 하라고 떤지자. 묻지마. 객체는 계속 변해. 니가 알고 있던 걔가 아니다. | . | . | 디미터, 헐리우드 2 원칙은 객체지향이라기 보다 수정에 강한 코드를 만들어낸다. 이 2 원칙과 밀접한 관계를 가지는 것이 SOLID원칙 중 리스코프 치환, 개방폐쇄 2 원칙이다. LSP, OCP를 지키려면, 헐리우드원칙을 사용할 수 밖에 없다. | . | 코드로 배워보자. | . | . LSP . . 리스코프 치환 원칙: 자식 형으로 부모 형(자리에)을 안전하게 대치할 수 있다. 지난번 공부 부모CLASS형 자리에는 자식Class형을 집어넣어서 원칙을 지키는지 판단 ex&gt; 생물-숨쉰다()다리로이동한다() -&gt; 아메바 | . | 그렇지 않을 땐, 부모class(추상층의) 메소드를 따로 빼내서 자식들의 공통점만 가지게 수정한다 | 추상층을 어떻게 잘만들까? 어떻게 추상층이 함부러 나대지 않게 만들까? | . | 상속을 지원하므로 당연한 얘기 같지만, 그렇지 않다. | . | . 어떤 구상클래스들의 메소드가 공통이면 -&gt; 공통메소드를 추상클래스(or인터페이스)로 뽑아낼 수 있다. 이것을 추상화라 한다. | . | 그런데 이런 것은 대부분 성급한 추상화다. 예를들면, 공통인줄만 알았는데, 다른 구상클래스에는 존재 하지 않은 메소드c()로 바뀔 수 있기 때문이다. | . | 대부분의 개발자들은 귀찮아서 fake c()를 만들어서, 강제로 공통메소드로 주입시킨다 하지만 c()를 강제로 넣은 순간 리스코프 치환 원칙 위배이다. fake c()를 집어넣는 것 때문에 숨겨진 context 버그가 일어나기 때문 | . | fake c()를 만들지말고, 일부공통인 메소드 c()를 구상하는 새로운 추상층을 만들고, 전체공통 a()b() 추상층을 따로 두어서 리스코프 치환 원칙을 만족시킨다. | 리스코프 치환 원칙은 위의 예처럼 스펙(공통메소드)가 줄어들 때 유용하다 즉, 새로나온 녀석이 공통점이 줄어든체로 등장하면 굉장히 쓸모이다. | . | 그렇다면, 스펙(공통메소드)가 늘어나는 경우는 어떨까? 공통점을 다 추상화된 상태인데? 리스코프 치환 원칙은 지킨 상태다. 혼자 늘어난 d()는 어떻게 할까? 이것이 바로 다운캐스팅을 일으키는 (=LSP을 위배시키는) 코드다. 다운캐스팅을 쓰는 순간 OCP도 자동으로 망가진다. | . | 다운캐스팅없이는 늘어날때는 쉽지 않다. | 열심히 설계했는데도, instanceof 와 다운캐스팅이 넘쳐나는 이유이다. | . | 언어적인 수단으로 제네릭을 이용해서 이 문제를 해결한다. 저번시간에는 형을 인식하는 제네릭 | 이번에는 리스코프 치환 원칙이 확장형으로 일어날 때, 확장하여 다운캐스팅을 방지하는 제네릭을 공부할 것이다. | . | . | . | . Generic for 확장형 LSP 해결 . . 코드를 LSP를 시도하면서 삽질하고, 제네릭으로 바꿔보면서, OCP원칙을 지켜가는 과정을 재해석 해보자. | . 개발자의 세계 . . 개발자는 IT회사내에서도 극히 희귀한 존재다. 개발자를 도구로 바라본다. (생각을 주면 프로그램으로 바꿔줄거야) | . | .",
            "url": "blog.chojaeseong.com/object/2022/05/14/(object1-9)LSP%EC%9C%84%EB%B0%98_2%EA%B0%80%EC%A7%80_%EA%B2%BD%EC%9A%B0.html",
            "relUrl": "/object/2022/05/14/(object1-9)LSP%EC%9C%84%EB%B0%98_2%EA%B0%80%EC%A7%80_%EA%B2%BD%EC%9A%B0.html",
            "date": " • May 14, 2022"
        }
        
    
  
    
        ,"post68": {
            "title": "github command shortcut",
            "content": "Repo 탐색 . searchbox(/) . / : 메인화면 왼쪽 상단 searchbox . . | . file finder(T) . T: repo 내에서 file finder 열기 . 일일히 파일클릭해서 찾아들어가기 안해도 됨 . . | . | . command pallete(ctrl + k) -&gt; #, &gt;, tab, enter . ctrl+K: 커맨드 팔렛 . repo들 다 확인 가능 . | enter시 해당 레포로 완전 이동 . | 팔렛트 유지하려면 tab으로 진입 . | 모두 지운 상태(계정명까지)에서 #을 누르면 PR이 나옴 . 계정 있는 상태 is2js / #하면 내가 참여한 PR/merge/issue | . . | &gt; : github command들 나옴 . . | . | . 단축키 확인 (?) . PR관련 . hide comments (i) . i를 통해 PR &gt; Files changed에서 코멘트 숨기기 . . . | . 닷닷닷&gt; view file 상태 . line jump(L) . . git blame 모드(B) . . 마우스를 올리면, 커밋내역이 자세히 보인다 | . . code 공유 . permalink 만들기 . 01 view file상태 &gt; line 좌측 클릭(닷닷닷) . . 02 shift + 클릭으로 여러line 만들기 . . 03 주소창 or Copy permalink를 영구link(canonical)로 변경하기(Y) . 이미 default로 적용된 듯? | 파일경로 주소 -&gt; github commit기반의 주소 파일명이 변경되어도 계속 주소가 유지 된다. | . | . . 04 팔렛트 &gt; 관심 레포 &gt; &gt; issue (PR or issue 속 readme, markdown )에 link 복붙시 코드스니펫도 제공된다. . . . . . . 마크다운 팁 . kbd 태그 / 백틱 + hexcode#hexcode / diff . . . . . 계정 주소 뒤에 .png . . . . 그외 . or 주소맨앞에 vscode.dev/추가해서 enter . comment 남기기 . 모든 comment 모아보기 . . .",
            "url": "blog.chojaeseong.com/git/github/2022/05/12/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%8B%A8%EC%B6%95%ED%82%A4.html",
            "relUrl": "/git/github/2022/05/12/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%8B%A8%EC%B6%95%ED%82%A4.html",
            "date": " • May 12, 2022"
        }
        
    
  
    
        ,"post69": {
            "title": "OBJECT 08 객체설계3_Theater_with_SOLID(코드스핏츠)",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . ch8. theater_with_solid . Movie . . 책하고 동일하게 policy를 단일로 1개를 가지고 있다. final로 가지고 있다? | calculateFee()할때는 screening, count를 받아서 policy에게 calculateFee를 위임하는데, 추가로 + Movie속 fee도 같이 건네줘야한다 | . | . DiscountPolicy . . discountpolicy는 hashSet을 통해 다수의 condition을 소유하고 있다. (중간에 유연하게 더 받아들일 수 있도록)생성자에서 받지 않고, addCondition()메소드로 빈Set에서부터 추가/삭제 하려고 하는 것 같다 runtime context를 중요하게 생각(my) condition을 유연하게 보유 )한다면, 책 2장의 형태로는 안된다. | . | . | 2번째 문제는, 중간에 유연하게 원소를 더 받아들일 수 있는 conditions(hashset)을 가지는데, Movie가 final로 선언한 policy지만 다른 policy로 바꿔치울 때, 내부 conditions는 어떻게 유지할 것인가? . 5장에서, Movie가 policy를 가진 장점 -&gt; Movie가 중간에 policy를 바꿀 수 있다. | 그러나 policy와 condition은 별도의 객체다 -&gt; policy를 바꿀 때, 기존 condition을 유지하는 방법은? 내가 AmountPolicy -&gt; PercentPolicy로 바꿀 때, AmountPolicy내부에 있는 conditions를 유지하는 방법은? | . | . | **특정policy에게 &quot;나의 conditions를 물려줄게&quot; ** 물려준다=객체내부정보를 준다=객체내부에서만 가능하다 = 본인 내장을 까는 것이기 때문에 Policy클래스 내부에서 copyCondition( 새로운policy) -&gt; 새로운policy.addAll(내장conditions)을 통해 넘겨준다. | . | conditions은 Movie에 걸려있는 것이다. 근데, conditions를 소유하고 있는 policy를 바꿀 때, movie에게 그대로 넘겨줘야하니, 바뀐policy에게 내장을까서 넘겨주는 메소드 copyConditions를 만드는 것이다. 원래는 Movie꺼지만, Movie의 지식을 줄이기 위해서 -&gt; policy에게 위임했던 condition Movie가 policy와 condition을 둘다 아는 것보다 policy만 아는 것이 더 낫다고 판단했었다. 근데, policy를 교체한다면, 기존 condition을 다시 만들어서 넣어줘야하는 문제가 생겼다. 다시 만들면 안된다. 객체는 식별자를 통해 구분함. 값만 똑같이 만든다고 해서 기존 condition이 아님. | 기존 condition그대로 유지해야하므로 내장에서 같은Classr객체BUT바뀐policy객체를 받아서, 빈set에 기존꺼 add해주기 | 기존policy.copyCondition( 바뀐policy ) 바뀐policy.빈conditions.addAll(기존conditions) | . | . | . | . | 같은종류의 객체끼리는 이렇게 내장까서 복사가 가능하다. | . | 원래는 Movie가 가져야할 condition다. 하지만, policy가 condition을 가져왔기 때문에, policy교체시 condition도 옮겨줘야하는 책임이 딸려왔다. | 객체에서, 소유권을 함부러 이전하면 그 여파는 반드시 온다. 아무 관계 없는 policy와 condition을 한줄로 엮어놔서… 책에서 문제가 발생한 것. | . | . | . | calculateFee는 condition을 돌면서 계산하면 된다. . NosalePolicy는 condition을 무시하고 계산해야한다. . Set안에 아무것도 안들어와있으면 -&gt; for돌린 것은 무시되니 -&gt; return이 for문 밖에서도 있게한다. . . | . | . | 현재까지 DiscountPolicy는 추상클래스이고 addCondition, copyCondition은 템플릿메소드이고 | calculateFee같은 구상클래스에 위임한 훅 이 발동한다. | . | 템플릿 메소드패턴은 언제 많이쓰나 구현층에서 공통적으로 사용되는 로직이나 상태가 있음을 확신할 때 | 수많은 policy가 나올 것이지만, 어느정도 형태와 로직이 공통일 때, 형이 한정되어있을 때 | . | 전략패턴은 인터페이스로서의 메소드 calculateFee()만 존재할 때 전략패턴은 인터페이스만 공통 -&gt; 구현이나 상태의 공통점이 없다.(각기 다르게 구현되는 유연함을 가질 때) 만약 템플릿메소드를 써야할 곳에 전략패턴을 쓴다면.. 템플릿메소드부분을 모두 들고 다녀야한다 -&gt; 버그 많아지고 수정할부분도 여러군데 | . | . | . | 만약, 템플릿메소드라고 생각했는데, 공통아닌 policy가 발견되었다? -&gt; 전략패턴으로 바꿔줘야한다. | . AmountPolicy, PercentPolicy . . 템플릿메소드패턴의 DiscountPolicy를 상속받았다면 calculateFee()에 쓰일 추가적으로 amount만 생성자에서 받아들여주고 | 자식마다 달라지는 훅의 calculateFee()부분만 @오버라이드 해서 구현해주면 된다. | . | . . PercentPolicy도 마찬가지다. | . NosalePolicy . . percent는 오타 . public class NosalePolicy extends DiscountPolicy { @Override public final Money calculateFee(Money fee) { return fee; } } . 그냥 fee를 받으면 그대로 fee를 리턴한 것이다. | 추상클래스 DiscountPolicy를 보면, condition을 가지고 있어서, 부모의 로직에서의 for문에 걸려 calculateFee(fee) -&gt; 훅 -&gt; return fee를 하나 | 컨디션 없이 return fee를 하나 동일하게 로직이 수행된다. | . | . . 리스코프 치환 원칙에 의해서, if자식형을 찾지않고 부모형인 DiscountPolicy수준에서 찾는데 성공했다(?) **로직이 if분기되지 않았다.** | conditions이 있든/없든 Nosale이 Amount, Percent와 동일한 로직으로 일반화(return fee만)되었다. | . | . | . DiscountCondition . . 추상클래스에선 할일이 없다. 구상클래스에선 메소드 1개만 구상하면 되니 좋은 인터페이스다. | . | . PeriodCondition . . when받아서 when이 일치하는지 확인해주면 된다. | . SequenceCondition . . 마찬가지로 sequence 받아서 일치하는지 보면 된다. | . TicketSeller . . TicketSeller는 customer+theater+movie+screening+count 5개를 인자로 받았다. 인자로 받았다 = Dependency로서 가지고 있다 | 5개의 인자 = 지식들을 형으로 강제하면 좋은데, Seller는 TickeyOffice에게 해당 정보를 넘겨줘야하니, 기존 형을 모르게할 수가 없다. | 도메인상, customer는 주문시 seller인 나에게 5개 정보를 다보낸다. 코드상으로는 5개 정보에 대해 dependency가 있지만, 실제로 이 dependency(theater, movie, screening)를 사용하면 안된다. 왜? 중개용으로서 Customer -&gt; -&gt; TicketOffice에게 건네주기 위해 받았을 뿐 **중개 = 나와 계약한 ticketOffice = 원래 의존성 있던 객체가 .reserve()에 사용하도록 전달만해줌. ** | 나한테 원래 의존성이 없던 , 인자로만 받았던 movie가 사용해선 인자로 넘어온 dependency들을 사용해선 안된다. | . | dependency 받은 목적이 사용이 아니라 전달하기위함이었다. java에서는 표현할 능력이 없음. | . | . | . | 직접사용하는 코드 movie.calculateFee( screening, count)는 movie에게 중개용, 전달용 dependency를 메세지로 전달해서 사용하고 있는 오류 를 발생시키고 있다. 도메인상 어쩔수 없이(전달 목적으로) 받은 dependency를 사용하게 되면, 겉잡을 수 없게 된다. | . | . | . . 빨간줄이 잘못되었다는 것을 깨달아야한다. . 최소지식의 원칙 = 디미터의 원칙으로 바꿔줘야한다. | 나와 직접적인 관계가 있는 TicketOffice에게 맡긴다 | . . 직접적인 관계가 없던 movie가 하던 것을 -&gt; ticketOffice에게 시킴 theater, movie, screening의 변화에 안전해졌다. | 중개용 인자 (= 직접관계 객체라면, 걔만 사용가능)를 중개용으로만 사용되게 했다면, 인자들에 대한 변화에 안전 = dependency가 사라짐 | . | . | . TicketOffice . . movie의 대한 지식(직접관계가) 원래 있던 TicketOffice는 calculateFee()를 내부에서 movie에게 시킬 수 있게 된다. | 결국엔 movie.calculateFee()를 할 예정이지만, 직접 관계있는 놈에서 실행시키도록 돌리는 wrapping method를 TicketSeller에게 적용했던 것이다. | . | 그렇게 수정하다보니, 코드중복이 떠서 하나는 내부메소드를 사용하게 한다. | .",
            "url": "blog.chojaeseong.com/object/2022/05/12/(object1-8)theater_with_solid_%EA%B0%9D%EC%B2%B4%EC%84%A4%EA%B3%843.html",
            "relUrl": "/object/2022/05/12/(object1-8)theater_with_solid_%EA%B0%9D%EC%B2%B4%EC%84%A4%EA%B3%843.html",
            "date": " • May 12, 2022"
        }
        
    
  
    
        ,"post70": {
            "title": "OBJECT 07 SOLID 5원칙 + DDHL + GRAPS 9패턴(코드스핏츠)",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . ch7. SOLID 5원칙과 GRASP 9패턴 . 알려진 기본 설계요령 5원칙: SOLID . 책 6~8장 . | 1940년대 대부분의 개발이론이 다 나왔다. | 1960년대 대부분의 이론 다 완성 | 1980년대 완성된 이론을 -&gt; 차근차근 실현단계 | 100년의 역사지만, 처음부터 고등학문(천재들이 만들어서) 평민들은 공부할 수가 없음 | 1980년대부터 평민의 언어로 바꾸기 시작 우리가 아는 문건들 -&gt; 평민 언어로 쉬운 것만 추린 것 | 그것이 5개 SOLID원칙 | . | . | . SRP . SRP( 단일책임원칙, Single responsibility) . | 책임: 오브젝트 책 p117 srp에서의 책임: 코드의 변화하는(수정하는) 이유가 1개가 되도록 객체를 설계해라 코드 수정 이유에 가장 좋은 방법: 변화율(코드의 변동 주기(시간)+이유)에 따라서 분리한다 “이 객체는 이 때 + 이래서 변해 -&gt; 나눠줘야겠어 -&gt; 변하는 이유를 &lt;변화율:이때+이래서 변함&gt;로 선택 “ | seller와 office를 나눈(분리시킨) 이유도 마찬가지 고객에게 갈취하는 역할: seller | 티켓을 정산하는 역할: office는 다를 거야. 이러한 이유로 서로 다르게 변할거야. | . | . | . | . | 쓸데 없는 책임을 벗어나게 하는 방법: SRP는 spring API처리에서 많이 언급된다. 똑같이 트랜잭션처리+로그처리가 어느 클래스든 공통로직으로 들어가있다. 이 공통로직이 되어있다면, 공통로직 수정 -&gt; 수많은 클래스 같이 수정해야하는 문제 | . | 클래스 변화 이유: 도메인이어야하는데, 일반로직까지 같이 가지고 있기 때문에 문제가 생긴다. 변화하는 이유 : 도메인이어야한다. -&gt; 여러 이유(+일반로직까지)를 가지고 있다. | cf) 공통로직 -&gt; 유틸리티 클래스로 빼면 된다. | . | . | . | SRP가 제대로 지켜지 않을 때: 1가지 변화 이유로 수정시작 -&gt; 수많은 클래스를 고치게 되는 문제점(산탄총 수술, shotgun surgery) | 변화는 이유: trigger는 1개가 되도록 -&gt; 클래스도 거기에 맞게 나눠서 구축하자 | . | . OCP . OCP(개방폐쇄원칙, Open and Close) 다형성이라 생각해도 무관하다. 구현보다는 인터페이스를 참조하자. | open:확장이 열려있다. / close: 수정이 닫혀있다. a -&gt; b 직접 참조시 b의 수정 -&gt; a에도 충격 : close원칙에 위배 | b를 안고침 -&gt; a에도 변화X : a의 open원칙을 위배 안고쳤다 = 수정이나 확장에 열려있지 않다 | . | . | 직접참조 = 건들이면 망가지고 안건들이면 확장이 없음 | . | . | 직접참조를 피하면 OCP를 만족시키는 것이다. 포인터의 포인터: 포인터를 직접참조하지말자. | a -&gt; b의 외부 interface -&gt; 다양한 b 구현체orClass | . | . LSP . LSP(리스코프 치환 원칙, Liskov Substitusion, 업캐스팅 안전 때문에 존재) | **부모CLASS형 자리에는 자식Class형을 집어넣을 수 있다. ** -&gt; 그렇지 않을 땐, 부모class(추상층의) 메소드를 따로 빼내서 자식들의 공통점만 가지게 수정한다. | 모든 case를 다 알아아야하고, 공통점만 가지도록 -&gt; 구상화된 메소드는 인터페이스로 뺀다 | 이게 왜 원칙일까? | . | . . 추상층이 너무 구체적이면 구상층 구현에 문제가 생기므로 추상층을 어떻게 잘만들까? 어떻게 추상층이 함부러 나대지 않게 만들까?에 관한 얘기다 . | 추상층에 생물을 만들고, 메소드 2개 정의 . 숨을 쉰다 | 다리로 이동한다 | . | 구상층으로서 생물-&gt; 사람 / 생물-&gt; 타조를 구현하고 . 리스코프 치환 원칙에 따라, 부모자리에 자식을 넣어보자. | 지금까지는 어색하지 않다 사람이 숨을 쉰다. / 사람이 다리로 이동한다. | 타조가 숨을 쉰다. / 타조가 다리로 이동한다. | . | . | 문제는 다른 구상층들 중에서 발생한다 아메바, 독수리, 고래는 다리로 이동할 수 없다. . . 이러한 일은 왜 일어났을까? 추상층에 있는 다리로 이동한다 메소드가 | 앞으로 일어날 구상층의 확장에서 도메인을 반영할 수 없기 때문이다. | . | 너무 나댄 것이다. 욕심이 나지만.. 함부러 추상층에서 정의해선 안됬다. 사람, 타조만 보고선 -&gt; “어? 공통인데 추상화해서 추상층으로 빼면 좋지 않을까” 라고 욕심이 났다 | . | . | 위의 예에 따르면 리스코프 치환 원칙 = 추상층은 구상층의 확장을 모두 포용할 수 있는 교집합만을 가지고 있어야한다. . my) 여러 구상층들을 미리 생각해서 -&gt; 그것들의 교집합, 공통점만 추상층에 올리도록 해야한다. -&gt; 머리가 좋은 사람들만 할 수 있다. 다 파악해야한다. 그래서 어렵다. | 발견하자마자 추상층 메소드를 수정/제거할 수 있어야한다. | . . | 그럼 일부 구상층만 가지는 메소드는? -&gt; 인터페이스로 따로 빼놓고, 해당하는 구상층들만 추가 impl하게 한다 . . 추상층 - 생물 - 숨을 쉰다() 메소드 1개만 다리로 이동() -&gt; 인터페이스로 빼내기 | . | 구상층 생물만 구상하다가 -&gt; 해당하는 구상층만 다리이동()인터페이스 추가 impl | 나머지들은 생물만 구상 | . | . | . ISP . ISP(인터페이스 분리 원칙, Interface Segregation) . | 구상형으로 쓰지말고, 외부호출별(?) 모듈별(?) 접근하는 객체별(?) 외부 접근을 인터페이스(형)별로 분리시켜 엉뚱한 접근을 막는다.한다. . 안그럴시, 밖에서 엉뚱한 메소드를 호출하더라도 못막는다? | 엉뚱한 호출(메소드접근권한)을 막는 방법 : 형밖에 없다 -&gt; 인터페이스별로 분리한다 ex&gt; 모듈A야 너는 인터페이스A에 있는 메소드 2개만 바라봐 | ex&gt; 모듈B야 너는 인터페이스B에 있는 메소드 1개만 바라봐 | . | . | 예를 들어, 어떤 객체에 메소드가 6개가 있다. 아래와 같이 짜면 안된다. . . 왼쪽 2개 메소드 -&gt; 모듈A에서 사용 . | 가운데 1개 메소드 -&gt; 모듈B에서 사용 . | 오른쪽 1개 메소드 -&gt; 모듈C에서 사용 . | 나머지 2개 메소드 -&gt; 객체 자체에서 사용 . (멍청한) 우리가 Class를 짜면 항상 이런식으로 작성된다. 이렇게 하지말라는 말 -&gt; 왜? 인터페이스 분리가 안되어있다. | 메소드들이 모여있으면, 모듈A가 다른 엉뚱한 메소드들을 호출해도 못막는다. | . | . | 첫번째 ISP 방법 . . hasA방법: 각각을 모듈별로 인터페이스를 가지도록 객체자체를 나눈 뒤 -&gt; 모든 객체를 소유 | . | 두번째 ISP 방법 . 일반적인 인터페이스 모델방법: 인터페이스별로 메소드를 분리 | implements A, B, C -&gt; 각각의 메소드들 구현 | 자체메소드 2개 구현 | | . | 경우에 따라서 소유모델(hasA)와 인터페이스(형)모델을 섞어서 쓰기도 한다. . | . | . DIP . DIP(의존성 역전 원칙, Dependency Inversion, 다운캐스팅 금지) . . 어려운말로 나타내면 위와 같다. 고쳐 말하면 | 빨간색 말만 봐라보면 -&gt; 구상 클래스에 의존X 추상 인터페이스나 추상 클래스에 의존하자. 구상화된 형을 가리키는 코드가 있다면 -&gt; 추상화된 형으로 바꿔줘야한다. | 그러려면 4. 인터페이스 분리(ISP, 접근별로 인터페이스를 분리해놓고 impl하자)가 되어야하고 | 그러기 위해선 3. 업캐스팅 안전(LSP. 모든 case를 다 알아아야하고, 공통점만 가지도록 -&gt; 구상화된 메소드는 인터페이스로 뺀다) 도 되어야한다. 그래서 어렵다. | . | . | . | . 그외 설계요령 추가 4원칙 . . 로버티 마틴이 줄여서 말한게 5가지고 그 외에도 설계요령이 많다. 기본적으로 우린 머리가 나쁘니까 이렇게 해야해가 대부분이다. -&gt; 머리를 덜 쓰기 위해서 지켜야할 원칙 DI: 의존성 주입(Dependency Injection) 너흰 추론 불가능이야. | . | DRY: 중복방지(Don’t Repeat Yourself) 너흰 기억력이 엉망이야 | . | Hollywood Principle: 의존성 부패방지(헐리우드 원칙) 나한테 연락하지마. 내가 필요시 전화할테니 너 전번만 줘 | 묻지말고 시켜라. ex&gt; 묻지말고 500원만 줘. 물으면 많은 것들을 알게됨 ex&gt; 지갑사정을 보고 500원만 줘. 대출사정을 보고 500원만 줘. | 물어보지 않은 원칙 -&gt; 모두 시키기만 하자. 물어보지 말자. 물어본놈: 간첩 | . | . | 빨리 500원을 받아야하는데, 물어보는 순간 -&gt; 얘네 집안과 연동됨 -&gt; 의존성 부패 물어보는 순간 일반적으로 부패된다. | 객체지향에서는 물어보는 순간 -&gt; 대답용 객체가 온다(return). -&gt; 새 의존성이 추가되어버린다. | . | 응답기반으로 프로그램을 짜면 안된다. 대답이 올지 장담할 수 가 없다. 시키는 원칙을 지키자. getter(응답객체가 return됨)형은 나쁜 것. | . | Law of demeter: 디미터의 법칙 = 최소지식만 요구한다. 책 6장에서 다루는 디미터의 법칙 | classA안에 메소드 methodA가 가질 수 있는 최대 지식은? 필드 / 필드들의 형 / 자기가 만든 객체 / 인자로 넘어온 객체 / 지역변수들 | 나머지는 알면 안된다. 1차원 관계의 것들만 이용하자. 1차원이 안되면,직거래를 유도하도록 래핑메소드를 제공해서 1차원적으로 만들자. 인자로 넘어간 객체가 호출 메소드의 return값 | 필드에 있는 객체가 호출한 메소드의 return값 다 이용하지말자. | . | . | 직거래만 하자. 타고 가서 return되는 간접거래는 하지마. 간접적으로 아는 것들(걔의 집안사정)은 머리가 나빠서 기억못한다. 모르는게 최고 | . | 어기면 열차전복 (train wreck) 사고가 난다. A.B.C 다 연결되서 문제가 생기고 의존성이 생긴다. | . | . | . | . 의존성 부패방지와 최소지식의 모순 . . 지금 나오는 것을 암기 하지 않으면 책을 읽을때 이해가 안된다. 참고할정도도 아니고 총 9개 설계원칙은 코드짤 때 항상 머리속에서 벨리데이션 하고 있어야한다. solid + DDHL | . | 헐리우드 원칙(묻지말고=응답(return객체) 바라지말고, 시키자) | 디미터 원칙(최소지식만 요구 = 알고 있는 1차원의 것들만 직거래) | . | 헐리우드 원칙(시키기만) + 디미터 원칙(보이는 것만 직거래) 두 원칙을 지키다 보면 모순점이 발생 . . 객체망에서 핵심내용은 메세지만 주고받아 객체간통신은 가능하지 내부를 들여다 보진 않는다. 내장은 까지 않는다. | . | 내가 메세지를 주면서 시켰는데, 걔가 잘했는지 확신은 어떻게 하지? 내가 던지기만 하면 그만인가? 객체지향은 무책임한가? | . | 우리가 던전 메세지가 제대로 작동했는지 확인하는 코드가 필요하다. work를 확인하는게 아니라 메세지가 제대로 수신되었는지만 확인한다. | 그 메세지로부터 다른 메세지들도 잘 퍼져나갔는지가 중요 | 실제 작동은 안궁금하다. | . | 객체망의 성립은 쉽지가 않다. 단방향이지만 알아야한다. | runtime에 만들어지기도 해야한다 | 어떤 것은 set으로 할당되기도 하지만, 어떤 것은 생성자에서 만들어진다. | 활성화되었는지 껍데기 객체인지도 모른다. | | 메세지 전파부터 제대로 해야한다. 클라코드에서 screening.reserve() 호출하는 것은 보았지만 더 중요한 실제 movie의 calculateFee()를 호출하는지 메세지 전파 -&gt; 다른 메세지 제대로 전파되었는지 확인 | 우리는 reserve() 내장을 깔 방법이 없기 때문에 들여다볼 방법이 없다. | . | . | 객체 생성이라는 것은 runtime에 이루어지기 때문에, 코드를 짜는 우리로서는 제대로 객체통신(메세지전달)을 확인할 방법이 없다. 객체지향은 runtime context를 극한으로 = lazy하게 이용하려고 하기 때문에 생기는 문제점 | 즉 runtime context 시점에서만 확인가능. 코드로는 정적분석 불가능 | . | . | . | . . 객체망 통신(메세지 전달)을 확인하려면 (가운데 객체로 확인) 회색 -&gt; 테스트객체로 메세지를 보내고 | 테스트 객체 -&gt; 파/빨강 객체로 다시 메세지를 잘 보내어지는지 | 테스트 객체와 (원래 내장까는) 이웃한 객체들의 메세지 수신조사해서 확인한다. 회색 -&gt; trigger객체 -&gt; 대상객체 -&gt; 파/빨이 다시 메세지 제대로 수신했는지 확인해서 | . | | 가운데 테스트 객체를 깔 방법은 없다 -&gt; (처음부터 내장까지는 전/후 이웃) 3 객체들을 까서 조사한다 대상 객체의 단위테스트는 안중요하다 객체망 진짜 테스트 -&gt; 감싸고 있는 회/빨/파 내장까지는 객체가 메세지 수신하는지? | . | . | . . 내장까지는 객체는 어떻게 만들까? Mock객체를 활용해서 검증한다. | 내부를 log찍는 인터페이스를 구현 -&gt; 인터페이스를 구상하는 객체 -&gt; 구현 | . | . mock객체 활용 검증 . . 내부를 log찍는 인터페이스 구현도 반복적이므로 mock객체를 쓴다 . | 단위테스트를 하는데 mock을 사용하지? . 실환경에 존재하고 해주는 일을 하는 객체를 대신하여 사용하는 것일까? 아니다. | . | . | 우리는 객체망을 통해 문제를 해결하는데, 해당객체를 추론해서 볼 수 없으므로 객체망검증을위해 mock객체가 필요하다 . 회색/파란/빨강 객체 -&gt; mock객체 -&gt; 대상 테스트 객체가 제대로 작동하는지를 검증할 수 있다. | . | 목 객체 용어 . mockery(모조 객체) vs mock(목 객체) | 테스트 관리 객체 vs 테스트용 모의 객체 mock(모의 객체)들의 우두머리 -&gt; mockery | mockery는 일종의 테스트관장하는 우두머리 context라고 볼 수 있따. | . | | . . 일단 context인 mockery부터 배치를 한다. | . . 필요한 목객체 생성은 context로부터 생성한다. . context는 자기로부터 생성된 목객체들을 감시할 수 있다. . | 아까 봤던 회색 / 파란 / 빨간색 객체를 생성한다. . mockery인 context를 안고 생성하게 한다. | 해당 인터페이스 구현부에 만들어진다? | 안에 context에 보고하는 로직으로 구현되어있다 | . | 대상 객체를 둘러싼, 객체망을 검증할 수 있는 주변 객체들을 생성했다 . 객체 본질 = 책임 = 메세지를 주고 받는다 = 주는사람이 있으면 받는 사람도 있다. | . | . | 테스트할 객체를 둘러싼 객체망으로 구성하기 . 실제 대상객체를 만들고 | 목객체 3개를 원하는 구조를 구성한다(보통 DI구성 or 직접수동으로) | . | 트리거 발동하여, 회색객체에 첫번째 메세지 발동 . 테스트 대상객체 내장은 못깐다. 못건들인다고 생각하고 | 회색객체에서 할 수 있는 것 = 목객체에서 메세지를 쐈다.를 mockery에서 보고받음. | 파랑/빨강객체에서 할 수 있는 것 = 목객체로서 메세지 수신했다를 mockery에서 보고 받음 | . . 전체적으로 mockery가 원하는 시나리오 대로 성립했는지 확인할 수 있다. 대상객체에의 메세지처리가 정상적으로 유통되고 있어.를 판단한다 | . | 객체망 참가하는, 대상객체 테스트 방법은, 이방법이 유일하다. 객체 내장은 못깐다. | 객체는 책임으로서만 의미가 있다. 책임 = 메세지를 주고 받는 행위다 객체를 바르게 테스트 하는 방법은, 주변객체를 활용해서 메세지 송수신이 제대로 유통되는지를, mockery에서 확인하는 방법밖이다. | . | . | . | 목 시스템 외에는 객체테스트가 불가능하다는 결론 테스트 작성 -&gt; 무조건 mock이 필요하다 | mock없이는 객체지향 테스트는 불가능하다. | . | 객체 메소드 단위테스트는 정상작동하는 객체다를 증명할 수 없다. 객체는 오직, 객체만이 참가해서, 메세지를 주고받을 때 의미가 있으므로 | 정말 바른 객체다?를 증명하려면, 메세지를 주고받는 것으로 확인할 수밖에없다. | . | . | 객체지향 개발을 한다 = mock기반의 테스트를 작성해야만 가능하다. runtime에서 잘 작동할지 알 방법이 없다 | 보통 주변 객체들이 적시에 그자리에 있냐 or setter로 세팅한 것이 적시에 이루어지냐에서 뻑난다 screening 안에서 movie.calculateFee()를 호출한다고 하더라도 movie가 적시에 바르게 작동하고 있는지의 문제가 생긴다 | . | . | 안하면 코드를 상상으로 하는 것이다. 선택이 아니다. | 객체 테스트는 이 방법 밖에없다. | . | 단위 테스트(메소드)도 객체가 가시성을 내어놓은 상태로 짜는 것. 꽁꽁 숨겨둔 객체라면 못짠다. | . | 객체는 오직 객체통신을 통해서만 = 책임이라는 메세지를 호출하는 것으로만 의미를 가지기 때문에 테스트방법도 메세지 테스트 외에는 방법이 없다. | . | . GRASP과 9 패턴 . 오브젝트 책 5장의 주제다 | 객체지향 기본이론(5+4)를 base로 보다 더 민간용으로 나온 설계요령 다른 관점에서 SOLID법칙, 헐리우드법칙, 디미터법칙을 인식하는 좋은 계기가 된다. | . | . . 9가지 원칙 패턴 거성들의 원칙(5+4)보다 객체지향 적용의 약한 레벨에 적용할 수 있게 좀 풀어놓은 버전 | 응용범위는 더 좁을 수 있다. 패턴은 특정상황에서 쓰는 것 | . | 켄트백은 적용할 수 있는 레벨을 여러가지로 분류했다. 원칙, 가치, 패턴 원칙: 무조건 지켜야하는 것(이유 없이) | 가치: 돈이 되는 행위(보다 돈이 방향으로 움직여라) 코드를 잘짜는 것 &lt; 디버깅을 할 필요가 없는 코드를 만들기 개발시간은 디버깅의 1/4밖에 안되므로 | . | . | 패턴: 원칙+가치를 반복적으로 하다보니 만들어진 모범답안 | . | . | 9가지 패턴으로 쓰면 도움이 되고 시간 절약 + 많은 오류 해소 | 반드시 적용되는 것은 아님 | . | . Information Expert . . SOLID원칙 이전에, 객체지향의 은닉성 자체을 의미 데이터 하이딩, 은닉을 지키고 싶다라면, **데이터를 가진 애가 책임(메소드)도 가지는게 좋아(패턴) cf)(맞어 -&gt;원칙) ** 패턴이라서 ~ 하는게 좋아. 정도의 어감. 항상 지킬 수 있는게 아닌 패턴 ex&gt; 어떻게 screening이 reserve를 하나.. | . | 은닉성을 잘 지켜지니까, 데이터를 가진 놈이 메소드도 가지면 좋아 | . | . | . Creator . . 정보 은닉성과 연결된 얘기 니가 객체를 만드는 일이 생겨도 (in runtime) 그 때도 정보 전문가 패턴을 적용할 필요가 있다. | 객체를 만드는 것 = 그 객체(가 가질 필드)정보를 많이 알고 있는 or 포함/이용/부분으로 삼는 놈이 -&gt; 그 객체와 친밀한 놈이 그 객체를 만드는게 좋아 실제로 지키기 힘든 패턴이다. | 정보전문가패턴과 일치할때도 있고 아닐때도 있다. ex&gt; reservation에 들어갈 필드정보를 많이 알고 있는 screening이 reservation 생성을 맡긴다. | . | 나중에 고친 모델에서는 reservation을 사용하는 theater가 생성을 담당했다. ex&gt; theater가 검표(표 확인)시 reservation을 이용할 것이기 때문에 | . | . | . | . Controller . . 컨트롤러가 무슨 패턴이냐 -&gt; 패턴이다. 컨트롤러: 어떤일을 중개할 때, 직접접촉하는게 나은지 아닌지를 판단하는 것 | 어댑터 패턴과 미디에이터 패턴을 공통적으로 한꺼번에 적용할 필요가 있을 때 -&gt; 컨트롤러 패턴으로 퉁치는게 좋아. 미디에이터 패턴: 객체가 다수의 객체를 알아야할 경우, 객체망이 너무 복잡해지니, 미디에이터를 중심에 두고, 미디에이터가 다 알게 한 다음 -&gt; 나머지는 미디에이터만 알게 한다 나머지가 하고 싶은일이 있으면 미디에이터에게 위임하면, 알아서 해준다. | 하나의 시스템이 -&gt; 여러시스템에 물려서 통신한다. -&gt; 중개자가 처리한다. | 모든 case를 알고 있는 법원으로 가서, 사람들이 따지게 하는 방법 | . | 어댑터 패턴: 내가 직접하는 것보다 간접적으로 아는게 훨씬 유리하다. MVC에서 Model(데이터) -&gt; Controller(어댑터) -&gt; View(UI, 콘솔, 사운드 등) 여러 구상체로 나뉠 수 있으니, 구상체를 직접아는 것보다. 중간에 어댑터를 알게 하는 것이 더 좋다. | . | 어댑터가 1개 시스템(1개 Model-데이터)만 아는게 아니라, 여러 시스템이 알고 있는 경우가 미디에이터패턴도 해당한다 Controller를 만들어서, MVC의 어댑터를 맡기던지, 법원의미디에이터를 맡긴다. | . | . | . | 객체지향 설계를 공부하다보면, 고프의 디자인 패턴을 이야기한다. 반대로도 통하는 사람에게 통하니 문제다 | 학습루트 추천 디자인 패턴(구현물)을 일단 달달 외운다. | 객체지향 원리를 공부하면서 외운 패턴을 적용하면서, 패턴이 왜 그렇게 만들었는지 생각해본다. 2개를 동시에 학습할 수 없다. | . | . | . | 컨트롤러 패턴이 나온 이유: 어떤 객체가, 어댑터패턴 &amp;&amp; 미디에이터패턴을 동시에 사용해야할 대 -&gt; 컨트롤러를 만들어서 사용한다. | 컨트롤러를 보면 외부에 대해선 어댑터 | 내부에 대해선 미디에이터다 | . | . | . Low Coupling . . 오래된 이론이다. | 객체지향에서 커플링(결합도)가 낮다 = 알고 있는 객체가 적다 책에서는 적절한 객체를 알고 있다고 표현해놨다. 비겁한 표현이다. | 우리는 알아야만 하는 객체를 알고 있을 뿐이다. 알아야할 필요가 없는 객체 -&gt; 설계 대상이 아니라 리팩토링 대상이다. | . | . | . | 알아야만 하는 것에 대해 단방향 의존성이 Low Coupling의 목표다 양방향 의존성(참조)이 되는 순간 -&gt; 상태를 보고서 버그를 확정할 수가 없다. 디버거들이 무력화 된다. | 주고 받았기 때문에, 값이 얼만지 모른다. | 주고 받지 않아야만, 메세지 보내기 전/후로 나눠서 디버깅 가능해짐. | 양방향 참조는 100% 제거해야한다. 순환참조를 통한 양방향 참조도 무서운 것 -&gt; 제거하자. | RDB의 기술: M:N -&gt; 1:M으로 바꾸는 것 | DB-중개테이블처럼 &lt;중개 객체&gt;가 더들어와야지 양방향 참조를 제거할 수 있다. 형1개가 늘어날 수 밖에 없다. 어댑터패턴에서도 -&gt; 어댑터 인터페이스 + 어댑터구상체가 늘어나듯이 | . | . | . | . | 주고 받았으면 누구 책임인지 알 수 가 없다. runtime에서는 에러를 못잡는다. | . | Low Coupling -&gt; 알고 있는 객체가 적다 -&gt; 양방항참조를 제거한다 -&gt; 제거 과정에서 M:N을 풀듯이 가운데 객체로 인해 형이 1개 추가될 수밖에없지만 두려워말라. 양방향은 디버깅조차 안되므로 형을 통해 단방향으로 바꾸는 수 밖에 없다. | . | . High Cohesion . 그에 비해 High Cohesion(높은 응집성)은 달성 방법이 정해져있다. SRP의 책임 -&gt; 변화율 요인을 1개로만들어서 분리 도메인(내가 가진 정보)에 의해 변한다. or 변하는 주기(자주 변하는 부분과 안변하는 부분의 공존시 분리)에 의해 변한다. | 최종 목표: 변화율에 따라 코드를 나누고, 변화시 다른 곳에 영향주지 않게 격리시켜라 격리 유일한 방법: 형 경계를 넘지 않게(?)= Dependency를 단방향으로 의존하는 것 | . | . | . | . Protected Variations . . 인터페이스 분리 원칙을 적용한 것 가능한 직접적인 형을 참조 하지말고 공통점 찾아 인터페이스로 추상화 하라는 얘기 | 가능하지 않는 대부분의 이유: 다양한 case들 때문에 추상화(공통점 찾기가)하기 어려움 공통점을 억지로 찾아도 의미가 없다 | 공통점 찾는 이유: 인터페이스로 노출하여 -&gt; 책임을 할당하기 위함이다. 억지로 찾아봤자다 3~5년 역할책임모델의 눈을 가지게 되는데 오래걸리는 이유 | . | . | . | . Polymorphism . . 인터페이스로 추상화하라는 얘기랑 비슷하게 들지만 아니다. 전략패턴을 의미한다. 얘가 하는 행동이 추상적으로 의미가 같지만, 실제 하는 행동은 여러가지로 달라질 수 있을 때 책의 예제, policy나 condition차원에서는 isSatisfiedBy나 calculateFee메소드 2개를 공통적으로 사용해 퉁칠 수 있지만, 내부구현은 다 달라질 수 있을 때 | . | 폴리모피즘 패턴으로 전략패턴처럼 구현하는게 더 좋아 추상체를 인자로 받아들이고 | 구상적인 체들은 달라질 수 있는 부분을 나중에 구현한 뒤, 받아들일 수 있게 하는게 좋아 | . | . | . Pure Fabrication . . SRP를 AOP적인 관점을 바라볼 수 도 있다고 했었는데 단일책임원칙: 코드수정은 이 때 + 이래서 변하는 변화율 1개로 기준을 잡아서 객체 분리. 공통된 기능을 분리해서 가지고 있으면, 관심사 수정시, 수정여파가 다른 곳으로 가지 못하게 한다. | . | . | 단일책임원칙에 의거해서, **공통된 기능을 ** | 빨리빨리 추상층으로 빼내든지 | 공통클래스로 빼내라 | . | 완성판 객체 = 추상화가 끝난 객체는 공통 기능들은 인터페이스를 구현한 추상클래스에 템플릿 메소드로 되어있고 소유를 통해 처리하는 public 메소드 훅이 아니라 독립객체 인터페이스 구상한 것을 hasA모델로 추상클래스에 넣어줌 | . | 훅을 통해 처리하는 template 메소드가 노출되어있고 | . | 그 추상클래스를 구현한 구상클래스에서는 훅들을 구성해서 채워줌 | . | . | 디자인패턴 중 세련되게 + 많이 + 능숙하게 써야하는 패턴은 템플릿메소드패턴+전략패턴이다 밥 먹듯이 써야한다. | 템플릿메소드패턴 &lt;-&gt; 전략패턴 밥먹듯이 바꿀 수 있어야한다.(loop&lt;-&gt;재귀 바꾸듯) case(객체)들이 확정되었다고 생각해서 템플릿 메소드 패턴을 사용했는데 | 지금보니 runtime에서 더 많은 case(객체)들을 정의할 것 같다 -&gt; 전략패턴으로 바꿔야지 | . | 딱딱할수록 고정 구상층을 가진 추상클래스가 유리 템플릿 메소드 패턴 | . | 유연할수록(=확장될 가능성이 있음) 구상층 일일히 다 만드는 귀차니즘이 없도록 인터페이스가 확장성이 유리 전략패턴 | . | 2장에 나와있는 인터페이스로 구현한 추상클래스가 훅을 이용하고 + 템플릿메소드를 제공하고 있는지 확인해봐야한다 다 그렇게 되어있다. 추상화를 다 하고 나면, hasA도 쓰고 isA도 같이 쓰기 때문에 | . | . | . Indirection . . 포인터를 직접 참조하지말고, 포인터의 포인터를 참조해라 왠만하면 직접적으로 가지 않는게 좋다 | . | 포인터의 포인터는 다른의미로 인터페이스같은 추상형을 사용하거나 | 직접만든 데코레이터패턴 or 어댑터패턴을 통해 직접명령이 아닌 걔를 통해 간접적으로 명렁을 내리는 것 를 말하는 것일 수도 있다. | . | 간접참조(껍데기)를 하면, 직접참조를 하는 애(업데이트 되는 내용물)는 바꿀 필요가 없다. SOLID원칙에서 OCP를 말하는 것 | . | .",
            "url": "blog.chojaeseong.com/object/2022/05/10/(object1-7)SOLID5%EC%9B%90%EC%B9%99_GRAPS9%ED%8C%A8%ED%84%B4.html",
            "relUrl": "/object/2022/05/10/(object1-7)SOLID5%EC%9B%90%EC%B9%99_GRAPS9%ED%8C%A8%ED%84%B4.html",
            "date": " • May 10, 2022"
        }
        
    
  
    
        ,"post71": {
            "title": "OBJECT 06 객체간통신(코드스핏츠)",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . ch6. 객체망과 객체간 통신 . . 객체지향 관련 책들이 많지는 않다. 뻔한 얘기외에 구체적인 사례를 들어주는 책은 드물다. | . | 오브젝트 5장: 1234장을 정리 객체설계시 좋은 요령 지금까지의 theater코드에 요령 적용 이 책은 알고있다고 가정하는게 너무 많다 -&gt; 이해 안되는게 정상 | 맨 뒤에서, 책이 참고하고 있는 책 6권이상이 나열되어있음. 사전요구사항이 되게 큰 책이다. | . | . | . | 오브젝트 6장부터: 새로운 내용의 시작 | . | 지금까지의 내용 정리해보기 설계 이전에 중요한 것: 책임 객체간의 책임(함수)을 주고받기 위해 메세지(객체 인자)를 사용 | . | 그렇다면, 누구에게 책임? 메세지는 어떻게 사용? 이 설계의 목표다. 이 책에서 설계: 코드를 대치하는 기술 어차피 돌아가는 코드에 대해 향후 유지보수 등이 쉬워지는 코드를 설계한다 | 구동하는 코드를 만드는 것X -&gt; 구동 코드를 어떻게 배치할 것인가 | . | . | 설계: 코드를 객체지향원리에 따라서 &lt;책임&gt;을 객체별로 나눠 배치 설계요령: 코드를 나누는 요령: 역할책임모델 | . | 객체 만드는 이유: 역할(책임=메소드의 집합, 인터페이스?) 역할: 책임의 집합 책임을 어떤 객체가 가져가야할 것인가부터 부터 이해해야 어떤 객체에 그 코드를 할당해줄 것인가를 결정 | 객체지향에 의해 적절한 책임을 객체에 할당하는데, 나눠가지려면 메세지를 주고 받아야한다. | . | . | . | . | . 객체간 통신 . 객체가 책임을 나눠갖기 위해 메세지를 통해 주고받으니까 우리는 객체가 책임을 통해 통신하고 있는 네트워크를 생각해볼 수 있다. 객체망(object network): 역할책임모델 기반으로, 객체간 코드분리가 잘되어있는 형태 객체망에 소속되어있는 객체끼리 메세지를 주고 받음 -&gt; 책임을 분담/분산해서 나눠가짐 | . | . | 객체간 통신 책에서는 다 안다고 가정하고, 메세지를 던지면 다 알아먹는다고 가정하고 있다. 하지만 잘 모른다. | 실제 객체간통신은 복잡한 문제다 | . | . . 객체 1개 가지고는 객체망(역할책임모델기반 객체간코드분리)을 형성할 수 없다 일단 객체에 대해서 더 살펴보자. | . | . . 객체는 **내부에 캡슐화를 이용해서 정보은닉한 상태로, 외부와는 메소드를 통해 소통하고 있다. ** 내부는 안보여준다. | 외부는 캡슐화된 메소드만 제공해준다. | . | . . 객체는 2개이상이다. . 서로 내장을 까지 않는 객체끼리는 public interface(껍데기)를 통해 메세지를 주고 받는다. . . | 하지만, 현실세계 객체는 위와 다르게 생겼다. 역할과 책임이 서로 틀리기 때문 . 객체의 책임은 수행해야할 업무 | 객체의 역할은 객체가 당면한 어떠한 측면 가정에서는 아빠, 회사에서는 사장 | 책임(업무)를 수행하되, 소속공간, 바라보는 측면에 따라 역할이 달라진다. | . | . | . | 객체의 본질은 은닉화한 데이터를 자기만 컨트롤 가능하지만, public한 interface로 외부에 [책임]으로써 노출 . 집안(역할1)에서 돈(은닉화 데이터)을 나(객체1)만 가지고 있으면, 집에서 나만 돈 쓴다(역할1) | 회사(역할2)돈(은닉화 데이터)을 나(객체1)만 가지고 있으면, 회사에서 나만 돈 쓴다(역할2) | . | 은닉화 데이터를 기준으로 -&gt; 책임 =외부에 노출한 public interface가 정해진다. . BUT, 데이터는 측면(역할)을 반영하진 않는다. . | 측면 =역할 = 객체를 둘러싸고 있는 인터페이스들이다. . . 현실세계 객체는 위처럼 생겼다 내부는 캡슐화 -&gt; 데이터 은닉화 | 외부에 보여주는 것은 역할=측면(A사장, B아빠, C남자)에 따라 외부노출되는 메소드는 다른 형태 책임: 돈을 준다 | 역할 -&gt; 바깥으로 나가는 측면에 따라 여러가지로 A: 급여 지급 | B: 용돈 지급 | C: 술값 지급 | . | &lt;역할참여=측면에따라&gt; 책임(메소드)는 다양하게 나타난다 | . | . | . | 메소드 자체는 객체내 은닉화된 데이터에 의해서만 나올 수 있다. . 데이터에 따라, 객체가 가지는 메소드는 정해져있다. ** **그러나 다른 측면(역할)에 따라 여러가지를 구현해줄 수 있다. | . | . | 은닉화 데이터(돈)에 따라 책임(업무, 메소드)는 정해지는데 . 역할에 따라 = 측면에 따라 -&gt; 여러 인터페이스가 구현되는 것은 class implements 사장, 아빠, 남자를 통해 여러가지를 구현한다. **각 역할에 따라 메소드는 다른 방식으로 각각 구현된다. ** | . | 해당 데이터는 나만 가지고 있으므로, 무조건 내가 구현해야한다. 역할에 따라 다르게 구현한다. 현실세계 객체는 데이터 때문에 -&gt; 다양한 측면의 메소드를 가지는게 정상 책임(메소드)은, 각각 역할에 따라 1개씩 가진다. 모든 역할을 가지고 1개의 책임(메소드)만 가지는 것은 불가능. 각각 책임이 만들어진다. | . | . | . | . | 현실세계 객체(나)는, 다양한 역할(사장, 아빠, 남자)을 가지며, 그 역할에 따라 각각의 책임(급여지급, 용돈지급, 술값지급)을 수행한다. . 요점: 나라는 객체가 -&gt; 사장만 impl하거나 아빠만 impl할순 없다 -&gt; 여러역할을 다 imple해서 -&gt; 역할에 따른 여러 책임을 수행한다 | . | . . 객체간 통신이 어려운 이유: 객체망내 **다른 객체도 똑같이 중**이다. 나 = 은닉화데이터에 따라 사장, 아빠 impl 구현 중. | 옆사람 = 은닉화데이터에 따라 사원, 아들 impl하여 구현중. | . | . . 객체간으로 볼 때, 2 객체의 추상층(추상레이어)입장에서 볼 수 있다. 색깔별로 같은 병행 interface를 갖고 있다. 인터페이스 수준에서는 색깔별로 같은 놈으로 보인다. | . | but 통신은 서로를 바라보는 측면(역할)에 의해 객체간 통신이 성립한다. 역할의 형태(바라보는 측면, 관점)에 따라 통신함 파란색 -&gt; 파란색을 바라보는 관점뿐만 아니라 | 파란색 -&gt; 갈색을 바라보는 관점으로 따로 또 통신할 수 있다. | . | . | . | . . 객체1개에서 각 인터페이스별로 책임과권한을 따로따로 가지고 있으며 책임과권한을 가진 인터페이스를 모두 다 합한 것이 객체가 된다. 아빠 -&gt; 아들에게 용돈주는 책임 | 사장 -&gt; 사원에게 급여를 주는 책임 각 책임(과 권한)을 -&gt; 인터페이스 Level별로 나눠서 가지고 있다. 객체 = 떡진 덩어리가 아니라, [관점별]로 다르게 [구현]한 것들을 [Type(형)]으로 분리해서 인식한 것 | . | . | . | . . 각각의 **다양한 측면(관점)에 따라 책임과권한을 구현한 모든 인터페이스를 ** 책임에는, 합당한 권한을 가져야 수행가능 아는게 있어야, 뭘 한다 | . | 다 합친 게 역할 -&gt; 물주 | . | . . **객체간통신은 아름답게 [서로 스펙을 알고서 주로 받는게 아니다] ** 각각 여러가지의 책임별 인터페이스를 가지면서 역할을 수행하는 객체들끼리 객체1의 일부 책임 -&gt; 객체2의 다른 형태의 책임을 가리키면서 걔와 통신을하는 복잡한 과정이다. | . | 처음부터 파란색의 인터페이스는 -&gt; 상대를 갈색으로 바라보고 메세지를 날릴 준비를 한다. 아름답게 아빠(책임A)와 아들(책임a)의 통신이 아니라 아빠(책임A)가 사원(책임b)에게 급여줄 생각을 하고 있다는 말이다. 이게 실제 세계의 통신이다. 그룹끼리 묵어서 통신하지 않는다. | . | . | 실제 객체간통신에 쓰려고 개발해도, 다각도적인 측면에서 복잡한 경우의수가 생기는 이유이다. 객체 설계시, 절대 1개인터페이스-1개메소드를 가진 class를 만들 순 없다. | 왜냐면 그 은닉화된 데이터 -&gt; 발현된 책임들이 정해져서 나오기 때문 | . | 예제에 나온 Screening을 예를 들면 정보를 아는 것 때문에(은닉화된 데이터) -&gt; 어쩔 수 없이 reserve예약도 받게 되었음 | 원래 상영 = 극장에서 영화시작시간을 알고 있는 책임만 있을 뿐인데 왜 예약이라는 책임(메소드)를 떠맡았느냐? 상영 지 혼자만 아는 정보이므로 어쩔 수 없이 | . | Screening 인터페이스A: screening 정보의 책임과 권한 | 인터페이스B: reserve()의 책임과 권한 형식으로 생긴 것으로 생각해볼 수 있다. | 실제로는 책임 -&gt; reservator interface를 impl해서 메소드reserve()를 구현해야한다. 원래는 명시적으로 만들어서, Type으로 만들어야한다. 즉, interface로 만들고 -&gt; class가 impl해서 메소드 구현 | Screening implements reservator 로 구현한 뒤? 클라이언트: reservator(screening).reserve()로 예약해야한다.?? 이렇게 하면 모순점이 발생안한다. | . | screening이 예약을 하는 모순점이 사라지고, screening impl reservator를 하면 -&gt; reservator가 .reserve()를 하게 되고, Type(형)으로 이해가 된다. 책 2장의 모순이 해결된다. | . | . | . | . | . | . | . | . 통신망의 구성 . . 객체가 2개가 아니라 4개 이상을 보자. 실제 객체는 어떤일 하기위해 누구에게 도움받았고, 서로 도움을 합체해 다른애들에게 도움을 요청한다. | 2장 theater도 마찬가지다. screening에게 부탁했더니 movie에게 부탁 -&gt; policy -&gt; condition에게 부탁하고 있다. | . | 동시에 2군데에서 부탁하고, 도착한 부탁 2개가 있으면 내부에서 변환하여 -&gt; 1개로 다시 부탁할 수 있다. 합체+대기+병합조건 등이 일어나면서 비동기인 경우도 많아서 복잡하다. 객체통신은 비동기도 포함해서, 다양한 형들이 다양한 형들과 대화하는 복잡한 망으로 되어있다. | . | . | 이 책을 보는 이유 스프링에 있는 controller, service만 주구장창 짜는게 아니라 구성하는 파워를 기르기 위함이다.(이 통신망을 짜기 위함) | 비즈니스 도메인 -&gt; 코드로 변역하여 통신망을 짜는 힘 도메인: 해결해야하는 문제 | 협력하는 객체의 망 + 메시지로 연결할 수 있느냐 코드를 분산시킨 그릇들 = 객체들을 만들고 | 메세지로 연결할 수 있느냐 | . | . | . | . . 두 메세지망의 차이점은? 왼쪽: 비선형구조 / 오른쪽: 선형구조 (or 순환구조) 일반적으로 순환 통신망 -&gt; 잘못된 구조 3개 밖에 없어서 파악했는데, 일반적으로는 파악할 수 없다. | 설계의 원칙을 지켜서 순환구조를 만들지말자. | . | . | 양방향 화살표, 서로 알고 있는 구조가 없어야한다. 설계의 목적: 의존성을 제거할 수 없다 -&gt; 단방향화(simplex) 시켜야한다. 설계 = 코드 대치의 목표 -&gt; 의존성을 단방향화 시키는데 있다. | . | if 조건부을 제거하는 방법? 없다 관련된 의존성을 제거할 방법도 없다 ex&gt; 하나카드랑 같이 일하는데, 하나카드 화살표를 제거할 방법 없다. | 도메인에서 원하는 것들만큼 화살표가 나가야한다. 제거할 방법 없다. | 우리가 해야할 것은 순환 참조만 일어나지 않게 하는 것이다. 직접 순환 뿐만 아니라, 돌다가 오는 것도 막아야한다. | . | . | . | . | . 객체설계 난점 . . 목표를 알았다. 순환참조를 안한다고 해도 객체설계에 난점들이 많다. | . 인터페이스의 그룹화 . 인터페이스: 특정 책임을 나타내는 것 제일 좋은 인터페이스 : 아무 메소드도 없는 것 | 2번째 좋은 인터페이스 : 메소드 1개 있는 것 | 안좋은 인터페이스 : 메소드 2개이상 있는 것 기본적으로 인터페이스 = 메소드 1개만 가진다고 가정하자. 인터페이스를 왜 만들었을 까? | . | . | 인터페이스는 합당한 책임을 추상화한 것 책임은 어디서? 도메인에서 나왔다. 도메인은 여러 측면을 가지고 있다. 사업자, 이용자, 에이전시 각각의 측면을 가지고 있다. | . | . | . | 즉, 여러 측면의 도메인에 따라 -&gt; 책임이 관점에 따라 여러가지 -&gt; 추상화한 인터페이스도 여러가지 | . . 도메인A관점(사업자) 측면에서 -&gt; 여러 책임 -&gt; 추상화한 여러 인터페이스 ABCD 도메인B관점(이용자) 측면에서 -&gt; … -&gt; 여러 인터페이스 abcd 같은 객체인데, 도메인에 따라 인터페이스도 여러개 추출 | . | . | . . 도메인이외에, 추가적인 관점들에 따라 -&gt; 여러 인터페이스들이 마구마구 나온다. Player라는 객체를 만든다. 어떻게 바라볼 것이냐에 따라서 움직이는 로직관점: 유저직접 / AI / 랜덤으로 / 히스토리기반 으로의 인터페이스들 | 컨트롤러 관점: 조이스틱 / 키보드 / 마우스 으로의 인터페이스들 | … | … | | 수많은 인터페이스가 많은 관점으로 양산 왜? 우리는 책임(메소드)를 추상화하고 싶으니까 그 책임이라는 것은 관점이나 도메인에 소속되어있기 때문에 -&gt; 관점에 따라 수많은 책임 도출 -&gt; 추상화하고 싶어서 인터페이스도 수많은 것이 도출 | . | . | . | 내가 사장or아빠인 것처럼, 1개의 객체는 . 은닉화된 데이터 -&gt; 수용해야하는 관점이 많고 -&gt; 그만큼 인터페이스를 부여해야한다. . | 또한 객체마다 수용or소속되어있는 관점이 다르다. . 어떤 객체는 B인터페이스만 -&gt; 도메인A관점에만 사용됨 | 어떤 객체는 D, 라 -&gt;A관점, 모델링관점 2관점으로 사용됨 | . | . | 각 객체들은 소속된 관점마다 다양한 인터페이스를 &lt;부분적으로&gt; 가지고 있다 . . | . . 각 객체들은 따로 존재하는게 아니라 망을 구성하고 있으니 서로 다른 관점끼리 통신하기도 하지만 | 같은 관점내에서 통신하기도 하고 | 순환참조를 하고 있는 것도 있다. 책만 보면, 이런 설계를 할 수 도 있다. | . | . | 여러관점을 수용한 객체망 &lt;-&gt; 인터페이스 그룹화된 표가 상호작용을 하고 있다. 객체망 구성후 -&gt; 모순점 or 잘못된 인터페이스 발견 -&gt; 인터페이스그룹화된 표를 다시 다 고쳐줘야한다. | . | .",
            "url": "blog.chojaeseong.com/object/2022/05/08/(object1-6)%EA%B0%9D%EC%B2%B4%EA%B0%84%ED%86%B5%EC%8B%A0.html",
            "relUrl": "/object/2022/05/08/(object1-6)%EA%B0%9D%EC%B2%B4%EA%B0%84%ED%86%B5%EC%8B%A0.html",
            "date": " • May 8, 2022"
        }
        
    
  
    
        ,"post72": {
            "title": "OBJECT 05 객체설계2_Theater_with_Reservation(코드스핏츠)",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . ch5. Theater with Reservation . . 저번시간까지 모델 . . 극장이 ticket이나 invitation을 발행할 수 있다( 생성시 theater가 생성자 인자로 ) | ticket의 판매는 복잡한 책임이 있기 때문에, 극장은 생성만 하고 -&gt; TicketOffice에 위임한다. 대신 TicketOffice는 Fee를 받는다. | . | TicketOffice는 Office로서 Fee만 받게하고, 고객상대는 -&gt; 프리랜서인 TicketSeller를 고용한다. | . 이번 시간 모델 . . ticket 물물교환은 끝났다 -&gt; 인터넷예매의 시대 . 초대장도 없앴다. 대신 예약을 한다. | . | theater가 Reservation을 허용해 줄 수 밖에 없다. . 이 책에서는 Screening이 적당한 expert다. -&gt; expert pattern을 따르게 하고 있다. 책임을 누가 질 것이냐? -&gt; 정보 전문가가 책임을 부여하는게 가장 낫다. 객체의 특성(자기의 상태를 외부에 노출하지 않는다) 때문이다. | 최대한 노출하지않고 수행하려면, 가장 관련있는/정보를 가장 많이 가지고 있는 객체가 받아서 처리하는게 좋다. 캡슐화가 가장 덜 깨진다. | . | 하지만 이 패턴에 따르면 말이 안되는 경우가 많다. 팀장, 사장이 정보가 전문가가 아니다. -&gt; 현실세계는 정보 전문가가 그 책임을 수용하진 않는다. 정보 전문가 패턴의 단점이다. 실제 짜보면 그렇게 안된다. | . | . | . | 책에서는 Screening(상영)이 Reservation을 받는 까닭은? . Reservation관련 정보를 가장 많이 가지고 있기 때문에, 정보전문가 패턴에 의해 Screening이 Reservation을 책임진다. . . | 상영 정보가 예매를 한다는게 이해가 되나? . 말이 안된다. 설계가 안된다. screening.reserveSeat()가 말이 안된다. 쓸데 / 안쓸때를 구분해서 써야한다. | . | . | 진짜 도메인에서는, 상영 정보는 자리번호/순서/시간을 가진 시간표일 뿐이다. . 여러 영화가 공유할 수 있다. 10시 상영객체 -&gt; 인디아나존스도, 스타워즈도 각각 2개 가질 수 있다. 10시-스타워즈 / 10시-인디아나존스를 따로 만들필요가 없다. | DB 정규화와 관련되어있다. | 어떤 객체가 2개 만들어질 필요가 있는지 고민해볼 필요가 있다. | 함부러 객체를 남발한다 = 더이상 객체context 사용X = 값 context를 쓰겟다고 하는 것과 마찬가지다. 1, 2는 값으로 분리될 수 있어서 값을 넣어, 인스턴스를 여러개 만든다? | . | . | 객체는 객체 고유정보만 들고 있다면, 관계형 DB처럼 참조객체로서 보여주면 되는 것이다. 10시상영 시간표객체는 1개만 있으면 된다. -&gt; 각 영화들이 10시면 참조만 해주면 된다. 굳이 영화를 field로 받아서 각각 영화마다 여러개를 만들 필요가 없다.? | . | . | 객체지향 설계에 도움되는 개념 = RDB의 정규화(1~3정규화) 객체의 역할과 책임을 분리할 때, 어디까지 얘의 정보로 다룰지 결정할 수 있다. 인디아나존스 영화1, 스타워즈 영화2가 있다면, 상영정보(Screening)은 영화제목을 가질 게 아니라, 시간만 있으면 된다. -&gt; 각각의 영화에 참조만 시간별로 참조가 되어주면 된다. | 만약, 상영정보(Screening)에 영화제목을 넣는다면.. 상영정보-시간/영화1 | 상영정보-시간/영화2 똑같은 시간에 영화마다 여러개의 객체를 만들어줘야하니.. 그냥 안만들고 참조만 해주면 된다. | . | . | . | . | . | . | . | Screening은 시간표일 뿐 -&gt; 알고있는 정보는 시간뿐 -&gt; Reserve를 받기에 적합하지 않다. . 정보전문가패턴에서도 그랬다 -&gt; 이번시간 모델에서는 아예 안받게 함. | 현실세계에서는 극장도 여러개 / 영화도 여러개 / 영화마다 상영도 여러개 | . | . . 책에서는 할인정책도 소개하고 있다. discount policy(어떻게 할인 하는가) 2가지 정책 타입이 있다. amount | percent 그외 고정금액 확정도 있고 보너스 정립 등 많은 정책들이 있다. | . | . | discount condition(언제 할인이 일어나는가)도 2가지다. time condition: 언제를 기준으로 할인 | sequence condition: 몇번째인지를 기준으로 할인 그외 몇명이상일 때/소아일때/여성일때 등 많은 condition정책들이 있다. | . | . | 위에 그림처럼 보는 것처럼 연관관계가 수직적 성립하진 않는다. 각각 교차조건이다. 서로 부모자식관계 없다. Type시스템의 문제: 부모자식 관계가 없는데, 어떻게 소화하지? 책에서는 비겁하게 무기에다가 상수값으로 타입을 놓거나 | 객체간 분리해야할 것을 무기의 속성으로 소화하고 있으나 -&gt; 그러면 안된다. 무기의 속성으로 소화 -&gt; throw return시 -&gt; 중간메소드 2개씩이 생겨남 자기 타입불렀는데 아니면 죽는 메소드가 2개나 가지고 있게 된다. | 즉 조건분기만큼 하드코딩으로 메세지를 받게 된다? 쓸대없이 값을 가지고 있기 때문 | . | . | . | 책 4장까지 나온 movie 클래스로서는 discount 1개만 더 추가되더라도 많은 변화를 시켜야함. person, amount외 다른 type를 추가하면 다 고쳐야한다. -&gt; 내부에 type에 의한 if분기가 있기 때문!! | . | . | . | . | . Main . client코드인 Main코드부터 짠다. | . . . client코드부터 짜야 class짜기가 쉽다 | 충분한 도메인 검증(제대로 작동하는지) 검증할 수 있다. | . | . 극장을 100원으로 만들어냈다. . 극장의 처음 받는인자는 자본금이었다. 책에서 값 객체 = Money를 쓰기 원해서 바꿨다. new Theater(100L); | new Theater(Money.of(100.0)); 값 객체는 값을 대신하는 객체라서 레퍼런스형 객체와는 다르다. | . | . | . | 그 담으로 극장 상영을 위해 영화를 만들어낸다. . 영화의 타입으로 AmountDiscount를 받는다. 왜? 책에서 내건 제약조건이 1 영화 = 1 policy 제약조건을 줘서 AmountDiscountor PencentDiscount 둘 중 1개의 Type조건을 가진다. 값도 객체도 아닌 Type(형)으로 인식해야할 문제다. | . | 그냥 Movie가 아니라, Type 2개 중 1개의 Movie, 즉, Subtype을 가지는 Movie로 인식해야한다. 책의 제약조건 영화란, 단 1개의 할인정책을 갖는 존재라고 했기 때문이다. | . | 제네릭도 두려워하지말고 일단 지르자. 회사에 잘하는 사람이 알아서 짜줄 것이다. | . | Movie의 Type이 정해졌으면, 나머지 영화제목 | 지속시간 | 영화가격(실제에서는 영화에 가격X Screen-상영(시간)에 따라서 가격이 정재짐) | 컨디션 AmountDiscount 중에 Sequence를 쓰는 것으로 나타냈다. | 위에서 지정한 Type을 썼고, 그 중에서도 Time/Sequence 중에 sequence를 쓴 것이다. amount 1000원 할인 + sequence가 1일 때 할인 | . | 컨디션도 Type에 맞춰서 넣어줘야한다. 그렇지 않으면 제네릭에 걸려 죽게 된다. | . | . | . | theater에 만들어진 movie를 추가 . movie는 상영(screen)을 가지고 있지 않기 때문에, 따로 theater-movie(1)-screen(N)매칭시켜줄 필요가 있다. | . | theater에 Screening을 추가하는데, 각 movie에 맞춰서 Screening을 추가해줘야한다. ** **일별 x (매일마다) 시간별로 여러개를 추가한다. . 2019년, 7월, for 7일부터 / 매일(1일마다(간격으로)) / 31일까지 for 10시부터 / 3시간간격으로 / 24시 전까지 **for sequence 1부터 / 시간간격마다+ 1되면서 ** | sequence는 안쪽 for문에서 hour처럼 매일 1로 초기화되서 커짐 | . | . | Screening을 만드는데 순서=seq(시간마다 1부터 +1씩 증가되서 번호가 생성됨) | 상영시간=LocalDateTime으로 2019년 7월 &lt;7일부터 31일까지 매일, 시간은 10시부터 3시간 간격으로&gt; | 상영마다 가용한 좌석 수(상영관 class(여기에 예매가능한 좌석정보 포함?) 만들어야하는데, 너무 오래걸려서) 무한 예매를 방지하기 위함. | 상영관이 없으면 무한예약이 될 수 있다. 대신 상영마다 가용 자석수를 배정하면, 무한예매가 방지된다. (좌석수만큼만 예매가능) | . | . | . | TicketOffice를 자본금 0원으로 만들고, theater &lt;-&gt; TicketOffice가 계약(contract)하게 만든다. . 계약시 TicketOffice에게는 Fee(수수료) 10%를 떼어준다 | . | 프리랜서 TicketSeller를 만들고, TicketOffice &lt;-&gt; Seller와 계약시킨다. . . | customer만드는 코드가 빠짐 . Customer customer = new Customer(Money.of(20000.0)); . | 마지막 예약한다. 예매를 할 때는 . theater으로부터 특정 movie에 대한 상영시간표(Screen)들을 얻어온다. theater는 공개적으로 특정영화 선택시 Screen들에 대한 인터페이스를 외부에 공개할 책임(기능,함수)이 있다. | . | 지금은 for문 돌리면서 break로 첫번째 Screening만 예약하지만, 실제에서는 특정 Screen을 UI로 선택할 것이다. customer가 .reserve()예약하는데 특정seller에게 | 이 theater에서 | 이 movie를 이 때(screening) | . | 2명이서 보고싶다고 예약한다. | . | . | . | customer는 예매후 theater.enter()입장을 한다. customer는 인자로 넘어가면, 내부에 표를 2장 가지고 있을 것이다. 1사람이 표2장을 제시하면서 입장한다. | . | 결과로 입장가능한지 결과를 알려준다. | . | | 실제 예매과정과 비슷하다 핵심은 class가 아니라 Main의 client코드부터 시나리오대로 짜보는 것이다. 이것 가지고 회의를 먼저 한다. UI에 넘겨줄 부분.. 등 | . | 중요한 건 class가 아니라 instance, 실체, 진짜 일하는 놈들 일, 활동의 결과는 return값(isOK)가 되기도 하고 | 인자로 넘어가기도 한다.(theater.enter(customer)) | . | . | . | . 검토하기 . TicketOffice를 생성할 때, 생성자로 넘기는 인자는 값 객체다. Money를 만들 때는 값(0.0)이 어쩔수 없이 들어갔지만 | TicketOffice입장에서는 객체(Money)가 들어간다. | . | contract할 때도, 객체를 받아들였다. . . rate(할인율) 10.0은 좀 아쉽지만, 이것까지 객체로 하긴 귀찮아서 일단 안함. . 사실은 이부분은 객체지향 위반 중이다. 값이 들어가면 안된다. | . | 그렇다면, 예매한 좌석 수(사람 수) count 2도 값으로 들어가서 안좋은 것 . . 실제로는 count객체가 들어와야한다. | return값이 isOK도 boolean = 값이라서 위반이다. 원래 객체로 리턴되야한다. | . | 여기도 100대신 seatCount라는 객체로 들어가야한다. . | 여기도 1이 아니라 sequenceNumber객체로 . | spiderman 문자열도 title객체로 . | . | 농담하는 것 같지만, 고도화된 객체지향 시스템에서는 값이 등장하지 않는다. . 객체만이 역할을 수행할 수 있고 | Type만이 책임을 수행할 수 있다. 형이 아니면, 책임을 질 수 없고, 역할을 수행할 수 없다. | . | . | 아래 예제에서는 값1을 쓴이유: 작성자는 sequenceNumber라는 객체는 더이상 관여할 일이 없음을 확신하고 씀 대부분 이러한 착각때문에 시스템을 뜯어고치게 된다. 값은 더이상 확장할 수 없다. seat 100석이 더이상 바뀔일이 없다고 확신? 절대 하지마라 | . | 만약, 객체를 썼다면? 포인터의 포인터를 통해 어떻게든 반응할 여력이 생김 | . | . | . | . DiscountType . . 일단 위의 구조는 틀렸다고 했다. 짜보면 안다. . | DiscountCondition할 것은 2가지다. . 대부분의 최소화된 인터페이스가 가지는 2가지 조건(발동 조건+액션)을 가진다. | . . 이 조건들을 만족하는가(hasNext = 발동 조건) . | Fee를 계산해봐(next = (발동조건 만족시)액션) . 2가지 | iterator패턴 중 hasNext -&gt; next 쓰는 것이 중요한게 아니다. 아래 2쌍의 pair가 더 중요하다. 내가 발동할 조건을 가지고 있는지 와 | 내 action이 무엇인지 | | 여기서 DiscountCondition은 실제 액션하기 위해 쓰인 것이다. 더 추상화된 개념에서 보면 actor -&gt; action을 할 녀석 -&gt; 발동trigger를 가지고, trigger만족시 action한다. | . | 하지만 DiscountCondition는 자율적인 애가 아니라 외부에 위탁한다. 1. 발동 조건을 가지고 있는지 외부에서 알려주는 인터페이스 | 2. 본인이 진짜 action하는 인터페이스 이런 수동적인 객체는 lazy = 외부사정에 맞춰서 발동trigger를 확인후 -&gt; 나를 action시킴하기 위해서 작성된다. | . | . | iterator패턴을 쓰는 이유 : 내가 원할 때 hasNext 호출후 trigger 만족하면 -&gt; next로 액션하려고 씀. | while이 아니라 이 담에도 있어? -&gt; 해의 능동형 queue = 내가 원할 때 작동하는 queue를 만들 때 while이 아니라 hasNext -&gt; next의 iterator를 쓰게 된다. | . | . | | DiscountCondition은 인터페이스로 2개의 역할(책임)을 동시에 수행하고 있다. . 책임으로 보면, 2개의 책임 -&gt; **와 을 분리가 가능**하다. 발동 trigger | action | . | . | 인터페이스가 2개 이상의 메소드(책임)을 가지면, 해체 가능하다. . **인터페이스는 함부러 2개이상 메소드가지면 안된다!! ** | 기본이 1개를 갖도록 분리시키는 것이다. | . | . 메세지 . 세상에서 제일 좋은 함수: 인자 없는 함수 = 프로시져 자율적으로 업무를 수행함 | 유틸함수 -&gt; 프로시져 객체 -&gt; 객체 내부 상태만 이용하는 객체 | . | 인자가 없다 = UML에서는 dependency라 부르는 것이 없다. 결합이 약해진다 | . | 하지만, 우리 수준에선 못짠다. | 세상 2번째로 좋은 함수: 인자가 1개 만 있는 함수 3번째로 좋은 함수는 ? 없다 인자 2개이상부터는 나쁜 함수 | . | 우리가 짤 수 있는 제일 좋은 함수 = 2번째로 좋은 함수 = 인자가 1개만 있는 함수 | . | . | **어떻게 좋은 함수(=인자가 1개 뿐인 함수)를 만들까? ** 우리의 수준에서는 세상에서 제일 좋은 함수 = 인자 없는 함수 = 프로시져를 만들긴 힘들다. | 그렇다면 어떻게 인자 1개인 함수를 만들까? 모든 인자를 추상화 -&gt; 객체화시켜서 객체를 1개의 인자로 받는 함수를 만들면 된다. 언제나 옳은 정답이며, 객체지향에서 메세지라 부르는 것이다. | . | . | 메소드의 인자를 정할 때, 전달된 인자가 2개이상이다? 메세지가 충분히 추상화 되지 않았다. | 메세지가 충분히 Type(형)이 되지 않았다. | . | . | 세상에서 제일 좋은 인터페이스는? . 메소드가 없는 인터페이스 진정한 역할은 역할자체만 나타냄 -&gt; 어떻게 해야한다(메소드)를 정의해주지 않는다. | . | . | 세상에서 2번째로 좋은 인터페이스 = 메소드 정의가 1개만 있는 인터페이스 . 메소드 정의 2개부터는 다 나쁜 인터페이스다 . 우리의 예제도 나쁜 인터페이스 -&gt; 인터페이스가 충분히 추상화되지 않아서 . . | 하지만 책에서는 이정도 수준으로 만족하고 있다. . 메소드 1개짜리 인터페이스로 인도되려면, Layer가 지금보다 더 많아진다. ( 머리에 한계가 찾아옴.. ) -&gt; 너무 깊은 추상화는 팀원들이 화냄 . . | . | . | . | . DiscountPolicy . . policy야말고 마커 인터페이스다. 책에서는 enum으로 정의하고 있지만, enum은 Type이 될 수 없다. enum(에넘)을 type으로 generate하는 언어들도 있지만 java에선 허용하지 않는다. | . | java에서는 interface로 정의한다. | . | 인터페이스를 DiscountPolicy를 상속받는 AMOUNT, PERCENT 등의 type들을 interface로 다시 정의해서 Type을 만든다. 인터페이스 DiscountPolicy를 따르는 다양한 마커인터페이스를 정의할 수 있다. 마커 인터페이스 = 메소드가 없는 (인터페이스만 여러개) 인터페이스 = 세상에서 제일 좋은 인터페이스 | . | . | . 더 못난 인터페이스(DiscountCondition) 공략 . 더 못난 인터페이스 DiscountCondition에 메소드 2개가 정의 되어있다. 둘 중에 하나의 메소드를 막아야한다. | . | . . DiscountCondition에 있는 인자 2개인 나쁜 함수 isSatisfiedBy()를 막도록 공략하자. 방법: 인터페이스 속 메소드 1개 처리를 추상체(추상클래스) SequenceDiscount로 공략한다. 생성자 인자로 sequence를 받아들여, sequence기반으로 isSatisfiedBy를 final로 더이상 안내려가게 잡아준다. SequenceDiscount를 상속하는 애들은, 만족하는지여부를 Screening의 sequence와 비교하는 로직은 다 똑같아진다. AMOUNT, PERCENT, COUNT, NONE이든 상관없이 모두 sequence기반으로 isSatisfiedBy 만족여부를 추상체에서 커버하도록 한다. | 이후 상속받는 애들은 sequence기반의 DISCOUNT가 된다. | 차후 implements를 AMOUNT, PERCENT, COUNT, NONE 각각 분기처럼 나눠서 구현한다. | . | . | . | 추상체가 DiscountCondition를 implements해서 isSatisfiedBy를 @ Override public -&gt; public final로 정의해서 이후 상속받은 구현체들은 정의못하게 == 그대로 갖다쓰도록 막아버린다. DiscountCondition대신 공략용 추상체 SequenceDiscount를 상속하는 애들은 calculateFee만 정의시켜주면 된다. | . | | . | 2개 메소드를 가지는 인터페이스를 처리하는 전략: 1개 메소드를 xxx기반으로 처리되도록 정의하는 추상체(추상클래스)를 만든다. | . . 추상체 SequenceDiscount를 상속받는 애들은 (ex&gt; SequenceAmountDiscount) SequenceAmountDiscount를 하고 싶다면, extends는 SequenceDiscount로 상속받은 상태에서 implements를 DiscountPolicy.AMOUNT(분기처럼 선택해서)로 구현해서 Amount개념을 입힌다. | 이 때, 생성자에서 sequence는 super()를 이용해서, 부모인 SequenceAmount에게 처리해달라고 한다. sequence의 처리는 부모(막은 추상체)에게 맞기고 우리는 현재기반인 amount를 생성자에서 받아준다. | my) 메소드 1개 처리는 추상체로 막았지만, 인자는 2개 모두 이후 구현체에서 생성자가 받긴 다 받는다. | . | 그럼, Amount기반으로 calculateFee만 정의해주면 된다. | . | 같은 개념으로 Amount대신 Percent기반으로 sequenceDiscount에 적용해보자. . . 똑같이 SequenceDiscount받기, 구현implements만 DiscountPolicy.PERCENT로 | 생성자에선, 부모가 처리해줄 sequence도 같이 받는다. | Discount정책중 Sequence정책 중 PERCENT 정책으로 | . | . | 받은 sequence는 부모(추상체)에게 super()로 맡기고 | caculateFee만 percent를 곱해서 원래fee에서 빼준다. | . | 추상체를 통해 메소드 1개처리를 막는 이러한 추상화는 4개 자식들의 공통조상이 되어버린다. 도메인, movie에서는 discountPolicy가 공통으로 묶였으면 했지만, 4개로 분리 되어버렸고, DiscountCondition중에 하나인 SequenceDiscount로 묶였다. 추상층을 Condition으로 시작하면 안됬다. | 다시 추상화 해야함. | . | . | implement inversion . . 요구 인터페이스(DiscountPolicy) 공략 . 잘못된 공략: 문제가 원하는 인터페이스(DiscountPolicy)가 아닌 DiscountCondition을 구현한 추상체를 통해 메소드 1개 처리를 중간에서 추상체가 처리하여 막았다. 이번에는 문제 반대방향으로 implementation하면서 Condition( Sequence -&gt; isStatisfiedBy()막기 )가 아닌 AMOUNT -&gt; calcuateFee()를 막는 추상체를 생성해서 1개 메소드를 막아보자. | . | . . **원하는 interface인 DiscountPolicy.AMOUNT를 implements하면서, 동시에 DiscountCondition도 implements ** AMOUNT계열의 Condition임을 나타내고 있다. 그러나 AMOUNT처리가 메인이며 -&gt; 관련된 메소드인 calculateFee를 public -&gt; @Override public final | 추상체가 calculateFee()를 커버함. isSatisfiedBy는 sequence/time의 처리영역 | amount -&gt; fee.minus(amount) | . | 관심사가 sequnece가 아니라 amount(Money)이므로 생성자에서 amount를 받는다. | . | . | . | . 2번째 추상클래스는 AMOUNT대신 오타 -&gt; Discount.PERCENT &amp;&amp; DiscountCondition을 상속한 추상체를 만들면 calculateFee를 percent단위로 discount하게 추상체를 정의한다. PERCENT계열의 부모가 된다. | . | . | AMOUNT or PERCENT계열의 부모 공통적인 처리는 policy -&gt; calcuateFee()로 묶게 된다. | . | discountCondition이 2개의 메소드를 가져서 문제 -&gt; 분리가 필요했었다. -&gt; 1개의 메소드를 중간 추상체를 만들어서 정의시킨다. . isSatisfiedBy 를 추상체에 올려서 정의 -&gt; 아래쪽에 calcuateFee를 각자 정의 | 반대로 calculateFee를 추상체에 올려서 정의 -&gt; 아래쪽에 isSatisfiedBy를 각자 정의 인터페이스 2개 이상(Condition, Policy)이 모이면 경우의 수가 폭증되는 문제점 도메인이 무엇과 일치(여기선 Policy정책을 기준으로 도메인이 정해짐)하는가를 찾아서 -&gt; 기준이 되도록 추상화 만들면 된다. | . | . | | . . 이제 Policy가 추상화된 상태에서 -&gt; Sequence + Policy(AMOUNT or ~) + Discount (SequenceAmountDiscount)를 만들어보자. . 받은 amount는 부모(= 1개 메소드 처리해준 추상체)에 보내서 처리하고 | 이제 is~쪽을 각자 정의해주면 된다. sequence가 같은지를 비교한다. | . | . | 다른 Policy를 선택해서 sequenceDiscount를 만들어도 똑같이 is~만 정의해준다. . . | 이러고 봤더니, sequence관련된 로직들은 어느 policy든 공통되는 것을 확인했다. . implements는 여러개 가능하지만, 상속은 1개 밖에 안된다. 인터페이스 2개메소드 -&gt; 메소드 1개 처리용 중간 구상체 -&gt; 상속한 구현체 | 상속 구현체의 한계 = 병합 되어있는 여러 경우의 수(자식들)에 걸린 코드중복을 제거할 방법이 없다. 별도의 [전략 객체]를 받아들이는 수 밖에 없다 cf) 코틀린은 classby를 선언하면 자동으로 해준다?! | . | 생성자에서 sequence처리 로직을 갖는 전략객체를 외부에서 수입 -&gt; 받아서 해결 | . | . | 우리가 원하던 추상화 계열은 도메인 요구 -&gt; policy별로 AmountDiscount orPercentDiscount를 상속받아서 SequenceAmountDiscount or SequencePercentDiscount를 만드는 쪽 원하면 TimingAmountDiscount or TimingPercentDiscount도 만드는 쪽 | . | . | movie에 꽂을 수 있는 특정 policy를 따르는 객체들이 된다. | . | seqeuence이외에 나머지를 직접 구현해보자. | . | . Movie . . 제네릭 . 제네릭을 통해 if문을 완전히 제거할 수 있다. cf) 라우터: 조건에 맞는 객체를 생성 (객체처리기?) -&gt; if문이 사라짐 | . | 추상클래스 등이 잘 지원되는 jvm을 쓰는 동안은 제네릭의 필요성을 거의 못느낀다. . 제네릭외 해결방법이 많으므로 but swift같이 철저히 프로토콜, extends만 지원하는 언어들은 대부분을 제네릭으로 해결한다. | . | my) T 제네릭을 통해, policy와 condition 2개를 다 만족하는 추상체 -&gt; 의 하위객체를 movie T에 꽂을 수 있따. | . | 제네릭을 깊이 공부하다보면 상위경계 / 하위경계 라는 개념이 나온다. 그리고 각각을 조합할 수 있다. . . DiscountPolicy 이자 Condition을 만족하는 Type(의 하위)만 올 수 있다. . 여기오는 T형은 반드시 Policy이면서 Condition이어야만 한다. . 상속은 안되고 2개 동시에 implement를 통해 만든 것이어야한다. . 제네릭T의 경계 조건(2개이상 사용가능) -&gt; 필요한 것만 받는다. -&gt; if분기를 대체할 수 도 있다. | . . | . | . | . | 제네릭 -&gt; 형에 따른 if분기를 컴파일러에게 맡긴다. if를 제거하는 유일한 방법: 바깥에 if분기를 위임 -&gt; 거기에서 객체처리기로 객체 생성 -&gt; 받기 바깥에 위임한 객체처리기조차 형으로 대체할 수 있다. -&gt; 제네릭 if분기 대체를 객체 -&gt; 형으로 대체하는 방법 | . | 형으로 대체해서 집어넣는 것만으로도 if를 대체할 수 있으니 제네릭을 사용한다. | . | . | 이 제네릭 T의 상위경계(bound) —&gt; if에서의 조건을 의미하게 된다. . 각 if에서 맞는 객체처리기 객체—&gt; 상위경계를 만족하는 추상체를 상속받아서 구현한 자식class들 | . | if문을 쓰는 대신 -&gt; 각 case에 맞는 interface를 상속 or impl한 추상클래스를 만들고 —&gt; 그것(들)을 상위경계로 하는 제네릭&lt;T extends&gt;를 사용해서 대체할 수 있다. . **2중 if문을 -&gt; 각 조건(policy + condition)마다 interface로 만들고, ** . 2개의 인터페이스로 빼낸 뒤 . | 1개를 막아주는 구상클래스로 바꿈 . | . | 2개 조건을 각각 implementation으로 넘어오게 하는 추상클래스를 구현한다. . . 컴파일러가 각 조건에 맞는 코드를 내부에서 구현하게 된다. 컴파일러가 제공해주는 Type의 router로 봐도 된다는 개념 | . | . | class의 이름에서부터 이중 if조건이 걸려있도록 정의한다. . A: Sequence &amp; B: Percent인 Discount | . | | 코드에서 if를 안보이게 하는 방법 router도입이 아니라 제네릭을 도입하는 것이다. if문 자체가 -&gt; 컴파일러로 숨어진다. (사용자코드에서 존재하지 않게 됨) | . | . | 응용: if조건이 3개다? –&gt; implements에 3개가 오는 추상클래스를 구현 –&gt; 제네릭이 상위경계로 받으며 구상클래스(Moive) 정의 조건의 갯수 = 추상클래스가 implements하는 갯수 | 조건의 분기갯수 = 각 추상클래스마다 정의해놓아야하는 구상클래스 제네릭은 이 구상클래스들을 &lt;T extends 조건1구상 &amp; 조건2구상 &amp; 조건3구상&gt;으로 상위경계를 잡는다. 재귀함수를 loop로 바꾸듯이 익숙해져야한다. 재귀함수 -&gt; 꼬리물기 최적화 -&gt; loop | . | if문 -&gt; 제네릭으로 분산시키는 것도 자연스러워야한다! 제네릭 분산시스템 -&gt; 묶어서 -&gt; if문 객체들로 바꾸는 것도 자연스러워야한다. | . | . | . | . | . 다시 movie . . movie가 제네릭인 이유? . movie에 적용되어야하는 조건이 2가지다. . 조건갯수만큼의 추상클래스 -&gt; 그 조건의 분기만큼의 구상클래스 中 1개 선택 | 그 조건의 갯수만큼 extends로 연결한 제네릭을 사용 | | 조건에 대한 경우의수를 받아들이는 조건을 제네릭 - 상위경계로 받아들여서 class를 정의한다. . | 생성자에서도 T제네릭형에 맞는 condition을 받아들인다. . . T형의 conditions는 반드시 상위경계의 하위 형으로만 올 수 있기 때문에 일관된 policy를 가진 condition이 올 것이다. | . | | conditions들을 Set으로 만들어서 추가로 집어넣는다. . . list를 쓴다? 값 context를 생각하고 있는 것이다. 0번과 1번 element가 반드시 다를 것이라고 생각한다면, set을 안쓸 수가 없다. 객체 context -&gt; 식별자에 의한 구분만 한다? -&gt; list 쓸리가 없다. set을 쓴다. | . | list의 index -&gt; 값 -&gt; 이것에 의존해서 0번과 5번을 구분한다. -&gt; 값에 의존한다. | . | 컨테이너에 값이 아닌 객체로 식별하고 싶다 -&gt; set만 사용해서 집어넣는다. | . | . . Movie가 할인정책(discountConditions)과 원가(fee)를 알고 있기 때문에, 정보전문가패턴으로? Movie만이 calculateFee()를 할 수 있다. 어떤 상영인지, 관객수 를 외부에서 받아서 계산한다. | 할인조건은 여러개일 수 있다. for문으로 돌면서 현재에 맞는 조건을 찾는다. -&gt; 맞는 조건 = 여러조건들 중 발동조건 = isSatisfiedBy() | . | condition에 내제된 있는 계산방법을 통해, 인원수만큼 multi해서 return해준다. | . | 여기서 애매한 점: moive calculateFee에 audienceCount를 곱하는 책임을 가져야하냐? 미래에 fee를 계산할 때, 관객수에 따라 fee에 미칠 것 같았으므로, movie에게 audienceCount를 넘겨서 condition내부의 multi를 수행하는 권한을 줬다. 역할 권한: 내부 나만이 알 수 있는 것들 (알 책임) 니가 그런 권한이 있으니, 그것을 할 수 있지로 설명 | . | 책임: 외부한테 수행하는 메세지 (할 책임) | . | . | 맨 처음에는 audienceCount가 isSatisfiedBy()를 판단하는 인자 중 1개로 들어갔다. 시간대 말고, 몇명이 예약했는지에 따라 더 깍아주기 위해서 받아들였었다. | . | . | . | if 발동조건에 안걸렸더라면 (return안되고 생략된 else 부분쪽으로 빠져나오면 -&gt;) 할인없는 할인없이 fee를 받환하도록 return걸어준다. | . Money . value object . . . 객체처럼 참조의 참조가 가능(껍데기 -&gt; 업데이트된 내부 접근)하지만, 값의 특성도 가지고 있는 박쥐같은 녀석이다. | . | 값객체의 참조는 -&gt; 새로운 참조(새 객체)를 return하게끔 되어있다. 불변성으로서 값은 불변이다. | 값이 변할때마다 새 객체를 return한다. 유용하기 때문에, 다른언어들은 내장하고 있다. ex&gt; swift-structure | 객체기 때문에 참조의 참조가 되긴한다. 그렇지만 복사본만 return되고 값은 불변 | . | java에선 지원안해서 직접 구현해야한다. | . | | 자세히 보기 처음에 final로 Double amount가 확정된다. 모든 필드는 final이어야한다. (불변특성을 확정하고 있다) | . | 일반적인 연산에서도 new Money()의 새로운 객체를 return하고 있다. 값을 갱신(변경)할 수 없으니, 새로운 값을 가지는 객체를 만들어 return한다. 뺄셈에 있어서는, 본인amount &gt; 받아온 amount의 크기를 비교하고, 작거나 같으면 하한선 0을 return하게 한다 | . | multi()는 amount(Money)객체가 아니라 Double times인 값을 받아들인다. audienceCount를 객체가 아닌 값으로 처리했던 응보를 받는 부분이다. | 어떤 객체context에서라도 단 1개의 primitive를 채용하면… -&gt; 전역적으로 값을 쓰는 이질적 api를 생성하게 되어버린다. | . | 되도록이면 객체로 바꿔야한다. times는 money와는 다른 것 같지만, times를 객체로 처리했고 &amp; times와 money를 추상화했을 때, abstractNumbers의 공통 추상체가 만들어질지 아무도 모른다. 객체로 만들면 추상화될 희망이 있다. | 2개의 책임 모으기 -&gt; 1개의 역할 도출의 추상화 할 가능성이 있다. | 역할을 상속받은 2개를 만듬 -&gt; 한번에 처리될 수 있음. | . | primitive가 온 순간 확장(추상화 등)은 없다. 반드시 객체가 오도록 하자. | . | . | | . . greaterThan()과 같은 비교연산도 얄짤없이 내부api로 정의해서 은닉화된다. . amount는 private한 속성으로서 외부에 노출안된다. | 외부에 boolean 값을 return하는 경우에도, 내부에서 연산해서 건네준다. | . | 값 객체의 장점 . 번거로워도 값객체 -&gt; private필드로 내부에 데이터 은닉 -&gt; 외부는 정의한 api를 통해서만 대화할 수 있다. -&gt; 연산의 안전성 보장. . | new 새객체를 return하기 때문에 -&gt; 기존 상태에 간섭할 수 없음. -&gt; 객체임에도 동시성 문제에 자유로워진다 . | | 확정된 도메인, 확정된 연산 -&gt; 값 객체로 바꾸는 것을 고려하자 . 이유: 동시성 문제에 자유로워지니까 | . | . Reservation(value object2) . . 이펙티브 자바에서 나오는 null대신에 쓰는 static final NONE객체 나온다. NONE 객체는 불변으로final, 돌려쓰기static는 객체인가보다. | . | 그외에 예약은 순수한 데이터 정보 -&gt; 다 final이다. 극장 | 영화 | 상영시간 | 명수 | . | Reservation도 순수한 값객체이다. 연산을 제공하지 않아서 복사본 new Reservation()이 없는 것 뿐이지, 모든 필드가 final인 값객체다. | 다 final인 값 객체는 return새객체가 없어도 만들고 나면 못건듬=변경불가=다final이라서 쓰레드안전 | . | . Screening(value object3) . . Screening도 다 final로 들어오는 순수 데이터 정보라서 값객체다. 단지 seat만 private이면서 final이 아닌데, TRIGGER(is~/has~) 와 -&gt; ACTION을 통해 발동조건에 따라 변동(count보다 많을 때, count만큼 까야지 완성)이 있기 때문이다. | . | 객체 생성시 trigger(bool반환 메소드) 와 그 trigger발동조건 만족시 action이 있다면? 외부 상황(count)에 사정에 따라 맞춰서 사용되는(lazy하게 사용) 것들일 경우, 최소한의 인터페이스 2개 (trigger + action)를 정의한다. | . | trigger: 현재 Screening이 외부 count만큼 seat를 가지고 있나?? count만큼 예약해줘 -&gt; 가지고 있는 seat에서 까줘(Screening이 할 수 있는 것은 전체seat수에서 count만큼 빼는 것) | . | action: trigger를 만족할 경우에만 처리 안그럼 thr | . | . Theater 업글하기 . . . amount -&gt; 값객체 Money로 업그레이드 . | 각 Theater마다 계약하고 있는 TicketOffice Set들이 있다. . | 각 Movie마다, movie에 맞는 Screening Set들이 있다. . . TicketOffice처럼 그냥 Set&lt;&gt;으로 정의해도 될 것 같지만, Movie에 Screening이 없는 경우에 편하게 map.empty()처럼 편하게 메소드를 쓸 수 있도록 set위에 hasmap을 씌웠다. | . | . . addMovie(key추가)시 이미 존재하는 거면, add의 결과로 false를 / 그게 아니라면 새로운 movie마다 set에 보관할 수 있도록 빈set을 생성해준다. | . | addScreening(value추가)시 해당 movie에 screening을 추가해주는 것이므로 2개의 인자를 받는다. | movie가 아예 존재하지도 않으면, false로 끝낸다. | 있으면, movie마다 빈 set에 있던 곳에 screening을 넣어준다. | . | . . rate를 가지고 특정 office와 계약한다 . office에서도 계약을 해보고 잘됬으면, 여러 offices들 중 한개로 추가한다. | . | remove로 계약을 cancel할 수 도 있다. . | plusAmount(Money amount) . ticketOffice가 표를 팔았으면, theater의 재산을 plusAmount해준다. . | 가지고 있는 값 객체(amount)를 plus해주면 -&gt; new Amount새 값객체가 나오고 -&gt; 다시 재할당해준다. . 값 객체의 변동은 새 객체 -&gt; 재할당해줘야하는 것이 숙명 . . this.amount같은 값 객체의 할당부분을 외부에 노출해선 안된다. | . | 값 객체는 포인터(Money)의 포인터(amount)를 깨먹고 있다. . amount의 참조를 바꾸고 싶지 않았다. | Money객체(외부)는 그대로 있고, double amount(내부)만 바뀌었으면 좋겠는데 Money객체(외부)가 새객체로 재할당되었다. | . | this.amount 자체의 포인터가 변경된다.( my) 내부 내용만 바뀌던 것이 껍데기 자체가 바뀜 ) 기존Money -&gt; 새 Money객체 by this.amount.plus(amount) - 값객체연산 | . | 따라서, 값객체를 할당하고 있는 field(this.amount) = 값객체 껍데기 필드가 외부에서 노출안되게 한다. this.amount = 값 객체(껍데기)를 가리키는 포인터 값객체의 내부 연산시 -&gt; 새객체할당 -&gt; 껍데기 자체가 바뀐다. | 이 새객체 할당 to this.amount(값 객체 포인터) 부분이 외부에선 드러나선 안된다. | . | . | += 의 증감이 아니라 =새객체 재할당부분이 외부에 노출되었다 ? 그 외부에 노출된 부분은 -&gt; 새객체 재할당 이전의 옛날 Money(값객체)를 가지고 있을 것 | . | . | . | my) 값객체: 객체 사용 = 껍데기-&gt;내부필드 =포인터의 포인터 과정이 없어지고 . **값 객체 할당부분(this.amount = ) = 껍데기 보단 내부필드나 마찬가지 -&gt; 외부에서 쓰지마. 내부 부분이나 마찬가지 이므로, 한번 노출되면 업데이트 안됨. 외부노출된 것들은 과거의 것 가지게 됨. ** | 값 객체의 할당은 뒤쳐지기 싫으면, 내부 연산 -&gt; 새객체 할당에서만 사용 | . | my) 일반적인 값의 변화 . 원래 객체로 쌈 -&gt; 껍데기에 접근 -&gt; 내부에서 원시필드 한번 더 접근 내부 원시필드 변화 -&gt; 껍데기(포인터1)에 접근하면 -&gt; 업데이트된 내부원시필드(포인터2)를 받아볼 수 있다. | 값 객체는 외부 껍데기의 변화 -&gt; 내부는 final로 고정된 값. 아예 외부껍데기 1개밖에 존재 안함 -&gt; 어떻게 접근하든 업데이트는 안됨 -&gt; 외부에서 사용금지 | . | . | . | 값객체의 외부노출은 -&gt; 값으로 환원해서 외부노출밖에 없다. . 값객체의 변화는 껍데기-&gt;내부필드 변화가 아니라, 껍데기 자체의 변화이므로 업데이트를 받아볼 길이 없기 때문 | 값 객체의 숙명 값객체를 그대로 외부에 노출한다면? -&gt; 값객체연산후 새객체가 들어옴 -&gt; 참조가 깨지게 됨.(옜날 객체에서 업데이트 안됨) | . | . | . . getScreening은 movie에서부터 screening Set 리스트를 얻어내는 것 movie가 존재하지 않으면 null return아니라 EMPTY객체 return | . | isValidScreening: 상영중인지 확인하는 인터페이스 이 movie가 이 screening을 가지고 있는지 감정해주는 것 movie를 가지고 &amp;&amp; 그 screening을 가지고 있다 | . | . | . . enter Customer가 오면, 거기에 있는 reservation을 가져와서 NONE이 아니다. | 예약속.theater == this(현재 극장) | 예약속 movie-screening이 유요한지 | 예약속 count == 현재 들어온 사람수 맞는지 다 통과하면 true가 반환된다. | | . | reserve movie, screening, count를 보내면 movie, screening이 valid한 것인지 확인 | screening한테 hasSeat있는지 물어본다 둘중에 하나라도 아니면 -&gt; NONE객체 반환 | . | . | screening한테 seat를 count만큼 까라고 시킨다. | 극장(this)를 포함해서, movie, screening, count다 포함시켜서 -&gt; Reservation을 만든다. **요청을 받게 되면 무조건 예약 발급된다? ** **public이 아니다 = 내부만 호출한다 = 계약맺은 애들만 reserve를 호출 할 수 있게 한다. ** | . | . | reserve호출 여부 판단은 변화율이 크다 -&gt; 외부로 ticketOffice한테 뺐다. | . | . TicketOffice . . ticketOffice는 자본금인 amount를 가지고 있고 | Map을 통해서 &lt;극장마다, 얼마의 할인율Rate&gt;로 계약맺었는지를 가지고 있다. contract()할 때, map에 집어넣는다. | cancel()을 통해, map에서 빼낸다. | . | . . **핵심적인 것은 TicketOffice에게 TicketSeller가 reserve해달라고 요청한다. ** | 이게 TicketOffice에게 있는 reserve()의 역할이다. 궁극적으로는 theater에게 reserve해달라고 한다. 그전에 office에 계약된 theater인지 확인하고 | 극장에게 상영중인 movie인지 물어보고 | 스크리닝한테 seat자리 있는지 물어보고 만족안하면 reservation불가인 NONE객체로 처리한다. | . | . | . | 극장에게 reserve요청한 결과물 reservation이 NONE만 아니면 -&gt; 제대로 예약된 것이다. - NONE 객체라면, 그 NONE객체를 담고있는 결과물변수를 return해주면 된다. 극장에서 reservation이 되었다면? movie에게 calculateFee()를 때려서 총매출을 구하고 | 총매출에서 commissionRate를 곱해, 내(Office)가 먹을 커미션을 구한다. | 내 재산amount에 commision만큼 더해주고 | 극장에게는 총매출 - 커미션만큼을 매출로 더해준다. | . | 여기까지가 Office에서 하는 reserve | . | . TicketSeller . . tickerOffice와 계약맺는 절차가 있고 | reserve는 Customer와 한다. 일단은 기본적으로 Reservation이 없다고 생각하고 진행한다.(중첩if의 else마다 할당될 값을 else 없이 &amp; 미리 할당해놓음) | 일단 movie에게서 price를 가져온 뒤 | customer에게 그 돈이 있는지 일단 물어본다. customer가 돈있는게 확인되면 | Office에게 reserve()로 reservation을 받아온 다음, | 유효한 reservation이라면, customer에게 돈을 뜯어낸다. | . | NONE이든 유효한 reservation이든 -&gt; reservation을 return해서 끝낸다. | . | . Customer . . 일단은 기본적으로 Reservation이 없다고 생각하고 NONE객체를 가진체 진행한다. TicketSeller도 이걸로 시작 -&gt; 받아오기 시도 -&gt; 없으면 그대로 NONE객체 반환 | Customer도 이걸로 시작 -&gt; 받아오기 시도 -&gt; 없으면 그대로 NONE객체 반환 | . | seller에게 seller.reserve()를 요청하는 reserve를 정의한다. | hasAmount와 minusAmount는 값객체를 외부에 공개해야하는 api | . Main 다시보기 . . Movie를 만들 때 . **제네릭 를 상위경계 T로 지정했으므로** 그 자식인 Sequence + AmountDiscount를 받았다. | XXXX + AmountDiscount를 다 받을 수 있게 된다. **if문 2개를 대체한 것 ( Amount vs Time ) -&gt; 그 추상체 자식들 중 ( Sequence vs …. ) ** | Sequence 자리의 XXX는 DI(injection)이 주입해준다. | . | 제네릭과 친해지면 if문이 완전히 없어진다.(router나 외부 객체처리기 없이 if문 다 없어짐) IF문 -&gt; 제네릭이 대체함. | 제네릭에서 인젝션을 DI가 해준다. 우리는 인젝션할 DI의 객체만 바꿔주면 된다. | . | . | . | . . sequnce가 1일 때, amount 1000원을 깍아주는 discount policy다. | . | theater에게 movie집어넣기 | theater에게 movie마다 여러개의 screening들을 map에 집어넣어서 movie-screening들쌍을 만들어준다. | . . ticketOffice를 만들고-&gt; theater와 계약을 하고 . | seller를 만들어서 -&gt; ticketOffice와 계약하고 . | customer만드는 코드가 빠짐 . Customer customer = new Customer(Money.of(20000.0)); . | screening이 돌아가면서 . customer가 seller와 예약을 함 예약시 customer내부에 reservation객체를 가지게 됨. | . | reservation을 가진 customer가 theater에 enter입장함 결과를 return받아서 출력 | . | . | 4장, 5장 일부까지 정리 . 실제 워킹하는 코드임. | 본인만의 역할모델 짜보기 | . | .",
            "url": "blog.chojaeseong.com/object/2022/05/07/(object1-5)theater_with_reservation_%EA%B0%9D%EC%B2%B4%EC%84%A4%EA%B3%842.html",
            "relUrl": "/object/2022/05/07/(object1-5)theater_with_reservation_%EA%B0%9D%EC%B2%B4%EC%84%A4%EA%B3%842.html",
            "date": " • May 7, 2022"
        }
        
    
  
    
        ,"post73": {
            "title": "OBJECT 04 Type, Condition, 책임기반개발(코드스핏츠)",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ . | 참고 유튜브 : https://www.youtube.com/watch?v=sWyZUzQW3IM&amp;list=PLBNdLLaRx_rI-UsVIGeWX_iv-e8cxpLxS&amp;index=1 | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . ch4. Type과 condition . Type: 형 . 우리가 보통 알고 있는 type은 data type이다. . 변수이름 = 메모리 주소의 별명이다. a = 3: a라는 메모리 주소에 3을 할당했다. | . | data type = 메모리 주소로부터 시작하여 얼만큼 길이를 차지하는지 데이터의 길이 java의 원시형 data type들도 다 데이터의 길이다. | . | . | 객체지향에서 Type(형)은 dataType이 아니라 모든 것을 형으로 바꿔서 생각하는 개념이다. ~형(Type): 객체지향에서 구현 가능한 유일한 개념 -&gt; 무조건 ~형으로 구현한다. Type(형)으로 만들 수 없으면, 개념을 구현할 수 없는 것이다. | . | . | Type(형)의 사용 Role(역할): 역할은 반드시 Type으로 구현되어야한다. 인터페이스가 됬든class가 됬든 enum이 됬든 Type으로 구현해야 역할을 지정한 것이다. | . | Responsibility(책임): 책임(~할수있음을 수행)도 Type으로 드러난(로직을 구현)다. 어떤 애가 예약을 받을 수 있다 -&gt; Reservationable 인터페이스의 형(Type) Reservationable이라는 형(Type)이 예약받을 수 있음을 증명한다 = 책임 | . | 내가 수행해야할 책임(역할 중 특정 책임 수행시에도) = 형으로 드러난다 | 람다로 써서 함수로 넘기면요? -&gt; 함수의 시그니쳐도 다 형(func형)이다. | . | **Message(메세지): 특정 역할끼리 or 특정 책임끼리 협력을 위해 -&gt; 메세지를 주고 받을 때도 그 메세지 조차도 형(Type)으로 되어있다. ** 궁금한 점: 다른 객체에게 메서드 호출해서 인자를 보낼 때, 그 인자가 string or integer라면 형(type)으로 봐야할까? (X) string or integer는 값이다. | 형과 값의 차이는 ? 값: 불변이며, 보내도 복제된 객체를 만들어낸다. | 형 보내면 객체의 주소(참조)를 보낸다. | . | . | 값은 상태관리의 책임이 없으며, (참조X -&gt;) 캡슐라이즈를 할 수 없기 때문에, 객체지향에서 쓰지 않는다. 값을 주고 받으면 -&gt; 책임 위임이 안됨 -&gt; 협력대상 X 동등한 대상X | . | 원하는 역할/책임(로직)/메세지를 받으면 형으로 바꿔야한다. | . | Protocal(프로토콜): 객체 양자간 협의에 의해 서로 동의된 공통요소를 쓰자고 합의를 본 내용 swift: 인터페이스 -&gt; 프로토콜이라고 씀. -&gt; 다 형으로 표현되어야 의미가 있다. | 이펙티브 자바 책: 마커 인터페이스 -&gt; 우리가 원하는 계약을 형으로 표현하기 위해, 몸체는 없지만 형을 가지게 한다. | . | | . static, enum, class: jvm 동원 가능 3가지 타입 . . static: 인스턴스 단 1개만 존재시 + 동시성문제 보유 . 싱글톤 대신 static을 쓰며, static이 적용된 field, contxext 전부 다 단 1개를 의미한다. | 주의점: static 초기화 -&gt; 호출, 작동이 thread안전이 아니라는 점 jvm에서 동시성을 보장하는 장치가 없기 때문에, 싱글톤 보장하도록 코드를 직접짜야한다. | 토이프로젝트에서는 문제 x , 상용 프로젝트에서는 문제점을 보게 됨. 그래서 많은 책에서는 static context를 완전히 버리기를 권유함. -&gt; instance context만 사용 | 왠만하면, static사용없이 instance로만 구현하자. 왜냐면 동시성 해결 잘 못할 것 같으니까 | . | . | . enum: 제한된 수의 인스턴스 존재시 + 제네릭 사용불가 . 사실 class와 완전히 동일하나, jvm이 시작시 instance를 만들어주고 시작한다. | class는 원하는 수만큼 instance를 만들어낼 수 있으나 enum은 명시된 제한된 수의 instance만 만들며, jvm이 static보다 더 빨리 만들어주고 시작한다. 생성에 대한 동시성 문제에 대해 안전성이 확보됨. | 하나의 instance를 만들더라도, 사실은 enum으로 만드는게 유리하다. | . | . | 일반적으로 1개의 인스턴스 생성할 때 -&gt; static context | 여러개의 인스턴스를 확정적으로 생성할 때 -&gt; enum | 몇 개 만들지 모를 때, 무제한 인스턴스시 -&gt; class 많은 경우에 인스턴스가 무한이 아니라는 알고 있어서, class -&gt; enum 으로 대체되는 경우가 많다. | enum은 값이 아니라 참조라는 점에서 좋다 but 제네릭에 사용할 수 없다.는 것이 단점이다. -&gt; 형 대체가 불가능하다. | 그래서 마커 인터페이스를 비록한, 다양한 class, 인터페이스로 형을 지정할 수 밖에없다. | . | . | . | 정리: 동원할 수 있는 3개의 context중에 주력으로 할 것은 동시성문제X + 제네릭에 사용가능 + 무제한 인스턴스 생성가능한 class(+인터페이스)를 주력으로 형(Type)으로 쓰게 된다. | 확장이 없는 제한된 instance -&gt; enum을 쓸 때도 값이나 type의 확정이 아닌, 일반적인 인스턴스가 확정될 수 잇는 경우에도 enum을..? | . | static은 우리의 적이다. 왠만하면 쓰지 않는다. **factory(자신context(X). 하나의 instance만들어주는 공장일뿐 -&gt; 동시성 문제 X)나 ** | utility 함수(원래부터 상태를 갖지않음) 인 경우만 사용한다. | . | . | 이 책에서는 메소드의 정의를 4번을 다루지만, 간단히 유틸리티 함수와 인스턴스메서드를 구분하는 방법은 class 속 메소드에 this가 등장하지 않는다? -&gt; 유틸리티 함수 -&gt; class에서 빼내야한다 인자와 지역변수만 가짐 or 모두 공유하는 전역context만 가지고 정의 | class속 인스턴스메소드로 유지되면 절대 안됨 | . | this 또는 유지되는 instance의 사용범위 lifecycle?을 가지고 있다면 -&gt; class속 메서드 | . | . Condition: 조건 . 조건: 특정 상태(인스턴스의필드or변수)에 대한 연산 만약 특정상태(인스턴스의 필드 or 지역변수 or 변수)에 의존하지 않는 연산이라면, 고정되어서 분기될 일이 없어진다. 안쪽이 변수, 필드라서 runtime이 바뀔 가능성이 있어야 분기의 의미가 있다. | 분기 = 특정 상태에 의한 분기 -&gt; 상태(필드, 변수)가 더 중요한 말이다. | . | . | . . 조건 분기는 결코 제거할 수 없다. 우리는 코드안의 if를 절대 제거할 수 없다. 신입사원 연봉이 if 6개월 지났으면 100만원 더 오른다 -&gt; if 제거하면 구현 못한다. | . | if는 몇단계 중첩까지 감당할 수 있을까? if 2단계부터는 60%이상의 사람들은 감당 못한다 -&gt; if 1단계까지만 감당한다. 사람의 머리는 분기에 약하기 때문 -&gt; 분기 늘어나면 경우의 수를 빼먹게 된다. | . | . | . | 조건 분기에 대해 쓸 수 있는 방법은 2가지 뿐이다. 내부에 응집성있게 모아두기 switch… 장점: 모든 경우의수를 한눈에 파악 (관리가 편하다) | 단점: 분기 늘어날 때마다 코드 전체를 변경 -&gt; 수많은 위험과 회귀테스트 spring @annotation 대신 if문이라면.. | . | . | . | 외부에 분기를 위임하여 내부에선 처리기만 호출 -&gt; 외부에서 분기를 선택하는 방식 함수 내부에 있던 if + else -&gt; 함수 바깥에 if + else를 둔다. | 조건 분기를 처리하는 방식은 내-&gt;외부로 위치를 바꾸는 방법 밖에 없다. 장점: 분기 늘어날 때마다 외부 처리기에 if만 1개 추가 해준다. (전체코드변경X) | 단점: 모든 경우의 수를 내부에서 파악할 수 없다. 외부에서 if분기가 끝난 객체 1개만 -&gt; 내부에서 받는다. spring에서 @annotation 방식으로 url을 지정 -&gt; 총 몇개 url있는지 모르는 것과 마찬가지 | . | 책과 디자인패턴의 대부분이 이것을 구현하는 것 | . | 디자인 패턴에서는 전략패턴, 상태패턴 등 대부분의 패턴이 이 방식이 따르고 있다. 전략 패턴: 전략 객체에 가서 처리 -&gt; 전략 객체 5개면, 5개의 if문을 함수안에 넣어도 되는데, 바깥에서 5개의 경우의 수만큼 전략객체를 미리 만들고 바깥에서 전략객체를 선택해서 주면 -&gt; 내부는 받아서 수행만 | . | . | . | | 내부 cohesion응집성 있는 코드(한 눈에 잘보이는 코드) . ​ . processCondition하려면, 상태인 condition을 받아서 if로 해당 컨디션인지 검사한 뒤 거기에 맞는 처리기()를 호출해주고 있다. | . | . | . 분기를 외부화한 코드 . . 바깥에서, 이미 정해진 분기마다, 처리기를 생성하도록 해놓고 생성된 처리기만 로 넘겨준다. ![image-20220125220922980](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220125220922980.png) | . | 내부에서는 처리기만 받아서, 호출만해주면 된다. ![image-20220125221008291](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220125221008291.png) . | **정확하게 전략패턴이다. if는 없어지지 않는다. 외부로 옮겼을 뿐 ** 이 분기를 외부화했을 때의 장점은? 내부 코드는 수정할 필요가 없어진다. 외부코드 = client코드 = client마다 새로 작성해야할 코드 -&gt; 어차피 원래 새로 작성/수정되는 곳에 if분기를 옮겨놨다. 변화가능성 있는 분기 if코드를 &lt;어차피 변화하는&gt; client코드로 옮기는 것이 목적이다. | . | 내부코드 = utilies측 코드 = 수정없이 계속 재사용가능한 코드(library layer) 계속 재사용 가능한 코드를 더이상 수정할 필요가 없어졌다. | 내부인 library layer 코드에 &lt;변화가능성의 if분기&gt;가 있다면 확장을 더이상 할 수 가 없다. 한번 배포하면 거의 못고침. | 예를 들어, 내부(server 코드)의 attack메소드(재사용되는 코드)를 작성하는데 무기 100종마다 if문이 attack에 작성되어있다고 치자(내부에 if분기) | 업데이트 때 101번째 무기가 추가된다면? 내부server의 attack이라는 기본모듈을 업데이트(전체 다운로드) 하나? ㄴㄴ | . | 외부(client쪽 코드)에 무기 분기를 두면, 무기 추가시 -&gt; 외부에서 101번째 무기 분기만 추가해주고 내부 라이브러리 속 attack메소드에 101번째 무기 정보만 건네주면 된다. | . | 변화율이 적은 코드(무기사용 코드)-&gt; 변화율 큰 if분기 등을 제외하고 배포해야한다. 변화율 큰 코드(무기 추가하는 분기 코드) -&gt; 변화율 큰 쪽에 두어 어차피 수정할때 수정하게 한다 | . | . | . | . | . | | . | IF분기(를 포함한 자주바뀌는 코드)는 외부로 옮기고, 각 경우마다 객체를 만들어서 공급해주자.그럼 내부 2단계 분기 -&gt; 외부1단계 + 내부 1단계로 고칠 수 도 있다. if의 depth를 1개까지만 주자. 2개 이상의 복잡한 코드라면, 외부로 if를 빼고, 그 경우마다 객체를 만들어서 공급해주자. my) 메소드라면, 미호출 메소드 = 객체로 넘긴다. | . | if를 내부에서 제거하는 방법은 이것 밖에 없다 | . | . 책임기반 개발 . . 2003년 웨슬리에서 나온 책이 2004년 번역되어서 나왔다. 구할 수 있음 구해봐라. [Evans 2004] Evans, Domain Driven. Addison Wesley,2004. or | [Fowler 2003] Martin Folwer 등, Patterns of Enterprise Application Architecture, Addison Wesley, 2003. 책임기반의 개발, 전문가 패턴 등 패턴들을 다루게 된다. | 오브젝트책은 이 책을 쉽게 해설한 책이다. | . | . | . 책임(들) -&gt; 역할 -&gt; 추가 책임 . . 책임기반의 개발에서 나오는 여러가지 개념을 쉽게 설명하도록 하자. . 어떤 시스템의 가치는 무엇이냐? 사용자에게 기능을 제공함으로써 가치가 생김 . | 사용자가 사용할 기능 = 가치 = 시스템의 책임 . 예매사이트 들어갔는데 예매가 안된다? 싸이트의 가치는 0임. | 사이트가 최우선적 방어해야할 책임 = 예매(사용자 기능) | 책임 = (기능 =) 가치 그자체( 시스템, 객체, 역할 무엇이 됬든, 유일한 가치는 책임(사용자 기능)과 일치한다) | . | (시스템의 책임에만 집중하면 된다.) 시스템 차원의 책임 -&gt; 더 작은 단위의 책임으로 분할하자. 그리고 책임은 = 기능이며 = (알고리즘 코드가 들어있는 진짜 working하고 있는) 함수 (인터페이스, 추상클래스는 X 프로토콜만 있는지 workingX 껍데기일 뿐. 구상클래스의 메소드가 책임) . 예매 = 기능 = 코드가 있지지만 너무 복잡한 함수 -&gt; depth2이상의 if 등 -&gt; 분리시킨다. . | 예매가 잘되어야한다? -&gt; 방대한 책임이다 -&gt; 머리가 나빠서 다 이해할 수 없다. | 딱딱 잘라지진 않는다. -&gt; 이게 바로 실력(3~5년 걸리는 역할모델의 책임) 응집성은 높으면서도(한눈에 보임) 의존성=결합도가 낮은 부분으로 쪼갤 수 있느냐 | . | . | 책임(쪼갠 함수)들의 공통점/공통의존기능을 추상화한 것을 -&gt; 역할이라고 정의할 수 있다. 만약 성공했다면, 반대로 새로운 책임(케이스, 사례)을 추가할 수 도 있다. . 함수 분리과정에서 함수끼리 공통점 or 공통의존 기능을 발견하게 된다. . | 역할은 여러개의 책임(=기능=함수)가 아니다. **1개의 책임(기능)이라도 더 높은 수준으로 정의 -&gt; 나중에 공통점이 모일 수도 있도록 추상화한 것 ** | . | 책임 -&gt; 더 높은 수준 형태로 추상화 -&gt; 역할로 승격되는 것임. cf) 1-1시간에 배운 추상화 - 객체지향적 추상화 - 일반화: 인터페이스, 추상클래스 이용 | . | 책임과 역할을 따로 생각하는 것이 어렵다. 무엇보다 다양한 책임에서 -&gt; 공통된 점(코드, 의존기능)을 뽑아내서 -&gt; 역할로 정의하는게 굉장히 어렵다. | 다양한 책임으로부터 -&gt; 역할 정의에 성공하면, 사례들 -&gt; 추상적인 것을 만들어낸 연역법이다. 성공했으면, 추상화된 역할을 가지고 -&gt; 다른 사례를 만들어낸 귀납법을 사용할 수 있다. | 일단 추상클래스를 만들어낸 순간 -&gt; 다른 사례들을 만들어낼 수 있다. if문 처리기를 더 만들어낼 수 있다. | if분기만큼의 객체를 -&gt; 외부에 위임할 수 있다는 말이다. depth if문 유일한 처리방법 : if문을 바깥쪽에 빼서, if문 case만큼 다른 객체들을 만드는 수 밖에 없다. | 만들어지는 객체들간에 공통점이 없는 것 같은데.. -&gt; 비슷한 사례들로 찾아내서 만든 역할 -&gt; 추상화된 역할로부터 새로운 다른객체를 생성하게 된다. | 어떤 사례들로 인해 객체가 생성되었어도 -&gt; 내부에선 Runnable이 왔으니까 run()만 시켜주면 된다. 여기선 Runnable이 실행되다라는 &lt;공통기능&gt; 역할이다. | 어떤 케이스로 인해 진입해서 객체를 생성했어도 생성된 객체는 일괄 Runnable == 공통점 | . | 서로 다르게 구상되어있는 각 구상클래스 속 run()메소드들의 구상화 코드들이 책임 | **책임들의 공통점을 찾아서 추상화 성공한 것이 Runnable이라는 역할 ** 공통점1: 각각의 인자들을 인자를 안받고 return도 안한다 | 공통점2: … | | 추상화 성공한 역할 Runnable을 통해 -&gt; d , e에 대한 케이스도 구상화해서 추가할 수 있게 된다. 추상화과정은 위로 올라가기도 하지만(책임들 -&gt; 공통점 -&gt; 역할 = 인터페이스 or 추상클래스 정이 성공) 아래로 내려가기도 한다(역할 -&gt; 새로운 책임 -&gt; 새로운 처리기(케이스) 추가도 가능하다) | . | 만약, 인자를 받는 경우라면? 내부 라이브러리 레이어들도 다 바뀌어야한다. 추상화 능력이 떨어지면, 수시로 라이브러리가 업데이트 된다. | . | . | 여러 케이스들을 받아들이는 처리기 -&gt; 각 케이스들의 공통점을 찾아내야한다. | . | . | . | . | . | 역할에 따라 협력이 정의된다. . 협력단계를 섵불리 책임단계에서 정의하고 싶지 않다. 책임단계에는 다양한 형식이 있음. 책임이 추가되면 협력도 깨져버림 | 보다 높은 단계인 역할단계에서 협력을 구축하고 싶다. 하나하나의 lambda함수 run()수준(책임=함수)에서 프로세스를 만드는게 아니라 Runnable수준에서 프로세스를 만들어야 귀찮은 일이 발생하지 않는다. | . | . | 어설프게 책임(함수)단계에서 협력이 정의된다 -&gt; 책임 추가/변경시마다 협력시스템까지 위험해진다. | . | | 여기까지 정리 . 값이 아니라 형Type을 써야한다 | 조건분기에 대해 쓸 수 있는 방법은 2가지 밖이다. | 그걸이용해서 설계하는 방법은.. 책임-&gt; 역할 | . | .",
            "url": "blog.chojaeseong.com/object/2022/05/05/(object1-4)Type_condition_%EC%B1%85%EC%9E%84%EA%B8%B0%EB%B0%98%EA%B0%9C%EB%B0%9C.html",
            "relUrl": "/object/2022/05/05/(object1-4)Type_condition_%EC%B1%85%EC%9E%84%EA%B8%B0%EB%B0%98%EA%B0%9C%EB%B0%9C.html",
            "date": " • May 5, 2022"
        }
        
    
  
    
        ,"post74": {
            "title": "의연방11) PSA 분석2(층화, 가중치, 공변량)",
            "content": "R 고급 실습(ps matching with datacleaning-dplyr, MatchIt, tableone-CreateTableOne, geepack-geeglm, broom-회귀계수를 OR로 변환) 포함됨 | . &#54617;&#49845;&#47785;&#54364; . PSA 방법 중 stratification, weighting, covariate adjustment 방법을 이해하고 설명할 수 있다. . | PSA를 사용한 임상논문을 읽고 내용을 이해할 수 있다. . | 임상연구를 수행할 때 주의해야할 점을 설명할 수 있다. . | . &#51452;&#50836;&#50857;&#50612; . Inverse probability of treatment weighting (IPTW) : 각 환자가 실제로 받은 treatment를 받을 확률의 역수를 weight로 사용하는 방법. 치료군과 대조군을 비교하는 PSA에서는, 치료군에 1/PS, 대조군에 1/(1-PS)의 weight를 준다. | . &#47785;&#52264; . PS 추정 후 분석방법 | 예제 논문 matching과 IPTW가 가장 많이 쓰인다. | . | 임상연구 Do’s and Don’ts | PS &#52628;&#51221; &#54980; &#48516;&#49437; &#48169;&#48277; . PS &#52628;&#51221; &#54980; &#48516;&#49437;&#48169;&#48277;(4&#44032;&#51648;) . Matching | Stratification | Weighting | Covariate adjustment | . Matching . 지난 시간 학습한 PSA 방법 | PS가 비슷한 치료군 환자와 대조군 환자를 짝짓는다 | 짝지어지지 않은 환자는 분석에서 제외한다 | 장점 : 직관적으로 이해가 쉽다 | 단점 : 짝지어지지 않는 환자의 데이터를 잃어버린다 | . Stratification (&#50836;&#51608; &#48708;&#52628;) . PS가 비슷한 환자들끼리 strata를 나눈다 (보통 4~5개) | 각각의 stratum에서 (치료방법과 )outcome(의 상관관계를 분석)을 비교하고, 그 결과를 전체 strata에 대해서 합친다 | PS score가 같은 그룹 / 중간 그룹 / 큰 그룹을 각각을 stratum으로서 그룹을 나누고 그룹별(stratum별) 분석하고 | 나중에 합친다. | . | 단점: strata를 나누는 기준이 뚜렷하지 않다 PS score 몇을 기준으로 나눌지 기준 X가 대부분 | . | stratum 별로 (너무) 다른 결과가 나올 경우 해석의 문제 한쪽에서는 상관관계 높, 한쪽에서는 낮.. 어떻게 합치고 어떻게 해석할지 애매해짐 | . | 요즘은 안쓰이는 방법 | . | . Weighting (IPTW, Inverse probability of treatment weighting) . probability of treatment의 역수이다. | 치료군의 weight는 probability of treatment = 치료 받을 확률 = 치료군에 속할 확률 = PS score자체 | 치료군의 weight = Inverse probability of treatment = 1/PS | . | 대조군의 weight 대조군의 probability of treatment = 치료받지 않을 확률 = 1 - PS | 대조군의 weight: 1/(1-PS) | . | Inverse probability of treatment를 weight로 준다 치료군 weight : 1/PS | 대조군 weight : 1/(1-PS) | . | 이렇게 weight를 준 데이터에서는 치료군과 대조군 간 PS 분포가 비슷해진다 PS 추정에 쓰인 변수들의 분포(confounding)가 비슷해진다 | . | why? weight를 주면 PS가 비슷해질까? . 각 stratum별 치료여부별(치료군/대조군별 각각) probability of treatment를 계산해보자. PS가 작은 (원의 size가 작은) 환자들을 보면, 총 8명 중 2명이 치료를 받았다. 치료군 PS(치.속.확) = 1/4 | 대조군 PS = 3/4 | . | 중간 size 환자들 | 큰 size 환자들 | | 각 stratum별 치료여부별 PS(probability of treatment)를 Inverse해서 weight로주자. 작은 size 환자들은 weight가 1보다 큰 4/3이다. 6명 -&gt; 8명으로 뻥튀기 되는 효과를 가진다. 대조군: 6명 x 4/3 = 8명 | 치료군: 2명 x 4 = 8명 | . | 중간size 대조군: 2명 x 5/2 = 5명 | 치료군: 3명 x 5/3 = 5명 | . | 큰size 대조군: 1명 x 4 = 4명 | 치료군: 3명 x 4/3 = 4명 | . | | weight를 준 데이터를 보면, 대조군과 치료군 사이에서, PS의 분포가 완전히 똑같아진다. PS 역수를 weight로 주어 뻥튀기된 데이터를 이용하면, 2군간 PS가 같아져서 balance가 맞게 됨을 이용하여 -&gt; 2군간의 confounding이 없어진다. | . | . | 장/단점 . 장점 : outcome 분석 방법의 flexibility R에서는 weight를 줘서 분석하기에 편함. 다 적용 가능. | . | 단점 : 직관적 이해가 어려움 간단한 예제도 여러 계산을 거침. matching처럼 확 이해되지 않음. Weighted data에서의 치료군과 대조군의 balance를 평가해야한다 | . | . | PS matching과 마찬가지로 SMD 이용 Weighting 이후 분석 : weighting을 고려한 분석을 해야 한다 | 회귀분석 : weight 사용. robust variance estimator 사용. | Survival outcome의 경우: adjusted Kaplan-Meier curve, modified log-rank test | PS matching과 마찬가지로, 치료군/대조군 여부 이외에 다른 공변량을 포함할 필요가 없으나, 포함을 할 경우 doubly robust 해진다 . | 주의점 . 경우에 따라서 PS가 0에 가깝거나 1에 가까워서 weight의 분모가 무한대 or 0에 근접하는 경우가 있어서 분석 결과가 불안정하게 된다. weight를 안정화시켜주는 방법들이 개발되어있다. | . | Stabilized weight(추천): marginal probability of treatment (MPT) : 전체 환자 n명 중 치료군 m명의 비율 -&gt; 계산이 간단함. 환자 특성 고려없이 전체적으로 봤을 때 치료군에 속할 확률 | . | 치료군 weight에는 바로 곱해준다. : MPT x (1/PS) | 대조군 weight에는 (1-MPT)를 곱해준다 : (1-MPT) x (1/(1-PS)) | IPWS보다는 더 안정적으로 값을 가지며, 2군간의 weight된 데이터가 PS분포가 비슷한 것 자체는 유지됨. | . | trimmed or truncated weights Stabilized weight의 방법외에 weight가 너무 크거나 작은 환자를 분석에서 제외 or 분석에 포함시키되 weight값을 truncate(한계점 넘어가면 잘라내서 고정)해주는 방법도 있다. | . | . | weight된 데이터는 PS matching처럼 balance가 잘 맞을까? . PS matching과 마찬가지로 SMD 이용해서 평가한다 | . | Weighting 이후 분석 : weighting을 고려한 분석을 해야 한다 . 회귀분석 : weight 사용. 매칭처럼 p-value/신뢰구간 계산시 robust variance estimator 사용. | . | Survival outcome의 경우: adjusted Kaplan-Meier curve, modified log-rank test weight를 줄 경우 시행해주는 평가방법?! | . | PS matching과 마찬가지로, 치료군/대조군 여부 이외에 다른 공변량을 포함할 필요가 없으나, 포함을 할 경우 doubly robust 해진다 | . | . Covariate adjustment . 4번째 PS 방법 PS 추정후 데이터를 수정하는 것이 아니라 구한 PS를 최종 모델에 공변량으로서 추가한다. | . | outcome 비교를 위한 회귀분석 모델에 PS를 공변량으로 넣는다 model: outcome~ 치료군/대조군 + PS | . | 장점 : (모든 회귀분석에 적용할 수 있어서)outcome 분석 방법의 flexibility | 단점 : outcome과 PS의 관계가 올바르게 모델 되어야 한다 PS가 선형 모델이 맞는지 취약하다. | . | 디자인 단계와 분석 단계의 완벽한 분리가 되지 않는다 PS matching이나 weighting은 데이터를 새롭게 만들어서 쓰면 되므로, 데이터 가공단계로서 분석과 별개의 단계 | 공변량으로 추가하는 것은, 분석단계 실패시, PS를 다시 추정하는 단계로 돌아가 디자인&lt;-&gt; 분석단계가 분리되지 않음. | . | . | . &#50696;&#51228; &#45436;&#47928; . &#50696;&#51228;&#45436;&#47928;1: HPV &#48177;&#49888; . . HPV백신은 임산부들에게 recommend되지 않는데, 임신하지 모르고 맞는 경우가 가끔 있을 것이다. 이 경우, 안전한가? 임신이라는 outcome에 영향을 주지 않는가? 는 중요하다. | 의학적으로 중요. HPV 백신 이후에 임신 사실을 알았을 때 어떻게 해야할지 의사결정을 해야하기 때문 | 임상시험도 할 수가 없어서 관찰연구 밖에 할 수 없다. | . | Research question: 임신 초기에 HPV 백신을 맞을 경우 안전한가? . 임신기간 중 HPV 백신은 권장되지 않기 때문에 임상시험을 통해 조사할 수 없음 → 후향적 관찰연구만 가능 | 덴마크의 nationwide register 자료를 이용, 약 7년간 단태아 임신 자료 분석를 분석 | . | Outcomes 6가지 분석: . major birth defect | spontaneous abortion(유산) | preterm birth(조산) | low birth weight(저체중아) | small size for gestational age | still birth | . | . HPV백신 맞았다 vs 안맞았다 치료군vs대조군 정의 먼저 나누는데, 이 논문에서는 특이하게 6개의 outcome마다 치료군의 정의를 다르게 했다. . outcome마다 치료군을 다르게 한 이유: 각 outcome마다 언제 맞은 HPV백신이 영향이 있을 것이다 라는 가설이 각각 달라서 일 것이다. | 치료군을 5군으로 정의했다 -&gt; 같은 데이터지만, 5번의 다른 분석을 한 것이나 마찬가지 -&gt; 총 5번의 PS matching을 한 것이다. | 치료군 정의 : 각 outcome 마다 정의가 달라짐 major birth defect : 임신 초기 12주 내에 HPV 백신을 맞은 사람 | spontaneous abortion : 임신 7주~22주에 HPV 백신을 맞은 사람 | Stillbirth : 임신 7주 이후에 HPV 백신을 맞은 사람 | preterm birth : 임신 37주 이전에 HPV 백신을 맞은 사람 | low birth weight, small size for gestational age : 임신 기간 중 HPV 백신을 맞은 사람 | . | 대조군 정의 : 치료군이 아닌 사람 | 즉, 총 5번의 PS matching을 시행 | . | . 로지스틱 회귀분석을 이용한 PS matching을 했다. 백신을 맞을 가능성(propability)를 계산함. | . | all baseline characteristics 뿐만 아니라 all two-way interactions between demographic variables 극단적이긴 한데, 모든 인터렉션을 다 포함했다. | PS model에는 설명변수의 제한이 없기 때문에, 각 특징 이외에 인터렉션까지 포함시켜서 PS matching을 돌림. | . | . . 5개의 outcome에 대해 각각 PS matching을 했는데 1:4비율로 시행함. | 매칭 수행이 PS score뿐만 아니라. 나이, 임신 시작까지 추가로 넣어서 매칭을 수행했다. | . . 오스틴이 추천하는 nearest with caliper의 방법을 썼다. | 하지만, 이 방법은 PS score 단독으로만 사용될 때 쓸 수 있는 matching이다. 앞에 나온 age, calendar year와 부합되지 않는다 -&gt; 약간 걱정됨. | . | SMD를 이용해서 평가했다. | . . 앞 부분은 생존분석을 통해 분석해서 넘어감 | outcome들에 대해 (이분형 결과변수로 분석했음을 알 수 있는) 로지스틱 회귀분석을 이용해서 prevalence OR을 구했다. 앞서 09에서 로지스틱 회귀분석으로 OR을 구해 효과를 추정했었음. | . | GEE 방법을 썼다고 했는데 매칭을 고려해서 쓴 것은 아니고 | 데이터내 한 여성이 여러번 임신해서 여러번 들어가는 경우, 한 여자에서 나왔으므로 그 데이터들은 독립이 아니기 때문에 독립이 아니다를 보정하기 위해, GEE를 통해 correlation structure를 줘서 보정했다. possible correlation between pregnancies within the same mother.... | . | 매칭을 분석해서 따로 고려하지 않고, 일반적으로 매칭하지 않은 자료로로 분석하되 한 여성이 여러임신한 경우에 대해서만 GEE로 보정했다. | . | . . PS matching을 5번 했는데, 각각에 대해서, 치료군이라고 생각한 군 / 대조군이라고 생각한 군에 기본 환자 특성만 비교한 표이다. 요약통계량만 나와있고 | p-value와 SMD를 계산하지 않았다. 수치로 2군간의 balance를 평가한 것 같진 않다. | 앞에 기술에 의해 SMD를 이용했다 했으니, 표에만 표기하지 않은 것 같다. | . | . | . . table 3가 메인 결과인데 6가지 outcome들이 나오고 | 임신 중 백신 안맞은 그룹(대조군) vs 백신 맞은 그룹(실험군)을 비교했다. | . | outcome마다 군이 달라진다(정의가 달라서) | 각 군별로 안좋은 outcome의 비율이 요약되어있다. | OR이 아니라 Measure of Association이라 적혀있는 이유는 outcome들 가운데, 어떤 것은 생존분석 -&gt; HR로 report | 어떤 것들은 OR로 report 했기 때문일 것이다. | 밑에 주석에 mbd, pb, lbw, ssforg에 대해서만 prevalence OR로 계산했다고 나온다. | . | Major birth defect의 Measure of Association을 보면 OR가 1.19에 신뢰구간이 1을 포함한다는 것은 2군간 통계적 차이가 유의미하지 않음을 의미한다. | PS matching을 한 뒤, 임신중 HPV 백신여부는 -&gt; Major birth defect발생에 유의하지 않았다. 2군간 차이가 없다. | . | . &#50696;&#51228;&#45436;&#47928;2: CABG vs. PCI . . - PCI(스텐트)수술과 캐비지(CABG, 관상동맥 우회술)수술을 비교한 논문 - 오래되고 아직도 디베이트 하고 있는 논문 . Research question: multivessel disease 환자에서 CABG와 PCI 중에어느 쪽이 결과가 좋은가? CABG : coronary-artery bypass grafting (관상동맥우회술 (수술)) | PCI : percutaneous coronary intervention (관상동맥중재술 (스텐트 시술)) | 기존 연구에서는 second-generation drug-eluting stent로 시술한 PCI를 평가하지 않음 당시에...는 새로운 pci수술을 실험함. | . | . | Outcomes 4가지: all-cause mortality | myocardial infarction | stroke | repeat revalscularization | . | . . ps matching을 했다. | 치료여부는 PCI냐 CABG냐 였다 | PCI받을 확률을 PS score로 추정하는 로지스틱 회귀분석을 했다. nonparsimonious multivariable logistic-regression model : 간단하지 않은 모델 = 설명변수를 아주 많이 넣었다. | . | . . 매칭은 1:1로 했다. | without replacement = greedy-matching을 했다 | austin 추천방법대로 caliper를 썼다 | SMD를 계산해서 평가했다 | . . 매칭후 분석은 paired된 점을 고려해서 맥니머 테스트를 했고 | 연속 변수에 대해서는 paired Student’s t-test 를 이용했다 | . . table1을 보면 깔끔하게 정리되어있다. | 매칭 전/매칭 후를 일단 나누고 매칭 전에는 각 그룹별로 요약통계량 + SMD계산이 됬는데 %로 한 것을 보니 smd x 100을 한 숫자 %를 고려하면 매칭전 smd(차이)가 그리 크진 않았다. | . | 매칭 후에는 확실히 smd가 줄었다. | . | 매칭후 balance가 좋아졌다는 것을 smd로 잘 보여줬다. | . . 메인결과는 각 outcome들에 대해서 pci받은 그룹/cabg받은 그룹에 대해 환자수 / event / hr(생존자료분석) / p-value를 보여준다. | 지금까지 생존자료분석을 하지 않고 있기 때문에, 배운 이분형 결과변수를 이용한 연구를 찾고 있었는데 없었다. ps matching에서는 생존자료분석 -&gt; HR를 report하는 연구가 많음 | . | . &#50696;&#51228;&#45436;&#47928;3: VDZ vs. ADA . . IPTW가 어떻게 기술되어있는지 가져온 논문 | 크론병에서 2가지 약(VDZ, 베돌리주맙 vs ADA, 아달이무밥)을 비교한 논문 어느 약이 효과가 더 좋은지 연구한 논문 | . | . Research question : 크론병에서 VDZ과 ADA 중 어느 약이 더 효과가 좋은가? | Sicilian Network for Inflammatory Bowel Disease 데이터를 이용한 관찰 연구 | Outcomes: failure-free survival (failure: discontinuation of VDZ or ADA due to AE or inefficacy) | clinical response: reduction of Harvey-Bradshaw Index ≥3 with concomitant decrease of steroid dosage compared with baseline | steroid-free clinical remission (Harvey-Bradshaw Index ‹5 without steroid use) | rate of surgery at the end of FU (intestinal resection + stricturoplasty – perianal surgery) | . | . . 간단하지 않은 모델: 설명변수들에 confounder의심 변수들을 넣었다고 나열해놓음 변수들을 넣고, 로지스틱 회귀분석을 통해, PS를 추정함 | . | . . 추정한 PS를 가지고, IPTW방법으로 weight를 줬는데, stablilized weights를 줬다. 분자에 marginal probability를 곱한 값을 weight로 줬다 | . | weight를 줘서 2군간의 balance를 맞추고, SMD로 평가했다. | . . balance를 맞춘 뒤, 계산한 weight를 가지고 로지스틱을 했다. IPTW-adjusted logistic regression analyses | . | 생존자료 outcome에서도 CoxPH regression에서도 마찬가지로 weight를 줘서 했다. | weight를 고려해서 robust standard errors 더 보수적인 방법으로 p-value와 신뢰구간을 계산했다. | . . table2에서 baseline characteristic을 비교했는데 | 2가지 약재에 속한 그룹별로 나와있는데, 여기서 p-value는 쓰는 것이 좋지 않다는 것을 author들이 알고 있었을 것이다. 리뷰어 요청으로 계산한 듯 보인다. | 그 이유는 SMD를 계산한 그래프를 줬기 때문이다. | . . x축이 Absolute mean difference라 적혀있어서 헤깔리는데, 논문을 읽어보면 SMD임을 알 수 있다. 빨간점: 매칭전 SMD | 파란점: 매칭이후 SMD | 매칭이후에는 모두 0.1보다 작은 SMD를 보인다. | . | 전체 환자에 대해서도 IPTW를 했고, 52주이상 FollowUp된 환자들에 대해서도 IPTW를 계산했다. SMD를 표상의 숫자가 아닌 그래프로 balance를 예쁘게 평가했다. | 변수가 많을 경우, 그래프로 나타내면 예쁘다. | . | . . outcome비교 방법이 OR이 대표적이지만, 여기서는 각 군별로 event ratio를 막대그래프로 직관적으로 보여줬다. | main으로 본 outcome은 clinical response + steroid-free remission을 합쳐서 -&gt; 둘중에 하나라도 있었는가이다. VDZ에서는 event 발생 비율이 64.3 | ADA에서는 event 발생 비율이 83.1 | 그 event 비율의 차이에 대한 p-value는 0.107 | 이러한 방식으로도 2분형 결과변수에 대한 두 군간의 차이를 보여줄 수 있다. | . | . &#51076;&#49345;&#50672;&#44396; Do&#8217;s and Don&#8217;ts . Do&#8217;s . 먼저 Research question이 있어야하고, 가설을 먼저 세운다 | 그것을 통계적으로 검정가능한 가설로 변환한다 | (가설을 test할 수 있도록) 연구 계획을 세운다 연구 디자인 정하기 case-control study? cohort study? RCT? retrospective cohort를 하는데 PS로 confounding을 보정할 것인가 | . | 데이터 수집 방법 | 데이터 분석 방법 | | 계획한 방법에 따라 데이터를 수집한다 | 계획한 방법에 따라 데이터를 분석한다 | 결과를 해석한다 | dissemination 학회나 논문으로 발표 | . | Don&#8217;ts . Research question과 명확한 가설 없이 일단 데이터부터 모은다 | 모아진 데이터로 가능한 분석들을 해본다 | 원하는 결과(p&lt;0.05)가 나오지 않으면, 다른 방법으로 다시 분석한다 결과변수의 정의를 바꾼다 | 설명변수, 공변량을 바꾼다 연속형변수를 범주형 변수로, cutoff를 바꿔가며... | 범주형 변수의 변수를 다르게 묶어보고... | . | 환자군을 바꾼다 | 모델을 바꾼다 | 각종 subgroup을 본다 | . | p-value&lt;0.05가 나온 것만 발표한다 | &#47928;&#51228;&#51216; . “Research question과 명확한 가설 없이 일단 데이터부터 모은다” 연구 목적에 맞는 데이터 수집 기회 상실 디자인으로 인한 문제는 통계적으로 해결 어려움 | 질 높은 연구가 이루어지기 어려움 | . | . | “원하는 결과(p&lt;0.05)가 나올 때까지 방법을 바꿔가며 분석한다” p-value hacking, data dredging | 선택적으로 보고된 결과들의 Type I error확률이 유의수준 0.05보다 높아진다 결과를 믿을 수 있는 가능성이 높아진다. | . | Hurts replicability 같은 데이터로 재현은 할 수 있겠지만, 다른 집단에서 다른 연구자가 분석하면 같은 결과가 안나올 가능성이 높아진다. | . | 계속 바뀌는 분석방법으로 인한 피로도, 실수 가능성이 높아진다 | p-value 중심 연구 방식 자체의 문제 | p-value는 통계적 유의성만 알려주며, 이것은 임상적 유의성과는 완전히 다르다 | 귀무가설 기각 여부에 의해 Pass or fail로 나뉘는 dichotomy의 문제 | . | . &#50896;&#51064; . p-value&lt;0.05 달성에 대한 보상은 분명함 훨씬 높은 출판 가능성 | 출판된 논문 → 임용, 승진을 위한 currency | . | 연구계획수립에 대한 보상은 불분명함 미리 수립된 연구계획이 있었는지 여부가 출판 가능성에 거의 영향 없음 | 연구계획 승인 절차의 부재 (IRB? 국책 과제 심사?) | . | 애초에 연구계획의 중요성을 배운 적이 없음 연구계획 없이 연구 커리어를 이어온 선배 교수의 지도 | 연구계획의 중요성을 알아도, 연구계획 방법을 모름 | . | 통계학의 역할에 대한 오해 데이터를 넣으면 답이 나오는 블랙박스? | . | . &#54644;&#44208;&#52293; . 시스템 연구비, 보상 체계 | 임상과학 연구자 육성을 위한 지원 | . | 교육 | 통계학자, 역학자 등과 협력연구 연구 초반 가설을 세울 때부터 일찍 involve | technician이 아닌 collaborator, team member로 상호 존중과 협력 | . | . &#51221;&#47532;&#54616;&#44592; . Propensity score(PS)를 추정한 후 분석하는 방법 중, stratification은 PS 가 비슷한 환자들끼리 strata를 나누어 분석한 후 그 결과를 합치는 방법이다. | Inverse probability of treatment weighting(IPTW) 방법은 치료군은 1/PS, 대조군은 1/(1-PS)의 weight를 주어 분석하는 방법이다. | Covariate adjustment는 outcome model에 PS를 공변량으로 넣는 방법 이다. | 임상연구를 수행할 때에는 research question과 가설을 먼저 세우고 그에 맞 는 연구 계획을 세운 후, 계획한 방법으로 데이터 수집과 분석을 실시해야한다. | 원하는 결과가 나올 때까지 분석 방법을 바꾸어 하며 p-value hacking을 하 는 것은 Type I error 확률을 높이며, 연구 재현성을 해친다. | . &#50672;&#49845; &#47928;&#51228; . 01 &#45796;&#51020; Propensity score analysis &#48169;&#48277; &#51473;, &#45936;&#51060;&#53552;&#50640; weight&#47484; &#51452;&#50612;&#49436; &#52824;&#47308;&#44400;&#44284; &#45824;&#51312;&#44400;&#51032; baseline covariates&#51032; &#48516;&#54252;&#51032; &#52264;&#51060;&#47484; &#51228;&#44144;&#54616;&#45716; &#48169;&#48277;&#51008;? . Matching . | Stratification . | Inverse probability of treatment weighting . | Covariate adjustment . | 정답 : 3 | 해설 : IPTW 방법은 치료군에 1/PS, 대조군에 1/(1-PS)의 weight를 주어, weighted data에서 치료군과 대조군 간 PS 값이 분포가 비슷하게 만들고, 결과적으로 baseline covariates의 분포가 두 군간에 비슷해지게 만드는 방법이다. | . 02 &#45796;&#51020; &#51473; &#51076;&#49345;&#50672;&#44396;&#47484; &#49688;&#54665;&#54616;&#45716; &#48169;&#49885;&#51004;&#47196; &#51201;&#51208;&#54616;&#51648; &#50506;&#51008; &#44163;&#51008;? . 데이터 수집 전 먼저 가설을 명확히 세운다. . | 연구 계획에 따라 데이터를 수집하고 분석한다. . | 계획한 분석 결과가 통계적으로 유의하지 않을 경우, 결과변수의 정의를 바꾸거나 환자군을 바꾸어 유의한 결과가 나오도록 한다. . | 계획한 분석의 결과는 통계적 유의성과 관계없이 모두 보고한다. . | 정답 : 3 | 해설 : 통계적 유의성을 달성할 때까지 연구 방법을 바꾸는 행위는 p-value hacking으로서, 연구재현성을 해치고 Type I error 확률을 높인다. | .",
            "url": "blog.chojaeseong.com/r/r%EA%B3%A0%EA%B8%89/dplyr/matchit/tableone/geepack/broom/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/psa/stratification/weighting/covariate/2022/05/04/%EC%9D%98%EC%97%B0%EB%B0%A910)-Propensity-Score-Analysis-II(stratification,-weighting,-covariate-adjustment)-+-%EC%9E%84%EC%83%81%EC%97%B0%EA%B5%AC-Do's-and-Don'ts.html",
            "relUrl": "/r/r%EA%B3%A0%EA%B8%89/dplyr/matchit/tableone/geepack/broom/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/psa/stratification/weighting/covariate/2022/05/04/%EC%9D%98%EC%97%B0%EB%B0%A910)-Propensity-Score-Analysis-II(stratification,-weighting,-covariate-adjustment)-+-%EC%9E%84%EC%83%81%EC%97%B0%EA%B5%AC-Do's-and-Don'ts.html",
            "date": " • May 4, 2022"
        }
        
    
  
    
        ,"post75": {
            "title": "OBJECT 03 객체설계1_Theater(코드스핏츠)",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . ch3. Theater . 맛보기로 theater 책에서는 절차지향 -&gt; 객체지향으로 가는 과정을 설명하기 위해 만들어서, 조금 허술함 | 책 뒤쪽의 역할모델 설명처럼 정교하지 않다. | 책에 없는 역할모델을 옮기는 과정을 해볼 것이다. | . | 책에 나온 상호의존적인 표 극장이 seller와 audience를 둘다 알고 있다(화살표를 보면 됨) seller -&gt; ticketoffice -&gt; ticket 를 알고 있다. | audience -&gt; bag -&gt; invitation + ticket bag은 invitation + ticket을 둘다 담아야하기 때문에, 둘 다 알고 있다. | ticketoffice는 ticket을 알아야지, seller에 줄 수 있기 때문에 관계를 맺고 있다. | . | . | . | 책에 나온 엉망인 부분 체크(빨간색) theater가 enter()를 구현하기 위해서,자기(theater)가 가지고 있는 seller에게 audience를 pass해준다. 그럼 theater는 enter()가 중요메서든데, seller에게 audience에게 pass만 한다. 그렇다면, theater는 audience를 건네주기 위해서 seller를 알아야(가지고있어야)한다는 건가? | 극장이 seller를 알아도 되나? tickeroffice는 몰라도 되고? | . | seller는 tickeroffice를 알고, audience도 알고 있기 때문에, 중간역할을 하는 것처럼 보인다. 책에서는 audience하고 office하고 연결하면 연관성이 생겨 더 힘들어진다고 표현한다. | 왜 그런 문제들이 생길까 -&gt; 책의 설계가 잘못되었기 때문에 잘못된 설계를 보여주는 이유: 절자지향 -&gt; 객체지향으로 옮기는 과정을 보여주기 위한 설계일뿐이기 때문 | . | . | . | . | . diagram . 책을 고친 표 극장이 표 파는 곳을 모를 수 없다. 객체지향에서 의인화 = 실제 역할을 생각함 theater -&gt; ticketoffice | . | 극장 본인이 표를 발급하니까 표를 모를 수 없다. theater -&gt; ticket | . | theater - ticket - ticketoffice만 두고 얘기를 해보면 theater이 발급한 ticket을 ticketoffice에 맡긴다 | . | ticketoffice는 쌓인 ticket들을, 팔도록 ticketseller에게 맡긴다. ticketoffice -&gt; ticketseller | . | 극장이 ticket을 발급하듯, invitation도 만들고, audience에게 제공한다. | 극장이 audience를 알아야하는 진정한 의미는 audience를 입장(enter())시키기 위해서 알아야한다. | audience에게 invitation(초대장)을 넘겨주기 위해서 알아야한다. | . | theater은 자기가 발급하는 ticket / ticket판매를 위한ticketOffice를 알아야하고 ticket 을 —&gt; ticketOffice에게 맡길 것이고 | ticketOffice는 —&gt; ticketSeller를 고용하고 | ticketSeller는 —&gt; ticket을 팔아야하니 알고 있어야한다.(모르는데 팔 수 없음) | audience(고객)은 —&gt; ticket가 존재하는지 / invitation(초대장)이 있는지 확인을 위해 알아야한다.(모르면 매진여부/초대여부를 알 수 없음) | audience(고객)은 —&gt; 실질적으로 ticketSeller에게 표를 사니, 알아야한다. 매진/초대여부를 위해서 ticket, invitation을 알아야하지만, 실질적으로 관계되는 것은 ticketSeller이다. | . | 반대로 ticketSeller는 —&gt; audience(고객)에게 표를 팔아야하니, 서로 알아야한다. 트랜잭션관계로서, 서로 상호관계를 한다. | . | . | . | 표에는 시간이 없다고 가정하고 한다. | . Theater . . 표(ticket)를 발급하는 곳 = 표의 가격(fee)을 알 수 있는 유일한 곳(가격 책정하는 곳) final로 fee를 확정할 수 있다. | getFee()로 fee를 알려줄 수 있다. | 이 극장은, 이 fee로 ticket을 발급할 예정이다. | . | . . theater는 ticketOffices들과 거래한다. 인터파크, yes24 .. 등 티켓판매소는 여러군데다. 온라인/오프라인 포함 여러군데다.. 인자에 다수의 ticketOffices를 수용(극장에 set)한다. | . | . | ticketOffices들이 ticket을 받아오는 방법은? theater가 주는(set) 수 밖에 없다. . . theater가 set(준다) + (특정ticketOffice에게 , 원하는 수량만큼Long num) 주는 수밖에 없다. ticket발급해줄 ticketOffice가, 내가 거래하고 있는 (set된 오피스) 중 1곳인지 확인 한다. | 발급을 해주기 위해, 발급수량을 1개씩 숫자를 깍으면서 발급해준다. ( while (num-- &gt; 0) ) | 발급은 ticketOffice 내부에 addTicket( new Ticket(this));로 객체로 발급하는데, 중요한 것은 ticket이 어느극장 발행인지 this로 넘겨준다.. 원래는 티켓에 new Ticket(this = 발행극장, 상영시간, 영화 편수?, …. ) | 해당 극장만이, 표를 특정지어 발급할 수 있기 때문에, this를 필수로 건네줘서 발급한다. 거래하는 오피스에 num수량만큼, 발급해주는데, 발급극장이 유일한 발급의 주체라서… this로 건네준다? | . | . | | 여기까지 theater가 수많은 ticketOffices들을 거느릴수 있게 되었다. | . | . . theater와 audience사이에도 invitation을 준다(theater.set(고객 고객객체) -&gt; (내부) 고객.set() )의 관계가 있었다. A가 B에게 C를 준다. -&gt; A.setC(B b) { b.set( new C(this) ) } | 극장이 특정 귀빈(고객)에게 초대장을 준 것이다. 고객을 인자로 받은 뒤 | 고객은 (초대장을) 받는 메소드( 자기자신.set( 물건 ) )도 준비되어있어야한다. **준다 = 주는사람.set(줄 사람) , ** | 받는다 = 자기자신에게 set = 자기자신.set( 물건 )으로 해결한다. | . | . | theater가 audience에게 뭔가를 줄려면, audience는 받는 서비스(메소드)를 준비하고 있어야 줄 수 있다. audience가 setInvitation( 새 초대장 )할 수 있는 메소드를 제공했기 때문에 theater가 줄 수 있다. | . | 초대장 invitation도, ticket처럼 theater가 발행한 것 = 객체생성시 this를 넘겨줘서 발행극장을 표기하는 것이 중요하다. 주는 물건을 구분짓는 생성자인자가, 값(시간, 가격)이 아니라 이 극장 = theater = this = 객체 = 식별자가 들어간다는 것이 중요하다 | 값인 theater.name이런 것이 들어가면 안된다! name갔다고 같은 theater인가? (X) | 객체는 식별자로만 구분이 되므로, 식별자가 들어가야한다. | . | . | . | . . 마지막으로 audience을 입장시키는 enter()메소드가 필요하다. . theater는 audience를 enter(입장)시킨다. 입장하는것은 누가봐도 고객 | . | . | 극장이 하는 것은, audience에게 ticket을 받아내는 것이 주임무이다. . 티켓판매 등은 극장이 해야할 일 아니다… 판매는 seller가 하는 것. | . audience에게 .getTicket()으로 자기 표를 받아내고 | 유효한지 확인한다. 표가 유효한지는 극장이 검사할 필요가 있나? 표자체로 유효한지 검사할 수 있다. | 표 자체로 유효한지 판단할 수 있으나, 발행극장확인을 위해서는 theater(this)가 필요하다 enter()시 표한테 유효판단을 맡기는데, 현재 극장(this)이 발행한 표인지 확인하려면, 현재 극장의 식별자가 인자로 필요하다. | . | . | | . Ticket . . theater가 알고 있는 3인방 중 ticket에 대해 알아보자. | ticket은 생성될 때부터, 자신의 발급주체인 theater를 알고 있다. 이 theater에서 발급된 표임을 생성자에서 받아 증명해준다. | 따라서 발급주체는 절대 불변하도록 final로 theater를 잡아둔다. | . | . 요금 . 표를 보고 fee를 알아낼려면? . . fee는 표안의 속성이 아니라 theater가 getFee()한 것을 중개할 뿐이다. | 포인터(getFee())의 포인터(theater.)의 포인터(getFee()) 를 이용한 것이다. 지금은 final불변값 theater지만, | 만약, 배신을 때려서 theater가 변경되어도 -&gt; 포인터의 포인터 -&gt; ticket.getFee()는 정상작동(업데이트 자동으로 됨)될 것이다. 만약, Ticket의 필드로 fee를 잡아 fee = theater.getFee()로 값을 잡아놨다면 -&gt; theater의 fee를 바꾸면 ticket.fee에는 반영이 안될 것이다. | 값의 변화가 반영되려면, 참조의 참조로 얻어와야한다! 그래야 참조의참조 업데이트가 runtime에 반영(이후에도 반영) | . | . | 포인터의 포인터를 비용으로 치루더라도 -&gt; 변화가 바로 반영되도록 하는 원리를 가지게 한다. | . | . validation . . ticket의 꽃은 fee가 아닌 validation이라고 한다. valid한 상태를 판단할 때, 값이 아닌 식별자로 3가지 잘못된 경우를 판단하는 것을 확인할 수 있다. | . | 일단 ticket.isValid(theater)로 사용되어 theater를 받아와서 validation한다. 먼저, isEntered라는 숨겨진 속성이 있다. -&gt; 자기 상태를 자기가 관리하는 maintain of status 속성 첫 값은 false;로서 아직 사용안됬음을 알려준다. | flag속성으로서 내부 토글되지만, 바깥은 아예 모른다. = 자기가 관리한다 | 표가 이미 사용되었으면 -&gt; if절에 true가 되어 out | . | 받아온 theater가 &lt;-&gt; 내가 알고 있는(ticket생성시 필요한 theater)랑 달라도 out | 자기자신(ticket)이 this == EMPTY인 경우 꽝 첫 줄에 정의된 EMPTY를 보자. (이펙티브 자바 책에서 나오는 null 대체 패턴) null를 사용할거면, null을 대체하는 객체나 값을 대체로 사용하는 것 | **ticket이 잘못되거나 null쓸 것을 대신해서 Ticket형 EMPTY를 대신 만들어놨다. 특히, final로 ** ticket이 null이거나 잘못되었다 -&gt; EMPTY로 대체해서 쓴다. | . | . | . | | invalid3가지에 안걸린다면? 미리 이건 쓴 표야 도장을 찍어놓고 고객이 제시하는 순간, 그 표는 어떠한 경우든 사용됨 isEntered = true가 꽝! 찍히고 | true 든 false든 1개가 return된다. | . | true를 return시킨다. | | . Invitation . . ticket과 마찬가지로, 발급주체인 theater를 생성자에서 받은 뒤, final로 확정해서 받아놓는다. | 있다/없다의 판단시 null대신 Invitation형 EMTPY를 final로 만들어준다. 이펙티브 자바.. | . | . TicketOffice . my) 받기만 하는 쪽에서는, 주는쪽의 객체를 사용못하는 제약 + 주는쪽에서 [받는 서비스(메소드)]를 제공해줘야 -&gt; 주는 쪽(theater, TicketSeller)이 무엇을 줄 수 있다. theater에게는, theater가 표를 줄 수 있게 -&gt; 표를 받는 메소드 addTicket | ticketSeller에게는 표를 꺼내갈 수 있게 -&gt; 표를 꺼내주는 메소드 getTicketWithFee/NoFee를 제공한다. | . | . . 의외로 theater만 -&gt; office를 알고, office는 theater를 모르게 되어있다. TicketOffice는 theater에 관심 없다.(뭔가를 안준다?) theater가 TicketOffice에게 뭐를 줄려고 한다( 안다, 관심있다) | (theater가 주는 것에 대해) TicketOffice는 받아주는 메소드(서비스)를 노출해줄 때만, theater가 이용할 수 있다. | 화살표 방향과는 반대로, 받는 쪽이 [받는 메소드=서비스를 제공] 해주지 않으면 사용불가하여, 더 거만한 것은 TicketOffice쪽이다. 화살표 나가는 쪽이 많이 알고는 있지만, 받는 쪽이 오픈/제공해줘야 사용가능 | 화살표 나간다 = 알고 있다 = (제공되는 서비스가 있어야) 이용한다. | 화살표 받는다 = 서비스를 제공해줘야 주는 쪽에서 이용가능하다. | . | . | . | addTicket()은 특정 theater가 -&gt; ticketOffice에게 표 넣어줄 때 사용하는 메소드 . 화살표를 받는 쪽에서, 주는 쪽(발급주체)인 theater에게 제공하는 메소드 . | 이것이 있어야 theater가 ticket을박아줄 수 있다. . . | . | 그외 변수에는 티켓오피스 생성자(자산amount를 가지고 시작함), 티켓오피스의 재산인 (amount), 받은 총 티켓 리스트(tickets) 이 있다. . | ticket의 fee는, 직접 받아 가지고 있는게 아니라, 포인터의 포인터의 포인터로.. theater까지 가서 받아와야한다고 했다. . . ticketOffice는 theater를 기본적으로 모른다. 정보의 은닉 = 상호참조가 아니라 단방향 의존성을 가지게 했다. | theater를 모른다 = theater.getFee()를 못쓴다(my) theater객체를 못쓴다) 그럼 어떻게 theater에 있는 표의가격을 알수 있을까? 자기가 가진 ticket에서 조회를 한다. | . | . | . | . 티켓오피스에 표가 없다? -&gt; 표의 가격을 모른다 -&gt; 0원으로 반환 | 안다? -&gt; (한 극장내에서 받았다 가정하면) 1번째 표에서 getFee()를 때린다. my) 받기만 하는 TicketOffice(theater를 모름)에서는, 주기만 하는 theater의 객체를 사용못하므로 그 내부의 getFee()를 이용못하는데, 받은 물건(tickets)을 이용해 fee를 조회한다. | . | | 이번엔 theater가 아닌 TicketSeller에게도 2가지 서비스를 제공하는데 . TicketOffice에서 표를 1장 뺀 뒤 -&gt; TicketSeller에게 줘야한다 . | 빼가지고 줄 때 2가지 방법을 준다. . 초대권으로 무료로 준다. . | 돈 받아서 준다. . | | . | . . 어느 경우든, 빼내서 줄 티켓이 없으면 null대신 Ticket.EMPTY를 준다. . | 티켓을 돈주고 팔때는 List에서 .remove(0)으로 list에서 제거하면서 &amp; 반환된 Ticket을 받은 뒤 그 ticket.getFee()로 티켓가격을 재산amount에 보탠다 판 표는 remove(0)로 제거가 아닌 받아오는 빼내기 전략를 이용한다. remove되면서 반환되는 ticket 데이터를 이용하여, 참조의 참조로 표 가격을 구한다. | return ticket을 통해 표를 건네준다. | . | 판 표에 대한 돈은 재산amount+= 를 한다. | . | 티켓을 초대장으로 그냥 줄 때는 ticketOffice는 invitation의 존재를 모르는 상황이다. 존재를 모르더라도, 그냥 공짜로 표를 주는 것 정도로 처리한다. .remove(0)로 받아오는 것은 같으나 ticket.getFee() -&gt; amount += 의 과정이 없다. | . | . | 초대장을 몰라도 되는 이유는? 초대장 이외에 VVIP 등에게도 무료로 표를 줄 수 있기 때문에, 무료로 표를 갈취해가는 경우는 많다. -&gt; 모든 경우를 처리하려면, invitation을 모르는게 정상 | . | . | **ticketOffice가 표를 돈주고 팔지 / 무료로 줄지를 결정하는 것이 ticketSeller다 ** Seller의 역량에 따라서, Office에서 무료로 빼줄지 / 돈주고 팔지를 결정한다. | . | . TicketSeller . . 악의축 TicketSeller는 ticketOffice의 소속이라, TicketSeller생성자==발행주체에 소속기관(TicketOffice)을 set메소드로 박아둔다. ticket의 발행 주체인 theater를 -&gt; 발행담당 생성자에서 받아, final로 박아두는 것과는 달리 태어나서 ~ 죽을때까지 절대 못바꾸는 나의 소속기관(발행주체)이다? = 생성자에서 받는다. | . | 프리랜서로서생각하여, 발행주체=생성기관이 아니라 중간에 소속을 바꿀 수 있는 소속기관으로서 set메소드로 박아준다 프리랜서의 소속기관으로서, 바뀔 수 있는 소속기관이다? == set메소드로 필요시마다 변경하며 박는다. | 표를 파는 직원이 종신으로 일할 리 없다. -&gt; setter로 소속을 박는다. | . | . | 소속을 setter인지 생성자에서 받을 것인지는 신중하게 생각해야한다. 태어나서 불변하는 발행주체, 소속기관 -&gt; 생성자에서 태어날때부터 받기 | 중간에 계속해서 바뀔 수 있는 프리랜서의 소속기관 -&gt; setter로 받기 | . | . . 중요한 역할은 getTicket이라는 거래이다. 이 때 트랜잭션이 성립하기 때문이다. seller의 getTicket은 audience와 거래를 한다는 얘기다 | 누가 갑일까? 거래는 을인 audience가 표를 원할 때 이루어진다. 갑은 seller다. 표를 줄 수도 / 안줄 수 도 있다. 을의 매표소직원의 느낌이 아니라 출입국 심사원의 느낌으로 고객에게 여러가지 검사를 요구한다. | 을인 audience 표달라고 빈다. | . | . | 거래에 있어서, 판매원은 갑의 위치에 있다는 말이 무슨 말일까 판매원은, 일단 기본적으로 표를 안줄 생각(Ticket.EMPTY)을 하고 있다(갑으로서 검사과정에서 여러가지 이유에서 안 줄 가능성이 있음을 시사) | 첫번째 고객자격검사로, 고객이 돈은 둘째 치고초대권 가지고 있는지( != EMPTY 로 ) 검사한다. 초대권 있으면, 소속인 TicketOffice에서 무료로 표를 얻어온다. | TicketOffice에서 표를 받아왔는데, EMTPY 표일 수 도 있다! 빈 표가 아닐때, return ticket될 예정이니, audience의 초대장을 (뺏어서)파기(audience.removeInvitation())한다.(고객의 권한을 침범하는 것 아닐까? 아니다. 을이라서 시키는대로 한다.) 트랜잭션은 누가 주체인지 정확하게 알아서 주도해야한다. | 초대장 파기의 순간은, 정상적으로 표를 받아왔을 때인데, seller만이 알고 있다. 그 타이밍에 파기 명령을 갑으로서 내린다. 고객이 getInvitation()으로 보여주기만 하고, 파기를 안할 수 도 있으니, 파기명령도 거래에서의 갑인 seller가 하게 한다. | . | . | seller에게 ticket만 return받고, 초대장을 파기안했을지 seller는 모른다 -&gt; 갑의 권한으로 을의 초대장을 파기한다. | . | TicketOffice에서 일단 get한 ticket은 EMPTY or 정상 ticket이 될 것이며, ticket이 EMPTY가 아니라면 -&gt; 곧 return ticket으로 표를 건네줄 것이기 때문에 -&gt; 상대방의 돈을 가져오거나 or 초대장을 파기해야한다 | empty라면, 상대 돈뺏or초대장파기없이, 그대로 return ticket(EMPTY)를 하면 된다. | . | . | 두번째 고객자격검사로, 고객이 애초에 표를 살만한 돈을 가지고 있는지 검사를 한다. 트랜잭션이 성립하려면, 누가 무슨책임을 가지고 있는지 봐야한다?! | 고객은 getAmount로 내장(amount 값)을 까는 정도는 아니지만, hasAmount( 표가격 )으로 최소 노출로서 고객자격 증명을 한다. 살만한 돈을 가지고 있으면, 트랜잭션으로 표가격만큼 돈을 갈취해해야한다. | 고객의 돈 갈취는 실제 표 == EMPTY 표가 아닌 것을 확정되었을 때 갈취 한다. | . | 돈을 주고 ticketOffice에서 표를 받아온 뒤, 그 표가 EMPTY가 아닌게 확정 되었을 때 진짜 표를 받아온 것 -&gt; 고객의 돈을 갈취한다. TicketOffice에서 getTicketWithFee()를 하면 EMPTY 표 일 수 도 있다. 이것은 티켓의 갯수가 0개인 경우였다. -&gt; 티켓 없는 상황이다. | EMPTY가 아닌 표를 받아왔다면 ticket을 1개 빼온다( remove(0) -&gt; 받아오기) | 그만큼 office는 amount+= 돈을 이미 받은 상태 | . | seller는 audience에게 amount-= 로 돈을 갈취해야만 한다. audience(고객)이 표만 먹고 나를 수 있으므로, seller가 갈취해야한다. | 을인 audience가 갑인 seller님이 .removeInvitation()이나 .minusAmount()해서 갈취를 할 수 있게끔 서비스를 제공해줘야 거래가 일어난다. 현실세계와 다르다. 트랜잭션이 성립하려면, 갑인 seller는 audience에게 초대장(상품권) or 돈있는지 확인후 | office에 - 물건을 받아온 뒤, + amount돈을 늘려놓고 | return 물건이 EMPTY아니여서 물건 있음 확정되면, -amount돈 갈취 or -초대장 갈취를 주도적으로 한다. | . | . | . | . | . | . | | seller의 주업무는 getTicket에 대한 비니지스 로직을 가지고 있게 된다. 갑으로서 audience에 대해 검사를 하면서 판매(트랜잭션) 한다. 초대장 있는지 확인한다. 있으면 NoFee로 Office에서 티켓을 떼온다. 티켓이 있으면 (티켓을 주는 코드는 공통이라 맨 나중에) 초대장을 갈취(파기)한다 | . | . | (초대장 없으면) 돈이 있는지 확인한다. 있으면 Fee로 Office에서 티켓을 떼온다. 티켓이 있으면 (티켓을 주는 코드는 공통이라 맨 나중에) 돈을 갈취한다. | . | . | . | **TicketSeller는 아래와 같이 &amp; 계속 바뀌거나 추가될 가능성이 있는 &lt;invitation정책&gt; + &lt;요금정책&gt;의 도메인 지식(로직)을 가지고 있어서, 대부분 고정된 로직인 ticketOffice와 다르기 때문에 클래스가 분리되었다. ** ticketOffice에 대해 Fee/NoFee경우 나누기 | audience에 대해 검사 + 물건 확정시 - 초대장파기/돈 갈취 | | 새로운 invitation정책이 생기거나 새로운 요금정책 -&gt; ticketOffice는 안건들이고 ticketSeller만 건들이면 된다. 격리가 된 파일이 된다. | . | 티켓판매 정책은 많이 바뀐다. + 많은 것들이 관여한다. + audience도 다양한 자식클래스로 파생 될 수 있다. 파생되는 고객종류들이 생길때마다 -&gt; 분리해놓은 ticketSeller만 수정한다. ticketOffice가 변하고 망가지는 일들이 예방된다. | 변하는 등급별 audience 파생 / 요금정책 등을 분리해놓은 ticketSeller가 다 받아서 해결한다. 그래야 그 밑에 TicketOffice - theater등을 방어할 수 있기 때문에 | . | 밑으로의 수정 여파를 발생시키지 않기 위해서, TicketSeller라는 객체가 나왔다. | . | 변동 가능성 높은, audience등급 마다 할인정책 / 분기별 바뀌는 요금 정책 / 시즌마다 제휴마다 이벤트마다 발생하는 변동 변하는 것과 관계없는 부분만 따로 모아서 -&gt; TicketOffice | 변하는 부분만 따로 모아서 격리 -&gt; TicketSeller | . | . Audience . . audience(고객)은 동네북이다. | 고객이 가질 수 있는 ticket과 invitation을 EMPTY로 가지도록 default한다. | 태어날때부터, 금수저/흙수저인지 amount를 생성자로 받아 태어난다. | buyTicket으로 사려면? audience는 을이다. -&gt; ticketSeller를 찾아가는 수밖에 없다 . seller를 찾아간다. = seller를 인자로 받아와서 티켓을 구매한다. | 셀러에게 &quot;티켓좀 (Office에서 떼와서) 주세요. 저한테this&quot;의 메소드를 날린다. (seller는 티켓떼오면서 여러가지 을을 검사해서 줬었다) ticket = seller.getTicket(this) | . | 티켓은 EMPTY이거나 있는 표가 올테니, default EMPTY였던 티켓 갱신하고, 극장에서 검사받는다. | . | hasAmount(seller의 충분한 돈 있는지 검사용)과 minusAmount(seller의 진짜 표를 떼온 뒤, 돈 갈취)는 seller에 협박에 의해 최소 노출(getAmount가 최고노출)된 것이다. 안해주면, 갑인 seller는 거래안해준다. . . | getInvitation(seller의 초대장 있는지 검사용)과 removeInvitation(seller의 진짜 표를 떼온 뒤, 초대장 강제파기) 역시 seller가 요구하는것이다. hasAmount, minusAmount, getInvitation, removeInvitation 4가지는 모두 seller가 트랜잭션(거래)를 위해 요구하는 스펙(조건)들이다. | 위 4가지는 인터페이스로도 뺄 수 있다.? 그렇게 되면, audience를 더이상 audience class가 아닌 트랜잭션 컨디션이라는 인터페이스로 인식할 수 있다. | seller가 사실 원하는 것은 audience가 아니다. 4가지 조건들을 원한다. 이것들만 만족하면 티켓을 줄 수 있다고 seller는 생각한다. 책에서 나오는 인터페이스 빼기 = 책임을 분리하는 방법이다. 어렵다… | . | . | . | getTicket()는 극장이 검사할 때 요구하는 것이다. . . 표 있으면 줘봐. | . | setInvitation은 theater에서 특정 audience들에게 표를 무료로 제공하는 초대장을 꽂아 주는 행위 . theater만 audience를 일방적으로 알고 있다. audience는 받아주는 서비스를 제공해야, theater가 초대장을 줄 수 있다. | . | . | 다 다른클래스 접대 메서드이고, 스스로 행사할 수 있는 메소드는 buyTicket()밖에 없다. 바깥에 노출되는 public은 buyTicket()밖에 없다 | 나머지 4가지 -&gt; seller와 internal로 내부패키지(seller)끼리 필요한 것에게 | 나머지 2가지 -&gt; theater에게 internal로 필요한 것 | . | . Main . . Theater를 만드는데 표값을 100원(100L)로 정한 극장이다. theater가 태어날때부터 안바뀌는 것은 표가격(fee)를 생성자로 받았다. | . | Audience 2명을 만드는데, 흙수저(0L)과 은수저(50L) 로 만들었다. | TicketOffice는 재산, 자본(amount)를 생성자로 받아서 만들어진다 theater를 모르는 놈이다. 자본은 0원으로 만들었다. | . | TicketSeller는 자유의지를 갖는 = 프리랜서로서, 소속기관을 set으로 박아주고 생성자로는 아무것도 안받는다. 그냥 태어난다 | . | . Theater가 자기와 거래할 TicketOffice와 계약( by setTicketOffices() )을 맺는다. 계약 맺은 직후, TicketOffice에게, ticket을 10장 지급한다. | (추가) 흙수저에게, 무료 표인 invitation을 1장 박아줬다. | . | . . 프리랜서인 seller는 해당 TicketOffice와 계약을 했다. 변동 가능성 소속기관을, set으로 박아 계약한다. | . | . . 고객1과 고객2가, seller에게 표를 사러 갔다. 그냥 사는 것 같아보여도, 갑 &amp; 특정 seller에게 (인자로 받아서) 표를 사러간다. 내부에서는 갑이 메소드를 실행해서 거래한다. | . | . | . . 고객들은 theater에 입장했을 때 -&gt; 티켓을 꺼내 -&gt; 그 티켓이 isValid한지 검사하는데 고객1 -&gt; invitation이 있으므로 -&gt; 표로 바꿔서 -&gt; 들어가는 데 성공했을 것이다. | 고객2 -&gt; 돈 없으므로 -&gt; 들어가는데 실패했을 것이다. | . | . 교훈 . 절대로 우리의 수준으로 class들 -&gt; main순으로 이렇게 짤 수 없다. main코드를 먼저 짜고 -&gt; 거기에 맞는 class를 만들 수 밖에 없다. | . | 책에서는 다양한 책임을 먼저 구하고 -&gt; 역할들을 찾아보라곤 하지만 실제로는 그렇게 짤 순 없다. | . | 내 도메인에 맞는 시나리오(Main)부터 짜고 거기에 맞는 Class를 짜면 된다. 객체들의 협력상황을 보고 -&gt; class를 만들어야한다. class짜는 것도 팀마다 있는 퀜트백(조영호)같은 사람이 짜면 된다. | . | . | 테스트코드부터 설계에 반영하려면, 테스트코드가 실제 설계에 사용되는 client코드와 닮아있어야하는데 클래스를 완성되었다고 가정하고, 클래스를 객체로 어떻게 사용할 건지 먼저 짜보는게 훨씬 낫다 상상속으로 class를 짜봤자, 어떻게 사용되는지는 모른다. | . | . | .",
            "url": "blog.chojaeseong.com/object/2022/05/04/(object1-3)theater_%EA%B0%9D%EC%B2%B4%EC%84%A4%EA%B3%84.html",
            "relUrl": "/object/2022/05/04/(object1-3)theater_%EA%B0%9D%EC%B2%B4%EC%84%A4%EA%B3%84.html",
            "date": " • May 4, 2022"
        }
        
    
  
    
        ,"post76": {
            "title": "OBJECT 02 식별자와 다형성(코드스핏츠)",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . ch2. 객체지향이라면 . value &lt; identifier: 객체는 값이 아닌 식별자(메모리주소)로 식별 . 값과 식별자 . 객체지향에서의 객체 구분은 식별자(runtime 적재되어있는 메모리주소) 한다. . | 값이 같다고 똑같은 객체X 메모리주소가 같다 = 같은 식별자 = 같은 객체다 . | 값을 사용하는 context는 값만 같으면 같은 것이다. . | 값이 같더라도 메모리로 같고 다름을 평가한다? 객체로 평가한 것이다. . | java에서 문자열 비교시 .equals()를 사용하는 이유 . java에서는 그냥 비교하면 식별자를 비교해버린다. | 문자열을 값으로서 비교를 원하면 equals를 써야한다. | . | 현대언어에서는 이 모순(그냥 비교 == 식별자 비교 like java)를 해결해서 . 값 context를 쓰는 애들은, 그냥 비교 = 값 비교가 default가 연산자가 작동하게 된다. | javascript에서는 string을 객체로 안보고 값으로 본다. 할당하거나 인자를 보내면 무조건 복제본이 된다.(주소전달X) | 비교시에도 안에 내용물만 비교 | . | java에서는 string을 값으로 보기엔, 사람들이 너무 멍청하니까, 기본적으로 객체(식별자)로 기본 비교하게 해놨다. -&gt; equals()를 써야 값으로만 비교한다. 비교시, 메모리의 주소인 식별자로 평가된다. | . | . | name이라는 field를 이용해서, equals 메소드를 field 값이 == 같은지의 결과로 판단하도록 메소드를 짠다. . (필드)값으로써 비교하는 메소드가 된다. . | 값으로 쓰려고 마음 먹은 메소드. 더이상 객체가 아니라고 생각한다 . | cf) 코틀린에서 == : 값으로 평가 equals()를 호출 / === : 식별자로 평가 . . 값으로 평가하는 메소드 ValueType()는 true가 나오고 | 식별자비교시에는 false가 나온다. | . | . | 내가 이 객체를 값으로 볼지 vs 객체로 볼지 를 먼저 정해야한다. . 객체로 본다면 -&gt; 무슨 값을 가지든 식별자로서 확인이 된다 | 값으로 본다면 -&gt; 안에 있는 값만 확인한다. | . | . | 객체지향에서는 객체를 지향하므로 모든 평가를 식별자(identifier)로 평가한다? . Okay. 미리 정해진 답이 아니라면 객체로 쓰자. . 우리는 식별자로 시스템을 만들어가야한다 . | setter로 협력자 객체를 받아왔다? . 값으로 확인? (X) 식별자context를 통해서 식별한다. | . . | . | 특정값을 정해서 미리 가지고 있는 유형이 아니라면 . 객체지향이라고 해서 숫자, 문자 안쓰는 것은 아님. | 값 지향 -&gt; 함수형 시스템에서는 참조를 지향하지 않는다 불변성과 순수함수를 위해서 | 똑같이 나오려면 값 지향을 해야한다. | . | . | . | . Polymorphism: 이게 지원되야 진짜 객체지향 . 객체지향이라 부를려면, 폴리모피즘(다형성)이 시스템에서 지원되어야 객체지향이라 부를 수 있다. 이게 안되면 객체지향 방식으로 짜는 것일 뿐이다. | . | 다형성은 구체적인 2가지 요소가 충족되어야한다. Substitution(대체가능성): | Internal identity(내적동질성): | . | . 대체가능성: 포인터1(위쪽 여러 형들, 껍데기)의 포인터2(변형가능성있는 메소드 or 변수) . 예를 들어 클래스 Worker가 Runnable(인터페이스)를 implements해서 run()을 구현하고 있다. | 이 때, 클래스Worker()객체는 Worker형이 아니라, Runnable형(인터페이스를 형)으로 지정해서 객체를 집어넣는다. worker는 클래스Worker타입인데, 어떻게 인터페이스Runnable타입으로 들어갔을까 클래스Worker가 인페Runnable을 구상한 것이기 때문에 가능해진다. | 자기형은 아닌데 자기형을 포괄하는 형에는 소속될 수 있다.(상속아니므로 실제 포괄X) 클래스Wokrer는 자기형=Worker형뿐만 아니라 Runnable형을 가지고 있다. 둘 중에 하나를 선택해서 객체를 집어넣을 수 있다. | . | . | . | **포괄하는형에 넣은 순간부터는 worker는 Worker로서는 기능하지 못하고 Runnable로써 밖에 기능을 못한다 ** 왜냐면, Pointer of Pointer개념으로서, 껍데기인 Runnable의 포인터를 통해서 worker의 포인터를 다루게 되므로 | Runnable의 포인터를 통해서 worker를 다루게 되므로 Runnable안에 있는 집합만 사용가능 | Worker객체지만, Worker의 run()만 사용가능해짐 | Runnable - run() —매핑—&gt; 실제구현된 worker 속 run() 메소드 | 사용자는 Runnable 밖에 못다룬다. -&gt; run() 밖에 못다룬다. | run()을 찾아들어간다면? 직접 run()? ㄴㄴ 관계에 의해 Runnable을 통해 -&gt; run() -&gt; 매핑 -&gt; 실제구현된 worker의 run() 메소드까지 포인터의 포인터로 찾아들어간다. | . | . | 다형성을 쓰면, 직접 run()을 호출하는 것보다 느려질 수 밖에 없게 된다. 포인터의 포인터를 찾아가서. 그냥 바로 쓰는게 아니다. | 다형성은 꽁짜가 아니라 비용이 크다. | . | . | . | 자세히 보자면 인터페이스 상속한 클래스가 객체를 생성하는 순간, 쉽게 생각하려면, 객체 생성자 호출시 -&gt; 메모리 속에 2개의 변수가 동시에 생성된다고 생각하자. Runnable 객체 | Worker 객체 | 2개 중에 배정하는 형에 포인터를 배정한다. Runnable | . | . | Runnable 객체인 worker.run()을 때리면 run()을 찾기 위해서 Runnable(껍데기 포인터)부터 찾아들어간 다음 | run(내부 포인터)를 찾아들어간 다음 | 실제 구현부 Worker - run()을 찾아들어간다. | . | . | 대체가능성(포인터의 포인터)을 실현하는 방법은 간단하다 자바스크립트: 프로토타입 체인 생성 -&gt; 포인터의 포인터… | 책에서는 동적 바인딩이라 부르는데, runtime에서 포인터의 연쇄를 계산하기 때문이다. | . | 이번에는 인터페이스 -&gt; 구현이 아니라, class -&gt; 상속받은 클래스를 예를 들어보자. HardWorker()의 생성자를 호출하는 순간, 3개형의 변수가 메모리에 생성된다 Runnable | Worker | HardWorker 3개 중에 배정하는 형에 포인터를 배정한다. | . | Runnable형인 worker = 변수에다가 할당해주는 순간 Runnable에 포인터를 배정하게 된다. | . | . | . | 대체가능성의 실체 내가 객체를 만들 때, 다수의 형(상속, 구현 등 위쪽 껍데기-포인터1 후보들)을 선택할 수 있는 가능성이며 | 하나의 형을 선택하면, 그 형에 해당되는 포인터를 노출함으로써 동적 바인딩으로 진짜 구현되어있는 곳으로 인도하는 행위 | . | . 내적 동질성: 메소드참조는 다른 형인 상태라도 출신class메소드를 참조 . . Worker클래스안에 print()라는 메소드를 신설했다. . 보면, 내부에서는 run()을 호출하면서 프린트한다. | . | HardWorker객체를 Runnable형이 아니라 Worker형으로 만들었다. . HardWorker()를 만드는 순간, Runnable형 | Worker형 | HardWork형의 변수가 3개가 생성되며 | . | Worker형에 넣은 순간, 포인터가 Worker를 가리킨다고 했다. | . | 그렇다면, worker.print() 때린다면 . 포인터가 가리키는 —&gt; Worker —&gt; 그내부 print()호출시, println( run() )에서의 run()은 this.run()일 텐데 Worker내부의 run()일까? 아니면 HardWorker내부의 run()일까? 나는 지금 Worker의 context로 들어와서 호출한 상태임. | context상 바로 위에 있는 Worker의 run()일까? 아니면 생성자 Hardworker()의 객체의 run()일까? | . | . | . | OOP 객체지향 프로그래밍에서 약속한 내적 동질성에 의해 . 최초 생성한 객체(HardWorker)에 함수포인터는 여기로 유지하겠다. | 비록 형은 달라지더라도, 변형된 형(class)속 함수가 아니라 내적으로 동질성은 유지하기 위해 생성자를 호출한 출신지class의 함수를 참조한다. Worker형으로 포장되더라도 run() 메소드는, Worker의 run()이 아니라 원래 객체의 class인 HardWorker의 run()을 참조한다. | 메소드 참조에서는 출신지가 더 중요하다. | . | . | . object . 객체지향에서 객체가 갖춰야할 2가지 기능의 캡슐화(Encapsulation of Functionality) ATM기: 외부에 상세기능을 다 노출하지 않고, 보다 잘 쓸 수 있게 노출한다. | 이것을 하는 이유는 궁극적인 목표는, 변화에 따라서 프로그램 수정/추가 등을 격리시키기 위함이다. 캡슐화하여 일부만 외부노출 -&gt; 다양한 나머지들은 내부에 갖힘 = 격리 -&gt; 외부에 영향 줄어듬 | . | . | 상태 관리(Maintenance of State) 관리 중 대표적인 것이 은닉화 | 자율적인 데이터 갱신 | 변화시 외부 노티피케이션 | B가 배신때릴 때, C와 D가 망가진 것은 상태관리에 실패한 것 | 객체지향이 레퍼런스를 가리키고, 식별자로 참작, 식별자로만 구분 등 하는 이유는 포인터의 포인터를 쓰기 위함이다. 더 근본적으로는 상태관리를 위해서 | . | | 격리되었는지 안되어있는지 확인 -&gt; 해당안건의 특정 파일만 수정했는데 성공 | .",
            "url": "blog.chojaeseong.com/object/2022/05/03/(object1-2)%EC%8B%9D%EB%B3%84%EC%9E%90%EC%99%80_%EB%8B%A4%ED%98%95%EC%84%B1.html",
            "relUrl": "/object/2022/05/03/(object1-2)%EC%8B%9D%EB%B3%84%EC%9E%90%EC%99%80_%EB%8B%A4%ED%98%95%EC%84%B1.html",
            "date": " • May 3, 2022"
        }
        
    
  
    
        ,"post77": {
            "title": "OBJECT 01 읽기전 필요소양(코드스핏츠)",
            "content": "참고 유튜브 : https://www.youtube.com/watch?v=sWyZUzQW3IM&amp;list=PLBNdLLaRx_rI-UsVIGeWX_iv-e8cxpLxS&amp;index=1 | 정리본: https://github.com/LenKIM/object-book | 코드: https://github.com/eternity-oop/object | 책(목차) : https://wikibook.co.kr/object/ | . ch1. 책 읽기 전 기본 소양 . 코딩을 하는 이유(motivate) : 돈 왜 이렇게 짰어? :돈이 덜 드니까 | | 왜 그렇게 생각? -&gt; 생각의 기저에 있는 philosophy(철학)을 살펴봐야함 근대부터의 과학철학 : 토마스쿤 - 과학혁명 -&gt; 과학사 철학구조에 큰 영향을 끼침 -&gt; 어떻게 서구문명과 프로그래밍에 영향을 끼칠까 | | 철학구조를 이해한다고 해서 -&gt; 우리가 실질적으로 머리속에서 무엇을 하는데에, 직접적인 영향을 끼치진 않는다. 철학은 base일 뿐이고, 그 윗단계의 frame이 필요함 . 켄트 백의 구현 패턴이라는 책을 보면, 생각하는 코드의 틀로서 3가지를 제시함 . 가치(value) | 원칙(principle) | 패턴(pattern) : 가치와 원칙을 base로 해서 반복되는 유형이 나오는 것일 뿐이므로 1,2가 더 윗단계 | . 캔트백은 죽은 사람도 아니고 지금도, 알고리즘 시험쳐서 페이스북에 입사해서 일하고 있다고 함.. 짤없다.. 알고리즘 공부는 계속해야한다. | . | . | 켄트 백 3가지와 다르게, 패턴을 빼고 이 책에서는 Xoriented라는 사고유형의 틀(패러다임과 유사, 객체지향적 or 함수형)을 제시한다. . 이 3가지 틀을 바탕으로 프로그램 왜 이렇게 짰니?라고 설명을 시도해보려고 | . . 토마스 쿤(과학혁명의 구조): 철학사적 관점. 과학은 상대적. 그 동네의 믿음일 뿐 진리는 아무도 모름. 현재 우리가 추구하는 과학은 종교와 다르지 않다. 분자가 최소단위라고 생각했다가 원자가 발견된 이후로는 패러다임이 바뀜. 상대주의 기본적 기틀 | 러커토시 임레(합리주의): 과학은 여론조사같은 것이 아니야. 합리성이 있어. | 파울 파이어아벤트: 난장판 | . | 상대주의와 합리주의는 공존한다. . 클래스 -&gt; 상대적으로 부모의 자식클래스일 수도 있고, 자식클래스의 부모일 수 도 있다. ~보다 크다 작다 (상대주의 적용) | bmi기준으로는 무조건 뚱뚱해. 평균, 중앙값 등 적용(합리주의 적용) | 상대성을 갖기 위해서는 어떤 기준 = 어떤 합리성이 적용되었는지 계속 생각해야한다. | . | . | . value: 개발자세계에서 추구해야할 가치(돈)는 3가지 . 캔트백의 가치(value) : 사람들이 보편적으로 환산할 수 있는 돈이 있는 것처럼 . 개발자 세계에서는 코드를 이렇게 짠 이유는? 환산할 수 있는 가치인 communication, simplicity, flexibility 커뮤니케이션 안되면 비용이 발생한다. | 간단하게 짤 수록 비용이 발생한다. | 유연(여기저기 사용가능)하게 짤 수록 비용이 적게 발생한다. 사실 유연하다 = 여기저기 사용가능하다 = 간단한 코드만 가능하다. | ex&gt; 실제 짠 메소드 vs Math.sin() : 간단한 Math.sin()이 훨씬 많이 재활용된다. | . | 유연성(flexibility)을 얻으려면 간단(simplicity)하게 짜야하고, 유연하고 간단하게 짰다면 커뮤니케이션(communication)도 잘될 것이다. | . | . . | . principle: 다같이지킴으로써 -&gt; 예외상황을 즉각 캐치할 수 있어 최소비용으로 처리 . 예를 들어, 문제 있는 사람만 일어나주세요 -&gt; 일어난 사람만 바로 캐취해서 즉각처리 가능 맘대로 일어나거나 앉거나 -&gt; 문제 있는 사람을 바로 캐취 X -&gt; 비용 많이 듦. | . | 원칙은 value(가치)와 다르게 가치를 발생시킴. 팀, 회사, 국가 등 각 카테고리, 각 그룹이 요구하는 원칙들을 지켜야하므로, 레이어형태로 발생한다. | . | 캔트백이 제시하는 원칙 4가지는??? Local consequences: 변수 Localize해서 생명주기를 짧게 가져가는 원칙(머리가 나쁘다. 언제 생성되고 죽는지 다 기억못한다. 짧게 가져가라) | Minimize repetition: 중복을 최소화해라(중복은 제거하는게 아니라 발견하는 것) (수준이 올라가면 반복이 새롭게 보이게 된다.) | Symmetry: 짝을 맞춰라. getter 만들면 -&gt; setter만들기. 되도록이면 짝을 맞춰서 만들어내라 | Convention: 컨벤션을 지켜라. 원칙 4개를 지키게 되면 많으 비용을 아낄 수 있게 된다. | 안지키면 버그로 확정짓자. | . | | . Xoriented . OOP(객체지향 프로그래밍론)을 깔게 되면, SOLID원칙이나 DRY 등 다양한 기법들을 다루게 된다. 반응형, 함수형 등…은 불변성을 강조한다 cf) 객체지향은 불변성을 강조하지 않음. | . | . . pattern: 3개 원칙을 쓰다보면 반복되서 나타는 유형이 있다 -&gt; 베스트를 만들어놓고 -&gt; 비용없이 즉각 적용시키자. . . 미국에서는 매년 생산성을 측정하는데, 코드작성은 20%, 디버깅 50% . IT는 100% 인건비 사업이다. | 사람의 시간 = 돈 | IT환경에서 돈을 적게 쓴다 = 시간을 적게 쓴다 같은 말. . 디버깅, 기능 추가 등의 시간을 50%이상 투자한다. . | 받아온PM팀 욕하면서, 밤세게 됨 -&gt; 사실은.. 본인의 코드가 유연(간단)하지도 X , 견고하지도 X, 격리되지 X . | . | 요즘은 애자일시대 -&gt; 코드가 유연하게 받아질 수 있도록 설계를 탄탄하게 -&gt; 코드의 품질을 높여야 살길이다. . 보여질 때마다 요구사항이 달라짐. | . | 어떻게? 변화에 따른 로직 격리에 성공해야함. | . | . 역할 모델 . 객체지향 프로그래밍론에서 변화에 따른 격리에 성공하는 방법은 1가지 방법만 제시한다. 역할 모델만 제시한다. 역할 모델외에 기업단위의 규모을 격리시킬 수 있는 수단을 생각해내지 못했다. | . | 역할 모델을 통해 로직의 격리에 성공해야한다. 빠르면 3년 ~ 길면 5년 | 역할 모델 이해 -&gt; 프로그래밍 격리 방법을 알아야 OOP세계에 입장권을 끊은 순간이다. 책을 읽고 -&gt; 역할 모델로 entity나누기 -&gt; 객체 설계 -&gt; 이제 입장.. | . | . | . | . Abstraction: 역할 모델을 위한 추상화 이해 . 추상화 대표기법1: 일반화: 수학에서 온 것. 다양한 현상을 1개로 설명할 수 있게 하는 것. 2, 8, 16의 공통점 -&gt; 함수로 묶는 것 ex&gt; modeling, function, algorithm | . | 추상화 대표기법2: 연관화: 내가 다 못하니까 다른애한테 맡겨야지. 나의 일부는 쟤꺼야. 복잡한 것은 띄어내서 쟤한테 준다. 위임이 가능하다. ex&gt; reference, dependence | 통으로 보면 복잡한 놈을, 뗴어낼 것은 떼어내서 위임시켜 보면, 간단하다. | . | 추상화 대표기법3: 집단화: 체계적인 분류 ex&gt; 카테고리제이션, 그루핑 ex&gt; group, category | . | IT에서의 추상화 데이터 추상화(Data Ab): 메소드, 함수가 없음. = 동작, 행위가 없음. | 크게 3가지로 나뉨.(외우자.) modeling: 특정 목표에 따라 기억해야할 것만 추리는 것( 학생 vs 학적부관리를 위해 기억해야하는 학번+이름만 기억) | categorization: 카테고리를 잘 만들어서 카테고리에 맞게 작동하도록 하는 것. 아빠이자~ 사장이자~ | grouping: 그냥(의미, 공통점 없더라도 4기를 묶어두는 것) 모아두는 것 | . | . | 프로시져 추상화(Procedural Ab): 절차적? (X) 순차적으로 1개씩 하는 것? (X) 고유명사로서 함수에게 데이터를 넘겨 처리를 맡기는 것 = 데이터 처리방법을 함수에게 위임하는 것 = 함수만을 이용해서 데이터를 처리하는 것 편하게 함수라고 생각하자. generalization: 일반화된 방법을 사용하면 할수록 함수를 적게 만들 수 있다. 책: 공통된 역할을 찾아, 하나의 인터페이스로 정의한다. | 문제점: 우리의 머리가 나쁘다. -&gt; 머리가 좋은 사람이 할 수 있다. | . | capsulization: 객체지향에서 나오는 캡슐화. 은닉화와는 다르게, 보다 더 추상적인 것을 표현하는 것이다. | 캡슐화의 여러가지 정의가 있어서 ATM기라 생각하자 출금 메소드- 사용자는 통장+돈 만 넣으면 되지만, 그 안에 인증+은행권연결+보안+트랜잭션+타은행연결 상호인증… 많은 기능이 내부에 있다. 하지만, 내부의 복잡한 기능은 감추고, 사용자에게는 간단한 인터페이스 출금이라는 것만 노출함. | 캡슐화를 하지 않으면, 바깥에 복잡성이 노출된다. -&gt; 여러가지 문제 중 가장 큰 문제는 (복잡성노출시 안에를 고치기 힘들다?X) 복잡성을 노출 하면, 머리가 나쁜 사용자들은 사용을 못한다. 우리가 만든 모듈을 누구나 쓰게하고 싶다면 캡슐라이제이션해야한다. | . | . | . | . | . | 객체지향적 추상화(OOP Ab): UML에서 class간의 연결관계 표현방법 Generalization: 일반화 - 인터페이스 or 추상클래스를 만듦 | Realization: 구상화 - 인터페이스 or 추상클래스에서부터 파생된 클래스 | Dependency: 함수의 인자를 받거나 부분적으로 참조해야할 때 | Association: 단짝, 나의 영혼에 각인된 친구, 필드에 정의된 dependency | Directed Association | Aggregation | Composition | . | . | 객체지향 프로그래밍이 어려운 이유 역할 모델을 사용하기 때문 역할 모델을 사용하기 위해서는 모든 추상화 기법을 동원함. 그 중에 일반화를 가장 대표적으로 씀(가장 머리가 많이 필요) | . | . | 수련하는데 시간이 오래걸려서 실패를 많이 한다. | . | . Timing: 프로그램이 실행되는 시간 . 프로그램이 실행되는 순간이 언제냐 . 여기에도 똑같이 추상화 기법이 적용이 된다 몇시몇분(X) 어떤 시간대 | . | . | Program &amp; Timing . 프로그램: 메모리에 적재되서 실행될 때부터를 program이라고 함. 프로그램은 언제 어떤시기에 생명주기를 갖고 실행되는지 = Timing을 보자. | . | . . language code : 언어로 코드 작성 컴파일 이전에, 코드품질을 위해 lint라는 것을 이용한다 | 프로그램 작성시 lint time을 이야기한다. 그거 왜 lint time에 못골라냈어. lint를 바꿔봐. | . | . | machine language: 컴파일을 통해 머신 랭기지로 바꿔짐 compile time | . | file: 파일로 바꿔서 영구보존 시도 | load: 메모리에 적재 | run: 실행 이후 LOAD -&gt; RUN 만 반복하여 실행됨 | run time | . | terminate: 종료 | | 3가지 에러가 있음. . context error도 있는데, 못잡아낸다. | run time error도 앵간하면 못잡아낸다. | 에러를 맞으려면 lint time or compile time에 맞고 싶어한다. | 스크립트 랭기지는 runtime에서 밖에 못 잡아낸다. | . | script program의 생명주기 . 바로 file이 되고 load된 이후에 machine language로 바뀐다. . . 이 동네는 syntax error빼고는.. run time에러에서나 잡아낼 수 있다. | . | . | . runtime . Runtime . load -&gt; run되는 부분만 생각해보자. . | file로 짠 코드를 [실행]을 눌러 메모리에 적재가 된다. . . load . 명령set와 값set로 로딩이 된다. | cpu는 간략하게 그리면, 외부버스를 통해 -&gt; 3가지 유닛으로 간다. | 제어유닛: 디코더를 이용해서 명령들 해석 및 격리 | 데이터유닛: 메모리계수기로서, 메모리의 위치를 찾아서 넣거나 빼거나.. | 연산유닛: 제어정보 = 말그대로 연산 | . | . | load이후에는 instruction fetch 와 decoding(명령을 가져와서 -&gt; 디코딩)한다. 메모리에 있는 명령과 cpu의 명령과는 직접적으로 일치하진 않기 때문에 . 디코딩을 통해 cpu가 이해할 수 있는 명령어로 디코딩한다. . | 외부버스를 통해 fetch한 명령이 cpu로 들어오고, 디코딩이 일어난다 . | 그리고나서 디코딩이 끝난 명령을 -&gt; 연산유닛으로 보내어 명령을 실행시킨다. . . | 명령을 실행할 때, 필요한 값들을 메모리 -&gt; CPU의 데이터유닛으로 가져온다. . | 가져온 값을 연산유닛에게 건네주면, . 연산유닛이 명령 + 데이터를 이용해서, 결과데이터를 다시 데이터유닛에게 건네준다. 이게 바로 execution(실행)이다. . | 데이터유닛은, 결과데이터를 다시 메모리로 돌려준다. . | . | 이후로는 다음명령(명령2)을 가져와 실행시키고 결과데이터를 건네주는 loading을 제외한 instruction fetch &amp; decoding -&gt; execution이 반복 된다. | . | 이처럼 메모리에 적재(loading)된 순서대로 명령이 실행된다면 동기화(sync)라고 부른다. 여기까지 메모리에 적재(loading)된 명령의 실행(fetch &amp; decoding -&gt; execution)을 runtime이라 부른다. . 명령이 다 실행되면 terminate가 일어난다. | . | Runtime이란 loading -&gt; instruction fetch &amp; decoding -&gt; execution이 다 일까? . Essential definition loading . 프로그램마다 다 가지는 최초 로딩 과정으로서, 메모리에 적재되는 순간 최초에 하는 행동은 이 프로그램 구동을 위한 기초적인 정의부터 로딩 ex&gt; 기저에 있는 print함수, console 등의 필수 정의들을 로딩.하도록 컴파일러안에 짜여져 있다. | . | 그 다음으로VTABLE MAPPING을 한다. . 코딩: 우리는 text만 짰음 | 컴파일러: file을 만드는 애 일 뿐이다. | 우리가 쓴 변수와 메모리공간은??? 이미 compile time에 변수마다 가상의 메모리가 있다고 가정하고, 컴파일 한다 | 이미 변수-가상의 메모리가 컴파일된 상태에 맞춰서 vtable mapping을 표로 만들어, 진짜 메모리와 매핑을 시켜, 진짜 메모리주소로 바뀐다. | . | vtable mapping으로 진짜 메모리를 얻은 상태이므로 실행가능해 진다. | . | 이제서야 RUN이 일어난다. . . 하지만 실행이후에 모든 랭기지는 끝나지 않는다. | . | RUNTIME DEFIFITION LOADING을 통해 실행이후에도, class 및 함수 정의 등 많은 정의를 로딩한다. . 최초 프로그램 실행시만 class등이 로딩되는 것이 아니다. | java만 해도 실행도중 새로운 class들을 계속해서 로딩할 수 있다. | java가 대단한점 : 업계최초로 runtime loading을 적용한 것 jar파일이 1~2기가 되는데, 실행시 왜 안뻗을까? 필요한 파일들은, 필요시 최초로 file에서부터 loading을 시작해서 ~! | c나 c++은 프로그램 시작시, 우리가 정의한 모든 class가 시작된다. | . | java는 사용자가 만든 것은 하나도 로딩X 필요시에 파일로부터 로딩 | . | . | RUN다시 로딩된, 새로운 class 등의 정의를 실행시킨다. . | 같은 runtime임에도 불구하고, essential definition loading과 vtable mapping은 한번만 일어나지만, run -&gt; runtime definition loading -&gt; run 은 계속해서 일어난다. . | . | Script Program . 스크립트의 생명주기를 생각해보면, 컴파일되거나 최초로딩(essential definition loading과 vtable mapping)없이 실행된다. . . | 일단 실행해야, 내가 만든 class와 함수가 loading이 된다. . 예를 들어, 브라우저 시작 -&gt; run -&gt; jquery를 로딩 -&gt; jquery를 쓰는 코드 실행 | 같은 runtime이지만, jquery쓰는 코드(run time)에 대해 상대적으로 jquery 정의 코드(static time)를 정적타임으로 보여진다. | jquery외에 다른 class 등을 사용할때도 상대주의적으로 나뉜다. runtime은 정의되어있거나 확정적인 것이 아니라고 생각해야한다. runtime안에서도 runtime이 쪼개지며, 각 코드에 대해서 확정타임이 상대적으로 정해진다. | . | . | . | . | . | runtime 요약 : runtime은 확정적인 무엇이라고 가정하지 말아라 . 유연하며, 언어에 따라 애매할 수도 있음. | . | . Pointer of Pointer: 메모리를 다루는데 있어서 반드시 기억해야할 것 . . 특정 포인트를 직접 가르키지 않고 어떤 값을 얻기 위해선 포인트를 찾은 뒤 -&gt; | 다시 포인트를 찾아서 얻겠다. | . | 왜 그럴까? | . | 가상의 메모리판이 있다. . A에라는 변수에 “TEST”라는 문자열을 넣었다고 가정하자. . 메모리에 그대로 박았으면, 11번~14번까지 문자열을 넣었다. | . | A의 주소 &amp;A는 11번이라고 할 수 있다. . 변수에는 2가지 속성이 있다. 변수안에 값 &amp; 메모리 | 11번에서 시작하지만, 4칸을 차지하는 것은 어떻게 안다? 변수의 길이로 안다. | java의 INT or BOOLEAN 같은 기본형들은 시작메모리번호에서부터 메모리를 얼마나 차지하는지의 길이를 나타내는 것들이다. 포인터는 첫번째 위치만 가리킬 뿐이다. | . | . | B라는 변수는 A의 주소를 가지고 있다고 가정해본다. . 26번 메모리에 있는 11은 실제론 숫자x a의 주소값이다. . | B의 주소가 기리키는 값 *B가 “TEST”라고 예기할 수 있다. . . | . | 중요한 것은 C와 D가 B와 동일한 값(&amp;A)를 갖도록 만든다면, 아래와 같이 만들어질 것이다. . B에 들어있는 것은 값이 아니라 주소(A의)기 때문에 B, C, D 모두 원래의 A를 가리키게 된다. B가 A를 가리켰는데, C와 D도 A를 가리키게 되었다. | . | . | 근데 B가 배신때린다면? . B가 “ABC”의 값 + 메모리28번부터의 K를 가리키도록 K의 주소값을 가지게 된다면? . . | B는 배신때려서 K를 가리키고 있고(K의 주소값을 가진다 = K를 가리킨다) C와 B는 여전히 A를 가리키고 있다. 뭐가 문제일까? | . | 이후 B는 바뀌었는데, C와 D는 자동으로 못갈아타고 A에 남아있다. . | 변화에 따라오질 못함. -&gt; 문제가 심각함. | . | . | 써있는 것은 C = B, D = B로서 B와 같은놈들이라고 쓰여져 있는데, 이후 B의 배신 및 C와D는 변화에 따라오지 못하고, B가 새롭게 가리키는 것(K)와는 다른 것 &amp; B옛날 것(A)을 가리키고 있다. . - B가 배신을 떄리는 순간 `코드를 보는 우리의 눈`이 잘못 안 체로 개발을 하게 된다. - **이게 바로 `참조의 전파`라고 한다** - 외부에 노출된 참조 = 직접참조의 문제다 - **이미 전파가 되어, 변화에 못따라가니까** 직접참조를 하면 안된다. - 문제는 사람이 만드는 것이다. C와D가 B와 같을 것이라고 코드를 보면서 믿고 있기 때문이다. - B가 배신때리는 순간 다 망가진다. - **객체 생성시점 == setter시점에 어떤 레퍼런스(참조)를 받아와 변수에 잡아넣고** **변수로서 프로그램을 돌리고 있는다. + 내가 받아온 레퍼런스(참조)는 안변하겠지(B의 배신이 없겠지)라고 생각한다.** . | 직접참조로 인한 문제, B의 배신에도 C,D가 변화를 유지하는 유일한 방법은? 참조(&amp;변수=주소값)값이 바뀔 가능성이 있는놈 자체를 변수 = 에 &amp;K 주소값을 넣는 포인터, 직접참조 하지 않고 | 참조값을 넣을 변수(=포인터)에 (map을 이용하여 value에다 넣는).을 통해서 포인터의 포인터를 이용하는 방법이다. | . | 포인터에 한번더 포인터비용을 지불함으로써, 런타임에서 레퍼런스를 바꿔도, 동일한 레퍼런스를 참조하게끔 만들 수 있다. 01번에 obj VALUE, V를 key로 갖는 map을 만든다. (map으로 만들어서 .을 사용) 이 때, VALUE라는 key가 A주소값을 가지는 = A를 가리키는 포인터가 된다. | 01번 map(포인터1) - 원래는 heap영역에 있어야하는데, 메모리에 그냥 임시로 그림 01번 map -&gt; 09번 VALUE(포인터2) -&gt; A(11번) | 01번 map -&gt; 16번 V -&gt; 3 | . | . | C와 D를 -&gt; B를 가리키게 하고 싶다. 변수 B는 26번 -&gt; 01번 map을 가리키고 있다. | 17번 C , 36번 D -&gt; 01번 map을 가리키게 했다. | . | B의 배신 대신 -&gt; B.VALUE로 배신을 때린다. B가 아니라 B.VALUE에 &amp;A대신 -&gt; &amp;K로 K포인터가 되도록 배신을 때리면 | B.VALUE -&gt; 11번(&amp;A)을 가리키던 것이 B.VALUE -&gt; 28번(&amp;K)로 바뀐다. | C(17)와 D(36)는 B.VALUE의 배신에도 여전히 B가 보던 01번 map을 보고 있는 상황이라 B, C, D 모두 01번 map -&gt; 업데이트 된 .VALUE -&gt; 28번(K)를 보게 된다 주소를 담은 변수(B)의 할당(직접참조)는 map의 껍데기만 할당해주고, 실제 참조가 바뀌는 부분은 map속 .VALUE로 가리키기해서, 매번 업데이트 되게 하자. | . | . | | . | my) runtime시 레퍼런스(한 변수가 참조하는 주소)가 바뀌는 경우가 있고 . 그럴경우, 일반 변수로 받아보던 또다른 참조변수들은 업데이트가 안되니 | 바뀔 예정이 있는 애들은 map안에 변수가 포인터가 되도록하고 받아보던 또다른참조변수들은 map을 할당받고 | 바뀌는 것은 map안의 .변수가 reference를 할당받으면서 변경가능하게 하자 | . | 직접 메모리 참조시, 걔를 참조하는 애들은, 업데이트가 자동반영안되 문제가 된다. | 참조하는 애들은 껍데기를 참조하도록하고, 변경가능한 놈은 내부에서 바뀌게 한다. 대신 참조하는 애들은 껍데기-&gt; .점을 통해 -&gt; 업데이트되는 내부에 접근하게 한다 | . | **이 원리(참조에 참조, 점을 통한 다시 한번 참조 찾기)는 객체지향에서** 직접참조X 위(바깥) 참조를 통해 아래(내부)로 내려오는 구조로서 | 인터페이스를 정의시, 추상클래스 메소드호출 -&gt; 그 함수가 구상클래스 메소드를 호출할 수 있는 원리이며 | 링크드리스트의 원리 | 데코레이션 패턴의 원리 | . | 책에서는 동적 바인딩이라고 표현한다. 우리는 직접참조는 지양하고, 참조에 참조를 이용해야, 런타임변경에 안전해진다. | 그래서 객체지향에서는 값을 이용하지 않고, 모든 곳에 참조를 이용한다. 가리키는 것이 &amp;A(11번) -&gt; &amp;K(28번)으로 바꿀수 있는 유연성을 얻기 위해서 | 직접 참조했을 땐, 전파시 문제가 생김(참조당하는 애들이 변경하면 업데이트가 안됨) | 감싸는 포인터를 가리켜야함. -&gt; 객체 안에 객체가 있어야함 -&gt; 모든 것을 객체로 만들어야함. | . | . | . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/2022/05/01/(object1-1)%EC%B1%85%EC%9D%BD%EA%B8%B0%EC%A0%84_%ED%95%84%EC%9A%94%EC%86%8C%EC%96%91.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/oop/object/2022/05/01/(object1-1)%EC%B1%85%EC%9D%BD%EA%B8%B0%EC%A0%84_%ED%95%84%EC%9A%94%EC%86%8C%EC%96%91.html",
            "date": " • May 1, 2022"
        }
        
    
  
    
        ,"post78": {
            "title": "레벨1 레벨 인터뷰 및 피드백",
            "content": "레벨 인터뷰 관련 . 레벨로그를 작성해서 공유하여 레벨 1학습한 것을 정리 . | 메타인지: 자신이 아는지 모르는지 성찰하는 능력, 자신의 생각에 대해 생각하는 능력 . | 6명: 1인터뷰이 -&gt; 3인터뷰어(질문자) + 2옵져버(피드백 기록-어떤점이 부족하고 어떤점을 보완했으면 좋겠다.) . | 명당 30분(인터뷰 20분 + 피드백 10분) 내가 인터뷰어일 때, 해당하는 인터뷰이의 레벨로그를 읽어보고 참석해야한다 | 내가 옵져버일 때, 말하기 역량에 대한 피드백을 준비한다. | . | 레벨 2 시작하고 수, 목 14시~17시 . 코치들이 난이도 있는 질문을 추가적으로 한다. | . . | . 준비 . 레벨 로그 . TDD . test 파일부터 만들어서 개발을 시작한다. 메서드명은 한글로 사용해도 상관 없으며 단위테스트가 의미하는 바를 잘 나타내야한다. | 테스트시 코드를 작성할 때 당장 존재하지 않는 클래스, 메서드를 사용해서 작성한 뒤, red(error)를 발생시킨다. red를 제거하여 green(pass)이 되는 방향으로 프로덕션 코드를 작성한다. | pass된 프로덕션 코드를 바탕으로 기존 프로덕션 코드를refactoring한다. | 더이상 refactoring할 것이 없다면 새로운 단위테스트를 만들어서 이어나간다. | 요약하면 fail하는 test -&gt; pass하도록 빠르게 production 수정 -&gt; refactoring | . | 할 수 있다면 주석으로 //given //when //then 3단계로 나누어서 테스트코드를 작성하여 예상값과 실제값을 비교한다. | 직전과 비슷한 test case를 작성한다면 코드를 복사하여 붙여넣기를 활용하면 좋다. | . 테스트 하기 힘든 것을 전략패턴으로 . 자동차 미션의 랜덤한 값에 따라 자동차가 움직임 , 로또 미션의 자동 로또를 랜덤하게 생성함, 블랙잭 미션의 랜덤한 카드덱을 매번 생성, 체스 미션의 매번 DB에 연결하는 Dao | 각 미션마다 테스트하기 힘든 부분을 어느 추상체에 대한 구현체 중 1개로 보고 해당코드를 추상화한다. 이 때, 추상화된 인터페이스를 파라미터에서 받아 외부에서 주입받도록 한다면 전략패턴이 되는 것이다. 이제 테스트 하기 힘든 구현체와 같은 레벨의 테스트 하기 쉬운 구현체를 작성하여 Test코드에서 외부에서 주입할 수 있다. | . 상속, 추상클래스, 조합 . 상속은 같은 레벨의 클래스들이 중복된 코드를 가질 때 고려해볼 수 있다. 공통된 메서드나 필드가 발견되면 그것들을 모아놓은 부모클래스를 생성하고 그 메서드나 필드를 받아 쓸 자식클래스들은 해당 클래스를 상속한다. | . | 이후 공통적이지 않은 메서드들에 대해서는 구현부는 다를지언정 메서드명을 추상화할 수 있는지 고려해보아야한다. 자식클래스들에 대해 서로 다른 구현부를 가진 메서드에 대해서 메서드명이 추상화가 된다면, 추상화된 메서드명으로 abstract method를 정의해주자. intellij가 알아서 abstract class로 변경하라고 메세지를 보내준다. | 메서드명의 추상화 성공시, 또다른 중복코드가 발생할 수 있는데 다시 abstract class로 공통 부분들을 올려주면 된다. | . | 조합은 공통되는 코드를 부모클래스를 생성하여 올리는 것이 아니라, 따로 클래스로 추출한 뒤, 기존 클래스의 생성자호출시 주입하여 상태값(필드)로 가지고 있게 된다. 코드중복을 상태값으로 간 객체의 메서드호출로 해결할 수 있다. 상속의 단점이자 조합의 장점 기존 클래스의 변화에 영향이 적어지며, 안전하다. | 메서드를 호출하는 방식으로 동작하기 때문에 캡슐화를 깨뜨리지 않는다. | . | 조합대신 상속을 고려해볼만 할 때 확장을 고려했는데도 설계한 확실한 is - a 관계(부모가 변할일이 없을 때) | . | . | . 대본 . TDD . 정의: 켄트 백에 의해 창시된 TDD는, 기존의 [ 설계-&gt; 개발-&gt; 테스트 ]의 과정과 다르게, [설계 -&gt; 테스트 -&gt; 개발]의 과정으로 진행되며, 테스트 자체도 red-&gt;green-&gt;refactoring 3가지 cycle로 돌아갑니다. 1) red로 테스트를 작성하고 2) green으로 기능을 완성하되 빠르게 완성시킵니다. 3) 다음 case로 넘어가기 전에 refactoring을 실시합니다. . | 장점: 마음에 안정감이 생기면서, 디버깅 시간을 줄이면서, 그 자체로 명세 역할을 할 수 있습니다. 1) 안정감이 생기는 이유는, 자연스럽게 작은 단위를 테스트하도록 작성하므로, 단일책임원칙을 지키면서 코딩할 수 있었습니다. 하지만, TDD에 실패하는 대부분의 이유가 추상체가 아닌 구현체를 테스트하는 경우임을 인식해야합니다. 인터페이스를 테스트해서 무엇보다도, 초록색불을 보면 안정감이 생겼습니다. 2) 디버깅 시간을 줄인다는 의미는 프로덕션 코드 이전에 설계 후 테스트가 이어지기 때문에, 테스트과정에서 설계가 바뀐다면 빠르게 설계를 수정할 수 있습니다. 처음에는 오히려 시간이 많이 걸릴지도 모르지만, 엎어지는 설계를 하는 과정에서도 도메인 지식이 쌓이게 되어 장기적으로는 빠르게 코드를 완성할 수 있습니다. 3) 자체로서 명세역할을 한다는 의미는, 팀원이 TDD의 과정으로 개발된 프로젝트는 테스트 코드만 봐도, 로직을 이해할 수 있게 되기 때문입니다. . | 상속 . 같은 레벨의 클래스들이 중복코드를 가져서 코드중복 제거을 위해 고려해볼 수 있다. . 상속의 예시: 체스판 위의 기물들, 예를 들면 킹,퀸,룩,비숍,나이트,폰 등을 표현하고자 할 때, 각 기물들은 구현하다보면, move라는 공통 기능을 발견하게 됩니다. 이 때, 각 기물들을 자식클래스라고 생각하고 Piece라는 부모클래스를 만들어서 공통기능을 위임하고 코드 중복을 제거할 수 있습니다. . 하지만, 상속에서 자식은 이미 부모가 불변할 것이라고 가정하고, 추가적인 역할을 얹어 사용하는 경우가 많은데, 이렇게 사용할 경우, 부모가 더이상 base문제를 해결하지 못하게 되면, 그 위에 쌓인 자식의 기능들도 다같이 무용지물이 되게 됩니다. . 이럴 때, 고려하는 것이 조합입니다. 조합은 부모의 코드를 바로 내려받는 것 아니라, 공통 기능을 외부 주입으로 통해 받아 변화에 대응할 수 있게끔 합니다. 마치, 원신값 대신 VO를 사용하듯이, 포인터의 포인터를 사용해 공통기능의 변화가 발생하면, 변화된 코드를 받아 사용할 수 있습니다. . 만약, 상속을 유지하겠다면, 자식에게는 최소한의 역할만 배정하는 게 좋습니다. 추상클래스를 하면서, 템플릿메소드패턴을 사용해서 위임할 수 있는 가장 작은 구현책임만 자식에게 위임할 수 있습니다. . 하지만, 여러 기물들을 차례로 하다보면 구현하다보면 공통된 기능이 아니라 서로 다르게 구현해야함을 발견할 수 있습니다. 이 때, 메서드명만 추상화한 추상클래스로 정의해볼 수 있습니다. 더욱이, move뿐만 아니라 canMove? 등의 메서드를 구현하다보면, 자식들마다 구현이 다른 코드가 축적되게 되고, 특히 폰의 경우 그렇습니다. . 이렇게 자식의 책임이 커질 때는, 부모클래스가 더이상 필요 없을 수 있습니다. . 혹은 공통된 기능만 주입받는 조합을 고려해볼 수 있고, 부모의 역할에상속을 이용하는 것보다, 모든 책임을 위임하도록 인터페이스와 구현체로 전환을 고려해볼 수 있습니다. . 이 때, 조합이나 인터페이스로 변경을 통해, 상속이 가지는 단점인 부모 코드에 대한 의존성, 높은 결합도를 줄여볼 수 있습니다. . 전략패턴 -&gt; 로또미션 + 체스dao로 예시들기 . 피드백 . 같은 조 인터뷰 피드백 전체 . 경험을 바탕으로 말하라. | 실패 사례도 같이 예시 들기 | 학습 방식도 같이 말하기 | 뜻을 잘 모르겠으면 다시 질문의 묻기 | 생각할시간달라하기 | 물어본 것부터 답변후 사례나열하기 . 주관식답변 + 3줄 정도만 답변후, 더 답변을 원하는 눈빛을 보이면 하기 | . | 말하기 전 3~5초 잠깐 생각하고 말하기 . 아는 것 나왔다고 바로 답변하지 않기 | . | 잘모르는 키워드, 단어는 꺼내지도 마라 . ex&gt;일급컬렉션 -&gt; 불변으로 연결안되면 꺼내지도 마라. . | “그것에 대해서는 학습이 많이 필요한 상태입니다.!” . | . | 계속 질문한다면 고집스런 모습이 없는지 파악하는 것일 수 있다. 다른쪽으로 유도 되는 질문을 잘 파악하기 | 상상력을 요구하는 꼬리질문에 대해서, 단정짓게 끝내지마라. | 급한 느낌을 받았다. 내가 말할 수 있는 목적을 간단명료하게 하는 것이 학습로그의 목적&gt; 질문 듣고, 말하기 전에 3~5초는 잠깐 생각하고 말하기 | 주관식답변 + 3줄 정도만 답변후, 더 답변을 원하는 눈빛을 보이면 하기 | . | 잘하는 부분과 못하는 부분 같이 말하며 현장감이 드는 설명하기 | . 레벨1 피드백 . 일급컬렉션 반례: 객체생성비용이 많이 드는 경우도 있다. ex&gt; db컨넥션, 웹소켓 객체들은.. 생성비용 크다 -&gt; 일급x | 재사용 및 상태변경이 일어남 -&gt; 일급X | . | . | mvc 장점: 레이어간의 책임분리(레이어분리)로 요구사항 변경에 대한 확산이, 딱 그 레이어까지만 일어나게 | . | 중복된 코드 제거의 목적 : 가독성 뿐만 아니라, 요구사항 변경의 전파를 막기(격리) 위해 중복코드를 제거함. By한 부분만 수정 | . | 어필하기 위한 글쓰기도 전략 어려운 것 질문하기 쉽게 내지마라. | 예) 수달님의 레벨로그 방어적 복사 vs Unmodifiable vs CopyOf | 답변: 방어적 복사: 파라미터로 넘어오는 객체(컬렉션)에 대해서 연결을 끊어놓고 받아 사용하고 싶을 때 new ArrayList&lt;&gt;( 파라미터로 넘어온 컬렉션 ) | . | Unmodifiable &lt; CopyOf getter 내가 가지고 있는 컬렉션을 끊어서 줄 때 | . | . | . | . | 개념 -&gt; 사례순으로 나열하기 | . 개인 피드백 . 할 말이 많아도 천천히 말하기 -&gt; 못 따라간다. | 사례를 많이 말한다 -&gt; 말이 빠르다 + 정정하는 말이 많았다. -&gt; 많은 사례에 비해 들리는 것이 없었다. | 중간 중간 분위기를 풀어주는 농담이 좋았다. | 여러 사례에서 넘어갈 때 텀과 포인트가 필요하다. | 모범답안이 아니라, 주관적인 답변이 개발적 가치관을 알 수 있어 좋았다. | 작은 질문에 비해, 답변을 많이 했다. 밸런스가 중요한데, 질문할 텀을 좋은 것 같다. | 경험이 잘 전달되는 인터뷰라 좋았지만, &lt; 급한 느낌을 받았다. 내가 말할 수 있는 목적을 간단명료하게 하는 것이 학습로그의 목적&gt; . | 질문듣고, 말하기 전에 3~5초는 잠깐 생각하고 말하기 | 내 인터뷰 답변 내용 기록 . 테스트 네이밍 메소드 명과 같이 카멜케이스 사용 혼자서 작성할 때는 한글, 그렇지 않은 경우는 영어로 . | 중복된 코드를 줄이기 위해 인터페이스가 아닌 상속을 사용한 이유 . | 같은 레벨에 있는 클래스를 작성할 때 중복 코드가 발생 | 인터페이스를 사용하지 않는 이유는 부모의 역할이 클 때는 상속을 사용하고, 확장성이 있다면 조합이나 인터페이스를 사용해서 진행 | . 조합을 사용해본 경험 프로젝트에서 조합을 사용해보려 했으나 실패, 상속에 비해 조합이 부모 클래스에 대한 의존을 줄일 수 있음 . | 전략패턴 분기를 줄이는데도 사용, 테스트를 줄이기 위해 사용 . | TDD의 장점 | 테스트 코드 안정감 | 단일 책임 원칙을 지킬 수 있음 | 디버깅 시간을 줄일 수 있음 + 숙달 시 설계 시간을 줄임 | 자체로 명세가 될 수 있음 . | TDD의 단점 시간이 너무 오래 걸린다. 절충이 필요한 점. 작은 프로젝트에 적합하지 않다고 생각 . | 큰 프로젝트에서 요구사항 변경이 생긴다면 TDD가 적합하지 않지 않을까 TDD가 익숙하다면 무조건 유리할거 같다. . | TDD를 학습하기 위한 전략 메인 로직을 짜다가 작은 단위를 테스트하고 올라오고 반복 . | TDD를 큰 로직을 성공 후 작은 로직을 개발하다가 전체가 문제가 생긴 경험? | TDD가 실패를 기반으로 개발하다 보니 전체가 문제가 생긴 경험이 많음. | . 테스트 코드 + 프로덕션 코드 변경이 많은 경우 | 주요 로직이 아니라면 삭제, 삭제가 불가능한 경우 테스트 코드 자체를 리팩토링 해야한다고 생각 | . 추상화란 무엇인지 | 비슷한 역할을 하는 것들이 보이면 추상화의 대상이 된다고 판단. 최초로 코드를 짤 때는 추상화를 고민하지 말고, 리팩토링 할 때 추상화를 고려해보아야 한다. | . 중복된 코드는 왜 제거해두어야 할까? | 다른사람이 읽거나 찾아가는데 방해가 되는 경우 중복된 코드를 내버려두어도 된다.” | .",
            "url": "blog.chojaeseong.com/%EB%A0%88%EB%B2%A81/%EC%9D%B8%ED%84%B0%EB%B7%B0/%EB%A0%88%EB%B2%A8%EC%9D%B8%ED%84%B0%EB%B7%B0/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/19/%EB%A0%88%EB%B2%A81-%EB%A0%88%EB%B2%A8%EC%9D%B8%ED%84%B0%EB%B7%B0.html",
            "relUrl": "/%EB%A0%88%EB%B2%A81/%EC%9D%B8%ED%84%B0%EB%B7%B0/%EB%A0%88%EB%B2%A8%EC%9D%B8%ED%84%B0%EB%B7%B0/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/19/%EB%A0%88%EB%B2%A81-%EB%A0%88%EB%B2%A8%EC%9D%B8%ED%84%B0%EB%B7%B0.html",
            "date": " • Apr 19, 2022"
        }
        
    
  
    
        ,"post79": {
            "title": "데스크탑 iptime RDP 설정",
            "content": "iptime에 물린 컴퓨터/테블릿 중 원격접속할 [데스크탑 내부ip]를 확인한다. . 192.168.0.1 &gt; 관리도구 . | 고급 설정 &gt; 네트워크 관리 &gt; 내부 네트워크 정보 . | 원격접속할 데스크탑의 내부ip 확인 . 192.168.0.11 D8-BB-C1-5F-99-3A DESKTOP-CJROKE9 유선:자동할당 . | 데스크탑 내부ip를 포트포워딩 설정(외부:4444 1~100빼고 맘대로, 내부:3389 rdp고정) . 고급 설정 &gt; NAT/라우터 관리 &gt; 포트포워딩 설정 외부포트는 1~100를 제외한 맘대로(4444)로 설정해준다. | 내부포트는 3389가 고정이어야한다(3389로 보내야, RDP로서 컴퓨터가 port 오픈해줌) | . | . . . 기본 설정 &gt; 시스템 요약정보에서 [외부IP]확인 or DDNS 사용하기 . 외부IP는 동적IP이기도 해서 외부IP는 사용하지 않는다. | IP대신 DDNS를 제공받아서 chodesktop.iptime.org 자체를 내 외부ip로 사용한다. | . 원격 제어되는 컴퓨터 설정(원격 설정 활성화/계정 비번설정/계정 확인) . 시작메뉴에서 원격 설정 검색 &gt; 원격 데스크톱 설정 &gt; [x] 원격 데스크톱 활성화 | 현재 사용자 비밀번호가 없다면 설정 win + i &gt; 계정 &gt; 로그인 옵션 &gt; 비밀번호 &gt; 추가 | . | 시작메뉴에서 control userpasswords2로 사용자 이름 확인 | 외부(공용 네트워크)에서도 접속가능하도록 설정 . . 시작메뉴에서 windows defender 방화벽 검색 | windows Defender 방화벽 설정 또는 해제 클릭 | 공용 네트워크 설정 tab &gt; [ ] 허용되는 앱 목록에 있는 연결을 포함하여 모든 들어오는 연결 차단을 체크해제 | mstsc &gt; chodesktop.iptime.org:4444 &gt; cho_desktop로 RDP 접속하기 .",
            "url": "blog.chojaeseong.com/rdp/iptime/%EC%9B%90%EA%B2%A9/configuration/2022/04/19/%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91-iptime-RDP-%EC%84%A4%EC%A0%95-%EC%B4%9D%EC%A0%95%EB%A6%AC.html",
            "relUrl": "/rdp/iptime/%EC%9B%90%EA%B2%A9/configuration/2022/04/19/%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%83%91-iptime-RDP-%EC%84%A4%EC%A0%95-%EC%B4%9D%EC%A0%95%EB%A6%AC.html",
            "date": " • Apr 19, 2022"
        }
        
    
  
    
        ,"post80": {
            "title": "의연방09) PSA 분석1(매칭)",
            "content": "R 고급 실습(ps matching with datacleaning-dplyr, MatchIt, tableone-CreateTableOne, geepack-geeglm, broom-회귀계수를 OR로 변환) 포함됨 | . &#54617;&#49845;&#47785;&#54364; . Propensity score analysis의 목적과 정의를 설명할 수 있다. . Propensity score의 정의를 알고, 추정하는 방법을 설명할 수 있다. . PS matching 방법을 이해하고, 직접 수행할 수 있다. . &#51452;&#50836;&#50857;&#50612; . Propensity(프로펜서티) score analysis : confounding이 존재하는 관찰연구의 데이터를 RCT의 데이터처럼 confounding이 없도록 가공하여 분석하는 방법 . | Propensity score : 치료군에 속할 확률 . | . &#47785;&#52264; . Motivation | PS 추정 방법 | PS Matching 4가지 중 1가지 방법 | . | Motivation(&#54616;&#45716; &#51060;&#50976;) . Association vs. causality . 위험요소-질병간의 상관관계 -&gt; 인과관계를 살펴보고 있는데 상관관계가 곧 인과관계를 의미하지는 않는다 | . | . 상관관계가 관측될 경우, 아래를 확인해야한다. 이 상관관계가 진짜인가? | 우연이나 잘못된 연구디자인에 의한 것인가? | . | 상관관계가 진짜로 판단되는 경우 인과관계가 성립하는가? | confounding에 의해 생겨난 상관관계인가? | . | Confounding&#51012; &#45796;&#47336;&#45716; &#48277; . 연구 디자인 단계에서 confounding을 최대한 제거한다 랜덤화 -&gt; RCT를 하는 것 | 매칭 | | 데이터 분석 단계에서 confounding 효과를 보정한다 Stratification confounder 값별로 그룹을 다시 나눠서 분석 | . | Adjustment multivariable model로 분석하는 것 | . | Propensity score analysis confounding 효과를 보정하기 위해서 | (마치 RCT에서 나온 것 같이) 데이터를 가공하여, X값을 랜덤하게 배정했을 때 관측될 법한 virtual data를 만들어 분석한다 | . | | . Propensity score analysis . Confounding이 존재하는 관찰연구의 데이터를 -&gt; RCT의 데이터처럼 confounding이 없도록 가공하여 분석하는 것 | Propensity score (PS) : (치료군/대조군 비교 연구에서) 치료군에 속할 확률 . 위험요소 - 질병 or 치료방법 - 질병 간의 관계를 살펴볼 때 위험요소O/X or 치료O/X 2군으로 나누고, 질병 발생 빈도를 살펴보게 된다. | . | 2군으로 나누었을 때, 그 중에 1군(치료군)에 속할 확률을 PS라 한다. . RCT에서는, 모든 환자에 대해서 PS = 0.5(치료군 0.5 -&gt; 대조군도 0.5) | 관찰연구에서는 PS(치료군에 속할 확률)는 알려지지 않은 (일정한 확률이 없는)미지의 값 | 관찰연구에서 PS는 환자 특성(or 치료자, 환자가 속한 지역/병원)에 따라 달라짐 | . | . | PS를 사용하는 이유? PS에 condition을 하고나면, baseline characteristics(환자 특성)와 treatment selection(치료군이냐 대조군이냐)이 독립이 된다. | 무슨 얘기냐? PS가 비슷한 환자들끼리 모아놓으면, 치료군/대조군의 baseline characteristics 분포가 비슷해진다 | . | 원래는 환자 특성(baseline characteristics) -&gt; 환자가 치료군에 속할 확률(treatment selection)에 영향을 주게 되는데 환자 특성을 일일히 확인해서 비슷한 사람들끼리 모아놓는게 아니라, 환자 특성에 영향 받는 PS만 알고 있다면, PS를 기준으로 비슷한 환자를 모아두기만 하면, 환자 특성 분포가 비슷해진다 | . | . | . PSA&#50836;&#44396;&#54616;&#45716; 4&#44032;&#51648; &#44032;&#51221; . consistency(컨시스턴시) 환자가 받은 치료법에 따라서, 치료군이든 대조군이든 관측될만한 outcome(질병)이 있다. 그것이 real world에서 관측한 것과 outcome(질병)이 같다 | 환자의 potential outcome = 실제로 관측된 outcome | . | no unmeasured confounder 모든 confounder를 알고 있고 관측했다는 가정 | . | Positivity : 치료군이 될 확률＞0, 대조군이 될 확률＞0 어떤 환자든지 한쪽에만 속하는게 아니라 2군 각각 속할 확률이 존재한다 | . | no misspecification of PS model PS score 추정모델이 잘못되어선 안된다. | . | 3번 제외 다른 가정들은 만족시키기 어렵다 모든 통계모델은 많은 가정아래 존재한다. | 그런데 항상 만족시키는 것은 아니다. 현실을 완벽하게 반영은 X | . | . Regression vs. PSA . PSA에 대한 사람들의 의문점 “Confounder는 공변량으로 Multivariable regression model에 넣으면 보정 되는 것 아닌가요?” 이것도 유효한 방법이나, treatment effect가 조금 다르게 나온다. | . | . | . Regression에서 추정하는 효과 : conditional treatment effect 각 환자 개개인에서의 평균 효과 | . | PSA와 RCT에서 추정하는 효과 : marginal treatment effect 모집단 전체에서의 모든 환자의 평균 효과 | . | Conditional vs. marginal . 두 개는 뭐가 다른 것일까? | . Conditional treatment effect in Regression . “한 환자에게 혈압강하제를 투여하는 실험을 여러번 반복할 때, 평균적으로 수축기 혈압을 10만큼 낮춘다” 여기서 -10이 Conditional treatment effect이다. | 이 환자에게 약을 투약하는 실험을 여러번 반복해서 평균적으로 수축기혈압을 10만큼 낮춘다. 개인에서의 평균 | . | . | . | Marginal treatment effect in PSA, RCT . “고혈압 환자 전체에서 평균적으로 수축기 혈압을 10만큼 낮춘다” 여기서 -10이 ConditMarginal treatment effect이다. | 각 환자에게 낮춰진 수축기혈압을 모두 구해, 모든 고혈압 환자에서 평균적으로 10만큼 낮춘다. 전체에서의 평균 | . | . | . | 한 환자당 10만큼 낮추면(conditional) -&gt; 평균적으로 전체에서도 10만큼 낮춰질 수 밖에 없다.(marginal) . 이 것이 가능한 상황은, 현재 연속현 변수(수축기혈압)의 평균으로 추정하거나 | 아니면, 이분형 변수에서 치료군vs대조군 비율의 차이(Risk Differenece)로 계산할 경우에 | conditional == marginal treamment effect 로 항상 같다 | . | 하지만, | 효과가 연속변수의 평균 차이 또는 이분형 변수의 비율차이(RD)가 아니라 OR 또는 생존분석의 Hazard Ratio로 측정되는 경우도 있디. conditional tx effect ≠ marginal tx effect로 다르다. | . | . | 그럼 무엇을 써야할지 어떻게 결정할까? . 내가 추정할 치료효과가 RCT에서 나타나는 결과와 유사한가? yes라면, Multivariable regression가 아닌 Propensity score analysis가 더 적합하다 판단하고 Marginal treatment effect in PSA, RCT 를 구하면 된다. | . | . | . 2&#44032;&#51648; &#45224;&#51008; &#47928;&#51228; . PS를 어떻게 추정할 것인가 | PS가 비슷한 환자들은 confounder가 없는 상태라고 하는데, 비슷한 환자들은 어떻게 모아서 치료효과를 추정할 것인가? | PS &#52628;&#51221; &#48169;&#48277; . PS&#47484; &#52628;&#51221;&#54616;&#45716; &#48169;&#48277; . 보통 로지스틱 회귀분석을 이용한다 Propensity score는 치료군에 속할 확률이라고 했다. | 치료군에 속하느냐? vs 대조군에 속하느냐?의 이분형 변수로 하는 로지스틱 회귀분석을 이용해서 추정한다. | 그렇다고 꼭 로지스틱 회귀분석을 사용하는 것이 아니라, 이분형 결과변수를 사용하는 모든 종류의 분석방법 사용가능 예) SVM, neural network, tree, random forests | 결과변수(종속변수, 반응변수) : 실험군(치료군)/대조군 | . | . | . | 현실적으로는 로지스틱 회귀분석이 가장 많이 쓰인다. | . PS model&#51032; &#49444;&#47749;&#48320;&#49688; . propensity score를 구하기 위해 regression model에 어떤 설명변수를 넣어야할까? PS 개념상으로는 이 사람이 치료군에 속할지/대조군에 속할지 결정(X, 치료여부)에 영향을 끼치는 변수들을 모두 설명변수에 변수들(아래 그림 중 가운데에서 C)을 넣는 것이 맞는 것 같지만... | X(어느군에 속할지 == 치료여부) -&gt; Y(outcome) | . | 추가로, 여러 시뮬레이션을 통한 여러 연구결과: 치료군/대조군 결정(X)에 영향을 끼치지 않더라도 outcome(Y)에 영향을 끼치는 변수들(3번째 그림)은 넣는 것이 좋다라고 연구 결과가 나왔다. 분산을 감소시킴 = p-value가 낮아짐 &amp;&amp; 신뢰구간 좁아짐 등의 효과** X(치료여부)에는 영향을 끼치지 않더라도 Y(outcome)에 영향을 끼친다면 넣자. | . | . | outcome(Y)에 영향을 끼치지 않으면서 치료군/대조군 결정(X)에 영향을 끼치는 변수들은 넣지 않는 것이 좋다 (분산을 증가시킴) PS정의상으로는 넣으면 좋을 것 같지만 | 연구결과 넣지 않는 것이 더 좋다고 나옴 | 가운데 그림의 C -&gt; 넣지 않는 것이 좋다라고 연구결과가 나온 것도 있다. | . | . | . 그럼 어떤 것을 PS의 regression model에 어떤 설명변수를 넣어야할까? | . 보통 Table 1에 들어가는 baseline characteristics는 치료군/대조군 결정(X)과 outcome(Y) 둘 다에 영향을 준다 → 다 포함하는 것이 좋다 | table1의 기본특성은 거의다 confounder로 생각된다. 다 포함시키면 된다. | . | PS model은 overfitting 문제가 없다 원래 다변수 모델에서는 설명변수가 많아지면 -&gt; 데이터에 비해 모델이 복잡해져 overfitting이 발생하지만 | . | PS model에서는 그런 overfitting 문제가 없다 → 설명변수 개수에 제한이 없다 | . | PS model은 우리가 알고 싶어하는 것에 대한 최종 model이 아니라 confounder 보정의 중간단계이기 때문에, 넣고 싶은만큼 많이 넣어도 된다. 조금이라도 confounder 같다고 의심되는 변수는 모조리 포함시키면 된다. | . | . | 절대 포함하면 안되는 변수 치료군/대조군 결정 이후 관측된 변수 | PS의 정의= 치료군에 속할 확률 치료군/대조군 결정되기 이전의 변수들로 판단되어야한다 | 군 결정이후 발생된 변수는, 과거(군 결정)에 영향을 주면 안된다. | . | cf) 관측만 결정 이후에 되었을뿐이지, 그 변수값 자체는 치료군vs대조군 결정이전에 결정된 경우도 있다. 예) 2가지 수술방법에 대한 비교 연구 수술이후 조직을 biopsy한 결과 -&gt; 치료군vs대조군 결정이후 = 수술방법 결정이후 관측되었지만 | 수술이전에 이미 내부장기상태는 결정된 상태라고도 볼 수 있다. | . | . | . | . PS Matching . PS model을 만들어서 PS를 추정했다고 가정하자 그 이후 다음 단계 분석은 어떻게 해야할까? | . | . PS &#52628;&#51221; &#54980; &#48516;&#49437;&#48169;&#48277; . - Matching - Stratification - Weighting - Covariate adjustment(코베리에잇 어저스먼트) . 예제 원의 크기 = 환자별 치료군에 속할 확률(PS) 대조군에는 원의 크기가 작은 환자들이 많고 | 치료군에는 원의 크기가 큰 환자들이 많다. | . | . | . PS matching . PS가 비슷한 환자별로 치료군:대조군 1:1 쌍을 지어주는 것 짝이 지어진 환자들만 분석하고, 짝이 안지어지면 분석에 사용안한다 | 2군에 걸쳐 짝이 지어졌다 = 분포가 동일해진다. = 전체적으로 PS가 비슷해짐 = 다른 기본특성도 비슷해짐 = confounding이 제거된다. | 장점 : 직관적으로 이해가 쉽다 | 단점 : 짝지어지지 않는 환자의 데이터를 잃어버린다 n은 클수록 좋은데, 모아진 데이터를 버려야하니 큰 단점 | . | . | . &#47588;&#52845; &#48169;&#48277; . With replacement vs. without replacement . With replacement: 매칭해서 짝 지은 다음 -&gt; 복원 추출처럼 다른 환자랑 매칭가능하게 하는 것 통계적으로 더 좋은 성질을 가지지만, 여러번 들어갈 수 있어서 -&gt; 사람들이 껄끄럽게 생각함 | . | withoutreplacement: 비복원추출 -&gt; 매칭후 분석풀에서 재고 실제로 많이 사용되는 것 | . | . | Greedy vs. optimal matching vs. full matching . Greedy: 한명씩 순차적으로 매칭 가장 많이 쓰임. | . | optimal: 전체적 2군의 PS가 비슷해지도록 한번에 매칭 | full: 버림없이 모든 환자를 매칭 | . | 1:1 vs. n:1 . 대조군이 너무 많을 경우 -&gt; 대조군:치료군 = 4:1까지 매칭된다. | . | 오스틴이 밝힌 가장 좋은 매칭 방법은? . nearest neighbor matching(=Greedy) with caliper 치료군 환자에 대해 가장 PS가 비슷한 환자를 뽑더라도, 가장 비슷한 PS를 뽑더라도, 치료군의 PS와 차이가 많이 나는 대조군이 뽑을 수 있다. | . | PS차이의 한계를 정해놓은 것 = caliper logit of PS을 먼저 계산한다 log 𝑃𝑆/(1-𝑃𝑆) | . | logit of PS의 표준편차를 계산하고, 여기에 0.2를 곱한 값을 caliper로 생각한다. 0.2 * SD of logit of PS | . | 위의 caliper를 치료군-대조군 matching시 PS차이 한계점으로 생각(넘으면 버림)하고 nearest neighbor matching을 돌리면, confounder로 인한 치료효과 추정치에 생기는 bias가 99%가 제거된다. | | . | 이로 인해 nearest neighbor(=Greedy) matching with caliper를 가장 많이 쓴다. . | . &#47588;&#52845; &#54980; balance &#54217;&#44032; . 매칭을 한 뒤, 잘 매칭되었는지 확인하기 위해 PS matching -&gt; 목적:confounding이 없어졌는지 == baseline characteristic 차이가 정말 줄어들었는지를 확인해야한다 | 즉, baseline characteristics의 차이가 줄어들었는지 평가해야한다 | . | 이 때, 매칭된 dataset에 대해 잘못된 방식으로서 치료군과 대조군의 각 baseline characteristics의 요약통계량 계산 후 | 2군의 비교이므로 p-value로 계산하면 될까? 2군 비교시 p-value가 익숙해져 있어서 매칭데이터도 p-value로 비교하는 경우가 많다 -&gt; 좋은 방법이 아니다. | . | . | . | 매칭된 dataset을 p-value로 비교하면 왜 잘못된 방식일까? p-value는 sample size에 영향을 받지만 | matching의 경우, 대부분 매칭되지 않는 환자들이 제외되어 original sample size보다 줄어들게 되고 | power가 줄어든다 -&gt; 두 군간의 차이가 있었더라도 -&gt; p-value는 높게 나올 수 있다. | p-value가 높게 나온 것이, 줄어든 sample size 때문인데, 마치 matching이 잘되어서 p-value가 나온 것처럼 잘못된 impression을 줄 수 있다. | . | p-value로 비교한다는 것은 2군의 sample에 대해 2개의 큰 모집단이 있다는 것을 가정한 것이다. | 2개 모집단을 비교할 수 없어서 random sample을 뽑아, 2개 모집단을 추론하는 것이 p-value이다. | . | 그러나 우리는 matching 했다 2군 뒤의 2개 모집단에 대한 관심은 잃은 상태다. | 2개 모집단은 애초에 baseline characteristic이 다르기 때문에, confounding으로 인한 치료효과 분석이 어렵다고 생각해서 인위적으로 matching을 하는 것 인위적으로 baseline characteristic를 맞춘, 인위적은 dataset을 보는 것 | 더이상 sample로 모집단을 추론(p-value)하는 것이 아니라 sample 자체에 관심을 가지게 되는 것이므로 p-value로 2군 비교는 적합하지 않다. | 개념적으로 아예 맞지 않는 것 | . | . | . | 그렇다면 옳은 매칭후 평가 방법은? matching후 평가방법은 여러가지가 있다. 그 중에서 사용하기 편하고 이해하기 쉬운 방법인 Standardized mean difference를 통해 평가해보자 | . | . Standardized mean difference (SMD) . 연속형 변수의 SMD . 복잡해보이지만, 치료군의 평균(X_bar_tx)와 대조군의 평균(X_bar_tx)의 차이에서 | 치료군과 대조군의 표준편차를 잘 합친 것(pooled SD)으로 나누어, 데이터의 변동을 고려했을 때의 평균 차이 . . | . | 이분형 변수의 SMD 2 군의 비율 차이를 적당한 표준편차 값으로 나눈 것으로 생각하자 | . | 두 군간 평균의 차이가 pooled SD의 몇배인가 | SMD &lt; 0.1~0.2 이면 작은 차이로 간주 | 매칭 이후 매칭변수들(PS model에 사용된 설명변수들)에 대해 SMD를 계산하고 대부분 0.1미만이면 좋다 | 몇개는 0.1을 넘어 모두 0.2 미만이면 balance가 잘 맞는 것으로 평가 －　이정도면，매칭된　dataset에서　치료군과　대조군　사이에　baseline characteristic차이가　무시할만한　차이이다 | . | . &#47588;&#52845; &#54980; &#48516;&#49437; . 분석을 하려면, 우리가 애초에 궁금한 치료효과에 대해 평가해야한다. . 치료여부-질병여부와의 association이 얼마나 강한가?를 평가하는 measure of association를 이용해야한다. | 여러가지 방법이 있었다. OR말고 RD(risk diffrence) = attributable risk라던가 relative risk를 계산할 수 있지만 | OR이 가장 계산이 쉽고, 편리하기 때문에 대표로 사용해보자. | . | . | 매칭된 치료군과 대조군에서 결과변수의 차이 . 이분형 결과변수의 경우: OR과 OR의 95% 신뢰구간, OR이 1인지 아닌지에 대한 p-value 정도를 사용한다 | . | 보통의 방법을 사용하면 되는가? . 매칭된 dataset은, 매칭되면서 짝끼리 서로 비슷하게 맞춰놓은 상태기 때문에, 환자가 서로 독립이라고 할 순 없다. 그래서 대부분의 통계방법은 서로 독립이라고 가정을 하는데, 일반적인 통계방법으로 분석하면 안된다. -&gt; 매칭된 짝끼리는 독립이 아니라는 점을 고려해서 분석하는 것이 좋다는 것이 다수 의견이다. | . | 매칭된 짝은 서로 독립이 아니라는 점을 고려하여 분석한다 . 이분형 결과변수의 경우: McNemar’s test : p-value를 계산해주지만, OR자체를 계산해주지 않는다. OR 계산하려면 logistic regression을 해야한다. | . | conditional logistic regression case-control study에서 사용했던 것. 매칭된 짝끼리 비슷한 점 = 독립이 아니라는 점을 이용할 수 있다. | . | logistic regression with correlation structure (GEE) 일반 logistic regression을 하되, 매칭된 짝끼리의 correlation을 허용하면서 모델을 fit하는 것 | GEE model이라고 하는데, 사실은 계산방법이다. | GEE 계산을 통한 로지스틱 회귀분석을 통해 OR을 계산하고, 신뢰구간을 구하면 된다. | . | . | . | 소수의견 : RCT에서 얻어진 데이터처럼 만들었기 때문에, RCT처럼 독립성을 가정하고 분석해야 한다는 관점도 존재한다 . | . conditional logistic regression이나 logistic regression with correlation structure (GEE)을 수행할 때 결과 변수는 질병여부 | 설명 변수는 치료군vs대조군 여부가 되는데 | 애초에 confounder라고 생각했던 공변량들은 설명변수로 포함할 필요가 없게 된다. 왜냐면, PS matching을 통해 공변량 효과를 이미 제거된 상태가 되었기 때문이다. | 즉, multivarable이 아니라 univariable의 로지스틱 회분석해서 OR(오즈 레이시오)를 계산하면 된다는 것이다. | . | . | 그럼에도 불구하고, 공변량으로 포함시켜 계산하는 방법도 존재하는데 doubly robust하다라는 이름을 얻게 되었다. PS model이 잘못됬거나 아니면, 최종 모델로 생각한 회귀분석이 잘못되었어도, OR 추정치가 unbiased하게 되는 좋은 성질을 갖게 된다고 한다. | 하지만, 매칭 분석은 univariable model만 쓰면 된다. | . | . R &#49892;&#49845; . MatchIt 패키지를 이용한 PS matching matchit() 함수 이용 | Austin이 추천한 nearest neighbor matching with caliper = 0.2*SD of logit of PS 을 구현하는 방법 실습 | . | tableone 패키지를 이용한 SMD 계산 CreateTableOne() 함수 이용 | 매칭후 balance 계산을 위해 SMD를 계산. | . | geepack 패키지를 이용한 OR 추정 geeglm() 함수 이용 | 매칭된 데이터셋에서 GEE방법으로 OR를 계산해주는 패키지 | . | . matchit() from MatchIt . PS matching이외에 여러가지 매칭이 가능한 패키지이나 필요한 것만 설정하기 matchit(formula, data, method, replace, ratio, distance, link, caliper, std.caliper, m.order) . | . formula : 매칭하려는 그룹 (치료군/대조군)~ 매칭변수1+매칭변수2+...+매칭변수d 치료군이냐 대조군이냐 그룹변수 ~ confounder라고 의심해서 PS model에 넣고 싶은 변수들을 더하기로 연결 | . | data : 데이터셋 이름 | method : 매칭방법. “nearest”라고 입력하면 nearest neighbor matching을 수행한다 | replace : 재복원여부. 디폴트는 FALSE (비복원표집, 한번 매칭된 환자는 다시 매칭되지 않는다) | without replacement = 한번 매칭된 환자는 다시 매칭하지 않는 것이 default | . | Ratio : 매칭비율 (치료군 1명당 매칭되는 대조군 환자 수). 디폴트는 1. 치료군 1명당 매칭될 대조군의 수 | . | . distance=“glm” matching 중에 Propensity Score matching을 이용하는 옵션 | . | link=“logit” caliper의 기준을 정하는데, PS의 logit를 거리측도로 사용하여 매칭을 수행한다 | . | caliper=0.2 caliper 기준에 곱해줄 값을 입력 | . | std.caliper = TRUE caliper 의 표준편차를 기준으로 매칭 | 위 4가지를 다 설정해야, austin의 PS login의 SD의 0.2를 caliper로 사용한 매칭을 실시하게 된다 | . | m.order=“random”: 매칭을 수행하는 순서 입력하지 않으면 거리측도 값 = PS값이 큰 개체부터 순서대로 매칭한다. 그러나 PS score 큰 수대로 매칭해봐야 장점이 없다. 랜덤으로 매칭하도록 선호된다. | . | “random”으로 입력하면 랜덤한 순서로 매칭하는데, 이 경우 matchit() 함수 실행 직전에 set.seed()함수로 seed number를 정해주어야 같은 결과를 재생산할 수 있다. (그렇지 않으면 matchit() 함수 실행 때마다 다른 매칭결과가 나온다 | . | . CreateTableOne() from tableone . CreateTableOne(vars, data, strata) . 임상과학 논문의 Table 1에 해당하는 표를 편리하게 만들 수 있는 함수 vars : 표에 들어갈 변수 이름의 벡터 | data : 데이터셋 이름 | strata : 비교할 그룹을 나타내는 변수 스트레이라를 입력해주면, 그룹을 나눠 그룹별 요약통계량과 그룹별 p-value가 나온다. | . | . | CreateTableOne()으로 만든 객체를 print() 안에 넣으면 표가 인쇄된다 smd : TRUE로 입력하면 SMD를 계산해준다 | test : FALSE로 입력하면 p-value를 인쇄하지 않는다 | . | . geeglm() from geepack . geeglm(formula, id, family, corstr, std.err, data) . GLM(generalized linear model)을 GEE(generalized estimating equation) 방법으로 correlation structure를 주면서 fit하는 함수 | formula : 결과변수~설명변수 fitting하고 싶은 model 입력 | . | id : cluster를 나타내는 변수 . PS maching의 경우 같이 매칭된 자료의 경우 matching id를 넣어주면 된다. | 내가 생각하기에 correlate되어있는 클러스트를 나타내는 변수를 넣는다. | . | family : GLM의 종류. 로지스틱 회귀분석의 경우 “binomial” . 로지스틱 회귀를 설정 옵션 | . | corstr : cluster 내에서의 correlation structure. 어떤 correlation structure를 줄 것이냐 | “exchangeable”: cluster내에서 모든 개체 쌍의 correlation이 동일할 경우 매칭된 환자(치료군 1명에 대조군 1~4)는 같은 cluster내에 있으며, 매칭 환자들 중에 아무 2명씩 짝을 지어도 항상 correlation같다는 옵션 | 가장 무난한 옵션 | . | “independence”: cluster내에서 모든 개체가 서로 독립일 경우 매칭된 cluster환자들 내(치료군+매칭된 대조군(들))이 서로 독립이라고 가정하고 싶을 때 쓰는 옵션이나 | 매칭되었으니까 independent할텐데, 왜 쓸까? 어떤 복잡한 통계적 방법에 의해 이 방법이 더 타당하다고 주장/연구결과가 있어서 옵션으로 언급만 | . | . | . | std.err : standard error 계산방식. 디폴트 “san.se”는 robust estimator방식으로 계산하게 되는데, 일반적인 방식이 아니라 데이터가 매칭=독립이 아니다라고 가정하여, 더 보수적으로 계산한 estimator다 | 95% 신뢰구간과 p-value 계산시 영향을 끼친다 | robust estimator를 써야 더 보수적인 결과가 나오며 default옵션이다. | . | data : 데이터셋 이름 | . &#53076;&#46300; &#49892;&#49845; . # install.packages(&quot;MatchIt&quot;) -&gt; 설치 안되서 터미널에서 아래와 같이 # conda install -c conda-forge r-matchit # - ocnda로 검색해서 안되서, stackoverflow에서 얻은 설치주소 # - https://stackoverflow.com/questions/71041174/installing-r-package-matchit-in-anaconda-environment . library(MatchIt) . # - matchIt 다른 곳에서 설치 -&gt; R을 4로 업데이트 -&gt; 추가적인 것 수동 업데이트 . library(dplyr) library(tableone) . 다음의 패키지를 부착합니다: &#39;dplyr&#39; The following objects are masked from &#39;package:stats&#39;: filter, lag The following objects are masked from &#39;package:base&#39;: intersect, setdiff, setequal, union . data(&quot;lalonde&quot;) . head(lalonde) # treat age educ race married nodegree re74 re75 re78 # 치료여부 / / 교육 / 결혼여부 / nodgree 고등학교졸업/ 년도별 연소득 # 의료데이터는 아니나,, 가정하고 한다. . A data.frame: 6 × 9 treatageeducracemarriednodegreere74re75re78 . &lt;int&gt;&lt;int&gt;&lt;int&gt;&lt;fct&gt;&lt;int&gt;&lt;int&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . NSW11 | 37 | 11 | black | 1 | 1 | 0 | 0 | 9930.0460 | . NSW21 | 22 | 9 | hispan | 0 | 1 | 0 | 0 | 3595.8940 | . NSW31 | 30 | 12 | black | 0 | 0 | 0 | 0 | 24909.4500 | . NSW41 | 27 | 11 | black | 0 | 1 | 0 | 0 | 7506.1460 | . NSW51 | 33 | 8 | black | 0 | 1 | 0 | 0 | 289.7899 | . NSW61 | 22 | 9 | black | 0 | 1 | 0 | 0 | 4056.4940 | . &#51060;&#48516;&#54805; &#44208;&#44284;&#48320;&#49688; &#47564;&#46308;&#50612;&#51452;&#44592; . re78이 5000을 넘는지 안넘는지로 | . dat1 &lt;- lalonde %&gt;% # outcome 변수이름을 간단히 y로 둔다. # re78이 5000달러를 넘으면 [질병여부 발생여부]로 임시로 가상으로 만든다. mutate(y=ifelse(re78 &gt; 5000, 1, 0)) . head(dat1) . A data.frame: 6 × 10 treatageeducracemarriednodegreere74re75re78y . &lt;int&gt;&lt;int&gt;&lt;int&gt;&lt;fct&gt;&lt;int&gt;&lt;int&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . NSW11 | 37 | 11 | black | 1 | 1 | 0 | 0 | 9930.0460 | 1 | . NSW21 | 22 | 9 | hispan | 0 | 1 | 0 | 0 | 3595.8940 | 0 | . NSW31 | 30 | 12 | black | 0 | 0 | 0 | 0 | 24909.4500 | 1 | . NSW41 | 27 | 11 | black | 0 | 1 | 0 | 0 | 7506.1460 | 1 | . NSW51 | 33 | 8 | black | 0 | 1 | 0 | 0 | 289.7899 | 0 | . NSW61 | 22 | 9 | black | 0 | 1 | 0 | 0 | 4056.4940 | 0 | . dat1 &lt;- lalonde %&gt;% mutate(y=ifelse(re78 &gt; 5000, 1, 0)) . &#50672;&#49549;&#54805; -&gt; &#48276;&#51452;&#54805;&#48320;&#49688;&#47196; &#54620;&#44732;&#48264;&#50640; &#52376;&#47532;&#54616;&#44592; by mutate_at . # - y도 0 or 1로 바꿔줬는데, 연속형변수(숫자)처럼 되어있을 것이다. # - 연속형 변수는 min/max가 나와있다. # - 치료여부(treat) 와 질병여부(y)가 모두 연속형 변수로 되어있다. # 그외 summary(dat1) . treat age educ race married Min. :0.0000 Min. :16.00 Min. : 0.00 black :243 Min. :0.0000 1st Qu.:0.0000 1st Qu.:20.00 1st Qu.: 9.00 hispan: 72 1st Qu.:0.0000 Median :0.0000 Median :25.00 Median :11.00 white :299 Median :0.0000 Mean :0.3013 Mean :27.36 Mean :10.27 Mean :0.4153 3rd Qu.:1.0000 3rd Qu.:32.00 3rd Qu.:12.00 3rd Qu.:1.0000 Max. :1.0000 Max. :55.00 Max. :18.00 Max. :1.0000 nodegree re74 re75 re78 Min. :0.0000 Min. : 0 Min. : 0.0 Min. : 0.0 1st Qu.:0.0000 1st Qu.: 0 1st Qu.: 0.0 1st Qu.: 238.3 Median :1.0000 Median : 1042 Median : 601.5 Median : 4759.0 Mean :0.6303 Mean : 4558 Mean : 2184.9 Mean : 6792.8 3rd Qu.:1.0000 3rd Qu.: 7888 3rd Qu.: 3249.0 3rd Qu.:10893.6 Max. :1.0000 Max. :35040 Max. :25142.2 Max. :60307.9 y Min. :0.0000 1st Qu.:0.0000 Median :0.0000 Mean :0.4853 3rd Qu.:1.0000 Max. :1.0000 . dat1 &lt;- lalonde %&gt;% mutate(y=ifelse(re78 &gt; 5000, 1, 0)) %&gt;% # vars(변수들), list(~하고싶은작업(.)) . 자리에 변수들이 들어간다. mutate_at(vars(treat, married, nodegree, y), list(~as.factor(.))) . summary(dat1) . treat age educ race married nodegree 0:429 Min. :16.00 Min. : 0.00 black :243 0:359 0:227 1:185 1st Qu.:20.00 1st Qu.: 9.00 hispan: 72 1:255 1:387 Median :25.00 Median :11.00 white :299 Mean :27.36 Mean :10.27 3rd Qu.:32.00 3rd Qu.:12.00 Max. :55.00 Max. :18.00 re74 re75 re78 y Min. : 0 Min. : 0.0 Min. : 0.0 0:316 1st Qu.: 0 1st Qu.: 0.0 1st Qu.: 238.3 1:298 Median : 1042 Median : 601.5 Median : 4759.0 Mean : 4558 Mean : 2184.9 Mean : 6792.8 3rd Qu.: 7888 3rd Qu.: 3249.0 3rd Qu.:10893.6 Max. :35040 Max. :25142.2 Max. :60307.9 . &#47588;&#52845;&#51204; [&#52824;&#47308;&#44400;vs&#45824;&#51312;&#44400;(treat)&#48324;] confounder&#51032;&#49900;&#48320;&#49688;&#46308;&#51032; balance(2&#44400;&#44036;&#51032; &#52264;&#51060; by p)&#54869;&#51064; by tableone . 4가지 변수를 confounder라고 가정하고 만들어준다. | 치료군 vs 대조군 = 치료여부를 의미하는 treat별로 봐야한다. | CreateTableOne()이란 치료군vs대조군변수를 strata로 넣어, 표1을 생성하는 메서드다. | . &#51068;&#45800;, &#52824;&#47308;&#50668;&#48512;&#48324; &#54364;1&#51012; &#47564;&#46308;&#50612;&#49436; confounder &#50976;&#51032;&#48120;&#54620; &#52264;&#51060;&#48372;&#44592; . # install.packages(&quot;haven&quot;) # install.packages(&quot;forcats&quot;) # install.packages(&quot;hms&quot;) . tobj &lt;- CreateTableOne(vars=c(&quot;age&quot;, &quot;educ&quot;, &quot;married&quot;, &quot;nodegree&quot;), data = dat1) tobj . Overall n 614 age (mean (SD)) 27.36 (9.88) educ (mean (SD)) 10.27 (2.63) married = 1 (%) 255 (41.5) nodegree = 1 (%) 387 (63.0) . # -&gt; treat 변수별로 보도록 strata를 treat로 지정해준다. tobj &lt;- CreateTableOne(vars=c(&quot;age&quot;, &quot;educ&quot;, &quot;married&quot;, &quot;nodegree&quot;), data = dat1, strata = &quot;treat&quot;) tobj . Stratified by treat 0 1 p test n 429 185 age (mean (SD)) 28.03 (10.79) 25.82 (7.16) 0.011 educ (mean (SD)) 10.24 (2.86) 10.35 (2.01) 0.633 married = 1 (%) 220 (51.3) 35 (18.9) &lt;0.001 nodegree = 1 (%) 256 (59.7) 131 (70.8) 0.011 . tobj &lt;- CreateTableOne(vars=c(&quot;age&quot;, &quot;educ&quot;, &quot;married&quot;, &quot;nodegree&quot;), data = dat1, strata = &quot;treat&quot;) print(tobj) # treat가 0 , 즉 대조군에 대한 4가지 confounder변수의 요약통계량이 나온다. # 치료군에 대해서도 나온다. # 치료군 185, 대조군 429명의 정보도 나온다. # p-value를 보고, 2군간의 confounder( baseline characteristic)의 차이를 표1을 만들어서 본다. # -&gt; &quot;p가 낮으면 두 군간의 유의미한 차이&quot;가 있다는 뜻이다. # -&gt;age married nodegree 는 2군간에 유의미하게 차이가 난다. . Stratified by treat 0 1 p test n 429 185 age (mean (SD)) 28.03 (10.79) 25.82 (7.16) 0.011 educ (mean (SD)) 10.24 (2.86) 10.35 (2.01) 0.633 married = 1 (%) 220 (51.3) 35 (18.9) &lt;0.001 nodegree = 1 (%) 256 (59.7) 131 (70.8) 0.011 . smd&#47484; &#51060;&#50857;&#54616;&#50668; balance&#54217;&#44032; with print( tobj, smd =T) . smd는 매칭 후에 평가한다고 했는데, 매칭전 smd를 구해보면, 차후 얼마나 줄었는지 알 수 있다. | . tobj &lt;- CreateTableOne(vars=c(&quot;age&quot;, &quot;educ&quot;, &quot;married&quot;, &quot;nodegree&quot;), data = dat1, strata = &quot;treat&quot;) print(tobj, smd = T) # 0.2를 넘는 것(married)은 두 군간에 상당히 다르다는 것을 의미한다. . Stratified by treat 0 1 p test SMD n 429 185 age (mean (SD)) 28.03 (10.79) 25.82 (7.16) 0.011 0.242 educ (mean (SD)) 10.24 (2.86) 10.35 (2.01) 0.633 0.045 married = 1 (%) 220 (51.3) 35 (18.9) &lt;0.001 0.721 nodegree = 1 (%) 256 (59.7) 131 (70.8) 0.011 0.235 . matching&#51032; &#47785;&#51201;: 2&#44400;&#44036;&#51032; confounder&#51032; p&#52264;&#51060; -&gt; smd &#52264;&#51060;&#47484; 0.2 &#48120;&#47564;&#51004;&#47196; &#51460;&#51060;&#45716; &#44163; . &#47588;&#52845; by matching . 매칭 결과는 바로 쓰는 것이 아니라 mobj라는 객체에 저장해놓고 쓰는 것이 좋다. | 목적은 confounder들의 차이를 smd 0.2미만으로 줄여서, 2군간의 차이를 줄여놓는 것 | . mobj &lt;- matchit(treat ~ age+educ+married+nodegree , # formula : 치료여부 ~ confoiunder들 data = dat1, # dataset method = &quot;nearest&quot;, # 매칭 방법: austin의 nearest ~ distance = &quot;glm&quot;, # 매칭 중 PS matching link = &quot;logit&quot;, replace = F, # 매칭된 환자 비복원 capliper = 0.2, std.caliper = T, # caliper 지정 m.order = &quot;random&quot;, #매칭순서 -&gt; default방법 안좋음. random으로 지정 ) # 뭐가 들었는지 일단 summary 안에 넣어본다. summary(mobj) # 썩 보기 좋은게 아님. # 맨 마지막만 보고, 몇 쌍이 매칭 되어있는지 확인한다. # Sample Sizes: # Control Treated # All 429 185 # Matched 185 185 # Unmatched 244 0 # Discarded 0 0 # -&gt; 185쌍이 매칭되었다. . Call: matchit(formula = treat ~ age + educ + married + nodegree, data = dat1, method = &#34;nearest&#34;, distance = &#34;glm&#34;, link = &#34;logit&#34;, replace = F, m.order = &#34;random&#34;, std.caliper = T, capliper = 0.2) Summary of Balance for All Data: Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean distance 0.3772 0.2686 0.8386 0.7471 0.2080 age 25.8162 28.0303 -0.3094 0.4400 0.0813 educ 10.3459 10.2354 0.0550 0.4959 0.0347 married0 0.8108 0.4872 0.8263 . 0.3236 married1 0.1892 0.5128 -0.8263 . 0.3236 nodegree0 0.2919 0.4033 -0.2450 . 0.1114 nodegree1 0.7081 0.5967 0.2450 . 0.1114 eCDF Max distance 0.3602 age 0.1577 educ 0.1114 married0 0.3236 married1 0.3236 nodegree0 0.1114 nodegree1 0.1114 Summary of Balance for Matched Data: Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean distance 0.3772 0.3745 0.0210 1.0358 0.0085 age 25.8162 25.1730 0.0899 0.5492 0.0688 educ 10.3459 10.6054 -0.1290 0.7558 0.0171 married0 0.8108 0.8108 0.0000 . 0.0000 married1 0.1892 0.1892 0.0000 . 0.0000 nodegree0 0.2919 0.3297 -0.0832 . 0.0378 nodegree1 0.7081 0.6703 0.0832 . 0.0378 eCDF Max Std. Pair Dist. distance 0.0865 0.0378 age 0.2378 0.8348 educ 0.0541 0.6130 married0 0.0000 0.0000 married1 0.0000 0.0000 nodegree0 0.0378 0.2735 nodegree1 0.0378 0.2735 Percent Balance Improvement: Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max distance 97.5 87.9 95.9 76.0 age 70.9 27.0 15.4 -50.8 educ -134.8 60.1 50.8 51.5 married0 100.0 . 100.0 100.0 married1 100.0 . 100.0 100.0 nodegree0 66.0 . 66.0 66.0 nodegree1 66.0 . 66.0 66.0 Sample Sizes: Control Treated All 429 185 Matched 185 185 Unmatched 244 0 Discarded 0 0 . &#47588;&#52845;&#46108; &#45936;&#51060;&#53552;&#47564; &#48977;&#50500;&#45236;&#44592; from mobj by match.data . m.data &lt;- match.data(mobj) summary(m.data) # ps를 의미하는 distance가 보인다. # subclass -&gt; 짝 지어진 번호. 1인 환자 -&gt; 다른데 또 1인 매칭환자가 있다 # - 즉, matching Id를 의미한다. . treat age educ race married nodegree 0:185 Min. :16.00 Min. : 3.00 black :207 0:300 0:115 1:185 1st Qu.:19.00 1st Qu.: 9.00 hispan: 41 1: 70 1:255 Median :23.00 Median :11.00 white :122 Mean :25.49 Mean :10.48 3rd Qu.:29.00 3rd Qu.:12.00 Max. :55.00 Max. :18.00 re74 re75 re78 y distance Min. : 0 Min. : 0.0 Min. : 0.0 0:196 Min. :0.08913 1st Qu.: 0 1st Qu.: 0.0 1st Qu.: 260.9 1:174 1st Qu.:0.30744 Median : 0 Median : 310.6 Median : 4300.7 Median :0.41360 Mean : 2979 Mean : 1779.0 Mean : 6340.2 Mean :0.37586 3rd Qu.: 3536 3rd Qu.: 2557.9 3rd Qu.: 9588.5 3rd Qu.:0.47373 Max. :35040 Max. :25142.2 Max. :60307.9 Max. :0.58644 weights subclass Min. :1 1 : 2 1st Qu.:1 2 : 2 Median :1 3 : 2 Mean :1 4 : 2 3rd Qu.:1 5 : 2 Max. :1 6 : 2 (Other):358 . &#47588;&#52845;&#45936;&#51060;&#53552; balance(&#52824;&#47308;&#50668;&#48512;&#48324; confounder&#51032; p/SMD &#52264;&#51060;) &#54217;&#44032; by CreateOneTable . mobj &lt;- CreateTableOne(vars=c(&quot;age&quot;, &quot;educ&quot;, &quot;married&quot;, &quot;nodegree&quot;), data = m.data, strata = &quot;treat&quot;) print(mobj, smd = T) . Stratified by treat 0 1 p test SMD n 185 185 age (mean (SD)) 25.17 (9.66) 25.82 (7.16) 0.467 0.076 educ (mean (SD)) 10.61 (2.31) 10.35 (2.01) 0.250 0.120 married = 1 (%) 35 (18.9) 35 (18.9) 1.000 &lt;0.001 nodegree = 1 (%) 124 (67.0) 131 (70.8) 0.500 0.082 . # print( , test = F) print(mobj, smd = T, test = F) # 매칭후에는 smd가 0.2보다 다 작다 . Stratified by treat 0 1 SMD n 185 185 age (mean (SD)) 25.17 (9.66) 25.82 (7.16) 0.076 educ (mean (SD)) 10.61 (2.31) 10.35 (2.01) 0.120 married = 1 (%) 35 (18.9) 35 (18.9) &lt;0.001 nodegree = 1 (%) 124 (67.0) 131 (70.8) 0.082 . random -&gt; set.seed() . 원래는.. seed를 안정해주면, 매칭된 환자수가 바뀐다. | 결과 자체는 문제가 없으나 재현성이 없어져버린다. | . mobj &lt;- matchit(treat ~ age+educ+married+nodegree , # formula : 치료여부 ~ confoiunder들 data = dat1, # dataset method = &quot;nearest&quot;, # 매칭 방법: austin의 nearest ~ distance = &quot;glm&quot;, # 매칭 중 PS matching link = &quot;logit&quot;, replace = F, # 매칭된 환자 비복원 capliper = 0.2, std.caliper = T, # caliper 지정 m.order= &quot;random&quot;,#매칭순서 -&gt; default방법 안좋음. random으로 지정 ) m.data &lt;- match.data(mobj) tobj &lt;- CreateTableOne(vars=c(&quot;age&quot;, &quot;educ&quot;, &quot;married&quot;, &quot;nodegree&quot;), data = m.data, strata = &quot;treat&quot;) print(tobj, smd = T, test=F) # 원래는 seed를 정해주지 않으면, 매칭 n수가 바귄다. # -&gt; 여기서는 m.order = random을 바꾸면 SMD가 바껴서 적용은 되는 것 같다. # -&gt; 혹은 seed가 자동적용되었을 가능성이 있다. . Stratified by treat 0 1 SMD n 185 185 age (mean (SD)) 25.05 (9.51) 25.82 (7.16) 0.091 educ (mean (SD)) 10.64 (2.30) 10.35 (2.01) 0.138 married = 1 (%) 35 (18.9) 35 (18.9) &lt;0.001 nodegree = 1 (%) 123 (66.5) 131 (70.8) 0.093 . set.seed(2022) mobj &lt;- matchit(treat ~ age+educ+married+nodegree , # formula : 치료여부 ~ confoiunder들 data = dat1, # dataset method = &quot;nearest&quot;, # 매칭 방법: austin의 nearest ~ distance = &quot;glm&quot;, # 매칭 중 PS matching link = &quot;logit&quot;, replace = F, # 매칭된 환자 비복원 capliper = 0.2, std.caliper = T, # caliper 지정 m.order= &quot;random&quot;,#매칭순서 -&gt; default방법 안좋음. random으로 지정 ) m.data &lt;- match.data(mobj) tobj &lt;- CreateTableOne(vars=c(&quot;age&quot;, &quot;educ&quot;, &quot;married&quot;, &quot;nodegree&quot;), data = m.data, strata = &quot;treat&quot;) print(tobj, smd = T, test=F) # SMD가 다 0.2 이하라서 2군간의 confounder차이가 사라지도록 매칭된 데이터가 완성되었다. . Stratified by treat 0 1 SMD n 185 185 age (mean (SD)) 25.12 (9.68) 25.82 (7.16) 0.081 educ (mean (SD)) 10.61 (2.31) 10.35 (2.01) 0.120 married = 1 (%) 35 (18.9) 35 (18.9) &lt;0.001 nodegree = 1 (%) 124 (67.0) 131 (70.8) 0.082 . 1:2 &#47588;&#52845; by ratio=2 . set.seed(2022) mobj &lt;- matchit(treat ~ age+educ+married+nodegree , # formula : 치료여부 ~ confoiunder들 data = dat1, # dataset method = &quot;nearest&quot;, # 매칭 방법: austin의 nearest ~ distance = &quot;glm&quot;, # 매칭 중 PS matching link = &quot;logit&quot;, replace = F, # 매칭된 환자 비복원 capliper = 0.2, std.caliper = T, # caliper 지정 m.order= &quot;random&quot;,#매칭순서 -&gt; default방법 안좋음. random으로 지정 ratio=2, # 치료군(1) 한명당 대조군 2명을 붙인다. ) m.data &lt;- match.data(mobj) tobj &lt;- CreateTableOne(vars=c(&quot;age&quot;, &quot;educ&quot;, &quot;married&quot;, &quot;nodegree&quot;), data = m.data, strata = &quot;treat&quot;) print(tobj, smd = T, test=F) # 만약, 185명의 2배가 아니라 더 적게 매칭되었다면? # -&gt; caliper가 있어서, PS가 비슷한 환자를 찾지 못해서 1명만 매칭된 경우가 포함되어있다. . Stratified by treat 0 1 SMD n 370 185 age (mean (SD)) 27.88 (11.19) 25.82 (7.16) 0.220 educ (mean (SD)) 10.35 (2.56) 10.35 (2.01) 0.002 married = 1 (%) 161 (43.5) 35 (18.9) 0.551 nodegree = 1 (%) 240 (64.9) 131 (70.8) 0.128 . &#47588;&#52845;&#46108; &#45936;&#51060;&#53552;&#50640;&#49436; &#52824;&#47308;&#54952;&#44284;(y) &#54217;&#44032; by GEE . GEE를 통한 회귀분석 : geepack | 회귀계수를 OR로 바꿔주는 패키지 : broom | . . . . library(geepack) library(broom) . 0,1&#48276;&#51452;&#54805;&#51012; -&gt; 0,1 &#50672;&#49549;&#54805;&#51004;&#47196; &#47564;&#46300;&#45716; sense ( bool -&gt; as.double ) . # -&gt; 결과변수를 다시 연속형 변수로 매핑해줘야한다. head(m.data$y == 1) . &lt;ol class=list-inline&gt;TRUE | FALSE | TRUE | TRUE | FALSE | FALSE | &lt;/ol&gt; head(as.double(m.data$y == 1)) . &lt;ol class=list-inline&gt;1 | 0 | 1 | 1 | 0 | 0 | &lt;/ol&gt; &#52572;&#51333; &#54924;&#44480;&#48516;&#49437;&#50640;&#49436;&#45716; &#44208;&#44284;&#48320;&#49688;(&#51656;&#48337;&#50668;&#48512;, &#50672;&#49549;&#54805;) ~ &#49444;&#47749;&#48320;&#49688;(&#52824;&#47308;&#50668;&#48512;), id=&#47588;&#52845;id&#48320;&#49688;(subclass) 2+1 &#44060;&#51032; &#48320;&#49688;&#47564; . match된 데이터 = 이미 2군간(treat) confounder 제거된, RCT 데이터 같은 데이터 효과를 제거한 변수들 4개를 넣은 doubly robust 방법을 쓸 수 도 있지만, 여기선 simple하게 univarable model을 쓴다. | . | . obj &lt;- geeglm(as.double(y == 1) ~ treat, data = m.data, # id = subclass, # subclass칼럼에 정의된 각 매칭id를 제시하여 correlation이 있다는 것을 알려준다. family = &quot;binomial&quot;, # 로지스틱 회귀분석 명시 corstr = &quot;exchangeable&quot;, # correlation structrue 암기... std.err = &quot;san.se&quot;, # default라 안써도 되는 에러 계산시, robust estimator 사용 ) # 회귀분석 결과는 기본적으로 summary에 넣으면 된다. summary(obj) # Coefficients: # Estimate Std.err Wald Pr(&gt;|W|) # (Intercept) -0.01093 0.10426 0.011 0.917 # treat1 -0.17337 0.18076 0.920 0.337 # treat1에 있는 Estimate -&gt; 회귀계수 -0.17337 과 p-value 0.337 # -&gt; 강의랑 달라서 아래 스샷을 바탕으로... . Call: geeglm(formula = as.double(y == 1) ~ treat, family = &#34;binomial&#34;, data = m.data, id = subclass, corstr = &#34;exchangeable&#34;, std.err = &#34;san.se&#34;) Coefficients: Estimate Std.err Wald Pr(&gt;|W|) (Intercept) -0.0109 0.1043 0.01 0.92 treat1 -0.1734 0.1808 0.92 0.34 Correlation structure = exchangeable Estimated Scale Parameters: Estimate Std.err (Intercept) 1 0.0047 Link = identity Estimated Correlation Parameters: Estimate Std.err alpha 1.01 0.104 Number of clusters: 553 Maximum cluster size: 2 . . &#54924;&#44480;&#48516;&#49437; &#44208;&#44284;obj&#47196; OR&#47484; &#44396;&#54616;&#44592; by broom&#54056;&#53412;&#51648;&#51032; tidy() . # treat1의 p-value가 0.05보다 크다 == treat1이라는 변수는 회귀변수 결과변수에 별로 안중요하다?! # -&gt; treat여부가 질병발생(outcome발생) 비율에 유의미한 영향을 주지 않는다?! # 주의) 여기서의 p-value는 회귀계수 자체의 p-value이지, OR이 아니다. # -&gt; 우리가 해석할 것은 treat의 회귀변수의 p-value가 아니라 OR를 구해야한다. # broom패키지의 tidy()함수로 회귀분석결과 -&gt; OR를 바로 구할 수 있다. tidy(obj, exponentiate = T, conf.int = T) . A tibble: 2 × 7 termestimatestd.errorstatisticp.valueconf.lowconf.high . &lt;chr&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt;&lt;dbl&gt; . (Intercept) | 0.989 | 0.104 | 0.011 | 0.917 | 0.806 | 1.21 | . treat1 | 0.841 | 0.181 | 0.920 | 0.337 | 0.590 | 1.20 | . . # conf.low ~ conf.high는 OR의 95%신뢰구간 하한~상한이다. . &#51221;&#47532;&#54616;&#44592; . Propensity score analysis (PSA)가 어떻게 confounder들을 없앤 데이터를 만드는지 알아봤다. | . Propensity score analysis (PSA)는 confounding이 존재하는 관찰연구의 데이터를 RCT의 데이터처럼 confounding이 없도록 가공하여 분석하는 방법이다. | Propensity score (PS)는 치료군에 속할 확률을 의미한다. | PS는 보통 로지스틱 회귀분석으로 추정하며, PS 모델에는 outcome에 영향을 끼칠 것으로 생각되는 변수를 모두 넣는 것이 좋다. 단, 치료군/대조군 결정이후에 관측된 변수는 넣으면 안된다. | PS 추정 이후 분석 방법에는 matching, stratification, weighting, covariate adjustment 등이 있다. | PS matching 후 치료군과 대조군의 balance는 standardized mean difference (SMD)로 평가할 수 있다. | PS matching된 데이터는 matching을 고려하여 분석한다. | . &#50672;&#49845;&#47928;&#51228; . 01 &#45796;&#51020; &#51473; Propensity score analysis&#50640; &#45824;&#54620; &#49444;&#47749;&#51004;&#47196; &#53952;&#47536; &#44163;&#51008;? . 관찰연구 자료의 confounding을 없애는 방법 중 하나이다. . | Propensity score를 추정하는 모델은 설명변수 하나당 샘플사이즈 15가 필요하다. . | 최종결과변수(환자의 outcome)에 영향을 끼치는 변수들은 PS 추정 모델에 넣는 것이 좋다. . | 치료군/대조군이 결정된 이후에 관측된 변수들은 PS 추정 모델에 넣지 않는다. . | 정답 : 2 | 해설 : PS 추정 모델은 overfitting의 문제에 구애받지 않고 많은 수의 설명변수를 포함할 수 있다. | . 02 &#45796;&#51020; &#51473; PS(propensity score)&#47484; &#52628;&#51221;&#54620; &#54980; &#51088;&#47308; &#48516;&#49437; &#48169;&#48277;&#51004;&#47196; &#50508;&#47582;&#51648; &#50506;&#51008; &#44163;&#51008;? . Matching . | Stratification . | Weighting . | Randomization . | 정답 : 4 | 해설 : PS 추정 후 자료분석 방법에는 matching, stratification, weighting, covariate adjustment가 있다. | .",
            "url": "blog.chojaeseong.com/r/r%EA%B3%A0%EA%B8%89/dplyr/matchit/tableone/geepack/broom/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/psa/matching/2022/04/11/%EC%9D%98%EC%97%B0%EB%B0%A909)-Propensity-Score-Analysis-I-(matching).html",
            "relUrl": "/r/r%EA%B3%A0%EA%B8%89/dplyr/matchit/tableone/geepack/broom/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/psa/matching/2022/04/11/%EC%9D%98%EC%97%B0%EB%B0%A909)-Propensity-Score-Analysis-I-(matching).html",
            "date": " • Apr 11, 2022"
        }
        
    
  
    
        ,"post81": {
            "title": "강의) 제이슨 SQL 기본 강의",
            "content": "복습 정리본 . 해석 보고싶은 것을 f어떤 테이블(j)에서 w조건으로 보는데 | g그루핑한다면 h어떤조건으로 볼건지 정하고 | s어떤 데이터를 볼 것인지 정한다. | 보는 데이터를 o어떤순서로, l몇개 볼 것인지도 정해준다. | 문제 해석은 수식어는 join될, fk가진 테이블 속 재료 / 명사가 먼저 찾을 테이블속 재료로 먼저 찾는다. | | 문제1 풀이 첫번째 재료를 어떤테이블에서 어떤조건으로... 어떤 데이터를 볼 지 정해서 찾는다. 탐색용 select *에는 항상 limit 100을 붙여서 탐색하자. | . | 첫번째 재료에 달린 조건 속 숨은 재료도 첫번째 재료가 담긴 테이블에 없다면, 첫번째 재료 테이블에 연결될 수 있게 fk_id가지면서, 숨은 재료를 가진 테이블을 찾는다.(연결 재료는 조건이 +1) my) 첫재료테이블id를 fk로 가지는지부터 확인해서 필터링하자 | 첫번째 재료가 포함된 테이블명_id를 기억해서 fk로 가진 테이블만 연결된다는 것을 생각하자. | 연결된 재료 찾기는 연결될 재료 뿐만 아니라 연결에 필요한 첫번째 재료의 테이블_id(fk)까지 필요하여, 조건이 2개가 필요한 것이 차이점이다. | . | 연결에 필요한 첫재료테이블_id -&gt; join을 통해 -&gt; 첫재료자체로 연결하여 변환할 수 있다. fk자리를 join연결을 통해 첫재료로 바꿔볼 수 있다.(ProductId -&gt; ProductName)의 새로운 관점 | 실제 join은 fk테이블(다)에 자리바꿔들어가는게 아니라, PK테이블(일)에 left로 꽂는다. left로 꽂으면서 첫재료의 데이터가 (다)로 늘어나는데, fk테이블은 꽂으면서 fk를 PK테이블의 원하는 데이터 중 1개로 대체한다는 관점으로 가져가보자 | . | 연결조건을 갖춰 연결하여 fk를 통해 left에 꽂아 연결한 뒤, 원하는 데이터로 대체해서 볼 수 있지만, 1:1관계가 아닌 이상 1 &lt;- m을 갖다 꼽았다면, 꽂임 당한 PK테이블 쪽은 없던 중복이 생길 수 밖에 없다 꽂힘 당하면서 중복이 생긴 PK테이블은 select에서 id를 distint()를 걸어 중복제거후 count()를 씌워 갯수를 확인한다. (고객이) 상품(목적어m)을 주문(동사, 1)한다. -&gt; 주문:상품 = 1:m관계 반대로, 1상품이 여러개의 주문에 들어갈 수 도 있으니 m:n관계다. 어디든 m이 꽂히는 입장이니, 중복은 생긴다. | . | 주로 fk를 가진 m이 꽂히며 -&gt; join결과 1쪽에 대해 중복이 발생한 상태이다. 1주문당 m이꽂히므로, 주문갯수 n x 꽂힌 m 상품이 총 데이터 갯수다. 주문당 여러개란 뜻이지 항상 m개를 가지고 있지 않으므로 그만큼 많이 중복?! | . | join후 1(PK)에 생긴 중복을 고려해서 select에서 id를 distinct로 중복제거하여 실제 사용된 데이터 갯수를 준비를 하자 | . | distinct(pk.id)는 첫재료(1)쪽의 사용된 갯수 확인일 뿐이다. 연결된 중복 데이터에 대해 집계하여 중복제거를 하기 위해서는 group by + 집계함수로 해야한다. 이 때, 1쪽에 대한 group by는 원본재료의 id를 통해하는 것이다.필요한 재료는 select절에서 id이후 1쪽은 나열, m쪽은 집계해서 가져온다. id를 통해 groupby 집계해놓고, 거기에 select절에서는 id기본 + 타 컬럼정보를 가져다가 1쪽은 어차피 중복제거되었으니 나열, m쪽은 집계할 수 있다. | m쪽을 집계안하면? 첫번째 데이터만 올라오니 조심 m쪽을 집계안하고, 1쪽처럼 나열만 한경우 | 1쪽은 나열, m쪽은 집계한 경우 | . | . | m쪽 집계까지 끝난 뒤에야, having으로 m쪽 집계한 메서드를 그대로 가져와 조건을 걸어준다. having의 작성은 groupby -&gt; select 1id, 1칼럼나열, m집계 -&gt; m집계에 대해 조건순이지만 | having의 실제 실행은 select이후이므로 select에서 작성한 AS는 사용불가이다. select에서 준 m집계함수를 그대로 having에 걸어줘야한다. | . | join후 집계, 집계조건 걸기까지 끝난 뒤, 순서없는 것에 대해 order by/limit 등을 걸어준다. order by는 m집계함수를 그대로 걸어줘도 되지만 | select이후라서 alias를 걸어줘도 된다. | . | alias주는 리팩토링 from 에 걸린 대문자TABLE에 대해 AS 소문자로 alias를 준다. | 대문자로 쓰였던 TABLE_NAME들을 소문자alias로 교체한다. | select에서 준 소문자 칼럼alias는 having까지는 못준다. order by에서는 집계함수라도 alias로 줄 수 있다. | | select c.CustomerId as &quot;고객ID&quot;, c.CustomerName as &quot;고객이름&quot;, sum(od.Quantity) as &quot;총 주문횟수&quot; from Customers c left join Orders o on c.CustomerId = o.CustomerId left join OrderDetails od on o.OrderId = od.OrderId group by c.CustomerId order by sum(od.Quantity) desc; . | 문제2 풀이 customer(1) &lt;- Orders(n) &lt;- OrderDetails(m)을 join해놨어도, 중복이 n x m으로 생긴 customer에 대해 id로 group by하더라도 customer에 대해서만 하면 된다. Orders x OrderDetails(n x m)에 대해 집계하면 집계메서드에 의해 다 모이게 되어있다. Orders는 OrderDetails에 대해 집계로 중복제거 안해도 되나? -&gt; 목표가 고객별 집계니까,, 알아서 다 집계된다. 목표가 고객별/주문별 집계가 아니라는 점을 인식하자. | . | m:1 관계에서 fk를 가진 m에다가 pk - 1쪽의 데이터를 left join할 수 있다. Customers(1) &lt;- Orders(k-830) &lt;- OrderDetails(n-2155, Quantity) &lt;- Products(1, prices) 필요재료는 총 구매금액 = quantity * prices을 customers별 집계해야한다. | . | 이 경우, join을 받는 m쪽에 데이터 중복이 안생기고 row 당 1개 정보만 추가된다. | my) left join을 받는 쪽은 받는 쪽 row 1개당 정보가 추가되는데 보통은 1(PK)쪽에 &lt;— M(fk)를 left join으로 박아서, row 1개당 대략 m개의 데이터 중복이 생긴다고 생각한다. 다른 의미로는 m(fk)테이블 쪽에 있는 fk(pk_id)대신 (join된 테이블에서) pk테이블의 칼럼 중 택하여 정보를 바꿔 볼 수 있다. pk테이블의 칼럼 기반으로 나열하여 집계 + fk테이블(m)은 집계메서드하여 살펴볼 수 있다. | . | 연결하다보니 M(fk) &lt;— 1(PK)를 **left join으로 박아서, (m쪽이지만) row 1개당 중복없이 1개의 정보 추가만 발생한다고 생각하자. my) left join을 fk(연결당할 놈이 fk를 가지고 있는 경우) &lt;— (연결할 놈이지만 fk를 안가지고 있는)pk방향으로 하는 것은 row 1개당 1:1로 추가정보만 1개 더 추가한다고 생각하자. | . | | my) fk를 안들고 있는데 연결해야한다? -&gt; 최초 박힘의 테이블 or fk는 없지만, fk있는 곳에 1row당 1개 정보를 제공해주는 테이블 | my) 현재 테이블이 fk를 들고 있다면, m &lt;- 1 left join을 통해서 pk테이블로, fk를 들고 있는 현재 테이블에 row당 1개 정보 를 제공한다. ex&gt; 고객의 주문정보들(fk_productId) &lt;— (productId) 1row당 상품정보(prices)를 중복없이 정보만 제공 | . | my) 1쪽을 두고 m(fk)를 박아야, group by시 id로 해놓고, 1쪽칼럼은 나열 vs m쪽칼럼은 집계를 편하게 할 수 있을 것 같다. select c.CustomerId, c.CustomerName AS name, sum(od.Quantity * p.price) AS total from Customers c left join Orders o on c.CustomerId = o.CustomerId left join OrderDetails od on o.OrderId = od.OrderId left join Products p on od.ProductId = p.ProductId group by c.CustomerId order by total desc . | . | | SQL . update . where을 안주면 테이블 전체가 바뀐다. . . | . distinct 와 groupby로 중복제거 . distinct : 종류별로 1개만 남기도록 중복제거 . . | group by 로 인해 그루핑으로 기준칼럼별 중복제거된 데이터로 보기가 편해진다 . select이니까 결국엔 보이는 중복만 제거하지만, 같은 그룹기준별로 보여주니 그룹기준칼럼이 종류별로 1개가 되는 점 + 그 1개에 대한 여러 중복데이터들은 필요시 강제집계을 이용하는 것이다. | 원래 그룹바이는 1000000개의 데이터를 보기 편하게 묶어서 보기위함이다. 그 과정에서 그룹의 기준이되는 칼럼은 중복이 제거되어 1개가 된다. | . | . | group by이 궁극적인 목적은 기준칼럼의 중복제거가 아니라 -&gt; 중복제거된 기준칼럼에 속하는 단일 or 여러데이터들의 집계가 목적이다 . . | having으로 그루핑한 상태에서 where를 걸 수 있다. . | select(셀렉)시 limit 100, limit 1000을 버릇화해야한다. . order by | limit 체스게임 같은 경우, 생성날짜가 있다면 orderby limit1을 적용할 수 있다. | . | . | . select(쎌렉!) . 보는 순서 . . from부터 where, group by, having까지 내려가되, select한 뒤 order by+limit . . from 부터 볼 건데 join이 올 수 도 있다. . | where로 조건을 줘서 어떤 범위들을 볼 지 조건으로 지정하고 | group by로 그룹별로 묶어서 보고 | having 그룹 중 어떤 그룹을 볼지 조건으로 지정하고 . | f(j)-w/g-h으로 만들어진 데이터 중 select으로 어떤 데이터만 골라서 볼 것이며 . | select이후 order by, limit으로 어떤 정렬로, 얼만큼 짤라 볼 것인지 지정한다 | 쎌렉이 제일 마지막 같지만, 5.쏄렉에서 지정한 alias를 -&gt; 6. order by + limit에서 사용할 수 있다. -&gt; where은 fw gh 다음 select이라 select의 별칭이 안먹힌다 . sql해석방법 . from부터 내려가면서 [어떤 테이블f에 어떤범위w로부터 그룹핑g을 한다면, 어떻 그룹h을 골라볼 것인지 정해지면 -&gt; 어떤데이터s만 골라서 볼지 정한 뒤 -&gt; 그 데이터를 어떻게 정렬orderby하고 어떻게 짜를limit 것인지는 [쎌렉이후 칼럼선택 + alias주고] 본다 . 해석시 쎌렉은 fw-gh- 다음인줄알았는데, 직접 작성시에는 groupby까지하고 쎌렉에 집계메서드로 집계해놓고 -&gt; 그대로 칼럼처럼 가져와 having에 조건을 추가한다. . 심지어 order by에서도 쎌렉에 있는 [[집계칼럼메서드를 칼럼]]으로 그대로 가져다 쓴다. . 주의! 작성은 쎌렉 집계후 having에서 갖다썼지만, 실행은 having후 쎌렉이라서-&gt; having절(+where절)에 쎌렉alias못쓴다! . . 실습 . 실습 사이트 w3schools: https://www.w3schools.com/sql/trymysql.asp?filename=trysql_func_mysql_concat | . 주의점: 서브쿼리X + innerjon외 left or right 1개만 섞을 것 . 문제1 . 1. 200개 이상 팔린 상품명과 그 수량을 수량 기준 내림차순으로 보여주세요. | . 풀이1 . # 1. 200개 이상 팔린 상품명과 그 수량을 수량 기준 내림차순으로 보여주세요. ## 1-1. 재료가 일단 어디있는지, 재료가 속한 &lt;테이블&gt; 찾는다. [상품명] -&gt; [수량] 단독 재료같지만, [상품명] 앞에 200개 이상 팔린 -&gt; (연결된 조건재료)에 속한다. ## [상품명]은 왠지 Products테이블에 있을 것 같다 -- select * from Products; -- 지금은 77개 밖이지만, 테이블 전체데이터 쎌렉시 limit 100, 1000을 고려하자 -- * from Products limit 100; ## ProductName의 [상품명]이 있는 테이블을 찾았다. ## 1-2. [재료:상품명]에 (수식어)가 있으니 ([재료]와 연결된=찾은테이블+Id를 Fk로 가져 연결이 가능한 (조건 연결재료))로서 (200개 이상 팔린)의 (주문량,팔린량)을 가진 &lt;테이블&gt;을 찾아야한다. ## (팔린) -&gt; 주문과 관련있는 것 같아서 &lt;Orders&gt;테이블을 조회해본다. -- select * from Orders limit 100; -- OrderID CustomerID EmployeeID OrderDate ShipperID ## 뭐야 (팔린량,주문량)도 없고 [상품명과 연결될 ProductId]도 안가지고 있다. ## my) 추가정보를 얻기 위해선 ## 다시 테이블을 보니, &lt;OrderDetails&gt;가 있다. -- select * from OrderDetails limit 100; -- OrderDetailID OrderID ProductID Quantity -- 1 10248 11 12 -- 2 10248 42 10 -- 3 10248 72 5 ## 여기에 [상품명]과 연결시켜주는 [ProductID]와 + (주문량, 팔린량 Quantity)가 동시에 있다. ## my) 수식어, 조건 재료를 찾을 때는 (수식재료) 뿐만 아니라 [원본재료의 테이블과 연결된 원본재료테이블ID]도 가지고 있어야한다. ## FK인 ProductId는, Product테이블입장에서 [상품명]을 대표하는 그야말로 Id이므로, ## -&gt; (연결재료)찾을 시 [FK테이블+ID]의 FK자체를 -&gt; [연결된 기존재료]로 해석해도 된다. ## --&gt; [FK 테이블Id]를 [상품명]등 [재료]로 바꿔보기위해선 join이 필요한 것 -- OrderID ProductID Quantity -- 10248 11 12 ## ex&gt; ProductId(FK)가 11인 것은 주문량이 12다 ## = [해당 11번 상품명]은 12개 팔렸다 ## -&gt; join으로 연결해서보면 [11번 상품명] [주문량 12개 팔림]으로 보인다. ## 1-3. 재료들을 다 찾았다면, join해서 보는 것으로 결정낸다. ## -&gt; join시 on자리에 &lt;기존테이블&gt;.[기존재료]의PK_ID - &lt;연결재료테이블&gt;.(연결 재료)를 찾을 때 보이던 [FK_id]로 연결해주면 된다. select * from Products inner join OrderDetails on Products.ProductId = OrderDetails.ProductID; ## 이 때, Products &gt;- Orders : (고객이) 상품을 주문한다 -&gt; 주문:상품 = 1:m 관계다. ## -&gt; 1주문당 여러개의 상품을 가질 수있으며 -&gt; 주문들을 모아놓은 테이블은, 각 주문마다의 상품들이 겹칠 수 밖에 없다. ## 즉, 1:m 을 join했다면, 1(주문량, 상품FK)에서 m에 있는 정보(상품명 with 상품PK)를 얻기위해 붙인 것으로 [중복이 발생할 수 밖에] 없다 . ## 2. 재료들을 합친 상태라면, 이제 (조건재료)속 조건 or 요구사항을 만족시켜줘야한다. -- select * from Products -- inner join OrderDetails on Products.ProductId = OrderDetails.ProductID; ## 2-1. (200개 이상 팔린) [상품명]의 (요구사항)은 어떻게 처리? ## 2-2. 1:m의 join에서 1order당 mProduct명 -&gt; n order : n x m Product -&gt; n X m개의 row속에 중복이 무조건 존재한다. ## -&gt; 일단 m쪽에서 제공해준 FK을 [[ 쎌렉 distinct( FK ) ]]로 중복제외한 종류별로 1개씩이라면 총 몇개가 사용됬는지 확인한다. ## -&gt; on에 걸린 아무FK or PK를 가져와서 쎌렉으로 복붙해서 * 대신 -&gt; distinct( FK )를 넣어준다 ## --&gt; 1쪽인 order도 자기가 가졌던 m개의 product에 대해 모두 같은 orderId를 가져 중복이 된다. ## --&gt; 1쪽은 1:m으로 1order라도, m쪽에서 본다면, m개의 order를 가지게 되는 것. ## my) 1:m에서 1개 데이터라도 m입장에서는 기본 m개 중복이네! ## my) 오히려 1입장에서 1개 데이터라면, m은 중복없기 수량칼럼을 가질 듯. ## my) 1:m은 join전에는 m이 미중복, 1은 m개만큼 중복 -&gt; [[1개 데이터일 땐 미중복 m개의 데이터]] join후 [[1이었떤 order가 늘어남에 따라 m에서도 중복이 생길 가능성이 높아진다]] ## 2-3. &lt;&lt;distinct()&gt;&gt;로 [join전 1개 order에 대해 미중복이던 m쪽 Product]가 join후 중복됬는데, ## &lt;&lt; join으로 생긴 중복들 속에 [[ 실제 사용된 m쪽의 데이터]]는?&gt;&gt; by &lt;&lt;distinct( on에 걸려있는 m의 FK)&gt;&gt; -- select * from Products -- 2155 -- inner join OrderDetails on Products.ProductId = OrderDetails.ProductID; -- 77 : 중복이 발생한 m Product 중에 실제로는 77종류(distinct종류별 1개씩이니)만 사용되었다. select distinct(Products.ProductId) from Products inner join OrderDetails on Products.ProductId = OrderDetails.ProductID; . # 3. join후 생긴 m쪽 Product가 중복된 상황에서 (77개 -&gt; 2155개 데이터로 중복된 상태) ## - cf) 1쪽 Order는 1개의 order에 대해 m개의 OrderId가 동일한 중복상태 -&gt; join하더라도, order의 갯수만큼만 distinct함. ## - my) 1쪽은 join시, 달라붙는 order만 추가되고 매번 그 안의 m개 Product에 대해 중복이므로, -&gt; Order의 row수 == join시 distinct()한 orderId수 동일함. ## - my) m쪽은 1order시 중복없다가, join시 중복이 발생할 가능성이 있으니 [[m쪽만 중복을 필수 확인]]해야함. -- select distinct(Products.ProductId) -- from Products -- inner join OrderDetails -- on Products.ProductId = OrderDetails.ProductID; ## 3-1 요구사항을 보면 (200개 이상 팔린) [상품명] -&gt; 중복가능성이 있는 m쪽이므로 ## -&gt; distinct가 아닌 [[m쪽의 Id로 groupby]]해서 중복을 제거와 함께 집게해야 [수량]을 판단할 수 있게 된다. select * from Products inner join OrderDetails on Products.ProductId = OrderDetails.ProductID group by Products.ProductID; -- 77; -- Number of Records: 77 ## (m쪽id)로 groupby하여 집계를 하면, distinct(m쪽Id)한 것과 동일한 갯수가 나온다 -&gt; 집계로 중복제거 #### 근데 집계함수를 안쓰고 group by 만 상태 -&gt; distinct하기만 하고 집계는 안되어있는 상태다! #### -&gt; group by는 되어있는데, 첫데이터만 대표로 내어놓은 상태 . # 4. 집계준비가 되었다면, 쎌렉에서 집계한다. ## 현재 [group by 재료ID]로 -&gt; [ distinct한 mProduct별로 집계된 데이터] &amp;&amp; 쎌렉에서 집계는 안해줬다면, 첫데이터만.. ## 4-1. 일단 쎌렉절에 각 테이블에서 가져온 [재료]들과 그 [ID]까지 쎌렉해야한다. group by는 id로 하는 것이다. ## -&gt; &lt;타테이블&gt;.(연결재료)는 꼭 ID가 없어도 되긴한다. ## -&gt; 마지막으로 집계(연결재료) 등 집계대상을 집계해준다. ## --&gt; &lt;해당테이블&gt;.[재료ID] &lt;해당테이블&gt;.[재료(상품명)] &lt;타테이블&gt;.(연결재료) ## --&gt; &lt;해당테이블&gt;.[재료ID] &lt;해당테이블&gt;.[재료(상품명)] sum ( &lt;타테이블&gt;.(연결재료) ) -- select * -- select Products.ProductID, Products.ProductName, OrderDetails.Quantity select Products.ProductID, Products.ProductName, sum( OrderDetails.Quantity ) from Products inner join OrderDetails on Products.ProductId = OrderDetails.ProductID group by Products.ProductID; -- Number of Records: 77 -- ProductID ProductName sum( OrderDetails.Quantity ) -- 1 Chais 828 -- 2 Chang 1057 -- 3 Aniseed Syrup 328 . ## 4-2. 집계가 완료된 데이터에서 having을 건다. ## my) 해석시 쎌렉은 fw-gh- 다음인줄알았는데, 직접 작성시에는 groupby까지하고 쎌렉에 집계해놓고 -&gt; 그대로 가져와 having에 조건을 추가한다. ## -&gt; 쏄렉: sum( OrderDetails.Quantity ) -&gt; having : sum( OrderDetails.Quantity ) &gt;= 200 select Products.ProductID, Products.ProductName, sum( OrderDetails.Quantity ) from Products inner join OrderDetails on Products.ProductId = OrderDetails.ProductID group by Products.ProductID having sum( OrderDetails.Quantity ) &gt;= 200; . ## 4-3. 심지어 order by에서도 쎌렉에 있는 [[집계칼럼메서드를 칼럼]]으로 그대로 가져다 쓴다. select Products.ProductID, Products.ProductName, sum( OrderDetails.Quantity ) from Products inner join OrderDetails on Products.ProductId = OrderDetails.ProductID group by Products.ProductID having sum( OrderDetails.Quantity ) &gt;= 200 order by sum( OrderDetails.Quantity ) desc; . 쎌렉에 집계 alias 리팩토링 for order by, limit . ## 4-4. 이제 쎌렉을 가져다 쓰는 놈들(order by, limit ) 을 위해 [[ 쎌렉에 alias주는 리팩토링 ]] 하기 ## -&gt; 주의! 작성은 쎌렉후 having에서 갖다썼지만, 실행은 having후 쎌렉 -&gt; having절에 쎌렉alias못쓴다! ## 1) select 집계에 alias주기 -&gt; total ## 2) order by, limit에서 alias로 바꾸기 select Products.ProductID, Products.ProductName, sum( OrderDetails.Quantity ) as total from Products inner join OrderDetails on Products.ProductId = OrderDetails.ProductID group by Products.ProductID having sum( OrderDetails.Quantity ) &gt;= 200 order by total desc; . from(+join)에서 에만 테이블 as 소문자 별칭 -&gt; 이후 fw-gh-select까지 보이는 테이블 모두 alias주는 리팩토링 . ## 4-5. from(+join)에 주어지는 테이블의 대문자만 따서 alias로 주는 리팩토링 -&gt; fw-gh-s까지 다 리팩토링 가능해진다. ## from에만 as 소문자 -&gt; 그 뒤로는 테이블들 모조리 소문자로 변경 select p.ProductID, p.ProductName, sum( od.Quantity ) as total from Products as p inner join OrderDetails as od on p.ProductId = od.ProductID group by p.ProductID having sum( od.Quantity ) &gt;= 200 order by total desc; . 문제2 . 2. 많이 주문한 순으로 고객 리스트(ID, 고객명)를 구해주세요. (고객별 구매한 물품 총 갯수) | . 풀이2 . -- 후니 select c.CustomerID, c.CustomerName, sum(od.Quantity) total from Customers c join Orders o on c.CustomerID = o.CustomerID join OrderDetails od on o.OrderID = od.OrderID group by c.CustomerID order by total desc; -- 아리 SELECT Customers.CustomerID , Customers.CustomerName , SUB.Quantity FROM Customers JOIN (SELECT Orders.CustomerID AS ID , SUM(OrderDetails.Quantity) AS Quantity FROM Orders JOIN OrderDetails ON Orders.OrderID = OrderDetails.OrderID GROUP BY Orders.CustomerID ) AS SUB ON Customers.CustomerID = SUB.ID ORDER BY SUB.Quantity DESC; -- 아서 SELECT c.customerid &quot;고객 ID&quot;, c.customername &quot;고객 이름&quot;, sum(od.quantity) &quot;총 주문갯수&quot; FROM Customers c join Orders o ON c.customerid = o.customerid JOIN OrderDetails od ON o.orderid = od.orderid JOIN Products p ON p.productID = od.productId GROUP BY c.customerid ORDER BY SUM(od.quantity) DESC -- 필즈 SELECT c.CustomerId, c.CustomerName, od.orderQuantity FROM Orders o inner join ( SELECT OrderId, sum(Quantity) &quot;orderQuantity&quot; FROM OrderDetails group by OrderId ) od on o.OrderId = od.OrderId inner join Customers c on c.CustomerId = o.CustomerId order by orderQuantity desc ; -- 베루스 select c.CustomerId as ‘고객 아이디‘, c.CustomerName as ‘고객 이름‘, sum(od.Quantity) as ‘주문량’ from Customers as c left join Orders as o on c.CustomerId = o.CustomerId left join OrderDetails as od on o.OrderId = od.OrderId group by c.CustomerId order by sum(od.Quantity) desc -- 루키 SELECT Customers.CustomerID, Customers.CustomerName FROM Customers inner join Orders on Customers.CustomerID = Orders.CustomerID GROUP BY Customers.CustomerID ORDER BY COUNT(Orders.CustomerID) DESC; -- 유콩 SELECT Customers.CustomerID AS `고객아이디`, Customers.CustomerName AS `고객이름`, sum(Quantity) AS `주문량` FROM Orders JOIN OrderDetails ON Orders.OrderID = OrderDetails.OrderID RIGHT JOIN Customers ON Orders.CustomerID = Customers.CustomerID GROUP BY Customers.CustomerID ORDER BY `주문량` DESC; -- 케이 SELECT Orders.CustomerId, Customers.CustomerName, sum(Quantity) FROM OrderDetails join Orders on OrderDetails.OrderId = Orders.OrderId join Customers on Orders.CustomerId = Customers.CustomerId group by Customers.CustomerName order by sum(Quantity) desc -- 배카 . 문제3 . 3. 많은 돈을 지출한 순으로 고객 리스트를 구해주세요. | . 풀이3 . -- 아서 SELECT c.customerid &quot;고객 ID&quot;, c.customername &quot;고객 이름&quot;, sum(od.quantity * p.price) &quot;총 주문가격&quot; FROM Customers c join Orders o ON c.customerid = o.customerid JOIN OrderDetails od ON o.orderid = od.orderid JOIN Products p ON p.productID = od.productId GROUP BY c.customerid ORDER BY SUM(od.quantity * p.price) DESC -- 케이 SELECT Orders.CustomerId, Customers.CustomerName, sum(Quantity*Price) FROM OrderDetails join Orders on OrderDetails.OrderId = Orders.OrderId join Customers on Orders.CustomerId = Customers.CustomerId join Products on OrderDetails.ProductId = Products.ProductId group by Customers.CustomerName order by sum(Price*Quantity) desc -- 베루스 select c.CustomerId as ‘고객 아이디‘, c.CustomerName as ‘고객 이름‘, sum(od.Quantity*p.Price) as ‘지출액’ from Customers as c left join Orders as o on c.CustomerId = o.CustomerId left join OrderDetails as od on o.OrderId = od.OrderId left join Products as p on od.ProductId = p.ProductId group by c.CustomerId order by sum(od.Quantity*p.Price) desc -- 디우 select Customers.CustomerID, Customers.CustomerName, sum(OrderDetails.Quantity * Products.price) from Customers, OrderDetails, Orders, Products where Customers.CustomerID = Orders.CustomerID AND OrderDetails.OrderID = Orders.OrderID AND Products.ProductID = OrderDetails.ProductID group by Customers.CustomerID order by sum(OrderDetails.Quantity * Products.price) desc; -- 후니 SELECT c.CustomerID, c.CustomerName, (p.Price * od.Quantity) total FROM Customers c join Orders o on c.CustomerID = o.CustomerID join OrderDetails od on o.OrderID = od.OrderID join Products p on od.ProductID = p.ProductID order by total desc; -- 코린 select c.CustomerID, c.CustomerName, sum(od.Quantity * p.price) as total_price from Orders o join OrderDetails od on o.OrderID = od.OrderId join Customers c on o.CustomerID = c.CustomerID join Products p on od.ProductId = p.ProductId group by c.CustomerID order by total_price desc; -- 이프 select c.CustomerID, c.CustomerName, sum(od.Quantity * p.Price) as total from Customers as c join Orders as o on c.CustomerID = o.CustomerID join OrderDetails as od on o.OrderID = od.OrderID join Products as p on p.ProductID = od.ProductID group by c.CustomerID order by total desc -- 루키 SELECT Customers.CustomerName FROM Customers INNER JOIN Orders ON Customers.CustomerID = Orders.CustomerID INNER JOIN OrderDetails ON Orders.OrderID = OrderDetails.OrderID INNER JOIN Products ON Products.ProductID = OrderDetails.ProductID GROUP BY Customers.CustomerID ORDER BY SUM(OrderDetails.Quantity * Products.price) DESC; -- 더즈 select c.CustomerId, sum(p.Price) as &#39;총지출&#39; from Customers c inner join Orders o on c.CustomerId = o.CustomerId inner join OrderDetails od on od.OrderId = o.OrderId inner join Products p on p.ProductId = od.ProductId group by c.CustomerId order by sum(p.Price) desc; -- 필즈 SELECT c.CustomerId, c.CustomerName, od.quantity * p.price &quot;orderPrice&quot; FROM Customers c inner join Orders o on c.CustomerId = o.CustomerId inner join OrderDetails od on o.OrderId = od.OrderId inner join Products p on od.ProductId = p.ProductId order by orderPrice desc; -- 유콩 SELECT Customers.CustomerID AS `고객아이디`, Customers.CustomerName AS `고객이름`, sum(Price * Quantity) AS `지출금액` FROM Orders JOIN OrderDetails ON Orders.OrderID = OrderDetails.OrderID JOIN Products ON OrderDetails.ProductID = Products.ProductID RIGHT JOIN Customers ON Orders.CustomerID = Customers.CustomerID GROUP BY Customers.CustomerID ORDER BY `지출금액` DESC; -- 썬 select c.CustomerID, c.CustomerName, sum(od.quantity * p.price) as price_total from Customers c inner join Orders o on c.CustomerID = o.CustomerID inner join OrderDetails od on o.OrderID = od.OrderID inner join Products p on p.ProductID = od.ProductID group by c.CustomerID order by price_total desc; -- 수달 select c.CustomerName as &#39;고객명&#39;, sum(d.Quantity * p.price) as &#39;지출금액&#39; from Customers c inner join Orders o on c.CustomerID = o.CustomerId join OrderDetails d on o.OrderID = d.OrderId join Products p on d.ProductID = p.ProductID group by c.CustomerID having sum(p.price * d.Quantity) order by sum(p.price * d.Quantity) desc; -- 릭 SELECT c.CustomerID AS `ID`, c.CustomerName AS `고객명` FROM Customers AS c INNER JOIN Orders AS o ON c.CustomerID = o.CustomerID GROUP BY o.CustomerID ORDER BY SUM(o.CustomerID) DESC; -- 연로그 select c.CustomerID , c.CustomerName , sum(p.Price * od.Quantity) total from Customers c join Orders o on o.CustomerID = c.CustomerID join OrderDetails od on o.OrderID = od.OrderID join Products p on p.ProductID = od.ProductID group by c.CustomerID order by total desc; -- 봄 SELECT c.customerId, c.customerName, sum(p.price * od.quantity) as total FROM Customers as c JOIN Orders as o ON c.customerId = o.customerId JOIN OrderDetails as od ON o.orderId = od.orderId JOIN Products as p ON od.productId = p.productId GROUP BY c.customerId ORDER BY total DESC; -- 라라 select c.CustomerID, c.CustomerName, sum(p.Price * od.Quantity) as total from Customers as c inner join Orders as o on c.CustomerID = o.CustomerID inner join OrderDetails as od on od.OrderId = o.OrderId inner join Products as p on p.ProductId = od.ProductId group by c.CustomerID order by total desc .",
            "url": "blog.chojaeseong.com/sql/jason/%EC%9A%B0%ED%85%8C%EC%BD%94/%EA%B0%95%EC%9D%98/2022/04/05/%EC%A0%9C%EC%9D%B4%EC%8A%A8-sql%ED%95%B4%EC%84%9D-%EA%B0%95%EC%9D%98.html",
            "relUrl": "/sql/jason/%EC%9A%B0%ED%85%8C%EC%BD%94/%EA%B0%95%EC%9D%98/2022/04/05/%EC%A0%9C%EC%9D%B4%EC%8A%A8-sql%ED%95%B4%EC%84%9D-%EA%B0%95%EC%9D%98.html",
            "date": " • Apr 5, 2022"
        }
        
    
  
    
        ,"post82": {
            "title": "의연방08) Sample size",
            "content": "R 고급 실습(이분형 결과변수의 samplesize계산을 위한 power.prop.test() ) 포함됨 | . &#54617;&#49845; &#47785;&#54364; . 샘플 사이즈를 계산하는 목적을 설명할 수 있다. . | 샘플 사이즈 계산의 주요 개념인 가설, α, β, 효과 크기에 대하여 설명할 수 있다. . | 이분형 결과변수를 사용하는 임상연구에서 필요한 샘플 사이즈를 계산할 수 있다. . | . &#51452;&#50836; &#50857;&#50612; . 제1종 오류 : 귀무가설이 참일 때 귀무가설을 기각하는 오류 | 제2종 오류 : 대립가설이 참일 때 귀무가설을 기각하지 못하는 오류 | α : 제1종 오류 확률의 최대값 | β : 제2종 오류 확률 | . &#47785;&#52264; . 샘플 사이즈 계산의 주요 개념 | 이분형 결과변수일 때 샘플 사이즈 | 기타 고려사항 | Sample Size . &#49368;&#54540; &#49324;&#51060;&#51592; &#44228;&#49328;&#51032; &#51452;&#50836; &#44060;&#45392; . 샘플 사이즈가 너무 작으면 : 위험요소와 질병 간에 실제로 존재하는 상관관계를 보이지 못할 수 있다 | 샘플 사이즈가 너무 크면 : 비용과 시간이 많이 든다 | 유의미한 상관관계를 보일 가능성이 충분히 높은 샘플 사이즈를 확보하고 연구를 시작하자! | . &#49368;&#54540; &#49324;&#51060;&#51592; &#44228;&#49328;&#51032; &#47785;&#51201; . 샘플사이즈 계산을 해야한다?! 왜?? 없으면 포함하라고 리뷰어의 코멘트가 날아온다. | IRB 심사받을 때도, Sample size 계산 근거를 제출하라고 날아온다. | . | 너무 작으면 -&gt; 데이터 정보 충분치 X -&gt; 알고 싶은 정보를 알 수 없다. 위험요소-질병간의 상관관계 -&gt; 인과관계를 알고 싶은데, 실제 존재하더라도 sample size가 작으면 알 수가 없게 된다 | . | 데이터가 크면 클수록 좋다 마냥 클 수 없는 것이 모으는데 비용과 시간이 많이 든다(환자수 1명당..) | . | 보이고 싶은 것을 충분히 보일 수 있는 샘플 사이즈를 알아야한다 유의미한 상관관계(인과관계)를 보일 가능성 있는 충분히 높은 샘플 사이즈를 확보한 뒤 연구에 들어가자 | . | . 유의미한 상관관계 보인다?!의 의미 : 상관관계에 대한 가설검정을 통과할 정도여야한다. . 상관관계가 없다는 귀무가설을 기각해야한다 | p-value가 알파(0.05)보다 낫게 나와야한다 | 결국 가설검정해서 0.05보다 낫게 나와야한다 | . | 유의미한 상관관계 보일 가능성이 충분히 높다 = p 0.05보다 낫게 나올 가능성이 충분히 높다 = Power가 높다 = 베타가 낫다 . | . &#49368;&#54540; &#49324;&#51060;&#51592;&#51032; &#44208;&#51221; &#50836;&#49548;(3&#44032;&#51648;) . 가설 | α와β | 효과 크기 | &#44032;&#49444; . 귀무가설 : 위험요소와 질병 간에 상관관계가 없다(차이가 없다) | 대립가설 : 위험요소와 질병 간에 상관관계가 있다(차이가 있다) | . 이분형 결과변수(이벤트/질병발생이 있었는가 vs 없었는가)에 대해서 두 그룹(위험요소 노출 vs 노출안됨) 비교하는 경우를 생각해보자. p1: 위험요소 노출O그룹 = 실험군 에서 이벤트 있을 확률(risk) | p0: 위험요소 노출X그룹 = 대조군에서 이벤트 있을 확률(risk) 귀무가설 : 차이가 없다 = 위험요소와 질병간 상관관계 없다 = p1과 p0가 같다 = OR = 1이다 cf) OR = 실험군오즈(p1/1-p1) / 대조군오즈(p0/1-p0) | . | 대립가설 : 차이가 있다 = 위험요소와 질병간 상관관계 있다 = p1과 p0가 다르다 = OR != 1이다 | . | . | . &#51228; 1&#51333; &#50724;&#47448;, &#51228; 2&#51333; &#50724;&#47448; . 항상 귀무가설(H1)이 참이거나 거짓이거나 둘 중 하나다 무엇인지 모르지만 2가지 경우를 나누어서 본다. | . | 다음엔 귀무가설을 기각할 수 도, 기각하지 못할 수 도 있다. | . y 귀무가설이 참인데 -&gt; x 귀무가설을 기각하면 잘못된 것 -&gt; Type 1 Error 귀무가설이 참인데, 귀무가설을 기각하는 오류 | . | y 대립가설이 참인데 -&gt; x 귀무가설을 채택하면 잘못된 것 -&gt; Type 2 Error 대립가설이 참인데, 귀무가설을 기각하지 못하는 오류 | . | my H0/H1이 (고정)참일 떄 -&gt; (고정)H0를 어떻게 했냐에 따라 같은 것 잘못(H0참 -&gt; H0기각 : type1) | 다른 것 잘못(H1참 -&gt; H0기각 : type2) | . | 2가지 오류를 나눠서 생각한다 | . a(&#50508;&#54028;) . a = 제 1종 오류의 최대허용치 a = H0가 참인데 H0를 기각할 오류의 최대허용치 | . | 유의수준이라고도 말한다. | 보통 0.05을 사용한다 상황에 따라, 초반 연구(preliminary study)라서 조금 더 type 1 error를 높여 조금 더 높게 허용 = 0.05를 -&gt; 0.1, 0.2, 0.25까지 올려서 사용하기도 한다. | . | a를 낮추면 정확한 study가 되지만, 초반 연구 디자인/ 도움을 주기 위해서, 정확하진 않지만 a를 조금 높게 허용하기도 한다. | . | a를 확 낮춰 정확한 study를 할 때는, 결과변수가 여러개일 때, 얻어걸리는 경우를 방지하기 위해 조금 더 엄격하게 연구하는 다중비교 (Multiple comparisons)에서, 다중성을 보정하기 위해 a를 낮춰 가설검정을 수행한다 | . | . b(&#48288;&#53440;) . b = 제 2종 오류 b = H1대립가설이 참인데, H0를 기각하지 못하는 오류의 최대 허용치 | 만약, H1참인데, H0를 실제로 기각하고, H1을 채택하여 2종오류X -&gt; 검정력이라고 함 | . | 검정력(power) = 1-b 보통 0.2로 많이 한다. 0.1로 할 때도 많다. b0.2 -&gt; power는 0.8로 한다는 말 | b0.1 -&gt; power를 0.9로 한다는 것 | . | . | . &#54952;&#44284; &#53356;&#44592; . 위험요소 노출된 그룹과 노출 안된 그룹 간 결과변수 값의 차이 | 우리는 계속 이분형 결과변수를 보고 있음. 이 경우, 두 그룹간의 event rate차이 = p1과 p0의 차이가 효과크기기 된다. | 보통 p0(대조군 = 위험요소 노출X그룹의 질병발생율)은 보고가 되고 | p0가 얼마일 때, p1 대신 아래 3가지 중 1가지를 제공한다면 -&gt; 효과크기가 제공 되었다고 한다 Absolute difference(=RD =attributable risk) p1 - p0 제시 | . | Relative change(OR, RR) OR o RR 제시 | . | 실험군(위험요소 노출된 그룹)의 이벤트 비율을 직접 언급 p1을 직접 제시 | . | . | . | . 효과 크기 예제 대조군의 이벤트 비율 = 10%이라고 할 때, (p0 제공) p0 = 0.1 | . | 아래 네가지 중 하나를 같이 언급하면 p1을 제시한 것과 같아서 -&gt; effect size를 밝힐 수 있다. p1 = 25% = 0.25 | absolute difference = 15% = 0.15 attributable risk = p1-p0 = p1 - 0.1 = 0.15 | p1을 제시한 것과 동일 | . | OR = 3.0 OR식을 p1으로 정리하여 recovery할 수 있다. | . | RR = 2.5 p1/p0 = p1/0.1 = 2.5 | . | | . | . a/b, &#54952;&#44284;&#53356;&#44592;&#50752; Sample Size&#44036;&#51032; &#44288;&#44228; . α와 β, 효과 크기와 샘플 사이즈는 서로 얽혀있다 | 다른 모든 조건(샘플 사이즈, 효과 크기)이 동일한 경우, α가 커지면 β는 작아지고, α가 작아지면 β는 커진다 | type 1 error rate이 올라가면, type2 error rate이 내려간다 | type 1 error rate이 내려가면, type2 error rate이 올라간다 | α와 β는 서로 반대 방향으로 가는 관계이다. | . | 효과 크기가 일정할 경우, 샘플 사이즈가 커질 수록 α와 β는 작아진다 샘플 사이즈가 커진다 = 데이터를 많이 모은다 = 정보가 많아진다 = 전체적으로 오류의 확률이 낮아진다. | . | 샘플 사이즈가 일정할 경우, 효과 크기가 클 수록 α와 β는 작아진다 효과의 크기가 크면 클수록 적은량의 데이터로도 차이가 잘 보이게 된다. = 오류를 범할 확률이 낮아진다. | . | 우리는 오류의 확률(α와 β)을 낮추기를 희망한다 효과 크기가 크거나, 샘플 사이즈가 커야 양쪽 오류의 확률을 낮출 수 있다 | . | . &#50612;&#46500; &#54952;&#44284;&#53356;&#44592;&#47484; &#44032;&#51221;&#54624;&#44620;? . 샘플 사이즈를 계산하려면 a, b 및 효과 크기를 가정해야한다. | . | 어떤 효과 크기를 가정할까? 실제 효과 크기를 XX일 때, type 1 error 확률이 a(알파)보다 낮고, power가 1-b(베타)보다 높은 샘플사이즈는 YY이다. | . | a는 0.05로 많이하고, b는 0.2로 많이 하는데, 효과 크기는 얼마로 가정해야할까? 임상적으로 중요한 효과크기를 가정하는 것이 좋다. | 선행연구에 관측한 효과크기를 쓰기도 한다. | . | . &#51060;&#48516;&#54805; &#44208;&#44284;&#48320;&#49688;&#51068; &#46412; &#49368;&#54540; &#49324;&#51060;&#51592; . 테스트 해야하는 가설이 아래와 같고 | 검정은 카이제곱 검정을 사용한다 | 실험군 vs 대조군은 1:1을 가정하지만 RCT는 내가 모으는 거라 가정하지만, 관찰연구는 이미 숫자가 정해져있어서 1:1이 아님 | . | 1:1인 경우의 샘플사이즈 구하는 공식이 아래와 같이 나온다 공식 자체가 중요하진 않다. 소프트웨어로 계산하면 된다. | 공식을 통해, 샘플 사이즈가 어떻게 효과크기/a/b에 영향을 받는지 확인한다. | 효과크기 가정시 p1,p0가 가정되어있다. | z sub a는 표준정규분포곡선에서 면적이 a가 되는 x값을 z sub a로 표시한다. | . | . a,b,p0,p1&#51032; &#49368;&#54540; &#49324;&#51060;&#51592;&#50640; &#45824;&#54620; &#50689;&#54693; . 아래 표에서 Pc는 P0를, Pi는 P1을 의미한다. control / intervention | . | . 세로축 방향으로 보자면, 가로축을 P0가 0.6일 때 고정시 . P1이 점점 작아진다. = 차이가 커진다 = 효과 크기가 커진다. (차이가 잘보여)필요한 sample size는 줄어든다 | . | . | 가로축 방향으로 보자면 . a(알파)값이 왼쪽으로 갈 수록 작아진다.(0.05, 0.025, 0.01) . 1종 오류 확률을 낮춘다 = 오류가 낮은 테스트를 한다 = 데이터가 더 많이 필요하다 필요한 sample size가 커진다 | . | . | 0.90, 0.80은 power를 의미한다. . power가 높으려면 더 많은 샘플사이즈를 필요로 할 것이다. | power가 높다 = 높은 확률로 실제 존재하는 두군간의 차이를 확인하고 싶다는 의미이므로 샘플 사이즈가 커야한다. | . | . | . (곡선 1개 고정) x축은 p0-p1을 의미한다. x축이 커질수록 효과크기가 커져, 샘플사이즈는 적게 필요하므로 점점 줄어드는 모양의 그래프가 나타난다 | . | (x축 고정) 같은 효과크기에 대해 기울기 = Pc = P0 를 의미하므로 대조군의 event rate에 따라 필요로 하는 샘플 사이즈가 달라진다. | . | . Case-Control study&#51032; &#44221;&#50864;, &#45796;&#47480; p1, p0 . 위에서 나타난 샘플사이즈 공식 + 그래프는 코호트, 크로스섹셔널, RCT에서는 적용가능하나 | Case-control study에서는 적용이 불가능하다. | . | Case-Control의 경우 실험군-대조군이 존재하지 않고, case와 control이 있다. | 이미 질병(event)이 발생한 vs 발생하지 않은 그룹이 있다. 각각 위험요소 노출이 얼마나 되었는지 확인하는 study이다. | 그래서 p1과 p0의 정의가 위 코호트, 크로스섹셔널, RCT study와는 다르다. | . | p1 : case 중 위험요소 노출확률 | p0 : control 중 위험요소 노출확률 샘플 사이즈 공식은 같으니 그대로 이용하면 된다. | . | . | . Loss to follow up(LTF) &#48372;&#51221; . Cohort study나 RCT는 LTF가 생긴다. 일부는 이사가기도 하고, 일부는 연락두절 등 되서 끝까지 follow up 못한다. | 이런 loss까지 반영하여 샘플 사이즈를 좀 더 크게 확보해야한다. | . | LTF가 생기는 매너니즘이 ignorable하다고 가정한다? 중간에 환자를 사라지게 하는 여부 &lt;-&gt; outcome과 관계없다고 가정하는 것 | 이 가정을 이용해서 아래 공식을 통해 샘플 사이즈를 뻥튀기(inflate)한다 N(*) = N / 1-R (R = LTF 비율) 원래 N보다 좀 더 크게 나온다. | . | . | . | 예) 연구에 필요한 환자 수가 100명이어야, 내가 significant level 0.05에서 80% power를 가지고 효과크기를 추정할 수 있다고 결론을 내린 상황 + 약 20%의 환자가 LTF될 것이라고 예측된다면? 100명 모아도 20%는 나가리 될 예정이니 | R = 0.2 -&gt; N(*) = 100/(1-0.2) = 125명을 가지고 시작해야 나중에 100명을 얻을 수 있다. | . | . &#49368;&#54540; &#49324;&#51060;&#51592;&#44032; &#51060;&#48120; &#51221;&#54644;&#51652; &#44221;&#50864; . 관찰연구의 경우 이미 가용한 데이터가 정해져있어서 샘플 사이즈를 바꿀 수 없는 경우가 종종 있다 | 관찰 연구의 경우, 내가 쓸 수 있는 데이터 수가 정해져있다. | observation study에서는 sample size 필요없다고 생각해서 논문을 투고했더니, sample size justification 해서 보내라고 피드백이 올 것이다. | 그런데, 생각해보면, 관찰 연구라도 sample size justification가 필요하다. 이 연구가 애초에 될 연구/안될연구인지 체크하는 정도로 생각하면 된다. | 그러나 이미 정해져있기 때문에 sample size라는 용어대신 power analysis라고 부르는데, | 주어진 sample size + 내가 가정한 효과 크기를 가지고, 내가 몇프로의 power를 가질 수 있는지 계산하는 것이 된다. | 지금까지는 a,b,효과크기 가정 -&gt; sample size 계산 | 관찰연구 a,효과크기 가정, 주어진 sample size -&gt; b를 계산하는 과정이다. | . | 혹은 a, b, 주어진 sample size -&gt; 효과 크기를 추정하는 minimum detectable diffrence도 있다. 최소 요만큼은 효과 크기를 dectect할 수 있다. 실제 효과크기가 요정도 이거나 이것보다 크면, power 80%로 두군간의 차이를 detect할 수 있다고 분석하기도 한다. | . | . | 관찰연구에서 sample size 계산 없이 분석만 했다면? 너무 작은 샘플 사이즈로 분석된 경우 상관관계를 보이는데에 실패했을 경우(p-value 0.05보다 높게 나옴) : 결과 해석이 어렵다 상관관계가 없어서 못 보인 것인지 | 상관관계가 있는데도 데이터 양이 적어서 못보이는 것인지 -&gt; 결론을 내릴 수 없다. | . | 상관관계를 보이는데에 운좋게 성공할 경우(p-value 0.05보다 낮게 나옴): 여러가지 분석 중 유의하게 나온 것만 골라서 보고한 것이 아닌지 의심받을 수 있다 샘플 사이즈가 이렇게 작은데 p-value가 0.05보다 낫게 나왔다면, 조작을 의심할 수 있다. | 여러 위험요소 분석 후 얻어걸린 것을 보고한 것은 아닌지 research integrity(리서치 인테그러티) 의심됨. | . | . | . | . Sample size &#50696;&#51228; . . 대상 모집단: 병원 밖에서 심장 발작으로 구급대원의 치료를 받는 중 정맥주사로 epinephrine을 맞는 환자들 | 실험군 : usual treatment + vasopressin | 대조군 : usual treatment + placebo | 결과변수 : restoration of spontaneous circulation (ROSC) at any time during resuscitation 저절로 순환 및 호흡하는 좋은 event가 결과 변수 | ROSC가 비율이 높을 수록 좋은 것 | . | . . 샘플사이즈 계산 대조군이 30% ROSC라고 가정했다 | 15%의 ROSC change를 detect하기 위해 필요한 sample size를 계산했다. 2군간의 ROSC 차이를 계산했다. | RD = p1-p0 = 0.15라고 했다. 대조군에서는 0.30의 30% ROSC가 있을 것이라고 가정했고 | 실험군에서는 0.45의 45% ROSC가 있을 것이라고 효과 크기를 가정한 것이다. | . | . | 이를 바탕으로 계산했더니 162명의 sample size가 필요하다는 결론을 얻었다. | . | . SampleSize &#44228;&#49328; R &#49892;&#49845; . # - 기본 내장된 함수 power.prop.test()를 쓰면 된다. . ?power.prop.test # power.prop.test(n = NULL, p1 = NULL, p2 = NULL, # sig.level = 0.05, #알파 # power = NULL, # 1-베타 # alternative = c(&quot;two.sided&quot;, &quot;one.sided&quot;), # strict = FALSE, tol = .Machine$double.eps^0.25) . # - 여기서 대조군/실험군이 어떤 것인지는 중요하지 않음. # 이분형 결과변수의 경우, 단측검정이 불가능하다 # -&gt; 양측 검정으로만 해야한다. # -&gt; 카이제곱 검정을 하기 때문에 그렇다. power.prop.test( p1 = 0.45, p2 = 0.3, sig.level = 0.05, power = 0.8, # b=0.2 alternative = &quot;two.sided&quot; ) # 162.3 -&gt; 올림해서 163명으로 해도된다. # 주의할 점은, 각 군에서 필요한 sample size다. # NOTE: n is number in *each* group . Two-sample comparison of proportions power calculation n = 162.3344 p1 = 0.45 p2 = 0.3 sig.level = 0.05 power = 0.8 alternative = two.sided NOTE: n is number in *each* group . # 1) power 계산 # 2) detect할 수 있는 효과크기 (minimum detetable diffrence) 계산이 가능하다. # 1) 고정된 sample size + 가정한 효과크기 -&gt; power를 계산한다 # - power를 제외하고 다른 것들을 채워주면 된다. power.prop.test( p1 = 0.45, p2 = 0.3, sig.level = 0.05, # power = 0.8, # b=0.2 n = 200, alternative = &quot;two.sided&quot; ) # power = 0.8754082 # -&gt; sample size 200명을 가지고 계산하면, power가 87% 정도가 생긴다 . Two-sample comparison of proportions power calculation n = 200 p1 = 0.45 p2 = 0.3 sig.level = 0.05 power = 0.8754082 alternative = two.sided NOTE: n is number in *each* group . # -&gt; 효과크기는 p1,p0에 의해 결정이 되므로 # -&gt; 1가지는 고정해서 채워넣어야한다. # -&gt; 문제에서는 대조군의 ROCS rate가 30%라 했으니, 0.3을 살려놓고 돌려보자. # --&gt; p1을 계산시킨다. power.prop.test( # p1 = 0.45, p2 = 0.3, sig.level = 0.05, power = 0.8, # b=0.2 n = 200, alternative = &quot;two.sided&quot; ) # p1 = 0.1806459 # 대조군에서 30% ROCS를 가정할 시, # -&gt; 치료군에서 ROCS는 18%나 이것보다 작게 나와서 -&gt; 두군간의 차이가 커지면 # --&gt; power 80%를 가지고 sig 0.05에서 두군간의 차이를 detect할 수 있다. # 주의점 # -&gt; 치료군의 ROCS가 높아질 것으로 예상하고 있다( good event라서) # -&gt; 즉, p1이 p2인0.3보다 높아질 것이라고 기대를 했는데, 더 낮게 나왔다 # --&gt; 더 높은 확률을 산출하도록 바꿔야한다 # p1자리에 0.3을 넣어주자. power.prop.test( p1 = 0.3, # p2 = 0.3, sig.level = 0.05, power = 0.8, # b=0.2 n = 200, alternative = &quot;two.sided&quot; ) # p2 = 0.4346572 # 즉, 치료군의 실제 ROCS비율이 43.5%이거나 더 높을 경우, # power 80%를 가지고 sig 0.05에서 두군간의 차이를 detect할 수 있다. . Two-sample comparison of proportions power calculation n = 200 p1 = 0.1806459 p2 = 0.3 sig.level = 0.05 power = 0.8 alternative = two.sided NOTE: n is number in *each* group . Two-sample comparison of proportions power calculation n = 200 p1 = 0.3 p2 = 0.4346572 sig.level = 0.05 power = 0.8 alternative = two.sided NOTE: n is number in *each* group . &#44284;&#51228;2-01&#48264; . 두가지 수술방법의 합병증 비율을 비교하는 임상시험을 하려고 한다. 수술방법 A는 15%의 환자에게 서 합병증이 발생할 것이고 수술방법 B는 5%의 환자에게서 합병증이 발생할 것으로 예상되는 상황 이라고 하자. 두 수술방법의 합병증 비율에 차이가 있다는 것을 유의수준 0.05에서 80% 파워(검정력) 으로 보이려면, 총 몇 명의 환자를 모집해야 하는가? (단, lost-to-follow up이나 결측은 고려하지 않는 다. 계산을 위한 R 코드와 출력결과를 답안에 포함한다.) . n = 200 +200 | α(유의수준) = 0.05 | β = ? | p0 = 0.15 | p1 = 0.05 | . # 1) power 계산 # 2) detect할 수 있는 효과크기 (minimum detetable diffrence) 계산이 가능하다. # 1) 고정된 sample size + 가정한 효과크기 -&gt; power를 계산한다 power.prop.test( p1 = 0.45, p2 = 0.3, sig.level = 0.05, n = 400, alternative = &quot;two.sided&quot; ) . Two-sample comparison of proportions power calculation n = 400 p1 = 0.45 p2 = 0.3 sig.level = 0.05 power = 0.9928852 alternative = two.sided NOTE: n is number in *each* group . &#44284;&#51228;2-02&#48264; . 두가지 수술방법의 합병증 비율을 비교하는 후향적 연구를 하려고 한다. 아직 데이터를 분석하기 전 이지만, 수술방법 A는 15%의 환자에게서 합병증이 발생할 것이고 수술방법 B는 5%의 환자에게서 합병증이 발생할 것으로 예상되는 상황이라고 하자. 연구자가 근무하는 병원에서 A수술을 받은 환자 200명, B수술을 받은 환자 200명, 이렇게 총 400명이 연구 참여에 동의하여 데이터를 수집할 수 있었 다. 두 수술방법의 합병증 비율에 차이가 있다는 것을 유의수준 0.05에서 보이기 위한 파워(검정력)는 얼마인가? (단, lost-to-follow up이나 결측은 고려하지 않는다. 계산을 위한 R 코드와 출력결과를 답안 에 포함한다.) . n = ? | α(유의수준) = 0.05 | β = 0.2 | p0 = 0.15 | p1 = 0.05 | . # - power 계산 power.prop.test( p1 = 0.45, p2 = 0.3, sig.level = 0.05, n = 400, alternative = &quot;two.sided&quot; ) . Two-sample comparison of proportions power calculation n = 400 p1 = 0.45 p2 = 0.3 sig.level = 0.05 power = 0.9928852 alternative = two.sided NOTE: n is number in *each* group . &#44284;&#51228;2-03&#48264; . Propensity score matching을 사용한 연구결과를 보고하는 논문 1편을 조사하여 다음에 답하시오. a. 연구질문(research question)이 무엇인가? | b. 연구에 사용한 결과변수의 정의가 무엇인가? | c. 연구에서 비교한 그룹이 무엇인가? | d. Propensity score 분석 방법을 사용한 이유가 무엇인가? | e. Propensity score를 어떤 방법으로 추정하였는가? | f. 매칭된 데이터의 밸런스를 어떻게 평가하였는가? | g. 매칭 이후 분석은 매칭된 데이터라는 점을 반영하였는가? 반영하였다면 어떤 방법으로 반영하였는가? | h. 연구의 결론이 무엇인가? | . | &#44592;&#53440; &#44256;&#47140;&#49324;&#54637; . &#49368;&#54540; &#49324;&#51060;&#51592;&#47484; &#51460;&#51060;&#44256; &#54028;&#50892;&#47484; &#45720;&#47532;&#45716; &#51204;&#47029; . 누구 샘플 사이즈는 적게 가져가도 충분한 power를 가지길 원한다. . | 연속형 결과변수를 사용한다 . 이분형 결과변수에 비해 훨씬 더 많은 정보를 가지고 있다. 잘 생각해보면, 연속형 변수를 자르면 이분형 변수가 되기 때문 | 이분형 결과변수로 바뀐 순간, cut off보다 높다? 낮다? 의 정보만 가지게 된다. (정확한 값은 모르게 된다.) | . | 같은 샘플 사이즈를 가지더라도 더 높은 power를 가지게 된다. | 같은 power를 달성하는 데에도 더 적은 샘플 사이즈가 필요로 된다. | . | (어쩔 수 없이)이분형 결과변수를 사용할 경우, (되도록이면) 이벤트가 발생하는 확률이 높은 결과변수를 사용한다. (up to 0.5) 확률이 0.5근처에 있을수록 더 좋다 0이나 1에 가까울수록 샘플사이즈가 더 많이 필요로 된다. | . | . 이벤트 발생확률이 높은 고위험군 환자를 연구 | 추적관찰 기간을 늘린다 이벤트가 발생할 확률을 늘인다. | . | | . &#44032;&#49444;&#44160;&#51221;&#51060; &#51452;&#50836;&#48516;&#49437;&#51060; &#50500;&#45772; &#44221;&#50864; . 지금까지는 가설검정 기반(그룹간 비교)의 샘플사이즈 계산만 봐왔다. | 하지만, 임상연구 초반에서는 현상만 설명하는 descriptive study를 하게 된다. 검정이 주목적이 아닌 추정이 주목적이 된다. 예) 우리나라 당뇨병 유병률이 몇퍼센트인가? 추정이 중요하지 그룹간 비교가 중요하지 않다. | . | 이런 경우, 추정의 precision이 샘플 사이즈 선정의 기준이 된다. | . | 추정량에 대한 95% 신뢰구간을 구할 때 신뢰구간의 폭이 좁을 수록 -&gt; 내가 더 추정치에 대해 자신있게 된다. | . | . | sample size와 신뢰구간의 폭의 관계를 가지고 sample size justicfication을 할 수 있게 된다. sample size가 정해진 경우, 이 추정량에 대한 95%의 신뢰구간이 얼마가 될 것으로 추정이 된다.로 justify할 수 있다. | 반대로, 신뢰구간의 폭이 얼마가 되길 원하는데, 필요한 sample size는 n명이다. 그래서 우리는 n명의 데이터를 모았다.로 justify할 수 있다. | . | . Multivariable analysis&#50752; &#49368;&#54540; &#49324;&#51060;&#51592; . 중요한 confounder가 있을 경우, confounder를 반드시 모형에 포함시킨 Multivariable analysis를 실시해야한다. 이럴 경우 모델의 complexity에 걸맞는 sample size를 사용해줘야한다. | 모델이 변수가 많아서 복잡한데, sample size가 작을 경우, overfitting이 발생한다. 모델이 작은 수의 데이터만 설명하고, 비슷한 데이터는 설명 못하게 된다. | . | . | 이분형 결과변수인 경우 사용하는 Multivariable logistic regression의 경우 rule of sum으로서 15×[독립변수의 개수]가 2개 그룹 중 작은 그룹의 환자 수가 최소 이정도는 되어야한다 주로 event발생하는 적은 수의 환자 수 = 15 x 독립변수의 개수 만약, 환자 수가 이것보다 작으면, 환자 수에 비해 모델이 너무 복잡해서 overfitting이 발생하는 것으로 본다. | . | . | . | . Post-hoc power analysis . 이미 데이터 분석을 마쳐서 결론을 얻고, OR를 구하고 x와 y의 상관관계를 구한 상태라고 할 때 여기서 구한 OR + 관측한 sample size를 가지고 -&gt; power를 몇퍼센트 가졌는지 계산하는 것이다. 임상저널의 리뷰어가 하라고 하는 경우가 종종 있다. | 하지만, 이 분석은 통계적으로 타당하지 않으며, 결과가 정해져있기 때문에필요없는 분석이다 | . | . | 필요없고 하면 안되는 분석이다. 왜? 내가 관측한 효과크기에 완전히 의존하는 분석이기 때문이다. 내가 관측한 효과크기가 유의하면 power가 크게 나온다. | 내가 관측한 효과크기가 유의하지 않으면 power도 부족하게 나오기 때문이다. | . | 즉, 내가 계산한 p-value와 Post-hoc power analysis로 계산한 power값이 완전히 1:1대응이 된다. p-value이상의 정보를 제공해주지 못함. | 이미 일어난 사건에 대한 확률을 계산하는 것이라 통계적으로 말이 안되는 분석이다. | . | . | 이 계산을 하지 않겠다 대응하면 된다. | . &#54645;&#49900; &#44256;&#47140;&#49324;&#54637;(&#54620;&#44228;&#51216;) . 한계점 : 샘플 사이즈 계산은 overlay되어있다. 사실은 많은 가정 하에 이뤄지는 예측일 뿐이다 | 우리는 효과크기를 계산해야하는데, 그 효과크기를 모르기 때문에 연구하는 건데, 모르는 값을 가정해놓고 구하는 sample size는 틀릴 가능성이 높다. | . 쉽게 어긋날 수 있다 | 쉽게 ‘조작’할 수 있다 a, b, test종류, 양측검정vs단측검정, samplesize에 비해 바뀌기 때문에, 맞춰서 꾸미기도 쉽다. | . | all-or-nothing의 결정을 내려선 안된다 sample size 구한 것을 절대적으로 생각해선 안된다. | . | | 높은 확률로 성공적인 연구를 수행하기 위하여 주어진 정보를 바탕으로 최선의 결정을 내리기 위한 노력이라고 이해해야한다 | . &#51221;&#47532;&#54616;&#44592; . 유의미한 상관관계를 보일 가능성을 충분히 확보하기 위하여 연구 시작 전 샘플 사이즈를 계산한다 | α는 제1종 오류 확률의 최대허용치이고, β는 제2종 오류 확률이다. 파워는 1-β이다. | 이분형 결과변수의 경우 효과크기는 두 그룹간 event rate의 차이로 결정된다 | 원하는 α와 β값과 어떤 효과 크기를 가정하면, 필요한 샘플 사이즈를 계산할 수 있다 | 가설검정이 주요 검정이 아닌 경우 신뢰구간의 폭을 기준으로 샘플 사이즈를 계산할 수 있다 | Multivariable logistic regression의 경우, 이분형 결과변수로 나누어지는 두 개의 그룹 중 작은 그룹의 환자 수가 적어도 15×[독립변수의 개수] 정도 되어야 한다 | Post-hoc power analysis는 통계적으로 타당하지 않으며, 결과가 정해져 있기 때문에 필요없는 분석이다 | . &#50672;&#49845; &#47928;&#51228; . 01. &#45796;&#51020; &#51473; &#49368;&#54540; &#49324;&#51060;&#51592;&#47484; &#44208;&#51221;&#54616;&#45716; &#50836;&#49548;&#44032; &#50500;&#45772; &#44163;&#51008;? . 목표하는 제1종 오류 확률 . | 목표하는 제2종 오류 확률 . | 귀무가설과 대립가설 . | 눈가림 방법 . | 정답 : 4 | 해설 : 눈가림 방법과 샘플 사이즈 간에는 직접적인 연관이 없다. | . 02 &#45796;&#51020; &#51473; &#51076;&#49345;&#50672;&#44396;&#51032; &#49368;&#54540; &#49324;&#51060;&#51592;&#50640; &#45824;&#54620; &#49444;&#47749;&#51004;&#47196; &#47582;&#45716; &#44163;&#51008;? . 다른 모든 조건을 같게 유지하면서 유의수준 α를 감소시키면, 필요한 샘플 사이즈도 작아진다. . | 다른 모든 조건을 같게 유지하면서 파워를 높이면, 필요한 샘플 사이즈는 작아진다. . | 이분형 결과변수일 때 다른 모든 조건을 같게 유지하면서 실험군과 대조군의 이벤트 확률의 차이를 크게 하면, 필요한 샘플 사이즈도 작아진다. . | 연구에 필요한 환자 수가 100명이고, 연구기간 중 약 20%의 환자가 lost to follow up될 것이라고 예상된다면, 100명 +　２0명 = 120명을 모집해야 한다. . 연구에 필요한 환자 수가 100명이고 약 20%의 환자가 LTF된다고 예상된다면, 100/(1-0.2) = 125명을 모집해야한다. | . | 정답 : 3 | 해설 : 유의수준을 감소시키거나 파워를 높인다는 것은 각각 제1종의 오류, 제2종의 오류를 줄인다는 뜻이므로, 필요한 샘플 사이즈가 늘어난다. 실험군과 대조군의 이벤트 확률 차이가 커지면 두 군간의 차이를 detect하기 더 쉬워지므로, 필요한 샘플 사이즈가 작아진다. | .",
            "url": "blog.chojaeseong.com/r/r%EA%B3%A0%EA%B8%89/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EC%83%98%ED%94%8C%EC%82%AC%EC%9D%B4%EC%A6%88/samplesize/2022/04/04/%EC%9D%98%EC%97%B0%EB%B0%A908)-Sample-Size.html",
            "relUrl": "/r/r%EA%B3%A0%EA%B8%89/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EC%83%98%ED%94%8C%EC%82%AC%EC%9D%B4%EC%A6%88/samplesize/2022/04/04/%EC%9D%98%EC%97%B0%EB%B0%A908)-Sample-Size.html",
            "date": " • Apr 4, 2022"
        }
        
    
  
    
        ,"post83": {
            "title": "while 반복문 -> 재귀함수 변환",
            "content": "반복문(while) to 재귀 . 01 while문 내부 전체로직을 1개메서드로 추출 . . public void run() { final PairProgram pairProgram = new PairProgram(); while (!pairProgram.isOff()) { final Menu menu = Menu.from(inputView.inputMenu()); menu.execute(inputView, outputView, pairProgram); } } . . public void run() { final PairProgram pairProgram = new PairProgram(); while (!pairProgram.isOff()) { start(pairProgram); } } private void start(final PairProgram pairProgram) { final Menu menu = Menu.from(inputView.inputMenu()); menu.execute(inputView, outputView, pairProgram); } . 02 while문을 벗겨내고, 반복되도록 마지막에 한번더 호출한다.(필요연산이 있다면, 재귀함수 파라미터 속에서 변수와 함께) . . public void run() { final PairProgram pairProgram = new PairProgram(); // while (!pairProgram.isOff()) { start(pairProgram); // } } private void start(final PairProgram pairProgram) { final Menu menu = Menu.from(inputView.inputMenu()); menu.execute(inputView, outputView, pairProgram); start(pairProgram); } . 03 while문의 ! 탈출조건을 -&gt; 재귀함수 맨위의 종착역으로서 if 탈출조건 early return;으로 지정해준다. . . public void run() { final PairProgram pairProgram = new PairProgram(); // while (!pairProgram.isOff()) { start(pairProgram); // } } private void start(final PairProgram pairProgram) { if (pairProgram.isOff()) { return; } final Menu menu = Menu.from(inputView.inputMenu()); menu.execute(inputView, outputView, pairProgram); start(pairProgram); } . 04 에러발생시 다시시작하고 싶은 부분(입력부분)부터 try{}로 째려보게 한다. -&gt; 에러안나도 재귀함수는 flag에 걸리기전까지 반복해야하므로 재귀호출부까지 다 째려본다 . . . private void start(final PairProgram pairProgram) { if (pairProgram.isOff()) { return; } try { final Menu menu = Menu.from(inputView.inputMenu()); menu.execute(inputView, outputView, pairProgram); start(pairProgram); } catch (Exception e) { System.out.println(&quot;[ERROR]&quot; + e.getMessage()); start(pairProgram); } } . . 꼬리재귀 . 참고블로그 | . 재귀 사용 이유 . 반복문보다 가독성이 좋다 f(n) = f(n - 1) + f(n - 2) ) : f(n)을 구하기 위해선 f(n - 1), f(n - 2)라는 자기자신의 함수를 인자만 바꾸고 다시 호출해야 한다. | . | 변수가 줄어들어 -&gt; 사이드이펙트가 줄어든다. | 가독성 = 유지보수비용 &gt; 성능유지비용 | 꼬리재귀를 사용하면, 단점인 스택오버플로우를 방지할 수 있다. 실행할 작업을 없애 함수 호출 위치를 저장하지 않도록하여 스택이 넘치는 경우를 방지 | 파일 옵션에서 코드 최적화가 되도록 설정해 주어야 한다. | 꼬리 재귀는 결국 반복문 실행이기 때문에 일반 재귀 함수에서 발생하는 스택 오버 플로우나 성능저하가 발생하지 않는다. | . | 연산을 재귀함수의 인자에서만시행하여 재귀의 업데이트되는 상태변수(count, n)의 시작값 뿐만 아니라 누적연산 등 연산의 초기값도 같이 가져간다. | . | 재귀 작성법 . base case를 input을 0 또는1과 관련지어서 생각한다. . 문제에서 주어진 요구사항 및 예시를 무시하고 0 또는 1과 관련지어서 생각하자 . 예시로 주어진 인풋값을 보고, 어떻게 이걸 답으로 만들지? 라고 생각하면 안 된다. 자꾸 함수 실행 순서를 생각하게 되기 때문이다. | 최대한 재귀적으로 생각하지 않고, 마치 1차원 문제인 것처럼 푸는 게 우리 전략이다. | . 이 때 가장 간단한 인풋값은 0 혹은 1인 경우가 많다. 만약 정수 타입이 들어온다면, 인풋이 0이나 1인 상황을 생각해보자. 만약 배열이 들어온다면? 그러면 배열의 길이가 0인 경우(빈 배열), 배열의 길이가 1인 경우를 생각해보자. 만약 트리가 들어온다면? 인풋값이 nil인 경우, 혹은 자식 노드가 nil(잎 노드)인 경우를 생각해보자. 만약 인풋값이 2차원이라면? 인풋값이 m x n 그리드 (이차원 배열)이라면, 둘 다 0이거나 (m = 0, n = 0), 둘 중 하나가 1이거나 (m = 0, n = 1) (m = 1, n = 0) 둘 다 1인 (m=1, n=1) 케이스를 생각해보자. 0과 1을 사용한 인풋값이 들어왔을 때 즉각 답을 구할 수 있는가? 만약 YES라면, 그게 베이스 조건과, 베이스 조건에서의 결과값이 된다. . | . | 꼬리재귀 연습 . public class MyTest { //https://velog.io/@eddy_song/you-can-solve-recursion @DisplayName(&quot;&quot;) @Test void for_loop() { int sum = 0; // 0부터 100까지 누적합 for (int i = 0; i &lt;= 100; i++) { sum += i; } System.out.println(&quot;sum = &quot; + sum); } @DisplayName(&quot;&quot;) @Test void recursive() { //1. 재귀함수는 일단 메서드를 호출해서 실행하므로, 메서드부터 만든다. // -&gt; 기본적으로 인자는 시행횟수가 들어가서 +1, -1, /2 등으로 업데이트되서 다음 재귀를 호출한다. System.out.println(&quot;recursiveSum(100) = &quot; + recursiveSum(100)); } private int recursiveSum(final int n) { //1. 줄어들면서, input과 0과 1과 관련시켜 가장 간단한 base case를 찾아 문제를 풀어 return하기 // 0 -&gt; 0까지의 합 return 0 // 1 -&gt; 1까지의 합 return 0 + 1 // 2 -&gt; return 0 + 1 + 2 //2. base값에 가까운 윗단계로 input값 조정 후 input(n)과 관련지어 계산하기 // 3 -&gt; 0 + 1 + 2 + 3 = f(2) + n // 0 + 1 까지의 합에서 base는 n=0이 들어오는 경우이다. if (n == 0) { return 0; } return recursiveSum(n - 1) + n; } @DisplayName(&quot;&quot;) @Test void recursive_to_tail() { // recursiveSumByTail(100); //1. 연산(덧셈)의 초기값(0) 또한 파라미터로 건네주어, 인자내에서 연산 후 다음 재귀의 초기값으로 호출되게 한다. System.out.println(&quot;recursiveSumByTail(100, 0) = &quot; + recursiveSumByTail(100, 0)); } private int recursiveSumByTail(final int n, final int acc) { //2. 종착역에서 반환값이 있었다면, 꼬리재귀에서는 해당재귀호출()자체가 최종 값이 되므로 // -&gt; 최종값이 아니라-&gt; 연산의 결과 파라미터를 찍어주면 된다. // -&gt; 종착역에서 연산이 이루어지지 않고 [return 연산변수]로 끝나기 때문에, 종착역을 마지막연산n보다 1개 더갔을 때 연산변수를 반환하도록 한다. // if (n == 0) { // return 0; // return acc; // } // 종착역을 최종연산지점보다 1개 더 주어서 걸리게하고, 직전까지의 계산 = n최종지점까지의연산 의 결과인 acc를 return한다. if (n &lt; 0) { return acc; } return recursiveSumByTail(n - 1, acc + n); } @DisplayName(&quot;&quot;) @Test void zero_to_100_sum_by_tail() { //1. 꼬리재귀는 [횟수관련 초기값] + [연산관련 초기값] 모두를 가지고 들어간다. // - 0부터 시작하고, 덧셈의 초기값은 0이다 System.out.println(&quot;recursiveSumReverse(0, 0) = &quot; + recursiveSumReverse(0, 0)); } private int recursiveSumReverse(final int count, final int acc) { //2. basecase는 0,1과 관련지어서 input을 만들어 풀어주는데, 여기서 종착역은 99, 100이다. // -&gt; 꼬리재귀에서는 종착역을 최종지점(100)을 1단계 넘어서 지정해준다. // -&gt; 직전까지 = 최종지점(100)까지의 [파라미터에서 연산]한 결과물이 [오버지점 파라미터]로 들어왔을 것이니까 그것을 반환해준다. if (count &gt; 100) { return acc; } //3. 횟수변수 및 연산변수를 [파라미터에서 연산 하여 업데이트]해준다. // -&gt; 직전까지의 연산값 acc를 현재n번째 (count) 와 관련시켜 연산해주면 된다. return recursiveSumReverse(count + 1, acc + count); } } .",
            "url": "blog.chojaeseong.com/java/try/catch/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98/%EA%BC%AC%EB%A6%AC%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98/%EC%9E%AC%EC%9E%85%EB%A0%A5/%EC%B2%B4%EC%8A%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/04/%EB%B0%98%EB%B3%B5%EB%AC%B8(while)-to-%EC%9E%AC%EA%B7%80(%EA%BC%AC%EB%A6%AC%EB%AC%B4%EB%8A%94).html",
            "relUrl": "/java/try/catch/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98/%EA%BC%AC%EB%A6%AC%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98/%EC%9E%AC%EC%9E%85%EB%A0%A5/%EC%B2%B4%EC%8A%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/04/%EB%B0%98%EB%B3%B5%EB%AC%B8(while)-to-%EC%9E%AC%EA%B7%80(%EA%BC%AC%EB%A6%AC%EB%AC%B4%EB%8A%94).html",
            "date": " • Apr 4, 2022"
        }
        
    
  
    
        ,"post84": {
            "title": "generic 개인공부 2",
            "content": "참고 유튜브 | . 개념 . 모던 자바(5이후) 가장 대표적인 기술 2가지 제네릭 | 람다 하나 더 추가한다면, 애노테이션 | 애노테이션은 프레임워크 개발자, 라이브러리 개발자들이나 만들 것. 우리가 만들 일은 없다. | . | 코드 작성시 가장 많이 만지는 것 제네릭과 람다 | 잘 활용해야한다. | . | . | . 제네릭과 raw type . 제네릭 -&gt; 사실 타입 파라미터를 사용하면 제네릭이다~! | 제네릭 사용이유 .add() : 컴파일 시점에서, 컴파일에게 타입을 건네주어, 데이터 일관성 있게 모을 때, 정확하게 타입체킹한다. 타입정보를 안주면, List는 T자리에는 Object로 대체하여, 컴파일러가 타입체크를 못해준다. 컴파일러가 몰랐기 때문에, compile에러 대신 runtime시 에러가 난다. | 즉, runtime시에만 발생하는 버그(모은 데이터가 일광성이 없는 버그)를 미리 방지한다. | . | 해당 list에는 어떤 타입만 들어갈지 정해서, 일관성있게 코드를 작성해야하는데, 이런 부분을 도와준다. intellij 빨간줄 -&gt; compile에러 by 제네릭 | . | . | .get(): 1번에서 일관성 없게 모은 Object타입의 list라면? 꺼내서 사용할 때, 매번 다운캐스팅해야한다. 실수 할 수도 있음. 제네릭은 적절한 타입캐스팅(다운캐스팅)을 알아서 해준다. | . | 똑같은 코드 Type만 다른 class를 또 생성할 필요 없다 Type만 바꾼 class재사용이 가능해진다. | . | | raw Type 좁은 것을 타입 파라미터 없는 raw Type List에 할당해주는 것은 가능하지만 그 순간부터 가지고 있던 내용물의 Type을 잃어먹는다. | . | 다시 좁은 쪽으로 할당시키면, 일단 해당 타입 파라미터에 맞게 할당은 되지만 꺼내는 순간부터 가지고 있던 내용물 Type &lt;-&gt; 타입파라미터 타입이 달라 에러가 난다. | . | raw Type을 쓰지마라. 더불어, 컴파일시 Problems에 뜨는 워닝을 그냥 넘어가지마라. 워닝을 체크하고 Build &gt; Rebuild Project로 해결하면서 확인하자. | 상세하게 워닝을 보는 방법은 설정 &gt; java compiler &gt; 추가 파라미터 -&gt; 에러창에 나온 -Xlint등을 붙혀서 다시 컴파일한다. | . | . | . | raw Type으로 중간에 넣어도 컴파일 에러가 안나는 이유 . java 5 제네릭 이전의 코드는 모두 raw Type List이었기 때문에 . 개발자가 체크하고, 변환해서 사용해야한다. . | 개발자가 raw Type List를 좁은 곳으로 할당할 때 생기는 문제인 Unchecked assignment에서는 @SuppressWarning(“unchecked”)로 옛날 코드임을 명시해준다 . final List&lt;Integer&gt; ints = Arrays.asList(1, 2, 3); List rawInts = ints; // 3) 반대의 상황은? // -&gt; raw Type을 -&gt; 다시 변&lt;구&gt;제에 넣으면? @SuppressWarnings(&quot;unchecked&quot;) final List&lt;Integer&gt; ints2 = rawInts; . | . | . | . public class Generics { //2. staic main에 사용할 static 클래스를 만드는데, 클래스 옆에 &lt;T&gt; 뻐금괄호로 [타입파라미터]를 추가한다. // - 타입 파라미터는 type variable로 불린다. 내부에서 변수처럼 T t;로 쓸 수 있기 때문 static class Hello&lt;T&gt; { //6. Hello&lt;T&gt; class에 옆에 선언한 타입 파라미터에 매핑이 되어서 // -&gt; 클래스 내부에서는 1) 필드Type 2) 메서드 파라미터의 Type 3) 메서드 응답Type으로 사용되기도 한다. //new Hello&lt;String&gt;(); -&gt; //1) T t; //2) Object method(T t) {return null;} //3) &lt;T&gt; Obejct method(T t){return null}; } //3. 일반적인 (메서드)파라미터는 파라미터 자리에 신언 -&gt; 밖에서 해당Type의 input(값, 객체)를 넣어준다. static void print(String value) { System.out.println(value); } //1. main메서드 ps vm으로 만들기 public static void main(final String[] args) { //4. print(&quot;Generics&quot;); //5. 타입 파라미터에도 메서드 파라미터와 마찬가지로 실제 뭔가(타입)를 넣어주는데 [타입 인자]라고 한다. // -&gt; 실제 &lt;Type&gt;정보(타입 인자)를 타입 파라미터 T자리에 넣어주면 -&gt; 6. //new Hello&lt;String&gt;(); //type argument //7. 제네릭 사용이유 List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 1) 넣을 때, 컴파일 에러가 나서, 일관성있게 타입체킹을 해준다 //list.add(4) list.add(&quot;str&quot;); // 2) 꺼내서 사용할 때, 매번 다운캐스팅해야한다. 실수 할 수도 있음. //final String s = (String) list.get(0); final String s = list.get(0); //3) 타입만 바꿔서 class재사용이 가능해진다. //8. raw Type?! (구체형 지정했는데 타입파라미터 없이 변수로 받는 경우) // 1) 우항은 호.&lt;구&gt;.제를 해놨는데, -&gt; 변&lt;구&gt;제로 변환없이 -&gt; 좌측 변수는 제네릭 타입 없는 변수(raw Type)에 받는 경우 // -&gt; 괜찮다?! //new ArrayList&lt;Integer&gt;(); List rawList = new ArrayList&lt;Integer&gt;(); // 2) 호&lt;&gt;.구.지 -&gt; 변.&lt;구&gt;.제 를 -&gt; 다시 그대로 제네릭 타입 없는 변수(raw Type)에 할당하는 경우 // -&gt; 괜찮다?! final List&lt;Integer&gt; ints = Arrays.asList(1, 2, 3); List rawInts = ints; // 3) 반대의 상황은? // -&gt; raw Type을 -&gt; 다시 변&lt;구&gt;제에 넣으면? @SuppressWarnings(&quot;unchecked&quot;) final List&lt;Integer&gt; ints2 = rawInts; // Unchecked assignment: &#39;java.util.List&#39; to &#39;java.util.List&lt;java.lang.Integer&gt;&#39; // --&gt; raw Type으로 받는 순간, 다시 어떤 Type인지 모르는 상태가 된다. // --&gt; T상태를 다시 type argument가 있는 곳에 넣어줬으니, // --&gt; Object(우) -&gt; Integer(좌)로 캐스팅해서 넣는 것이다. // &gt; 위험하다. 만약 Object에 integer 들어있는 것을 List&lt;String&gt;에 캐스팅해서 넣으면... @SuppressWarnings(&quot;unchecked&quot;) final List&lt;String&gt; strs = rawInts; // raw type에 들어간 순간, 안에 내용물의 타입은 잊어먹고, 좁은 곳으로 캐스팅되서 들어갈 수 있게 된다. // -&gt; 문제는, type argument에 맞춰서 다운캐스팅되서 들어가 컴파일은 되지만, 꺼내올 때부터 문제가 된다. // --&gt; 내용물은 int, type은 final String s1 = strs.get(0); // class java.lang.Integer cannot be cast to class java.lang.String (java.lang.Integer and java.lang.String are in module java.base of loader &#39;bootstrap&#39;) // at Generics.main(Generics.java:67) } } . 제네릭 메서드 . 인스턴스 메서드 . | 스태틱 메서드 : class level type parameter꺼는 못씀 . class level의 type paramter는 인스턴스 생성시 class&lt;T&gt;의 T가 정해져 사용되기 때문 | . | 생성자 . public class GenericsMethod { //0. class 혹은 interface 옆에 타입파라미터가 붙어서 시작하는 경우도 있지만, static class Hello&lt;T&gt; { } //1. method에서도 타입 파라미터를 붙일 수 있다. // -&gt; String을 파라미터 받아서 출력했었지만 void print(String value) { System.out.println(value); } // --&gt; 이젠 어떤 타입이든 받아서 .toString()으로 출력하면 어떤 타입이든 다 출력된다. // --&gt; 이 때, class, interface옆에 &lt;T&gt;를 붙인 것처럼, [응답형 앞에 &lt;T&gt;를 붙여줘야한다.] &lt;T&gt; void print(T t) { System.out.println(t.toString()); } //3. static 메서드(인스턴스 안만들고 쓰는 메서드)에도 적용가능하다. static &lt;T&gt; void staticPrint(T t) { System.out.println(t.toString()); } //5. 주의!! // class&lt;T&gt; type variable은 -&gt; 해당 class의 인스턴스가 만들어질 때 인자를 받아오게 되는데 // -&gt; static은 인스턴스 만들지를 않고 사용하니, T를 모르는 상태 그대로 // -&gt; static 메서드는, 인스턴스생성때 T를 채우는 class level이 아닌, method level에서 Type parameter를 사용해야한다. // --&gt; class level type paramter로는 사용 불가능했던 static method는 // method level에서는 type paramter를 static method에서 사용 가능하다. //6. class level과 다르게 메서드 level type parameter를 지정하자. static &lt;S&gt; void staticPrint2(S s) { System.out.println(s.toString()); } //7. &lt;,&gt;로 2개 level(class, method)의 Type paramter를 섞어 쓸 수 있다. // -&gt; 1개는 class level, 1개는 method level일 것이다. // 1) method level에 정의한 타입파라미터 -&gt; 메서드 파라미터에서 사용 // 2) class level에 정의한 타입파라미터 -&gt; 메서드 응답형에서 사용 가능 &lt;S, T&gt; T staticPrint3(S s) { System.out.println(s.toString()); return null; } //8. method level 1) 인스턴스메서드 2) 스태틱메서드(new)에 추가로 // -&gt; 3) 생성자에서도 method level type paramter를 쓸 수 있다.(class level과 별개로) public GenericsMethod() {} // 생성자에서도 class level과 별개로 아무Type이나 받을 수 있다. // 생성자는 응답이 없으므로 생성자 메서드앞에 &lt;&gt;를 작성해주면 된다. public &lt;S&gt; GenericsMethod(S s) { } public static void main(final String[] args) { //2. 어떤 타입이든 받아서 출력되는지 확인해보자. new GenericsMethod().print(&quot;Hello&quot;); new GenericsMethod().print(1); //4. method level의 타입파라미터는 static method에도 적용가능하다 GenericsMethod.staticPrint(&quot;Hello&quot;); GenericsMethod.staticPrint(1L); } } . | Bounded Type paratmer : 내부 로직에 의해 제한이 필요한 Type paramter . 다양한 Type을 다 받을 수 있다 -&gt; generic한 method | 내부 알고리즘상 꼭 필요한 제약조건(Comparable을 구현한 Type만 들어와서 비교가능해야함)이 걸고 싶다 -&gt; bound type parameter | . public class GenericBounded { // 0. default로는 타입제한이 없은 &lt;T&gt;가 오지만 &lt;T extends List&gt; 등 // -&gt; Bounded Type parameter ? // 1. 인스턴스 or static(for main) 메서드에서도 쓸 수 있다. // -&gt; 변.&lt;구&gt;.제와 비슷하게, 메서드용 &lt;구체형&gt;제한은, 응답형 앞에 표기하는 &lt;T&gt;에서 해준다. //static &lt;T extends List&gt; void print(T t) {} // 2. bound제한을 줄 때, 1개만 할 수 있따 생각하지만, &amp; 1개로 여러개 형을 줄 수 있다. // -&gt; multiple bound ( 공통으로서 다 만족해야한다. OR옵션은 없다.) //static &lt;T extends List &amp; B &amp; C&gt; void print(T t) {} // -&gt; class가 올 경우는 1개만, interface는 여러개 구현하는 것처럼 여러개 가능 static &lt;T extends List &amp; Serializable &amp; Comparable &amp; Closeable&gt; void print(T t) { } //3. 예시) array + 기준값을 받아서, 기준값보다 큰 것의 갯수 구하기 // -&gt; 제네릭 사용하지 않고, Integer로 fix static long countGreaterThan(Integer[] arr, Integer elem) { return Arrays.stream(arr) .filter(s -&gt; s &gt; elem) .count(); } // 6. type만 다르니 generic method을 도입하자.(구체형 -&gt; T로 변경) // static &lt;T&gt; long genericCountGreaterThan(T[] arr, T elem) { // 10. 내부 비교로직이 들어가는 method level type paramter는 Comparable&lt;T&gt;로 구현한 Type으로 제한을 걸어줘야한다 // -&gt; 이제 genericCountGreaterThan() 인자는 comparable구현하여 비교가능한 애들만 넘어온다. // --&gt; cf) Comparable은 impl시 해당 class형을 제네릭파라미터를 받았었다. -&gt; 여기선 T static &lt;T extends Comparable&lt;T&gt;&gt; long genericCountGreaterThan(T[] arr, T elem) { return Arrays.stream(arr) // 7. 문자는 크기비교를 숫자Type만 가능한 부등호로 비교하고 있었다. //.filter(s -&gt; s &gt; elem) // 8. 숫자 이외에 더 일반적으로 &amp; Type(객체)의 순서를 비교(크기 비교)하려면 // - Comparable &lt;- 이 인터페이스를 작성해서 찾아 들어가서 확인도 같이해보자. //Comparable // - Comparable 구현후 -&gt; 내부 compareTo 라는 메서드를 구현해서 비교할 수 있지만. // - s는 T타입 이라서 .compareTo가 있는지 도 모른다는게 문제다 //.filter(s -&gt; s.compareTo(elem)) //9. 그렇다면 T타입은... 미리 좀 내부에서 Comparable을 구현해서 비교가 되는 놈으로 제한하자 // -&gt; type parameter를 (비교가능한 객체로) 제한하려면? -&gt; bounded type parameter를 쓰면 된다. //11. 이제 s가 bounded type parameter로서 comparable구현Type으로 보장되었다 // -&gt; compareTo가 사용가능하다. 이 return값은 int 1, 0, 1이니.. t/f가 아님을 조심하자. .filter(s -&gt; s.compareTo(elem) &gt; 0) .count(); } public static void main(final String[] args) { final Integer[] integers = {1, 2, 3, 4, 5, 6, 7}; System.out.println(&quot;countGreaterThan(integers, 4) = &quot; + countGreaterThan(integers, 4)); //4. 숫자말고, 다른Type인 문자도 크기 비교가 가능하다~ final String[] strings = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;}; //countGreaterThan(strings) -&gt; 구체형이 fix되어있으니 컴파일 에러 //5. generic 도입을 고민한다. //12. generic + 비교를 위한 bound type paramter가 적용이 끝났으면 사용해보자 // -&gt; string도 String을 찍어서 들어가보면, impl Comparabel&lt;String&gt;을 구현하고 있기 때문이다. System.out.println(&quot;genericCountGreaterThan(strings, &quot;3 &quot;) = &quot; + genericCountGreaterThan(strings, &quot;2&quot;)); } } . | 제네릭과 상속 . 타입 파라미터의 상속관계는, 제네릭 적용 class 상속관계에 아무 영향을 주지 않는다. . | 같은 추상체의 SubType(추상체가 가진 type paramter도 같으면)이면 . 구상체만의 type paramter는 달라고 할당된다. . static class MyList&lt;E, P&gt; implements List&lt;E&gt; {} // final List&lt;String&gt; s1 = new MyList&lt;String, Integer&gt;(); final List&lt;String&gt; s2 = new MyList&lt;String, String&gt;(); . | . | . 제네릭 타입 추론 . java 7이하는 type paramter를 추론 못하는 경우도 있을 수 있다. 이 때는 메서드 호출() 앞에 &lt;Type&gt;를 붙여준다. . | Collections.emptyList(); 같은 경우, 들어가는 parameter가 없기 때문에 추론이 안될 수 있다. -&gt; 메서드앞에 &lt;Type&gt;을 명시해준다. . //java 7이하 타입추론안될 때 명시해주기 final List&lt;String&gt; c = Collections.&lt;String&gt;emptyList(); . | . 제네릭과 와일드카드 . ?: wildcards -&gt; 모르고, 알필요도 없다. | T: 선언시점에서 T는 뭔지 모르지만, 타입 정해지면 그것으로 사용하겠따 . | &lt;?&gt; . &lt;? extends Object&gt;와 동치이다. Object의 기능만 사용한다 . | List&lt;?&gt; : 구상체들 기능은 필요없고, 추상체 List의 기능만 사용한다. . | **명확하게 형을 정해놓는 것에 비해, 아무형이나 올 수 있고, 그 기능은 가장 추상형 기능만 사용한다.( bound 제한있을 시)** . public class GenericsWildcards { static void printList(List&lt;Object&gt; list) { list.forEach(s -&gt; System.out.println(s)); } static void printList2(List&lt;?&gt; list) { list.forEach(s -&gt; System.out.println(s)); } public static void main(final String[] args) { final List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3); // 1. Object-Integer와 달리, List&lt;Object&gt; 와 List&lt;Integer&gt;는 SubType의 관계가 아니므로 인자로 못 넣는다. // - my) 추상형 변수 = 구상형 객체 [할당] == 호출시( 구상형 인자 ) -&gt; 메서드 선언부(추상체 파라미터) 호출이나 마찬가지 // -&gt; 인자 대입은 구상형 -&gt; 내부 파라미터는 추상형으로서, SubType만 올 수 있는데 // --&gt; List&lt;Integer&gt; 인자 -&gt; List&lt;Object&gt; 파라미터는 SubType관계가 아니므로 들어갈 수 없다. // --&gt; 즉, integer는 Object의 서브타입이지만, 리스트integer는 리스트object의 서브타입이 아니므로 호출시 대입 불가능 // -&gt; 명확하게 &lt;형&gt;을 정해놓으면, SubType만 할당/대입 가능하다!!! //printList(integers); //compile Error //2. ? 와일드카드는 명확하게 어떤형X, 어떤 형이든 상관없이 받아서, 추상형의 기능만 이용한다. printList2(integers); } } . | . | 와일드카드 제한점?! . public class GenericsWildcards { static void printList(List&lt;Object&gt; list) { list.forEach(s -&gt; System.out.println(s)); } static void printList2(List&lt;?&gt; list) { list.forEach(s -&gt; System.out.println(s)); } //3. class 2개를 만들어보자 static class A { } static class B extends A { } public static void main(final String[] args) { final List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3); // 1. Object-Integer와 달리, List&lt;Object&gt; 와 List&lt;Integer&gt;는 SubType의 관계가 아니므로 인자로 못 넣는다. // - my) 추상형 변수 = 구상형 객체 [할당] == 호출시( 구상형 인자 ) -&gt; 메서드 선언부(추상체 파라미터) 호출이나 마찬가지 // -&gt; 인자 대입은 구상형 -&gt; 내부 파라미터는 추상형으로서, SubType만 올 수 있는데 // --&gt; List&lt;Integer&gt; 인자 -&gt; List&lt;Object&gt; 파라미터는 SubType관계가 아니므로 들어갈 수 없다. // --&gt; 즉, integer는 Object의 서브타입이지만, 리스트integer는 리스트object의 서브타입이 아니므로 호출시 대입 불가능 // -&gt; 명확하게 &lt;형&gt;을 정해놓으면, SubType만 할당/대입 가능하다!!! //printList(integers); //compile Error //2. ? 와일드카드는 명확하게 어떤형X, 어떤 형이든 상관없이 받아서, 추상형의 기능만 이용한다. printList2(integers); //4. final List&lt;B&gt; bList = new ArrayList&lt;&gt;(); // 4-1. A 이하의 SubType형 list를 받을 수 있게하고, List&lt;B&gt;를 넣었더니.. List&lt;? extends A&gt; la = bList; // 4-2. 호.&lt;구&gt;.지로 완전 내부가 바꼈나??? A를 add하면 compile error //la.add(new A()); //compile Error // 4-3. 그렇다고 치기엔, B도 add가 안된다. //la.add(new B()); // 4-4. 와일드카드의 제한점으로서... add는 null밖에 안된다. -&gt; why? la.add(null); } } . | . 심화 . type paramter를 필요로 하는, 제네릭 메서드의 파라미터(List&lt; &gt;)에 대해 Type Paramter 적용 vs WildCards 적용 . Type Paramter 적용 . 와일드카드를 적용한 것과 다르게 . 한번 정의된 type parameter는 추가 파라미터, body내부 인스턴스 변수, 응답 값 등 메서드 내부 다양한 곳에서 T를 활용할 수 있다. . //1. type paramter를 메서드 파라미터(List&lt; &gt;)에 사용한 경우 static &lt;T&gt; void method1(List&lt;T&gt; list) { } . //1. type paramter를 메서드 파라미터(List&lt; &gt;)에 사용한 경우 static &lt;T&gt; T method1(List&lt;T&gt; list, T t) { // 1) 메서드파라미터 // 2) 내부 인스턴스 변수의 Type T value; // 3) 응답Type으로도 type paramter를 활용할 수 있다. return null; } . | . | . unbounded WildCards 적용 . 내부에서 활용할 수 도 없는 와일드 카드를 type paramter로 왜 사용하는 것일까? . static void method2(List&lt;?&gt; list) { } . | . 컬렉션를 받고 싶다면, 컬렉션&lt;?&gt; 와일드카드를 이용해야한다. . List&lt;Object&gt;로 형이 명시된 경우, List&lt;SubType&gt;의 자손이 아니므로 파라미터가 인자를 받을 수 없게 됨. List&lt;?&gt;는 List&lt;Obejct의 SubType&gt; 아무거나 다 받을 수 있다. | . | . | 그러나 unbound wild card인 &lt;?&gt;사용시에는 제약이 있다. . 특정 Type의 값을 add등 넣지 못한다. . | 특정 Type의 원소들과 관련된 기능은 사용못하고 -&gt; 가장 추상체List, Object만의 기능만 사용한다. . static void method2(List&lt;?&gt; list) { //3.그러나 `unbound wild card`(extends 등 사용안한 것)인 `&lt;?&gt;`사용시에는 제약이 있다. //3-1. 해당 자료구조에 구체적인 Type의 값(객체)을 넣을 수 없다. // -&gt; 해당 자료구조에는 null만 넣을 수 있다. //list.add(&quot;1&quot;); //compile error //list.add(1); //compile error //list.add(null); // runtime UOE error //3-2. 가장 추상체 = List만의 기능 + Object만의 기능만 사용가능하며, 각 Type의 원소들과 관련된 기능은 사용 못한다. //3-2-1. List만의 기능 //list.clear();// runtime UOE error list.size(); final Iterator&lt;?&gt; iterator = list.iterator(); //3-2-2. Object만의 기능 list.toString(); list.equals(null); } . | | unbound wild card 사용 예시1 . list를 받아 비어있으면 true반환하는 isEmpty() . | list의 원소가 어느type이든, 어떤 종류의 list라도 받을 수 있게 &lt;T&gt; 와일드카드로 파라미터 지역변수를 지정해주자 . . private static &lt;T&gt; boolean isEmpty(final List&lt;T&gt; list) { return list.size() == 0; } . | 메서드 파라미터속 type parameter T를 내부에서 사용하지 않았다면, T -&gt; 언바운드 wild card로 바꿀 수 있다. . //메서드 파라미터속 type parameter T를 내부에서 사용하지 않았다면 // -&gt; 타입 파라미터 대신 와일드카드를 적용시킬 수 있다. // -&gt; (타입파라미터 안쓰면 -&gt; 응답형 앞에 명시한 것도 삭제해주기) private static boolean isEmpty(final List&lt;?&gt; list) { return list.size() == 0; } //4. unbound wild card 사용 예시를 들기 위해 // -&gt; 어느 list를 받아 비어있으면 true를 반환하는 isEmpty()를 만든다 가정한다. final List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3, 4, 5); System.out.println(isEmpty(integerList)); . | | 지네릭 메소드를 쓰는 이유: 지네릭 type parameter로 정의된 T type의 원소에 관심 있어, 메서드 내부 T를 사용해야만 하는, add/remove/set 원소단위로 기능이 들어가는 경우 . | 지네릭 메소드 대신 와일드카드를 쓰는 이유: 자료구조 속 원소에는 관심X -&gt; List단위로서의 기능만 + Object의 기능만 쓸 경우 . | unbound wild card 사용 예시2 . frequnecy( list, 3) -&gt; 특정 원소가 몇번 중복되어있는지 . . . | List의 원소 Type, 개별원소Type 모두 T로 대체해준다. . private static &lt;T&gt; long frequency(final List&lt;T&gt; list, final T elem) { return list.stream() .filter(s -&gt; s.equals(elem)) .count(); } . | 빈도 검사에서도 내부에서 T가 안쓰였으니.. 와일드카드로 변환이 가능할 것 같은데 . type parameter를 정의하는 곳에만 들어갈 수 있다. | 컬렉션&lt;T&gt;의 파라미터 변수는 컬렉션&lt;Object&gt;로 컬렉션&lt;Subtype&gt;을 받을 수 없지만, 단일 TypeParameter는 추상-구상 SubType관계가 유지되므로 Object로 어느 타입이든 받는 T를 대신할 수 있다. 즉 메서드 파라미터 속 T t -&gt; ? t(X) -&gt; Object t (O)로 바꿔도 된다! | . | . . . | 내부 로직에서 사용되는 메서드를 봐도 . equals -&gt; Object에 정의된 기능 -&gt; ?로 변환 가능! | 와일드카드의 사용법 중에 1가지는 Object에 정의된 기능은 사용 허용!이다 | . private static long frequency(final List&lt;?&gt; list, final Object elem) { return list.stream() .filter(s -&gt; s.equals(elem)) .count(); } //5. 빈도를 세는 것(list + 개별원소)도 내부에서는 개별원소 기능이 없다 -&gt; filter + equals기능만 사용 -&gt; 지네릭 메서드 대신 와일드카드로 final List&lt;Integer&gt; duplicateIntegerList = Arrays.asList(1, 2, 3, 4, 5, 3, 2); System.out.println(&quot;frequency(duplicateIntegerList, 3) = &quot; + frequency(duplicateIntegerList, 3)); . | | bounded WildCards 적용 . max 메서드 생성 . . | 원래는 integer로 시작해서 T로 변환해야하지만, 바로 제네릭 메서드로 작성해보자. . stream을 이용해서 max를 구한다면 . loop -&gt; 제일 작은 초기값 세팅후 -&gt; 업데이트 방식과 다르게 | reduce의 초기값 없이 바로 BinaryOperator 사용방식으로, 누적해서 2개의 값씩 비교해나간다 | . | optional반환인데 값만 강제로 꺼내고 싶다면 .get()을 때리면 된다. . 만약 Optional에서 .get()으로 값을 못꺼낸 상황일 땐, NoSuchElementException을 낸다. | . //2. 원래는 Integer부터 만들어야 정상이지만, 제네릭을 계속 썼다보니 제네릭 메소드로 만들어보자. //private static &lt;T&gt; void max(final List&lt;T&gt; list) { //2-2. 제네릭 메서드의 type parameter에서 upper bound는 파라미터 자리가 아닌 [응답형 앞]에서 준다. private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;T&gt; list) { return list.stream() //2-1. max를 loop를 구할 땐, 가장 작은값을 후보 변수에 세팅 -&gt; 계속 업데이트하면서 구하는데, stream으로는? // -&gt; reduce의 2번째 방식(초기값 identity 따로 안주고 첫+둘 -&gt; 합+셋 -&gt; 순으로 연산 하기위해)으로 작성해보자. // -&gt; 연산후 연산결과의 Type이 현재 원소들과 같은 Type으로 되돌려줘야한다. // -&gt; 누적해가면서 &lt;2변수를 비교후 큰값을 남기기&gt;가 max값이다. // --&gt; Integer였다면 a &gt; b ? a : b 의 3항연산자를 써서 (비교후 t/f별 return) 했을 것이다. //.reduce((a,b) -&gt; a &gt; b ? a : b) // -&gt; 하지만, 제네릭을 통해 아무Type T -&gt; [부등호를 통한 숫자비교]이외의 비교를 위해서 // --&gt; Comparable 구현으로 제한한 Type에 대해 compareTo로 비교한다. .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) //2-3.stream에 원소가 없을 경우 optional로 반환하는데, get()을 통해 값만 강제로 꺼낼 수 도 있다. // -&gt; 값이 없는데 get을 시도했을 때 예외가 발생하는데, 이것은 자연스런 예외라고 생각할 수 있다. // NoSuchElementException: No value present // default값이나 or 특정예외를 발생시키는 코드를 작성안해도, 없는 값 get시도시 예외는 자연스러운 것으로 봐도 된다. .get(); } . | . | 내부T 안쓴 것처럼 보이지만, stream -&gt; 개별 원소 접근 -&gt; T쓴 것 과 마찬가지로 wildcard로 변환 불가능.의 상태이다. 하지만, wild cards가 개입될 여지가 있다. . wild card 도입 전 . private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;T&gt; list) { return list.stream() .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) .get(); } . | stream 아니였으면, 내부 T를 사용 -&gt; wildcard로 변환은 불가능한 상태 . T currentMax = list.get(0); for (final T t : list) { if (t.compareTo(currentMax)&gt;0) { currentMax = t; } } return currentMax; . | . | 내부에 개별원소 T의 사용으로 &lt;?&gt; 대신 &lt;T&gt;의 제네릭 메서드로 정해졌어도 . 내부에서 사용되는 파라미터 속 컬렉션의 type parameter는 upper bound with ?으로 수정가능하고 | 외부에서 사용되는 응답형 앞의 Comparable&lt;T&gt; type paramter는 lower bound with ?로 수정 가능하다 | . //3. 내부T 안쓴 것처럼 보이지만, stream -&gt; 개별 원소 접근 -&gt; T쓴 것 과 마찬가지로 wildcard로 변환 불가능.의 상태이다. //3-1. 비교메서드compareTo() 의 사용은 T type 원소뿐만 아니라, T의 SubType들도 인자로 들어와 비교될 수 있다. // 비교메서드의 인자뿐만 아니라 컬렉선&lt;T&gt;에서 각 원소가 [메서드 내부에서 사용=소모]되는 경우라면 [와일드카드를 사용한 upper bound type paramter]로 넘긴다는 가이드라인 있다. // -&gt; 메서드 파라미터의 [개별 원소가 메서드 내부에 사용되는 컬렉션의 type parameter] List&lt;T&gt; -&gt; List&lt;? extends T&gt; // private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;T&gt; list) { //3-2. 반대로, Comparable&lt;T&gt;에 걸린 T는 메서드내부에서 정해져 사용되지 않고, 메서드 밖에서 사용되는 Type paramter라서 // -&gt; lower bound로 정의해준다. // private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;? extends T&gt; list) { private static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(final List&lt;? extends T&gt; list) { return list.stream() .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) .get(); } . | wild card로 정의 가능하다면 지네릭 메소드 대신 와일드카드로 메서드 작성하는 이유 . oracle문서: T type parameter의 지네릭 메소드는 내부 로직에 T type을 사용해서 처리하겠다라는 의미가 담겨있다고 한다. Type parameter는 내부 구현이 노출이 된다. | . | 와일드 카드로 작성을 권장한다. | . 와일드카드를 사용한 상태에서 비교를 위한 compareTo 사용을 위해 bound wild card인 &lt; ? extends Comparable&gt;은 허용한다. 하지만 메서드 내부에 T를 이용하느 코드가 나온다면, 응답형 앞에 T를 &lt;T extends Comparable&gt;로 바꿔주면 된다. . private static boolean isEmpty(final List&lt;?&gt; list) { return list.size() == 0; } private static boolean isEmpty2(final List&lt;? extends Comparable&gt; list) { return list.size() == 0; } private static &lt;T extends Comparable&gt; boolean isEmpty3(final List&lt;T&gt; list) { return list.size() == 0; } . PECS는 사실… 메서드내부 사용되는 T는 E / 메서드외부에서 사용되는 T는 S 이다. . 어느타입의 List든 List&lt;T&gt;를 받아 max(list)를 구현 . reduce로 누적하여 연산하되, 둘중에 큰 값만 남기도록 한다. . 초기값 없이 바로 BinaryOperator작성하여, 1과2 -&gt; 연산값과 3번째, … , | 매번 연산값은 첫번째 요소와 동일한 Type이 되어야한다. | 둘 중에 큰 값만 남겨 return해야하므로 삼항연산자를 활용했다. | . | Integer로 시작했었지만, Number Type 이외의 값도 비교해야하므로 . 들어오는 T에 대해 응답형앞에서 &lt;T extends Comparable&lt;T&gt;&gt;로 Comparable 인페를 구현한 Type으로 bound한다. | . private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;T&gt; list) { return list.stream() //2-1. max를 loop를 구할 땐, 가장 작은값을 후보 변수에 세팅 -&gt; 계속 업데이트하면서 구하는데, stream으로는? // -&gt; reduce의 2번째 방식(초기값 identity 따로 안주고 첫+둘 -&gt; 합+셋 -&gt; 순으로 연산 하기위해)으로 작성해보자. // -&gt; 연산후 연산결과의 Type이 현재 원소들과 같은 Type으로 되돌려줘야한다. // -&gt; 누적해가면서 &lt;2변수를 비교후 큰값을 남기기&gt;가 max값이다. // --&gt; Integer였다면 a &gt; b ? a : b 의 3항연산자를 써서 (비교후 t/f별 return) 했을 것이다. //.reduce((a,b) -&gt; a &gt; b ? a : b) // -&gt; 하지만, 제네릭을 통해 아무Type T -&gt; [부등호를 통한 숫자비교]이외의 비교를 위해서 // --&gt; Comparable 구현으로 제한한 Type에 대해 compareTo로 비교한다. .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) //2-3.stream에 원소가 없을 경우 optional로 반환하는데, get()을 통해 값만 강제로 꺼낼 수 도 있다. // -&gt; 값이 없는데 get을 시도했을 때 예외가 발생하는데, 이것은 자연스런 예외라고 생각할 수 있다. // NoSuchElementException: No value present // default값이나 or 특정예외를 발생시키는 코드를 작성안해도, 없는 값 get시도시 예외는 자연스러운 것으로 봐도 된다. .get(); } . | . | (stream안썼으면) 내부에서 T가 사용되는 상황(stream으로는 개별원소에 접근하는 상황)이므로 &lt;T&gt; 대신 &lt;?&gt; = 추상체 자체기능 + Object의기능만 사용은 불가능한 지네릭 메소드여야만 한다 . 하지만 와일드카드가 끼어들만 여지가 남겨져있다 | . private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;T&gt; list) { return list.stream() .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) .get(); } . | 위에서 보는 것처럼 . 내부에서 개별적으로 사용되는 메서드 파라미터 속 List&lt;T&gt;에서의 T는 a.비교메서드( b )에서 a와 b 자리에는 T type대신 SubType도 들어가서 비교될 수 있기 때문에 T의 subtype을 의미하는 List&lt;? extends T&gt;를 대신사용할 수 있다. . | 외부 Comparable 클래스에서 compareTo정의시 사용될 Comparable&lt;T&gt;의 T는 비교메서드를 구성하는 Type이라고 볼 수 있다. . Integer끼리의 비교는 a - b 처럼 compareTo가 간단하게 구성될지 몰라도 | 어느타입이든 비교되려면, Object객체 2개를 비교할 수 있는 compareTo가 만들어져야한다. | 그래서 Comparable처럼 외부에서 사용될 T는 T에 대해 SuperType으로 구성되어도 된다. | . private static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(final List&lt;? extends T&gt; list) { return list.stream() .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) .get(); } . | | 바깥에서 쓰는 T의 대한 예시 -&gt; Collections.max( list , comparator) . public static void main(final String[] args) { final List&lt;Integer&gt; list = Arrays.asList(1, 2, 3); //4. 바깥에서 쓰일 Comparable&lt;T&gt;의 T는 &lt;T extends Comparable&lt;? super T&gt;&gt;처럼 SuperType이 들어가도 된다?? 를 증명해보기 // 4-1. List 예시는, 자체 comparator가 내부에 내장 되어있어, Comparable를 구현안해도 알아서 집계함수내에서 집계된다. System.out.println(&quot;Collections.max(list) = &quot; + Collections.max(list)); // 4-2. 이번엔 비교대상obj의 class가 직접 Comparable을 구현하는 것이 아니라, // 한 단계 위층에서, 직접 2개의 원소를 받아 비교가능하도록 만드는 비교자 Comparator인터페이스를 만드는 경우 // 집계메서드의 다음인자로 만들어서 던진다. //Collections.max(list, Comparator) //Comparator의 내부 구현을 보기 위해 잠시 적어두고 타고 들어갔다옴. // -&gt; Comparator은 인터페이스로 증 @FunctionalInterface로서, 외부에서 인자를 던질 때, 람다식으로 구현가능하다. // --&gt; int compare(T o1, T o2); 파라미터 2개 -&gt; (a,b)로 시작 &amp;&amp; 응답 int -&gt; 1개 int로 나오도록 람다식 마무리 //Collections.max(list, (a, b) -&gt; a - b ); // &gt; 그러나, T 타입을 받아 비교하도록 되어있으므로 [람다식의 Type paramter 다운? 캐스팅]을 사용할 수 있다. // cf) 람다식은 타입을 캐스팅할 수 있는 것이 장점이라고 한다. // -&gt; Integer List의 원소들끼리 비교라면, Compator&lt;Integer&gt;로 람다식의 T타입을 캐스팅해서 쓰면 되지만 // 여기에서는 지네릭 -&gt; 모든 타입 -&gt; Object로 [람다식 타입 캐스팅]을 시도하여 obj vs obj 비교가 가능하게 한다. // --&gt; 이렇게 되면, object - object 의 부등호 비교가 말을 안듣게 된다. //Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a - b); // a-b error! // &gt; a와 b가 integer가 아니라 object가 되었다고 가정하고 // **object의 공통 .toString()**을 통해 compareTo로 비교한다고 가정하고 작성한다. Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString())); // a-b error! //4-3. 이렇게 2개의 obj로 비교하는 Comparator 인터페이스 구현체를 람다식타입캐스팅해서 인자로 던졌는데 잘 동적을 한다 System.out.println( &quot;Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString())) = &quot; + Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString()))); // 4-4. 여기서 하고 싶은말은, Comparable or Comparator에 붙은 &lt;T&gt;는 비교할 객체 2개의 type이며 // -&gt; 그 T에는 SuperType이 와도 된다는 이야기를 하고싶은 것 // --&gt; 하위 경계만 list의 T인 Integer로 잡혀있을 뿐 -&gt; ? super T 로서, Integer의 SuperType이 와도 된다. //5. 이제 Comparable&lt; ? super T&gt;를 통해 -&gt; compareTo를 사용할 객체는 T보다 더 SuperType 특히, Object를 줘도 가능하다는게 밝혀졌다. // -&gt; Comparable내부 구조를 object. 비교메서드 ( object )로 바꿔놓은 상태다. // 그렇다면, max(final List&lt;? extends T&gt; list) 에서 list의 원소는 [비교될 객체 a, b자리에 구현체 SubType이 들어갈 수 있다]는 어떻게 확인할까? // -&gt; 비교 구조는 SuperType 특히, Object1. 비교메서드 ( Object 2)로 잡힌 상태로서, // --&gt; 각각의 Object1, 2 자리에 SubType(구현체)가 들어가는 것은 자연스러운 일로 이해할 수 있다. // -&gt; SubType의 원소가 비교메서드 자리에 들어갈 수 있는지 판단하려면 // &gt; max()함수의 T를 Integer의 추상체인 Number로 고정시켜 호출하면, // 파라미터속 T -&gt; NumberType인데, 인자로 던진 Integer 타입이 들어가도 잘 동작하는 것을 확인할 수 있다. System.out.println( &quot;Collections.&lt;Number&gt;max(list, (Comparator&lt;Object&gt;)(a,b) -&gt; a.toString().compareTo(b.toString())) = &quot; + Collections.&lt;Number&gt;max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString()))); //6. 어떨때는 upper bound? 어떨때는 under bound? -&gt; java에서 설명하는 기준이 있다. // 1) 넘기는 파라미터 type이 메서드 내부에서 사용되는 경우 -&gt; 상위경계(upper bound)를 쓰면 되고 // 2) 외부에서 정의되는 메서드에 사용될 경우 ex&gt; Comparable내부에서 사용될 T -&gt; 하위 경계(under bound)를 쓰면 된다. // -&gt; 가장 잘보여주는 예가 Collections 내부의 copy()메서드다 // cf) alt+7(Structure)에서 ctrl+f에서 찾아보기 // public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) { // 소스 src는 안에서 copy메서드 내부에서 소모되는 것이므로 &lt;? extends T&gt; 구현체 와도 된다. // 데스티네이션 dest는 copy메서드 내부에서 [만들어진 뒤 밖으로 내보내 사용 될 것] -&gt; 구조를 추상체로 잡아주도록 &lt;? super T&gt;로 와일드카드를 준다. // - 안에서 만들어지긴 하지만 ouput으로서 밖에서 사용되는 것임. /// 3) 귀찮으면, 잘모르겠으면 그냥 &lt;T&gt;로만 지정해서 쓰면 된다.. } . | public class GenericsWildCard { public static void main(final String[] args) { final List&lt;Integer&gt; list = Arrays.asList(1, 2, 3); //1. list가 들어오면 그 원소들 중 가장 큰 값을 반환하도록 한다. 만든다. System.out.println(&quot;max(list) = &quot; + max(list)); //4. 바깥에서 쓰일 Comparable&lt;T&gt;의 T는 &lt;T extends Comparable&lt;? super T&gt;&gt;처럼 SuperType이 들어가도 된다?? 를 증명해보기 // 4-1. List 예시는, 자체 comparator가 내부에 내장 되어있어, Comparable를 구현안해도 알아서 집계함수내에서 집계된다. System.out.println(&quot;Collections.max(list) = &quot; + Collections.max(list)); // 4-2. 이번엔 비교대상obj의 class가 직접 Comparable을 구현하는 것이 아니라, // 한 단계 위층에서, 직접 2개의 원소를 받아 비교가능하도록 만드는 비교자 Comparator인터페이스를 만드는 경우 // 집계메서드의 다음인자로 만들어서 던진다. //Collections.max(list, Comparator) //Comparator의 내부 구현을 보기 위해 잠시 적어두고 타고 들어갔다옴. // -&gt; Comparator은 인터페이스로 증 @FunctionalInterface로서, 외부에서 인자를 던질 때, 람다식으로 구현가능하다. // --&gt; int compare(T o1, T o2); 파라미터 2개 -&gt; (a,b)로 시작 &amp;&amp; 응답 int -&gt; 1개 int로 나오도록 람다식 마무리 //Collections.max(list, (a, b) -&gt; a - b ); // &gt; 그러나, T 타입을 받아 비교하도록 되어있으므로 [람다식의 Type paramter 다운? 캐스팅]을 사용할 수 있다. // cf) 람다식은 타입을 캐스팅할 수 있는 것이 장점이라고 한다. // -&gt; Integer List의 원소들끼리 비교라면, Compator&lt;Integer&gt;로 람다식의 T타입을 캐스팅해서 쓰면 되지만 // 여기에서는 지네릭 -&gt; 모든 타입 -&gt; Object로 [람다식 타입 캐스팅]을 시도하여 obj vs obj 비교가 가능하게 한다. // --&gt; 이렇게 되면, object - object 의 부등호 비교가 말을 안듣게 된다. //Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a - b); // a-b error! // &gt; a와 b가 integer가 아니라 object가 되었다고 가정하고 // **object의 공통 .toString()**을 통해 compareTo로 비교한다고 가정하고 작성한다. Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString())); // a-b error! //4-3. 이렇게 2개의 obj로 비교하는 Comparator 인터페이스 구현체를 람다식타입캐스팅해서 인자로 던졌는데 잘 동적을 한다 System.out.println( &quot;Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString())) = &quot; + Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString()))); // 4-4. 여기서 하고 싶은말은, Comparable or Comparator에 붙은 &lt;T&gt;는 비교할 객체 2개의 type이며 // -&gt; 그 T에는 SuperType이 와도 된다는 이야기를 하고싶은 것 // --&gt; 하위 경계만 list의 T인 Integer로 잡혀있을 뿐 -&gt; ? super T 로서, Integer의 SuperType이 와도 된다. //5. 이제 Comparable&lt; ? super T&gt;를 통해 -&gt; compareTo를 사용할 객체는 T보다 더 SuperType 특히, Object를 줘도 가능하다는게 밝혀졌다. // -&gt; Comparable내부 구조를 object. 비교메서드 ( object )로 바꿔놓은 상태다. // 그렇다면, max(final List&lt;? extends T&gt; list) 에서 list의 원소는 [비교될 객체 a, b자리에 구현체 SubType이 들어갈 수 있다]는 어떻게 확인할까? // -&gt; 비교 구조는 SuperType 특히, Object1. 비교메서드 ( Object 2)로 잡힌 상태로서, // --&gt; 각각의 Object1, 2 자리에 SubType(구현체)가 들어가는 것은 자연스러운 일로 이해할 수 있다. // -&gt; SubType의 원소가 비교메서드 자리에 들어갈 수 있는지 판단하려면 // &gt; max()함수의 T를 Integer의 추상체인 Number로 고정시켜 호출하면, // 파라미터속 T -&gt; NumberType인데, 인자로 던진 Integer 타입이 들어가도 잘 동작하는 것을 확인할 수 있다. System.out.println( &quot;Collections.&lt;Number&gt;max(list, (Comparator&lt;Object&gt;)(a,b) -&gt; a.toString().compareTo(b.toString())) = &quot; + Collections.&lt;Number&gt;max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString()))); //6. 어떨때는 upper bound? 어떨때는 under bound? -&gt; java에서 설명하는 기준이 있다. // 1) 넘기는 파라미터 type이 메서드 내부에서 사용되는 경우 -&gt; 상위경계(upper bound)를 쓰면 되고 // 2) 외부에서 정의되는 메서드에 사용될 경우 ex&gt; Comparable내부에서 사용될 T -&gt; 하위 경계(under bound)를 쓰면 된다. // -&gt; 가장 잘보여주는 예가 Collections 내부의 copy()메서드다 // cf) alt+7(Structure)에서 ctrl+f에서 찾아보기 // public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) { // 소스 src는 안에서 copy메서드 내부에서 소모되는 것이므로 &lt;? extends T&gt; 구현체 와도 된다. // 데스티네이션 dest는 copy메서드 내부에서 [만들어진 뒤 밖으로 내보내 사용 될 것] -&gt; 구조를 추상체로 잡아주도록 &lt;? super T&gt;로 와일드카드를 준다. // - 안에서 만들어지긴 하지만 ouput으로서 밖에서 사용되는 것임. /// 3) 귀찮으면, 잘모르겠으면 그냥 &lt;T&gt;로만 지정해서 쓰면 된다.. } //3. 내부T 안쓴 것처럼 보이지만, stream -&gt; 개별 원소 접근 -&gt; T쓴 것 과 마찬가지로 wildcard로 변환 불가능.의 상태이다. //3-1. 비교메서드compareTo() 의 사용은 T type 원소뿐만 아니라, T의 SubType들도 인자로 들어와 비교될 수 있다. // 비교메서드의 인자뿐만 아니라 컬렉선&lt;T&gt;에서 각 원소가 [메서드 내부에서 사용=소모]되는 경우라면 [와일드카드를 사용한 upper bound type paramter]로 넘긴다는 가이드라인 있다. // -&gt; 메서드 파라미터의 [개별 원소가 메서드 내부에 사용되는 컬렉션의 type parameter] List&lt;T&gt; -&gt; List&lt;? extends T&gt; // private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;T&gt; list) { //3-2. 반대로, Comparable&lt;T&gt;에 걸린 T는 메서드내부에서 정해져 사용되지 않고, 메서드 밖에서 사용되는 Type paramter라서 // -&gt; lower bound로 정의해준다. // private static &lt;T extends Comparable&lt;T&gt;&gt; T max(final List&lt;? extends T&gt; list) { private static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(final List&lt;? extends T&gt; list) { return list.stream() .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) .get(); } //2. 원래는 Integer부터 만들어야 정상이지만, 제네릭을 계속 썼다보니 제네릭 메소드로 만들어보자. //private static &lt;T&gt; void max(final List&lt;T&gt; list) { //2-2. 제네릭 메서드의 type parameter에서 upper bound는 파라미터 자리가 아닌 [응답형 앞]에서 준다. private static &lt;T extends Comparable&lt;T&gt;&gt; T max2(final List&lt;T&gt; list) { return list.stream() //2-1. max를 loop를 구할 땐, 가장 작은값을 후보 변수에 세팅 -&gt; 계속 업데이트하면서 구하는데, stream으로는? // -&gt; reduce의 2번째 방식(초기값 identity 따로 안주고 첫+둘 -&gt; 합+셋 -&gt; 순으로 연산 하기위해)으로 작성해보자. // -&gt; 연산후 연산결과의 Type이 현재 원소들과 같은 Type으로 되돌려줘야한다. // -&gt; 누적해가면서 &lt;2변수를 비교후 큰값을 남기기&gt;가 max값이다. // --&gt; Integer였다면 a &gt; b ? a : b 의 3항연산자를 써서 (비교후 t/f별 return) 했을 것이다. //.reduce((a,b) -&gt; a &gt; b ? a : b) // -&gt; 하지만, 제네릭을 통해 아무Type T -&gt; [부등호를 통한 숫자비교]이외의 비교를 위해서 // --&gt; Comparable 구현으로 제한한 Type에 대해 compareTo로 비교한다. .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) //2-3.stream에 원소가 없을 경우 optional로 반환하는데, get()을 통해 값만 강제로 꺼낼 수 도 있다. // -&gt; 값이 없는데 get을 시도했을 때 예외가 발생하는데, 이것은 자연스런 예외라고 생각할 수 있다. // NoSuchElementException: No value present // default값이나 or 특정예외를 발생시키는 코드를 작성안해도, 없는 값 get시도시 예외는 자연스러운 것으로 봐도 된다. .get(); } } . 와일드카드 사용시 캡처 문제 . reverse . public class GenericsCapture { public static void main(final String[] args) { final List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5); //1. 이번엔 어느타입의 list든 revese시키는 함수를 만들어보자. // -&gt; 제일 쉽게 구현하는 것은 list를 1개 temp에 방어적 복사(새로운 list로 복제)해놓고, // -&gt; i번째에, temp에서는 n-i-1번재로 뒤에서부터 꺼내서, 원본 list값을 바꿔버리는(set) 전략이다. reverse(list); System.out.println(&quot;list = &quot; + list); } private static &lt;T&gt; void reverse(final List&lt;T&gt; list) { //2. reverse전략: temp list 1개를 방어적 복사 -&gt; index를 돌면서 뒤에서부터 temp에서 꺼낸 값을 -&gt; 원본 list의 값에 set final List&lt;T&gt; temp = new ArrayList&lt;&gt;(list); for (int i = 0; i &lt; list.size(); i++) { list.set(i, temp.get(list.size() - i - 1)); } } } . | List는 사용됬지만, 개별원소 T t의 type관련 기능이 사용되지 않았다. . T type정보가 내부에서 의미있게 사용되는가? 생성자에 list집어넣기 / size / get in List/ set in List -&gt; 전부 List자체 기능 | . | type paramter대신 와일드카드 사용가능하다 . 응답형 앞에 T 삭제 | type parameter List&lt;T&gt;를 List&lt;?&gt;대체하기 | . | 와일드 카드로 바꿔줬더니, capture에러가 뜬다. . . | . | 와일드카드로 Type을 모르고 관심없다고 했는데 그 ?의 Type을 추론해야하는 상황 = 캡처의 상황이 찾아오기도 한다 . 캡처=와일드카드의 타입추론 | listd에 .set을 할려고보니, temp에서 꺼내온 Type을 어떤 형으로 정해서 넣어줘야하지? 모르는 상황 | . | 다시 지네릭메서드로 돌아가도 되지만, 자바 설계상 헬퍼메서드를 만들어준다 . reverse()메소드 내부에 private revserseHelper( list )메소드를 만들고, 지네릭메소드로 돌린 코드를 helper메서드에 넣어준다. . 구조상 원본메서드는 List&lt;?&gt; list의 와일드카드를 사용중이고 | 내부 helper메서드는 와일드카드 list를 던졌는데 -&gt; 파라미터는 List&lt;T&gt; list의 지네릭 메서드를 사용하게 된다. | . . | List&lt;?&gt; list -&gt; List&lt;T&gt; list 메서드에 대입이 가능한가? . SubType 인자만 -&gt; SuperType파라미터가 받을 수 있을 텐데? 일치하거나 List 가 ?의 SuperType(추상체)여야 인자로 던지기 가능함 | . | 사실 그런관계는 없다. 그러나 컴파일러가 자동으로 ? -&gt; T 대입시 T로 캡쳐를 해준다고 한다. why 이런구조를 쓸까? 그냥 지네릭 메서드를 쓰면 편할텐데 T라는 type도 내부구현으로서 감출 수 있으면 감추기 위해 | . | . | . public class GenericsCapture { public static void main(final String[] args) { final List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5); reverse(list); System.out.println(&quot;list = &quot; + list); } private static void reverse(final List&lt;?&gt; list) { reverseHelper(list); } private static &lt;T&gt; void reverseHelper(final List&lt;T&gt; list) { final List&lt;T&gt; temp = new ArrayList&lt;&gt;(list); for (int i = 0; i &lt; list.size(); i++) { list.set(i, temp.get(list.size() - i - 1)); } } } . | 와일드카드로 변환했는데, 구체적인 Type정보가 필요한 코드를 만나서 캡처문제가 발생했구나 정도로 이해하고 있으면 된다. . | public class GenericsCapture { public static void main(final String[] args) { final List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5); //1. 이번엔 어느타입의 list든 revese시키는 함수를 만들어보자. // -&gt; 제일 쉽게 구현하는 것은 list를 1개 temp에 방어적 복사(새로운 list로 복제)해놓고, // -&gt; i번째에, temp에서는 n-i-1번재로 뒤에서부터 꺼내서, 원본 list값을 바꿔버리는(set) 전략이다. reverse(list); System.out.println(&quot;list = &quot; + list); } //3. List&lt;T&gt;는 사용됬지만, 개별원소 T t의 type관련 기능이 사용되지 않았다. // -&gt; T type정보가 내부에서 의미있게 사용되는가? // 생성자에 list집어넣기 / size / get in List/ set in List -&gt; 전부 List자체 기능 // -&gt; type paramter대신 와일드카드 사용가능하다 private static void reverse(final List&lt;?&gt; list) { //2. reverse전략: temp list 1개를 방어적 복사 -&gt; index를 돌면서 뒤에서부터 temp에서 꺼낸 값을 -&gt; 원본 list의 값에 set // final List&lt;?&gt; temp = new ArrayList&lt;&gt;(list); // // for (int i = 0; i &lt; list.size(); i++) { // list.set(i, temp.get(list.size() - i - 1)); // } //4. 지네릭 -&gt;와일드카드로 변환시 캡처 문제가 발생할 경우, private helper메서드를 만들고 // 그 내부를 다시 지네릭메서드로 돌린다. reverseHelper(list); } //5. List&lt;?&gt; list -&gt; final List&lt;T&gt; list 메서드에 대입이 가능한가? // -&gt; SubType 인자만 -&gt; SuperType파라미터가 받을 수 있을 텐데? // (일치하거나 List&lt;T&gt; 가 ?의 SuperType(추상체)여야 인자로 던지기 가능함) // --&gt; 사실 그런관계는 없다. 그러나 컴파일러가 자동으로 ? -&gt; T 대입시 T로 캡쳐를 해준다고 한다. private static &lt;T&gt; void reverseHelper(final List&lt;T&gt; list) { final List&lt;T&gt; temp = new ArrayList&lt;&gt;(list); for (int i = 0; i &lt; list.size(); i++) { list.set(i, temp.get(list.size() - i - 1)); } } } . Lambda . 람다식을 인자로 받는 메서드를 만들고 . . . | 인자의 빨간줄은 파라미터를 뭘로 바꾸면 람다식 인자가 사라질까? . IDE가 아직 람다식을 java.util.Function으로는 파라미터 자동생성을 안해준다. . . | . | 해석해보기 . Function은 람다식 구현을 하나의 구현체 인자로 받는 변수/파라미터 속 추상체이자 인터페이스이다. . | 내부를 보면, 메서드가 1개만 있는 함수형인터페이스다 . 람다식으로 구현 가능 == 인터페이스에 구현해야할 함수가 1개만 있어서 그자리에서 구현 == 함수형 인터페이스 | . | **그렇다면 람다식 구현 자체가 메서드 1개인 인터페이스의 구현체가 되어, 인터페이스(추상체)를 파라미터로 받는 메서드의 인자로서 구현체로서 던져진다. ** . . | 함수형인터페이스는 지네릭 인터페이스로서, 인자/응답의 type paramter를 지정한 메서드 파라미터로 지정할 수 있다. . private static void hello(final Function&lt;String, String&gt; o) { } . | 람다식 구현 인자를 받는 함수형인페에 제네릭 type parameter여부는 parameter hint로 확인하면서 람다식을 구현하면 된다. . | . | 람다식 구현 이전, 익명클래스로 구현 . //4. 사실 람다식을 -&gt; 익명클래스라는 [인터페이스를 객체처럼 생성후 -&gt; 중괄호로 그자리에서 인터페이스속 1개 메서드를 Override구현]한 뒤, 변수 추출하여, 익클로 구현 변수를 함수형 인터페이스 인자 자리에 넣어줄 수 있다. //new Function&lt;String, String&gt;(){} // -&gt; generate -&gt; impl method // new Function&lt;String, String&gt;(){ // @Override // //4-1. 그자리에서 구현했지만, 들어오는 인자는 s // public String apply(final String s) { // //4-2. 그자리에서 구현했지만, 응답값은 s // return s; // } // }; // 4-3. 인터페이스를 객체처럼 -&gt; {}중괄호 그자리 구현 했다면 -&gt; 그것을 사용하기 위해선 -&gt; 익클은 변수 추출로 빼야한다. final Function&lt;String, String&gt; function = new Function&lt;&gt;() { @Override public String apply(final String s) { return s; } }; // 4-4. 이제 익클로 구현한 function를 람다식이 있던 자리 == 함수형인터페이스를 파라미터로 받는 메서드(인자) 자리에 넣어줄 수 있다. // -&gt; 그러면 내부에서 apply가 자동으로 호출된다.?! //hello(function); // 4-5. 하지만, 메소드1개인 함수형 인터페이스의 구상체 구현은 익클구현보다는, 람다식으로 해당 메서드를 구현하면 된다. hello(s -&gt; s); . 익명 클래스 구현 -&gt; 람다식 구현으로 옮겨오는 과정 . //5. 메소드1개 인터페이스의 익명클래 구현에서 // 1) 익명클래스 관련 코드 삭제(new ~ @Override) // 2) 응답형은 알아서 추론&lt;, R&gt; // 3) 메서드명 필요없어 삭제 // 하면 아래와 같다 hello( (String s ) -&gt;{ return s; } ); // 4) 지네릭을 쓰는 함수형인페에서 이미 인자의 type을 정해놨을 것이므로 // -&gt; 인자 type도 추론 가능해서 삭제 // 5) 응답쪽 statement가 1줄인 경우, 중괄호 + return + 세미콜론 생략 hello( s -&gt; s); . cf) type추론은 compile time에 이루어진다. | . | . IntersectionType 기본 . 람다식 구현인자를 받는 함수형인페 파라미터의 메서드를 쓰는 데, 마커 인터페이스를 붙여야할 경우가 생긴다면 . 해당 메서드의 파라미터를 Function t -&gt; T t를 받는 제네릭메서드로 바꾸고 . | upper bound를 &lt;T extends Function&gt;으로 준다. | 이제type parameter에 &lt;T extends 함수형인페 &amp; 마커인터페이스&gt;형식으로 intersectionType type parameter를 사용해서 상한시 요구되는 타입을 여러 interface를 섞어 제한하면 된다. | | . public class GenericsIntersectionType { public static void main(final String[] args) { //1. [람다식 구현]을 인자로 받는 [메서드]를 만들자. // -&gt; why? 람다식 구현을 받는 추상체 파라미터는 [메소드 1개의 함수형인페 구현을 받아주는 중 &amp;&amp; 인자-&gt;응답T를 지네릭으로 정의]해놓았기 때문이다. // cf) 람다식으로 구현해도, 익명클래스는 아니지만, 비슷한 클래스가 내부에 정의되서 익클처럼 작동한다... hello(s -&gt; s); //3. 람다식은 앞에 (소괄호를 통한 타입 캐스팅)이 가능하다고 했다. // -&gt; type없이 캐스팅을 해줘도 된다. 불필요 하지만.. hello((Function) s -&gt; s); //4. 람다식의 캐스팅은 사실 intersectionType을 위해 사용된다. // -&gt; 메서드 1개는 이미 함수형인페것을 구현하고 있는 람다식이지만 // --&gt; 메서드가 내부에 없는 marker interface를 &amp;를 통해 추가 구현한다는 개념이다. // 대표적인 marker interface를 [Serializable]로 생각하자. // impl Comparable처럼, impl Serializable을 하면 -&gt; [파일/네트워크에서 직렬화 가능한 class임을 마킹]하는 인터페이스다. // impl로 구현즉시, instanceof로 확인해보면, Serializable Type이 되어버린다. // -&gt; Type만 가지고도 전송가능한지 확인할 수 있어서 좋다. // 5. 람다식 구현 유지조건은, intersectionType을 사용하더라도, 총 구현 메서드가 1개기만 하면 된다. // 1 &amp; 0 &amp; 1 -&gt; 람다식구현에서 에러가 난다. 람다식은 메서드 1개만 구현 //hello((Function &amp; Serializable &amp; Closeable) s -&gt; s); // 1 &amp; 0 // -&gt; 내부적으로 class를 정의하는데, 3가지 인터페이스를 모두 impl한 class를 정의함. hello((Function &amp; Serializable) s -&gt; s); } //2. 이번엔 함수형인페속 type paramter를 지금 정의하지 않았고 -&gt; raw type으로 지네릭 인터페이스를 사용한다. // -&gt; 이 경우, &lt;T, R&gt; 자리에는 &lt;Object, Object&gt;가 들어가 있다. private static void hello(final Function o) { throw new UnsupportedOperationException(&quot;GenericsIntersectionType#hello not write.&quot;); } //6. [람다식구현을 받는 함수형인페 Type]의 메서드 파라미터(final Function o)에다가 // -&gt; bounded type parameter으로 명시되는 제네릭 메서드(T o)로 변환할 수 있다. // -&gt; 원래는 지네릭메서드를 고려할 땐, 어느타입이든 받을 수 있게 T로 놓았지만 // -&gt; 여기서는 [직렬화가능한 &amp; 람다식 구현]을 인자로 넘기는 경우가 있으며, 그 때 제한을 걸어줄 때 // --&gt; 여기선 최소 해당조건을 구현하거나 그 자식 구현체로 제한하는 Type을 type parameter로 넣어준다. // &gt; 이렇게 할 경우 class Myclass implements Function, Serializeable의 여러 인터페이 구현한 클래스의 객체를 생성할 필요가 없어진다. //-&gt; 요약) 마커인터페이스를 붙일 필요가 있는데, 람다식으로 간결하고 표현하고 싶다 -&gt; 지네릭 메서드를 intersectionalType을 써서 정의해라 private static &lt;T extends Function &amp; Serializable&gt; void hello2(final T o) { throw new UnsupportedOperationException(&quot;GenericsIntersectionType#hello not write.&quot;); } } . 그러나 요즘 직렬화가능한 것을 넘겨주는 것은 잘안한다고 한다. | 새로운 class를 만들지 않고도, IntersectionType을 통한 인터페이스 조합을 통해 새로운 class = 새로운 익명의 Type을 만들어내는 효과를 만들어낼 수 있다. | . IntersectionType으로 marker interface의 default method을 합친 익명 객체 만들어보기(제한점 존재) . 기존 함수형인페의 기능(apply) + 마커인페의 default method들의 기능을 모두 합쳐서 가지고 있는 새로운 객체가 생성된다. 문제점: 람다식구현 인자 던질 때 캐스팅 해준 만큼 -&gt; 제네릭 메서드의 상한에도 또 명시 | . | . public class GenericsIntersectionType2 { //1. 새로운 default메서드만 가지는 인터페이스를 하나 생성한다. interface Hello { //2. 인터페이스안에는 default 메서드를 1개 만들어 -&gt; 부연코드를 넣을 수 있다(아니면 다 공통 추상메서드만 있어야함) // -&gt; 제한이 있긴하다 (상속x/ public만/ 필드정의 후 사용x) // -&gt; 가능한 것 : 인터페이스 내 추상메서드 / static메서드 호출 가능 default void hello() { System.out.println(&quot;Hello&quot;); } } //2. 또 default메서드만 가지는 인터페이스를 하나 생성 interface Hi { default void hi() { System.out.println(&quot;Hi&quot;); } } public static void main(final String[] args) { //3. 람다식 구현을 인자로받는 [함수형인터페이스]를 파라미터로 받는 메서드를 정의한다. //hello( s -&gt; s); //4. 람다식 구현은, 해당 추상체인 [함수형인페]로 캐스팅할 수 있다 // hello((Function) s -&gt; s); //5. 람다식 구현시 사용하는 캐스팅에 Intersection Type으로서 &amp;로 여러 market 인터페이스를 구현할 수 있다. // -&gt; 람다식 캐스팅은 총 method개수가 1개여야하지만, default method는 0개로 친다! hello((Function &amp; Hello &amp; Hi) s -&gt; s); } //6. Function 및 그 구상체(람다식구현)만 받았었지만 // -&gt; 3개 인터페이스 다 구현한 이후만 받도록 만들기 위해서 //private static void hello(final Function function) { // 6-1. 제네릭 메서드로 변환한다. Function function -&gt; T function // 6-2. T에 상한을 Function으로 둔다 //private static &lt;T extends Function&gt; void hello(final T function) { // 6-3. T에 상한 인터페이스에다가 &amp; Intersection로 마커인터페이스들을 추가한다. private static &lt;T extends Function &amp; Hello &amp; Hi&gt; void hello(final T function) { //6-4. T function는 &lt;Function &amp; Hello &amp; Hi&gt; Type으로 제한된 상태이므로 // -&gt; Function이 가지고 있는 apply를 적용할 수 있다. function.apply(&quot;s&quot;); // 7. 신기한 점은 market interface내에 있는 default method도 호출이 가능하다는 점이다. // -&gt; 함수형 인터페이스의 기능(apply) + 마커인터페이스의 default method들의 기능을 모두 합침 function.hello(); function.hi(); } //8. 제네릭메서드의 상한과 insectionType + 인터페이스의 defaul method를 활용하면 // -&gt; 기능 자체를 계속 추가해줄 수 있는데, // [문제]는 [1) 람다식구현시 캐스팅 일일히 해놓고] -&gt; 또 호출을 받는 [2) 제네릭 메서드의 upper bound에도 일일히 명시]해줘야하기 때문에 // -&gt; 의미가 없다. } . Consumer파라미터 추가를 통한, 콜백형식으로 IntersectionType에 기능 하나씩 확장하기(제한점 존재) . 각각 따로 기능을 구현한 interface의 method기능들을 모았어도 -&gt; 공통정보를 활용하는 방법이 없으니, 모아도 별로 의미가 없어 보이는 제한점… | . public class GenericsIntersectionType3 { interface Hello { default void hello() { System.out.println(&quot;Hello&quot;); } } interface Hi { default void hi() { System.out.println(&quot;Hi&quot;); } } public static void main(final String[] args) { //1. run이라는 메서드를 만들어 (intersectionType)으로 캐스팅된 람다식구현을 인자로 받는다. //run((Function &amp; Hello &amp; Hi) s -&gt; s); //5. 컨슈머T로 넘어갈 컨슈머용 람다식(인자O -&gt; return값 없는 사용만 우항에 몰빵) run((Function &amp; Hello &amp; Hi) s -&gt; s, o -&gt; { o.hello(); o.hi(); }); //6. 누락된 개념: // 6-1. 제네릭메서드의 상한으로 3개 인페 정의부분을 -&gt; 첫번째 파라미터의 람다식 캐스팅에 의존한다 (컨슈머T는 첫번째 상한제한T를 그대로 이용하기 때문에 다 미리 타입이 추론되어있다) // 6-2. 제네릭메서드 내부에서 호출된 로직을, 바깥의 ConsumerT 구현 람다식으로 뺐다.-&gt; 2번째 인자의 람다식구현 우항(lambda object) // - 요곤 6-1.을 이용하기 위함함 //7. s-&gt;s는 의미가 없다. Function의 람다식구현을 가장 짧게 나타냈을 뿐이다. // -&gt; 주요기능은 intersectionType으로 추가되는 marker 인터페이스의 &lt;default method&gt;기능이다. //9. 새로운 마커인터페이스+그 default method기능을 추가시켜서 사용해보자. // 9-1. 람다식 캐스팅에 추가한다. run((Function &amp; Hello &amp; Hi &amp; Printer) s -&gt; s, o -&gt; { o.hello(); o.hi(); // 9-2. 새로운 default method 기능 추가 사용 in Consumer o.print(&quot;sadsf&quot;); }); //10. 각자 따로 노는 기능들을 그냥 단순 조합만 하면 무슨 의미가 있을까? // 그냥 static메서드 모아놓은 것과 같은 효과일뿐이다? // -&gt; 1개의 Type안에 method가 여러개다? -&gt; 공유하고 있는 필드정보가 있어야 의미가 있는 것이다. // --&gt; delegate를 활용하여 각각 따로 기능을 구현한 interface가 공통정보를 활용하는 방법이 있다.?! } //8. 이제 marker인터페이스 및 default method를 추가하여 새로운 기능을 추가한 Type으로 확장해보자. interface Printer { default void print(String str) { System.out.println(str); } } // cf) 일반 람다식은 파라미터를 함수형인페로 안잡아주는데, 캐스팅하니까 바로 잡아준다. // 2. 일단은 함수형인페 이하로 upper bound를 준 제네릭 메서드로 변경한다. //private static void run(final Function function) { //3. 이번엔 upperbound에 intersection을 거는 것이 아니라 // -&gt; [함수형인페 Consumer&lt;T&gt;]를 메소드 파라미터로 추가한다. // --&gt; 컨슈머T(void accept(T t);)는 accept기능을 가지는데, return은 없고 파라미터만 있다 // &gt; 반대로 Supplier&lt;T&gt;는 get기능을 가지는데, 파라미터는 없고, return만 T type이다. // [컨슈머T를 썼다 -&gt; 뭔가 Lambda object(람다식 구현의 우항)를 갖다주면, &lt;&lt; 그걸 파라미터로 받는 메소드 내부에서 응답없이 .accept( 인자 )로 넘어온 lambda object(우항)을 사용하기만 할 수 있다&gt;&gt; 는 뜻이다] //private static &lt;T extends Function&gt; void run(final T t) { private static &lt;T extends Function&gt; void run(final T t, final Consumer&lt;T&gt; consumer) { // 4. 그렇다면, run내부에서 호출되었던 t.hello();, t.hi();들을 // -&gt; consumer 인자부분에서 lambda object(우항)에 담아서 던져주고 // consumer.accept(t)로 lambda object(컨슈머 람다식 우항)를 return없이 실행만 시킨다. consumer.accept(t); } } . 람다식구현 인자용 함수형인페&lt;T&gt;를 상속한 인터페이스로, default method내부에서 변경가능한 람다식에 따른 기능 수행하는 메서드가 된다. . . . . . . . . public class GenericsIntersectionTypeWithDelegate { //1. 지네릭으로서 type 정보 1개를 가진 interface 선언 interface DelegateTo&lt;T&gt; { //2. supplier처럼 인자안받고, 응답만 T type의 객체로 하는, 추상메서드 1개를 선언한다. T delegate(); } //3. 이제 delegateTo 지네릭 인터페이스를 extends로 상속하는 인터페이스를 만든다. // -&gt; 이 때, 지네릭 인터페이스의 type parameter에 구체형을 줘야한다! // -&gt; 또한 확장기능을 추가하기 위해 default method를 추가한다. (총합 1개메서드의 람다식에 카운팅 안되는 메서드) interface Hello extends DelegateTo&lt;String&gt; { default void hello() { //4. 이제 확장기능 뿐만 아니라 + default메서드 속에서 상속한 (함수형)인터페이스의 기능(delegate())를 호출할 수 잇다. // -&gt; 함수형인페 추상메서드는 인자없이 T응답인데 -&gt; DelegateTo&lt;String&gt;으로 박아서 상속했으니 String을 응답할 것이다. System.out.println(&quot;Hello &quot; + delegate()); } } public static void main(final String[] args) { //5. 아까랑 조금 다르다. // -&gt; 바깥에 호출하는 메서드 + 일단 람다식 캐스팅부터 작성한다. // -&gt; 상속한 마지막 인터페이스가 뿐만 아니라, 부모인 함수형인페도 같이 처음부터 적어줘야 // -&gt; 함수형 인페로 인한 람다식 작성이 가능하다. //run((DelegateTo&lt;String&gt; &amp; Hello)) //6. 이번엔 [함수형인페 속 메서드가 인자X의 supplier -&gt; 람다식 구현시 좌항이 빈 ()-&gt;로 출발해야한다] //run((DelegateTo&lt;String&gt; &amp; Hello) () -&gt; ) //7. 인자없는 ()-&gt; 지만, 응답은 T 타입 -&gt; String 이므로 [우항=lambda object]는 String으로 반환해주자. //run((DelegateTo&lt;String&gt; &amp; Hello) () -&gt; &quot;ChoJaeSeong&quot;) //8. 이제 기본적으로 제네릭메서드로서 상한 2개 &amp;&amp; 내부에서 기능호출하는 메서드에서 // 내부호출을 2번재 인자에 [return없이 메서드 호출만 하는 로직 옮기기용 Consumer&lt;T&gt;의 람다식] 작성 // -&gt; 이것을 통해, 상한을 일일히 제네릭 상한으로 안적어주고, Consumer&lt;T&gt;가 1번째 람다식에서 추론해서 갖다쓰게 된다. run((DelegateTo&lt;String&gt; &amp; Hello) () -&gt; &quot;ChoJaeSeong&quot;, o -&gt; { }); //12. 해석 // 1) 람다식 구현() -&gt; &quot;ChoJaeSeong&quot;는, 함수형인터페이스DelegateTo&lt;String&gt; 의 추메 T delegate()의 실제 구현 코드가 되어버린다. // 2) Consumer가 받아온 로직 중 default 메소드 hello 호출 -&gt; 그 내부에 함수형인페 속 추메 delegate() 호출이 있다면? // -&gt; 여기 정해둔 람다식구현이 빨려 들어가 실행된다. // 3) 그 이유는, 타입캐스팅 속 InterSectionType &amp; 로 인해, 뒤쪽 인페의 default method안에 들어있는 부모인터페이스의 메서드 호출시, 앞에 함수형인페의 추상메서드를 그대로 가져와 호출한다.(자바가 인식해준다) run((DelegateTo&lt;String&gt; &amp; Hello) () -&gt; &quot;ChoJaeSeong&quot;, o -&gt; { // 13. 앞에서 intersectionType으로 추가해준 인터페이스는 // 그 앞의 deletage를 상속한 뒤, 그 속의 추메를 내부에서 사용할 수 있게 된다. // -&gt; default 고정 기능이 아닌, 함수형인페를 부모로 상속한 뒤, default method에서 사용 -&gt; // 호출시 람다식에 의해 언제든지 변경가능한 기능을 수행하게 됨됨 o.hello(); }); //14. 람다식 캐스팅 부분에 인터섹션Type을 추가한 뒤, // consumer block에서 새로운 기능을 호출하면, 람다식구현이 그대로 추상메서드 호출 자리에 사용되면서 기능이 추가된다 run((DelegateTo&lt;String&gt; &amp; Hello &amp; UpperCase) () -&gt; &quot;ChoJaeSeong&quot;, o -&gt; { o.upperCase(); }); //15. 이제 람다식을 동적으로 바꿔도 바뀐 체로 기능이 합쳐진다. run((DelegateTo&lt;String&gt; &amp; Hello &amp; UpperCase) () -&gt; &quot;abcde&quot;, o -&gt; { o.upperCase(); }); } //13. 이제 Consumer block안에 새로운 기능을 추가하고 싶다! 하지만, 새로운 클래스를 만들거나 하고 싶진 않다면? // -&gt; 람다식 캐스팅에 인터섹션Type을 추가할 default method의 interface추가 -&gt; [람다식으로 구현하는 delegate()기능 + @]로 기능 추가할 수 있다. //13-1. 똑같이 함수형인페는 상속해서 -&gt; 내부에서 함수형인페를 호출할 수 있어야한다. interface UpperCase extends DelegateTo&lt;String&gt; { default void upperCase() { System.out.println(delegate().toUpperCase()); } } //9. 기본 제네릭 메서드로 정의하며, 람다식의 추상체 파라미터인 인터페이스(DelegateTo&lt;String&gt;) 대신 -&gt; T t로 쓴다. // -&gt; 여기서 말하는 T는 람다식캐스팅 맨 앞의 인터페이스를 T로 본다. // -&gt; 이제 인터페이스를 구현한 것 이후로의 SubType만 받기 위해, T의 상한을 응답형 앞에서 받아준다. // --&gt; 여기서, T는 DelegateTo&lt;&gt;인데, DelegateTo 자체의 type paramter는 다른 것으로 표기해줘야한다. // run은 2개의 type paramter &lt;T, S&gt; 2개를 가지게 된다. // -&gt; Consumer는 delegate에 해당하는 T를 받아와서 람다식에서 호출되도록 한다. // 10. 아까는 Function이라는 함수형인페를 바로 사용했지만, // -&gt; 지금은, DelegateTo라는 자체제작 (메소드1개의 인터페이스-&gt;) 함수형인페 + type이 중요해서 Function에서 안쓰던 제네릭을 붙여서 type을 살린 상태로 // 좀더 복잡해졌다. private static &lt;T extends DelegateTo&lt;S&gt;, S&gt; void run(final T t, final Consumer&lt;T&gt; consumer) { //11. Consumer의 람다식으로 뺀 로직을, 실행context는 여기 메서드 내부에서 시켜주게 한다. // -&gt; my) 람다식구현 인자로 받은 로직 -&gt; 함수형인페로 파라미터로 받아서 -&gt; 로직.실행()의 context는 메서드 내부에서 실행되게 한다. 함수실행로직 작성만 밖에서 // -&gt; my2) 구현체 객체 -&gt; 인터페이스 파라미터 -&gt; 구현체 객체.의 기능 실행()은 메서드 내부에서... consumer.accept(t); } } . 새로운 아이디어와 최종 예제 . 기존: (구현class 후 구현체 인자 대신) 람다식 구현 인자 -&gt; 함수형인페 파라미터 (구현체.추클()호출 대신 정해진메서드()호출하여 내부context로 실행) -&gt; 제네릭 메서드로 변환하되 함수형인페를 T상한으로 -&gt; 여러Type 동시구현을 상한경계 대신 람다식 캐스팅 + Consumer로 밖으로 빼기 . 현재: 일반 인터페이스(메서드 2개이상) 의 기능 다 가지면서 + 새로운 기능을 람다식 캐스팅 했던 것처럼 동적으로 추가하고 싶다 . 더이상 수정할 수 없는 라이브러리에 기능추가 . Repository의 findAll()이 List가 아닌 iterator를 리턴하는데, list로 받으려고 별도의 메서드 만드는 것이 관련있을까? 아님… . | 예제 인터페이스는 이미 4개의 메서드를 가진 인터페이스가 base라서… 람다식 구현(함수형인페-메소드1개를 인자에서 구현)을 받을 수 가 없다. . 람다식의 우항에서 해당 구현체객체를 넘겨주는 람다식을 작성하더라도.. 캐스팅은 안된다?! | . . | . public class GenericsIntersectionTypeWithDelegateExample { //1. List는 구현해야할 추메가 너무 많아서, Pair&lt;T&gt;라는 인터페이스를 하나 정의해준다. interface Pair&lt;T&gt; { // 2. 값을 2개 가질 수 있어서 각각을 꺼낼 수 있는 메서드 2개를 가진다( 함수형인페X -&gt; 람다식으로 인자에서 구현X) // + setter도 2개 가진다. T getFirst(); T getSecond(); void setFirst(T first); void setSecond(T second); } //2. 이제 일반 인터페이스를 구현하는 class를 만든다. // -&gt; 인터페이스 impl할 때, 제네릭 인터페이스면 -&gt; 직접 명시해서 구현하자. static class Name implements Pair&lt;String&gt; { //3. class라서 이제 필드를 만들어, 정보를 보관할 수 있다. private String firstName; private String lastName; public Name(final String firstName, final String lastName) { this.firstName = firstName; this.lastName = lastName; } @Override public String getFirst() { return firstName; } @Override public String getSecond() { return lastName; } @Override public void setFirst(final String first) { this.firstName = first; } @Override public void setSecond(final String second) { this.lastName = second; } } interface DelegateTo&lt;T&gt; { T delegate(); } private static &lt;T extends DelegateTo&lt;S&gt;, S&gt; void run(final T t, final Consumer&lt;T&gt; consumer) { consumer.accept(t); } //7. Forwarding인터페이스를 만들어준다. (~를 넘긴다는 의미) //7-1. 람다식으로 쓰기 위해 함수형인페 Delegate 인터페이스를 상속한다. // - 동적으로 쓰고 싶은 인터페이스 Pair&lt;T&gt;를 함수형인페&lt;T&gt;의 type paramter에 넣어준다. // - Delegate뿐만 아니라, Pair 인터페이스도 상속한다. interface ForwardingPair&lt;T&gt; extends DelegateTo&lt;Pair&lt;T&gt;&gt;, Pair&lt;T&gt; { //7-2. 인터페이스에 있는 여러개의 추상메서드를 -&gt; 상속후 default method로서 오버라이딩 하는 방법이 있다. // (1) 오버라이딩 해서 다 가져온 다음 -&gt; (2) @Override 지우고, default메서드로 바꾸주고 // (3) getter의 경우, DelegateTo 상속으로 호출가능한 delegate()를 호출한다. // -&gt; delegate는 들어오는 T를 응답해주는 supplier 역할인데, 그 T자리에 Pair&lt;T&gt;가 들어가 있으니 // -&gt; pair내부의 여러 추상메서드를 호출하도록 작성한다. // @Override // T getFirst(); default T getFirst() { //8. delegate()하면, elegateTo에 적힌 Type인 pair&lt;T&gt; 타입이 오고 -&gt; 거기서 정의된 메서드를 호출한다. // -&gt; supplier형태의 T응답 DelegateTo&lt;T&gt; 인페를 상속한 인페는 // -&gt; DelegateTo&lt;T&gt;의 T 자리에 넣은, extends DelegateTo&lt;Pair&lt;T&gt;&gt; 상의 [Pair&lt;T&gt;]를 반환해주게 된다. // --&gt; delegate()로 반환된 인터페이스 Pair&lt;T&gt;는.. 그 내부 추상메서드를 호출할 수 있다. return delegate().getFirst(); } default T getSecond() { return delegate().getSecond(); } default void setFirst(T first) { delegate().setFirst(first); } default void setSecond(T second) { delegate().setSecond(second); } } //9. ForwardingPair를 만들면, 인터페이스는 Delegate만 남는다. // -&gt; 그 뒤의 Pair는 이미 안에서 구현된 상태기 때문이다. public static void main(final String[] args) { //4. 생각하면서 람다식구현을 인자로 받는 메서드 -&gt; 그것을 제네릭으로 받는 메서드를 run을 호출해보자. //run(()-&gt;&quot;&quot;, o-&gt;{}); //5. 우리가 원하는 것: 일반인페 기능구현 + 동적으로 기능추가 하고 싶다. // 5-1. 메서드 2개이상의 일반 인터페이스 의 기능을 다 가진다 -&gt; 람다식구현 대입 불가 -&gt; 구현체객체를 만들어, [넣어줘야할 구현체 객체를 람다식 우항에서 제공]해주기 // - 참고) 추상체 인터페이스 파라미터에 넣을, 구현체 객체를 생성할 때도, 변수(좌항)은 추상체로 받아주자.! //final Name name = new Name(&quot;Toby&quot;, &quot;Lee&quot;); final Pair&lt;String&gt; name = new Name(&quot;Toby&quot;, &quot;Lee&quot;); // 5-2. 람다식으로 함수형인페 1개 전체 구현이 아니라, 일반 인페가 받는 구현체 객체를 람다식으러 넣어주면 된다. //run(() () -&gt; name, ); //6. 하지만, 람다식의 우항으로 넘기는 name은 Pair라는 인터페이스를 넘길 수 없는 상황?이다. // -&gt; 람다에서 사용하게 만들고 싶다~! 새로운 아이디어가 필요하다. //10. 이제 람다식 캐스팅을 ForwardingPair라고 놓는다. // -&gt; FP는 DelegateTo를 상속한 상태이므로 // -&gt; DelegateTo를 상한경계로 받는 run의 첫번재 인자 T에 넣어줄 수 있고 ( 람다식의 우항에 supplier -&gt; T t ) // -&gt; 메서드 내부호출될 로직을, 함수형인페로 받아 -&gt; 외부에서 [첫번째 인자에 의해 자동 추론된 Type] 람다식으로 제공 받을 수 있어 // -&gt; 2번째 인자 람다식을 동적으로 넣어줄 수 있다. run((ForwardingPair&lt;String&gt;) () -&gt; name, o -&gt; { System.out.println(&quot;o.getFirst() = &quot; + o.getFirst()); System.out.println(&quot;o.getSecond() = &quot; + o.getSecond()); }); //11. 컨슈머 쪽의 o의 Type은 사실 ForwardingPair이다. // -&gt; ForwardingPair이다는 delegateTo에 해당하는 것이고 // -&gt; delegateTo를 구현하는 메서드는 () -&gt; name 밖이다. // -&gt; 그 우항에서 반환되어 입력되는 name속 메서드는 // -&gt; ForwardingPair가 delete상속후 다 정의를 해놓았으니 // -&gt; o에서 호출해서 쓰기만 하면 된다?! //람다식 타입캐스팅 쓸 수 있는 인터페이스 -&gt; default method는 0개로 침. 함수형 인터페이스..?! //https://www.youtube.com/watch?v=PQ58n0hk7DI&amp;list=PLv-xDnFD-nnmof-yoZQN8Fs2kVljIuFyC&amp;index=11 //1:43:00 c참고하기 } } . 제네릭 기본 적용 예시 모음 . print . //before void print(String value) { System.out.println(value); } //after &lt;T&gt; void print(T t) { System.out.println(t.toString()); } . | countGreaterThan(arr, elem) . //before static long countGreaterThan(Integer[] arr, Integer elem) { return Arrays.stream(arr) .filter(s -&gt; s &gt; elem) .count(); } public static void main(final String[] args) { final Integer[] integers = {1, 2, 3, 4, 5, 6, 7}; System.out.println(&quot;countGreaterThan(integers, 4) = &quot; + countGreaterThan(integers, 4)); } . //after static &lt;T extends Comparable&lt;T&gt;&gt; long genericCountGreaterThan(T[] arr, T elem) { return Arrays.stream(arr) .filter(s -&gt; s.compareTo(elem) &gt; 0) .count(); } public static void main(final String[] args) { final Integer[] integers = {1, 2, 3, 4, 5, 6, 7}; System.out.println(&quot;genericCountGreaterThan(integers, 4) = &quot; + genericCountGreaterThan(integers, 4)); final String[] strings = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;}; System.out.println(&quot;genericCountGreaterThan(strings, &quot;3 &quot;) = &quot; + genericCountGreaterThan(strings, &quot;2&quot;)); } . | isEmpty(list) - 지네릭 메소드 버전 . private static &lt;T&gt; boolean isEmpty(final List&lt;T&gt; list) { return list.size() == 0; } . isEmpty - 내부 로직에 type paramter 미사용으로 unbound wild card로 변경한 버전 | . private static boolean isEmpty(final List&lt;?&gt; list) { return list.size() == 0; } . | frequency(list, elem) - 지네릭 메소드 버전 . private static &lt;T&gt; long frequency(final List&lt;T&gt; list, final T elem) { return list.stream() .filter(s -&gt; s.equals(elem)) .count(); } . frequency - 와일드 카드 버전 **equals비교가 제대로 되려면 List의 원소 vs 원소1개 T를 비교하는 지네릭 메소드가 낫지 않을까?** | equlas의 비교는 사실, 똑같은 Type일 이유가 없다. equals비교 대상으로 허용하지 않는다면, 에러가 날 것이다. | list의 원소Type와 비교할 원소는 다른 Type을 가져가는 경우도 있다. ex&gt; SubType | 동일한Type으로만 비교시, 지네릭 메서드를 쓰면 되겠지만… SubType(구상체)와의 비교도 하기도하고, 자바 api에도 이렇게 설계되어있다. | . | . | . private static long frequency(final List&lt;?&gt; list, final Object elem) { return list.stream() .filter(s -&gt; s.equals(elem)) .count(); } . | max - 제네릭 메소드 버전 . private static &lt;T extends Comparable&lt;T&gt;&gt; T max2(final List&lt;T&gt; list) { return list.stream() .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) .get(); } . wild card 개입 by 메서드 내부 사용시 upper / 메서드 외부용 super | . private static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(final List&lt;? extends T&gt; list) { return list.stream() .reduce((a, b) -&gt; a.compareTo(b) &gt; 0 ? a : b) .get(); } . max - collections(인자인 List내장 Comparator 사용 버전) | . Collections.max(list) . max - collections + Comparable&lt;? super T&gt;예시를 위해, 비교메서드 구성을 Object로 해버리는 직접 Comparator(객체 비교방법) 제시 with 람다 캐스팅 | . Collections.max(list, (Comparator&lt;Object&gt;) (a, b) -&gt; a.toString().compareTo(b.toString())); . | reverse: 지네릭 메서드로는 1개로 표현가능 . private static void reverse(final List&lt;?&gt; list) { final List&lt;?&gt; temp = new ArrayList&lt;&gt;(list); for (int i = 0; i &lt; list.size(); i++) { list.set(i, temp.get(list.size() - i - 1)); } } . private static void reverse(final List&lt;?&gt; list) { reverseHelper(list); } private static &lt;T&gt; void reverseHelper(final List&lt;T&gt; list) { final List&lt;T&gt; temp = new ArrayList&lt;&gt;(list); for (int i = 0; i &lt; list.size(); i++) { list.set(i, temp.get(list.size() - i - 1)); } } . |",
            "url": "blog.chojaeseong.com/java/generic/lambda/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/03/%EC%A0%9C%EB%84%A4%EB%A6%AD2.html",
            "relUrl": "/java/generic/lambda/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/03/%EC%A0%9C%EB%84%A4%EB%A6%AD2.html",
            "date": " • Apr 3, 2022"
        }
        
    
  
    
        ,"post85": {
            "title": "generic 개인공부 1",
            "content": "기본개념 . 제네릭(generic)이란? . 컴파일타임에 타입체크 하여 코드의 안전성을 높여준다. | 우리는 항상 사용하고 있다. . | 정의시 &lt;T&gt;를 타입매개변수라 한다. | List&lt;String&gt;자리에 뭔가를 주었다면 매개변수화된 타입이라고 부른다. | . 제네릭 [타입 지정] 사용 이유 . 컴파일러가 을 알게되어, 런타임 전에 [다른형 생성(add)시] 컴파일 에러가 나 해결됨 . @DisplayName(&quot;&quot;) @Test void lesson9_techTalk_sadly_runtimeError() { // 여러타입 가능한 자료구조라 ArrayList내부에 제네릭으로 정의해놨는데 // 1. 제네릭을 지정 안했줬다면? // 1) 변수추출시, Object로 변&lt;구&gt;제 된다. final List&lt;Object&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;woowacourse&quot;); list.add(1); // 2) 제네릭을 타입 미지정 결과, 아무 형이나 (실수에 의해) 넣을 수 있다. //3) 타입이 다른 것이 들어갔는데, 확인안하고 하나의 타입으로 지정해서 써버리면, 형의 차이때문에, runtimeError가 발생한다. //4) Object형이기 때문에 casting해서 하나의 형으로 받아줬다 -&gt; 그 과정에서 실수로 들어간 다른형이, 런타입 에러를 발생시킨다? final String result = (String) list.get(0) + (String) list.get(1); //5) 즉, 여러형이 들어갈수 잇는 자료구조에서, 제네릭을 안쓴다면, 꺼낼때마다 확인해서 써야한다. } @DisplayName(&quot;&quot;) @Test void lesson9_techTalk_lovely_compileError() { // 여러타입 가능한 자료구조라 ArrayList내부에 제네릭으로 정의해놨는데 // 2. 제네릭&lt;T&gt;타입매개변수를 지정해서 사용한다면? // 1) 컴파일러님께서 알 수 있게 되어, runtime 전에 해결된다. final List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;woowacourse&quot;); // 1) runtimeError까지 가기전에, CompileError를 발생시켜 아무 형이나 집어넣을 수 없게 형 검사를 해준다. list.add(1); } . 컴파일러가 아는 것만 받다보니, [꺼낼 때 (타입검사 후 -&gt;) 캐스팅(타입변환)] 안해줘도됨 . @DisplayName(&quot;&quot;) @Test void lesson10_techTalk() { final List&lt;Object&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;woowacourse&quot;); final Object o1 = list.get(0); // 1) 제네릭 타입미지정시, 캐스팅 안해주면 Object final String result = (String) list.get(0); // 2) 캐스팅 해줘야 생성했던 형/원하는 형으로 구체형 추출가능 } @DisplayName(&quot;&quot;) @Test void lesson10_techTalk_2() { final List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;woowacourse&quot;); final String result = list.get(0); // 1) 제네릭 타입지정해줬다면, 컴파일러가 아는 것만 들어가 있어서, 꺼낼때 캐스팅이 필요없다. } . 주의점) 배열과 다르게, 호..제는 변제와 동치이므로, 완전히 동치일때만 가능하다. . 우항의 호출시 &lt;구체형&gt; 제한은 좌항의 변.&lt;구&gt;.제와 완전히 동치이다. 반면, 우항의 호출시&lt;&gt;. 구체형.지정사용은 변수에 들어가는 놈일 뿐이다. | . | 즉, 좌항의 변구제와 우항의 호구제는 동일해야만 한다. 우항의 호구지와는 다른 개념 | . | . @DisplayName(&quot;&quot;) @Test void lesson11_techTalk_3() { final Object[] arrays = new Integer[1]; List&lt;Object&gt; list1 = new ArrayList&lt;Integer&gt;(); // 호.&lt;구&gt;.제 는 좌변과 완전히 형이 동치여야한다. // 컴팔일러가 알고 있는 변수와 다른 형이기 때문에 컴파일에러가 난다. List&lt;Object&gt; list2 = new ArrayList&lt;&gt;(List.of(1)); // 반면 호&lt;&gt;구.지는 object에 들어가는 것으로서 가능하다. } . . 제네릭 타입 . **형(T)를 파라미터로 가지는 class or interface를 말한다. ** class나 인터페이스 이름 뒤에 꺽쇠로 타입매개변수 class&lt;T&gt; or interface&lt;T&gt;가 붙는다. | . | . 제네릭 [T] 사용 이유 . 상태값(필드값) 등을 Object타입을 사용한 것처럼 모든 타입을 받아들여 저장할 수 있게 된다. . Object타입으로 상태값을 저장할 때 . private class Category { private final Object value; private Category(final Object value) { this.value = value; } public Object getValue() { return value; } } . | 제네릭타입(class)를 쓸 때 . private class GenericCategory&lt;T&gt; { private final T value; public GenericCategory(final T t) { this.value = t; } public T getValue() { return value; } } . | . | Object때와는 다르게, 컴파일러에게 타입을 지정해주고 사용하면 . 컴파일러가 알아서 에러를 내준다. . | 타입확인 -&gt; 타입변환 안해줘도 된다. . | | . 제네릭 메서드 . 메서드 선언부에 제네릭타입이 선언된 것 타입매개변수의 범위가 메서드내로 한정되어, 제네릭타입의 변수와 전혀 별개의 변수임. | . | . 생성자 대신 주입자 메서드(setter) vs 제네릭 메서드 . setter는 상태값(필드)에 주입하는 것이고 . | 제네릭 메서드는 상태값(필드)와는 별개로 지역변수에서 사용하는 타입매개변수를 사용한다. . | 제네릭 메서드 정의 . public &lt;K&gt; void printClassName(K k) { System.out.println(&quot;제네릭 타입의 필드 타입매개변수 = &quot; + this.value.getClass().getName()); System.out.println(&quot;제네릭 메서드 타입매개변수 = &quot; + k.getClass().getName()); } . 생성자든, 메서드든, 호&lt;&gt;.구체형.지정사용하기 | . //1. 제네릭 타입(class)에 저장하는 T는 Noodle형 객체를 호&lt;&gt;.구.지 -&gt; 변.&lt;구&gt;.제로 자동으로 형 제한 final GenericCategory&lt;Noodle&gt; noodleGenericCategory = new GenericCategory&lt;&gt;(new Noodle()); //2. 제네릭 메서드의 타입은, Pasta형을 호&lt;&gt;.구.지정사용 noodleGenericCategory.printClassName(new Pasta()); . 출력 | . 제네릭 타입의 필드 타입매개변수 = MainTest$Noodle 제네릭 메서드 타입매개변수 = MainTest$Pasta . | . 제네릭 타입을 모든형이 아닌, 제한된 타입으로 제한 . Noodle 및 Noodle 자식형들로만 넣고 싶을때? Coke 타입은 못들어오게 막고 싶을 때가 있을 것이다. . . | . P-E, C-S 원칙 + Extends의 와일드카드를 사용하여 T에는 본인 및 그 자식들만 들오게 -&gt; 나머지는 컴파일에러 . P-E, C-S 원칙: 생성자/add 등의 Produce상황에서는 &lt;? Extends &gt;의 와일드카드를 사용하여 T에는 본인 및 그 자식들만 들오도록 상한 경계를 준다. . 컴파일러들이 상한경계+그자식들만 알고 있어 나머지는 컴파일에러를 낸다. | . . | 와일드카드는 코드속 ?로서, 모든 타입이 다 가능하게 한다 . | 그외에 &lt;? super &gt;의 하한 경계는 Consume을 정의할 때 사용한다. . | . . 파라미터 정의시 사용되는 제네릭타입의 타입제한(와일드 카드) . 제네릭타입(class)는 1개 타입 or 상/하한의 타입을 받아 저장하는 자료구조(?)에 사용된다. . | 제네릭타입 자료구조의 타입 지정(제한)을 하면서 &amp;&amp; 그 제네릭타입의 (생성)기능호출은 더 바깥에서 Helper (Static)클래스의 메서드 파라미터에서 변.&lt;구&gt;.제로서 정하여 사용한다고 가정한다. . 참고로.. 호&lt;&gt;.구.지정사용시.. 와일드카드를 사용못하네… 상한 지정해주고 -&gt; 정의부에서 ? extends 상한 으로 바꿔서 파라미터 정의해주기 | . . | 해석 . 01 생성자or메서드 파라미터에 상한의 와일드카드 쓴 제네릭 자료구조 -&gt; (외부에선 하위객체위주로 인자대입)내부 하위class 형 타입을 필드로 가짐 -&gt; 상한class를 setter는 못해줌 But 하위필드를 꺼내 상한(상위class)변수에 할당 및 생성은 가능. . private static class GenericCategoryHelper { public static void popNoodle(final GenericCategory&lt;? extends Noodle&gt; extendsNoodleCategory) { // 1) Noodle 및 그이하가 꺼내지면 -&gt; 하위class로 생각 -&gt; 우항에 꺼낼 수 있다. -&gt; 경계이면서 상위class인 Noodle에 다 받을 수 있다. (모든 경우) final Noodle noodle = extendsNoodleCategory.getValue(); // 2) 하지만, 내부 하위class 필드를 가진다고 보면 -&gt; 경계이면서 상위class인 Noodle의 값을 우항으로 대입할 수 없다. // -&gt; 모든 경우가 만족안되서 컴파일 에러가 난다. // extendsNoodleCategory.setValue(new Noodle()); } . . 제네릭타입은 주로, 해당 자료구조 사용처 메서드에서, 파라미터에서 상하한제한을 와일드카드로 건다 파라미터쪽으로 외부에서는 최상위 형이하로 들어온다 | 이하로 들어온다고 보장받으면 꺼내는 것(getter), 꺼낸 것을 주입하여 생성하는 것은 OK이다. 꺼낸 값을 변수가 부모&amp;추상체에 해당하는 상한을 지정해주면로 그 이하를 모저리 받을 수 있기 때문이다. 우항: 꺼낸 것 -&gt; Noodle과 Noodle이하 | 좌항: 변수, 주입되서 생성 -&gt; Noodle로 지정해주면 그 이하 다 받아줌 | . | . | | 02 생성자or메서드 파라미터에 하한의 와일드카드 쓴 제네릭 자료구조 -&gt; (외부에선 상위객체위주로 인자대입)내부 상위class필드를 가짐 -&gt; 하한이하의 하위class 대입(저장) 가능 + 꺼내면, 상위class기 때문에 경계의 하위class에 값꺼내 할당은 불가능 . public static void pushNoodle(final GenericCategory&lt;? super Noodle&gt; superNoodleCategory) { //1) Noodle 및 그 이상이 꺼내지면 -&gt; 그 자료구조(내부 변수) 상위class 필드에 &lt;- 하위class객체(Noodle)를 setter할 수 있다 superNoodleCategory.setValue(new Noodle()); //2) 하지만, 상위class 필드를 꺼내 -&gt; 하위타입인 하한(Noodle) 담을 순 없다. //final Noodle noodle = superNoodleCategory.getValue(); } . . 예시1) 제네릭타입 E -&gt; 제네릭메서드에 E(타입매개변수)에 대한 상/하한 제한 with PECS . 제네릭메서드에 ? extends E(제네릭타입의 타입매개변수)로 상한제한(내부하위필드or하위값)을 하면, 꺼낸 값(E하위)이 내부필드(제타의 내부필드 E고정)에 대해 안전하여 제타E에, 외부에서 들어올 제네릭메서드 파라미터 값들을 안전하게 값 할당 -&gt; 제타필드를 Produce해주기가 가능 . . 제네릭메서드에 ? super E(제네릭타입의 타입매개변수)로 하한제한(내부상위필드or상위값)을 하면, 상위필드를 가진 자료구조로 생각하고 내부필드(제타의 내부필드 E고정)가 하위값으로 소비하는 것에 안전하여 외부에서 들어올 제네릭메서드 파라미터 값들(X) 상위필드 자료구조 -&gt; 제타E의 하위값들 안전하게 대입 -&gt; 제타필드를 Consumer해주기가 가능 . . PECS에서 P와 C는 제네릭타입(class, interface)속 필드를 생성(초기화)해주느냐, 갖다쓰느냐의 이야기였다. . 제네릭 타입소거 . 컴파일타임에 타입을 검사 | 런타임에는 소거 해당 정보를 알 수 없다. | Java 5에서 등장했기 때문 | . | 4이전 기존코드도 돌아가게 하기 위해 타입소거가 등장함. | . . 오브젝트 . 오브젝트 속 if instanceof(타입검사)를 줄이는 generic . 내 생각 . Object가 모든 타입을 받아들였지만, 각 instance검사후 타입캐스팅(타입변환후) 작업하는 것처럼하는것 처럼 | 추상체는 여러 구상체를 받을 수 있지만, 각 구상체마다 하는 일이 달라진다면, 전략패턴을 썼었고 | 여러 구상체를 받는 외부 추상체를 파라미터로 받아 들어오는 구상체마다 instanceof로 자신 내부의 일이 달라지는 클래스가 있다면 외부 추상체를 T형으로 받고, class옆에는 ? extends T의 상한제한을 걸어주면 | 외부 추상체로만 알아서 instanceof를 쓰던 타 클래스에서 제네릭 적용을 통해 외부 특정 구상체를 아는 타 클래스가 되도록 한다. | . | 외부 특정 구상체를 아는 제네릭 타클래스가 만약, 추상클래스 + 템메패턴이라면 -&gt; 자식클래스 또한 제네릭 타클래스&lt;T&gt;의 제네릭을 받는 추상클래스로 선언할 수 있고, new 자식()을 만들어도, 추상클래스로서 {}중괄호로 실시간 다르게 구현해야만 한다. | |",
            "url": "blog.chojaeseong.com/java/generic/%ED%85%8C%EC%BD%94%ED%86%A1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/03/%EC%A0%9C%EB%84%A4%EB%A6%AD1.html",
            "relUrl": "/java/generic/%ED%85%8C%EC%BD%94%ED%86%A1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/03/%EC%A0%9C%EB%84%A4%EB%A6%AD1.html",
            "date": " • Apr 3, 2022"
        }
        
    
  
    
        ,"post86": {
            "title": "command 분기 제거를 인터페이스+enum",
            "content": "전략패턴처럼 분기를 추상화하되, 외부주입 대신 enum에서 구현체 받아오기 . 01 일단 1개 분기에 대해서 전략package&gt;구현체1개 -&gt; 내부 구현체클래스.전메()로 1개만 먼저 만들기 . 각 분기별 전체 로직이 추상체변수. 전메()로 실행될 수 있도록 1개 분기를 예시로 구현체class생성 -&gt; 전메로 로직 일괄호출()하도록 메서드를 만든다. | | . public void run() { final PairProgram pairProgram = new PairProgram(); while (!pairProgram.isOff()) { final Menu menu = Menu.from(inputView.inputMenu()); if (menu == Menu.MENU_1) { pairMatch(pairProgram); } if (menu == Menu.MENU_2) { pairSelect(pairProgram); } if (menu == Menu.MENU_3) { pairProgram.initPairs(); } if (menu == Menu.MENU_Q) { pairExit(pairProgram); } } } . . . . . . . . 02 1개 구현체속 전메가 완성 -&gt; @override를 붙여서 인터페이스로 뺀다. . . . . 03 뽑아낸 전략추상체.전메()로 로직상의 구현체.전메()를 대신해야한다. 구현체들의 외부주입의 전략패턴이 아니라면? -&gt; enum의 필드에 함형로 구현체들을 매핑해놓고 가져다 사용해야한다. enum필드 = 함형 Type이다. . . 원래는 구현체 1개 -&gt; 추상체로 바꾸고 -&gt; 그 추상체를 변수or파라미터에서 받아서 외부제공해줘야하는데, 여기서는 enum에게 메세지를 던져서 해당 구현체가 나오도록 던져져야한다. . . 분기마다 구현체실행되니 -&gt; 선택된 enum의 field에 분기별 구현체 생성 매핑해둔다. 이 때, enum의 구현체 매핑 필드 변수가 구현체 생성호출하는 함수형인터페이스&lt;추상체&gt;가 된다. | . | enum에게 메세지를 던져 현재 선택된 구현체에 구현체.전메()를 쓸 수 있도록 추상체.전메()로 정의해준다. | enum에게 메세지를 던질 시, . | enum으로 가서, 각 필드마다, 분기에서 추상체.전메()형태로 사용될 new 구현체()들을 생성할 수있게 함수형인터페이스로 정의해주고, 필드의 변수명을 함형&lt;추상체&gt;로 받아준다. . | . 1) 추상체 객체 통로를 통한 구현체 외부주입(전략패턴)이 아니라, 2) 추상체 객체 통로없이 enum의 추상체 필드에 매핑된 구현체 가져오는 방법을 쓴다. (외부주입될 구현체들은 enum에 메달려 있고(매핑), 그것을 enum특성으로 돌면서 찾아거 가져온다.) . . 변수자리에 함수호출(생성자호출하여 객체생성)을 매핑하고 싶다면, () -&gt; {} 람다로 정의해두고 필드는 함수형인터페이스로 정의해주면 된다. . . . . 이넘에 넣어줄 생성자호출함수 정의하면서 나머지 분기도 다 정리해준다. . . 그냥 기존 구현체 1개를 드래그해서 복붙해서 생성하는게 더 빠를지도? . . | . . 그냥 첨부터 enum. 메달린구현체getter()로 해주면 된다. 이제 알아서 구현체를 가져온 상태 -&gt; 전메만 호출시켠 알아서 각 분기속 로직이 작동된다. . . . . public void run() { final PairProgram pairProgram = new PairProgram(); while (!pairProgram.isOff()) { final Menu menu = Menu.from(inputView.inputMenu()); new PairMatch().execute(inputView, outputView, pairProgram); final Supplier&lt;CommandMenu&gt; commandMenuGenerator = menu.getCommandMenuGenerator(); final CommandMenu commandMenu = commandMenuGenerator.get(); commandMenu.execute(inputView, outputView, pairProgram); } } . input -&gt; output -&gt; input 꼬리를 무는 controller 속 순서로직 -&gt; 메세지보내서 내부에서 처리 . 최초 시작 객체에 메세지를 던지면 된다. 메세지를 던질 때는, 첨부터 필요한 재료를 다 던져서, 책임을 위임한다. . 첫시작객체.메세지를 가장 마지막 메서드()로 | . . | . . 메서드추출로 해주는게 편하다 -&gt; 메세지를 보낼 시작객체만 앞으로 빼면 된다. . . | . . 빨간줄뜨는 메소드내 없는 객체 -&gt; 파라미터로 추출 . 자기자신이 메세지보내고 있는 객체. -&gt; 생략 | 자기자신이 파라미터로 들어간다? -&gt; this | . . | . .",
            "url": "blog.chojaeseong.com/java/%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%8C%A8%ED%84%B4/%EB%B6%84%EA%B8%B0%EC%A0%9C%EA%B1%B0/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/enum/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%B2%B4%EC%8A%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/03/%EB%B6%84%EA%B8%B0%EC%A0%9C%EA%B1%B0-%EC%9D%B8%ED%8E%98%EC%B6%94%EC%83%81%ED%99%94%ED%9B%84-%ED%86%B5%EB%A1%9C+%EA%B5%AC%ED%98%84%EC%B2%B4-%EC%A3%BC%EC%9E%85%EC%9D%84-enum%EC%97%90%EC%84%9C-%EB%B0%9B%EA%B8%B0.html",
            "relUrl": "/java/%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%8C%A8%ED%84%B4/%EB%B6%84%EA%B8%B0%EC%A0%9C%EA%B1%B0/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/enum/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%B2%B4%EC%8A%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/03/%EB%B6%84%EA%B8%B0%EC%A0%9C%EA%B1%B0-%EC%9D%B8%ED%8E%98%EC%B6%94%EC%83%81%ED%99%94%ED%9B%84-%ED%86%B5%EB%A1%9C+%EA%B5%AC%ED%98%84%EC%B2%B4-%EC%A3%BC%EC%9E%85%EC%9D%84-enum%EC%97%90%EC%84%9C-%EB%B0%9B%EA%B8%B0.html",
            "date": " • Apr 3, 2022"
        }
        
    
  
    
        ,"post87": {
            "title": "데분방03-2) 회귀식과 상관계수(...to be continue)",
            "content": "회귀분석 방법 | . Chapter 6. Regression and correlation . 6.1 Simple linear regression | 6.2 Residuals and fitted values | 6.3 Prediction and confidence bands | 6.4 Correlation | .",
            "url": "blog.chojaeseong.com/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EB%8D%B0%EB%B6%84%EB%B0%A91/2022/04/03/03-%EB%8D%B0%EB%B6%84%EB%B0%A903-2)Regression-and-correlation.html",
            "relUrl": "/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EB%8D%B0%EB%B6%84%EB%B0%A91/2022/04/03/03-%EB%8D%B0%EB%B6%84%EB%B0%A903-2)Regression-and-correlation.html",
            "date": " • Apr 3, 2022"
        }
        
    
  
    
        ,"post88": {
            "title": "의연방07) RCT 연구",
            "content": "&#54617;&#49845; &#44060;&#50836; . &#54617;&#49845;&#47785;&#54364; . RCT의 정의와 목적을 설명할 수 있다. . | 랜덤화의 목적과 구체적인 방법을 설명할 수 있다. . | RCT의 결과를 보고하는 원칙과 포함되어야하는 내용을 설명할 수 있다. . | . &#51452;&#50836;&#50857;&#50612; . 랜덤화 (Randomization) : 모든, 각각의 연구대상자를 치료군과 대조군에 확률적으로 배정하는 과정 . | 대조군 (Control group) : 연구의 대상이 되는 intervention을 받지 않는, 비교의 기준이 되는 그룹 . | 눈가림 (Blinding) : 각 연구대상자가 어떤 그룹에 속했는지 모르게 하는 것 . | ITT(intention-to-treat) principle : 랜덤 배정된 모든 환자의 모든 데이터를, 배정된 그룹으로 간주하여 분석한다는 원칙 . | . RCT . RCT in clinical research . 앞서서 관찰 연구들(cohort, cross-sectional, case-control study)에 대해 살펴보고, 그 연구들에서 위험요소와 질병간의 상관관계를 알아보았다. . | 위험요소와 질병의 상관관계, 인과관계 연구의 최종 목표 . modifiable risk factors를 modify하는 인터벤션을 통해 질병을 예방, 치료, 완화하는 것 | . | 이 위험요소를 수정하는 인터벤션이 실제로 질병발생에 효과가 있는지/없는지를 과학적으로 증거를 살펴봐야지, 실제로 임상시험에 사용할 수 있다. . RCT: 인터벤션(위험요소 수정)과 질병과의 인과관계를 과학적으로 rigorous하게 보이는 유일한 방법 | . | 임상시험(Clinical trial): 사람을 대상으로 전향적으로 인터벤션의 효과를 평가하는 연구 . 임상시험 중에서도, (관심인구가 있는 상태에서) 사람=연구대상자=(치료군vs대조군)을 랜덤하게 배정하는 임상시험을 RCT라 한다. my) case-controls study: 질병O군 -&gt; 질병X군 &amp; 연구자가 지정 | my) RCT: 치료군 + 치료X군 &amp; 랜덤하게 지정 | . | . | . . Study population: 관심 그룹 . 랜덤하게 배정한 치료군(Intervention) 이 중에 얼마나 질병이 나았나 | 이 중에 얼마나 질병이 낫지 않았나 | . | 대조군(Control) 이 중에 얼마나 질병이 나았나 | 이 중에 얼마나 질병이 낫지 않았나 | . | | . | 이 중에 얼마나 질병이 나았나/낫지 않았나의 비율이 -&gt; 치료군과 대조군 사이에 차이가 있는지 확인한다. . | . &#47004;&#45924;&#54868; (Randomization) . 랜덤화의 목적: 랜덤하게 배정하면 Confounder가 없어진다 &amp; 뽑을 때 발생하는 bias없이 인터벤션-&gt;질병의 효과를 추정 앞서, 위험요소-질병간의 상관관계가 관측되었을 때, 상관관계가 진짜인지? 인과관계로 인한 상관관계 vs confounder때문에 겉으로 보기에만 발생한 상관관계 구분해야한다고 했다. | 우리는 인과관계를 성립하고 싶다 -&gt; 방해가되는 confounding을 없애야한다 -&gt; 그 수단이 랜덤화로서, random chance로만 인터벤션O/X 여부(치료군/대조군)가 결정되어 systematic difference가 없어진다 -&gt; confounder의 개입효과가 없어진다 -&gt; 치료군/대조군 간의 차이는 오직 인터벤션O/X의 차이 때문이다. confounder의 설명변수(intervention)에 대한 효과가 끊어진다. 인터벤션O/X여부가 오로지 확률에 의해서만 결정된다. | 이 상태에서, 인터벤션-outcome간의 상관관계 = 100% 인과관계에 의한 것 | . | . | . | . &#51076;&#49345;&#49884;&#54744;&#51032; 4&#45800;&#44228; . Phase I | Phase II | Phase III | Phase IV | . Phase I Trials . 상관관계 등을 살펴보기 이전에, 인터벤션이 사람한테 해도 되는지/어느 강도로 해야하는지 안전성에 대한 시험 . | DLT(dose-limiting toxicity)를 정해놓고 -&gt; MTD(정해진 비율의 환자가 DLT를 겪게 되는 dose)를 추정하는 것이 주 목적 . | . . Phase II Trials . phase 3로 갈지/말지를 판단하는 작은 스터디 | safety 목표 : toxicity에 대한 정보를 더 모으고 dose 확정 | efficacy 목표 : 단기 효과 추정.“proof-of-concept” study | 보통 100명 미만, 많아도 200 ~ 300명 미만의 연구대상자 | . Phase III Trials . Full-scale, confirmatory study | 반드시 대조군이 있어야 함. | 일반적으로 말하는 Randomized Controlled Clinical Trial (RCT)에 해당됨 인터벤션의 효과가 있다/없다를 가르는 최종 Trial. 보통의 RCT를 의미함 | . | 300 ~ 3000명, 경우에 따라서는 그 이상의 연구대상자 | 의약품 시판 허가를 위해서 필요 | . Phase IV Trials . 시판된 의약품을 대상으로, 리얼월드에서 어떻게 효과가 관찰되는지 보는 study | phase 3에서 보기 힘들었던 장기효과 or 드문 부작용을 보게 된다. | 의약품 혹은 의료장비가 시판된 후에 이루어지는 장기 연구 | Phase III Trials에서 관측되지 못한 것들에 대한 추적 관찰 장기 효과 | rare side effect | 결과에 영향을 미치는 여러 요인들이 통제 되지 않은 | real-world setting에서의 효과 | . | . RCT &#50896;&#52825; . &#51076;&#49345;&#49884;&#54744;&#51032; &#50896;&#52825; . 임상시험: 인간을 대상으로 함. 관찰연구와 다르게 연구자가 인터벤션을 직접 가하는 것. 관찰연구에 비해 원칙을 철저하게 지켜야함. | 가장 중요한 가이드라인: ICH 임상시험의 디자인, 수행, 기록, 결과보고에 대한 윤리적, 과학적 기준을 여러 국가의 합의에 의해 만들어짐 | 헬싱키 선언에 따라 연구대상자의 권리, 안전, 웰빙을 보호 | 신뢰성있는 임상시험 데이터 획득 가능 | . | 각국의 임상시험 관련 규제를 따라야한다. 우리나라 : 생명윤리법, 약사법, 식약처 행정규칙(의약품 임상시험 관리기준 등), 의료기기법, 개인정보 보호법 등 | . | . | . 윤리적이어야 한다 사람에게 가하는 것이기 때문에 과학적이지 않으면, 비윤리적이다. | . | (거의 항상) 대조군 (Control group)이 필요하다 | 가능한 경우 눈가림 (Blinding)이 선호된다 | 연구대상자를 치료군과 대조군에 배정하는 방법은 랜덤화 (randomization)가 선호된다 | &#45824;&#51312;&#44400; . 연구의 대상이 되는 intervention을 받지 않는, 비교의 기준이 되는 그룹 | 실험군(=치료군)과 intervention 여부를 제외한 모든 면에서 비슷할 수록 좋다 그래야만, 2군과의 차이가 인터벤션 차이다 라고 말할 수 있기 때문 | . | 대조군이 없이는 intervention의 효과를 알 수 없다 어떤 사람은, 대조군없이, 치료군에 대해 인터벤션 전/후의 outcome을 비교하는 pre-post design의 임상시험을 계획하곤 한다 하지만, 인터벤션을 받는 동안 발생한 시간만으로도 어떠한 효과가 발생할 수 있다. | . | 치료군에서 관측된 intervention 전/후의 차이는 꼭 intervention의 효과가 아닐 수 있다 | 대조군 vs. 치료군의 비교가 필수적이다 | . | . 대조군도 종료가 어려가지임 . No intervention: 자연상태 그대로 | 플라시보 (Placebo): 약물 효과 관찰시, 똑같이 생긴 위약을 복용케 함 | Usual care: 현재 실행되는 일반적인 케어(일반치료법) | Standard of care: 가이드라인 케어(표준치료법) | | 효과가 입증된 치료법이 존재하는 경우, no intervention이나 placebo를 대조군으로 사용하면 안된다 . 윤리적이지 않기 때문 | 효과입증된 치료법이있다면, 일단 연구대상자에게 제공을 해야한다. | . | . &#45576;&#44032;&#47548; . 각 연구대상자가 어떤 그룹에 속했는지 모르게 하는 것 대상자는 자기가 치료군에 속했는지/ 대조군에 속했는지 모르게 함. | 무의식 중에 발생하는 bias를 방지하기 위해서 시행함 알게 되면... 나는 치료군이야... 인식만으로 몸 상태가 좋아질 수 있음/ 나는 대조군이야... 로 몸 상태가 안좋아질 수도 있음. | 또한, 대조군으로서 placebo를 복용 중임을 알게된다면, 중도 탈락할 확률이 높아진다. | . | . | 무의식 중에 편향을 일으킬 수 있는 가능성을 제거한다 연구대상자 : 자신이 치료군/대조군에 속했다는 것을 알게 되면, 증상이나 부작용 등을 다르게 인식할 수 있고, 중도 탈락 여부에 영향을 줄 수 있다 | 연구자, 임상의 : 연구대상자가 치료군/대조군에 속했다는 것을 알게 되면, 연구대상자의 치료에 영향을 줄 수 있다 연구자 조차도 모르게 | . | 평가자 : 연구대상자가 치료군/대조군에 속했다는 것을 알게 되면 outcome 측정에 영향을 줄 수 있다 평가하는 사람도 모르게 | . | . | . 더블 블라인드 | . &#47004;&#45924;&#54868; . 모든, 각각의 연구대상자를 확률에 의해 불확성성을 가지고 확률적으로 치료군or대조군으로 배정함 배정 확률이 모두 같을 필요는 없다. 하지만 확률적으로 배정하는 것이 중요하다. | 예1) 치료군이 대조군제외 2개이상일 수도 있다? a,b,c | 예2) 홀수날/짝숫날 -&gt; 불확실성이 없이 배정되기 때문에 랜덤화가 아니다 연구자가 치료군의 날자에 더 아픈사람을 선택할 수 있다 | 예3) 오는 순서대로 번갈아가면서 -&gt; 불확실성이 없이 배정되기 때문에 랜덤화가 아니다 연구자가 치료군의 순서에 더 아픈사람을 선택할 수 있다 2, 3번은 연구대상자에게는 눈가림이 되나, 연구자에게 눈가림이 안되서 랜덤화가 아니다. | . | . | . 7강 20분 slide 21번부터 .",
            "url": "blog.chojaeseong.com/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/rct/2022/04/02/%EC%9D%98%EC%97%B0%EB%B0%A907)-Randomized-Controlled-Trial.html",
            "relUrl": "/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/rct/2022/04/02/%EC%9D%98%EC%97%B0%EB%B0%A907)-Randomized-Controlled-Trial.html",
            "date": " • Apr 2, 2022"
        }
        
    
  
    
        ,"post89": {
            "title": "while 분기속 if break; 리팩토링",
            "content": "while(true) if break; 로 먼저 작성하기 . 01 while(ture)의 무한반복문에서 break;분기부터 작성해보기 . public class MyApplication { public static void main(final String[] args) { // 0. input객체 + 메인로직 특정객체 미리 만들어두기 final InputView inputView = new InputView(); final 특정객체 특정객체 = new 특정객체(); // 1. 일단 while(true) {} 로 돌아가면서 break부터 생각해본다. while (true) { // 1-1. 매번 받는 입력도 돌아가야한다. final String inputCommand = inputView.inputCommand(); // 1-2. 가장 간단한 경우부터 생각해본다. 어차피 if break; if continue; 일듯 싶어서 if (inputCommand.equals(&quot;end&quot;)) { } } private static class 특정객체 { } } . public class MyApplication { public static void main(final String[] args) { final InputView inputView = new InputView(); final 특정객체 특정객체 = new 특정객체(); while (true) { final String inputCommand = inputView.inputCommand(); // 1-3. if 종료버튼 + if 특정객체 종료조건 까지 걸려서 멈춘다고 한다. // -&gt; end를 눌럿을 때, ready / running / finished 중 finished 상태만 -&gt; 로직종료 + 입력도 종료(break;) if (inputCommand.equals(&quot;end&quot;)) { if (특정객체.isNotRunning()) { break; } } } } private static class 특정객체 { public boolean isNotRunning() { return true; } } } . 02 break;를 가진 분기를 만들었다면, 편하게 나머지 분기들을 늘려도 된다. 대신, if 속 break;는 flag로 밖에 처리 못하니, while문 맨 끝에 배치하고, 위로 채워가자?! . 여기선, if 종료버튼 눌른 뒤, if 특정조건 아니면 break;종료를 안한다. (게임 결과 출력은 Finished상태가 아니라, RunningToFinished되는 game.end()호출 순간이다.) . public class MyApplication { public static void main(final String[] args) { final InputView inputView = new InputView(); final 특정객체 특정객체 = new 특정객체(); while (true) { final String inputCommand = inputView.inputCommand(); // 1-3. if에 if 특정객체에 조건 까지 걸려서 멈춘다고 한다. // -&gt; end를 눌럿을 때, ready / running / finished 중 finished 상태만 -&gt; 로직종료 + 입력도 종료(break;) if (inputCommand.equals(&quot;end&quot;)) { // 1-4-1. end눌렀을 때 상태3개 중 ready/running/finished , 바로 finished 상태면 바로 종료?? ready -&gt; 바로 종료 if (특정객체.isNotRunning()) { break; } //1-4-2. break;로 바로 종료(ready/finished)의 배반인 running 상태 // -&gt; if early return처럼 early break 아래부분도 [if의 배반]이다. // -&gt; end 눌렀는데 아직 특정객체가 Running 중 이라면? // (1) running중인 정보(board)를 가지고 finished상태로 만들도록 명령한 뒤 특정객체.end(); // (2) 이 때만(ready(X), finsihed(X) running to finished by .end() )시에만 게임결과를 출력한다. // my) running -&gt; finished 순간을 캐취해서 게임결과를 출력해줘야한다. (가만히 있는 finished는 출력할 필요도 없이 종료) System.out.println(&quot;게임 하다가 끝났기 때문에, 게임 결과를 출력합니다.&quot;); } } } private static class 특정객체 { private String state; public 특정객체() { this.state = &quot;running&quot;; } public boolean isNotRunning() { if (this.state.equals(&quot;running&quot;)) { System.out.println(&quot;running상태입니다.&quot;); return false; } System.out.println(&quot;ready or finished상태입니다.&quot;); return true; // ready나 finished상태 } public void end() { System.out.println(&quot;상태가 running -&gt; finished&quot;); this.state = &quot;finished&quot;; } } } . state패턴으로서 start명령어가 있다면, ready가 기본이 된다. (end만 있을 땐 running을 기본으로 해서 게임-&gt;종료되는 상황 연출) . public class MyApplication { public static void main(final String[] args) { final InputView inputView = new InputView(); final 특정객체 특정객체 = new 특정객체(); while (true) { final String inputCommand = inputView.inputCommand(); //1-5-1. start명령어를 받는 순간부터, ready가 default이며, start에 의해 ready to Running으로 넘어간다. if (inputCommand.equals(&quot;end&quot;)) { if (특정객체.isNotRunning()) { break; } // (1) running중인 정보(board)를 가지고 finished상태로 만들도록 명령한 뒤 특정객체.end(); // (2) 이 때만(ready(X), finsihed(X) running to finished by .end() )시에만 게임결과를 출력한다. // my) running -&gt; finished 순간을 캐취해서 게임결과를 출력해줘야한다. (가만히 있는 finished는 출력할 필요도 없이 종료) System.out.println(&quot;게임 하다가 끝났기 때문에, 게임 결과를 출력합니다.&quot;); } } } private static class 특정객체 { private String state; public 특정객체() { // this.state = &quot;running&quot;; this.state = &quot;ready&quot;; // 1-5-2. start명령어가 있다면, ready가 기본이 된다. } public boolean isNotRunning() { if (this.state.equals(&quot;running&quot;)) { System.out.println(&quot;running상태입니다.&quot;); return false; } System.out.println(&quot;ready or finished상태입니다.&quot;); return true; // ready나 finished상태 } public void end() { System.out.println(&quot;상태가 running -&gt; finished&quot;); this.state = &quot;finished&quot;; } } } . 03 아주 만약, 모든 분기마다 자기일 끝나고 맨 마지막에 공통로직을 처리해줘야한다면, 굳이 continue;(반복문의 ealry return)로 아래로 내려가는 것을 안 막는다. . 각 분기 중 택1을 작업후, 다 제끼고 내려와, 분기없이 실행되는 로직(ex&gt; 무한반복문 아니라면 while조건속에 들어갈 count++변수 업데이트?) . my) 반복문 속 분기이후 공통로직/업데이트로직이 있는 남아있다면, continue;를 안쓴다. 만약, 맨 아래 공통로직 없이 분기 택1의 로직만 일어난다면 continue;로 아래로 내려가는 것을 막아 검사조차 안되게 하자. . public static void main(final String[] args) { final InputView inputView = new InputView(); final 특정객체 특정객체 = new 특정객체(); while (true) { final String inputCommand = inputView.inputCommand(); if (inputCommand.equals(&quot;start&quot;)) { 특정객체.start(); System.out.println(&quot;게임을 시작합니다.&quot;); //continue; // while continue 여부는 분기외에 아래 달릴 로직을 거치느냐 안거치느냐 차이 // -&gt; [공통로직 ]있으면 continue를 빼고 거치게 하지만, 택1의 분기라면 continue;를 달아주자. // -&gt; 지금은 맨 아래 print가 공통로직이라고 치고 있으니 continue;를 제거하자. } if (inputCommand.equals(&quot;end&quot;)) { if (특정객체.isNotRunning()) { break; } 특정객체.end(); System.out.println(&quot;게임 하다가 끝났기 때문에, 게임 결과를 출력합니다.&quot;); } // 공통로직을 매 입력-회전마다 거치는 경우에는 continue;를 쓰면 안된다. System.out.println(&quot;공통로직입니다. 한바퀴돌고 재입력받기 직전입니다.&quot;); } } . while(true) 반복문 속 if break;의 메서드 추출 . 01 if 종료조건 break; 는 메서드 추출을 위해 -&gt; if 종료조건 flag변수(Enum) Off처리; + continue;로 while조건문으로 보낸 뒤 -&gt; while조건문에 flag검사( not isOff()? )로 변경한다. . break; 대신 돌아가는 로직 객체의 flag변수(enum)에 .end()처리를 하고, continue;로 아래론 못가고, while문으로 가서 조건 검사를 바로 하게 한다. . 그림에선 boolean변수에 true/false를 주지만 캡슐화 및 확장성을 고려하여 enum으로 flag변수를 가지게 한다. . 메인로직을 담당하는 객체에 flag(enum)변수를 항상 변할수있는 상태값으로 가지게 한다. | . . ​ ​ . | . while (true) { final String inputCommand = inputView.inputCommand(); if (inputCommand.equals(&quot;start&quot;)) { 특정객체.start(); System.out.println(&quot;게임을 시작합니다.&quot;); } if (inputCommand.equals(&quot;end&quot;)) { if (특정객체.isNotRunning()) { //break; 특정객체.exit(); // flag isEnd = true; continue; // break; 대신 밑으로 못내려가게 일단 막아주자. } 특정객체.end(); System.out.println(&quot;게임 하다가 끝났기 때문에, 게임 결과를 출력합니다.&quot;); } if (inputCommand.equals(&quot;status&quot;)) { System.out.println(&quot;갑자기 결과를 출력합니다. &quot;); } } . private static class 특정객체 { private String state; private boolean isEnd; //... public void exit() { this.isEnd = true; } } . 02 flag .off() 처리후 continue;로 올라간 조건문 검사를 while (true) -&gt; 플래그변수가.isOff()인지 검사로 변경한다. . flag isEnd = true; 하는 순간, 다 continue (or return되서 ) while 조건문으로 보내야한다 조건문에서는 flag를 확인하여 입력과 반복을 종료시킨다 | . | . . 반복문은 break;였던 자리가 flag에 걸려서 종료되기 전까지 돌아야한다 !를 달아준다. | . | . . public class MyApplication { public static void main(final String[] args) { final InputView inputView = new InputView(); final 특정객체 특정객체 = new 특정객체(); //while (true) { while (!특정객체.isEnd()) { final String inputCommand = inputView.inputCommand(); if (inputCommand.equals(&quot;start&quot;)) { 특정객체.start(); System.out.println(&quot;게임을 시작합니다.&quot;); } if (inputCommand.equals(&quot;end&quot;)) { if (특정객체.isNotRunning()) { //break; 특정객체.exit(); // flag isEnd = true; continue; // break; 대신 밑으로 못내려가게 일단 막아주자. } 특정객체.end(); System.out.println(&quot;게임 하다가 끝났기 때문에, 게임 결과를 출력합니다.&quot;); } if (inputCommand.equals(&quot;status&quot;)) { System.out.println(&quot;갑자기 결과를 출력합니다. &quot;); } } } private static class 특정객체 { private String state; private boolean isEnd; //... public boolean isEnd() { return this.isEnd; } } } . 03 if break; -&gt; if flagOff + contine + while flag isOff()검사 해줬어도 if조건식에 extract method는 depth를 못 줄인다 . if + if전체를 추출하려고 하면, . 바깥if의 boolean문만 파라미터 추출 -&gt; t/f 메서드로 추출하여 통째로 넘어간다 | . . | 내부if 부분만 추출하려고 하면 . 내부 if 조건문 속 boolean문만 파라미터 추출 -&gt; true/false의 메서드 추출하여 통째로 넘어간다 . . . | . | 04 if조건문의 메서드추출은 수동으로 통째로 . if 문 위에 추출할 메서드를 빨간줄 작성후 생성 . . . 05 복붙으로 코드 옮겨가고 flag변수.Off() 처리후 continue; 대신 -&gt; 1) early return; + 2) 추출메서드를 while문 맨 뒤에 배치하여 flag처리 직후 while조건문 검사하는 continue;효과내기 . . . public static void main(final String[] args) { final InputView inputView = new InputView(); final 특정객체 특정객체 = new 특정객체(); //while (true) { while (!특정객체.isEnd()) { final String inputCommand = inputView.inputCommand(); if (inputCommand.equals(&quot;start&quot;)) { 특정객체.start(); System.out.println(&quot;게임을 시작합니다.&quot;); } if (inputCommand.equals(&quot;end&quot;)) { depth줄이기위한if통째로추출(); } if (inputCommand.equals(&quot;status&quot;)) { System.out.println(&quot;갑자기 결과를 출력합니다. &quot;); } } } private static void depth줄이기위한if통째로추출() { if (특정객체.isNotRunning()) { 특정객체.exit(); // flag isEnd = true; //continue; return; // 통째로 추출이기 때문에 return;하면 해당 분기 종료되므로 break; continue; early return기능은 있지만 + flag처리 직후 while조건문 검사기능은 구현불가능하다. // -&gt; 지금은 분기 택1의 로직만 일어나므로 바로 while문 검사하러 간다. // -&gt; 만약, return 아래로 더 내려간다면? 남은로직 or 공통로직이 있다면? -&gt; continue;를 return;후에 처버려야할듯? // depth추출 메서드를 빠져나갔는데 바로 while문으로 안가면 -&gt; 빠져나가 만나는 분기마다 continue; } 특정객체.end(); System.out.println(&quot;게임 하다가 끝났기 때문에, 게임 결과를 출력합니다.&quot;); } . while문을 재귀로 고치기 . 01 while속 돌아가는 모든 (분기)로직들을 통으로 1개 메서드로 추출 . . inputView는 원래 컨트롤러 속이라면 상태값을 가지고 있을 예정이기 때문에 일단 파라미터에 제외시켜야함 . . | . public static void main(final String[] args) { final InputView inputView = new InputView(); final 특정객체 특정객체 = new 특정객체(); while (!특정객체.isEnd()) { playGame(특정객체); } } private static void playGame(final 특정객체 특정객체) { final String inputCommand = new InputView().inputCommand(); if (inputCommand.equals(&quot;start&quot;)) { 특정객체.start(); System.out.println(&quot;게임을 시작합니다.&quot;); } if (inputCommand.equals(&quot;end&quot;)) { depth줄이기위한if통째로추출(); } if (inputCommand.equals(&quot;status&quot;)) { System.out.println(&quot;갑자기 결과를 출력합니다. &quot;); } } . 02 while !EndFlag 조건문 = flag 확인문 -&gt; 재귀 속 break(EndFlag)하는 종착역으로서 먼저 if early return로 정의해주기 . 기존 while (! 끝나는 조건) -&gt; if 끝나는조건 : 재귀함수 return . . . | . . 재귀함수는 종착역인 if flag isEND() :return;이 반복문의 break와 동일하게 반복을 제거한다 . . 03 반복되던 로직의 if return종착역까지 완성됬으면 -&gt; 함수 끝날 때 자신(메서드) 부르기 . 내부 if return의 종착역만 있다면, 편하게 마지막에 한번 더 호출하여 반복하는 재귀함수를 만들 수 있다. . . public static void main(final String[] args) { final 특정객체 특정객체 = new 특정객체(); playGame(특정객체); } private static void playGame(final 특정객체 특정객체) { if (특정객체.isEnd()) { return; } final String inputCommand = new InputView().inputCommand(); if (inputCommand.equals(&quot;start&quot;)) { 특정객체.start(); System.out.println(&quot;게임을 시작합니다.&quot;); } if (inputCommand.equals(&quot;end&quot;)) { depth줄이기위한if통째로추출(); } if (inputCommand.equals(&quot;status&quot;)) { System.out.println(&quot;갑자기 결과를 출력합니다. &quot;); } playGame(특정객체); } . 04 while to 재귀로 만든 이유 -&gt; inputView가 포함된&amp;&amp;입력받는 것부터 시작하는 로직은 try로 살펴보는 시작이 input부터이면서 &amp;&amp; catch시 다시 input부터 시작하도록 재귀함수형태를 만들어하므로 . 01 1번만 성공적으로 input받는 로직과 다르게 try 끝에 성공했어도 반복되기 위해 재귀호출을 한다. 1번만 호출되려면 catch로 실패시 재귀호출하여 시도함 . . 02 catch에서 실패한 경우 input부터 다시 받기 위한 재귀호출 vs try끝에 thr없는 성공했는데도 반복을 위한 재귀호출 . . private static void playGame(final 특정객체 특정객체) { if (특정객체.isEnd()) { return; } //1. 일단 input부터 try로 살펴봐야한다. try { final String inputCommand = new InputView().inputCommand(); if (inputCommand.equals(&quot;start&quot;)) { 특정객체.start(); System.out.println(&quot;게임을 시작합니다.&quot;); } if (inputCommand.equals(&quot;end&quot;)) { depth줄이기위한if통째로추출(); } if (inputCommand.equals(&quot;status&quot;)) { System.out.println(&quot;갑자기 결과를 출력합니다. &quot;); } //2. 실패하지 않았지만, if 종착역 = flag걸리기 전까지 반복을 위해 재귀호출 playGame(특정객체); } catch (Exception e) { System.out.println(&quot;[ERROR] &quot; + e.getMessage()); //3. try로 [input부터 시작하는 로직]살펴보다가 thr걸릴 때, [input부터 다시 받기 위한 재귀 호출] playGame(특정객체); } } . my) input부터 시작하는 로직을 재귀함수로 만들면, try input부터 살펴보는 중에 실패하면 -&gt; catch에서 재귀호출하여 다시 input부터 시작할 수 있다. . Enum과 명령어 문자열 캡슐화 + 외부input시 검증까지 . 01 갯수가 정해진 input명령어들(문자열상수)은 분기비교에 사용시 enum객체필드에 캡슐화해놓고 사용하기 . 명령어 객체 -&gt; 복붙해서 문자열에 넣고 소문자로 만들기 | . . . . 02 일단은 분기 속 input문자열 vs 비교문자열 -&gt; Enum from정펙매( input ) VS enum객체로 바꿔서 비교하기 . my) 컨트롤러에서 상수 쓰지말고input을 정펙매에 넣어 찾아진 ENum객체 vs 상수캡슐화한 enum으로 비교 + enum은 스태틱변수라 메모리값 1개 -&gt; equals 안써도 된다. . . . input -&gt; 정펙메에서 전체 돌기 + filter로 해당 enum객체를 구분하여 생성한다 | . . 마찬가지로 input -&gt; enum.from( input ) | “문자열” -&gt; Enum.문자열캡슐화한객체 | . | . . private static void playGame(final 특정객체 특정객체) { if (특정객체.isEnd()) { return; } try { final String inputCommand = new InputView().inputCommand(); //if (inputCommand.equals(&quot;start&quot;)) { if (MyCommand.from(inputCommand) == MyCommand.START) { 특정객체.start(); System.out.println(&quot;게임을 시작합니다.&quot;); } if (MyCommand.from(inputCommand) == MyCommand.END) { depth줄이기위한if통째로추출(); } if (MyCommand.from(inputCommand) == MyCommand.STATUS) { System.out.println(&quot;갑자기 결과를 출력합니다. &quot;); } playGame(특정객체); } catch (Exception e) { System.out.println(&quot;[ERROR] &quot; + e.getMessage()); playGame(특정객체); } } . 03 외부 input으로 찾는 Enum정펙매은 기본적으로 이넘객체들에 캡슐화되어매핑된 문자열들로 -&gt; contains thr 검증이 자동 되며 + 외부input NullOrEmpty를 여기서도 할 수 있다. . enum 외부input 검증01 - 기본적으로 filter사용 == contains 검증 : filter에서 외부input이 내부캡슐화된 문자열에 속하지 않아 못찾으면 orElseThrow에서 에러thr나게 됨. . 외부 input -&gt; Enum정펙매 from -&gt; filter( 캡슐화된 문자열 .equals 외부 input) . filter에 안걸리는 것 = 캡슐화된 문자열에 속하지 않은 것 -&gt; thr | try로 input부터 보고있었으면 검증되서 다시 받는다. | . . | . enum 외부input 검증02 - 추가적으로 checkNullOrEmpty : 찾아들어가기전에 외부 input의 nullOrEmpty검사를 정펙매 여기서 해줄 수 있다. 왜냐? 재귀에서 input부터 처다보고 있는 상황이니까 반복됨. . . . . public enum MyCommand { START(&quot;start&quot;), END(&quot;end&quot;), STATUS(&quot;status&quot;), ; private final String value; MyCommand(final String value) { this.value = value; } public static MyCommand from(final String inputCommand) { checkNullOrEmpty(inputCommand); return Arrays.stream(MyCommand.values()) .filter(it -&gt; it.value.equals(inputCommand)) .findFirst() .orElseThrow(() -&gt; new IllegalArgumentException(&quot;잘못된 명령어입니다.&quot;)); } private static void checkNullOrEmpty(final String inputCommand) { Objects.requireNonNull(inputCommand, &quot;빈칸 입력은 허용하지 않는다.&quot;); if (inputCommand.trim().isEmpty()) { throw new IllegalArgumentException(&quot;빈칸 입력은 허용하지 않는다.&quot;); } } } . 외부input으로 찾는 Enum의 filter에 정규식을 쓰면? . 01 equals()는 Pattern.matches()에 포함되며 일치를 포함하여 일치를 포함하여 패턴을 가지는 문자열도 처리 . . 추가 캡슐화 문자열 -&gt; Enum객체가 생겼다. 어차피 개별 비교라서 상관은 없다 | . | 하지만 개별비교가 equals에서 패턴매칭으로 달라진다면? 상관없다. 패턴매칭은 equals를 포함한다 | . | . . 원래 Pattern 클래스는 .complie()로 패턴을 만들고 . 이후 Matcher.matches()를 써서 비교했던 것 같은데 . Matches없이 한번에 matches()로 t/f를 반환시킬 수 있다. | . . | . | . 02 equals() -&gt; Pattern.matches()로 교환했다면 nullOrempty 검증도 패턴매칭에 포함된다. . enum 외부input 검증03 - Patter.matches()를 쓸 경우 : nullOrEmpty검증도 매칭안되는 것에 걸려 검증된다. . . . . . enum으로 분기 제거까지 적용하려면? . 외부input + 정펙매로 해당 enum객체 -&gt; 해당 분기로직을 분기별 해당enum field에 함수형인터페이스 필드-&gt; 전략객체들 생성자 -&gt; 호출까지 따로 or 함수형인터페이스 1개 지정 -&gt; 람다식 가져가야한다. . 01 분기 제거를 가정하려면, 추상화된 객체(인페orEnum).메서드()로 빨간줄을 만든다. . . . 01 if 정펙매( input ) == 예상Enum의 분기마다 알아서 작동하게 하려면, 분기내 로직을 모두 해당Enum의 field로 가져올 수 있는지 봐야한다. . private boolean isRunning() { if (gameSwitch.isOff()) { return false; } return !isNotRunning(); } private boolean isStatusInRunning() { if (gameSwitch.isOff()) { return false; } return state.isStatus(); } private boolean isEndInRunning() { if (gameSwitch.isOff()) { return false; } return state.isFinished(); } .",
            "url": "blog.chojaeseong.com/java/break/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/%EC%B2%B4%EC%8A%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/02/while-if-break;%EB%A5%BC-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95.html",
            "relUrl": "/java/break/%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/%EC%B2%B4%EC%8A%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/04/02/while-if-break;%EB%A5%BC-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95.html",
            "date": " • Apr 2, 2022"
        }
        
    
  
    
        ,"post90": {
            "title": "데분방03-1) One and Two sample Test",
            "content": "&#44053;&#51032;&#49548;&#44060; . &#53412;&#50892;&#46300; . 일표본 t 검정방법 . 독립표본 t 검정방법 . 대응표본 t 검정방법 . &#49464;&#48512; &#47785;&#52264; . Chapter 5. One- and two-sample tests . 5.1 One-sample t test | 5.2 Wilcoxon signed-rank test | 5.3 Two-sample t test | 5.4 Comparison of variances | 5.5 Two-sample Wilcoxon test | 5.6 The paired t test | 5.7 The matched-pairs Wilcoxon test | . One- and two-sample tests . One-sample t test (&#51068;&#54364;&#48376; t&#44160;&#51221;) . x들이 평균 뮤/분산이 시그마제곱인 정규분포 따르는, 표본 n개 를 가정 귀무: 평균이 뮤 제로인가 | 대립: 평균이 뮤 제로가 아닌가 | . | 이럴 때, t통계량을 사용한다 t통계량 계산: x_bar - m0 / 표준오차s/루트n ~ 귀무가설이 맞다고 할 때 -&gt; 자유도가 n-1인 t분포를 따른다 | . | &#50696;&#51228; . example concerning daily energy intake in kJ for 11 women (Altman, 1991, p. 183). To investigate whether the women’s energy intake deviates systematically from a recommended value of 7725 kJ. . # -&gt; remcommend되는 량이 7725 kJ인데 # -&gt; 11개 데이터는 평균이 == 뮤제로(7725kJ)인지 검증해보기 # H0: m == 7725 # H1: m != 7725 -&gt; 자연스럽게 양측검증이된다. # cf) H1: m &lt; 7725 -&gt; 단측검증 . daily.intake &lt;- c(5260,5470,5640,6180,6390,6515, 6805,7515,7515,8230,8770) daily.intake . &lt;ol class=list-inline&gt; 5260 | 5470 | 5640 | 6180 | 6390 | 6515 | 6805 | 7515 | 7515 | 8230 | 8770 | &lt;/ol&gt; # -&gt; 실제 평균 등의 숫자데이터의 mean() + sd() + 중앙값by quantile() + @ (boxplot, hist) 각각 구해보기 mean(daily.intake) # -&gt; 평균은 7725보단 작네 . 6753.63636363636 sd(daily.intake) # -&gt; 변동까지 고려할땐 sd구하기 . 1142.12322213737 quantile(daily.intake) # -&gt; 중앙값을 봤을 때도, 7725보다 작을 것을 예상 . &lt;dl class=dl-horizontal&gt; 0% 5260 25% 5910 50% 6515 75% 7515 100% 8770 &lt;/dl&gt; t.test(daily.intake, mu=7725) # - t값, 자유도, p값=유의확률=0.01814 -&gt; 유의수준a=0.05 기준 p값 &lt; a보다 더 작아서 # --&gt; 귀무가설 기각 reject H0 # true mean is not equal to 7725 : 양측검증을 기본으로 하는 일표본t검정 # 95% 신뢰구간 =&gt; 평균이 95% 확률로 여기있는 구간 -&gt; 5986.348 &lt; &lt; 7520.925 7755보다 작은 곳에 95% 평균이 존재함 # --&gt; 이 구간만 봐도, 귀무가설 기각되겠구나 알 수 있다. # data deviate significantly(하게 벗어난다)from the hypothesis that the mean is 7725. . One Sample t-test data: daily.intake t = -2.8208, df = 10, p-value = 0.01814 alternative hypothesis: true mean is not equal to 7725 95 percent confidence interval: 5986.348 7520.925 sample estimates: mean of x 6753.636 . # : mu (def=0), -&gt; # mu=값을 안주면 0으로 검정하게 된다. # alternative = “grater”(“g”) or “less” (“l”) (def=two-sided), # -&gt; 단측검정으로서 &lt;&lt;h1기준&gt;&gt; mu보다 크다 검정 -&gt; alternative =&quot;g&quot;옵션 vs mu보다 작다 검정 alternative =&quot;l&quot;옵션 t.test(daily.intake, mu=7725, alternative = &quot;l&quot;) # H1: m &lt; 7725 # --&gt; 단측검정의 p-value는 양측검증 p-value/2만 해주면 그 값이다 # conf.level = 0.99 (def=0.95) . One Sample t-test data: daily.intake t = -2.8208, df = 10, p-value = 0.009069 alternative hypothesis: true mean is less than 7725 95 percent confidence interval: -Inf 7377.781 sample estimates: mean of x 6753.636 . 5.2 Wilcoxon signed-rank test . t-test는 샘플 수가 많은 경우, 정규분포에서 벗어나더라도 잘 작동(fairly robust)하지만, 이러한 가정을 쓰지 않고, 분포와 무관한 방법으로 사용할 땐 비모수적인 방법인 Wilcoxon signed-rank test를 사용한다 | . | 각 값Xi과 m0를 뺀 뒤, 부호를 상관하지 않고서 차이에 대한 rank로 검증해내간다 | . wilcox.test(daily.intake, mu = 7725) # V값은 양수ranks들의 합이며, 통계량의 p-value는.. . Warning message in wilcox.test.default(daily.intake, mu = 7725): &#34;cannot compute exact p-value with ties&#34; . Wilcoxon signed rank test with continuity correction data: daily.intake V = 8, p-value = 0.0293 alternative hypothesis: true location is not equal to 7725 . Two-sample t tes (&#46021;&#47549;&#54364;&#48376; t&#44160;&#51221;) . library(&quot;ISwR&quot;) data(energy) . my) &#48276;&#51452;&#52860;&#47100;&#51032; unique&#54620; &#48276;&#51452;&#51333;&#47448; = &#44536;&#47353;&#51032; &#49688; -&gt; 2&#44060;&#50668;&#50556; &#46021;&#47549;&#54364;&#48376; t&#44160;&#51221; &#44032;&#45733; . energy$stature # 범주칼럼 -&gt; 범주의 종류 = 그룹의 갯수 -&gt; 2종류 == 2그룹 . &lt;ol class=list-inline&gt; obese | lean | lean | lean | lean | lean | lean | lean | lean | lean | obese | obese | lean | obese | obese | lean | obese | obese | obese | lean | obese | lean | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;lean&#39; | &#39;obese&#39; | &lt;/ol&gt; # t.test(expend ~ stature) # stature의 2그룹(2값)에 따라서 expend의 평균비교를 t.tset로 하시오 # -&gt; y ~ x(그룹변수, 범주칼럼) # H0: m1=m2, H1: m1 != m2 t.test(expend ~ stature, data=energy) # 맨마지막에 각 그룹의 평균이 나옴 # 두 그릅의 평균을 뺀 뒤 표준화한 값이 t통계량 -&gt; # -&gt; t0 = -3.85 # df= 15.919 -&gt; 자유도 소수점이하로 나온다? -&gt; 분산을 서로 다르다고 보고 작업하는 구나 # -&gt; r에서 기본 제공하는 t-test인 Welch 독립표본 t-test는 2그룹간의 분산을 서로 다르다고 보고 있구나 생각 # p &lt;0.05 : H0기각, H1채택 -&gt; mean차이가 유의미하게 난다. . Welch Two Sample t-test data: expend by stature t = -3.8555, df = 15.919, p-value = 0.001411 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: -3.459167 -1.004081 sample estimates: mean in group lean mean in group obese 8.066154 10.297778 . Welch(&#50928;&#49828;)&#51032; two-sample = &#46021;&#47549;&#54364;&#48376; t test . 2 그룹의 분산이 같은 경우엔 df = n1+n2-2의 정수가 나온다. | . &#46321;&#48516;&#49328; &#44032;&#51221; Two-sample t test . t.test(expend~stature, var.equal=T) # df = n1 + n2 - 2 # p-value도 등분산성 가정안했을때보다 더 줄어든다. . Two Sample t-test data: expend by stature t = -3.9456, df = 20, p-value = 0.000799 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: -3.411451 -1.051796 sample estimates: mean in group lean mean in group obese 8.066154 10.297778 . Comparison of variances(2&#44536;&#47353; &#48516;&#49328; &#44160;&#51221;) - &#50508;&#54028; 0.05&#45824;&#49888; 0.1 . # H0: 시그마1^2 = 시그마2^2 var.test(expend ~ stature, data=energy) # 유의수준을 0.05가 아니라 0.1보다 작은지를 많이 쓴다.*** # 등분산성은 H0를 기각하지못해야 이득 # -&gt; H0: 시그마1^2 = 시그마2^2 기각X -&gt; 등분산성 증명된다. # 등분산성을 만족시킨다면 -&gt; t.test( , var.equal=T)로 평균이 같은지 검정한다. . F test to compare two variances data: expend by stature F = 0.78445, num df = 12, denom df = 8, p-value = 0.6797 alternative hypothesis: true ratio of variances is not equal to 1 95 percent confidence interval: 0.1867876 2.7547991 sample estimates: ratio of variances 0.784446 . 5.5 Two-sample Wilcoxon test . 일표본 처럼, 비모수적인 윌콕슨test | 2그룹의 rank를 가지고 검정한다. | . wilcox.test(expend ~ stature, data=energy) # p가 0.05보다 작으니 2그룹간에 차이가 있구나를 증명할 수 있다. # W값은, 첫번째 그룹의 rank의 합이다. . Warning message in wilcox.test.default(x = c(7.53, 7.48, 8.08, 8.09, 10.15, 8.4, : &#34;cannot compute exact p-value with ties&#34; . Wilcoxon rank sum test with continuity correction data: expend by stature W = 12, p-value = 0.002122 alternative hypothesis: true location shift is not equal to 0 . 5.6 The paired t test (&#45824;&#51025;&#54364;&#48376; = &#51677;&#51648;&#50612;&#51652; &#54364;&#48376;) . 대응표본 = 짝지어진 표본 검정 | 같은 표본에 2가지 실험(실험전/후를 주로 많이)을 한 뒤 비교한다 | . intake # row개인별, 같은 표본으로서, 먹기 전/후 값 . prepost . 5260 | 3910 | . 5470 | 4220 | . 5640 | 3885 | . 6180 | 5160 | . 6390 | 5645 | . 6515 | 4680 | . 6805 | 5265 | . 7515 | 5975 | . 7515 | 6790 | . 8230 | 6900 | . 8770 | 7335 | . t.test(intake$pre, intake$post, paired = T) # df = 10 -&gt; 총 데이터 11개 # t-통계량 = 11 -&gt; 엄청 크다 -&gt; 차이가 확실히 있구나( t통계량은 평균을 빼서 표준화한 것?) # e-07 -&gt; 10^-7승 . Paired t-test data: intake$pre and intake$post t = 11.941, df = 10, p-value = 3.059e-07 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: 1074.072 1566.838 sample estimates: mean of the differences 1320.455 . 5.7 The matched-pairs Wilcoxon test (&#48708;&#47784;&#49688; paired t-test) . wilcox.test(pre, post, data=intake, paired=T) . Error in wilcox.test(pre, post, data = intake, paired = T): 객체 &#39;pre&#39;를 찾을 수 없습니다 Traceback: 1. wilcox.test(pre, post, data = intake, paired = T) . wilcox.test(intake$pre, intake$post, paired=T) . Warning message in wilcox.test.default(intake$pre, intake$post, paired = T): &#34;cannot compute exact p-value with ties&#34; . Wilcoxon signed rank test with continuity correction data: intake$pre and intake$post V = 66, p-value = 0.00384 alternative hypothesis: true location shift is not equal to 0 .",
            "url": "blog.chojaeseong.com/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EB%8D%B0%EB%B6%84%EB%B0%A91/sampletest/2022/04/01/03-%EB%8D%B0%EB%B6%84%EB%B0%A903-1)One-and-two-sample-tests.html",
            "relUrl": "/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EB%8D%B0%EB%B6%84%EB%B0%A91/sampletest/2022/04/01/03-%EB%8D%B0%EB%B6%84%EB%B0%A903-1)One-and-two-sample-tests.html",
            "date": " • Apr 1, 2022"
        }
        
    
  
    
        ,"post91": {
            "title": "피드백) 1-3(블랙잭) 코드리뷰",
            "content": "PR . 1단계 PR | 2단계 PR | . 블랙잭 1단계 피드백 . domain package내에서도 쌓인 class들을 용도에 package를 구분해라. . | 큰규모가 아니면, Contoller를 쓰지말고 Game/Program/Machine을 run하자. . | 자식class에서 상속받은 메서드에 대해 @Override는 강제가아니지만 표기하자 . | 확인할 때는, 실제로 계산로직과 별개로, 확인만 하는 메서드를 만들자 . 예를 들어, isBust()를 확인할 때, 카드를 직접 받아서 Bust를 만들어보고 rollback이 아니라 카드를 받아서 계산하는 실제 로직과 비슷하더라도 로직을 포함해 물어보자 | . . | getXXX는 getter가 아니면 다른 용어를 쓰자. ex&gt; .receiveXXXX() . . | 블랙잭-CardDeck 요소는 정해져 있지만 셔플로 랜덤이 생기는 경우도 전략패턴으로 외부주입 가능하게 해서 테스트 . . 자동차경주: 랜덤한 조건식을 테스트를 위해 전략패턴으로 빼서 외부주입 . | 로또: 랜덤로또생성을 테스트하기 위해 전략패턴으로 빼서 외부주입 . . | 블랙잭: 요소들은 정해져있지만 셔플된 CardDeck을 테스트하기 위해 전략패턴으로 빼서 외부주입 . . | 체스: (예정) 요소들은 정해져있지만 너무 규모가 커서 테스트하기 힘든 map을 작은 Map.of(,)으로 만들어서 테스트하기 위해 전략패턴으로 빼서 외부 주입 . | . | java에서는 Stack대신 Deque자료구조를 사용 . | Enum도 결과 계산로직 등 중요로직을 가지고 있으면 EnumTest하기 . | list와 단일요소를 합칠 때는 .stream() + Stream.of() 으로 stream으로 통일한 뒤, concat하여 묶음을 만들 수 도 있다. 다만 묶은 Stream을 forEach를 사용할 경우는 생각해봐야한다. . | my) 이미 정해진 자료를 db가 아닌 프로그램에서 초기화하려면, . 프로그램 시작부터 초기화는 상수static final변수에 -&gt; static { }블럭에서 초기화시키면 된다. | . public class RandomCardGenerator implements CardGenerator { static final List&lt;PlayingCard&gt; cardDeck; static { cardDeck = Arrays.stream(Suit.values()) .flatMap(RandomCardGenerator::getPlayingCardStream) .collect(Collectors.toList()); } . | 초기화되어있는 컬렉션을 Collections.shuflle()만 해줘도 랜덤이다. . 원본을 보호하고 싶다면, new ArrayDeque&lt;&gt; ( 컬랙션 )처럼 복사후 shuffle하고 return해준다?! | . | 입력받은 값을 확인하는 메서드 내에서 바로 t/f return이 아닌, return전 또다시 물어본 대답에 따라 로직을 수행후 return t/f return하는 경우도 있다.** -&gt; **isXXX Then YYY ()` . 만약 카드받는 로직이 없이 물어보기만 했다면? . private boolean isHit(final Player gambler) { final BlackJackCommand inputCommand = askHitOrStay(gambler); return inputCommand.isHit(); } . | 물어본 대답에 따라 로직이 추가되는 경우 -&gt; xxxThenyyy() . private boolean isHitThenReceiveCard(final Player gambler, final CardDeck cardDeck) { final BlackJackCommand inputCommand = askHitOrStay(gambler); if (inputCommand.isHit()) { gambler.receiveCard(cardDeck); // isHit인 경우, 추가로직 수행후, return한다. return true; } return false; } . | . | 블랙잭 2단계(베팅) 피드백 . 같은 상태값을 공유하는 테스트들만 따로 @Nested를 적용해줘도 된다. 예를 들어, setUp에 버스트의 상황이 없는 경우에 한하여테스를 작성할 때 | . | 전략패턴으로 빼고 랜덤까지만 production의 domain 패키지에, 테스트를 위한 수동전략객체Class는 test코드&gt; testutil&gt; XXXXFixtureGenerator로 만들어준다. . 전략객체라도 테스트를 위한 수동전략객체는 -&gt; production에 생성하면안된다. | . . getter가 아니라면 -&gt; .receiveXXX() or .createXXXX() . . | 조건이 여러개 있을 땐, 포함관계인지 확인하자 . . | | 객체에 역할수행을 위해 메세지를 보낼 때, 역할수행에 필요한 재료들만를 보내야지, 역할을 가진 도메인을 보내지마라 . 역할을 가진 cardDeck을, 역할을 가진 players에게 보낸다?? -&gt; (X) -&gt; (O) . 내부에서 cardDeck이 역할을 수행해야하는데, 다른 도메인내부에서 다른 도메인이 역할하게 하지말고 재료만 보내자. . | 만약, players에 있는 복수의 player에게 서로 다른 재료를 제공하려면, 복수의 재료를 제공해야하고, 매번 1개씩 재료를 제공해준다면, 재료를 1개씩 제공하는 역할의 도메인은 넘겨도 된다. . | 중요한 것은, 메세지를 받는 players, player를, 다시 내부에서 재료로 들어간 cardDeck 역할 수행시, 그 재료로 쓰면 안된다. . . | . private void spreadCards(final Players players, final CardDeck cardDeck) { // 변경 전: //players.receiveCard(cardDeck); // 중간 변경: // 컬렉션(복수)에 넘겨주는 재료는 &lt;-- 1개만 주면 안된다. //players.receiveCard(cardDeck.pop()); // 최종 변경: // 컬렉션(복수)에 메세지 던질 때는, 재료컬렉션(복수)나, 재료를 매번 제공해주는 역할의 도메인을 넘겨도 된다. // 복수 &lt;-- 재료도 복수 or 내부에서 복수재료를 만드는 역할은 수행해도 된다. players.receiveCard(cardDeck); } . public void receiveCard(final CardDeck cardDeck) { for (Player player : value) { //cardDeck.drawTo(player, DEFAULT_DRAW_COUNT); // player들을 돌면서, 매번 새로운 재료를 공급받는다. final PlayingCard firstCard = cardDeck.pop(); player.receiveCard(firstCard); // 2장씩 제공받는다. -&gt; 2번이라서 반복문 굳이 안써도 된다?? final PlayingCard secondCard = cardDeck.pop(); player.receiveCard(secondCard); } } . | . | 상한이 있는 경우, 점수보정은 작은 것으로 출발하는 것이 좋다. . blackjack의 ace를 1or11 중 큰 점수를 유지하고 싶어서 default 11로 하고, -10점씩 보정시켜줬지만 | 애초에 상한 점수(21)점이 정해져있으면, ace 3장을 가져도 33으로의 보정은 아예 불가능한 상황이기 때문이다. ace2장만 있다고 치더라도, 22점은 아예 불가능한 점수기 때문에, ace를 작은 점수 1을 default로 하고, 보정도 22를 못넘어도록 1번만 +10보정이 가능하므로 while문을 돌릴 필요도 없다 | . | . . | 구초리 . domain과 view(m&lt;-&gt;v)분리할 수없다면, mvc패턴이 아니므로 컨트롤러를 쓰지마라 . | inputView에도 . input메서드() 전에 출력로직이 있어야한다. | .scanXXX() 애매 -&gt; 탐색/검색의 의미임. -&gt; .inputXXX()로 가자, | view에서 형변환까지 완료해서 return 해보면 어떻까? 고민 | | view로직이 조금이라도 포함된다면? domain패키지에서 빼라 . | 지역변수 추출을 활용해서 가독성을 높이자 . | scanAndGetBetMoney : controller에서 내부 2가지 하는 일(로직 + 출력)을 하도록 묶은 메서드에 대해 . 메서드명에 내부 여러가지 일을 명시하여 노출하면 캡슐화 위배 | controller(M+V가 섞인 class)에서 메인로직 + View출력을 1개 함수로 묶지마라 | | controller or M+V메인로직에서 반복문 등 로직을 수행하지마라 -&gt; 로직을 담당하는 클래스에 메세지를 보내 책임을 넘겨라 . 메인로직 클래스가 일이 많아지거나 로직을 수행하게되면 객체에게 넘겨라 | . | scanAndGetBetMoney -&gt; . 내부 .scanXXXX() -&gt; 의미상 inputXXXX()으로 변경 | scanAnGetBetMoney -&gt; createBetMoney로 변경 get -&gt; getter아니면 receive(다른데서 받기) or create(생성) | . | . | A &amp;&amp; B &amp;&amp; C -&gt; 드모르간으로 단순화시킬 수 있다. . not A return false; | not B return false; | (자동 A &amp;&amp; B) return C | . . | 스트림의 결과를 변수로 추출하라 . . //변경 전 public static BlackJackResult from(final Players players) { return new BlackJackResult(players.getGamblers() .stream() .collect(Collectors.toMap( Function.identity(), gambler -&gt; calculateProfit(players, gambler), (x, y) -&gt; y, LinkedHashMap::new) )); //변수로 추출 public static BlackJackResult from(final Players players) { final Map&lt;Player, Double&gt; ProfitsPerPlayer = players.getGamblers() .stream() .collect(toMap(Function.identity(), gambler -&gt; calculateProfit(players, gambler), (x, y) -&gt; y, LinkedHashMap::new)); return new BlackJackResult(ProfitsPerPlayer); } . //변경 전 public double calculateDealerProfit() { return this.value.values() .stream() .mapToDouble(Double::valueOf) .sum() * DEALER_FLIP_UNIT; } //변수로 추출 public double calculateDealerProfit() { final double dealerTotalProfit = this.value.values() .stream() .mapToDouble(Double::valueOf) .sum(); return dealerTotalProfit * DEALER_FLIP_UNIT; } . | dto -&gt; 필요case : 시스템커졌을때, 레이어 나눠서 (도-&gt;서) 관리, 계층넘어갈때 문제 . | 페어간 새롭게 안 사실들 . 추상클래스를 사용하는 많은 경우가 인페에서는 공통적으로 못쓰는 공통 상태값을 공유하기 위해서 . | 여러 구상체(자식들) 존재시 변수는 무조건 추상체로 받아 -&gt; 컬렉션&lt;추상체&gt;로 묶어서 처리가 가능 . 변수, 파라미터, 응답값 모두 추상체로 주기 . // given String expected = &quot;pobi&quot;; final Player pobi = new Gambler(expected); final Player rich = new Dealer(&quot;rich&quot;); . | 만약 단수로 구현체로 받는 경우는 , 추상체로 묶어 사용할 것을 포기한 상태로, 구현체 전용 메서드를 사용하는 순간이다. . @Test @DisplayName(&quot;딜러는 현재 합산 17이상인지 확인할 수 있다&quot;) void over_than_sixteen() { // given final Dealer rich = new Dealer(&quot;rich&quot;); rich.addCard(PlayingCard.of(Suit.HEARTS, Denomination.KING)); rich.addCard(PlayingCard.of(Suit.SPADES, Denomination.KING)); // when boolean actual = rich.isUnderSixteen(); // then assertThat(actual).isFalse(); } . | . | 값 비교시, null가능한 값은 메서드 파라미터로, 확실한 값만 좌항으로 + 소문자 가능하려면 equalsIgnoreCase . 비교시 확실한 값을 왼쪽에 넣어서 null에러 안나게 + ignoreCase . . | . | 싱글톤 . static + final으로 클래스변수로서 애초에 생성해놓고 초기화도해놓음 | 정펙매로 이미 생성된 것만 반환함 ( 객체 생성 생성자 제공 안함. getInstance로만 사용함.) my) 프로그램 시작시부터 생성되어야할 놈들 static +final 상수 변수에 담아야함 | static { } 블럭에 초기화 - &gt; 프로그램 작동중에 다시 초기화할 때는? | 싱글톤 -&gt; new 기본생성자 제공도 안함.?! | . | . | . | 디버깅 찍고 싶은데, 아래 아무것도 없으면 sout만들어놓고, 그 위에 디버깅 표시 . . . | 도메인1 vs 도메인2 비교계산 로직이 같은 객체/일급컬렉션이 아닐 때의 비교 -&gt; 결과도메인이 1,2를 각각알고 서로는 모르게 . my) 같은형의 일급컬렉션 or 객체면, 상관없이 그냥 메세지&gt; 도메인1.메세지( 도메인2 ) . | 서로 전혀 다른 도메인인데, 각 도메인에서 최종결과값만 꺼내서 비교될 예정이라면? -&gt; 제3의 도메인을 만들어서 비교 . dealer vs players 점수비교하여 승패비교 . dealer. compare ( players )? | players . compare ( dealer)? | Result.of ( dealer, players ) | . . | 로또 비교도 마찬가지..? . LottoResult.of( winningLotto, Lottos ) | . . | . | |",
            "url": "blog.chojaeseong.com/java/feedback/review/%EB%B8%94%EB%9E%99%EC%9E%AD/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/31/%EB%B8%94%EB%9E%99%EC%9E%AD-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0.html",
            "relUrl": "/java/feedback/review/%EB%B8%94%EB%9E%99%EC%9E%AD/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/31/%EB%B8%94%EB%9E%99%EC%9E%AD-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0.html",
            "date": " • Mar 31, 2022"
        }
        
    
  
    
        ,"post92": {
            "title": "분기문과 드모르간 법칙",
            "content": "분기문에 적용하는 드모르간 . 문제 상황 . 루피 피드백 중 1개를 발취 . @Override public final boolean isMovable(Position source, Position target, ChessBoard chessBoard) { return !existSameColorPiece(source, target, chessBoard) &amp;&amp; isMovableByDirection(source, target); } . | 드모르간의 법칙을 참고하면 아래와 같이 변경할 수 있을 것 같아요. . &amp;&amp; : 작성자는 이해하기 쉬운 경우이나 라인 수는 줄어들지만 라인을 끝까지 다 읽어봐야 이해할 수 있을 것 같아요. | . | &amp;&amp; -&gt; || -&gt; if문 분기로 찢 : 반대로 분리해서 if 문으로 연산을 제거하면 라인 수는 늘어나지만 어떤 조건에서 if 조건을 실행하는지 좀 더 이해하기 쉬워질 것 같은데요. | 저는 최대한 and 연산을 지양하고 or 연산을 변환한 뒤 if 문으로 분리하는 편 입니다 ㅎㅎ | . | . @Override public final boolean isMovable(Position source, Position target, ChessBoard chessBoard) { if (existSameColorPiece(source, target, chessBoard)) { return false; } if (!isMovableByDirection(source, target)) { return false; } return true; } . | . boolean식 분기 적용법: ` &amp;&amp; -&gt; ||으로 분리후 -&gt; 드모르간 적용` . 01 return A &amp;&amp; B 로 작성해놓았다면, replace with ||로 분리한다. . private boolean isRunning() { return gameSwitch.isOn() &amp;&amp; state.isRunning(); } . . . private boolean isRunning() { return !(!gameSwitch.isOn() || !state.isRunning()); } . 02 가장 바깥 !( )는 무시한 체, return || 는 순서가 중요 -&gt; 아래쪽 순서대로 if return true문으로 찢는다. . ||의 or는 앞에 것 통과하면 뒤에것 안보고 통과하는 성격이 있다. . if 앞에 것 통과시 return되도로 if문으로 찢어보자. | 아래에다가 점진적으로 찢어보자. | . | . ` ||에서 앞에것 통과 못했으면 == if 분기에서 위에 것 통과 못했으면으로 동치다 -&gt; if A? ||오른쪽orif아래쪽은 자동notA` . ||에서 앞에것 통과 못했으면 == if 분기에서 위에 것 통과 못했으면으로 동치다 . 순서가 중요한 ||와 if분기 | . . | . private boolean isRunning() { return !( !gameSwitch.isOn() || !state.isRunning() ); //A통과 if (!gameSwitch.isOn()) { return true; } //(notA) B통과 if (!state.isRunning()) { return true; } } . 03 return || 오른쪽 끝까지 모두 통과X -&gt; false 이므로 if return true; 여러개 맨 아래 까지 통과x시 -&gt; return false; . . private boolean isRunning() { return !( !gameSwitch.isOn() || !state.isRunning() ); //A통과 if (!gameSwitch.isOn()) { return true; } //(notA) B통과 if (!state.isRunning()) { return true; } //(자동 notA &amp;&amp; notB) ||에서 순서대로 다 통과못할시 false다 return false; } . 04 무시했던 바깥 !()을 적용시키려고 return true/false 반대로작성하기 . . . private boolean isRunning() { //A통과 -&gt;!() 적용시켜서 A false -&gt; not A if (!gameSwitch.isOn()) { //return true; return false; } //(notA) B통과 -&gt;!() 적용시켜서 (A) B false -&gt; not B if (!state.isRunning()) { //return true; return false; } //(자동 notA &amp;&amp; notB) -&gt;!() 적용시켜서 ( A &amp;&amp; B ) //return false; return true; } . 05 암기 및 정리: (if를 다지난 마지막자리에 주석 //A &amp;&amp; B와 함께 자동 자리에)retun true를 주고 -&gt;if notA return false -&gt; if notB return false; . 06 사실 boolean이라면 if not A -&gt; (자동A) return B를 해버리면 된다. (로직일 경우 not B도 개별 처리해줘야하니까 다름) . 기본 로직 적용법 및 암기법: A &amp;&amp; B는 if notA -&gt; if notB -&gt; 맨마지막 자동 A &amp;&amp; B에서 처리되도록 . 예시1) row &amp;&amp; col의 대각선 . . public List&lt;Position&gt; pathTo(Position otherPosition) { List&lt;Row&gt; rowPath = row.pathTo(otherPosition.row); List&lt;Column&gt; columnPath = column.pathTo(otherPosition.column); // 2. [ not A ] row(X) -&gt; rowSize == 0 (자동으로 col) 부터 한다 if (rowPath.size() == NO_SIZE) { return getVerticalPositions(columnPath); } // 3. (A &amp;&amp;) [ not B ] col(X) -&gt; colSize == 0 (자동으로 row) 을 한다 if (columnPath.size() == NO_SIZE) { return getHorizontalPositions(rowPath); } // 1. [ ( A &amp;&amp; B ) ] row &amp;&amp; col == 대각선 -&gt; 맨 뒤에서 자동으로 return getDiagonalPositions(rowPath, columnPath); } . 예시2) 누구 king이 잡혔냐? -&gt; (자동 둘다 &amp;&amp;안잡힌 상황) . private static GameResult findWinner(final Board board, final double statusOfWhite, final double statusOfBlack) { // 2. not A -&gt; black잡힘 if (board.hasBlackKingCaptured()) { return GameResult.WHITE_WIN; } // 3. (black안잡혔는데 ) not B -&gt; white잡힘 if (board.hasWhiteKingCaptured()) { return GameResult.BLACK_WIN; } // 1. ( 자동 black안잡힘 &amp;&amp; white안잡힘 ) -&gt; 점수 비교 로직 return getResultWhenNoKingCaptured(statusOfWhite, statusOfBlack); } . 예시3) boolean에서 A &amp;&amp; B . . private boolean isStatusInRunning() { return gameSwitch.isOn() &amp;&amp; state.isStatus(); } . 01 (자동으로 될 A &amp;&amp; B를 주석처리와 함께)맨 끝에서 return true . . private boolean isStatusInRunning() { //gameSwitch.isOn() &amp;&amp; state.isStatus(); return true; } . 02 if not A를 만들고 return false; . . private boolean isStatusInRunning() { // if not A -&gt; return false; 주기 if (!gameSwitch.isOn()) { return false; } // (자동 gameSwitch.isOn() &amp;&amp; state.isStatus();) return true; } . 03 if not B 만들고 return false; . . private boolean isStatusInRunning() { // if not A -&gt; return false; 주기 if (!gameSwitch.isOn()) { return false; } // if not B -&gt; return false; 주기 if (!state.isStatus()) { return false; } // (자동 gameSwitch.isOn() &amp;&amp; state.isStatus();) return true; } . 04 boolean이라 따로 로직이 필요없다면 if not A return false;후 -&gt; return (자동 A &amp;&amp;) B . . private boolean isStatusInRunning() { // if not A -&gt; return false; 주기 if (!gameSwitch.isOn()) { return false; } // if not B -&gt; return false; 주기 //if (!state.isStatus()) { // return false; //} // (자동 A &amp;&amp; B == gameSwitch.isOn() &amp;&amp; state.isStatus();) //return true; // (자동A ) return state.isStatus(); } . my) A &amp;&amp; B의 처리는 if A부터 처리 못한다?(if not A) -&gt; 바로 탈락(return false;) 시킨다. OR로 본다면 앞에거 먼저 만족하면 return True로 전체 종료되는 개념과 유사하다. . my) boolean A&amp;&amp;B 이라면, notA || notB + 원랜 앞에것 통과시 true로 끝 But 여기선 !땜에 return false; -&gt; A부터 만족 못할시 빠르게 false로 종료처리되도록 -&gt; if로 찢어 if not return false시켜버린다. . my) boolean이라면, if not 앞쪽A -&gt; return false; 이후 (if문 아래쪽은 자동 A &amp;&amp;상태이므로) 마지막 분기식은 바로 return (자동A&amp;&amp;) B해버려도 된다. ( if not B로직이 필요없는 상황) . my) boolean처럼 로직도 if notA return -&gt; if notB return -&gt; (자동 A &amp;&amp; B) return 을 사용한다. . my-역) if return false -&gt; A &amp;&amp; B 조건에서 앞쪽 A를 먼저 만족시키지못해 애초에 탈락이구나 -&gt; not A 상황이라서 &amp;&amp; B보기전에 빨리 거르기 + 밑으로는 (A &amp;&amp;)상태구나 . my-역) if return false + return B -&gt; A||B의 앞쪽 A라 notA라 거르고, 밑에서 A &amp;&amp; B 이며, true시 true니까.. A &amp;&amp; B시 true리턴이구나.. . 해석 연습해보기 . BOOLEAN 中 and 조건문 . private boolean isRunning() { if (gameSwitch.isOff()) { return false; // 1. return false -&gt; end boolean식이 전제이며, A &amp;&amp; B에서 A를 만족못시키는 [A &amp;&amp; B에서 not A라서 먼저 false;로 걸러지는구나] } // 2. 자동 not A(! .isOff() == isOn()) 상태 &amp;&amp; 로서 A(스위치On)&amp;&amp;이면서 B가 와야하구나. // 3. 만약, 조건식이 1개가 남았다면 바로 return 조건문으로 끝낸다. // -&gt; [ (자동 isOn &amp;&amp;) !notRunning 이어야 end조건의 boolean식이 최종 true가 되는 구나] // -&gt; is ON &amp;&amp; running 상태여야 true return !isNotRunning(); } java private boolean isStatusInRunning() { if (gameSwitch.isOff()) { return false;//1. early false -&gt; and조건에서 빨리 걸러지는 상황으로 [앞쪽 not A -&gt; off ] } //2. (자동 A -&gt; on &amp;&amp;) 상태에서 if status상태여야 true구나. return state.isStatus(); } . private boolean isEndInRunning() { if (gameSwitch.isOff()) { return false; // 1. not A 가 off로 먼저 걸러진다 -&gt; A = on상태 &amp;&amp; } //2. on &amp;&amp; finihsed상태여야 true return state.isFinished(); } . BOOLEAN이 아닌 단순 경우의 수라면? -&gt; 마지막 경우의수만 자동으로 가져간다.?! -&gt; 복잡한 조건을 뒤에서 if없이 자동으로 가져가게 하자. . A OR B OR C 경우의수: 편한 순서대로 ealry return하면서 마지막 경우의 수만 if없이 자동으로 가져간다 참고: boolean OR 조건문 -&gt; (이왕이면 잘 걸리는 것을 앞A에 배치해놓고)early true return으로 빨리 끝내기 (&amp;&amp;조건문시 앞에것부터 early false return처럼) | . | . public void move(Position beforePosition, Position afterPosition) { Piece beforePiece = this.value.get(beforePosition); // 로직 or : 순서 상관없이 [early return] + 마지막만 자동 경우의수로 가져가기** // 단순 같은위상의 3가지 경우의 수 -&gt; 순서상관엇이 if A return 로직A; if B return 로직B; (if없이 자동 자동3번째) 로직C; // A: after에 빈칸이 있을 경우 if (isMoveToBlank(afterPosition)) { beforePiece.move(beforePosition, afterPosition, moveFunction(beforePosition, afterPosition)); return; } // B: after에 적이 있을 경우 if (isMoveToOtherCampPiece(beforePosition, afterPosition)) { beforePiece.capture(beforePosition, afterPosition, moveFunction(beforePosition, afterPosition)); return; } // C: (자동 빈칸도X 적X) -&gt; (자동 after에 같은편이 있을 경우) throw new IllegalArgumentException(CANT_MOVE_TO_SAME_CAMP); } . A OR B OR C -&gt; A+B OR C로 통합된 경우 -&gt; 마찬가지 마지막 경우의수만 if없이 자동 if OR의 경우의수 2개를 통합했더니 -&gt; A와 B의 로직이 다르면, 내부에서 다시 나눠야하는 부작용 있었음. | A+B통합이 더 크므로, 차라리 C OR A+B로 보고 규모가 작은 것을 앞에 배치시키면 if문 없이 자동이 편해짐(아래서 함) | . | . public void move(Position beforePosition, Position afterPosition) { // 빈칸 + 적의 내부로직이 통합됨 OR로 연결됨 - ( A OR B = D) // D OR C -&gt; if D return 로직D; (자동C)-&gt; if A return(true); 자동B if (board.get(beforePosition).isNullPiece() || !board.get(beforePosition) .isSameCampWith(board.get(afterPosition))) { movePiece(beforePosition, afterPosition); return; // OR는 early (true) return 필수다. 로직이라면 그냥 earyl return;필수 } // (자동C: 같은 진영의 기물인 경우) throw new IllegalArgumentException(CANT_MOVE_TO_SAME_CAMP); } . A+B OR C라면 규모가 작은 C를 먼저 ealry return | . public void move(final Positions positions) { if (isAfterPieceSameCamp(positions)) { throw new IllegalArgumentException(CANT_MOVE_TO_SAME_CAMP); } movePiece(positions); } .",
            "url": "blog.chojaeseong.com/java/if/conditionalstatements/a&&b/earlyreturn/boolean/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/30/%EB%B6%84%EA%B8%B0%EB%AC%B8%EA%B3%BC-%EB%93%9C%EB%AA%A8%EB%A5%B4%EA%B0%84.html",
            "relUrl": "/java/if/conditionalstatements/a&&b/earlyreturn/boolean/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/30/%EB%B6%84%EA%B8%B0%EB%AC%B8%EA%B3%BC-%EB%93%9C%EB%AA%A8%EB%A5%B4%EA%B0%84.html",
            "date": " • Mar 30, 2022"
        }
        
    
  
    
        ,"post93": {
            "title": "강의) 네오 3단계 블랙잭 피드백(4/4)",
            "content": "추상화레벨 맞추기는 나중에 . 중요) 클라이언트 관점에서 더 필요한 기능이 남았는지 꼭데기 인터페이스에서 고민하기 . 중요) 기존 [상태패턴용 인페 메서드]들 고민해보기 . . my+ 깨닮음 ) 메서드는 (1)(인자-&gt;파라미터로 오는) 추가정보가 있냐/없냐에 따라 -&gt; 추가정보을 유발된 상태값 업데이트냐/ 원래 상태값의 조회해서 처리냐를 구분 + (2) 응답값을 통해 추상체 or 객체냐/상태값/값이냐 -&gt; 처리내용이 같은 상카아래의 구현체 중 1개 객체 생성이냐/ 내부값 단순 조회/ 연산이냐가 나눠진다. . public interface State { State draw(final Card card); // [추가 정보]를 받아서 [상태값을 업데이트해서 -&gt; 새 객체를 만들어내겠군] // 응답이 추상체(인터페이스)? -&gt; 서로 다른 구현체로 바뀔 수도 있겠군 // 구현체끼리 바뀌려면 -&gt; 같은 상태값 &amp;&amp; 상태값을 재료로 받는 생성자가 있어야겠지 State stay(); // 추가 정보가 없는 메서드? 상태값을 업데이트보단 [조회해서 처리] 확률이 높겠다. // -&gt; 아무래도 [현재 상태값을 조회하여 -&gt; 무엇인가 처리]할텐데, // -&gt; 응답값 [추상체다? ] -&gt; [조회해서 다른 구현체 객체]로도 갈 수 있을 듯? Cards cards(); // 추가 정보가 없는 메서드? 상태값을 업데이트보단 [조회해서 처리] 화률이 높겠다. // -&gt; 아무래도 [현재 상태값을 조회하여 -&gt; 무엇인가 처리]할텐데, // -&gt; 응답값이 } . 54) 상태패턴 상카에서 빠진 기능 살펴보기 . public interface State { State draw(final Card card); State stay(); Cards cards(); } . 현재 상태 종류 (1) 끝난 상태 3개 (2) 최초시작&amp;&amp;진행가능 상태 1개 (3) 중간 진행가능상태 (1) . . 상태 상카의 현재기능 (1)상태변화 트리거(draw(추정)) + (2) (자의)종료상태 만들기(stay) + (3)현재상태 상태값getter(cards) - (중복제거으로 올렸더니 자식들 개별구현시 상태값 뽑아쓰기용) . 3개 기능 이외에 더 필요한 기능은? (4) 매번 끝났느지 안끝났는지 확인하는 기능은 필수로 제공되어야한다. . 중요) 특정클래스(추상클래스, 중카)에 속하는지 확인하기 위해 개별객체. isInstanceof 클래스.class 대신 -&gt; 객체.is특정추클? 특정클래스는 true/ 나머지클래스는 false를 반환하는 &amp;&amp; is특정클래스()의 이름을 딴boolean확인메서드를 새 메서드로서 추메/전메에 올려서 구현한다. . 55) isInstanceof(중카.class) 안쓰고 매번 끝난 상태(중카, 추상클래스)인지 아닌지 확인하는 기능 -&gt; 해당(끝난상태) 중카true vs 나머지 중카false를 반환하는 [확인클래스이름을 딴 boolean확인메서드]를 상카에 추가하기 . . 까먹) Finished처럼, 중카/추클 전체에 적용되는 메서드들은, 자식들이 딴짓 못하게 final로 막아주기 . . 중요) instanceof를 썼다면, 잘못된 설계다? -&gt; 메서드에 메세지보내서 t/나머지f를 받을 수 있게 메서드로 관리하자. . 56) 특정추클이 맞는지 확인메서드이지만, 모든 상태 객체가 대상이다 -&gt; 새 메서드는 일단 추메/전메에 올려서 먼저 개발 . 상카인페에 새 추메/전메를 올릴 때 인페 안에서 접근제한자 생략 -&gt; 자동public 이므로 returnType + 파라미터의 시그니처만 정의한다. . . public interface State { State draw(final Card card); State stay(); Cards cards(); // 하위 특정클래스 확인후 t/f를 반환해줄 메서드 추가 boolean isFinished(); } . 중요) 개별구현이 예상되면(t/f확인메서드) -&gt; 개별구현되는 곳까지 중간에 추클들은 무시하고 내려가서 구현해야한다. 중간/추클에 구현 impl == 중복코드 제거용으로 다시 추상메서드를 정의하지말고 무시하면 -&gt; 자식들이 화내면서 개별구현해야한다 -&gt; 즉, 개별구현해야된다면, 중간추클을 만나더라도 추상메서드 줄 필요없이 무시하면 개별구현자식들에게 자동전과되서 빨간줄 띄운다 . 최상위 중카인 Started가 있지만, Finished &lt;-&gt; 그외 중카의 개별구현이 예상되면, 개별구현되는 상위 중카추클까지 내려가서 구현한다. (최상위 중카를 무시하고 내려가면, 자식들에게 전과되어 개별구현하게 한다) . . 암기) 상카 인터페이스에서 추메/전메로 올려서 개발시작하되, 개별구현되는 곳까지는 중카-추클을 무시해서 개별구현 전과를 돌려도 된다 -&gt; 중간에 있다고 해서 미구현 추상메서드로 구현해 둘 필요없다 . 57) isXXXX() 대상 중카/추클까지 내려가서 개별구현으로서 true를 반환해준다 . 상카인 State에서 추메/전메로 올려서 시작했으면서 &amp;&amp; 중카인 Started를 건너띄었다면? . (추가 중카인 Finished 역시 필수 구현체X &amp; 중복코드라도 아직은 구현안해준 상태)에서 . **중카 추클이 구현impl을 무시했다면, 개별구현 책임이 자식들한테 넘어가 화가나있다 ** . . | . | 일단 isFinished()의 true를 대답해줄 그룹에 대해서 추클에 중복코드로서 구현해준다. . . | 깜빡!) 중복제거를 위해 상카-추메/전메 -&gt; 중카/추클에서 먹어서 정의하러 왔으면, 중카/추클 정의시는 항상 final로 자식 딴짓 못하게 막기 . 아래 일부사진들을 보면 중복제거용 부모 먹어주는 코드인 isFinished가 final이 안달려있다. | . 58) isFinished() 개별구현 책임이 전과된 isFinished 중카추클에 속하지 않은 중카추클이 아닌 개별구현체들 -&gt; 중복코드제거 해줄 추클이 위에 없다면, 전과받은 개별구현체들이 모두 직접 구현 . 현재 isFinished가 아닌 Ready와 Hit에 불이 나있다. . . . Ready . 전과된 직접 개별구현 -&gt; 끝난상태냐? false . . | . | Hit 역시 마찬가지 -&gt; 끝난상태냐? false . . | . | . 중요) 또 상태패턴의 상카 인터페이스에서 빠진 기능이 없는지 확인한다 블랙잭 라이브러리를 받아와서 이 기능들로 다 구현가능한지를 생각해보면 된다. . 상태변화 유발 메서드 with 파라미터(추가정보) -&gt; draw(card) | 자의로 끝난상태로 종료시키기 -&gt; stay | 구현체에서 부모상태값정보 받아먹기용 getter -&gt; cards | 현재 끝난 상태인지 확인 -&gt; isFinished | ??? | 중요) 상태패턴의 상태객체가 cards정보를 가지고 있으니 -&gt; 필수 기능외에 계산로직도 상태 상카의 추메/전메로 추가해준다. . public interface State { State draw(final Card card); State stay(); Cards cards(); boolean isFinished(); } . 중요) 계산profit() 하려면, 상태객체마다. isBust()인지 / isBlackjack() / isStay() 인지 구현체(상태객체) 종류마다 [isinstanceof 대신 boolean확인메서드]가 필요해지는데??? . . 초대박) isinstanceof 특정 중카(추클)을 대신하는 boolean확인메서드가 아니라 개별 구현체마다 확인이 필요하다면, boolean확인메서드가 구현체 종류마다 필요해지고, 나머지는 모두 예외처리?해야만 한다 -&gt; 개별구현체마다 다른 로직을 가지고 있으면서 &amp;&amp; 굳이 (종료상태냐?) 확인할 필요없다면 : 추메/전메 -&gt; [중카무시의 개별구현 책임전과]를 통해 [구현체마다 다른 로직을 구현]해서 다형성에서 알아서 처리되도록 구현하자 . 암기) 같은 카테고린데, 개별구현해야한다면? isInstanceof (x) -&gt; is특정구현체? (x,그룹일경우만) -&gt; 묻지말고 전략메서드처럼 추메/전메로 개별구현해서 알아서 작동하도록 . . . my) 전체가 크게 나뉘는 (종료상태들&lt;-&gt;진행상태들 등)그룹에 대한 확인이면서 &amp;&amp; isintanceof인지 꼭 물어봐야한다? isBoolean메서드를 추메/전메 올려서 개별구현까지 가서 구현 . my) 모든 구현체마다 다르게 구현되고 &amp;&amp; 물어보면서 그에 따른 로직이 정해져있다? -&gt; 공통메서드 로 추메/전메에 올리고 -&gt; 물어보지말고 구현체들마다 직접 개별구현 시키자 . my+깨닮음) 어떤 것을 할 때마다, 해당 상태(객채)인지 물어보고 + 거기에 맞는 로직까지 정해져있다 -&gt; 근데 그 상태가 제한된 종류로서 묶인다? -&gt; 상카-구현체들로서 안물어보고 추메/전메로 전략패턴처럼 만들어주면 -&gt; 구현체마다 알아서 작동하도록 개별구현해놓으면 -&gt; if instanceof가 사라진다. . 중요) 상태패턴에서 state구현체들은, 다음state의 판단을 위해 상태값에 정보를 가져야만한다. -&gt; 정보를 상태값으로 가졌다면, 계산로직도 거기(state 구현체, 상태객체들)에서 구현(다르다변 추메/전메 -&gt; 개별구현) 되어야한다. . 59) state의 구현체들이 정보인 cards를 상태값도 가지고 있으니, 계산로직도 여기서 처리해야한다. 계산: 대상은 Finished된 state들만 대상이 되며, 계산(기본 정보로 계산) 중 &lt;외부 입력을 받아 + 정보바탕으로 계산&gt;: input으로 들어온 betMoney(double)을 [구현체별 다르게 계산 로직 구현]하여 -&gt; 새로운 계산값을 output 응답하는 계산이 있다. . my) 정보를 통한 계산이 아니라, 외부 금액input 등 정보를 가진 곳에서 계산로직을 가질 때, 외부재료를 input으로 받아서 -&gt; 가진 상태객체의 정보cards를 바탕으로 -&gt; 새 재료?로 return응답 해주는 계산로직도 생각하자. + 계산로직은 State패턴의 구현체객체들 중 finished에 해당한 애들만 계산로직을 가질 수 있다. . 상태에 따라, 외부input인 배팅금액을 받아 -&gt; 상태마다 개별적으로 다르게 계산해서 새로운 배팅금액을 output으로 응답한다. . 이 때, Finished아래의 구현체들만 결과 계산 로직을 가진다. | . . | my) 계산시 외부재료가 필요한 경우도 있다. 그 외부재료에 계산한 값을 돌려주는 경우가 있다는 것을 생각 . 참고) 돈 계산의 원시형은 일단 double로 받아서 double로 내어주자 . public interface State { State draw(final Card card); State stay(); Cards cards(); boolean isFinished(); double profit(double money); // 계산 중에 외부에서 받은 것을 계산해서 응답해준다. } . 60) 외부재료받아 계산하는 로직의 [구현체마다 다르게 개별 구현] (finished 아래 구현체들만) . . blackjack -&gt; 외부재료(input money)를 * 2 하는 계산후 응답해준다. . 개별구현을 위해 중카/추클에서 impl무시하면, 자식들이 불나있다. . . public final class Blackjack extends Finished { Blackjack(final Cards cards) { super(cards); } @Override public double profit(final double money) { return money * 1.5; } } . | . | bust : 외부입력만큼, 손해로 작용한다면 * -1을 해주면 된다. . public final class Bust extends Finished { Bust(final Cards cards) { super(cards); } @Override public double profit(final double money) { return money * -1; } } . | 61) 개별 구현체 상태에서의 계산이… 추가 정보가 필요한 상태 -&gt; 임의로 input 그대로 응답해놓는 버릇을 들여보자. . stay상태에서는 추가정보로서 딜러의 cards와 비교를 해야한다. -&gt; 일단 무시하고 원본을 돌려놓는다. . public final class Stay extends Finished { Stay(final Cards cards) { super(cards); } @Override public double profit(final double money) { return money; } } . | . 62) 추가 처리가 필요한 예외상황 -&gt; 바깥에서 처리하기로 하고, 도메인내 자신의 역할만 생각해서 완성한다 . 참고) 상호작용의 검증/조건이 있더라도, 개별 도메인 작성시에는 자기역할만 순수하게 완성한다. . 현재 state가 blackjack 일때? 상대도 blackjack? 체스로 치면 king이 움직이는 것? 앞에 기물이 있는 예외상황은 바깥(board)에서 처리하고 일단 king자신 이 갈 수 있는 조건으로 계산한다. | . | 상대방도 blackjack이면, 이익은 0배로 무승부인데?, 일단 내가 blacjakc일때의 상금 1.5배만 생각해서 완성한다 | . | . 63) hit와 ready는 profit계산자체가 불가 -&gt; input있는 계산함수라도 개별구현시 예외처리 . @Override public double profit(final double money) { throw new IllegalStateException(); } . 대박) 개별구현 하다가 중복코드가 보인다? 무시했던 추클에서 impl -&gt; 후 중복부분만 구현(중클/추카 구현 메서드면 final) &amp;&amp; 개별구현체마다 다른 부분 = 개별class들이 아는 부분 -&gt; abstract메서드로 빼서 내려주기 . . 중요) 중카/추클이 무시하고 내려보내 -&gt; 개별 구현된 메서드들 중에서 상수 or 일부분만 중복이어도 -&gt; 중카/추클에서 중복제거용impl 구현시행 &amp;&amp;상수(일부분)만 다시 abstract로 내려보내주기 . 중요+암기) 개별구현 전과시키려고 [impl구현 무시한 중카/추클 내]에서 새로운 중복 발견인 경우, impl구현 무시한 곳 -&gt; impl시행하여 아래부분 중복제거를 시행하며 -&gt; 상수든 뭐든 구현체별로 달라지는 부분은 상수라도 -&gt; 메서드응답으로 빼고 -&gt; abstract 메서드로 정의해서 자식들에게 [응답메서드로 상수(일부분) 개별구현]으로 내려주기 . 64) Finished내부, 상수만 구현체별로 다르고 메서드가 중복된다면? -&gt; 제한된 중카/추클로만 올린 뒤, 달라지는 부분만 메서드로 추출하여 응답받도록 한 뒤 -&gt; abstract메서드로 내려보내서 자식들이 상수응답하도록 하기 . . Finished에서 무시했던 노필수 impl구현을 해줘서, 중복제거용 코드로 먹어준다. . . . | 중요) 중카/추클은 상카 존재 시 개별구현 -&gt; 무시하고 내려보내기 or 중복제거 -&gt; final로 막아두고 구현 or 중카/추클 자식들의 중복시 -&gt; 자신이 추메/전메처럼 abstract로 정의해서 뿌려준다. + 상수도 응답 메서드로서 뺀 뒤 -&gt; protected? abstract로 정의하여, 추메/전메처럼 내려준다 . **개별 클래스들이 알고 있는 부분(메서드 구현 뿐만 아니라 상수도!!)은 개별 클래스(구현체)들이 응답해줄 abstract메서드로 뺀다 ** . 상수를 메서드로 뺄 때, 상수이름을 메서드로 네이밍()해주는 센스 | . . 중카/추클에 정의하는데 final로 중복구현 vs 개별구현의 최상위라면, 중복코드는 final로 정의해주되, 내부에 개별구현 코드가 보인다면, 메서드로 뺀 뒤 -&gt; 추메/전메처럼 뿌려주려면, abstract 메서드로 내려주기 . . | 개별구현시키려고 abstract메서드로 뽑았더니, 자식들 구현하라고 protected로 찍혀있다. . . | abstract로 추메/전메처럼 개별구현으로 내려보내면 -&gt; 자식들 불 들어온다. . . | . | 암기) 중카-추클이 개별구현을 내려줘야한다면, 중복제거 코드내라도 가능하며, 상수, 일부분이라도 (1) 메서드로 빼고 -&gt; (2)abstract로 내려준다. . 개별 구현체들이 알고 있는 개별 상수들을 메서드로 구현해준다. . blackjack . 올린 중복코드는 제거한다. . | 중복코드를 제외한 상수의 개별구현을 abs -&gt; impl해줘서 응답해준다. . . public final class Blackjack extends Finished { Blackjack(final Cards cards) { super(cards); } @Override protected double earningRate() { return 1.5; } } . | | 나머지 들도, 중복코드를 삭제하고, 상수를 응답하는 개별구현 메서드를 구현한다 . . . public final class Bust extends Finished { Bust(final Cards cards) { super(cards); } @Override protected double earningRate() { return -1; } } . | stay: 원본 그대로 돌려주고 밖에서 나중에 예외처 계산함 . public final class Stay extends Finished { Stay(final Cards cards) { super(cards); } @Override protected double earningRate() { return 1; } } . | . | 중복제거 등, 추상화/상속 관련작업이 끝날 때마다, diagram을 보자 . ​ . profit()중복코드로서 중카/추클에서 정의해줬다 중복코드 -&gt; 외부에서 호출할 놈 -&gt; public | . | profit()내에서 구현체별 달라지는 부분(상수)는 내부에서 메서드추출 -&gt; 추카/중클에서 (protected)abstract로 전메/추메처럼 개별구현으로 내려보낸다 earningRate()는 개별구현체별 다르게 구현되는 상수를 추출한 메서드 | . | . . . 참고) 중카/추클(부모클래스)의 usage(extends)를 확인해보면, 같은 레벨의 자식들만 볼 수 도 있어서 -&gt; 레벨이 맞는지 확인할 수 있다 . . Started의 추클에서 usage(shift+F12)를 통해, extends자식들이 어떤 것들이 있는지를 보고 레벨을 확인해보자. 추클Finished | 구현체Hit | 구현체Ready | . | . 65) 2개 남은 쌩구현체들에 대해, 공통메서드 확인후 중카/추클 추가해서 묶어주기 . 중카/추클아래 구현체(자식들)은 본인의 역할만 잘하고 있는 것 같은데, hit와 ready는 좀 더러운 것 같다 . blackjack . public final class Blackjack extends Finished { Blackjack(final Cards cards) { super(cards); } @Override protected double earningRate() { return 1.5; } } . | . 쌩구현체들의 공통점 찾기 . Hit . @Override public boolean isFinished() { return false; } @Override public double profit(final double money) { throw new IllegalStateException(); } . | Ready . @Override public boolean isFinished() { return false; } @Override public double profit(final double money) { throw new IllegalStateException(); } . | . 66) 반대편 추클과 동일한 레벨의 추상화(중카/추클) 만든 후, 기존에 개별구현들은 무시하여 자식들에게 전과된 체 두고 + 중복제거용 메서드들만 뽑아서 impl하여 final -&gt; 자식들의 중복코드 제거한다 . . Finished의 반대 Running(중카/추클)만들기 . . | 중카/추클 생성하는데, 더 위의 중카/추클이, 상태값+생성자 (for getter?) 내려준다면, super()로 내려주는 상태값 초기화는 기본적으로 해줘야함 . . . Running &lt;-&gt; Finished . public abstract class Running extends Started { protected Running(final Cards cards) { super(cards); } } . | . 67) 추가 중카/추클은 기존 개별구현 메서드들을 제외시키면서 &amp;&amp; 중복처리를 해줄 메서드들을 -&gt; [implement Methods...] -&gt;상카의 추메/전메들 중 선택해서 처리한다. . 중간에 추가된 Finished대항마 Running은 impl해서 중복들을 상카-추메/전메중에 확인해서 처리해야한다. . | isFinihsed는 피니쉬의 대항마 추상레이어로서 아래 똑같이 중복 return false . 마찬가지로 profit도 아직 안끝났으면, 수익률계산불가 -&gt; 예외처리를을 중복처리한다. . public abstract class Running extends Started { protected Running(final Cards cards) { super(cards); } @Override public boolean isFinished() { return false; } @Override public double profit(final double money) { throw new IllegalStateException(); } } . | 중요) 중복처리하는 중카/추클의 중복처리 메서드는 final로 자식딴짓못하게 막아야하며, final을 달아줬다면 -&gt; 자식들이 extends 추가한 중카/추클하도록 넘어가자 . 68) 추클상 정의하는 메서드들은 무조건 접근제한자 확인할 것! 추클상 중복처리한다면, 자식에선 딴짓 못하게 final도 함께!! . . public abstract class Running extends Started { protected Running(final Cards cards) { super(cards); } @Override public final boolean isFinished() { return false; } @Override public final double profit(final double money) { throw new IllegalStateException(); } } . 69) final 중복처리 메서드로 중복처리까지 끝냈다면 -&gt; 새로운 자식들에게 가서 자식들이 extends &amp;&amp; 기존 중복코드들 제거해주기 . Running Hit | Stay | . | . 1. 새 부모로서 extends 처리된 중복메서드만 삭제(final로 막아놔서 -&gt; extends한 자식은 @Override시 빨간줄) . | Ready도 똑같이 처리한다. . | 중요+암기) 추상클래스에서 중복처리시 final을 달아서 처리해주면 -&gt; 기존 개별구현하던 자식들이 extends한 순간부터 딴짓했다고 빨간줄내면서지워달라고 해준다. . 70) 최종 다이어그램 확인하기 . . 중요) 추상클래스에서 전메/추메의 abstract가 나온다면, protected로서 자식들이 개별구현하도록 풀어준다. ex&gt; final 중복처리 메서드 내부에서 상수만 개별구현 . . 중요) 상태패턴 최종 기능파악 + 인터페이스로 약속만 정의 -&gt; 바깥에서 인페 추상체 state를 상태값으로 가진다면, 내부 구현 정보를 모르고 사용만 한다. (인페 추상체는 밖에서 주입해도 되고, 내부에서 즈그들끼리 변해도 되고.. 모른다) &lt;-&gt; state를 추클로 정의하면, 바깥에서 내부 정의를 다안다.? . public interface State { State draw(final Card card); State stay(); Cards cards(); boolean isFinished(); double profit(double money); } . isFinished()가 판단가능해서 끝나지 않았으면, 추가정보로 계속 상태변화 draw( ) | 끝났으면, 그 상태에서 결과계산 profit( ) | | stay()로 주체(Player)가 원할 때, isFinished()에 걸리도록 끝내주고 종료도.. 종료상태를 먼저 만들어주고, isFinished()에 걸려야하는 구나! | . | cards()로 출력이나, 상태업데이트를 위해 현재상태를 가져온다 | 인페는 말그대로 인터페이스만 제공해주고, 내부구현은 모른다. -&gt; 인터페이스로 연결되었다면, Player입장에서는 state 가 어떻게 동작하는지 1도 모른다. (내부동작을 모른다) . 인터페이스는 바깥에서 사용할 때, 내부 구현을 모르는 상테로, 약속에만 맞게 동작하는구나정도만 알 수 있다 Player -&gt; private State state;로 상태값으로 가지긴 하지만, 인페 객체(추상체)를 갖다쓰는 순간 내부 구현고 직접 구현체가 들어갈 때만 거기에 맞게 작동하므로) | . | 인터페이스가 좋다고 해도, 많아지면 장황해진다 | 추클과의 논쟁은 끝이 없다. | . 인페로 정의한 State는 사용자가 내용은 모른체, 원하는 대로 사용할 수 있다. . 71) Player가 인터페이스 객체(추상체)의 state를 상태값으로 가지는 순간, 그 내부 구현은 모르게 된다. . state와는 다른 .player패키지 -&gt; Player를 만들기 . . | State의 사용처는 인페객체 = 추상체를 상태값으로 가져, 내부구현은 모른다. . | 중요) 상태객체가 단독 public으로 열린 최초시작상태Ready 객체가 있다면, 시작이 그것 밖에 없으니, 생성자가 아니더라도 필드에서 바로 new Ready(); = (최초시작상태 객체)로 초기화`해줘도 된다. . 암기) 상태패턴은 필드에서부터 열려있는 접근제어자는 Ready객체 밖에 없어서 private State state = new Ready();로 시작 . Ready로 시작할 수 밖에 없다면, 생성자에서 초기화 안하고 필드에서 해도 된다. . public class Player { private State state = new Ready(); } . . | 72) 상태사용자 Player 등은, 상태업데이트 메서드 state.draw(card)를 사용하는 메서드를 한번더 만들어줘야한다( 객체를 포장하는 조합처럼). + 이 때, 필요한 재료(card)를 바로 줄지, 아니면 더 바깥상태의 재료를 받아서 내부에서 꺼내서서 넘길지(Deck.pick() -&gt; card)는 사용자 맘이다. -&gt; 어떻게 되었든 Player는 인터페이스로 연결된 State를 모른다. . . public class Player { private State state = new Ready(); // state사용 객체 입장에서, 재료 뭉태기를 한번에? public void draw(Deck deck) { state = state.draw(deck.pick()); } //or 1개 재료만? -&gt; 선택 가능함. public void draw(Card card) { state = state.draw(card); } } . 73) 사용자 가 끝나기전 호출가능 메서드들(draw, stay)을 호출하는 메서드를 작성할 때는, 항상 내부에서 현재State가 아직 안 끝난 상태인지 확인후 호출되도록 해야한다. . public interface State { State draw(final Card card); State stay(); Cards cards(); boolean isFinished(); double profit(double money); } . . . 74) state사용자가 상태변화메서드draw()의 재료뭉태기를 파라미터로 + while + is끝난상태객체 될대까지로 돌리면 한번에 계속 호출할 수 도 있다. . . public class Player { private State state = new Ready(); public void draw(Deck deck) { while (!state.isFinished()) { state = state.draw(deck.pick()); } } } . my) 매번 끝났는지 확인가능 + 끝날때까지 재료가 매번 제공되면 -&gt; if로 1동작만 할 것을 -&gt; while로 여러동작할 수 있다. . 메서드가 card를 파라미터로 받는다고 해서 외부에서 card를 직접꺼내주지말고, 외부에서는 card덩어리의 객체를 파라미터로 받아보자 . . Player . draw &lt;- Deck ( = cards by .pick() ) if ! isFinished() state &lt;- card &lt;- Deck.pick() | . | while ! isFinished() state &lt;- card &lt;- Deck.pick() | . | . | draw &lt;- card if ! isFinished() state &lt;- card | . | . | . public class Player { private State state = new Ready(); public void draw(Deck deck) { while (!state.isFinished()) { state = state.draw(deck.pick()); } } public void draw(Card card) { if (!state.isFinished()) { state = state.draw(card); } } } . | . | . 남은일 . 상태패턴에서 stay일 때 profit구현(임시로 money 1배로 반환) | .",
            "url": "blog.chojaeseong.com/java/pattern/state/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/29/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD%EA%B3%BC-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B44.html",
            "relUrl": "/java/pattern/state/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/29/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD%EA%B3%BC-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B44.html",
            "date": " • Mar 29, 2022"
        }
        
    
  
    
        ,"post94": {
            "title": "강의) 네오 3단계 블랙잭 피드백(3/4)",
            "content": "상태객체의 재료검증은 -&gt; 시작후 자기내들끼리 만드니 -&gt; 패키지파서 default로 몰아 내부생성만 가능 except 최초시작객체 -&gt; 검증이 필요없게 된다. . 재료(카드2장)에 대한 각 상태별 예외처리를 해줘야한다? -&gt; 구현체들의 생성자 접근제한자를 default + 패키지 따로 챙기기로 막아, 접근된 코드에서만 만들어지도록 제한하기 (최초시작상태 객체Ready제외) . my+중요) default 접근제한자는 같은 패키지내에서 만 접근 가능해진다 -&gt; 테스트 외 다른 곳에서는 생성못하게 패키지를 실시간으로 1개파서 생성의 안전성을 보장해준다. . 중요) Ready최초시작객체만 public(코드에서 생성가능) 제외 나머지 구현체 상태객체들은 오로지 트리거 메서드 내부 응답시만 생성되도록 패키지에 파서모으고 + default 생성자로 막아 -&gt; 패키지 내부에서만 생성 except Ready최초시작객체만 public 밖에서 생성 -&gt; 외부에서 이상한 재료가지고 생성하는 검증이 필요없이 안전하게 패키지내 서로에 의해서만 생성 + 시작은 Ready객체에서 . 35) 각 상태객체들을 state패키지를 파서 모으고 -&gt; 외부에서 생성되는 Ready를 제외하고default제한자로 바꿔서 -&gt; 테스트를 제외하곤 외부에서 생성X . 패키지를 만들어 추+구현체들을 모으고, 시작Ready를 제외한 다른 구현체들을 패키지내에서만 생성될 수있게 생성자를 default(접근제한자 삭제)해보자. . 몰기 전 . | 패키지 1개에 몰기 . . | . | 중요) 패키지 1개로 파서 몰 때, Test도 같은 이름으로 파서 몰아줘야, default가 작동된다. . . . 중요) 우리가 코드짜면서 외부에서 잘못된 재료로 객체Hit 등을 생성할일은 없다. 클라이언트가 실수하므로 강제로 패키지내에서만 생성되도록 Ready제외 접근제어자를 삭제해서 default로 만들어 외부생성X내부에서만 돌면서 생성되도록 바꿔주자 . my) 특정 객체에서부터만 시작하는 구현체들?? -&gt; 패키지 파서 모으고 1개만 public으로 열어두고 나머지는 default . 시작Ready만 public으로 그대로 둔다. . | 나머지 상태객체들은, state패키지내부에서만 생성가능하게 접근제한자를 삭제해준다. . . . public final class Hit implements State { private final Cards cards; Hit(final Cards cards) { this.cards = cards; } . | 참고) 생성자 정의 안해주면,아직 (재료를 가지고) 생성 한번도 안해봤었다? 상태이며 , 기본이 public 생성자 상태이다. 유틸클래스는 이것을 막아주기 위해 private 빈 상태로 재정의를 해줬던 것이다. . **만약, 생성자 없다? -&gt; 확인해보니, public으로 열려있다. -&gt; 나중에 Bust정의할 때,default로 닫아줘야한다. ** . . | 이제부터는 new Hit( 재료카드2장)으로 생성할 땐, state패키지내 메서드에 의해 생성되어, 외부 잘못된 카드로 인한 생성은 검증이 필요없이 안전한 상태가 된다. . | Ready만 열어줬다고 해서, Ready시작만 되는 것은 아닌 상태임. . | Hit(카드받기 가능)에서 -&gt; Stay안받아의 상태 추가 개발 . 가능한 상태 다시 생각 . 첨 카드 2장만 받고 최대(11+10)으로 bust는 불가능하고 -&gt; blackjack이 최대 높은 사태다 ready +2장 blackjack | hit +1장 bust | blackjack : 블랙잭은 2장일때만 가능이다. | hit | . | hit +stay(): hit상태에서 +1장이 아니라 테스트에선 생략하는 view로 물어보고 -&gt; 추가 메서드를 통해 stay상태로 갈 수 있다. stay | . | . | . | . 35) 기존 트리거 메서드외에 직접 추가한 메서드로 특정상태로 갈 수 있다. (hit -&gt; draw()말고 stay()) -&gt; view에서 물어보고 갈 case를 -&gt; 바로 메서드 호출()하여 case로서 가버리자 . 참고) Test에서는 inputView의 물어보는 과정을 아예 생략하고 그 이후 case로 진행해 나간다. ex&gt; stay할거냐? 안물어보고 바로 stay()로 가는 메서드를 호출 -&gt; 테스트에서 빨간줄로 호출하며 메서드 + 상태객체 다 만들자. . 참고) public외부에서 Ready시작객체로 시작해야하지만, Test에서는 패키지명 동일 -&gt; default 생성자 사용가능 -&gt; 바로 특정 구현체 객체 생성 가능~! . hitTest에서 -&gt; 빨간줄 Stay상태객체로 가는 빨간줄 메서드를 만들자. . . @Test void hitStay() { // given: hit(2,10) State state = new Hit(new Cards(SPADE_TWO, SPADE_JACK)); //when: draw(X) -&gt; stay() -&gt; Stay //state = state.draw(SPACE_TEN); state = state.stay(); //Stay객체가 나와야함. assertThat(state).isInstanceOf(Stay.class); } . | 참고) Test에서 클래스 생성시 -&gt; 빨간줄 -&gt; Create Class -&gt; 패키지명 확인후 tab + ↓ + ↑로 프로덕션 명시해주느 단축키 외우기 . 구현체에서 상태변화 메서드 stay()이전에 Stay클래스 부터 만들어준다. . . 단축키 tab + ↓ + ↑ 를 활용해서 프로덕션으로 빠르게 경로지정해주자. | . | . 상태객체의 class를 생성했따면 -&gt; impl State부터 . 추상체 구현후 generate -&gt; im을 검색해서 추상체 구현메서드를 오버라이딩이랑 구분해서 빠르게 정의해주는 버릇들이자. . . . . | . | 36) Stay클래스 State구현 후 공통 구현메서드는 일단 나중에! Test에서 하던 .stay()부터 개발 . 일단 구현해야하는 메서드는 두자. | 대박) 구현체 메서드 개발시 -&gt; 기본 공통 추메/전메로 올리고 -&gt; 나머지들도 구현해주는데 호출불가시 Thr illegalState -&gt; 호출불가 너무많다? -&gt; 구현체들 impl시 중복되는 코드들을 &lt;부모로써 먹어 자동구현 해주는&gt; 중간 카테고리를 추클(추메/전메를 다 필수구현안해해도 되는 성질)로 추가한 뒤, [추상체-impl-&gt;중간 추클] + 그 아래 구현체들을 [추클-extends-&gt;구현체]로 연결을 바꾼다. . 중요) 추상체변수로 받은 상태에서의 특정 구현체(Hit)에서 불러야하는 메서드(.stay()) 개발은?? 그냥 생성하면 추상체의 추메/전메로 생성되어 -&gt; 나머지 구현체들도 다 구현해야하는… 강제성을 가지게 된다. -&gt; 일단 원하던 특정 구현체에서만 추메/전메를 impl하여 구현 -&gt; 이후 다 구현해줘야하는데, 호출불가 상태에서는 thr예외처리로 해결 . hit상태에서 빨간줄 .stay();를 호출하면 Stay를 생성해줘야한다 . | 그냥 생성해주면.. 추상체의 추메/전메로 정의되어 -&gt; 나머지 구현체들이 구현해야한다 . 현재는 Hit에서 .stay()만 필요한 상태인데??? 일단은 추메/전메로 올려놓고 -&gt; 다시 Hit로 가서 구현해준다. | . | . . | 중요) 특정구현체에만 필요한 메서드 (hit에서 .stay())라도, 추상체 변수상태의 추메/전메로 생성된다 -&gt; (여러구현체 다 빨간색 impl요구 된 상태지만) 특정구현체로 먼저 가서 추메/전메를 구현해준다. -&gt; 이후 호출할 수 없는 구현체는 thr illegalState 예외처리로 해결한다 . Hit용 메서드가 -&gt; 추상체State의 추메/전메로 올라와 버리는 바람에 구현체 다 빨간줄상태지만, Hit부터 가서 추메/전메를 구현해서 정의해준다. . public interface State { State draw(final Card card); State stay(); } . | 원래 해당 메서드가 필요했던 특정구현체Hit로 먼저 가서 구현까지 해준다. . 호출시 바로 Stay상태가 되어야하므로 객체 생성해서 건네준다. | . . @Override public State stay() { return new Stay(); } . | 정리용) . 37) 나머지 구현체들도 강제로 구현해야한다. 호출불가 상태객체에서는 thr illegalState 처리 . hit를 제외하고 . @Override public State stay() { return new Stay(); } . Blackjack이 stay가능?(X) . | Bust이 stay가능?(X) . | Ready이 stay가능?(X) . Stay이 stay가능?(X) | 다 구현후 thr illegalState 처리 . | alt+insert -&gt; impl검색 -&gt; stay()구현 -&gt; thr 처리 | . @Override public State stay() { throw new IllegalStateException(); } . | . | 이제 hitStay에서 .stay()를 테스트할 수 있다. . @Test void hitStay() { // given: hit(2,10) State state = new Hit(new Cards(SPADE_TWO, SPADE_JACK)); //when: draw(X) -&gt; stay() -&gt; Stay //state = state.draw(SPACE_TEN); state = state.stay(); //Stay객체가 나와야함. assertThat(state).isInstanceOf(Stay.class); } . | . ### . 중요) 특정구현체용 메서드를 추상체에 올린후-&gt;구현-&gt;나머지 처리했더니 대부분이 사용안하고 예외처리다? -&gt; [중복코드를 부모로써 먹어주는 중간 카테고리 추클]을 [추상체-impl-&gt;추클]로 추가한 추상화를 하고 그 아래 구현체들을 [추클-extends-&gt;구현체]로 연결한다. . 기존 상태 . State(I, 첫 상카, 추상체) - Ready포함 여러 구현체들(final Class) | . . | . 38) 추메/전략을 구현하는 구현체or구현체들을 제외하고 나머지 대부분의 구현체들이 -&gt; 구현하면안되서 illegalState처리하는 그룹이 많아지면, 중복코드를 부모로써 먹어주는 추클로 중간 카테고리를 끼워넣되, 구현체들의 구조 상카impl-&gt; 중카extends -&gt; 구현체로 바뀐다. . 중요) 구현체용 단독메서드를 위에서 올려서 구현하다보니, 일부 구현체들은 안쓰는 코드로서 코드중복 -&gt; 특정 구현체들 묶음으로 묶어 코드중복을 없애줄 중간카테고리로 추상화하는 생각 + 중카는 추클로 추가한다. -&gt; 이름을... 구현체들 왜?? 묶는지로 생각해서 작명해주자. . 중요) 상카-추상체에서 타고 내려오는 메서드들의 코드중복만 추클이 먹어줄 수 있다. -&gt; 구현체들이 interface 공통인 추메/전메 이외에 다른 것을 구현했어도, 공통인 추메/전메에서 중복되는지만 확인해서 중간 카테고라이징해준다. . 중요) 특정 메서드의 중복발생이지만 -&gt; 중간 추클로 코드중복 제거시 -&gt; 상카의 전메/추메의 목록을 다 보면서 중간 카테고라이징 한다 . public interface State { State draw(final Card card); State stay(); } . stay()에 의해 코드 중복이 발생했지만, draw()도 같이 중복이 일어나는지 살펴서 중간 카테고라이징 한다. . | Hit만 stay된다. -&gt; 나머지 구현체들은 다 예외처리로 구현되어 중복이 발생했다. . Ready는 stay예외처리는 똑같지만, draw에서 코드 중복이 안일어난다. . | Blackjac, Bust, Stay는 이미 다 끝난 최종 상태객체로서 더이상 트리거 메서드 모두(draw, stay) 다 호출 불가 -&gt; 모든 추메/전메의 구현이 중복된다. . @Override public State draw(final Card card) { throw new IllegalStateException(); } @Override public State stay() { throw new IllegalStateException(); } } . | . | . 중간에 중간카테고리를 추상클래스로 추가하고, 상위카테고리 State를 imple해줘야한다. . 중간 카테고리 이름은? .stay() 못해서 thr처리 된 이유?를 생각해보면 Finished로 이미 끝났기 때문이다. 사실 Stay는 이미 stay를 호출해서 끝난 것 | . | State(최초상카, I) &lt;—&gt; 구현체들(final Class) 사이에 들어가 특정 구현체들 묶음으로 묶어 코드중복을 없애줄 중카 Finished를 끼워놓자 | 네오는 인터페이스에 정의한 필수 구현 추메/전메를 default메서드라고 불렀다. | . | 중요-용어) 추메/전메로 타고 개발한 구현체용 메서드가 추메/전메로 정의된 default메서드로서 구현체들에게 중복코드를 계속 imple시킨다면, 상카 &lt;-&gt; 구현체들사이 [중복코드를 부모로써 먹어주는 중간 카테고리] 추클로 추상화를 고려한다. . 구현체들의 중복된 예외처리 코드를 부모로써 먹어서 자동구현해주는 추상클래스를 중간카테고리로 추가한다. . 이미 stay로 가기엔 hit가 아닌 끝난 상태라서 .stay()를 호출못해서 예외처리코드로 코드 중복이 되는 상태이므로 중간 카테고리 추상클래스이름을 Finished로 끝난 상태라 stay못함.으로 지어준다. 여기에 Stay도 포함되어있다. | . | . . | 중요) 상카(interface)가 존재한 상태에서 [코드중복 먹어 자동구현시킬려고 끼운 중간카테고리 추상클래스]는 상카인 interface를 impl시켜야한다 . 중간 카테고리로서 끼어들어간 추클은 상카 State(I)를 impl해야한다. 클래스와 달리, 추상클래스는 추메/전메impl 필수구현이 아니다. | 그래도 추메/전메를 모두 구현해놔야 기존 상카 구현체들로서 모든 추메/전메를 받아먹게 된다 | . | . 중요) 상카(I)를 impl한 클래스와 달리, 상카를 impl한 추상클래스는 상카의 추메/전메가 필수 구현이 아니다. (cf.abstract를 지우면 필수구현하라고 뜸) -&gt; 추상체 중 원하는 메서드만 구현할 수 있기 때문에, 구현체들에서 발생하는 코드 중복의 [특정 메서드]만 대신 구현이 가능해진다. 하지만, 일단 모든 추메/전메를 impl구현해야 -&gt; 하카 속 자식들이 [원래 목적인 상카Interface의 구현체=상태객체]로서 성질이 유지될 것이다. + 중카 추클을 안끼워놓은 상카 구현체(상태객체들)이랑도 상호 호환되어야하는데, 중카 추클 있는데, 상카의 추메/전메가 없는 구현체(상태객체)가 되면 의미가 없다 -&gt; 중복제거 특정메서드 + 모든 상위 카테고리 추상체의 추메/전메 모두 받아먹을 수 있도록 -&gt; 중카 추클은 상카 인터페이스 impl시 모든 추메/전메를 impl구현해야만 한다. . 추메/전메를 가진 상카 인터페이스를 impl했지만, 전메/추메/default메서드 구현하라고 빨간줄이 안뜬다 중간 추클은 구현체가 아니다. 필수 구현 안해도 된다. -&gt; 그러나 중카 추클 추가 전에 상태 Interface의 구현체역할이 더 중요하므로 추메/전메도 같이 받아먹어야한다. | . | abstract를 지우면, 인터페이스의 구현체로서 필수 구현해야한다. . | 추클은 구현안해도 되지만, 추클 중간에 끼워넣기 이전에 interface의 구현체 성질(상태객체)가 먼저다! | . 중요) 잔소리말고, 코드 중복 제거를 위한 중간카테고리=추클은 -&gt; 기존 구현체 성질 유지를 위해서, 무조건 [필수는 아니지만 모든 추메/전메 impl구현] 하자! . 39) 중간 추클은 구현체가 아니라서 필수구현 안해도 된다. -&gt; 이 성질을 이용해서 특정메서드만 구현가능하지만, 일부 구현체그룹 중복발생 메서드stay()이외에 공통 추메/전메인 draw()도 impl해서 같이 중복처리를 해주는 버릇을 들이자. . 참고) 구현체들의 중복코드를 추클로 올릴 땐, impl로 껍데기는 구현 -&gt; 내부 코드는 중복되는 코드를 가진 구현체에서 직접 복사 붙혀넣기해서 대신 구현해주는게 젤 좋다.(100%중복되니까) . 현재 hit를 제외한 구현체들에서 stay() { 예외처리 }부분만 코드 중복이었지만, 상카의 구현체로서의 역할유지를 위해 모든 추메/전메를 impl해서 카테고라이장 하려고 해보자. . . . 일부구현체 코드 중복은 stay()에서만 발생했지만, 모두 impl해서 살펴보자 . . | . | 중요) 특정 메서드의 코드중복 -&gt; 다른 공통메서드들도 같이 살펴 볼 것!! . 살펴보니, stay뿐만 아니라 draw에서도 공통적으로 코드 중복이 일어나는 클래스들이 발견되었다. . | 중복코드는 직접 impl구현하지말고, 구현체 1개에서 다 똑같은 중복코드를 복붙해오자 . . public abstract class Finished implements State { @Override public State draw(final Card card) { throw new IllegalStateException(); } @Override public State stay() { throw new IllegalStateException(); } //blackjack, bust, stay 중복 -&gt; 중간 추클을 extends하도록 변경해야함. } . | my) 뜬금포: 중간 카테고리는 특정 상태가 많을 것이다. 상카는 전체 대명사에서 시작 -&gt; 중카는 대명사에서 이어지는 상태 형용사?! ( State -&gt; Finished(state)의 형용사) . 이제 중복코드를 가진 중간 카테고리 아래 구현체들이 코드 중복을 대신 구현해주는 부모로서 중간 추클(Finished)을 extends하도록 변경해준다. . 코드 중복 하위 카테고리 -&gt; blackjack, bust, stay . | 가장 상위 카테고리 상위카테고리 추상체 State를 impl -&gt; 코드중복 먹어주는 중간 추클 Finished를 부모로서 extends로 변경 . | . - . . | ​ . ​ . 중요) extends가 보인다면, extends로 부모(추클)의 중복코드 받아먹는 중 -&gt; 내부 코드는 제거된 상태로 먼저 생각하자!! . 중요) impl한 구상체에 @overriding은 필수구현 추메/전메 구현중이라고 생각 + cf) impl한 추클이라도 필수가 아닌 것 같지만, 모든 추메/전메를 구현해야 의미가 있다 . 중요) extends한 자식내부에서 @overriding이 있다면, 부모가 중복코드 먹어 구현해주는 데도 @또 고쳐쓴다로 해석하자. + 원래는 딴짓 못하게 부모인 추클 메서드 [모두impl]하여 정의시 final로 막아야한다 . **extends가 보이면, 부모가 중복코드를 먹어 대신 구현해 내려주는 중이라고 생각하고 ** . 추상체 인페의 impl하는 구상체에서의 @overrding == 필수 추메/전메 구현중은 지우고, extends로 중복먹어 내려주는 것을 받아먹자 | . . . public final class Blackjack extends Finished { private final Cards cards; Blackjack(final Cards cards) { this.cards = cards; } } . | . 중요) extends를 치는 순간부터, 부모가 중복코드 내려주는 중이니, 생략된체 받아먹자. 생각 -&gt; 만약, 자식으로 받아먹기 이전에, 구현체로서 impl + @Overriding의 추메/전메 필수 구현이 있었다면 -&gt; 삭제하여 자식으로서 받아먹고, 구현체로서 받아오는 역할은 추클(중카)에게 맡기자 . . . . 나머지 2개 중간카테고리 아래자식들도 다 extends로 중복코드 받아먹고 코드는 제거하자 | . ​ . public final class Bust extends Finished { } . ​ . Stay도 이미 Finished된 상태로 draw/stay예외처리하는 코드 중복이 발생하니 . extends 중간추클(부모) -&gt; 중복코드 받아먹기 -&gt; impl + @overridng 추메/전메 필수구현은 삭제 | . . . . public class Stay extends Finished { } . | . extends로 중카=추클=부모가 중복코드 구현해주고 받아먹는 중인데, 자식들이 중복코드 받아먹는 와중에 extends + @또 고쳐쓸 수 있다면? 불안한다 -&gt; 추클이 중복 코드 impl구현 부모 역할시의 모든 상카 추메/전메 impl구현할 때 -&gt; final or abstract를 달아줘서 중복코드 받아먹는 자식들이 딴짓 못하게한다. . 40) 중복코드 구현 추클 부모(중간 카테고리)는 내려줄 때, 자식이 extends후 받아먹기만 하고, @고쳐쓰는 것은 못하도록 -&gt; 추클 메서드에는 final (or abstract)를 미리 달아서 정의해놓는다. . 중요) 특정구현체 메서드 개발에서 비롯된, 코드중복 제거용 추클(중간 카테고리)이 예의상 추메/전메를 모두 구현해서 코드중복을 해결해줬는데, 추클이 중복제거할라고 impl 구현한 추메/전메에는 final (or abstact)을 달아서, 받아먹는 자식들이 딴짓(extends받아먹은 후 @또 고쳐쓰기)못하게 막자 . 상카 구현체들 중 특정 카테고리의 추메/전메의 중복코드를 구현해주는 추상클래스에서는 자식들이 extends로 받아먹게만 하고, extends후 @또 고쳐쓰기 못하게 final or abstract를 달아주자. . my) 추메가 중간에서 중카로서 중복제거 역할로서 끼워진다면 . impl 상카(추상체,interface)할 때부터 모든 추메/전메 impl구현 . . . . | 추클은 부모로서 자식들이 중복코드 받아간다 -&gt; 추메/전메impl 직후 -&gt;자식을 가진 부모라면 내부 final or abstract부터 정해주기 . . | 추클의 2가지 작업(모든impl 구현 + final or abstract 달아주기)가 구현체(자식될 놈)들 중 1개에서 중복코드를 복붙해와서 메소드 구현해준다. . . | . public abstract class Finished implements State { @Override public final State draw(final Card card) { throw new IllegalStateException(); // 구현체 블랙잭한테 복사해온 중복코드 } @Override public final State stay() { throw new IllegalStateException(); // 구현체 블랙잭한테 복사해온 중복코드 } } . | . | . 중요+정리) 코드 중복을 먹어서 자식에게 제공해주는 추클 끼워넣을 시, 해줘야하는 2가지 작업 . 기존 상위카테고리로서 interface의 모든 추메/전메를 구현한다 그래야 기존 상카(interface) 추메/전메&lt;—&gt; 구현체들(Class) 추메/전메 필수 구현의 관계가 유지된다. | 추상클래스는 상카(interface)를 impl해도 추메/전메 필수구현이 아닌 상태다. 그래도 생각말고, 모두 impl해주자 | . | . | impl 추메/전메의 모든 구현 직후 추클은 중복먹어 내려보내주는 부모인데 자식들이 가져가서 고쳐쓰거나 딴짓 못하게 final or abstract으로 메서드들 막아주기 | 41) 중카 추클 끼워넣기로 중복제거 완료후 -&gt; stay로 다시 돌아와서 -&gt; 도메인 테스트를 해준다. 개발기능: Stay상태객체 개발 및 hit이외에 나머지는 .stay() 호출안되는 예외처리 . hit-&gt; Stay를 테스트하는 와중이었다 . | Stay 도메인이 개발되었고, .stay()호출 기능도 개발되었다. . hit Stay는 통과했다. | 나머지 state(blackjack, Bust, Stay) -&gt; .stay() -&gt; 예외발생 테스트 굳이 Stay | | | 중요) new 구현체 () 생성시에는 항상 변수를 추상체로 바꿔서 받아주자! . new 구현체 생성시, 변수추출하는데, 변수형은 추상체로 바꿔받자 . . @Test void stay() { final State stay = new Stay(); } . | 참고) 호출시 예외발생하여 종료 테스트 -&gt; assert문 내부에서 호출하기~ . 이미 끝난 상태로서 Stay상태에서느 .stay() 호출시 예외발생하고 종료되어야할 때 . @Test void stayStay() { // stay -&gt; .stay() 호출 불가 final State state = new Stay(); // stay에서 stay()하면 안됨 -&gt; 예외발생되서 종료되야 정상 -&gt; assert문에서 호출 assertThrows(IllegalStateException.class, () -&gt; state.stay()); } . | 추가로 Stay상태에서 .draw()호출해도, 이미 끝난 상태로서 예외발생하고 종료해야한다. . @Test void stayDraw() { // stay -&gt; .draw(카드1장) 호출 불가 final State state = new Stay(); // stay에서 stay()하면 안됨 -&gt; 예외발생되서 종료되야 정상 -&gt; assert문에서 호출 assertThrows(IllegalStateException.class, () -&gt; state.draw(SPADE_ACE)); } . | 중요) 중복코드 구현체들을 위해 중카(추클)을 하나만 끼워넣으면, Layer가 안맞다 -&gt; 중복없는 구현체들도 Layer용 중카 추클을 끼워넣어준다 . . 현재 Finished만 중간 카테고리 (추상클래스 Layer)를 가져서 Layer구조가 안맞다. | . 참고) Stay class에 final을 안붙혀줬더니 다이어그램상 *모양이 없다 . . . . 42) Ready.start() 부분을 모두 리팩토링 -&gt; 돌아가서 회색메서드가 되면 안전삭제 . 중요) 메서드 테스트, 통합테스트는 개별적인 도메인 테스트와 달리, 객체들이 합쳐졌을 때 잘 작동하는지 확인할 수 있다. -&gt; 여러 객체들을 복합적으로 테스트 but 자기맘 . State객체의 모든 상태객체들은 결국 판단 및 새 객체응답판단시 뿐만 아니라 -&gt; 결과 보여주기 or View에 넘겨주기 위해 정보(상태값) 뿐만 아니라 getter조회메서드까지 무조건 가지고 있어야한다. -&gt; 전체 공통 메서드이므로 추메/전메로서 interface에 올려서 개발시작하며 중간카테고리가 존재한다면, 속하는 구현체(자식들)이 코드중복인지 아닌지 한번더 살핀다 . 43) 모든 상태객체는 결국엔 정보값에 + [getter메서드]를 가져야한다. 메서드이므로 interface에 올려서 개발시작하자 -&gt; getter는 getXXXX보다는 필드명 or 일급명을 소문자로 네이밍하자 . 참고) .getValue() 대신 상태응답값(returnType)과 함께 .인스턴스변수(상태값)명() or .일급상태값()으로 getter메서드를 네이밍 해보자. . 모든 상태객체마다 상태값(Cards)를 조회하는 메서드를 정의하기 위해 상카 추상체 State에 추메/전메로 올려서 개발시작한다 . public interface State { State draw(final Card card); State stay(); Cards cards(); } . Cards는 상태값 일급컬렉션이다. | . | 중요) 구현체들의 공통메서드를 추가할 땐, 최상위 상카 인터페이스에 추메/전메로 올린 뒤 -&gt; 구현체 개별구현인데, 인페추클구현체들로서 중복코드제거용 중카가 껴있다면? 해당하는 자식(구현체)들이 코드 중복인지 아닌지 먼저 살핀다 . . 중요) 중간에 추클로 코드중복제거해서 묶인 구현체들(자식들)은 이제 무조건 통해서 오는 추클의 자식들이 됬으므로, 항상 개별 구현 전에, 묶어서 부모에서 중복 먹일 수 있나 없나부터 먼저 생각해야한다. . 중요) 중카, 추클은 필수구현이 아니지만, 중간자식들의 구현체 성질 유지를 위해 모든 추메/전메impl 해야만 했다. 추메/전메에 새 메서드가 올라갔어도 [중카, 추클은 필수impl아니라서 놔둬도 빨간줄 안날줄 알았는데...] -&gt; 자식들이 빨간줄로 화나있다. -&gt; 살펴보니, 중카-추클이 impl안한, 상카-추메/전메에 대해서, 모두 구현안해주면, 자식들이 화를 난다. . . . 하위 자식들(구현체) 3개를 임시로 삭제하면, 추클에서는 에러 안난다. . | 이번엔, 추클이 impl구현한 메서드2개 중 1개를 삭제했더니 -&gt; 자식들이 화를 낸다. . . | . 중요) 결론적으로, 중카 추클은 추메/전메의 모든 impl구현이 필수가 아닌 것 같지만, 모두 impl안해주면, 자식들이 에러가 난다. . 추클 자체에러는 없지만, 자식들이 위에서 화를 내고 있다. -&gt; 추가되는 전메/추메는 모두 구현해줘야한다. . . | . 중요) 뭐야.. 중카 추클이 모두impl안해도 화내던 자식들에서 개별 impl구현해도 된다?!! . 중카 추클 Finished에서 .cards() 구현안해서 자식들이 화난 상황 . | 화난 개별 자식들에서 빨간줄 제거를 위해 impl해보았더니, 에러가 사라진다. . | . ​ . ​ . 인터페이스가 상위 인터페이스 - 구현 추상클래스 -의 자식들 중 하나인 blackjack을 추클 구현impl이 없다면, 직접적인 구현체들처럼 실제 구현으로 받아들인다. . . | . 정리 그림 . . 45) 새롭게 상카 추메/전메에 올린 getter(.cards())에 대해, 구현체들 개별 필수구현전에, 중간카테고리 추클의 하위 자식(구현체)들 Blackjack, Bust, Stay에 중복이라면, 추클에서 정의해줘서 받아먹게 해준다. -&gt; `중카 추클은 코드중복을 위해 묶여있기 때문에… . 중요) 새로운 메서드가 상카-인터페이스부터 타고 추가될건데, 중카-추클에 걸린다면, 추클의 목적상 하위자식들의 코드중복이므로, 중복되는 상황인지 보고 중복되면 중카에 vs 중카-추클에 구현안하고 개별 자식들에게 책임전과하여 개별구현도 가능하니 중복 안되면 중카-추클에서 정의하지말고 내려오는 추메/전메에 대해 중카-추클 무시 맨 끝 자식들에서 개별구현으로 구현책임 전과해도 된다. 반대로 여러 구현체에서 전체 중복이면 -&gt; 상카 인터페이스 직전에 중카-추클을 끼워넣어 전체 중복코드만 먹일 수 있다. ex&gt; 이후 Started가 그 예시 . getter인 cards()메서드는 3개 자식들에 대해 중복적으로 필요하다. . 그렇다면, 중카 추클에서 중복코드로서 대신 구현해서 -&gt; 자식들이 개별구현안해도 받아먹을 수 있게 해줘야한다 추클에서 필수아니라고 새로생긴 추메/전메를 impl구현 안해놓으면, 자식들에게 필수 구현으로서 전과됨을 참고하자 | . | . . | . 중요) getter를 구현할 때 필요한 상태값(인스턴스변수)도 있어야한다. getter는 중복이라서 추클에 대신구현으로 정의했는데, 상태값 -&gt; 자연스럽게 따라오는 [(최초시작 아니라면 -&gt; 여기선 끝난 상태객체 3개) 외부에서 재료를 받아 최초 상태값을 초기화해줄 재료받는 생성자] 정의도 중복이다! -&gt; 추클에선 자식들(구현체) 생성자 중복을 protected로 정의해줘야, 구현체(자식들)이 자기들 public생성자에서 &lt;주생성자 대신 부모것을 주생이라 여이고&gt; super() == 중복된 코드를 갖다써서 외부에서 재료를 받아 가공할 수 있게 된다. . 46) getter메서드가 끝난상태객체에서도 공통필수메서드면 -&gt; 상태값도 모든 구현체들에게 필수이다. -&gt; getter에 대한 상태값들도 중복코드로서 추클에서 정의해주자. . 중요) 상태값(인스턴스변수) = 필드를 생성할 땐, 가공전 raw상태값을 재료로 받는 or 최초시작이면 재료없이 내부 빈 상태값으로 초기화해주는 생성자 2개를 먼저 생각한다. . 현재 getter인 cards()에 쓸 상태값을 가져야하는 상황이 왔다면, -&gt; 가공전raw상태값 재료 생성자 or 내부 빈재료 생성자를 먼저 선언해주는 버릇을 가지자. . . 생성자 선언전에 가공전raw상태값을 재료로? 재료없이 내부에서 빈 상태값으로? 먼저 선택한다. 끝난 최종상태객체이므로 무조건 직전까지 업데이트된 상태값을 재료로 받아 가공하여 생성되는 객체다 | . | . | 중요) 추클속 코드중복 제거용 생성자는 &lt;외부에서 쓰는 구현체.메서드()와 달리 [자식 내부에서 주생this()쓰듯이 부모super()를 갖다쓰도록 하기 위해 -&gt; protected로 선언한다 . my) 추클, 부모에서 생성자 중복코드는 protected로 선언해줘야, 자식들이 주생성자를 this()로 갖다쓰듯이, 부모생성자를 super()로 갖다써서 자기들 생성자를 정의한다. . . . public abstract class Finished implements State { protected Finished() { } . 참고로 파라미터도 바꿀꺼면, 접근제한자도 같이 ctrl+F6의 change signature로 바꿀 수 있다. . | 추클의 생성자를 change signature로 public or proteced상태로 생성자 리팩토링 한다면 -&gt; extends 자식들에게 자동으로 직접구현까지 해준다 . public으로 추상클래스(부모)에서 생성자 리팩토링 예시 . . | . | . 중요) 생성자를 정의할 땐, 미리 생각해둔 초기화할 상태값 생각후 -&gt; 가공전 raw상태의 외부 재료를 생각해서 기입한다 . 상태값은 일급인 Cards를 가질 예정이다 -&gt; raw상태의 일급Cards가 들어올만한게… 그냥 직전 상태객체의 Cards가 들어와 만들 것임. . 생성자의 파라미터 변경은 ctrl+F6의 change signature를 계속 연습하자. . . public abstract class Finished implements State { protected Finished(final Cards cards) { } . | change signature로 생성자를 수정하면, 추클 -&gt; 자식들에 super()로 내부에서 직접 갖다쓰도록 코드까지 짜준다. . . . . | 근데… Cards cards의 재료를 받는 생성자를 protected로 리팩토링 했는데 -&gt; 재료안받는 생성자로 정의해줬다 -&gt; 삭제해도 될듯.. . 삭제하고 -&gt; 직접 생성자 다시 생성해줌 | . . . | . | . 중요) 상태값을 정의해야한다면, 무조건 생성자부터 -&gt; (재료로 가공후 ) 생성자 내부에서 this.예비상태값 = 에 초기화 하면서 -&gt; 빨간줄로 예비상태값 자동 생성/선언되도록 해주자. . 생성자가 완료되었으면, 생성자 내부에서 상태값을 초기화화면서 상태값을 선언해준다 . . . public abstract class Finished implements State { private final Cards cards; protected Finished(final Cards cards) { this.cards = cards; } . | 47) 재료받는 생성자 -&gt; 상태값 초기화 -&gt; 상태값 선언이후, getter메서드를 완성해준다. . . @Override public Cards cards() { return cards; } . . getter메서드 완성시 (1) 나가는 값이 불변객체하냐 안하냐에 따라 Dto없이 + public으로 열어두기 가능해지며 + (2) 추클내 메서드라면 자식딴짓 방지용 final/abstract를 정해주자 . 48) getter로 응답되는 값이 불변객체(현재 불변 일급컬렉션)이라면 public으로 열어두기가 가능하며 -&gt; dto도 없어도 된다 . 참고) 암기 : getter정의시 return 불변객체라면, public열어두기 가능 + dto없어도 됨 . . 추클내 메서드라면 final or abstract . 추클의 메서드가 getter가 아니더라도 중복코드제거용으로 추가된다면 . final/abstract를 결정해주자 | . . @Override public final Cards cards() { return cards; } . | 49) 추클의 중복제거 중간카테고리에 속하지 않은 개별 구현체(Hit, Stay)들에도 추메/전메(getter) 직접 구현해주기 + if 상태값도 없으면 return 상태값 -&gt; 생성자부터 . . Ready(최초상태객체)도 .cards()의 getter로 상태값을 보여줘야할까? -&gt; 필요없으면 thr처리를 하면되므로 구현체라면, 일단은 필수로 impl해줘야한다. . . . 중요) getter를 짠다고 해서 view에서 보여주는 방식을 생각하지마라 . 딜러 카드를 view에서 1장만 보여준다고해서, 도메인을 설계할 때 반영되면 안된다. | . Ready는 재료없이 빈 재료로 최초 생성되는 상태객체로서 getter로 외부에 보여줄 필요 없는 것 같지만, 1장 만 받아서 아직 다른 구현체 상태객체로 가기 전단계도 있다. -&gt; 선택이다. -&gt; 무조건 2장으로 다채워지기 전까지 cards를 외부에 보여주지말자 vs 1장 받았을 때 보여줘도 될 것 같다 —&gt; 여기선 1장 일때 보여줘도 되니까, Ready에서도 getter가지도록 설계해보자. . . 1장을 가져도 못보게할려면 예외처리하면 된다. | . Hit에서도 getter인 cards구현 . . 새롭게 추가된 추메/전메(getter) 구현 후 기존 중간카테고리-추클(Finished)을 포함한 다른메서드/중카를 무시하고 오로지 모든 구현체의 특정메서드 1개 중복제거를 위한 추가 [중카-추클] 더 위쪽에서 집어넣기 . . 중요) 기존에 이미 중간카테고리=추상클래스=구현체들 중복코드 제거용이 있음에도 -&gt; 새로운 추메/전메 1개의 중복코드 제거를 위한 추클을 더 위쪽에 끼워넣는다 . 중요) 만약, getter같이 ALL 중복 메서드가 추가되었다면, 기존 중간카테고리=추클로 묶인 구현체자식들을 포함한 새 중카=추클을 더 위쪽에서 한번 더 먹어준다고 생각하자 . 중요+정리) 새롭게 추가된 모든 구현체의 추메/전메의 중복코드 제거를 위한 중간카테고리 - 추상클래스 추가 후 할일: 1 abstract달기 2 인페를 impl후 &lt;자식들이 아직 구현안하고 있으면 전과되서 화내니&gt; 상카(인페) 모든 추메/전메 impl하기 or &lt;자식들이 이미 개별 구현하고 있는 상황 == 현재 묶이는 범위가 아니라면ex.중카의 중카추가 상황&gt; 기존 추메/전메는 그대로 전과시켜놓고 새로 추가된 중복되는 추메/전메만 impl구현하기 3 추메메서드 impl되었다면, 자식들딴짓못하게 막기 4 만약 getter등 상태값을 필요로 하는 메서드다? -&gt; 인페가 중복이어도 못먹어주던 상태값 중복 + protected생성자 중복도 고려해서 먹어주기(추클로 묶이는 놈들은 대부분-&gt; 정보를 가진놈이니 상태값+생성자는 거의 같이 묶일거라고 본다.) 5 중복코드 특정 구현체 1개에서 가져와 복붙해주기 6 구현체들(여기선 중카도 포함)을 인터페이스 구현체 -&gt; 추클의 자식으로 바꾸면서, 중복코드들 제거해주기 . my) 메서드명 중복이 우선 -&gt; 인터페이스 —&gt; (모든or일부) 구현체들의 (특정)메서드 내용까지 중복 발생 —&gt; 추상클래스 —&gt; 추클 중복코드제거시 인터페이스가 못하던 상태값과 그에 필요한 생성자도 중복제거를 고려해줄 것 . getter cards()는 모든 구현체+ 추클(자식들-&gt;추클에서 먹기)이 중복이다 이럴 경우, 다 묶고 싶어서 새로운 중카-추클을 더 위쪽에 집어넣는다. | . | 중간 카테고리는 상위카테고리 State(대명사)의 특정 상태로서 형용사로 네이밍하면 편하다 State &lt;— 형용사Started —&gt; Finished + 아직 덜 끝난 개별구현체 상태들 | . | . public abstract class Started implements State { } . 중카추클1) abstract (or final)을 class앞에 달아주기 . public final class Started { } . . 중카추클2) 인터페이스 impl후 구현체들+기존중카추클이 기존 메서드들에 대해 이미 구현 전과되어서 개별구현 중인 추메/전메는 그냥 두고 -&gt; 새롭게 추가되어 impl(개별)구현없이 중복 되어있는 메서드에 대해서만 중복제거용으로 먹어주기 . . 추클은 impl하라고 빨간줄 안뜨니 직접 챙겨서 해야한다. . . | 추클 impl시 이미 자식들or기존 중카 추클에서 전과되어 개별 구현하고 있는 내용은 그대로 둔다. . | . . **stay+draw는 이미 전과 개별구현 중이다. + 전체중복도 아니라서 고려대상도 아니다. ** 아래로 묶일 녀석들(구현체+@중카추클)에 대해 모두 중복되는 메서드만, 추클에 정의한다 | . | . . . 중카추클3) 추클에 impl되는 메서드들은 자식들에게 내려주는 놈들이니 final or abstract를 달자 . . 중카추클4) 추클이 메서드 먹어주는 와중에, 상태값이 필요로하면 -&gt; protected생성자와 상태값도 중복코드인지 확인하고(대부분 중복일 듯) -&gt; 추클에서 먹어준다. . 현재 기존 추가된 중카=추클인 Finished에서도, 3개 구현체-&gt;자식들에 대해, 상태값과 생성자는 중복이라서 중복코드로서 추클이 먹어준 상태 . . | 여기(Started)에서도 모든 상태객체는 모두 getter를 가지며 -&gt; 그에 따라 상태값+생성자 역시 모두 가질 것이니 -&gt; 상태값과 그에 필요한 protected생성자를 추클에 정의해주자 . 상태값을 생각해서 -&gt; 생성자에 가공안된 raw상태값을 파라미터로 받아주도록 정의 . . | protected생성자에 따라서, 필드는 빨간줄 자동생성 해준다. . | | . 중카추클5) 중복코드 구현체 중 1개 복붙해오기 (여기선getter + protected생성자 + 상태값이라 라 간단해서 복붙하는 것은 생략됨) . . . public abstract class Started implements State { private final Cards cards; protected Started(final Cards cards) { this.cards = cards; } @Override public final Cards cards() { return cards; } } . 중카추클6) &lt;&lt; 기존 추클 &gt;&gt; -&gt; 개별 구현체 순으로 기존 상카-인페를 impl하던 구현체에서 -&gt; 끼어들어가는 새로운 추클을 부모로 extends하면서, 내려받을 중복코드를 삭제해주자 . 기존 중간카테고리가, 기존 연결을 끊고 더 위쪽에 생긴 새로운 중간카테고리를 부모로서 받아와 보자. . 기존 구조 . . | State - Finished의 관계인 impl State을 끊고 -&gt; impl State를 하고 있는 새로운 카테고리 Started를 끼워놓고 기존 추클의 부모 추클로서 extends new중카(추클)해주자 . . | . 중요) 추클은 protected의 생성자 중복(+상태값)도 정의해서 내려준다. -&gt; extends하는 구현체성질 자식들은 주생성자호출 하듯 생성자 정의를 super()로 중복코드를 갖다쓴다 . . 에러 해결할 때, 자식 생성자 내부에 super()를 써서, 부모생성자를 this주생성자처럼 사용하여 -&gt; 상태값 초기화 중복을 해결해라고 한다. | . 중요) protected생성자를 내려주는 추클을 extends를 하는 순간, 생성자 없으면 super()로 생성자도 갖다쓸거다 or 이미 자식에 생성자 있었다면, (내려주는 super생성자 vs 기존 생성자가 [상태값 초기화 부분에서 부딪혀] 빨간줄 나는데) -&gt; this.상태값 = 초기화 ] 대신, [내려주는 생성자super()를 주생성자로 생각]하여, 외부재료를 가공해서 넣어주자라고 생각하자. -&gt; 내려주는 생성자가 부딪힌다면 상태값 초기화 부분이 내려주는 생성자 vs 기존 생성자가 부딪히니 -&gt; 기존 생성자에서 super()를 활용해 초기화하여 해결한다. . 기존 추클이, 새로운 추클을 부모로 extends했다. . | 그 순간부터 **중복코드 메서드 + 중복코드 protecetd생성자를 super()로 내려준다고 생각해야하며 ** . 기존 생성자가 있다면, 내려주는 생성자 vs 기존 생성자가 가장 중요한 역할인[상태값 초기화 부분]에서 부딪힌다. | . | . 암기) 부모가 내려주는 생성자 vs 기존 생성자의 해결은 자식의 생성자 내부에에서 super()를 this()처럼 사용하여 상태값 초기화 역할의 중복을 해결해준다. . 부모의 protected생성자를 super()로 내려주고 있다면, 자식 자체 생성자가 존재하긴 하나 상태값 초기화는 super에게 미룬다. | protected를 통해 호출가능해진 부모가 내려주는 생성자 super()를 자식 자체 생성자 내부에서 서서 | 물려받는 생성자 vs 본인 생성자의 충돌인 상태값 초기화는 super()에 양보하고, 외부에서 재료받아 가공하는 것만 자식생성자에서 해줘서 충돌을 피한다. | . | . 암기) 추클을 받는 기존 추클도 역시, protecetd생성자 정의된 추클을 extends 한다면, 자식으로 자신 생성자 안에서 [스스로 상태값 초기화 하던 부분 this.value= value는 삭제] 하고 -&gt; 부모내려주는 super()로 상태값 초기화 해줘야하는 것은 동일하다. . protected생성자는 추클로서 자식들에게 내려보내는 중인데, 다시 자기가 extends로 추가된 중카=추클에서 protected생성자를 super()로내려받는 꼴이 되었다. . 기존에 자식 생성자들 속에서 protected로 물려주면 호출되는 super()로 상태값 초기화부분만 차지한다 . | 현재 . 그 위에 중카 추클이 또다시 protected로 생성자초기화 부분을 대신하도록 super()로 물려준다 | 추클을 받은 기존추클도 super()로 상태값 초기화해줘야한다 | . . | . | 중요) protected생성자를 내려 받는 자식으로서 super()를 호출해서 상태값 초기화로 바꿔줬다면? 부모 추클이 protected생성자만 가지고 있겠냐? 부모 추클이 상태값도 같이 가져서 자기꺼는 자기가 초기화하겠지 -&gt; 그러면 부모한테 private 상태값도 정의되어 있으며 &lt;그 상태값도 물려받으나 private으로 호출만 못할 뿐이다 -&gt; 그래서 상태값 초기화를 super()에 맡기는 것 . 기존 추클도 내려받아보자. . 스스로 상태값 초기화하는 부분 삭제 . . | protected생성자를 내려 받는 자식으로서 super()를 호출해서 상태값 초기화 . . | . | 암기) protected생성자를 물려받아, super()로 상태값 초기화를 대신한다? -&gt; 부모 추클에서 protected가 초기화해주는 상태값도 private이든 protected든 물려받는다 -&gt; 자식들이 중복코드로서 정의안한다 -&gt; super()로 넘겨서 초기화하는 상태값은 부모에게 물려받는 상태값이니 -&gt; 자식에게 선언될 필요없이 삭제한다. . protected 생성자를 물려받아, 상태값 초기화를 super()에 맡겼다면, 호출가능(protected)하든 호출안되고 숨어있든(private) 상태값도 자연스럽게 같이 내려받으니, 자식에게선 삭제해줘야한다. . . | 애초에 중복코드로서, 추클을 끼워넣어 먹어주려던 대상인 getter메서드도 구현체 중1개가 가지고 있는 중복코드로 간주하여 삭제해준다. . . public abstract class Finished extends Started { protected Finished(final Cards cards) { super(cards); } @Override public final State draw(final Card card) { throw new IllegalStateException(); } @Override public final State stay() { throw new IllegalStateException(); } } . | 50) 중카 추클을 끼워넣어서 중복코드 제거했던 [기존 추클 + 상카 구현체1(Hit) + 상카 구현체2(Stay) ] 중 구현체1,2 들의 중카 자식으로 변환처맇 해보자. . 중요) 추클 자식으로서, 자신의 생성자 내부지만 상태값 초기화를 위해 재료를 super()에 넘긴다?? 그에 해당하는 부모가 내려주는 상태값도 같이 존재하며, 보이지 않지만 그것을 그 내려주는 상태값을 초기화 -&gt; 보통 private으로 선언해서 내려주므로 호출 불가 -&gt; 상태값을 가지고 있었다면 중복코드로서 제거한다 . 기존 인터페이스의 구현체 -&gt; 그 사이에 끼워진 중간카테고리 추상클래스의 자식으로 바꿔주기 . Hit | . . | 생성자 -&gt; 상태값까지 가진 추클을 extends하면 . 자신의 생성자 내부에서 상태값 초기화를 super()에게 맡긴다 | 사실 상태값 초기화 재료가 super()넘어갔다는 말은 보이지 않지만, 상태값도 같이 내려오고 있다 상태값을 가지고 있었다면 중복코드로서 제거한다 | . | . . . | 51) 사실 protected생성자-&gt;super() + 보이지 않는 상태값 -&gt; 기존상태값 중복코드로서 삭제 가 중요한게 아니라 getter인 cards()의 중복제거가 목적이었으며, 그 목적코드를 구현하는데 있어서, 추클에도 상태값-&gt;생성자까지 정의해줘야해서, 물려줄 수 밖에 없었다. . 중복제거 목적 코드 삭제 | 기존에서는 직접 상태값을 선언해서 사용하였으나, 추클 자식으로서 물려받다보니 기존 코드에 깔려있는 호출불가한 상태값 cards는 어떻게 처리할 것인가? 부모 속 private 상태값을 protected로 호출가능하게 풀지말고 유지하되-&gt; 상태값을 응답해주는 getter or 타 메서드()를 호출해서 처리한다 | . | . 대박) 추클의 자식클래스가 물려받아 안보이는 &amp;&amp; private이라 호출불가한 상태값을 호출가능한 곳인 부모에서 상태값 응답(getter) or 변형 상태값을 응답해주는 메서드를 통해, 자식에서 상태값이 필요한 곳에 조달해준다. -&gt; 상태값과 더불어 getter도 같이 물려받아야하며, 네이밍을 상태값()로 정의해서 받으면 -&gt; 자식의 상태값 자리 -&gt;상태값()로 바꿔주면 된다. . 52) 상태값을 부모private을 물려받게 된다면, 기존 상태값을 사용하는 자식내 메서드들은 -&gt; 부모 내에서 호출해서 상태값을 응답해주는 메서 메서드 또한 물려받으면 된다. = 부모내 상태값 응답 getter메서드까지 물려받는다. . 중요) 자식이 부모에게 물려받는 priavate상태값을 자식내부에서 받는 방법은? getter까지 물려받는다 -&gt; 부모내에서, 부모가 가진 private상태값을 응답해주는 메서드를 정의하고 -&gt; 그것을 자식이 물려받아 호출하면 된다. + 상태값이 cards였으면 cards()로서 getter네이밍해서 자식의 cards -&gt; cards()로 바꿔주기 . my +중요) 어차피 상태값 + 생성자가 물려진다면 -&gt; 중복코드가 상태값 or 중복코드가 상태값이 필요한 메서드(추클에 정의해줘야함)라서 어쩔수 없이 상태값+생성자도 물려줌 —&gt; 중복코드가 상태값이 필요메서드라서, 상태값+생성자도 추클에 정의되어 물려준다면 -&gt; 상태값 이름으로 getter도 같이 정의하고 -&gt; 물려지게 해서, 기존 자식들이 쓰던 상태값들을 상태값()의 getter로 대체하게하자 . 부모에게 물려받게 되어, 기존 상태값을 삭제한 상태 . | 부모 속 private 상태값은 물려받더라도 자식내에서 호출할 수가 없다. . 부모내에서 가진 상태값을 응답해주는 메서드를 정의하고 그것을 자식이 물려받아 호출하면 된다. . | 즉, getter까지 같이 물려받는다 . 기존 상태값 호출 cards | 부모에서 물려받는 부모내 상태값 응답 매서드 cards() | . //final Cards currentCards = cards.add(card); final Cards currentCards = cards().add(card); . . | . | Ready도 똑같이 처리해준다. . . . . | 암기+중요) 자식이 주/부 생성자가 있더라도, 부생성자는 받는 재료만 다르지 내부에서는this()로 주생성자에 의존하므로 -&gt; 생성자 물려주는 추클 extends후에는 주생성자만 -&gt; super() 만 바꿔주면 된다. this()를 사용하는 부생성자는, this()에 이미 변경된 주생성자(내부에super())를 이용할 것이기 때문에 그대로 두어도 된다. . . 부생성자는 this()를 쓰고 있어도 바꿔줄 필요없다 -&gt; 그 this()가 주생성자며, super()를 통해 부모물려받는 상태값을 초기화하는 코드로 바껴있을 것이다. . . . 부생성자는 그대로 바뀐 this() 주생성자를 그대로 사용하면 된다. | . | 생성자를 super()를 사용하도록 물려받았다면 -&gt; 상태값도 중복으로 물려받은 것이니, 기존 자체 상태값 삭제 . . . | . 중요) 자식이 이미 자체 상태값을 사용하고 있는 상황이라면 -&gt; 부모야. 상태값 물려받은 후 자체 상태값 삭제할 부분을 대체할 getter 상태값()도 같이 물려줘라를 생각해야한다. . 자식의 자체 상태값을 지워서 나타나는 빨간줄은 부모야 이미 상태값 사용하던 자식들이 있다면, getter메서드도 같이 물려줘라 . . . | . 중요) getter물려주다가 private상태값+protected생성자도 물려줌 -&gt; 구현체 레벨들이 super()를 쓰도록 생성자 재정의 하다가 접근제한자가 바뀔 수도 있다 -&gt; 상태객체는 Ready(public) + 중카 추상클래스(proected)를 제외하고 default생성자를 확인해주자. . my+중요) 상속/추상화 관련 문제에서 생성자 열린상태(접근제한자) 및 재료 확인은 다이어그램으로 하자 . 생성자만 on 시킨 뒤, 추상클래스들 -&gt; 물려줄 생성자가 있다면 노란색좌물쇠의 protected가 맞는지 생성자 물려준다? -&gt; 상태값도 물려준다 -&gt; 자식들이 자기꺼 쓰고 있다면 부모에서 정의한 getter도 물려주기 | . | 중간or최종 상태객체들 -&gt; 검은색 점의 deafult가 맞는지 | 최초 상태객체(Ready) -&gt; pubic 및 상황에 따라 재료없는 생성자(부) + 이후 트리거에 의해 다음 상태갈 수 있도록 재료받는 생성자(주)2개를 가지는지 | . | 다른데서 생성되면 안되고, 상태객체 -&gt; 상태객체의 트리거에 의해서 변해야한다. . | 일단 구현체레벨의 상태객체들 생성자를 재확인해보자 . . bust는 어쩌다보니… public으로 바껴있네 -&gt; default로 생성자 접근제한자 변경 . . public final class Bust extends Finished { Bust(final Cards cards) { super(cards); } } . | Ready는 재료안받고 내부에서 빈재료로 최초 시작하는 생성자 하나만 public . | . | . 53) Stay는 재료없이, stay부터 시작하도록 테스트를 했었었네? 최종상태객체로서 다른카드에서 -&gt; 트리거 -&gt; 메서드 내부에서 재료받아 생성되야하므로 -&gt; 재료받는 것으로 테스트도 수정 . . . public final class Stay extends Finished { Stay(final Cards cards) { super(cards); } } . 중요) 각 상태가 정보를 받아 상태값으로 유지하는 이유? (1) 현재 상태객체 속에서 가진 상태값으로 if 현재상태값.is다음객체인지()를 물어보고 맞으면 new 다음상태객체( 다음상태객체를 만족하는 현재 상태값정보를 가지고 만들어줘야하기 때문에) . my+깨닮음+중요) 생성자에 재료가 없다면 항상 똑같은 new 객체()만 만들 수 있다. 하지만 ` 상태값을 (가공전이라도 괜찮으니) 생성자의 재료로 받게 되면 -&gt; new 동일Type의 새로운 객체( 를 업데이트된 상태값를 재료로` ) 만들 수 있게 되며 . . my+깨닮음+중요) 현재 상태값의 업데이트 by 메서드()에 외부 추가정보가 필요하다면, 메서드(파라미터)를 활용할 수 밖에 없다. 현재 상태값을 사용가능한, this 객체내 메서드내에서, 메서드 파라미터 == 외부 추가정보를 받는 곳을 활용해서 -&gt; 추가 정보를 활용해 상태값 업데이트를 하고 -&gt; 새 객체를 생성해서 응답해주면 된다. . . . my+깨닮음+중요) 만약, 업데이트된 상태값을 가졌어도, 동일Type의 새객체가 아닌 다른Type의 새객체를 생성할 수도 있다 -&gt; 어떤Type이든 해당 정보를 재료로 받는 생성자만 있으면, 상태값업데이트=새객체를 생성할 수 있는 능력을 가지게 된다. -&gt; 동일Type이든, 다른Type이든 해당 상태값을 재료로한 생성자를 가진 객체라면, 상태값 업데이트 로직을 가진 메서드내에서, [if 업데이트된 상태값이, 생성자는 허락된 다른 객체Type으로 갈 수있는 상태값이됬니? ]를 물어본다면, 다른Type객체로 응답되어 [업데이트 객체 생성 메서드 뿐만 아닌 객체변환의 메서드]도 될 수 있다. . draw( 추가정보 card1장)은 if문이 없으면 추가 정보로 업데이트된 new Hit객체 반환 메서드d일 뿐이다. . @Override public State draw(final Card card) { final Cards cards = cards().add(card); return new Hit(cards); } . | **하지만, 업데이트된 상태값에 [if문으로 다른객체가 될 수도 있는 상태값으로 업데이트 됬니?]물어본 뒤, [같은 상태값을 재료로 받는 생성자]를 가진 다른Type의 객체로도 변할 수 있다. ** . if 업데이트된 상태값이 -&gt; 다른객체로 변할수 있는지 물어본다. . | 아니라면, 업데이트된 상태값으로 -&gt; 같은객체의 새객체를 생성하도록 한다. . @Override public State draw(final Card card) { // 4. (+추가정보를 활용해) 업데이트된 상태값으로 -&gt; 새객체를 생성후 응답해주면, 객체 업데이트 메서드가 완성된다. final Cards cards = cards().add(card); if (cards.isBust()) { return new Bust(cards); } return new Hit(cards); } . | | my+깨닮음+중요) 다른Type객체의 new 객체( 현재객체의 상태값 재료 ) 가 보여도, 아~ 업데이트된 상태값으로 -&gt; 비슷한or같은 상태값을 공유하며 - 상태값을 재료를 받아 생성한 객체라서 그 객체로 생성가능하구나. -&gt; if로 물어봐서 다른Type객체 생성후 -&gt; 응답을 통해 외부에서 넘어갈 수 있구나 정도로 생각한다. . 중요+요약) 같은 상태값 + 상태값을 재료로 받는 생성자를 가진 다른 Type 객체는 상대방 상태값 업데이트시 언제든지 넘어갈 수 있다. ( 같은Type의 업데이트 된 새객체 생성은 당연한 것임) . Ready는 같은 상태값을 공유하는 구현체-레벨의 상호교환가능한 여러 상태객체들이 같은 재료(가공전?/직접 상태값)를 받는 생성자를 가진다 -&gt; 같은 상태값을 가지는 객체들로 해석 한 뒤 . if문으로 물어보면서, 같은 상태값 &amp;&amp; 같은 상태값을 재료로 받는 생성자를 가진 객체를 생성하여 응답해서 넘어갈 수 있다. | . . . | . 중요) 중간, 최종상태 객체는 Ready or 다른객체에서 현 객체 내부에서 상태값 업데이트후에 -&gt; if 상태값.is다른거니?() 판단후에 넘갈 수도 있므로 같은 상태값 &amp;&amp; 그 상태값을 재료로 받는 생성자를 가지고 있는 상태여야한다. . 기존 테스트 오류 1 : Cards가 아니라 개별 카드 2장을 받아? -&gt; 지금 통일된 상태값의 재료로 받고 있어! . | 기존 테스트 오류 2: 재료가 없어? 중간상태 or 최종상태객체가? -&gt; Ready빼고는 같은 재료를 생성자로 받아서 넘어갈 수 있는 상태다. . . | . 현재까지 다이어그램 -&gt; 추상화 레벨이 안맞다 . . 현재 Fininshed의 중간카테고리만 있어서 다른쪽과 추상화 레벨이 맞지 않은 상태이다 . . | .",
            "url": "blog.chojaeseong.com/java/pattern/state/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/28/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD%EA%B3%BC-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B43.html",
            "relUrl": "/java/pattern/state/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/28/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD%EA%B3%BC-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B43.html",
            "date": " • Mar 28, 2022"
        }
        
    
  
    
        ,"post95": {
            "title": "의연방06) 환자대조군 연구",
            "content": "R 고급 실습(matched case-control study with dplyr-pipeline, broom-tidy, tableone, survival-clogit) 포함됨 | . &#54617;&#49845;&#44060;&#50836; . &#54617;&#49845;&#47785;&#54364; . Case-control study의 정의를 설명하고, cohort study와의 차이점을 말할 수 있다. . | Case-control study에서 매칭을 수행하는 이유와 주의할 점을 설명할 수 있다. . | Case-control study에서 risk를 추정할 수 없는 이유를 설명할 수 있다. . | Matched case-control study의 데이터를 분석하기 위하여 conditional logistic regression을 수행할 수 있다. . | . &#51452;&#50836;&#50857;&#50612; . Case-control study : 질병을 가지고 있는 환자군(cases)을 먼저 선정하고, 그 질병이 없는 대조군(controls)을 선정하여, 두 그룹 간 과거의 위험요소 노출여부나 특성을 비교하는 연구 | Individual matching : 각각의 case 환자 당 매칭변수 값이 비슷한 control을 찾아 짝을 짓는 매칭방법 | Conditional logistic regression : 매칭된 연구대상자끼리는 독립이 아니고 서로 비슷한 경향이 있다는 점을 반영한 로지스틱 회귀분석 | . Case-control study . &#50672;&#44396; &#46356;&#51088;&#51064; . Observatinal: 익스페리멘탈이 아닌 옵져베이셔널 스터디(관찰연구) 중에서 Retrospective: 후향적 = 현재 시점에서부터 과거의 기록들을 이용하며 Logintidinal: 적어도 2시점 이상을 관찰한다. | . | . | . 구체적으로 보면 . case: 질병을 가진 환자군(=case) 먼저 설정 | control: 질병이 없으면서 &amp;&amp; 환자군(case)과 비슷한 대조군을 그 후 설정 | 각 질병여부O/X(case/control) 그룹별 -&gt; 과거에 위험요소노출 O/X여부(특성O/X여부)를 확인 및 비교한다 cohort와는 반대로 순서로 순서가 정해져있음 | . | | 위험요소와 질병의 상관관계가 있다면? . 코호트(위험요소 그룹별 -&gt; 질병여부 risk, RR, OR)와 달리 질병여부 -&gt; 위험요소 순으로 계산을 해야한다. | 상관관계가 있다면, 질병O(case) 그룹 중 위험요소 노출O 사람이 질병X(control)그룹 중 위험요소 노출O보다 많을 것이다.가 기본 개념이다 | . | . Cohort study&#50752;&#51032; &#48708;&#44368; . cohort study에서는 현재 시점에 위험요소 노출여부가 먼저 결정이 되고 -&gt; 그 이후에 질병이 생기냐/안생기냐를 본다. | case-control에서는 현재 시점에서 질병O인 사람/질병X인 사람을 찾은 뒤-&gt; 과거에 위험요소에 노출이 되었냐/안되었냐를 본다. | &#51109;&#51216; . 저렴하고 빠르다 cohort처럼 질병이 일어날 때까지 계속 FU하면서 기다림, 이 필요가 없다 지금 벌써 질병이 발생한 사람으로 시작 -&gt; 빠르게 연구 수행 가능 | . | rare disease 연구에 적합하다 지금 벌써 질병이 발생한 사람으로 시작 -&gt; 희귀병도 발생할때까지 기다릴 필요 X | . | 발병에 오래 걸리는 질병 연구에 적합하다 지금 벌써 질병이 발생한 사람으로 시작 -&gt; 발병 오래걸리는 병을 기다릴 필요 X | . | . | 여러개의 위험요소를 동시에 연구할 수 있다 . 질병O/X가 먼저고 -&gt; 뒤에 결정되는 (그 이전 기록을 찾아보다가) 여러개 위험요소를 동시에 연구 가능 대신 먼저 지정되는 질병에 대해서는 1개만 관찰 가능 | . | . | 보통 cohort study에 비해 적은 수의 연구대상자가 필요하다 . 코호트는 많은 환자들을 대상으로 시작해야 -&gt; 일부만 질병이 발병함 | 케이스-컨트롤은 애초에 발병된 사람을 잔뜩 확보한 상태로 시작 -&gt; 그나마 적은 수로 가능 | . | 질병에 대해 알려진 것이 없을 때, 위험요소와의 상관관계를 제안하는 초기 단계의 연구로 적합하다 . 위험요소-질병의 상관관계를 알아보고 싶다면, 시간이 오래걸리는 전향적 코호트 연구 이전에, 먼저 질병O인 사람들 먼저 모아놓고 시작하는 케이스-컨트롤 연구부터 시작한다 | case-control study에서 상관관계가 있는 것 같다 -&gt; 다음 단계로 cohort study를 비용+시간 좀 들더라도 진행하는 것이 일반적이다 | . | &#45800;&#51216; . 위험요소 노출과 질병의 선후관계가 불분명할 때가 많다 (선후관계가 불분명하니)인과관계 성립이 어려움 | . | Case-control study에서 얻은 데이터에서는 case와 control의 비율이 연구자에 의해 인위적으로 조정되므로 prevalence에 대한 추론을 할 수 없다 case를 먼저 몇명 모은 뒤 -&gt; control을 계획해서 수가 정해진다. -&gt; case:control의 비율이 연구자에 의해 인위적으로 정해진다 | 질병에 대한 prevalence(발생확률), risk를 추정할 수 없다 | . | bias가 생길 가능성이 아주 높다 bias를 피하기 위해 신중하게 선택해야한다. | . | bias . Case 선택에서 오는 bias: case중 살아남은 사람만 연구에 포함된다. 즉, 발병 후 빠르게 사망한 환자는 연구에 포함되기 어렵다 정말 심각하여 발병후 사망한 환자들은 case를 선택할 때 포함되질 않는다. -&gt; 살아남은 사람만 포함되는 bias | . | 위험요소와 질병 발병(incidence)의 연관성보다는 위험요소와 ‘발병 후 생존’의 연관성을 관측하게 된다 case를 먼저 선택하는 경우, 질병 발생 &amp;&amp; 발병후 생존까지 포함된 개념을 -&gt; 위험요소노출과의 상관관계를 조사하게 된다. | . | . | Control 선택에서 오는 bias: . 최대한 case와 비슷한 사람을 골라야 하는가 vs. 최대한 control 전체를 대표(위험요소 노출 가능성이 관심인구와 비슷한)하는 사람을 골라야 하는가가 control 선택의 관건이다. | 예제) Pearl (1929): 결핵이 암을 예방하는가? . cases : 존스홉킨스병원의 암 사망자(질병O) | controls : 같은 기간 같은 병원의 암환자가 아니었던 사망자(질병X) case와 비슷한 controls를 고른 경우에 해당함 | . | case의 6.6%, control의16.3%가 부검에서 결핵이 발견됨 . 위험요소 노출여부 O/X를 확인함. | controls(질병X)에서 -&gt; 결핵(위험요소 노출여부 X)가 많이 발견됨 결핵(위험요소노출X) -&gt; controls(질병X, 암X)와 상관관계가 있다(결핵이 암예방에 효과있다)고 결론내릴 수 있다.?! | . | . | 당시 결핵이 주요 입원요인이어서, control 그룹의 결핵 prevalence가 general population에 비해 높게 나타남 . case와 비슷한 상황을 맞추다 보니(같은기간, 같은병원), control 전체를 대표하질 못했다. | . | Carlson &amp; Bell (1929): control을 같은 기간 같은 병원의 (암X사망자) -&gt; 심장병 사망자로 설정하여 재분석, 결핵의 비율이 case와 control에서 비슷하게 나타남 my) case와 비슷하게 맞추면서 (같은기간&amp;같은병원), 위험요소 노출 가능성이, 관심인구(전체인구)와 비슷해지도록, general population을 좁히기 위해, 암X사망자 -&gt; 특정 질환 사망자로 특정해주기 병원내 암X 사망자의 결핵 -&gt; general population(병원 밖... 포함)의 결핵과 너무 차이남 | 병원내 &amp; 심장병사망자의 결핵 -&gt; general population자체가 병원내 심장사망자? 중 결핵? | . | . | . | . | Control&#51012; &#49440;&#51221;&#54624; &#46412; &#51648;&#53020;&#50556;&#54624; &#50896;&#52825; . 되도록이면, case와 같은 general population(같은 국가 or 같은 도시or 같은 병원)에서 선정한다 앞의 연구 | . | 위험요소 노출 가능성(=질병의 노출이라면 prevalence)이 general population과 비슷한 그룹으로 선정한다 앞의 연구에서는, general population의 위험요소(결핵) prevalence보다, controls의 prevalence가 훨시 높았다. | . | 관심 질병이 발병할 가능성이 있었으나 발병하지 않은 사람으로 선정한다 예) 자궁암을 연구하면서 남성이나 자궁 적출한 여성을 control로 선정하면 안됨 | 과거에 발병했다가 치료된 사람은 되도록 control에서 제외한다 | . | Information bias . recall bias: case가 control에 비해 과거의 일을 더 잘 기억함 | reporting bias: case가 control에 비해 과거일을 더 잘 보고하거나, 더 잘 누락함 | . Matching . &#51068;&#48152;&#51201;&#51064; case-control &#54644;&#49437;&#44284; Confounding&#51228;&#44144;&#47484; &#50948;&#54620; Matched case-contro study . Case와 control간(질병O/X 그룹별)의 위험요소 노출 비율의 차이를 관측했을 경우, 이것은 위험요소와 질병간의 상관관계를 의미한다 | 이 상관관계는 인과관계인가, confounding에 의한 것인가? 상관관계 확인될 시, 항상 confounding여부를 확인한다 예) 환자군이 대조군에 비해 흡연률이 높지만 my) 일단 case/control 그룹간 -&gt; 위험요소 노출 비율 차이 발생 == 상관관계가 확인된 상태 -&gt; confounding 확인해야 함 | . | 예) 환자군이 대조군에 비해 흡연률이 높지만 소득이 낮을 경우, my) 위험요소 노출 이외에 소득이라는 confounding이 있을 경우 확인해야한다. | . | 예) 환자군이 대조군에 비해 흡연률이 높지만 소득이 낮을 경우, 흡연이 이 질병의 위험을 높이는가, 아니면 저소득으로 인한 다른 요인이 질병의 위험을 높인 것인가? 저소득 -&gt; 흡연이외에 다른 요인들이 질병 위험을 높이는지 vs 흡연에 의해 질병의 발병이 높아지는 것인지 구분해야한다. | confounding(confounder에 의한 효과)를 없애야한다?! | . | . | Confounding(에 의한 효과)을 없애기 위해, confounder로 의심되는 요인의 분포가 환자군과 대조군에서 비슷해지도록 matching을 수행할 수 있다 Matched case-control study my) Matched = confounding(효과)를 제거하기 위해 confounder분포를 case-control 그룹별로 맞춰놓은 것 | . | 주의 : 모든 case-control study가 matching을 하는 것은 아님 항상 그런 것은 아니다! 해석 방법이 다르다 | . | . | &#47588;&#52845;&#51032; &#51333;&#47448; . group matching case를 먼저 선정한 후 -&gt; case에서 매칭변수(=confounder로 의심되는 변수)의 분포를 알아보고 -&gt; 동일한 분포를 가지는 control을 선정한다 my) case 뽑고난 뒤, confounder를 고려해서 control을 뽑는다는 얘기 | 실제론 자주 안쓰임 | . | 예) case에서 저소득이 30%일 경우, control도 저소득이 30%가 되도록 선정 | . | individual matching (matched pairs): 실제로 자주 쓰임 | case군 먼저 선정 -&gt; 각각의 case 환자 1당 매칭변수 값이 비슷한 control(1명)을 찾아 짝을 짓는다 my) 한명씩 confounder를 고려해서 짝지어서 선발 | . | 예) 1번 case의 소득과 비슷한 소득을 가진 1번 control을 선정, 2번 case의 소득과 비슷한 2번 control을 선정... | 같은 동네에 사는 주민, 형제 자매, best friend 등을 control로 선정하기도 한다 1명, 1명이 아니더라도, 여러가지가 비슷한 group이면 한번에 뽑기도 한다. | . | . | &#47588;&#52845;&#51032; &#47928;&#51228; . 매칭변수가 많으면 매칭이 어려움 -( 20개가 confounder면...) 비슷한 control을 찾을 수가 없으므로 | 매칭변수의 효과는 분석 불가 case와 control간 매칭변수의 분포가 같아지므로 (같아놓게만 만들어놓고, 분석에는 사용 안됨) 예를들어, 나이를 매칭변수(=confounder)로 지정했다면, 나이분포는 서로 비슷하다 -&gt; 질병여부에 독립이 되어버림 -&gt; 질병과의 관계를 분석 못하게 됨 | . | . | overmatching (unplanned matching) 매칭변수를 지정했는데, 관계있던 변수들까지도 의도하지 않게 매칭된 경우를 말함. ex&gt; 소득을 매칭변수로 사용했는데, 소득과 비슷한 변수(생활습관, 식생활)까지도 비슷해져버려서 분석이 안됨 | 예) 소득에 대해서 매칭하였더니 생활습관, 식생활 등 다른 변수들까지 비슷해져서 관심 위험요소 분포까지 비슷해짐 | . | 또는, control을 비슷한 best-friend로 지정했는데, case와 비슷한게 너무 많아, 위험요소까지도 의도하지 않게 매칭된 경우를 말함. 예) 경구용 피임약과 자궁암의 관계 연구를 위해 best-friend control을 선정 : 친구끼리는 경구용 피임약 사용여부가 거의 같아서 환자군 대조군 간 경구용 피임약 사용여부가 의도하지 않게 매칭이 됨 | . | . | &#47588;&#52845; &#48708;&#50984; . 전체 연구대상자 수가 고정되어 있는 경우는 controls:cases = 1:1일 때 가장 파워가 높다 파워 높다 = 관측하고자 하는 차이를 detect할 가능성이 가장 높다 | . | Case-control 스터디는 대부분의 경우 case의 수가 고정되어 있고 vs control은 충분히 많다 2:1, 3:1, 4:1까지는 대조군 수를 늘릴 수록 파워가 눈에 띄게 증가한다 | 4:1 이후(5:1부터)로는 파워 증가가 미미하다 적은 case 1명당 -&gt; control은 4명까지만 모아라 | . | . | . RR &amp; OR in case-control study . &#54645;&#49900;: RR&#51008; &#52628;&#51221;&#50504;&#46104;&#51648;&#47564;, OR&#51008; &#52628;&#51221;&#44032;&#45733;&#54616;&#45796;. . Case-control study에서는 RR을 직접 추정할 수 없다. OR은 추정 가능하다 rare-disease의 경우, OR≈RR: 비슷하기 때문에 OR 구하고 -&gt; RR도 그럴 것이다. | . | . RR&#51012; &#52628;&#51221;&#54624; &#49688; &#50630;&#45716; &#51060;&#50976; . case-control study에서는 모집단에서 연구자가 질병O / X의 그룹별 n수를 직접 선택해서... 질병의 prevalence(발생 확률)이 인위적으로 설정되어 -&gt; risk도 인위적인 값일 수 밖에 없다 | . | . 모집단에서의 risk(아직 case 선택 전) 모집단에서는 risk를 계산할 수 있다. ( 위험요소노출여부 그룹별 -&gt; risk 계산 -&gt; risk비율 계산) | 폐암인 사람 100명 / 폐암 아닌 사람 5000명 / RR = 4 | . | 연구자가 뽑은 case -&gt; control . 폐암환자 100명은 모두 다 사용하였다 | 하지만 ,폐암 아닌 사람은 5000명 중 100명만 뽑아서 controls:case = 1:1로 표집하였다 . | controls는 100명으로 줄었지만, 위험요소 노출O/X 비율 1:4는 그대로 유지하여 잘 뽑혔다. . | . | 이제 case-control study에서 risk를 계산해보자. 흡연O 폐암risk: 50/50+20 -&gt; 0.71 흡연한 사람은 폐암발생확률이 71%다 -&gt; 아무도 흡연 안할 것. 너무 높은 위험 | . | 흡연X 폐암risk: 50/50+80 -&gt; 0.38 흡연을 하지 않아도, 폐암발생확률이 38% -&gt; 끔찍한 상황의 높은 위험 | . | controls를 case와 1:1로 표집 -&gt; controls의 n수를 굉장이 낮춰 case의 prevalence가 뻥튀기 -&gt; risk도 뻥튀기된 상황이기 때문 -&gt; risk 추정 불가능 -&gt; RR 추정 불가능 | . | OR&#51012; &#52628;&#51221;&#54624; &#49688; &#51080;&#45716; &#51060;&#50976; . . 모집단 OR = a(oo)d(xx) / bc . | case-control에서의 OR (표 반전 후, ad/bc) . a와 d는 그대로 있고, b와 c만 위치 바꼈다 -&gt; 공식에는 동일하게 ad/bc . . | . | Case-control study OR(unmatched data) . Case-control study에서는 controls(질병X)를 줄여서 1:1~4:1정도만 표집하느라 상대적으로 case그룹(질병O그룹)이 뻥튀기된 상태다 실제 모집단에서의 유병률(prevalence 질병/전체)보다 훨씬 높아진다. | 아래 질병O 컬럼의 숫자들이 실제보다 비율상 커져있게 된다. | risk의 계산 방법인 (위험 요소 노출O row / 위험요소 노출X row)별 -&gt; 가로별 risk(질o/질o+질x)가 의미가 없어진다. | 질병O 칼럼 뻥튀기 -&gt; risk 뻥튀기로 p 계산 불가 -&gt; RR 및 OR(p/1-p 비율) 계산 불가 처럼 보이지만, OR은 ad/bc로 계속 사용할 수있다. 분모분자속 a와 c가 똑같은 비율로 뻥튀기 되어있기 때문이다. | . | . | RR은 직접 추정할 수 없으나 rare disease(레어 디지즈)인 경우에 한해서는 OR과 RR 값이 비슷하다 | 신뢰구간 및 위험요소-질병 상관관계(독립성)검정은 카이제곱 검정 -&gt; cohort study와 동일하다 | confounding과 interaction을 다루기 위해 로지스틱 회귀분석 이용 -&gt; cohort study와 동일하다 | 로지스틱 회귀분석을 이용한 measure 추정은 cohort study -&gt; 연습했던 OR외 risk, odds 추정도 다 가능 | Case-control study -&gt; OR만 추정 가능 | . | Case-control study OR(matched data) . 일단 matching된 환자들끼리는 -&gt; 서로 독립이 아니다를 분석에 반영해야한다. (독립이 아니면) OR 공식이 더이상 성립X | (독립이 아니면) 위험요소 - 질병 상관관계(독립성) 검정을 카이제곱으로 더시아 X 1:1매칭일 때 : McNemar’s test | c:1매칭일 때 : Cochran-Mantel-Haenszel test 3.실제 Adjusted OR 계산, interaction 분석 : conditional logistic regression | . | | . &#45936;&#51060;&#53552; &#44396;&#51312; . 기존 데이터 구조 위험요소 노출(E)요부 row -&gt; 질병 여부(D) col | . | 1:1로 individual matching한 경우 데이터 구조 . 데이터 구조가 바뀌는 이유는, 상관관계의 정보가 없는 = 결과의 차이가 없는 n수를 한눈에 처리하기 위함이다?! | matching되어 짝이 정해진 상황이며 &amp;&amp; 특히 1:1이라면, 1명은 control 1명은 case이므로 my) 칼럼쪽에 있던 질병O/질병X를 row/col으로 나누되, 층을 하나 더줘서 나눴다?! | . | 짝지어진 pair내에서 둘다 exposed O -&gt; n11 | 둘다 Unexposed -&gt; n22 | case만 exposed O -&gt; n12 | controls만 exposed O -&gt; n21 선후관계에서 뒤쪽인 exposed여부에 따라 n을 세어주는 sense | 각 자리에 몇개의 matched된 pair가 들어갔는지 확인할 수 있다. | . | . | n11, n22는 매칭된 쌍들 중, 둘 다 exposed됬거나, 둘다 unexposed 된 것이므로 선후관계에서 결과 뒤쪽인 외험요소 노출 차이를 만들지 못하기 때문에 상관관계에 대한 정보가 없는 카운팅들이다. | . | case와 control간에 위험요소노출여부가 다른 cell만 상관관계에 대한 정보를 준다 . n12 -&gt; case는 위험요소노출 O / control은 X -&gt; n12는 많을 수록, 위험요소는 발병위험을 높인다. | n21 -&gt; case는 X / control은 위험요소 O -&gt; n21는 많을 수록, 위험요소는 발병위험을 높이진 않는다. | | matched Case-Control study에서 OR 계산법 OR = n12/n21 = CaseExposed(O)&amp;ControlExposed(X) / CaseExposed(X)&amp;ControlExposed(O) | 증명 | . | Mantel-Haenszel &#48169;&#48277;&#51004;&#47196; OR&#44396;&#54616;&#45716; &#44163; &#47532;&#48624; . 이전 . confounder가 있을 때, confounder의 값 별로 stratum을 나누고 | 각 stratum(스트레이 텀)마다 OR을 구한뒤 M-H방법으로 합쳤었다. | | 여기선 . 각 matcing pair를 stratum으로 보고, 매칭 쌍마다 OR을 구한 뒤, 합친다 매칭된 쌍이 총 I개 있는 경우 | . | matched case-control용 데이터구조에서 1cell( n ) 마다 -&gt; cohort나 unmathced 의 2by2 table로 변경할 수 있다.??? . 예를 들어, n11(case-exposed &amp; control-exposed) 이라면 -&gt; case-exposed :ai = 1 | control-exposed :bi = 1 | 나머지 ci, di = 0 | . | . | 다하면 아래와 같다고 한다. . | | . my) matched case-control study에서 OR은 데이터 구조가 조금 다르다(위층row-case, col-control 상태에서 아래층에는 위험요소노출여부) | OR계산은 n12/n21 = case-exposed &amp; control-unexposed / case-unexposed &amp; control-exposed my) 앞1:case-exposed / 뒤2:control-unexposed | my) 앞2:case-unexposed / 뒤1:control-exposed | . | | . McNemar&#39;s test: matched case-control&#50640;&#49436; &#50948;&#54744;&#50836;&#49548;-&#51656;&#48337;&#44284;&#51032; &#49345;&#44288;&#44288;&#44228;(&#46021;&#47549;&#49457;) &#44160;&#51221; . 기존 cohort, unmatched case-control study에서는 카이제곱 검정 범주형 변수 2개가 서로 독립인지 확인 | . | matched case-control study 범주형 중 2분형 변수 2개가 있고, 서로 짝지어진 matched 데이터일 때, 연관성 검정 -&gt; 멕니마 검정 | . | . McNemar&#39;s test H0 : 환자군과 대조군 간에 위험요소 노출비율의 차이가 없다 ⇔ 𝑛+1 = 𝑛1+ ⇔ 𝑛21 = 𝑛12 case환자군 위험요소 노출 total = n1+ | control대조군 위험요소 노출 total = n+1 2개가 같아야한다. | n1+ = n11 + n12 / n+1 = n11 + n21 이므로 2개가 같다면 n12 = n21이 같다가 귀무가설 | . | . | H1 : 환자군과 대조군 간에 위험요소 노출비율의 차이가 있다 ⇔ 𝑛+1 ≠ 𝑛1+ ⇔ 𝑛21 ≠ 𝑛12 반대로 n12 = n21이 같지 않다가 대립가설 | . | 검정통계량 : 귀무가설 아래에서 자유도 1인 카이제곱 분포를 따른다 결국에는 n12와 n21의 차이가 얼마나 크냐를 보게 되는 것이며, 분포는 카이제곱 분포를 따른다 -&gt; OR이 1이냐 아니냐로 차이가 얼마가 나는지 본다. | . | . | . &#51652;&#51676; &#44228;&#49328;&#51008; Conditional logistic regression(M-H&#47196; OR, &#47701;&#45768;&#47560; &#44160;&#51221;&#44032; &#50500;&#45772;..) . Conditional logistic regression 1개로 OR 종합 및 검정을 퉁쳐버린다. 모든 것을 한번에 해결(OR 추정, OR이 1인지 아닌지, OR의 신뢰구간) | standard logistic regression에서 딱 1가지만 다르다. 매칭을 분석에 반영해야함. | 매칭된 쌍마다 고유한 상수를 b0대신 ai(상수, intercept)를 넣어준다. 매칭 = 비슷한 경향 = 질병 발생 확률 비슷 = Odds에 로그 취한 것도 비슷 = 비슷하게 만들어주기 위해 상수 더해줌 | ai값 자체는 중요하지 않음.(추정하지 않음) 관심있는 회귀계수만 결국 계산됨. | . | . | . | . . R&#49892;&#49845;(Matched case-control study) . &#45236;&#51109;&#46108; Matched case-control study Data (infert) &#51060;&#50857; . . 연구질문: 인위적으로 임신중절을 했을 경우, secondary infertility에 영향을 미치는가 | case/control 선택 case : secondary infertility | control : 나이, 출산자녀 수, 교육수준으로 매치된 건강한 여성 | 2:1로 매치됨 (83 cases, 83×2-1=165 controls) 1명의 case는 control 1명 밖에 못찾아서 .. -1 | . | . | . head(infert) . educationageparityinducedcasespontaneousstratumpooled.stratum . 0-5yrs | 26 | 6 | 1 | 1 | 2 | 1 | 3 | . 0-5yrs | 42 | 1 | 1 | 1 | 0 | 2 | 1 | . 0-5yrs | 39 | 6 | 2 | 1 | 0 | 3 | 4 | . 0-5yrs | 34 | 4 | 2 | 1 | 0 | 4 | 2 | . 6-11yrs | 35 | 3 | 1 | 1 | 1 | 5 | 32 | . 6-11yrs | 36 | 4 | 2 | 1 | 1 | 6 | 36 | . dat.i &lt;- infert summary(dat.i) # parity: 자녀 수, induced: 중절 횟수, case: secondary infertility여부 # spontaneous: 자연유산 횟수 / stratum: 누가 누구랑 매칭되어있는지를 보기 위한 id(84번부터 control에 해당하며 id1이랑 매칭되어 1) # 관심있는 칼럼: case &lt;- induced . education age parity induced 0-5yrs : 12 Min. :21.00 Min. :1.000 Min. :0.0000 6-11yrs:120 1st Qu.:28.00 1st Qu.:1.000 1st Qu.:0.0000 12+ yrs:116 Median :31.00 Median :2.000 Median :0.0000 Mean :31.50 Mean :2.093 Mean :0.5726 3rd Qu.:35.25 3rd Qu.:3.000 3rd Qu.:1.0000 Max. :44.00 Max. :6.000 Max. :2.0000 case spontaneous stratum pooled.stratum Min. :0.0000 Min. :0.0000 Min. : 1.00 Min. : 1.00 1st Qu.:0.0000 1st Qu.:0.0000 1st Qu.:21.00 1st Qu.:19.00 Median :0.0000 Median :0.0000 Median :42.00 Median :36.00 Mean :0.3347 Mean :0.5766 Mean :41.87 Mean :33.58 3rd Qu.:1.0000 3rd Qu.:1.0000 3rd Qu.:62.25 3rd Qu.:48.25 Max. :1.0000 Max. :2.0000 Max. :83.00 Max. :63.00 . library(dplyr) . Warning message: &#34;package &#39;dplyr&#39; was built under R version 3.6.3&#34; Attaching package: &#39;dplyr&#39; The following objects are masked from &#39;package:stats&#39;: filter, lag The following objects are masked from &#39;package:base&#39;: intersect, setdiff, setequal, union . dat.i2 &lt;- dat.i %&gt;% mutate(induce.ever = ifelse( induced &gt; 0, 1, 0)) head(dat.i2) . educationageparityinducedcasespontaneousstratumpooled.stratuminduce.ever . 0-5yrs | 26 | 6 | 1 | 1 | 2 | 1 | 3 | 1 | . 0-5yrs | 42 | 1 | 1 | 1 | 0 | 2 | 1 | 1 | . 0-5yrs | 39 | 6 | 2 | 1 | 0 | 3 | 4 | 1 | . 0-5yrs | 34 | 4 | 2 | 1 | 0 | 4 | 2 | 1 | . 6-11yrs | 35 | 3 | 1 | 1 | 1 | 5 | 32 | 1 | . 6-11yrs | 36 | 4 | 2 | 1 | 1 | 6 | 36 | 1 | . dat.i2 &lt;- dat.i %&gt;% mutate(induce.ever = ifelse( induced &gt; 0, 1, 0), spontaneous.ever = ifelse( spontaneous &gt; 0, 1, 0)) head(dat.i2) . educationageparityinducedcasespontaneousstratumpooled.stratuminduce.everspontaneous.ever . 0-5yrs | 26 | 6 | 1 | 1 | 2 | 1 | 3 | 1 | 1 | . 0-5yrs | 42 | 1 | 1 | 1 | 0 | 2 | 1 | 1 | 0 | . 0-5yrs | 39 | 6 | 2 | 1 | 0 | 3 | 4 | 1 | 0 | . 0-5yrs | 34 | 4 | 2 | 1 | 0 | 4 | 2 | 1 | 0 | . 6-11yrs | 35 | 3 | 1 | 1 | 1 | 5 | 32 | 1 | 1 | . 6-11yrs | 36 | 4 | 2 | 1 | 1 | 6 | 36 | 1 | 1 | . dat.i2 &lt;- dat.i %&gt;% mutate(induce.ever = ifelse( induced &gt; 0, 1, 0), spontaneous.ever = ifelse( spontaneous &gt; 0, 1, 0)) %&gt;% mutate_at(vars(induced, induce.ever, spontaneous, spontaneous.ever), list(~as.factor(.))) head(dat.i2) . educationageparityinducedcasespontaneousstratumpooled.stratuminduce.everspontaneous.ever . 0-5yrs | 26 | 6 | 1 | 1 | 2 | 1 | 3 | 1 | 1 | . 0-5yrs | 42 | 1 | 1 | 1 | 0 | 2 | 1 | 1 | 0 | . 0-5yrs | 39 | 6 | 2 | 1 | 0 | 3 | 4 | 1 | 0 | . 0-5yrs | 34 | 4 | 2 | 1 | 0 | 4 | 2 | 1 | 0 | . 6-11yrs | 35 | 3 | 1 | 1 | 1 | 5 | 32 | 1 | 1 | . 6-11yrs | 36 | 4 | 2 | 1 | 1 | 6 | 36 | 1 | 1 | . summary(dat.i2) # as.factor() 로 범주형 변수로 만들면, summary시 counting이 잘된다. . education age parity induced case 0-5yrs : 12 Min. :21.00 Min. :1.000 0:143 Min. :0.0000 6-11yrs:120 1st Qu.:28.00 1st Qu.:1.000 1: 68 1st Qu.:0.0000 12+ yrs:116 Median :31.00 Median :2.000 2: 37 Median :0.0000 Mean :31.50 Mean :2.093 Mean :0.3347 3rd Qu.:35.25 3rd Qu.:3.000 3rd Qu.:1.0000 Max. :44.00 Max. :6.000 Max. :1.0000 spontaneous stratum pooled.stratum induce.ever spontaneous.ever 0:141 Min. : 1.00 Min. : 1.00 0:143 0:141 1: 71 1st Qu.:21.00 1st Qu.:19.00 1:105 1:107 2: 36 Median :42.00 Median :36.00 Mean :41.87 Mean :33.58 3rd Qu.:62.25 3rd Qu.:48.25 Max. :83.00 Max. :63.00 . # -&gt; case와 control에 대한 전반적인 비교를 해야한다. # 4-1. descript하게 보기 위해 table을 하나 만들어준다. # -&gt; tableone 라이브러리를 이용함 library(tableone) . tobj &lt;- CreateTableOne(vars = c(&quot;age&quot;, &quot;parity&quot;, &quot;education&quot;, &quot;induced&quot;, &quot;spontaneous&quot;), # 2) strata에 넣은 그룹(case vs control)별로, 보고 싶은 데이터 칼럼 strata = &quot;case&quot;, # 1) case와 control을 범주종류로 나눈 칼럼 data = dat.i2) tobj . Stratified by case 0 1 p test n 165 83 age (mean (SD)) 31.49 (5.25) 31.53 (5.28) 0.956 parity (mean (SD)) 2.08 (1.24) 2.11 (1.28) 0.889 education (%) 0.999 0-5yrs 8 ( 4.8) 4 ( 4.8) 6-11yrs 80 (48.5) 40 (48.2) 12+ yrs 77 (46.7) 39 (47.0) induced (%) 0.964 0 96 (58.2) 47 (56.6) 1 45 (27.3) 23 (27.7) 2 24 (14.5) 13 (15.7) spontaneous (%) &lt;0.001 0 113 (68.5) 28 (33.7) 1 40 (24.2) 31 (37.3) 2 12 ( 7.3) 24 (28.9) . print(tobj, test=F) # p-value를 제외하고 보는 방법: print( , test=F) # 해석 # - 이미 match를 age/aprity/education기준으로 맺어놓은데이터다 -&gt; case와 control에서 분포가 비슷할 것이다. # - induced는 control과 case가 분포가 비슷하다 # - spontaneous는 control과 case가 분포 차이가 난다. # -&gt; 특히, 자연임신중절이 0은, control일 때 훨씬더 많다. # --&gt; 우리의 가설: 인공임신중절(induced)와 case/control여부와 관계있을 것 같았지만,별로 관계없어보이고 # --&gt; 오히려 자연임신중절(spontaneous)과 관련있어 보인다. # --&gt; 그렇다면, spontaneous는 관심변수가 아니였는데, 결과변수에 영향을 주고 있으니, 혹시 관심변수(설명변수)에도 영향을 주고 있는 # --&gt; induced와도 관련있다면, confounder일 것이다. induced와의 관계가 궁금해진다(설명, 결과변수 모두 영향시 confounder) . Stratified by case 0 1 n 165 83 age (mean (SD)) 31.49 (5.25) 31.53 (5.28) parity (mean (SD)) 2.08 (1.24) 2.11 (1.28) education (%) 0-5yrs 8 ( 4.8) 4 ( 4.8) 6-11yrs 80 (48.5) 40 (48.2) 12+ yrs 77 (46.7) 39 (47.0) induced (%) 0 96 (58.2) 47 (56.6) 1 45 (27.3) 23 (27.7) 2 24 (14.5) 13 (15.7) spontaneous (%) 0 113 (68.5) 28 (33.7) 1 40 (24.2) 31 (37.3) 2 12 ( 7.3) 24 (28.9) . tobj2 &lt;- CreateTableOne(vars = c(&quot;induced&quot;), strata = &quot;spontaneous&quot;, data=dat.i2 ) print(tobj2, test=F) # 이산형 vs 이산형의 비교는 한눈에 잘 안보인다. . Stratified by spontaneous 0 1 2 n 141 71 36 induced (%) 0 67 (47.5) 47 (66.2) 29 (80.6) 1 45 (31.9) 16 (22.5) 7 (19.4) 2 29 (20.6) 8 (11.3) 0 ( 0.0) . tobj3 &lt;- CreateTableOne(vars = c(&quot;induce.ever&quot;), strata = &quot;spontaneous.ever&quot;, data=dat.i2 ) print(tobj3, test=F) # factor(범주형) vs 범주형의 비교는 한눈에 잘 보인다. # 그러나, row에 범주형 0,1 로 2개가 있을 경우 1개만 보여주는 경향 -&gt; 다보여주게 옵션 줘야한다. . Stratified by spontaneous.ever 0 1 n 141 107 induce.ever = 1 (%) 74 (52.5) 31 (29.0) . print(tobj3, test=F, showAllLevels=T) # showAllLevels=T # 해석: strata 칼럼의 범주 종류별로 -&gt; row별로 비율의 차이가 있나 본다. # -&gt; starat spontaneous.ever 1 : 한번이라도 자염인신중절 했던 그룹 -&gt; (안했던 그룹(52%)에 비해) 인공임신중절(30%)의 비율이 훨씬 낮다)) # --&gt; confounder는 아닐까 의심하고 연구를 시작한다. # --&gt; 자연임신중절과 인공임신중절은 완전히 독립은 아닐 것이다! 라고 생각해준다. . Stratified by spontaneous.ever level 0 1 n 141 107 induce.ever (%) 0 67 (47.5) 76 (71.0) 1 74 (52.5) 31 (29.0) . # - Conditional logistic regression을 쓰려면 clogit()함수를 써야하는데, base아래 없고, survival패키지를 설치해야한다 # - 또한, 회귀분석 결과물을 정리해서 보여주는 broom패키지도 사용한다 library(survival) library(broom) # clogit(결과변수~독립변수 + strata(매칭id칼럼) , data=) cobj &lt;- clogit(case~induce.ever + strata(stratum), data = dat.i2) summary(cobj) # 해석: induce.ever1일 때의, coef(코에피션트)를 보고 # - exp(coef)를 OR로 생각한다. # - lower .95 upper .95가 OR의 신뢰구간인지 확신할 수 없기 때문에, broom패키지의 tidy( ,exponentiate=T, conf.int=T)함수에 넣어주고 다시 보자. . Call: coxph(formula = Surv(rep(1, 248L), case) ~ induce.ever + strata(stratum), data = dat.i2, method = &#34;exact&#34;) n= 248, number of events= 83 coef exp(coef) se(coef) z Pr(&gt;|z|) induce.ever1 0.08972 1.09387 0.29913 0.3 0.764 exp(coef) exp(-coef) lower .95 upper .95 induce.ever1 1.094 0.9142 0.6086 1.966 Concordance= 0.509 (se = 0.04 ) Likelihood ratio test= 0.09 on 1 df, p=0.8 Wald test = 0.09 on 1 df, p=0.8 Score (logrank) test = 0.09 on 1 df, p=0.8 . . tidy(cobj, exponentiate = T, conf.int = T) # estimate : OR # p.value # conf.low conf.high # 해석: induce.ever1(인공임신중절)이, case(1)질병과 아무 관계가 없는 것 같이 보인다 # -&gt; p-value 0.76423 로 독립이라서, 독립변수 - 결과변수 상관관계 X? # --&gt; 하지만, 독립변수와 비슷해보이는 [자연임신중절]을 confounder로 의심할 수 있었다. . termestimatestd.errorstatisticp.valueconf.lowconf.high . induce.ever1 | 1.093866 | 0.2991307 | 0.2999307 | 0.76423 | 0.6086165 | 1.966006 | . # -&gt; 컨디션 로지스틱회귀에 공변량으로 추가한다. cobj2 &lt;- clogit(case~induce.ever + spontaneous.ever + strata(stratum), data = dat.i2) summary(cobj2) # 해석1) # + spontaneous.ever만 추가했을 뿐인데, # 1) summary()에서 induce.ever1 까지 p-value가 유의해졌다 -&gt; H1:독립X 상관관계 있는 것으로 나온다. # coef exp(coef) se(coef) z Pr(&gt;|z|) # induce.ever1 1.0926 2.9821 0.4058 2.693 0.00709 ** # spontaneous.ever1 2.1344 8.4522 0.4050 5.270 1.36e-07 *** . Call: coxph(formula = Surv(rep(1, 248L), case) ~ induce.ever + spontaneous.ever + strata(stratum), data = dat.i2, method = &#34;exact&#34;) n= 248, number of events= 83 coef exp(coef) se(coef) z Pr(&gt;|z|) induce.ever1 1.0926 2.9821 0.4058 2.693 0.00709 ** spontaneous.ever1 2.1344 8.4522 0.4050 5.270 1.36e-07 *** Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 exp(coef) exp(-coef) lower .95 upper .95 induce.ever1 2.982 0.3353 1.346 6.606 spontaneous.ever1 8.452 0.1183 3.821 18.695 Concordance= 0.73 (se = 0.045 ) Likelihood ratio test= 37.82 on 2 df, p=6e-09 Wald test = 27.82 on 2 df, p=9e-07 Score (logrank) test = 35.79 on 2 df, p=2e-08 . tidy(cobj2, exponentiate = T, conf.int = T) # induce.ever1의 OR이 3에 가까워졌다(1이면 차이X), p-value도 낮아서 유의하다 # -&gt; [자연임신중절]을 포함시키고 &amp; 고정해놓으면 # --&gt; 관련없어 보이던 [인공임신중절]이 [secondary infertility]와 통계적으로 유의한 관계가 있어진다. . termestimatestd.errorstatisticp.valueconf.lowconf.high . induce.ever1 | 2.982126 | 0.4058008 | 2.692544 | 7.090920e-03 | 1.346194 | 6.606085 | . spontaneous.ever1 | 8.452174 | 0.4050196 | 5.269927 | 1.364777e-07 | 3.821335 | 18.694839 | . Case-control study &#45436;&#47928; &#50696;&#51228; . 코호트 스터디 가기 전 단계 | 많은 증거가 없는 상황에서 시행되므로 high impact 저널에 출판되긴 힘들다. | . . . 연구질문 : Sigmoidoscopy(S형 결장내시경)을 이용한 screening이 대장암으로 인한 사망을 줄이는가? 만약, 위험요소 -&gt; 질병의 코호트 or RCT로 분석하면, 대장암이 발병할때까지 기다려야하므로 사실상 무리 질병 -&gt; 위험요소 노출여부 순으로 분석하는 후향적, Case-Control Study | . | . | 연구대상: Kaiser라는 의료보험 든 사람 이렇게 결정한 이유: 위험요소(S형 결장내시경)에 대한 접근이 같아지기 때문 소득 수준 등의 차이가 없어진다. | . | . case : 1971~1987년 사이에 대장암을 진단 받고 1988년 이전에 암으로 사망한 환자 | control : 매칭하여 각 case마다 성별이 같고 /나이와 보험 가입일이 비슷한 (＜1년) / 생존자/ 1~4명까지 | | . 통계분석 방법 case, contorl정했으면, 위험요소 노출여부를 언제까지 볼 것인가? 생존자료분석이 아니라면, 같은 기간을 보면 된다.(관측기간을 공평하게) | . | 매칭 case-control study라서 -&gt; conditional logistic regression을 이용해 OR 등을 구했다. adjusted analyses: confounder를 포함한 다변량 모델을 돌렸다 | . | adjustment는 자기들이 생각한 confounding factors들에 의해 이루어졌다. 그것들을 나열해놓음 | . | . case와 control별, 얼마나 Sigmoidoscopy(위험요소)에 노출되었는지를 디스크립트하게 나타낸 것 한번도 안받은 사람 / 한번 받은 사람 / 2번이상 받은 사람 | 아무래도 case가 (control에 비해) 위험요소?노출 0회(내시경을 한번도 안받은 사람)의 비율 더 많다 다른 검사도, case에 비해 control이 위험요소노출 0회 = 다른 검사를 안받은 비율이 더 높다. | . | . | . 핵심 테이블 질병, 대장암의 OR를 계산 한 것이 아니라 | S형 내시경을 받을 Odds를 계산 -&gt; case와 control간 ratio(비율)이 달랐는지? OR를 계산했다. exposed와 disease를 swtih한 OR^*에 해당하는 값이다. | 원래 생각하던 OR과 값이 같으니 해석도 -&gt; 대장암의 OR로 해석하면 된다. 대장암뿐만 아니라, 내시경확인불가 cancer를 포함하여 나눠서 계산했다 | OR이 1보다 작다 -&gt; 대장암 환자일수록 -&gt; 내시경을 전에 받았을 OR가 더 낫다 | 반대로 내시경을 전에 더 많이 받았을 수록 -&gt; 대장암일 OR가 더 낫다 | . | . | . | . &#51221;&#47532;&#54616;&#44592; . Case-control study는 질병을 가지고 있는 환자군(cases)을 먼저 선정하고, 그 질병이 없는 대조군(controls)을 선정하여, 두 그룹 간 과거의 위험요소 노출여부나 특성을 비교하는 연구이다 | Case-control study에서는 RR은 직접 추정할 수 없으나, OR은 추정 가능하다 | 매칭하지 않은 case-control study의 OR 추정방법과 confounding, interaction을 다루는 방법은 cohort study와 거의 같다 | Matched case-control study의 OR 추정은 M-H 방법이나 conditional logistic regression을 이용한다 | . &#50672;&#49845;&#47928;&#51228; . &#45796;&#51020; &#51473; case-control study&#50640; &#45824;&#54620; &#49444;&#47749;&#51004;&#47196; &#51201;&#51208;&#54616;&#51648; &#50506;&#51008; &#44163;&#51008;? . 관찰연구의 일종이다. 실험연구 아니면 다 관찰연구 | . | 여러개의 질병을 동시에 연구할 수 없다. 질병 먼저 -&gt; 뒤쪽에 시간들여서 찾는 위험요소노출이 여러개일 수 있다. 질병은 1개 | . | 희귀병이나, 위험요소 노출부터 질병 발병까지의 기간이 너무 긴 질병의 연구에 적합하다. 오래기다려야하는 병들을 미리 찍어서 과거를 보러 간다 | . | prevalence에 대한 추론이 가능하다. 연구자가 case 정하고 -&gt; control을 그에 맞춰 1~4명까지 정한다 -&gt; 모집단과는 전혀다르게 prevalence가 뻥튀기 된다. | . | 정답: 4 | 해설: Case-control study에서는 case와 control의 비율이 연구자에 의해 인위적으로 조정되므로, prevalence에 대한 추론을 할 수 없다. | . &#45796;&#51020;&#51008; &#50612;&#46500; case-control study&#50640;&#49436; &#55137;&#50672;&#44284; CHD&#51032; &#44288;&#44228;&#47484; &#50508;&#50500;&#48372;&#44592; &#50948;&#54644;, &#55137;&#50672;&#51088; 100&#47749;, &#48708;&#55137;&#50672;&#51088; 100&#47749;&#51012; 1:1&#47196; individual matching&#54616;&#50668; &#55137;&#50672;&#50668;&#48512;&#47484; &#51312;&#49324;&#54620; &#45936;&#51060;&#53552;&#51060;&#45796;. . . &#45236; &#54400;&#51060; . 주어진 데이터 자료구조를 보고 cohort study orunmatched case-control study 문제인지 | matched case-conrol study 문제 인지 판단한다 | | matched case-conrol study문제의 OR은 n12/n21로 구한다 n12 = case(앞) exposed(1) / control(뒤) unexposed(2) | n21 = case(앞) unexposed(2) / control(뒤) exposed(1) | 50/10 = 5.0 | . |",
            "url": "blog.chojaeseong.com/r/r%EA%B3%A0%EA%B8%89/dplyr/broom/tidy/tableone/survival/clogit/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%ED%99%98%EC%9E%90%EB%8C%80%EC%A1%B0%EA%B5%B0/2022/03/27/%EC%9D%98%EC%97%B0%EB%B0%A906)-Case-control-Study.html",
            "relUrl": "/r/r%EA%B3%A0%EA%B8%89/dplyr/broom/tidy/tableone/survival/clogit/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%ED%99%98%EC%9E%90%EB%8C%80%EC%A1%B0%EA%B5%B0/2022/03/27/%EC%9D%98%EC%97%B0%EB%B0%A906)-Case-control-Study.html",
            "date": " • Mar 27, 2022"
        }
        
    
  
    
        ,"post96": {
            "title": "함수형인터페이스 만들어 로직넘기기",
            "content": "문제 상황 . 어떤 객체 로직이 [타 객체.행위() 성공여부]에 따라 갈린다면, 응답값을 억지로 받지말고 -&gt; [타 객체 context] 내부로 넘기자 . public final class Board { private void movePiece(final Position beforePosition, final Position afterPosition) { Piece beforePiece = this.value.get(beforePosition); beforePiece.move(beforePosition, afterPosition); // .move()의 결과에 따라 실행/안실행되는 -&gt; piece내부로 넘겨주고 싶은 Board 로직 this.value.put(afterPosition, beforePiece); this.value.put(beforePosition, new NullPiece(null)); } . Board의 this.value(map)에 pu하는 로직을 **타 객체인 beforePiece.move( , )의 성공여부에 따라 실행시키고 싶다 ** | 그러려면 beforePiece.move( , )의 성공여부를 .move()의 응답값을 받아와 if 그 결과에 따라 실행시켜야한다. | 특정 로직의 결과에 따라 움직인다면, 결과를 응답받지말고, 그 객체 text에 함형으로 넘겨주자 | . | . 예시1: thr가능성있는 타객체.메세지() 이후의 로직들을 타객체메세지보낼때 같이 보내기 . 01 넘기고 싶은 로직을 () -&gt; {}; 람다를 이용하여 함형을 만든다. . 일단 넘기고 싶은 로직을 {}아웃풋 자리에 넣고 람다식()-&gt;{};을 만든다. . () -&gt; { this.value.put(afterPosition, beforePiece); this.value.put(beforePosition, new NullPiece(null)); } . | 02 타 객체가 내부에 사용됬다면, 람다식의 (input) -&gt; {};으로 받아 -&gt; 함형.메서드( this );로 사용되도록 해야한다. . . . beforePiece.move(, )에 넘겨줄 예정이므로 piece를 함형 람다의 input으로 지정해주고, 고치자 . private void movePiece(final Position beforePosition, final Position afterPosition) { Piece beforePiece = this.value.get(beforePosition); beforePiece.move(beforePosition, afterPosition); (piece) -&gt; { this.value.put(afterPosition, piece); this.value.put(beforePosition, new NullPiece(null)); }; } . | 03 람다식의 input이 정해지면, [변수추출]로 함형종류 + inputType을 지정해준다 -&gt; 변수추출하면 메서드 추출도 응답값 지정이 잘됨. . . 함형의 inputType에는 넘겨받을 타 객체Piece로 정해줘야한다. . private void movePiece(final Position beforePosition, final Position afterPosition) { Piece beforePiece = this.value.get(beforePosition); beforePiece.move(beforePosition, afterPosition); final Consumer&lt;Piece&gt; function = (piece) -&gt; { this.value.put(afterPosition, piece); this.value.put(beforePosition, new NullPiece(null)); }; } . | 04 타 객체의 메서드(인자)로 넘겨주기 위해, 함형의 = 제외한 우항만 메서드 추출 . 추출할 메서드의 응답Type -&gt; 타객체. 메서드( 인자로 들어갈 Type )이 될 것이니 응답값이 함수형 인터페이스가 되도록 = 우항만 메서드 추출해준다. 만약, 변수추출 안했다면 추론이 안되서 함형을 응답값으로 못빼주더라 | =를 포함시켜서 추출하면 추출안됨. | =제외시키고 함형 메서드추출하면 잘된다. | . | . =을 제외하고 우항만 메서드 추출해서, 응답값이 함수형 인터페이스로 잘 뽑히는지 확인한다. . private void movePiece(final Position beforePosition, final Position afterPosition) { Piece beforePiece = this.value.get(beforePosition); beforePiece.move(beforePosition, afterPosition); final Consumer&lt;Piece&gt; function = getMoveConsumer(beforePosition, afterPosition); } private Consumer&lt;Piece&gt; getMoveConsumer(final Position beforePosition, final Position afterPosition) { return (piece) -&gt; { this.value.put(afterPosition, piece); this.value.put(beforePosition, new NullPiece(null)); }; } . | 05 추출한 로직의 함형을, 타객체 메서드에 건네줘서 -&gt; 내부에서 this를 사용해 실행되도록 옮긴다. . . . private void movePiece(final Position beforePosition, final Position afterPosition) { Piece beforePiece = this.value.get(beforePosition); beforePiece.move(beforePosition, afterPosition, getMoveConsumer(beforePosition, afterPosition)); } . 06 함형으로 로직을 넘겨받은 타 객체는 내부에서 (this)를 인자로 주고 호출한다 . . @Override public void move(Position beforePosition, Position afterPosition, Consumer&lt;Piece&gt; moveFunction) { if (!canMove(beforePosition, afterPosition)) { throw new IllegalArgumentException(NOT_MOVABLE_POSITION); } moveFunction.accept(this); } . 예시2: 아래쪽 분기별 OutputView 로직이 도메인 샌드위치 사이에 위치한 경우 -&gt; Runnable?객체면 Consumer?로 위쪽 도메인 메서드 인자에 함형메서드로 쏴서 넘겨주기 . 문제상황 . public void run() { OutputView.printStartMessage(); while (gameSwitch.isOn()) { //도메인로직 final String command = InputView.inputCommand(); final GameCommand gameCommand = GameCommand.from(command); gameCommand.execute(command, this); //view로직 ( State에 따라서 출력 ) printBoardInfo(); //도메인로직2 (샌드위치유발) -&gt; 특정상태인 경우, 다시 돌려주는 로직 if (state.isStatus()) { state = state.toRunningState(); } } } private void printBoardAndBeRunningIfStatus() { if (isReadyOrRunning()) { OutputView.printBoard(getBoard()); } if (isStatusInRunning()) { OutputView.printStatus(calculateStatus()); } if (isFinishedAndGameEnd()) { OutputView.printFinalStatus(calculateStatus()); } } . 01 view로직을 도메인 메서드 안에서 출력시키고 싶은데, view 사용 == view를 알면 안된다. -&gt; view는 알면 안되지만, 함수형 인터페이스는 알아도 된다 -&gt; view로직 전체 -&gt; 람다를 통한 함형 -&gt; 메서드추출후 응답에 함형 . private Runnable printBoardInfo() { return () -&gt; { if (isReadyOrRunning()) { OutputView.printBoard(getBoard()); } if (isStatusInRunning()) { OutputView.printStatus(calculateStatus()); } if (isFinishedAndGameEnd()) { OutputView.printFinalStatus(calculateStatus()); } }; } . 02 도메인메서드의 인자에 함형 응답 메서드호출로 인한 함형인자를 추가하기 . public void run() { OutputView.printStartMessage(); while (gameSwitch.isOn()) { final String command = InputView.inputCommand(); final GameCommand gameCommand = GameCommand.from(command); gameCommand.execute(command, this, printBoardInfo()); //도메인로직2 (샌드위치유발) -&gt; 특정상태인 경우, 다시 돌려주는 로직 if (state.isStatus()) { state = state.toRunningState(); } } } . 03 view로직을 함형으로 넘겨받은 도메인 메서드에서는 함형.메서드()로 가동시키기 . 함형으로 넘겨서 실행만 시키면 도메인은 view를 모르고 view로직이 담겨 실행직전인 함수형인터페이스만 알아도 된다. | . . public final class Status implements CommandStrategy { @Override public void execute(final String command, final ChessGame chessGame, final Runnable runnable) { chessGame.status(); runnable.run(); } } . 04 샌드위치를 만들던 도메인로직2도 해당분기에 맞게 도메인 내부로 옮겨준다. . . public final class Status implements CommandStrategy { @Override public void execute(final String command, final ChessGame chessGame, final Runnable runnable) { chessGame.status(); runnable.run(); // if (state.isStatus()) { // state = state.toRunningState(); // } chessGame.start(); } } . [람다식을 통한 함형]이 유용할 경우 3가지 . list.sort( ) 속 [Comparator]의 역정렬 + thenComparing 2개이상 정렬 . // 1 inventory.sort(Comparator.comparing(Apple::getWeight) .reversed()); // 역으로 정렬 // 2 inventory.sort(Comparator.comparing(Apple::getWeight) .reversed() // 역으로 정렬 .thenComparing(Apple::getCountry)); // 두 사과의 무게가 같으면 국가별로 정렬 . 참고) 그냥 Comparable안에서 2개 정렬 . @Override public int compareTo(Position o) { return Comparator.comparing(Position::getRow, Comparator.reverseOrder()) .thenComparing(Position::getColumn) .compare(this, o); } . Predicate 1개에 .negate() 반전 이외에 .and( 람다 ) .or( 람다 )로 연쇄할 경우 . Predicate&lt;Apple&gt; notRedApple = redApple.negate(); // 결과를 반전 Predicate&lt;Apple&gt; redAndHeavyApple = redApple .and(apple -&gt; apple.getWeight() &gt; 150); Predicate&lt;Apple&gt; redAndHeavyApple = redApple .or(apple -&gt; apple.getWeight() &gt; 150); Predicate&lt;Apple&gt; redAndHeavyAndGreenApple = redApple .and(apple -&gt; apple.getWeight() &gt; 150) .or(apple -&gt; GREEN.equals(apple.getColor())); // 빨간 사과 중 무게가 150 넘는 사과 혹은 초록 사과 (오른쪽 연결) . 수식용 Function 들을 여러개 만들어놓고 .andThen( ) or .compose( )로 조합 . compose( )는 뒤에 람다부터 계산 | . Function&lt;Integer, Integer&gt; plus10 = (number) -&gt; number + 10; Function&lt;Integer, Integer&gt; multiply3 = (number) -&gt; number * 3; Function&lt;Integer, Integer&gt; multiply3AndPlus10 = plus10.compose(multiply3); System.out.println(multiply3AndPlus10.apply(4)); // 결과 22 Function&lt;Integer, Integer&gt; plus10AndMultiply3 = plus10.andThen(multiply3); System.out.println(plus10AndMultiply3.apply(4); // 결과 42 .",
            "url": "blog.chojaeseong.com/java/lambda/%ED%95%A8%EC%88%98%ED%98%95%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/comparator/predicate/consumer/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/27/%EB%9E%8C%EB%8B%A4%EB%A1%9C-%EB%A7%8C%EB%93%A0-%ED%95%A8%ED%98%95(%EB%A1%9C%EC%A7%81-%EB%84%98%EA%B8%B0%EA%B8%B0,-%EC%9C%A0%EC%9A%A9%ED%8C%A8%ED%84%B4).html",
            "relUrl": "/java/lambda/%ED%95%A8%EC%88%98%ED%98%95%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/comparator/predicate/consumer/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/27/%EB%9E%8C%EB%8B%A4%EB%A1%9C-%EB%A7%8C%EB%93%A0-%ED%95%A8%ED%98%95(%EB%A1%9C%EC%A7%81-%EB%84%98%EA%B8%B0%EA%B8%B0,-%EC%9C%A0%EC%9A%A9%ED%8C%A8%ED%84%B4).html",
            "date": " • Mar 27, 2022"
        }
        
    
  
    
        ,"post97": {
            "title": "강의) 네오 3단계 블랙잭 피드백(2/4)",
            "content": "도메인이 쌓이고 난 후 이름 리팩토링 . Game(서비스같은)Test로 Game.메서드들 테스트 -&gt; 구체적으로 클래스명 정하기 . 현재 Game.start() 이후 응답되는 상태 객체 state의 .draw()들만 테스트하고 있다. Game에서 카드 2장받아 start를 하면 -&gt; state를 반환한다? | . | Game대신… 상태패턴의 state가 시작되기 전을 의미하는 Ready의 준비를 .start( 카드1,카드2)받는 식은 어떨까? Ready가 start하면 state를 응답해준다? | . | . 26) Game.start() -&gt; Ready.start()로 이름 리팩토링 . 이름 리팩토링은 해당 파일로 가서 class명을 붙잡고 F2 -&gt; RenameTest도 같이 바꾸도록 select All선택 후 Okay해줘야 바뀐다. 클래스명 클릭 -&gt; F2 -&gt; RenameTest 에서 alt +a후 tab 2번 한 뒤 okay enter | . | . . 중요) 상태변화패턴이 시작되는 [최초 state가 나오기 전 상태]로서 Ready라는 이름으로 시작 -&gt; 이것 역시 State의 카테고리인 상태객체로 바꿔보기 . 27) Ready도 스태틱 로직메서드를 위한 class가 아니라 State로 만들어보자 . 상카(추상체) 구현을 시작으로 카테고라이징 된다. . 현 class상태에서 State를 구현하여 카테고라이징 . . impl해야하는 메소드를 가장 위로 올려, State임을 나타내주자 | . | [잘못설계] Ready 상태는 start(card1, card2)를 활용하여 Hit or Black상태임을 상태값으로 가지고 있다? . Hit, bust 등 처럼, 이전 정보cards + 추가정보card로 정보 업데이트후 -&gt; 업데이트된 정보로 객체 생성을 위해 상태값형태로 cards를 가지고 있었다. | Ready의 경우, 재료인 card1, card2가 들어와서처음 초기화되어 시작되며, cards정보를 통한 업데이트된 Ready를 만들 일 없이 한번 만들어지고 끝이다? 다른 State처럼 cards를 받는게 아니다? | 그러면 State와 동일한 상태객체일까? 고민이 된다. | . | . Ready는 어떻게 되었든 card1, card2를 재료로 받아 가공되어 내부에 가지는 상태값을 가지게 될 것이다. . . | 기존 메서드를 보니 재료를 받았지만, 가공은 State로 될 가능성이 높다. . 재료 가공을 State로 해서 상태값으로 가지고 있자 . | 복사해놓고 활용하면 더 쉬울 듯 . 생성자는 재료를 받아서 this.상태값=을 초기화해줘야하는 의무를 가진다. 그 상태값은 메서드로 치면 State들이다. . . . | . | . | 문제점: 아직 state로 가기전의 상태인데, 초기화로 Hit 나 Blackjack상태를 가지게 된다. -&gt; 메소드의 역할만 하고 있고 상태객체가 아니게 된다. . 중요) Ready라는 시작 상태는 고유하며, 생성시 아무재료(정보)도 없이 시작되며 -&gt; draw트리거메서드에 의해 바뀔 수 있다. . Ready는 생성시 Card1, card1를 받는게 아니라 재료가 없는 빈 생성자로 시작해야한다. 1장 씩 draw하면서 아직 ready인지 물어보고 | 2장을 draw했을 때, hit or blackjack 상태로 바껴야한다. by draw메서드에 의해 | . | . my) 인페를 상카로 뽑아 카테고라이징 했다면, 구현체의 단독 상태, 메서드 개발은 자유롭다 -&gt; 규칙에 맞는 메서드만 오버라이딩해서 개별구현하면 된다. . 중요) 시작 State도 마찬가지로 다른 구현체(상태)로 넘어갈지 판단에 필요한 정보 cards를 상태값으로 가진다 -&gt; 재료로 받진 않지만, 추가정보를 받아서 채우면서 판단 -&gt; 상태값인 cards의 갯수에 따라 현재상태인지 -&gt; 다른 상태로 넘어가야할지 판단할 수 있다. . 28) 재료없이 생성되는 객체라도 -&gt; 내부에서 빈 재료로 초기화하는 상태값을 가질 수 있다. . 참고) 일급을 빈재료로 넣어야할 때 -&gt; this.value = new 일급();으로 일급생성자에 재료를 빼고 넣어주고 -&gt; 일급으로 가서 [재료받는 것을 주생성자this]로 하여 -&gt; 재료없이 내부 빈재료로 초기화하는 부생성자를 추가 생성해줘야한다. . Ready의 재료없이 내부 빈재료로로 상태값을 만드는 생성자를 먼저 선언하고 -&gt; 상태값도 만들어주자. . | 이 때, 필요한 재료는 안받아오지만, 필요한 내부 빈 재료가 빈 일급컬렉션이다… . . . | 일급컬렉션에 재료받아 생성되는 주생성자를 this로 활용하여 그 위에 재료없는 부생성자를 추가로 만들어주자. . 상태값 및 재료가 원래 있던 놈들인데 없는 부생성자 만들시 -&gt; Select None으로 생성하면 된다. . | new ArraysList&lt;&gt;()로 빈 재료를 넣어주면 된다. . public final class Cards { private final List&lt;Card&gt; value; public Cards() { this(new ArrayList&lt;&gt;()); } . | . | draw는 아직 처리안되어있으니 return null로 State를 응답해주자. . | 29) Ready도 draw(card)를 한다. . 내부 일급상태값.add()는 보이기에만 add시 기존 상태값+업데이트정보로 -&gt; 업데이트 상태값으로 새 일급을 반환해주는 업데이트 일급 응답함수다. 이 업데이트된 일급으로 다음 상태를 판단한다. . 업데이트된 상태값으로 새 일급 반환받기 . @Override public State draw(final Card card) { //1. 다른 상태에서의 draw처럼 (1) 현재 정보들 + (2) 추가 정보를 가지고 내부업데이트해서 불변 새일급을 반환받는다. final Cards currentCards = this.cards.add(card); return null; } . | 업데이트된 상태값으로 -&gt; 일급이니 메세지를 보내서 다음 객체를 판단한다 . | 30) Ready가 가능한 상태를 생각해본다 -&gt; 1장씩 받으니 Ready 그대로 or 2장 다받으면 Hit or Blackjack -&gt; 업데이트된 상태값으로 isReady()로 물어봐야한다. . . . . 아직 카드갯수가 2보다 작은 1개 상태의 ready상태라면, 업데이트 된 상태값으로 -&gt; new 상태객체(상태값)를 만들어 응답해주자. . . | 참고) 늦게 생성됬어도 재료받는 생성자가 주생성자라는 개념을 가지고 가자 -&gt; 기존의 재료없는 생성자는 this를 활용해서 부생성자로서 재정의 해줘야한다. . 아직 재료없이 생성되는 Ready 생성자만 정의된 상태이니 생성자도 만들어줘야한다. . **재료를 받게 되는 순간부터 늦게 생성됬어도 재료받는 생성자가 주생성자라는 개념을 가지고 가자 ** | . . | 참고) 부생성자에서 주생성자 활용하여 정의: 기존 = 우항; 코드들을 복사하고 this()내부로 복붙한 다음, 가공해서 주생성자의 파라미터에 맞춰주면 된다. . 재료받은 주생성자가 생겼지만, 이놈은 외부에서는 호출안될 것 같으니 private으로 처리해주고 부생성자를 this로 다시 정의해주자 . . . . | . 리팩토링과 함께 . 상태로서의 Ready를 Test하기 . 기존 테스트들이 Ready.start( card1, card2)로 많이 만들어졌기 때문에 일단은 살려둔 상태다. . . 31) 상태로서의 Ready 테스트하기 . 기존에 카드 2장을 받아서, 상태를 만들어주는 정적메서드의 주체자 Ready였다. . public class ReadyTest { @Test void hit() { // given &amp; when : hit final State state = Ready.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK)); // then assertThat(state).isInstanceOf(Hit.class); } . | 참고) 코드 수정이나 개발은 기존 코드보다 위에, 기존코드를 복붙해놓고 새 기준 코드를 작성한다 . 2장 받아 상태반환 메서드 -&gt; 재료없이 최초 상태로서 출발하는 상태객체의 코드로 변경하려면 기존코드를 남겨두고, 위쪽에 복붙해서 수정한다. . . | 중요) 최초 시작상태 객체는 재료를 안받고 생성되며, 상태 변환 트리거 메서드를 호출하면서 다른 구현체 상태객체가 되는 조건까지 재료없이 내부 빈 재료로 초기화시켜 만든 상태값을 통해 확인하면서 진행하면 된다. . Ready(Class)로 시작하는 .start() 메서드호출 대신 직접 재료 없이 생성하여 최초 상태가 시작된다. . 과정 . . | . | 중요) 상태객체.트리거메서드()는 경우의 수 구현체를 다 받을 수 있는 추상체를 응답하므로 -&gt; 계속 체이닝으로 해서 호출이 가능하다. . 상태변화 트리거인 draw()를 호출하면서 내부에서 확인하면서 다른 상태로 간다. . 2번 draw()가 될때까지 내부에서 확인한다 | 상태변화 트리거 메서드는 추상체로 응답을 하는 덕분에, 체이닝으로 여러번 호출이 가능하다. | . @Test void readyHit() { // given &amp; when : ready -&gt; 2 -&gt; ready -&gt; 10 -&gt; 2장뽑는 순간 Hit상태(or Blackjack)로 최초 Ready객체 탈출된다. final State state = new Ready().draw(Card.of(Suit.SPADES, Denomination.TWO)) .draw(Card.of(Suit.SPADES, Denomination.JACK)); // then assertThat(state).isInstanceOf(Hit.class); } . | 중요) 최초Ready상태객체 + 트리거 했는데도 아직 Ready상태인 것도 테스트 . . @Test void ready() { // given &amp; when : ready -&gt; 2 -&gt; ready final State state = new Ready().draw(Card.of(Suit.SPADES, Denomination.TWO)); // then assertThat(state).isInstanceOf(Ready.class); } . 32) 기존 테스트코드를 전체 리팩토링 ( Ready.start -&gt; new Ready.draw().draw()로) . 일단 메서드의 통합테스트에서 -&gt; 특정 객체 테스트로 좁혀들어갔으니 -&gt; 개별 상태 객체들도 자기테스트로 테스트를 옮겨가도 된다. . . 테스트 가져가기 (ReadyTest -&gt; HitTest) . . | . 다시 Ready.start( 재료1, 재료2) -&gt; new Ready() 재료없는 최초 상태객체로 시작하도록 리팩토링 . 기존 돌아가는 코드의 위에 복붙 후 수정 | . @Test void hitHit() { // given &amp; when : ready -&gt; draw 2,10 -&gt; hit -&gt; draw 1 -&gt; hit State state = new Ready().draw(Card.of(Suit.SPADES, Denomination.TWO)) .draw(Card.of(Suit.SPADES, Denomination.JACK)) .draw(Card.of(Suit.SPADES, Denomination.ACE)); //State state = Ready.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK)); //state = state.draw(Card.of(Suit.SPADES, Denomination.ACE)); // draw호출이 가능해서 assertThat(state).isInstanceOf(Hit.class); } . | 33) 개별 상태객체부터 시작하는 Test로 고치기(Ready시작 안해도 됨) . 중요) 상태값을 가지는 객체라면, 그 상태값을 만드는 재료만 넣어주면, 그 정보를 가공하여 반영된 객체를 생성할 수 있다. . 사실 특정객체Test는 Ready최초시작객체부터 시작할 필요가 없다. . **객체 = 최초시작객체가 아니라면, 대부분 재료를 받아 -&gt; 가공 -&gt; 상태값으로 가지는 로직을 가지므로 Hit객체부터 재료를 줘서 만들어서 테스트하면된다. ** . | hit 만드는 테스트부터 만들자. . | . . . . | 참고) 객체 생성시, 재료를 넘겨줄 때, 사용성을 고려하여 생성자 추가는 해도 괜찮다. -&gt; new단일객체()도 귀찮은데 2개이상 생성하면서 List.of()로 묶어줘야한다? -&gt; 클라이언트 배려한 가변인자 파라미터 빨간줄 생성 . 리팩1) 외부에서 인자전달시 List.of()로 묶어서 전달한다? -&gt; 인자는 콤마로 + 파라미터는 가변으로 수정 by Ctrl+F6(change signature) . . 인자에 new 생성자(List.of(객체1, 객체2)) 형태라면 . new 생성자( ` 객체1, 객체2 ) **로 **List.of()의 묶어주는 과정을 제외하여 빨간줄 생성`한 뒤, 생성자를 추가해주자. . | 카드 2개로 인식하지만, 우아한 파라미터 개선의 change signature ctrl+F6으로 가변인자 파라미터로 바꿔주자 . . | 부생성자일 것이니 위치를 위로 옮겨가서 this()를 활용한다. . . | 배열 -&gt; List로 바꿔줄려고 배열.stream을 썼으나… . . | . | 참고) 가변인자는 밖에서 없애줬떤 List.of를 그대로 쓰면 된다. stream대신 -&gt; 내부 List.of()로 처리 . . public Cards(final Card... cards) { this(List.of(cards)); } . @Test void hit() { final State state = new Hit(new Cards(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK))); assertThat(state).isInstanceOf(Hit.class); } . 34) 카드 2장으로 new Hit() 시작하여 hit -&gt; hit 테스트 . . 2장으로 Hit를 만들고 체이닝으로 트리거메서드를 호출해했지만 가독성이 엉망이다. | . | . | . 리팩3) 가독성을 위한 긴 파라미터부분을 -&gt; 위에 변수로 추출 . . 선택된 부분이 윗줄에 변수로 추출되어야한다. . 파라미터 추출은 메서드의 파라미터로 이동된다. 조심 | . . @Test void hitHit() { // 2,10 으로 hit -&gt; draw 1 -&gt; hit final Cards cards = new Cards(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK)); State state = new Hit(cards); //when state = state.draw(Card.of(Suit.SPADES, Denomination.ACE)); //then assertThat(state).isInstanceOf(Hit.class); } . | . 리팩4 &amp; 중요) 많이 쓰이는 Test속 일급재료인 상수기반 단일객체는 Fixtures클래스에 모아두고 static import해서 단일객체가 객체지만, 상수처럼 갖다쓰자. . 중요) Test에서 자주쓰는 단일객체(일급의 재료)를 Fixures클래스에서 상수로 선언하여 모아두자.-&gt; new 단일() or 단일.of() / 단일.from() 등 인자에서 호출되는 단일객체 생성자(정펙매) 호출부분을 ctrl+alt+C로 객체를 상수추출한 뒤, F6 -&gt; public(psf)으로 Fixtures 클래스로 옮겨주자. . cf) psf = public static final -&gt; 다른데서 갖다쓰는 상수 -&gt; Test Fixture아니면 쓸일 없을 듯 -&gt; 상수라도 각 도메인내부에서 쓰기! | cf) pr sf = pr ivate static final -&gt; 일반 클래스내 상수 | . Fixtures클래스를 만든다. . breadcrums(c+a+;)를 이용해서 같은 테스트내에서 편하게 만들 수 있다. | . . | 상수가 아니라 new 단일() or 단일.of() / 단일.from() 등 인자에서 호출되는 단일객체생성자를 추출해와야한다. . 오른쪽에 복제가 아닌 1개 창으로 띄우기 ctrl + (복제) -&gt; 왼쪽으로 넘어오기(tabmover의 c+a+s+[) -&gt; 왼쪽 창끄거나 다른창으로넘어가기 | . . | 직접 Fixutre에서 상수로 선언하지말고 상수로 추출 -&gt; F6으로 상수옮겨가기를 해보자. . . ctrl+alt+ C의 상수추출 | . . 상수 부분을 클릭후 F6으로 이동 실수로 Card 등의 Class부분을 잡고 F6을 하면, class이동이 되어버리니 조심 | . | . . . 갖다 쓸 상수(public sf)로 가는 것이기 때문에 Public도 지정해준다. 안해주면 default생성자가 되어버린다. | . | . . Fixtures클래스로 public으로 옮겨갔으며 + 기존 있던 Test에서는 Fixtures.상수로 사용되어진다. | . | 참고) 테스트용 갖다쓰는 객체상수 클래스 Fixtures는 Add on-demand static import를 통해 편하게 현재클래스내 상수처럼 쓸 수 있게 한다. . 상수전용 클래스 Fixture를 static import로 생략하고 상수(SPADE_TWO)만 사용할 수도 있다. . . . | 상수객체가 정상 단일객체럼 행동하는지 해당 객체 테스트에서 객체상수 isSamaAs 생성한 객체 테스트를 해보자 . 기존 테스트 . @Test void of() { final Card card = Card.of(Suit.HEARTS, Denomination.ACE); assertThat(card).isSameAs(Card.of(Suit.HEARTS, Denomination.ACE)); } . | 사용되는 단일객체를 -&gt; 상수객체로 뽑아서 옮겨놓고 상수로 가져오자. . | | . . . . . | . | 나머지 사용되는 단일객체들도 다 상수화 -&gt; Fixutre에 public 상수로 옮기기 해주자 . public class Fixtures { public static final Card SPADE_TWO = Card.of(Suit.SPADES, Denomination.TWO); public static final Card HEART_ACE = Card.of(Suit.HEARTS, Denomination.ACE); public static final Card SPADE_JACK = Card.of(Suit.SPADES, Denomination.JACK); //... } . | 참고) 객체 -&gt; 상수 만들다가 기존 Fixtures에 뽑아 놓은 객체상수 발견시 -&gt; ctrl+H로 일괄변경해주기. -&gt; 의심되는 객체는 ctrl+shit+F로 Fixtures에 만들어놓은게 없나 살펴보기 . 상수 만들었다, 이미 만들었떤 것이 나온다? -&gt; 찾아바꾸기로 한번에 다 바꿔주자. . . . . . | Fixture 목록에 없는 것들이 나타나면, 또 뽑아서 바꿔준다. . | 이미 만들어놓은 것 같은데 확인하고 싶다면, -&gt; 블럭 + ctrl+shift+F에서 Fixtures에 걸리는게 있나 훔쳐보기 . 있다면 windows에서 클릭해서 해당 Fixture상수 복사해와서 -&gt; ctrl+H에 복붙여넣고 찾아바꾸기 . . | . |",
            "url": "blog.chojaeseong.com/java/pattern/state/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/27/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD%EA%B3%BC-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B42.html",
            "relUrl": "/java/pattern/state/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/27/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD%EA%B3%BC-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B42.html",
            "date": " • Mar 27, 2022"
        }
        
    
  
    
        ,"post98": {
            "title": "강의) 네오 3단계 블랙잭 피드백(1/4)",
            "content": "블랙잭 . 도메인 공부후 시작점 찾기 . 정제된 rawInput이 들어온다고 가정하고 했었다. 자동차 경주: new Car(&quot;이름&quot;)의 string 생성부터 -&gt; 응답하는 메서드 테스트 | 로또: rawInput으로 1,2,3,4,5,6의 list | | 블랙잭 로직을 시작하려면 재료 시작전 포장된 카드 -&gt; 카드덱이 먼저 필요하다 카드덱이 카드를 2장씩 제공해야하는데, 포장된 카드만 있으면 카드덱에서 뽑아서 줬다고 가정하고 메인로직 시작하면 된다. | . | 카드를 &quot;문자열&quot;, 숫자의 정제된 rawInput으로 가정해도 되지만, 이것은 input으로 들어오는게 아니라 원래 생성되어 있어야하는 것이므로 가정하고 -&gt; 나중에 포장하는게 아니라 미리 만들고 시작한다 게다가 2개는 같이 붙어서 움직이는 것이므로 -&gt; 미리 클래스로 포장한다 로또당첨번호 lotto + bonusNumber | Player가 가지는 name + cards | . | . | 캐싱 . 재료인 Card먼저 만들기 . 01 Card에는 2가지정보가 붙어서 움직인다. . . test를 파서 필요한, 붙어다니는 2개의 정보로 new Card( , ) 생성부터 해본다. . . | 2가지 정보는 제한된 상수이므로 Enum으로 생성하고 1가지 예시 enum객체를 활용해서 생성한다. . enum의 예시 -&gt; enum클래스.대문자_상수로 사용 | . . @Test void create() { //new Card(new Suit(), new Denomination()); //1. 2가지 정보는 제한된 수의 상수 -&gt; enum으로 받는다고 가정 -&gt; 예시로 생성한다. new Card(Suit.HEART, Denomination.ACE); } . . | enum 정보를 복사해오는데, 필드값이 지금 당장 필요하지 않으면 삭제하자. . public enum Denomination { ACE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING, ; } . package blackjack; public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES } . . | 2가지 정보로 new 객체생성 템플릿 주생성자를 일단 생성해줘야한다. . 캐싱을 하더라도 먼저 기본생성자부터 생성해주자. | . . . public class Card { private final Suit suit; private final Denomination denomination; public Card(final Suit suit, final Denomination denomination) { this.suit = suit; this.denomination = denomination; } } . 파라미터는 좀 길다면 보기 좋게 2번재 줄로 이동시켜도 된다. | . | 02 class는 객체 100% 새로 생성 new 단순템플릿이 아니라 캐싱등의 능동적 객체 생성 관리자역할을 by 로직을 포함한 생성자 정펙매로 할 수 있다. . 캐싱은 생성에 관한 것이며, 정적팩토리메서드를 통해 능동적으로 로직을 포함한 생성으로 객체생성을 관리할 수 있다. . . @Test void create() { final Card card = new Card(Suit.HEARTS, Denomination.ACE); //2. [new + 재료]가 아니라, of/from등의 [정펙매 + 재료]로 생성해야 로직을 포함한 생성이 가능하다. Card.of(Suit.HEARTS, Denomination.ACE); } . . 메서드 생성후 파라미터 라인 + 명칭 수정해주고 나중가면 final도 달아준다? | . . | 캐싱을 하기 위해서는 2가지만 해주면 된다. 미리 pr sf 로 클래스 변수 = 상수로서 cache map만들어주기 psf는 public sf/ prsf은 private이다. | . | 정펙매에서 생성된 CACHE_MAP + .computeIfAbsent(, )로 없을 때만 new 100%생성 기본생성자로 생성 후 반환 | 캐싱될 객체는 VO로서 값 같으면 같은객체 취급해주기 위해 eq/hC 오버라이딩 | | 클래스 변수(상수)로 cache를 선언할 것이므로 -&gt; 메소드 내에서 변수 추출로 형완성을 해가자 . ctrl+alt+F로 메서드내부에서 바로 필드(인변/클변으로 뽑을 수 있다) | . | 2개의 변수를 동시에 가지고 다니는 inner class를 선언한 뒤, 그 class의객체를 Key로 가지고 가도 된다.(사용한할 것임. 참고만) . private static class Key { private final Suit suit; private final Denomination denomination; private Key(final Suit suit, final Denomination denomination) { this.suit = suit; this.denomination = denomination; } } . 변수 추출시 다형성도 항상 확인하자 | . | 2개의 변수를 들고다니는 클래스Key를 만들어줘도, Card와 동일한 상태다(2개를 인변으로). 그냥 .name()을 활용한 string+string의 &lt;String, 으로 unique한 1개의 key로 만들어준다. 캐싱의 valueType은 해당 객체로 준다. . . | enum은 enum객체 변수명을 그대로 출력해주는 .name()메서드를 제공해준다. . . System.out.println(Suit.HEARTS.name() + Denomination.ACE.name()); . . | 메소드내부에서 변수추출했지만, scope이동할 땐, pr를 포함한 sf로 변경하여 접근제한자를 수정해주자.. . 메서드내부에서는 pr이 안먹는다. public메서드라면.. | . . 갯수를 미리 알고 있으면 map의 () 생성자에 넣어준다. | . public class Card { private static final Map&lt;String, Card&gt; CACHE = new HashMap&lt;&gt;(52); . | 캐쉬에 들어갈 key를 1.name() + 2.name()의 스트링으로 작성해줬다. 만약, 그 key가 없을 경우, 해당 key값으로 자동으로 넣어줄 value를 지정해줘야한다. . 이 때, key값은 활용을 안하므로 value값을 만들어줄 Function 함수의 람다 시작인자로서 자리에 앞선 인자 key를 활용 안하므로 ignored로 명명해서 작성해주자. | . . public static Card of(final Suit suit, final Denomination denomination) { return CACHE.computeIfAbsent(suit.name() + denomination.name(), ignored -&gt; new Card(suit, denomination)); } . | 03 캐싱되는 객체는 VO처럼 eq/hC 오버라이딩 해줘야한다. + 정펙매 사용하면 기본생성자는 private로 바꿔서 잠궈줘야한다. . 같은 값(2개 정보)를 가지면 -&gt; 같은 객체로 판단되어야 재사용시 같은 것으로 확인이 된다. . generate 띄운 후 eq로 빠르게 검색해서 사용하기 | . . | 리팩토리으로서 메서드 인자에, 메소드 연산을 하고 있다. -&gt; 메서드추출 . // return CACHE.computeIfAbsent(suit.name() + denomination.name(), // return CACHE.computeIfAbsent(toKey(suit, denomination), . . | 정펙메 사용순간부터 기본 생성자는 private으로 변경 . . 테스트 코드에 사용했던 new 기본생성자를 .of로 변경 | . . 테스트 메서드명도 변경 create -&gt; of | . | . . | . 만든 카드 캐싱 테스트 . 참고) assertThat()의 import는 qualify static call.. 이후 add static import로 ?? . . . . . . 캐싱 테스트: 만든것 .isSameAs( 방금 만든 것 )같은지 . class CardTest { @Test void of() { final Card card = Card.of(Suit.HEARTS, Denomination.ACE); assertThat(card).isSameAs(Card.of(Suit.HEARTS, Denomination.ACE)); } } . TDD 시작점 어디서부터 . 핵심 로직은? . 카드 2장을 받는 것? | 2장 받은 상태에서 판단을 한다. 21이면 블랙잭 if문이 등장했다. -&gt; 다형성/enum 등… | . | 21보다 낮으면(21 아니면) sit 그만 할 수 있다. stay 추가적으로 받을 수 없다. | . | hit시, 21보다 아래면 sit상태로 계속 받을 수 있다. | . | . | . | 행위는 사용자input에 의해 진행되지만, 특정 메서드(카드받기)에 의해 서로 바뀌는 &lt;상호 연결된 상태값&gt;이라는 밀접한 관계를 가지고 있다. 응답값이 상태이며, | (동일)메서드에 의해 실시간으로 바뀌는 상태다.. | if문이 엄청 나올 것이다 -&gt; 추상화로 if문을 제거한다 객체생활 체조원칙 -&gt; 체조는 어디에 좋은지 모르는데, 하다보면 좋아진다. | . | . | 시작점은 어디서? . 재료인 카드 2장을 뽑은 상태에서부터 시작하여 상호 연결된 다른 상태로 바뀌는 메서드를 호출하면서 시작한다. | . 01 핵심로직(like Service)의 클래스이름이 안정해졌으면 GameTest클래스 -&gt; Game.start(재료)메서드로 시작 . . . . 02 재료를 넣고 -&gt; 예상 응답값으로 뭐가 나올지 먼저 고민한 뒤 여러개면 만만한 1 case 선택 -&gt; 재료:예상 인자값도 맞춰서 정해준다. . 테메당 1case이므로 여러 응답(상태)이 나온다고 예상되면 -&gt; 그 중 1개를 예상응답값으로 선택하고 -&gt; 예상응답값에 맞는 재료를 넣어줘야한다. . 메인로직 클래스(game)의 static메서드()에 정제된 rawInput(재료)으로서 포장 카드 2장을 넣어야한다. . | 메서드를 짜기 전, 예상 응답을 먼저 생각해보고 여러 응답값이 나올 수 있다면, 만만한 응답값부터 예상값으로 정해놓고 1 case testmethod를 작성하자. . blackjack은 ace처리도 해줘야하기 때문에 만만하지 않다. | case가 정해지면 그에 따라 테스트 메서드 이름도 바꿔준다. (start-&gt; hit) | . @Test void hit() { //1. 재료: 카드 2장을 넣을 때 -&gt; 응답: if max21 Blackjack or if Hit(orStay)가 나올 수 있다. // -&gt; 먼저 만만한 것을 고른다. // -&gt; 21 아래 값인 hit를 먼저 예상응답으로 정한다. Game.start(); } . | 예상응답값에 대한 예상인자를 맞춰서 작성해줘야한다. . hit를 먼저 예상응답값으로 정했다면 | hit를 만드는 재료 카드 2장도 예상인자값으로 맞춰서 넣어줘야한다. | . . @Test void hit() { //1. 재료: 카드 2장을 넣을 때 -&gt; 응답: if max21 Blackjack or if Hit(orStay)가 나올 수 있다. // -&gt; 먼저 만만한 것을 고른다. // -&gt; 21 아래 값인 hit를 먼저 예상응답으로 정한다. //2. 카드2 -&gt; hit (예상응답값) -&gt; 거기에 맞는 재료 넣어주기 Game.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.FIVE)); } . . | 응답값이 상수/enum이 행위에 의해 다른 것으로 바뀔 수 있는 상태라면 -&gt; class의 객체로 미리 작성한다. . 03 테스트는 내부로직 완성전에 응답값 -&gt; then assert문을 미리 작성 -&gt; 클래스와 메서드는 껍데기만 일단 작성해놓기 . 참고) 앞으로 클래스가 상속예정없으면 다 final로 선언하는 버릇 들이기 . . 메인로직 메서드 보유 클래스(Game)을 만들어주고 **응답값을미리 ** 작성해야한다. . 클래스 생성만 해주고 넘어가야한다 | 이 때 class가 상속예정이 없으면 final로 선언하는 버릇을 들이자. | . public final class Game { } . . | 응답값 아직 작성안된 class의 객체가 있을 예정이라면 Object로 응답해주고 (실패용)return null;하는 메서드 작성하기 . 빈 메서드 완성해주기 . . . 응답값 객체가 있을 예정이면 Object로 일단 응답시키고 return null;로 작성하자 return null;로 초기 작성해줘야 실패를 해서 고친다. | . | 순서가 있는 파라미터는 first, second로 네이밍해놓자 | 파라미터는 줄맞춤 해도 된다. | . public final class Game { public static Object start(final Card first, final Card second) { return null; } } . . | 04 Object 응답객체로 받아서 null이 넘어와 실패할 assert문 작성과 동시에 expected에 기입할 응답객체.class로 응답클래스만들어주기 . 객체 응답은 .isInstanceOf( 클래스.class)로 확인하면서 class작성해주기 . . Object [미완성응답객체]로 받아주고 -&gt; 확인을 .isIntanceOf(Hit.class)로 해주면서 클래스를 만든다 . @Test void hit() { // given &amp; when : hit final Object hit = Game.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.FIVE)); // then assertThat(hit).isInstanceOf(Hit.class); } . . public final class Hit { } . | 클래스를 채우거나 완성하지 않고 테스트를 돌린다. . return null;의 미완성 상태라 실패한다. | . . | 05 첫번째 응답객체로 메서드 응답(응답Type+return) 바꿔주기 . null이 넘어가는 상황을 현재 case의 응답객체로 바꿔줘야 케이스가 통과될 것이다. . 기존 | . public final class Game { public static Object start(final Card first, final Card second) { return null; } } . 변경 후 | . public final class Game { public static Hit start(final Card first, final Card second) { return new Hit(); } } . . | 테스트 돌려보면 통과된다. . | 06 2번째 예상응답인 blackjack case로 만들어 주고 로직 추가해주기 -&gt; given예상인자값도 바꿔주자! . 다형성 적용전까진, 바뀔 수 있는 응답객체의 변수Type을 Object로 유지해주기 . 그래야 다형성 적용 전, case 추가해서 받아줘도 테스트들이 다 통과될 것이다. | . 테메 복사 -&gt; 테메이름 -&gt; 변수이름 -&gt; 예상 응답값 -&gt; 예상인자값given -&gt; expeceed 모두 해당case로 바꿔주기 . . | 없으면 해당 클래스도 만들어준다. -&gt; final + enter 활용 . tab누르면 추가가 아니라 단어 덮어쓰기 되서 class가 사라지더라. | . public final class Blackjack { } . | 예상인자값도 바꿔주야한다. . ace + jack으로 바꿔줌 | . . | 테스트는 로직 추가/수정이 없으니 통과안한다. . | 07 복잡한 case통과를 위한 로직 추가해주기 . blackjack은 단순if문으로 통과할 순 없다. | . 카드의 합이 21이 될 때 return new Blackjack() 해주면 되는데, 지금은 점수를 가지고 올 수 없다. . Card -&gt; Denomination -&gt; 점수를 가지고 와야함. | . public static Hit start(final Card first, final Card second) { return new Hit(); } . | . | 필요에 의해 enum에 필드 추가해주기 . 여러개 선택은 커서가 물리는 중간에서 시작해서 -&gt; 같이 움직인다. . 1~2자리 숫자면, 2자리 숫자로 입력해서 지우는 식으로 가자. | . . | . 참고) enum에 필드를 만들어줬다는 말은 밖에서 갖다 쓸거라는 말이다 -&gt; getter가 될 준비를 한다. . 나중에 필요에 의해 작성할것이지만, 미리 작성해줘도 된다. . getValue대신 특정필드명이 있다면 .필드명()으로 게터를 대신한다. | . public int point() { return point; } . | . 08 최대한 빨리 테스트 통과시키기 . 참고) 도메인vs같/다른도메인의 비교 는 서비스(메인로직 구동) 메서드 내부에서 일단 getter이용해서 하고 -&gt; 도메인로직으로서 클래스를 추출하거나 해서 옮겨야한다. . 현재 getter를 쓰는 것에 대한 정당성 확보 -&gt; 같은 도메인끼리라도 내부 비교로직이라면 현재 서비스 로직에서 일단 작성해주고 추출해줘야한다. . but 같은 도메인끼리 or 도메인1개에 대해 단순 상수비교/ 메서드없이 단순집계 등는 개별 일괄처리 or 집계라면 묶어서 -&gt; 메세지 보내서 물어본다` -&gt; 현재의 상황 . 참고) [객체] 내부의 [포장변수 속 변수]를 가져올 때도 getter대신 .최종 나올 변수명()으로 메서드 지어 들어가기 . 예시) Player 속 Cards 속 cards에 접근하고 싶을 때 Player.getCards()가 아니라 Player.cards() 메세지를 보낸 뒤 Cards 내부에서 return this.cards로 보내주는 식으로 자기 변수처럼 바로 꺼내보도록 하자. get중간포장변수()가 아닌 .최종변수xxxx() | . | . . . . blackjack을 응답해주는 코드를 최대한 빠르게 작성해보자. . . . | if분기에 따라 서로 다른형의 객체를 응답해야할 떄 -&gt; 다시 응답을 Object형으로 바꿔주고 -&gt; 다형성을 생각한다 -&gt; 일단 테스트통과부터 확인한다. . . . 테스트가 실패한다. -&gt; ace는 기본 1 point로 시작하고, 11로 계산처리를 안해줘서 . public static Object start(final Card first, final Card second) { if (first.point() + second.point() == 21) { return new Blackjack(); } return new Hit(); } . . | . ACE에 대한 처리 . if문에 들어가있던 도메인끼리 연산을 밖으로 빼서 처리후 넣어줘야한다. . == 21정답과의 비교는 빼고 처리해야한다. | . public static Object start(final Card first, final Card second) { final int sum = first.point() + second.point(); if (sum == 21) { return new Blackjack(); } return new Hit(); } . . | . 참고) 2개이상의 같은 형이 개별 일괄처리가 필요할 땐 list에 넣고 -&gt; stream으로 일괄처리 -&gt; 도메인끼리가 아니라 stream 도메인 개별 처리 -&gt; 꺼내지말고 메세지보내서 처리한다 . 받은 first와 second가 같은형의 같은 도메인이 때문에 -&gt; list(List.of())에 넣어서 일괄처리한다. . | 도메인 1개에 대한 것이므로 (같/다른 도메인끼리의 연산이 아닌 순간 메세지보내서 처리) 메세지를 보내서 ace있는지부터 확인한다. . . . 이넘에게 연산이라서 .is메서드()로 물어봐야할 것 같지만 일단 넘어가보자. | . . 여러개에 대해 isAce가 anyMatch로 가지고 있다면, hasAce가 된다. | . public static Object start(final Card first, final Card second) { final boolean hasAce = List.of(first, second) .stream() .anyMatch(it -&gt; it.isAce()); final int sum = first.point() + second.point(); if (sum == 21) { return new Blackjack(); } return new Hit(); } . . intellij가 list에 담아서 stream하지말고 Stream.of()로 한번에 묶어라고 한다. . final boolean hasAce = Stream.of(first, second) .anyMatch(Card::isAce); . . | . | ace는 비록 1이지만, 합계 계산시 ace객체의 point를 11로 변경하지말고 21의 블랙잭 기준상수를 11로 낮추자? . . public static Object start(final Card first, final Card second) { final int sum = first.point() + second.point(); final boolean hasAce = Stream.of(first, second) .anyMatch(Card::isAce); if (hasAce &amp;&amp; sum == 11) { return new Blackjack(); } return new Hit(); } . 테스트는 통과하게 된다. | . . | 다양한class의 객체들 응답시 Object로 응답? 메서드가 많은 일을한다? . Object응답 | 메서드가 너무 많은 일을 한다. 같은형이라도, 도메인vs도메인 비교로직이라면일단 getter 서비스로직에 작성하되 -&gt; 추후 도메인로직으로 넘긴다. | 하지만… 지금과 같은 일괄처리/내부변수단순집계-&gt; 묶어서 메세지보내서 일괄처리 한다. | | 09 메서드가 길어져서 너무 많은 일 -&gt; 도메인1개or같은도메인끼리 상수or단순연산/집계 -&gt; 묶어서 메세지보내 일괄처리 or 내부변수 단순집계로 일괄처리한다. . 첫번째, 두번째 카드의 합계는 같은 도메인이면서 단순집계다 -&gt; 묵어서 일괄처리가 가능하다. . . | . 같은 도메인이라면 List.of()나 Stream.of()로 묶어서 일괄처리 or 단순집계가 가능하다. . 같은 도메인이라면 List.of()나 Stream.of()로 묶어서 일괄처리 or 단순집계가 가능하다. . . public static Object start(final Card first, final Card second) { final int sum = Stream.of(first, second) .mapToInt(it -&gt; it.point()) .sum(); //final int sum = first.point() + second.point(); final boolean hasAce = Stream.of(first, second) .anyMatch(Card::isAce); if (hasAce &amp;&amp; sum == 11) { return new Blackjack(); } return new Hit(); } . | 일괄처리/내부변수단순집계가 2번이상 필요하면 -&gt; List.of( , ,) 묶어놓고 개별 list.stream() 때린다. . . public static Object start(final Card first, final Card second) { //1. 같은형의 [일괄처리/단순집계]가 2번이상 필요할 땐 -&gt; 무조건 List.of()로 일단 묶어 변수로 뺀다. final List&lt;Card&gt; cards = List.of(first, second); // final int sum = Stream.of(first, second) // 일괄처리1: 내부변수 단순집계 final int sum = cards.stream() .mapToInt(it -&gt; it.point()) .sum(); // final boolean hasAce = Stream.of(first, second) // 일괄처리2: 일괄처리로 메세지보내기 final boolean hasAce = cards.stream() .anyMatch(Card::isAce); if (hasAce &amp;&amp; sum == 11) { return new Blackjack(); } return new Hit(); } . 서비스로직내 도메인로직의 class로 추출 . 10 서비스 로직 내 같은형 객체 2개이상의 일괄처리 로직 -&gt; 일급컬렉션으로 추출 . 객체일괄처리를 위해 뽑아낸 List.of() -&gt; 객체List -&gt; 일괄처리가 메서드로 가는 일급컬렉션 추출과정이 된다. . public static Object start(final Card first, final Card second) { // 1) 도메인vs도메인 비교로직 후 새 결과값(생성자) 포장(class)후 // -&gt; 그것의 추가 로직(메서드)이 아니더라도 // 2) 같은도메인 객체 2개이상의 묶어서 일괄처리(메세지보내 일괄처리 or 내부변수 변환후 단순집계)도 // -&gt; 일괄처리하려면 List&lt;객체&gt;를 뽑아내야하고 (상태값, 인스턴스변수) // -&gt; 일괄처리로직이 도메인로직(메서드)가 되어서 // -&gt; 포장하는 일급컬렉션을 만들어낸다. final List&lt;Card&gt; cards = List.of(first, second); final int sum = cards.stream() .mapToInt(it -&gt; it.point()) .sum(); final boolean hasAce = cards.stream() .anyMatch(Card::isAce); if (hasAce &amp;&amp; sum == 11) { return new Blackjack(); } return new Hit(); } . sum하는 부분/ hasAce로 뽑아내는 부분 -&gt; 일괄처리로 간주했지만 어떠한 역할이며 도메인 class를 만들어 위임해야한다. | . 서비스 메서드 내에서 발견된 역할과 객체List -&gt; 메서드 로직 내에서 일급컬렉션 추출해보기 . 서비스 메서드 내지만, 기존 List생성 코드라인을 복붙후 재료로서 사용해서 빨간줄 컬렉을 만든다. . . 완성되면 객체list는 삭제해준다. | . | 포장전 내부까는 코드였다면, 포장전 복붙 or 복사해놓은 상태로 최종메서드만 남기고 -&gt; 내부처리코드를 잘라내 들고들어가 -&gt; list자리에 -&gt; 내부포장되어있던 value만 바꿔넣어준다. . 객체list삭제로 인한 list.stream()에서의 list부분에 빨간줄처리해준다. . 비교메서드가 빨간줄이었다면, 그대로 일급내부에서 생성해도 됬찌만 . | getter/stream 등이 내부를 까는 메서드가 빨간줄이라면 복사후 지우면서 -&gt; 최종메서드 남겨 메세지 던지고 -&gt; 내부처리 코드를 들어가 내부처리한다. . 기존 . | 일급적용: 복사해놓고, 위에 올려놓고, 내부까는코드는 지우고, 최종만 남겨 메세지보낸다. . . | 일급적용: 최종 메세지 메서드를 만들면서, 내부처리코드를 잘라내서 들고들어가자. . . . . . | . | . public final class Cards { private final List&lt;Card&gt; value; public Cards(final List&lt;Card&gt; value) { this.value = value; } public int sum() { return value.stream() .mapToInt(it -&gt; it.point()) .sum(); } } . | 마찬가지로 hasAce로직도 . 복사 -&gt; 내부처리코드 삭제 -&gt; 최종만 남기고 -&gt; 내부로 잘라내서 복사 -&gt; list자리에 일급컬렉내부value(list)로 바꿔주기 . | 기존 . | 처리 . 최종메서드명이 따로 없다면 뽑아놓은 변수명(hasAce)나 최종 체인된 메서드(anyMatch + isAce)로 유추한 메서드로 메세지보낸다. | . . 내부로 들고들어갈 코드복사된 상태로-&gt; 최종메서드로 이름바꿔주기 . . | 코드 복붙후 list 자리에 포장변수value + return 등 처리해주기 . | . | . | 1번만 쓰인다면 지역변수 제거하고 inline화 . . public static Object start(final Card first, final Card second) { final Cards cards = new Cards(List.of(first, second)); if (cards.hasAce() &amp;&amp; cards.sum() == 11) { return new Blackjack(); } return new Hit(); } . 참고) 너무빠른 리팩토링이지만, if문이 하나의 도메인에 대한 여러 boolean문장이면, 메세지를 넘길 수 있다. (메서드추출이랑 다름) . 두 boolean문장이 cards에 관한 것이므로 -&gt; cards에 메세지를 던질 수 있다. . . | 메서드추출을 한다면? -&gt; 한 도메인에 대한 것임을 고려하지 못한 체 해당 로직class내에서 추출한다. -&gt; 메세지를 던지지 못한다. . . | . 참고-연결) 메세지를 던지려면, 내부처리로직 코드복사후 -&gt; 최종메서드로 던지기 -&gt; 밖에서 list가 아니라 일급그대로를 썼던 코드는? 내부에서 바로 메서드()형태로 내부메서드를 이용하면 된다. . 여기서 최종메서드로 메세지 던지는 이름은 is + Blackjack()으로 한다. . . 복사후, 바꿔주고 -&gt; 내부로 들고들어가 -&gt; 변수명만 처리해주면 되는데, 포장된 일급을 쓰던 코드를 메세지보냈다. -&gt; 일급변수명 빼고 내부에 존재하는 메서드를 메서드()로 호출만 해주면 -&gt; 내부의 this.value를 이용한 메서드를 알아서 호출해서 쓴다. . . | move staetment up/down 변수없이 호출되는 내부메서드들보다 위쪽으로 올려준다. . . | . | . 메서드의 응답을 Object -&gt; 응답되는 객체들을 뽑아내서 추상화or상위Type 생성으로 카테고라이징 . 11 서로 변하는 Blackjack 상태, Hit상태들을 상위타입으로 뽑아내기 -&gt; 일단 상위카테고리는 인터페이스로 뽑아낸다. . . State인터페이스를 만든다. . . public interface State { } . | 다형성으로서 응답값을 상카인 interface로 응답해준다 . public static State start(final Card first, final Card second) { final Cards cards = new Cards(List.of(first, second)); if (cards.isBlackjack()) { return new Blackjack(); } return new Hit(); } . | 참고) 상카로 카테고라이징하려고 인터페이스를 만들었다면 -&gt; 하위카테고리 구현체들이 impl 전에 응답값/ 변수/파라미터 등의 길목 선언부 먼저 인터페이스로 바꿔주자 -&gt; 거기로 향하는 예비 구현체들이 빨간줄 -&gt; 쉽게 + 자동 impl된다 . 길목(변수,파라미터,응답값의 선언부)응답값을 인터페이스로 먼저 바꿔줬더니, 응답될 예비구현체들이 구현되려고 빨간줄이 뜬다. . . . | . 묶여서 카테고라이징 되는 놈들은 인터페이스를 모두 구현한다 . public final class Hit implements State { } public final class Blackjack implements State { } . | 메서드의 응답값을 바꿔줬다면 -&gt; 까먹지 말고 밖에서 받아주는 변수도 Object에서 -&gt; 다형성-상카-인터페이스로 + 변수명도 인터페이스명으로 바꿔주자 . . 테스트코드라면 단순하게 현재파일에서 Ctrl+H로 찾아서 replace ALL해주면 된다. 찾은 갯수만 잘 확인해서 바꿔주자. | . | 변수명도 바꿔주자. . . public class GameTest { @Test void hit() { // given &amp; when : hit final State state = Game.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK)); // then assertThat(state).isInstanceOf(Hit.class); } @Test void blackjack() { // given &amp; when : blackjack final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); // then assertThat(state).isInstanceOf(Blackjack.class); } . | . 중요1) 왜? 추클이 아니라 인터페이스?로 상카뽑아 카테고라이징) . 어떤 메서드 or 변수들이 추상화 or 공통메서드로 뽑힐지 모르며. 카테고라이징이 목적이다 상카뽑는 목적이면 인터페이스부터 뽑는다. 추클로 바뀔 수도 있다. | . | . 중요2) 제한된 수의 상태값들인데, 왜 Enum이 아니라 클래스 객체로 상태 응답? . hit과 blackjack사이에 서로 연결되어 &lt;메서드호출로 인해&gt; 서로 바뀔 수 있는 묶인 상태들이다. -&gt; **서로 바뀌더라도 인페구현의 다형성으로 들어가 [상태를 바꿔주는 같은 이름의 메서드]를 계속 호출할 수 있는 상태값으로 상태 패턴 객체를 선택할 수 밖에 없다. ** . | 추가로 enum도 가능한 형태 뿐만 아니라 다음 상태로 바뀌기 위한 판단을 위해 내부에 인변=상태로 가지고 있어야한다. . 이넘은 상태값을 가지면서 공유할 수 없다. | TDD의 D는 디자인이 아니다 -&gt; 미리 설계되어있고 development만 한다. | . | . 참고) 상속/추상화/카테고리 작업후엔 클래스 다이어그램 보기 . 프로덕션을 봐야한다. -&gt; 프로덕션의 패키지폴더를 클릭한 상태로 단축키 ctrl+alt+shift + U + edge create mode는 기본적으로 켜두자 . . | . 다음 상태로 이어가기 -&gt; 기본 2장받고 가능한 상태:Hit or Blackjack -&gt; 다음엔?? -&gt; 둘 중에 더 만만한 것에서부터상태 변화를 이어나간다. . 12 hit 과 blackjack 두 상태 중 blackjack은 다음이 게임종료라 구현이 더 쉽우니 blackjack에서 이어나간다. . 특정상태에서 이어나가는 테스트메소드의 작성 . 직전까지 작성된 blackjack이 된 상태응답 테스트코드를 그대로 복붙한다 -&gt; 테메이름에 현재상태 + 이어질 작업을 더해준다. . @Test void blackjackDraw() { // given : blackjack -&gt; 더이상 게임을 할 수 없다. (hit에서 이어지는 것보다 쉽다) final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); } . | 예외발생이 정답인 메서드호출 -&gt; 메서드 호출시 끝남 = 메서드호출시 예외 -&gt; 생성자처럼 assertThrows() 문에서 해당예외 명시하며 + 호출하며 테스트 . **blackjack에서 카드받는다고 하면 -&gt; 호출시 예외발생으로 작업이 끝나야하므로 **생성자처럼 예외발생이 정답인 호출이 된다. . @Test void blackjackDraw() { // given : blackjack -&gt; 더이상 게임을 할 수 없다. (hit에서 이어지는 것보다 쉽다) final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); // 1. blackjack은 끝난 상태로 -&gt; [상호 상태 변화 전략메서드()] 호출시 예외가 발생하도록 짜야한다. // -&gt; blackjack상태에서 .상호상태변화 전략메서드()호출시 -&gt; 문제가 생겨야한다. state.draw(); } . | 생각해보니, 상태변화에는 카드1장 받기의 재료(인자)가 필요하다. . @Test void blackjackDraw() { // given : blackjack -&gt; 더이상 게임을 할 수 없다. (hit에서 이어지는 것보다 쉽다) final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); // 1. blackjack상태에서 .상호상태변화 전략메서드()호출시 -&gt; 문제가 생겨야한다. // 2. 상태변화에는 card1장이 필요하다. state.draw(Card.of(Suit.SPADES, Denomination.TEN)); . | 예외발생이 정답인 호출이라면, assert문 내부에서 예외명시하며 호출한다 . @Test void blackjackDraw() { // given : blackjack -&gt; 더이상 게임을 할 수 없다. (hit에서 이어지는 것보다 쉽다) final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); // 1. blackjack상태에서 .상호상태변화 전략메서드()호출시 -&gt; 문제가 생겨야한다. // 2. 상태변화에는 card1장이 필요하다. //state.draw(Card.of(Suit.SPADES, Denomination.TEN)); // 3. 예외발생이 통과인 호출 -&gt; assert문 내부에서 예외명시하며 호출 assertThrows(IllegalStateException.class, () -&gt; state.draw(Card.of(Suit.SPADES, Denomination.TEN))); } . | 특정 구현체[끝 상태]에서 [상태변화의 전략메서드] 호출인지 / 아니면 단독메서드 호출인지 고민해보기 . 13 게임끝의 상태에서 더 진행하는 상태변화 메서드 호출시 에러발생인데, blackjack상태에서도 재료(인자, card1장)를 받는 공통 전략메서드를 부를 수 있나? . . @Test void blackjackDraw() { // given : blackjack -&gt; 더이상 게임을 할 수 없다. (hit에서 이어지는 것보다 쉽다) final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); // 1. blackjack상태에서 .상호상태변화 전략메서드()호출시 -&gt; 문제가 생겨야한다. // 2. 상태변화에는 card1장이 필요하다. // 4. 근데, blackjack은 끝난 상태인데 게임상 재료로서 들어올 수 있나??? (읹 //state.draw(Card.of(Suit.SPADES, Denomination.TEN)); // 3. 예외발생이 통과인 호출 -&gt; assert문 내부에서 예외명시하며 호출 } . 만약, 공통전략메서드가 아니라 특정 구현체만 가능한 단독 메서드라면 . 만약, blackajck에서 가능한지? 가 아니라 . | 하위카테고리 중 1개인 blackjack에서만 가능하다면 . 억지로 쓴다면 (특정카테고리)다운 캐스팅후 써야한다. | . . | . 중요3) 상카(추상체)가 잡힌이후 메서드의 추가는 (모든 카테고리 구현체 다 가능할 것 같은데, 혹시 모르니) 현재 특정상태(구현체) 1개만 호출 가능한 메서드라고 가정하고 해당 구현체에만 메서드가 생기도록 구현체변수 -&gt; 다운캐스팅 -&gt; 메서드호출() 빨간줄생성하여 코드를 짜보자. . 14 draw(Card card)가 hit와 blackjack 모든 카테고리가 호출가능할 것 같지만, 보수적으로 blackjack에서만 호출가능한 단독메서드라고 가정해놓고 짜보자. . 특정 구현체만 호출가능한 메서드를 호출하고 싶다면, 다형성으로 받던 곳에서 변수 먼저 특정 구현체Type으로 받아주고 -&gt; (= 우항 빨간줄 다운캐스팅)해서 -&gt; 단독메서드 호출()하여 -&gt;단독 빨간줄 생성해줘야한다. . 상카(추상체)가 있는 상황의 구현체(blackjack)에서, **특정 구현체만 호출가능한 메서드를 호출한다? ** . 다형성(추상체)으로 받는 변수 먼저 바꿔주고 . | ide빨간줄로 (우항에서 다운캐스팅)`하여 구현체로 받아서 단독메서드를 호출해야한다. . . . . @Test void blackjackDraw() { //1. 구현체 blackjack만의 단독메서드라고 가정 -&gt; 다운캐스팅해서 받아야한다. // final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), // Card.of(Suit.SPADES, Denomination.JACK)); final Blackjack state = (Blackjack) Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); assertThrows(IllegalStateException.class, () -&gt; state.draw(Card.of(Suit.SPADES, Denomination.TEN))); } . | | 구현체로 받은 상태에서 빨간줄 create method -&gt; 구현체에서 정의 or 추상체에서 정의 선택할 수 있다. . 다운 캐스팅 이후 구현체로 받은 상태에서 메서드 호출 -&gt; 구현체에만 메서드 생성해보자. . 구현체로 받은 상태에서 빨간줄 create method하면, 구현체에만 정의할 수 있게 선택할 수 있다. | . . | draw() 호출시 에러나야 통과하지만, 일단은 응답값으로 추상체를 넣고 정의해주자.(결국엔 추상체Type응답 -&gt; 다형성으로 응답하여 -&gt; 상호 바뀔 수 있는 카테고리내 상태 아무거나로 가능하게 바뀔 것임.) . public final class Blackjack implements State { public State draw(final Card card) { throw new IllegalStateException(); } } . | my) 인터페이스로 추상화했다면, 다운캐스팅 or 구현체변수 상태에서는 단독메서드 생성이 가능하다. . 다운캐스팅 + 구현체 변수가 거슬리지만, 예외발생으로 통과가 잘되는 것 같다. . @Test void blackjackDraw() { // final State state = Game.start(Card.of(Suit.SPADES, Denomination.ACE), // Card.of(Suit.SPADES, Denomination.JACK)); //1. 구현체 blackjack만의 단독메서드라고 가정 -&gt; 다운캐스팅해서 받아야한다. final Blackjack state = (Blackjack) Game.start(Card.of(Suit.SPADES, Denomination.ACE), Card.of(Suit.SPADES, Denomination.JACK)); //2. 다운캐스팅해서 blackjack에만 구현되도록 했지만. assertThrows(IllegalStateException.class, () -&gt; state.draw(Card.of(Suit.SPADES, Denomination.TEN))); } . . | 고민 - state가 card를 .draw()로 받아도 되느냐? . my) 상태값(인변)을 가진다-&gt; 재료로 받아서 시작되거나 재료없이 빈재료로 내부초기화되어서 시작 하며 -&gt; 추가정보 등 내부 상태값이 업데이트 되고, 그 변화된 상태값을 재료로해서 업데이트된 새 객체를 반환해주려면 상태값으로 가져야한다. . 어떤 값을 받았다 -&gt; 메서드호출로 업데이트 했다. -&gt; 인변 , 상태값으로 가지고 있어야 그것을 재료로 해서 new 새객체(업데이트재료)로 업데이트된 객체를 생성할 수 있게 된다. 상태값은 객체의 이전값을 유지 + 업데이트해서 새객체 반환을 할 수 있는 것이다. | . | . my) 요약: 클래스의 상태값은 재료로 들어와 포장되며 (가공된 뒤 적은 수로)내부에서 가지고 있어야, 변화를 반영한 새객체도 생성시에도 재료로서 생성시 쓰인다라고 할 수 있다. . 중요4 my) 추상체로서 여러 구현체 state를 가지는 state를 사용하는 순간부터 state 변화를 판단하는 정보들은 state가 내부에서 실시간 반영되는 상태값(인변)가지며 + 전략메서드를 통해 바로 바뀌거나, 필요한 추가정보를 현 정보들과 같이 판단하여 다른 구현체로 바뀐다 . player는 name과 cards를 가질 수 있다. cards에 담긴 정보를 메세지를 보내 물어봐서-&gt; 현재 state를 판단한다. | . | player는 name과 현재 상태이자 메서드호출시 다른 것으로 바뀔 수 있는state를 추상체를 가질 수 있다. state를 사용하는 순간부터 state판단에 필요한 정보들(cards 등)들을 state 내부에서 관리한다. state는 메소드를 호출을 통해 실시간으로 현재 상태에 맞는 구현체를 응답하여 상태를 바꾼다. 그 상태변화의 트리거가 추상체의 전략메서드 .draw()다. | 상태를 바꾸는 트리거 메서드는 전략메서드로서 공통이며 상태 변화를 유발하는 추가정보(card 1장)을 인자로 받을 수 있다. | . | . | . 15 blackjack상태는 끝났다면, hit상태에서 진행해보자. . 진행되는 테스트는 테메를 복사후 -&gt; 확인된 given을 유지한체 다음 상태를 유발한다 . 테메 복사후, 테스트_이름만 기존상태+트리거 로 바꾼다. . given만 hit상태를 유지 | . . @Test void hit2() { // given &amp; when : hit final State state = Game.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK)); } . | 특정상태에서 먼저, 상태변화 트리거인 메서드를 호출할 수 있는지(예외발생 안하는지)부터 고민한다. . 현재 hit상태에서의 목적: 카드1장받는 상태변화 트리거 메서드를 호출하더라도 에러안나고 호출가능 = 응답값 제대로 반환받음(isInstanceOf)증명해야한다. . 16 hit상태에서 또 draw로 카드받을 수 있나? 받을 수 있다면 단독메서드로서 다운캐스팅후 구현체 변수로 받아놓고 단독메서드로서 가정하고 개발을 시작한다. . 인터페이스의 상카를 가졌더라도, 보수적으로 구현체 단독메서드로서 일단 개발한다. . 구현체로 다운캐스팅 | 좌항을 구현체 변수로 받아주고 -&gt; 구현체 단독메서드로서 개발 | @Test void hit2() { // given &amp; when : hit -&gt; draw -&gt; hit //1. 구현체 (Hit)로 다운캐스팅한다. final Hit state = (Hit) Game.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK)); } . . | 다운캐스팅 하더라도, 우항에 체이닝으로 개발하면, 다운캐스팅 안먹고 응답되는 추상체로 메서드 개발됨. -&gt; 반드시 좌변 구현체 변수로 받아야 구현체-단독메서드 개발이 가능하다. . 구현체 변수로 변경이후 메서드 체이닝을 통해, 바로 이어서 단독메서드를 호출하여 단독메서드를 개발해보자. . 아래는 체이닝으로 했더니.. 다운캐스팅해도, 좌변 변수 받아도 단독메서드 빨간줄 생성 안됨. | . . | 참고) 어차피 직전 테메를 복붙해온 given의 hit상태가 보장되어있으니, 편하게 다운캐스팅 + 구현체 변수로 받아놓고 -&gt; 단독메서드 개발 . . . 일단 단독메서드 개발시 . 응답값은 추상체 State로 가야할 것이다. | 첫 개발이니까 return null;을 주고 실패하는 코드로 돌리자 | . public final class Hit implements State { public State draw(final Card card) { return null; } } . | blackjack과 다르게, 예외없이 다음에 올 구현체 상태를 응답해야하므로 밖에서는 state변수를 재할당시켜 업데이트해줘야한다. 하지만, 단독메서드 개발을 위해, 구현체 변수로 받아둔 state를 returnType State의 응답으로 재할당이 불가능하다. . . . . 다음 상태 트리거 전략메서드는 공통메서드, 추메라면 -&gt; 다양한 구현체 응답을 위해 State 응답이 맞으나 단독메서드 -&gt; 단독구현체로 응답하도록 임시대응 한다. . . . 중요5) 마지막 구현체(hit)의 단독메서드 구현 와중에 -&gt; 상카 아래 모든 구현체(hit, blackjack)들이 &lt;구현은 다르지만 모두 호출 가능&gt;한 공통메서드 -&gt; 인터페이스에선 추메로 추상화하고, 직접 추상화이후 @Override 직접 붙이기 . 중요6 my) 추메로 추상화해도 구상체별로 개별 구현해줘야하는데??? —&gt; 인페의 추메로 추상화 핵심은 코드 중복제거가 아니라 구현체 모두 호출가능시 구현체전용 단독메서드를 올려 다운캐스팅 제거+ 파라미터/응답/변수에서 추상체로 받아 일괄처리 가능해진다. . 16 구현체 모두가 호출가능할 수 있다면, 인페-추메(전메)로 추상화해서 -&gt; 다운캐스팅 제거후 추상체.전략메서드호출()로 호출이 가능해진다.. 그전에… . 참고) 구현체 단독메서드 -&gt; 추메/전메로 올리기 전 확인은 다이어그램+ creation mode + method로 하자 . . 현재 hit와 blakcjack의 구현체 모두 단독메서드(draw)들을 구현은 달라도 호출가능이라면 올릴 준비를 한다. | 중요7) 구현체 단독메서드 -&gt; 추메/전메로서 (선언부 시그니쳐만) 위로 올릴 때, 받는 변수/응답값/파라미터 등에 구현체가 있다면, 그것들도 추상체로 바꿔서 올려줘야한다. . 구현체의 단독메서드 -&gt; (선언부 시그니쳐만) 추상체의 전메/추메로 올릴 때 -&gt; 복붙해서 가져간 뒤 구현체로 응답이 보인다면 추상체로 바꿔줘야한다. . hit의 draw() 단독메서드를 올린다고 가정하보자. . . | 올리기 위해 추상부인 선어부만 복사 . . | 선언부 복붙후, 구현체 응답이 보이면 -&gt; 추상체로 변경 . . | . | 추메 선언부에서 추상체응답으로 바꿔두면, 기존 구현체 구상체응답으로 개별구현이 계속 허용된다. | . | . 참고) 인페의 추메/전메로 선언부를 올릴 때, 접근제한자 제거해서 default로 일단 시작하기 . . 중요) 인페의 추메/전메로 수동 추상화 올린 다음엔하고 난 뒤, usage-impl 수를 확인해서 개별 구현남아있어야하니 @오버라이딩만 직접 가서 해준다. . . . . 중요) 추상화 끝난 단독메서드는 더이상 구현체만의 단독메드가 아니다 == 다운캐스팅 안해도 (오버라이딩된) 추상체변수로 받은 상태에서 추메/전메로서 호출가능해진다. -&gt; 다운캐스팅 제거하고 추상체변수로 받도록 수정하기 . 기존 Hit 구현체에만 단독이라고 믿어서 개발했던 단독메서드가 . 추상화 -&gt; 추메/전메가 되었고 + 오버라이딩 @도 달게되었다면 | 다운캐스팅을 제거한 추상체변수로 받아 -&gt; 바로 호출이 된다. | . . . . | . 17 hit 에서 메서드 호출가능해서 -&gt; 모든 구현체 호출가능 -&gt; 메서드 추상화 해준 이후 -&gt; 응답으로서 또 여러 경우의수가 나온다. -&gt; hit + ?? -&gt; 복사해놓고 구체적으로 1case를 또 정해주고 빠른통과하도록 메서드짜기 . 참고) 다음 가능한 상태가 여러개로 나올 경우, 변화전 given현재 상태의 테메를 그만큼 복사해놓고, case를 정해놓고 진행해나가자 . . hit -&gt; draw(card) -&gt; ??? hit or stay 중에 만만한 것으로 가면 된다. hit부터 한다고 가정한다. | . | . given된 상태의 테메를 복사해서 . 예상응답값: hit | 가정인자: 다음 응답도 hit가 되도록 +1(ACE)를 draw()한다. | . . @Test void hitToHit() { // given &amp; when : hit -&gt; draw -&gt; 2,10,1 -&gt; hit State state = Game.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK)); state = state.draw(Card.of(Suit.SPADES, Denomination.ACE)); // draw호출이 가능해서 assertThat(state).isInstanceOf(Hit.class); } . | 이제 case에 맞게 메서드를 수정한다. . 일단 new Hit()만 반환해주면 된다. . . . @Override public Hit draw(final Card card) { return new Hit(); } . | . | hit담에 hit가 나오므로 통과한다. . | 18 hit에서 새로운 응답값(= 객체 상태)가 나오는 case에서는 테메이름 + case로 가정인자 조절 + expected로서 assert-isInstanceOf의 새객체.class등 미리 작성하고 하나씩 만들어나간다. . hit -&gt; hit 뿐만 아니라 다른 경우의 수인 hit -&gt; Bust를 위해 기존hit가 확인된 테스를 복사해뒀었다. -&gt; 테메이름을 변경하자 테메이름을 변경하자 -&gt; 기존 + 다음상태case | . | 주어진 hit상태에서 가정인자들도 다음상태를 유도하는 것으로 바꿔주자 . . | 예상값이 Bust의 상태객체가 나와야한다. . 빨간줄로 만들어가자 | . . | 참고) 카테고라이징(추상체 인페보유)된 상태들에 -&gt; 새 객체를 추가한다면? -&gt; class생성(fi or ab)후 해당 추상체를 impl -&gt; 그에 따라 추메/전메를 impl하여 카테고리에 추가해준다. . . . . . . Bust 상태에서 추메/전메를 impl하면 다음 상태로는 뭘 줘야할까? 끝나야할까? 일단은 return null;로 비워두기 . 아직 버스트에서 draw가능한지 / 다음 상태는 뭘로 줄지가 안정해졌으므로 구현체 단독메서드지만 일단 State응답 -&gt; return null;로 비워둔다. . . | . public final class Bust implements State { @Override public State draw(final Card card) { return null; } } . . 19 hit 상태에서 개별구현되고 있는 트리거 메서드에서 호출시 Bust가 응답되도록 메서드 로직 짜주기 . ctrl+F12를 통해, 추상체 변수.추메()로 보이는 구현체 Hit의 메서드로 찾아간다. 현재는 구현체hit에서 호출시 new Hit()만 반환하게 되어있다. | . | 중요) 개별구현중인 구현체 메서드에서 다른 구현체로 넘어가는 로직짜기 -&gt; 이전 정보를 받아와 by 재료를 생성자를 통해 현재 상태를 나타내줄 정보들을 상태값(인변)로서 내부에 가지고 있어야만 상태패턴의 상태객체다. . . @Override public Hit draw(final Card card) { // 0. 현재는 무조건 hit -&gt; draw -&gt; hit를 응답하지만 return new Hit(); // 1. if 21이 넘으면 -&gt; Bust를 응답해줘야한다. } . 20 필요에 의해 현 상태 -&gt; 다음 상태로 넘어가는데 필요한 정보들을 상태값(인변)으로 가지고 있어야하며 -&gt; 트리거 메서드에 의해 실시간으로 바뀌는 상태값으로서 State가 내부에서 직접 상태값으로 이미 가지고 있어야만 한다. . hit 상태에서 . if 21이 넘으면 bust객체로 응답 21이 넘는지는 내부에 필요정보인 cards를 들고 있어야만 가능하다. | . | . @Override public Hit draw(final Card card) { // 0. 현재는 무조건 hit -&gt; draw -&gt; hit를 응답하지만 return new Hit(); // 1. if 21이 넘으면 -&gt; Bust를 응답해줘야한다. // 2. draw()시 21이 넘는지 안넘는지 판단하기 위해서는 // -&gt; 들어오는 card에 대해, 현재 cards의 정보가 필요하다. } . | 중요) 현재 상태값(인변)으로 이미 정보를 가진다? -&gt; 상태값 필드(인변) + 생성자에서 재료받아 초기화형태가 있어야 이전 정보를 가져와 실시간 업데이트 가능한 정보로 보유한 셈이 된다. . 일단 필요한 정보로서 상태값(인변)을 private final로 가지자 . public final class Hit implements State { //3. card1장을 받기전에, [현재 상태를 상태값 cards]으로 가지고 있어야한다. // -&gt; 상태값(인변)을 가진다? -&gt; 생성자에서 재료받아 초기화한다. private final Cards cards; . . . public final class Hit implements State { //3. card1장을 받기전에, [현재 상태를 상태값 cards]으로 가지고 있어야한다. // -&gt; 상태값(인변)을 가진다? -&gt; 생성자에서 재료받아 초기화한다. private final Cards cards; public Hit(final Cards cards) { this.cards = cards; } . | 21) 상태값(정보)를 추가를 위해 필드+재료받는 생성자를 추가했더니 기존의 재료없이 기본생성자를 이용한 것들이 에러가 난다. . . 참고) new()로 생성자정의없이 기본생성자로 테스트에서 미리 많이 쓴 경우 -&gt; 재료받는 생성자가 생기는 순간 재료받는 생성자가 주 생성자 -&gt; 위에 this를 활용해서 재료 안받고 -&gt; 내부 빈 재료로 정보 초기화 하는 부새성자를 추가해주자. . 재료없는 생성자 생성방법은 -&gt; genearte 후 consructor -&gt; Select None으로 생성하면 된다. . public Hit() { } . | 재료받는 생성자가 주생성자이며, 재료 생성말고 빈 재료로 정보 초기화해주자. . 그 전에.. 사용처를 보니 new Hit()의 재료없는 기본생성자로 사용한 경우가 1usage로 현재 여기 Hit class내부 밖인 상황이다. -&gt; 기존 테스트 유지를 위한 생성자 추가 생성을 할 필요가 없는 상황임 . . | F12눌러서 따라가도 현재 상황 . | 그렇다면 굳이, 코드 유지를 위한 재료안받고 빈재료로 정보초기화해주는 기본생성자가 필요하지 않다. . | . | 중요) 추가정보(by트리거 메서드 인자)를 받아 현재 정보(인변으로 보유)를 업데이트해서 판단한다 . 일급컬렉션 정보(상태값)의 add/remove()는 내부 정보를 변화시키지말고 변화된 내부정보로 일급을 만들어 반환하여 불변 &amp;&amp; 밖에서 반환된 것을 이용 . 22) 이전 카드정보들을 상태값으로 보유하고 있는 상황에서 -&gt; 다음 상태로 가기위에 카드1장의 추가정보(메서드인자)를 받아 현재 정보(인변으로 보유)를 업데이트하자 . . . 일급 내부변수를 변경시키려한다면(list.add/remove) -&gt; 불변 일급으로 만들어서 -&gt; 변경된 list(정보)로 새 일급을 새로 만들어 반환해주면 -&gt; getter로 상태값을 열람할 필요가 없어진다. . 일급.add( )후 상태값 확인시 -&gt; 불변이면서 add가 새 일급을 응답하도록 불변 일급컬렉션만들어주기 비슷한 사례: Count VO의 +=로 내부 상태값 변화시키고 그게 필요 | 일급컬렉션의 add로 내부 상태값 변화시키고 그게 필요 | . | . | . 기존 상태값은 변경하기 전에, 복사를 먼저 한다. . 나쁜예: 기존 상태값에 .add()로 자체변경을 먼저 가하면 안된다. . | 기존 상태값은 건들지말고, 변경을 가할 복사본을 먼저 만든다 . | . | 복사된 상태값에 변경을 가한다. . public void add(final Card card) { //1. 기존 상태값을 변경없이 먼저 복사한다. (기존 상태값을 .add()로 바로 변경하지 않는다) final List&lt;Card&gt; newValue = new ArrayList&lt;&gt;(value); //2. 복사된 상태값에 증감을 가한다. newValue.add(card); } . | 증감이 반영된 복사된 새 상태값을 외부이므로 상태값이 아닌 포장된 일급객체로 응답해줘야한다. . public Cards add(final Card card) { final List&lt;Card&gt; newValue = new ArrayList&lt;&gt;(value); newValue.add(card); //3. 증감이 반영된 복사 상태값을 -&gt; **외부에서 일급**으로 쓰이니 // -&gt; [새 일급으로 포장해서 응답]** return new Cards(newValue); } . | 참고) 외부에서 내부(증감)변화의 메세지를 보낸 뒤 -&gt; 그 내부상태를 가져다 쓰고 싶다면 -&gt; 불변 포장객체로 응답해서 밖에서 사용가능하게 하라 . 23) 불변 일급컬렉션으로 증감시 새객체를 반환해주면 -&gt; 외부에서 .add 해줘도 내부만 변화되는게 아니라 외부에서는 증감이 반영된 내부정보를 포장한 일급을 받아쓴다 -&gt; 메세지 보내서 업데이트된 내부 정보에 대해 물어보기만 하면 된다. . 일급.add( 추가정보 )로 내부만 변화될 것 같지만 . 불변 일급은 내부에서 변화가반영된 새 일급을 응답해주니 그 정보를 밖에서 이용하면 된다. | . . | 이제 변화가 반영된 정보를 포장한 일급 컬렉션으로 메세지를 보내서 현재 상태를 물어보면 된다. . @Override public Hit draw(final Card card) { final Cards currentCards = cards.add(card); // 21이면 블랙잭 // 21넘으면 Bust // 21이하면 return new Hit(); } . | 변화된 정보를 담은 일급에게 21넘으면 Bust인지 물어보자. . 물어볼 때, 내부에서의 this.value는 변화가 반영된 정보상태임을 인지하자. | . . this.value나 value등을 사용하지 않는 같은 class에서 정의되었으며, 내부에서는 잘 사용되고 있는 이미 정의해놓은 메서드()를 호출해서 물음에 답(합)을 구할 수 있다. | . public boolean isBust() { return sum() &gt; 21; } . | 이제 또다른 Hit 구현체에서 정의한 draw()는 또다른 상태의 구현체도 return 메서드가 되었다. . . . | 24) 다른 구현체가 안되더라도, 같은 구현체로 응답(hit-&gt;hit) 되더라도 추가정보를 반영하여 응답된 업데이트된 정보 by 불변 일급를 담아서 -&gt; 업데이트된 구현체로 응답되어야한다. . . @Override public State draw(final Card card) { final Cards currentCards = cards.add(card); // 21이면 블랙잭 // 21넘으면 Bust if (currentCards.isBust()) { return new Bust(); } // 21이하면 return new Hit(currentCards); } . 다시 테스트로 돌아와서, hit -&gt; bust로 잘 업데이트 되는 것을 확인할 수 있다. . @Test void hitBust() { // given &amp; when : hit -&gt; draw -&gt; 2,10,10 -&gt; bust State state = Game.start(Card.of(Suit.SPADES, Denomination.TWO), Card.of(Suit.SPADES, Denomination.JACK)); state = state.draw(Card.of(Suit.SPADES, Denomination.TEN)); assertThat(state).isInstanceOf(Bust.class); } . | . 중요) 끝상태에서 -&gt; 트리거 호출시 예외발생으로 종료까지 마무리 해줘야한다. . hit or blackjack blackjack -&gt; 뽑을 시 예외발생해서 종료 | hit hit | bust -&gt; 뽑을 시 예외발생해서 종료 « 먼저 처리해주자 | blackjack? | . | . | . 25) bust에 온 상태의 테메를 복붙하여 bust까지를 세팅해놓고 -&gt; 뽑으면 종료되는 case를 처리하자. . bust까지 온 상태의 테메를 복붙한다. . 테메이름을 다음상태는 없으니 현상태 + 뽑았다정도로 짓는다. | . . | 참고) 원하는 상태까지 업데이트 트리거 메서드를 체이닝으로 호출해서 한번만 할당해놓자 . 참고) 추상체 응답Type의 구현체 상태 업데이트 트리거 메서드(draw)는 체이닝으로 원하는 상태 만들 때까지 갈 수 있다. . 재할당으로 업데이트 하는 순간 -&gt; assert문에서 람다캡처링에 걸려 메서드호출이 안되더라 . . | . bust도달까지를 given으로 주고, 추가로 카드를 하나 더 뽑기 전에 -&gt; 추상체 변수에 담기전에, 체이닝으로 트리거 메서드 호출하도록 해주자. . 참조변수 재할당시 -&gt; assertThrows의 람다캡처링 때문에 호출이 불가능 한 문제 발생 . | 기존 . State state = Game.start(Card.of(Suit.SPADES, Denomination.TWO),//2 Card.of(Suit.SPADES, Denomination.JACK));//10 state = state.draw(Card.of(Suit.SPADES, Denomination.TEN)); //10 -&gt; 여기까지 bust . | 체이닝으로 한번만 할당된 체로 bust 세팅완료 . State state = Game.start(Card.of(Suit.SPADES, Denomination.TWO),//2 Card.of(Suit.SPADES, Denomination.JACK))//10 .draw(Card.of(Suit.SPADES, Denomination.TEN)); //10 -&gt; 여기까지 bust by 메서드체이닝으로 업데이트 . | . | 테스트시 예외발생안해서 통과안되어야한다. 아직 로직을 안짠 실패하는 코드 상태이므로 . @Test void BustDraw() { // given : hit -&gt; draw -&gt; 2,10,10 -&gt; bust State state = Game.start(Card.of(Suit.SPADES, Denomination.TWO),//2 Card.of(Suit.SPADES, Denomination.JACK))//10 .draw(Card.of(Suit.SPADES, Denomination.TEN)); //10 -&gt; 여기까지 bust by 체이닝 // 예외발생해야 통과 메서드호출은, when으로 미리 호출하지 않고 -&gt; assert문에서 바로 호출한다. // 2,10,10 bust -&gt; 3 받을 시 예외발생해서 종료되어야한다. assertThrows(IllegalStateException.class, () -&gt; state.draw(Card.of(Suit.SPADES, Denomination.THREE))); } . | 중요) 추상체 변수로 받은 구현체 메서드의 로직개발시 추상체변수.메서드()의 외형이라도 현 구현체 상태에 잘맞게 ctrl+f12로 잘타고가서 개발하자 . 겉으로 보기엔 추상체 메서드를 개발하는 것 같다 | 하지만 현 구현체(Bust)를 잘타고 들어가서 개발해야한다. | . Bust의 .draw()메서드로 가서 예외발생로직을 짜주자. . . public final class B ust implements State { @Override public State draw(final Card card) { throw new IllegalStateException(); } } . | 테스트가 통과된다(호출시 예외발생으로 종료) . | 참고) 다이어그램에서, return이 Null이거나 Thr라면 물음표?가 찍혀있게 된다. ( 업데이트 안됨) . return을 억지로 new Bust()로 준 상태ㅁ . . | return null;로 준 상태 . | .",
            "url": "blog.chojaeseong.com/java/pattern/state/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/27/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD%EA%B3%BC-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4.html",
            "relUrl": "/java/pattern/state/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/27/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EB%B8%94%EB%9E%99%EC%9E%AD%EA%B3%BC-%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4.html",
            "date": " • Mar 27, 2022"
        }
        
    
  
    
        ,"post99": {
            "title": "의연방05) 코호트연구와 단면조사연구",
            "content": "R 고급 실습(cohort study with dplyr-pipeline, broom-tidy) 포함됨 | . &#54617;&#49845;&#44060;&#50836; . &#54617;&#49845;&#47785;&#54364; . Cohort study의 정의를 설명할 수 있다. . | Cohort study에서 RR과 OR을 추정하고, 위험요소와 질병의 독립성을 검정할 수 있다. . | 로지스틱 회귀분석을 이용하여 confounding과 interaction에 대한 분석을 수행할 수 있다. . | Cross-sectional study의 정의를 설명하고, cohort study와의 차이점을 설명할 수 있다. . | . &#51452;&#50836; &#50857;&#50612; . Cohort study : 연구자가 위험요소에 노출된 그룹과 노출되지 않은 그룹을 일정기간 동안 추적관찰하여, 두 그룹 간 질병 발생률(incidence)이나 질병에 의한 사망률 등을 비교하는 연구 . | Mantel-Haenszel 방법 : Confounder값 별로 나눈 stratum에서 각각 구한 OR(또는 RR)을, 그 OR의 분산의 역수를 weight로 준 weighted average(가중평균)으로 종합하는 방법 . | Logistic regression : 결과변수(반응변수, 종속변수)가 이분형인 회귀분석 . | Cross-sectional study : 위험요소 노출여부와 질병유무를 한 시점에 동시에 조사하는 연구 . | . Cohort study . &#50672;&#44396;&#46356;&#51088;&#51064;&#44284; cohort study . . 연구종류에는 대상자에게 뭔가를 가하는 Experimental(익스페리멘탈) study과 | 대상자에게 뭔가를 하지않고 관찰만하는 Observational(옵져베이셔널) study가 있다. | . | 대상자에게 뭔가를 가하지 않는 옵져베이셔널 스터디(관찰연구)에는 전향적인 연구인 Prospective study와 후향적인 연구인 Retrospective study가 있다. 전향적인 연구: 연구시점부터 무슨일이 일어나는지 관찰한다. | 후향적인 연구: 다 끝난 뒤에서 무슨일이 일어났었는지 관찰한다. | . | 전향적인 관찰연구(→) 중 적어도 2시점 이상을 관찰하는 연구를 Cohort Study(=Longitudinal Study)라 한다. | 전향이든, 후향이든 관찰연구(→, ←) 중 딱 1시점에서만 관찰하는 연구를 Cross-sectional Study(=? Case-control study?)라 한다. | . | . Cohort study . . 연구자가 위험요소 1개에 대해 노출O(group)/ 노출X(group)의 그룹을 나누고 . 위험요소 뿐만 아니라 치료법 O/X or 환자 특정 특성 O/X(ex나이)의 2그룹으로 나눌 수 있다. ex&gt; 남성/여성 | . | 실제로는 2그룹 뿐만 아니라 3그룹 이상도 나눌 수 있다. ex&gt; 20-40세 / 40-60세 / 60세이상의 3그룹 | . | . | 일정기간 동안 추적 관찰하여, 그룹간 질병 발생률(incidence)나 질병 사망률(또는 다른 이벤트) 등을 비교하는 연구 . | cohort &#49688;&#54665; 2&#44032;&#51648; &#48169;&#48277; . &#48169;&#48277;1: &#50672;&#44396;&#49884;&#51089;&#49884;&#51216;&#50640;&#49436; (&#50948;&#54744;&#50836;&#49548;&#45432;&#52636; O/X &#46321;) &#44536;&#47353;&#51012; &#47676;&#51200; &#45208;&#45576; &#46244;, &#51656;&#48337;&#48156;&#49373;&#47456;&#47564; &#44288;&#52272; . 연구 시작 시점에 위험요소(치료법, 특성) 노출O 그룹 vs 노출X 그룹을 먼저 나누고 -&gt; 각 그룹별 질병 발생/사망률 추적 관찰 예&gt; 방사능 노출이라는 위험요소에 대해, 노출시 아웃컴이 어떻게 변하는가? 원전사고가 있는 지역 = exposed group과 원전사고가 없지만, 비슷한 지역 = not exposed group 그룹을 먼저 나누고 | 질병 발생률이나 사망률을 follow up | | . | . . &#48169;&#48277;2: &#50672;&#44396;&#49884;&#51089;&#49884;&#51216;&#50640;&#49436; &#50948;&#54744;&#50836;&#49548;&#45432;&#52636; X &#51665;&#45800;&#51012; &#49440;&#53469;&#54616;&#50668;, &#45432;&#52636;&#50668;&#48512; -&gt; &#48716;&#48337;&#48156;&#49373;&#47456; 2&#44032;&#51648;&#47484; &#49692;&#49436;&#45824;&#47196; &#44288;&#52272; . 연구 시작 시점에 아직 위험요소(치료법, 특성)에 노출X 집단만 선택해놓고 -&gt; 위험요소 노출여부O/X 관찰 -&gt; 질병발생률 다시 관찰(2가지를 관찰) 이 때, 노출여부O/X는 랜덤화 하지않고, 자연스럽게 그룹이 나뉘게 한다. | . | . . Cohort study&#51032; &#51109;&#51216; . 연구 시작시점(방법1) or 연구기간(방법2) 중 위험요소 노출여부가 먼저 관측 -&gt; 그 이후에 새로 발생한 질병 관측하기 때문에 위험요소 -&gt; 질병발생의 선후가 정해져 있어서 질병발생 시점이 명확 -&gt; incidence(질병발생 속도와 관련) 추정이 가능 | 위험요소 -&gt; 질병발생의 선후가 정해져 있어서 인과관계 추론에 결정적 단서 | 위험요소 -&gt; 질병발생의 선후가 정해져 있어서 위험요소 노출O/X이후 나올 수 있는 여러 질병들을 동시에 연구 가능하다.(타겟질병말고도 다른 질병이 나타나면 연구가능) | . | . . Cohort study&#51032; &#45800;&#51216; . 질병 종류에 따라서 너무 오래걸리거나 비용이 많이 들 수 있다. 위험요소 -&gt; 질병발생의 선후가 정해져 있어서 질병 발생할때까지 계속 기다려야한다. | 위험요소 -&gt; 질병발생의 선후가 정해져 있어서 희귀병은 기다려도 몇 명 발생안하므로, 많은 수의 연구대상자가 확보되어야하고, 계속 follow up해야한다 대안: retrospective cohort study 전통적인 코호트 스터디는 전향적 연구( 연구시작 -&gt; 노출O/X그룹 -&gt; 질병발생률 관찰)인데 | 요즘은 레트로스펙티브 코호트 스터디도 소개되고 있다. | 연구시작 시점 이후 발병하는 질병을 follow 하는 것은 동일하나, | 연구시작 시점 이전 위험요소 노출O/X를 &lt;기록(데이터),기억(인터뷰)&gt;를 통해 결정하는 것 질병발생률은 prospective / 위험요소 노출여부는 retrospective로서 2가지가 섞여있는 디자인이라고도 볼 수 있다. | . | 위험요소 노출O/X를 기다렸다가 나누었다가 할 필요가 없이 바로 질병발생률만 관찰하므로 전체적인 연구기간이 짧아진다. | . | . | 위험요소 -&gt; 질병발생의 선후가 정해져 있어서 질병 발생할때까지 계속 기다리다가 위험요소 노출여부가 중간에 바뀌어버릴 수 있다. 예&gt; 흡연으로 위험요소 노출O였다가, 연구 중간에 금연해서 not/un exposed group으로 가버릴 수 있다 | 대안: 위험요소 노출여부를 여러번 측정 -&gt; longitudinal study(여러번 측정시) | . | . | . . &#53076;&#54840;&#53944; &#45824;&#54364; &#50696;&#51228; . 전형적이지 않게, 1948년 연구 시작으로 지금까지 연구중 | 위험요소가 무엇인지 모를 때 -&gt; 심혈관계 질환 발생에 어떤 것들이?? 위험요소라는 결정적인 증거가 없었을 때, 위험요소들을 모아보기 위해 연구 시작 | 식생활, 비만 등 | . | 맨 첨 시작할 때는 위험요소노출O/X 이후 -&gt; 질병발생까지 기다리는 시간이 오래 걸리니 30세 이상부터 연구 -&gt; 5000명 정도 시작 자식세대인 offspring cohort는 5000명 정도 follow 중 | 3세대는 80세 미만으로 400명 정도가 follow 중 | . | . &#53076;&#54840;&#53944;&#51032; &#47785;&#51201;: &#50948;&#54744;&#50836;&#49548; - &#51656;&#48337;&#48156;&#49373; &#49345;&#44288;&#44288;&#44228; &#53456;&#44396; . 이 상관관계를 탐구하기 위해 사용하는 메져가 무엇이 있었는가? . RR 랠러티브 리스크 for 상관관계 | OR 오즈 레이시오 for 상관관계 | attributable risk for 상관관계 | | RR과 OR을 코호트 스터디에선 어떻게 측정하는지 알아보자 . | . RR &amp; OR in cohort study . Review : RR &amp; OR . . RR을 구하려면 exposed risk(위험요소 노출 O group에서의 질병발생 확률)을 p1로 구한다. | unexposed risk(위험요소 노출 X group에서의 질병발생 확률)을 p0로 구한다. | RR는 p1/p0로 위험요소 노출X 그룹의 risk 분에 노출O 그룹의 risk로 위험요소노출 그룹별로 구한 risk들의 비율이다. | | . OR을 구하려면 exposed risk p1을 구한다 | unexposed risk p0을 구한다 | exposed Odds를 p1/1-p1으로 구한다. | unexposed Odds를 p0/1-p0으로 구한다. | OR는 위험요소 노출X 그룹의 odds 분에 노출O 그룹의 odds로 위험요소노출 그룹별로 구한 odds의 비율이다. | | . RR in cohort study . . 표에서 row/col을 보고 질병발생여부보다 위험요소 노출 여부가 있는 row별로 확인한다. . 위험요소 노출O -&gt; 질병발생 a명 / 질병발생안한 사람 b명 | 위험요소 노출X -&gt; 질병발생 c명 / 질병발생안한 사람 d명 | . | RR은 각 위험요소 노출O/X group별 risk의 비율이므로 각 group별 risk를 구한다. . exposed risk(p1) : a/a+b | unexposed risk(p0) : c/c+d | rr : p1/p0 = a/a+b / c/c+d | | OR in cohort study . . 표에서 row/col을 보고 질병발생여부보다 위험요소 노출 여부가 있는 row별로 확인한다. 2.OR는 각 위험요소 노출O/X group별 odds의 비율이므로 각 group별 odds를 구해야한다. . 각 위험요소 노출여부 group별 odds는 그룹별 risk(p)부터 구한뒤 -&gt; 그룹별 odds(p/1-p)를 구해야한다. exposed odds exposed risk(p1) : a/a+b | exposed odds(p1/1-p1) : a/a+b / (1 - a/a+b) = a/b | | unexposed odds unexposed risk(p0) : c/c+d | unexposed odds(p0/1-p0) : c/c+d / (1 - c/c+d) = c/d | | | OR = exposed odds / unexposed odds = a/b / c/d = ad/bc | | 구하고 보니 위험요소여부-질병발생여부 표에서 cross-product하면, odds ratio를 바로 구할 수 도 있다. . 이 때, a는 위험요소노출o-&gt;질병o, d는 위험요소노출x-&gt;질병x 이다. | . | &#50696;&#51228;&#47196; &#48372;&#45716; cohort study &#49549; &#50948;&#54744;&#50836;&#49548;-&#51656;&#48337;&#48156;&#49373; &#49345;&#44288;&#44288;&#44228; by RR, OR . &#49345;&#44288;&#44288;&#44228;&#51032; &#53356;&#44592;&#47484; &#48372;&#44256; &#49910;&#50612; RR, OR&#51032; &#44050; &#52628;&#51221;(&#51216; &#52628;&#51221;&#52824;) . . 표를 보고 위험요소 노출O/X(row for group) -&gt; 질병 발생여부(col) 순서로 확인한다. 아~ 위험요소 2개의 interaction문제는 아니구나 | 아~ 위험요소 1개 O/X별 -&gt; 질병발생 O/X 의 관계이므로 -&gt; 상관관계가 목적이고 -&gt; RR, OR로 계산하겠구나. 그럴려면 위험요소 O/X를 group으로 나눠서 risk/odds를 계산하겠구나 | . | RR를 각 위험요소 노출여부 그룹별(→row별) risk 비율로 구한다. . RR = exposed risk(p1) / unexposed risk(p0) = (9/9+291) / (10/10+490) = 9/300 / 10/500 = 1.5 | . | OR는 위험요소노출여부-질병여부 표에서 ad/bc의 cross-product로 빠르게 구한다 . 원래는 각 위험요소 노출여부 그룹별(→row별) odds(risk/1-risk) 비율로 구해야한다. | OR = a(oo)d(xx) / bc = 9 x 490 / 291 x 10 = 1.52 | . | &#49345;&#44288;&#44288;&#44228; &#53356;&#44592;&#47484; &#51216; &#52628;&#51221;&#54620; RR, OR&#50640; &#49888;&#47280;&#44396;&#44036; &#45908;&#54644;&#51452;&#44592; . RR, OR의 정확한 값 추정(점 추정치)는 95%신뢰구간으로 불확실성을 표시해줘야한다. | 신뢰구간의 여러계산법이 있지만, 거의다 비슷하게 나온다. | 다른 소프트웨어를 쓴다고 다른 값으로 나온다고 해도 의심안해도 된다. | 가장 많이 쓰는 방법은 Wald method(왈드 방법)인데, 좋은 방법이 아니라 계산이 쉬워서 흔하게 사용되는 것 | . &#50948;&#54744;&#50836;&#49548; &#45432;&#52636;-&#51656;&#48337;&#44284;&#51032; &#49345;&#44288;&#44288;&#44228;&#44032; &#53685;&#44228;&#51201;&#51004;&#47196; &#51080;&#45716; = 2&#44060;&#44032; &#46021;&#47549;&#51060; &#50500;&#45772;&#51648; &#53685;&#44228;&#51201; &#44160;&#51221;&#44620;&#51648; by RR,OR . RR, OR을 계산하는 이유는 위험요소 - 질병의 상관관계의 크기를 보기 위함이고, | RR, OR의 점추정에 대한 불확실성 때문에 상관관계의 크기 신뢰구간까지 더해준다. | 위험요소 - 질병의 상관관계가 통계적으로 유의한지를 2개가 독립이 아닌지로 통계적 검정까지 해줘야한다 위험요소 - 질병 상관관계는 RR, OR로 구한다며... 근데.. 신뢰구간과 독립아닌지 검정까지 해줘야해? | . | . 상관관계의 크기(RR, OR) 및 신뢰구간을 구했다면, 그래서 이것이 유의한 상관관계이냐를 독립이 아니냐의 통계적 검정(하이퍼 시시스 테스트)을 통해 증명한다. . 일반: 위험요소 - 질병간 상관관계가 있느냐? | 통계적 표현: 위험요소노출여부라는 변수와 질병발생여부라는 변수가 서로 독립이냐?(독립아니다의 대립가설을 채택해야함) | . | 위험요소 노출여부는 2그룹 이외에 3~4그룹으로도 나눌수 있지만, 질병발생여부는 무조건 2분형이어야한다. . | 위험요소여부, 질병여부 -&gt; 2개의 범주형 변수에 대한 독립성 검정은 카이스퀘어 검정을 이용한다 . H0(귀무가설): 독립이다. RR=1 or OR=1 | H1(대립가설): 독립이 아니다(상관관계 있다) RR != 1 or OR != 1 | 카시스퀘어 검정은 샘플작을 때 작동을 잘 안하므로 Fisher&#39;s exact Test를 이용한다 | . | . &#46021;&#47549;&#49457;&#44160;&#51221;(&#51088;&#49464;&#55176; &#49444;&#47749;X) . 서로 독립이다를 수식으로 나타내면 Pij = Pi x Pj로 나타낸다. 첫째 범주 i, 2번째 범주 j | . | 테스트하는 검정통계량 귀무가설 하에서의 기대도수를 이용하여 계산된 검정통계량을 사용한다(공식) | . | . R &#49892;&#49845;(&#49345;&#44288;&#44288;&#44228;&#47484; &#50948;&#54620; RR,OR,&#49888;&#47280;&#44396;&#44036;,&#46021;&#47549;&#49457;&#44160;&#51221;&#44620;&#51648; &#48152;&#50689;&#54620; &#49345;&#44288;&#44288;&#44228;) . 여러 방법이 있지만, epiR 패키지로 계산한다. . 업데이트에 민감하니, epiR패키지를 업데이를 하고 R을 최신버전으로 업그레이드까지.. 안되면 epiR 제거후 다시 설치 | . | 2by2 table을 입력할 때, 이미 형식이 정해져있다. . 위험요소가 row / 질병여부가 col에 있다고 가정하고 위험o : 질병o(a) 질병x(b) | 위험x : 질병o(c) 질병x(d) | . | 의 순서대로 c(a, b, c, d)순서대로 입력해줘야한다. my) 앞이 위험요소/뒤가 질병여부라 치면 row1: oo(a) ox(b) //row2: xo(c) xx(d)순으로 입력 | . | . | . # 아나콘다에서 epiR 검색후 r-epir 설치 . library(epiR) . Loading required package: survival Package epiR 1.0-4 is loaded Type help(epi.about) for summary information . . # 9, 291, # 10, 490 # ) # tab &lt;- c(9, 291, 10, 490) # 바로 벡터만 넣어주면 안되더라... matrix nrow=2 byrow 써서 matrix를 만들어줘야함 # ?epi.2by2 . tab &lt;- matrix(c(9, 291, 10, 490), nrow = 2, byrow = TRUE) # rownames(dat) &lt;- c(&quot;Expose+&quot;, &quot;Expose-&quot;); # colnames(dat) &lt;- c(&quot;Disease+&quot;, &quot;Disease-&quot;); # epi.2by2(dat = as.table(dat), method = &quot;cross.sectional&quot;, # conf.level = 0.95, units = 100, outcome = &quot;as.columns&quot;) tab . 9 | 291 | . 10 | 490 | . epi.2by2(dat=tab, method=&quot;cohort.count&quot;) # method 코호트.카운트가 default긴 하다. # case-control인 경우, method옵션을 바꾸면 된다. . Outcome + Outcome - Total Inc risk * Odds Exposed + 9 291 300 3.00 0.0309 Exposed - 10 490 500 2.00 0.0204 Total 19 781 800 2.38 0.0243 Point estimates and 95% CIs: - Inc risk ratio 1.50 (0.62, 3.65) Odds ratio 1.52 (0.61, 3.77) Attrib risk * 1.00 (-1.29, 3.29) Attrib risk in population * 0.38 (-1.24, 1.99) Attrib fraction in exposed (%) 33.33 (-62.19, 72.60) Attrib fraction in population (%) 15.79 (-28.34, 44.75) - Test that odds ratio = 1: chi2(1) = 0.809 Pr&gt;chi2 = 0.369 Wald confidence limits CI: confidence interval * Outcomes per 100 population units . # -&gt; RR ( 95% 신뢰구간이 자동 제공된다.) # Odds ratio 1.52 (0.61, 3.77) # -&gt; OR ( 95% 신뢰구간) # 신뢰구간은 wald방법으로 뽑아진 것 # 아래 attributable risk로 계산 한 것 # Attrib risk * 1.00 (-1.29, 3.29) # Attrib risk in population * 0.38 (-1.24, 1.99) # Attrib fraction in exposed (%) 33.33 (-62.19, 72.60) # Attrib fraction in population (%) 15.79 (-28.34, 44.75) . # Test that odds ratio = 1: chi2(1) = 0.809 Pr&gt;chi2 = 0.369 # 0.05보다 높아서 -&gt; H0 독립성 보장 -&gt; **상관관계 유의하지 않다** . my) &#52852;&#51060;&#51228;&#44273;&#44160;&#51221; -&gt; &#46021;&#47549;&#49457;&#44160;&#51221; -&gt; &#49345;&#44288;&#44288;&#44228;&#47196; &#54644;&#49437;&#54644;&#46020; &#46120; h0:(&#46021;&#47549;&#49457;)&#49345;&#44288;&#44288;&#44228; &#50976;&#51032;&#54616;&#51648; &#50506;&#45796; h1:(&#46021;&#47549;&#49457;X)&#49345;&#44288;&#44288;&#44228; &#50976;&#51032;&#54616;&#45796; . confounding&#44620;&#51648; &#44256;&#47140;&#54620; &#53076;&#54840;&#53944; &#49549; &#50948;&#54744;&#50836;&#49548;-&#51656;&#48337;&#44036; &#49345;&#44288;&#44288;&#44228; . 데이터분석 단계에서 confouning해결책 3가지 중에 2가지만 제시(후속강의에서 3번째 방법 진행) | . Stratification : 각 confounder 값 별로 strata를 나누어, 각 stratum별로 상관관계를 따로 추정한다 각 confouder값 별로 따로 추정한 상관관계를 종합하는 방법이 Mantel-Haenszel 방법 각 stratum별 RR이나 OR을 종합 | . | . | Adjustment : 기본적으로 Multivariable logistic regression를 하는 것으로 confounder를 공변량으로 넣은 회귀분석을 통해, confounder 값이 고정되어 있을 때의 X와 Y의 상관관계를 추정한다 . Multivariable logistic regression: adjusted OR . . | . | Mantel-Haenszel &#48169;&#48277; . . confounder 값별로 따로 2by2 table을 만들고 -&gt; OR(RR)을 계산한다 | 각 confounder값별로 나온 OR1,OR2 .. 를 평균을 내는데, 자신이 있는 지에 따라 분산의 역수를 weight로 준 가중 평균을 구한다. 좀 더 계산에 자신 있는 OR에 비중을 많이 둬서 평균을 구하는데 | (추정값에 대한) 자신 있다 없다는 분산(불확실성)으로 표현된다. 분산이 크면 -&gt; 불확실성 크다 -&gt; 자신 없다 -&gt; 분산의 역수 = 자신 있다 -&gt; 분산의 역수를 weight로 줘서 자신있는 곳에 비중을 둔다. | . | 예 confoudner가 성별이라고 치면, 여성에 대한 2by2 table , 남성에 대한 2by2 table을 따로 만들고, OR도 따로 구한다. | OR의 평균을 분산의 역수로 가중평균을 구한다. -&gt; 추정값에 대한 변동이 적은=추정값에 대해 불확실성이 적은 = 추정값에 대해 내가 더 자신있는 = 대체로 샘플사이즈가 더 큰 confounder의 OR을 더 많이 반영할 수 있다. | | . 계산과정을 생략하고, 전체적으로 보면 confounder 값의 갯수만큼(I개)로 2by2 table -&gt; OR이 나오며, 계산방법을 따라서 OR를 종합할 수 있다. | . | . R &#49892;&#49845;(confounding or interaction&#44620;&#51648; &#44256;&#47140;&#54620; &#49345;&#44288;&#44288;&#44228;) . # install.packages(&quot;Epi&quot;) . also installing the dependencies &#39;RcppArmadillo&#39;, &#39;cmprsk&#39;, &#39;etm&#39; . There are binary versions available but the source versions are later: binary source needs_compilation RcppArmadillo 0.10.4.0.0 0.11.0.0.0 TRUE cmprsk 2.2-10 2.2-11 TRUE Epi 2.44 2.46 TRUE Binaries will be installed package &#39;RcppArmadillo&#39; successfully unpacked and MD5 sums checked package &#39;cmprsk&#39; successfully unpacked and MD5 sums checked package &#39;etm&#39; successfully unpacked and MD5 sums checked package &#39;Epi&#39; successfully unpacked and MD5 sums checked The downloaded binary packages are in C: Users cho_desktop AppData Local Temp RtmpgfxhqH downloaded_packages . library(epiR) library(Epi) # 데이터용 library(dplyr) # 데이터정리용 . Warning message: &#34;package &#39;dplyr&#39; was built under R version 3.6.3&#34; Attaching package: &#39;dplyr&#39; The following objects are masked from &#39;package:stats&#39;: filter, lag The following objects are masked from &#39;package:base&#39;: intersect, setdiff, setequal, union . ?nickel # lung cancer (ICDs 162 and 163), nasal cancer (ICD 160) . data(nickel) # 예제데이터 dat1 &lt;- nickel head(dat1) # exposure: 위험요소 노출된 정도 -&gt; 위험요소 그룹은 2개를 넘어선다 # age1st : 위험요소에 노출된 첫번째 나이 # icd : 어떤이유로 사망했는지 알 수 있는데, 죽지 않았으면 0 # - lung cancer는 162, 163으로 코딩되어있고 / nasal cancer 는 160으로 코딩 . idicdexposuredobage1stageinageout . 3 | 0 | 5 | 1889.019 | 17.4808 | 45.2273 | 92.9808 | . 4 | 162 | 5 | 1885.978 | 23.1864 | 48.2684 | 63.2712 | . 6 | 163 | 10 | 1881.255 | 25.2452 | 52.9917 | 54.1644 | . 8 | 527 | 9 | 1886.340 | 24.7206 | 47.9067 | 69.6794 | . 9 | 150 | 0 | 1879.500 | 29.9575 | 54.7465 | 76.8442 | . 10 | 163 | 2 | 1889.915 | 21.2877 | 44.3314 | 62.5413 | . dplyr . &#47588;&#54609;(ifelse)&#54620; &#52860;&#47100;&#52628;&#44032;(mutate) . # ifelse()로 삼항연산자를 이용한 매핑을 한다. dat1 &lt;- nickel %&gt;% mutate(lung.cancer = ifelse(icd==162 | icd == 163, 1, 0)) head(dat1) . idicdexposuredobage1stageinageoutlung.cancer . 3 | 0 | 5 | 1889.019 | 17.4808 | 45.2273 | 92.9808 | 0 | . 4 | 162 | 5 | 1885.978 | 23.1864 | 48.2684 | 63.2712 | 1 | . 6 | 163 | 10 | 1881.255 | 25.2452 | 52.9917 | 54.1644 | 1 | . 8 | 527 | 9 | 1886.340 | 24.7206 | 47.9067 | 69.6794 | 0 | . 9 | 150 | 0 | 1879.500 | 29.9575 | 54.7465 | 76.8442 | 0 | . 10 | 163 | 2 | 1889.915 | 21.2877 | 44.3314 | 62.5413 | 1 | . dat1 &lt;- nickel %&gt;% mutate( lung.cancer = ifelse(icd==162 | icd == 163, 1, 0), nasal.cancer = ifelse(icd==160, 1, 0), ) head(dat1) . idicdexposuredobage1stageinageoutlung.cancernasal.cancer . 3 | 0 | 5 | 1889.019 | 17.4808 | 45.2273 | 92.9808 | 0 | 0 | . 4 | 162 | 5 | 1885.978 | 23.1864 | 48.2684 | 63.2712 | 1 | 0 | . 6 | 163 | 10 | 1881.255 | 25.2452 | 52.9917 | 54.1644 | 1 | 0 | . 8 | 527 | 9 | 1886.340 | 24.7206 | 47.9067 | 69.6794 | 0 | 0 | . 9 | 150 | 0 | 1879.500 | 29.9575 | 54.7465 | 76.8442 | 0 | 0 | . 10 | 163 | 2 | 1889.915 | 21.2877 | 44.3314 | 62.5413 | 1 | 0 | . &#50948;&#54744;&#50836;&#49548; &#48320;&#49688;&#47484; &#50672;&#49549;&#54805; -&gt; &#53945;&#51221;&#44050;&#51012; &#44592;&#51456;&#51004;&#47196; 0or1&#51032; &#51060;&#48516;&#54805;&#51004;&#47196; &#47588;&#54609;(ifelse) &#52860;&#47100; &#52628;&#44032;(mutate) . dat1 &lt;- nickel %&gt;% mutate( lung.cancer = ifelse(icd==162 | icd == 163, 1, 0), nasal.cancer = ifelse(icd==160, 1, 0), # 연속형 변수로 표현되어있던 위험요소 노출 정도를 -&gt; 특정값 기준으로 위험요소 노출여부(1or0)로 매핑 exposure.grp = ifelse(exposure &gt;= 10, 1, 0), # 위험요소노출 나이 또한 2분형 범주칼럼으로 매핑 age1st.grp = ifelse(age1st &gt;= 25, 1, 0)) head(dat1) . idicdexposuredobage1stageinageoutlung.cancernasal.cancerexposure.grpage1st.grp . 3 | 0 | 5 | 1889.019 | 17.4808 | 45.2273 | 92.9808 | 0 | 0 | 0 | 0 | . 4 | 162 | 5 | 1885.978 | 23.1864 | 48.2684 | 63.2712 | 1 | 0 | 0 | 0 | . 6 | 163 | 10 | 1881.255 | 25.2452 | 52.9917 | 54.1644 | 1 | 0 | 1 | 1 | . 8 | 527 | 9 | 1886.340 | 24.7206 | 47.9067 | 69.6794 | 0 | 0 | 0 | 0 | . 9 | 150 | 0 | 1879.500 | 29.9575 | 54.7465 | 76.8442 | 0 | 0 | 0 | 1 | . 10 | 163 | 2 | 1889.915 | 21.2877 | 44.3314 | 62.5413 | 1 | 0 | 0 | 0 | . boolean&#54805; &#52860;&#47100;&#46308; -&gt; &#51068;&#44292; factor&#54805;&#51004;&#47196; type&#48320;&#54872; by mutate_at() . 여러개의 작업에 대해 똑같은 작업을 할 때 mutate_at( vars( 변수들 나열), list(~ 개별로 적용할 작업(.)) 참고) %&gt;% 직전메서드 바로 뒤에 달아주고, 다음 메서드는 다음줄에 가능하다 | . | . dat1 &lt;- nickel %&gt;% mutate( lung.cancer = ifelse(icd==162 | icd == 163, 1, 0), nasal.cancer = ifelse(icd==160, 1, 0), exposure.grp = ifelse(exposure &gt;= 10, 1, 0), age1st.grp = ifelse(age1st &gt;= 25, 1, 0)) %&gt;% mutate_at(vars(lung.cancer, nasal.cancer, exposure.grp, age1st.grp), list(~as.factor(.))) head(dat1) . idicdexposuredobage1stageinageoutlung.cancernasal.cancerexposure.grpage1st.grp . 3 | 0 | 5 | 1889.019 | 17.4808 | 45.2273 | 92.9808 | 0 | 0 | 0 | 0 | . 4 | 162 | 5 | 1885.978 | 23.1864 | 48.2684 | 63.2712 | 1 | 0 | 0 | 0 | . 6 | 163 | 10 | 1881.255 | 25.2452 | 52.9917 | 54.1644 | 1 | 0 | 1 | 1 | . 8 | 527 | 9 | 1886.340 | 24.7206 | 47.9067 | 69.6794 | 0 | 0 | 0 | 0 | . 9 | 150 | 0 | 1879.500 | 29.9575 | 54.7465 | 76.8442 | 0 | 0 | 0 | 1 | . 10 | 163 | 2 | 1889.915 | 21.2877 | 44.3314 | 62.5413 | 1 | 0 | 0 | 0 | . &#51060;&#51228; &#47564;&#46308;&#50612;&#51652; &#48276;&#51452;&#54805;&#48320;&#49688;&#46308; &#51473; &#54596;&#50836;&#54620; &#50948;&#54744;&#50836;&#49548;1 - &#51656;&#48337;1&#51012; &#48977;&#50500; 2by2 table&#51012; &#47564;&#46304;&#45796;. . # 질병 여부 -&gt; nasal.cancer # 정해진 범주형 칼럼을 table()로 만든다. -&gt; 알아서 범주종류별로 n by m을 만들어주나보다. # -&gt; 만약, 값만 있다면? as.matrix( a,b,c,d , row=2, byrow=true) # 먼저 적어준 범주형칼럼이 row로 오게 된다? table(dat1$exposure.grp, dat1$nasal.cancer) . 0 1 0 595 41 1 28 15 . tab2 &lt;- table(dat1$exposure.grp, dat1$nasal.cancer, dnn = c(&quot;exposure.grp&quot;, &quot;nasal.cancer&quot;)) tab2 # 출력해보니, 위험요소/질병여부 oo -&gt; ox 순이 아니라 xx -&gt; xo 순으로 나온다. # -&gt; 코호트나 분석을 위해선, oo, ox xo xx 순으로 나타나도록 # --&gt; 데이터 dat1 속 factor의 level순서를 재설정해줘야한다. . nasal.cancer exposure.grp 0 1 0 595 41 1 28 15 . &#48276;&#51452;&#54805; 0,1 factor&#51032; &#47112;&#48296; &#49692;&#49436;&#47484; &#48148;&#45012;&#51452;&#44592; by relevel() + mutate() &#52860;&#47100;&#52628;&#44032; &#50808; &#52860;&#47100; &#45934;&#50612;&#50416;&#44592;&#47484; &#51060;&#50857;&#54644;&#49436; . relevel(, ref=&quot;1&quot;): reference 그룹 = 첫번째 기준그룹을 직접 지정해준다. default로 0, 1중 작은 수인 &quot;0&quot;으로 지정되어있다. | . dat2 &lt;- dat1 %&gt;% mutate(lung.cancer=relevel(lung.cancer, ref=&quot;1&quot;), nasal.cancer=relevel(nasal.cancer, ref=&quot;1&quot;), exposure.grp=relevel(exposure.grp, ref=&quot;1&quot;), ) # age1st.grp=relevel(age1st.grp, ref=&quot;1&quot;)) # 이놈은 나중에 confounder로 사용될 변수라서.. 딱히 1의 그룹을 첫번째그룹으로 안주어도 된다. head(dat2) . idicdexposuredobage1stageinageoutlung.cancernasal.cancerexposure.grpage1st.grp . 3 | 0 | 5 | 1889.019 | 17.4808 | 45.2273 | 92.9808 | 0 | 0 | 0 | 0 | . 4 | 162 | 5 | 1885.978 | 23.1864 | 48.2684 | 63.2712 | 1 | 0 | 0 | 0 | . 6 | 163 | 10 | 1881.255 | 25.2452 | 52.9917 | 54.1644 | 1 | 0 | 1 | 1 | . 8 | 527 | 9 | 1886.340 | 24.7206 | 47.9067 | 69.6794 | 0 | 0 | 0 | 0 | . 9 | 150 | 0 | 1879.500 | 29.9575 | 54.7465 | 76.8442 | 0 | 0 | 0 | 1 | . 10 | 163 | 2 | 1889.915 | 21.2877 | 44.3314 | 62.5413 | 1 | 0 | 0 | 0 | . tab2 &lt;- table(dat2$exposure.grp, dat2$nasal.cancer, dnn = c(&quot;exposure.grp&quot;, &quot;nasal.cancer&quot;)) tab2 . nasal.cancer exposure.grp 1 0 1 15 28 0 41 595 . epi.2by2(tab2) . Outcome + Outcome - Total Inc risk * Odds Exposed + 15 28 43 34.88 0.5357 Exposed - 41 595 636 6.45 0.0689 Total 56 623 679 8.25 0.0899 Point estimates and 95% CIs: - Inc risk ratio 5.41 (3.27, 8.96) Odds ratio 7.77 (3.85, 15.69) Attrib risk * 28.44 (14.06, 42.81) Attrib risk in population * 1.80 (-1.01, 4.62) Attrib fraction in exposed (%) 81.52 (69.40, 88.84) Attrib fraction in population (%) 21.84 (9.26, 32.67) - Test that odds ratio = 1: chi2(1) = 43.042 Pr&gt;chi2 = &lt; 0.001 Wald confidence limits CI: confidence interval * Outcomes per 100 population units . confounder&#47484; &#44256;&#47140; &#48143; &#48372;&#51221;(&#54648;&#46308;)&#54644;&#51452;&#47728; &#53076;&#54840;&#53944; &#49549; &#49345;&#44288;&#44288;&#44228; &#49892;&#49845; . &#54648;&#46308;1: Stratification(confounder&#47484; &#49440;&#53469;&#54980; &#44050;&#48324;(strrata)&#47196; &#45208;&#45600;&#49436; 2by2 &#53580;&#51060;&#48660;&#51012; &#48372;&#45716; &#52789;&#54868;) . age1st.grp도 0or1로 매핑했었다 -&gt; 이걸 confounder라고 가정하고, confounder값별로 나눠서 2by2 테이블을 그리는 것을 Stratification라 한다 | . &#50948;&#54744;&#50836;&#49548;1 + &#51656;&#48337;&#50668;&#48512;1 + confounder&#48320;&#49688;&#44620;&#51648; &#52628;&#52636;&#54644;&#49436; table&#51012; &#47564;&#46304;&#45796;. . tab3 &lt;- table(dat2$exposure.grp, dat2$nasal.cancer, dat2$age1st.grp, dnn = c(&quot;exposure.grp&quot;, &quot;nasal.cancer&quot;, &quot;age1st.grp&quot;)) tab3 # table()에 3번째 인자를 주면, 그 값별로 1,2번째 칼럼으로 만든 table을 나눠서 보여준다. # 3번째칼럼의 범주종류별로 3차원을 table이 완성된다고 생각하자. . , , age1st.grp = 0 nasal.cancer exposure.grp 1 0 1 1 9 0 12 269 , , age1st.grp = 1 nasal.cancer exposure.grp 1 0 1 14 19 0 29 326 . epi.2by2( tab3 ) # 데이터 자체는 위에서 만든 table과 유사하나, 아래 요약글을 보면 # RR, OR이 여러줄로 나타난다.( cf) rsk ratio = relative risk # Inc risk ratio (crude) -&gt; crude: confounder(age1st.grp)을 무시한 rr + 신뢰구간 # Inc risk ratio (M-H) -&gt; [맨틀-핸젤 방법으로 confounder별 (다른 table-&gt;) 다른 RR을 가중평균한] RR + 신뢰구간 # Odds ratio (crude) 7.77 (3.85, 15.69) # Odds ratio (M-H) 7.08 (3.45, 14.54) # -&gt; confounder 무시한 OR + cofounder별 OR구한 뒤 맨틀-핸젤방법으로 가중평균한 OR . Outcome + Outcome - Total Inc risk * Odds Exposed + 15 28 43 34.88 0.5357 Exposed - 41 595 636 6.45 0.0689 Total 56 623 679 8.25 0.0899 Point estimates and 95% CIs: - Inc risk ratio (crude) 5.41 (3.27, 8.96) Inc risk ratio (M-H) 4.78 (2.87, 7.97) Inc risk ratio (crude:M-H) 1.13 Odds ratio (crude) 7.77 (3.85, 15.69) Odds ratio (M-H) 7.08 (3.45, 14.54) Odds ratio (crude:M-H) 1.10 Attrib risk (crude) * 28.44 (14.06, 42.81) Attrib risk (M-H) * 27.34 (-32.35, 87.03) Attrib risk (crude:M-H) 1.04 - M-H test of homogeneity of incidence risk ratios: chi2(1) = 0.603 Pr&gt;chi2 = 0.438 M-H test of homogeneity of odds ratios: chi2(1) = 0.769 Pr&gt;chi2 = 0.38 Test that M-H adjusted odds ratio = 1: chi2(1) = 34.954 Pr&gt;chi2 = &lt;0.001 Wald confidence limits M-H: Mantel-Haenszel; CI: confidence interval * Outcomes per 100 population units . # [m]easure of [assoc] iation의 detail이라는 뜻. epi.2by2( tab3 )$massoc.detail$OR.strata.wald epi.2by2( tab3 )$massoc.detail$RR.strata.wald . NULL . NULL . 나는 안되네.. . . | . &#54648;&#46308;2: adjustment . confounder를 어저스트먼트(adjustment)로 보정하기 위해선 Multivaraible logistic regression이 필요하므로 logisitic regression에 대해 먼저 알아보자 | . &#49892;&#49845;&#51204; &#53076;&#54840;&#53944;-confounder &#54648;&#46308;&#51012; &#50948;&#54620; Logistic regression . 결과 변수가 이분형(binary)인 회귀분석 | 우리는 지금 코호트 속 설명변수 위험요소 노출여부에 대한 질병여부로서 결과변수를 이분형을 사용중이니 이분형 결과변수를 사용하는 logisitic regression을 적절한 회귀분석으로 사용할 수 있다 위험요소 노출여부를 x(설명변수) , 질병여부를 y결과변수(종속변수)로 로지스틱 회귀분석 모델을 잡을 수 있는데 | 회귀식의 좌항은 ln(질병발생O 그룹의 odds) = 1차 회귀식(독립변수의 linear combination)으로 성립한다. 즉, 로지스틱 회귀 모델은 질병발생O의 odds에 자연로그 취한 값을 = 독립변수들의 linear combination으로 설명하겠다는 뜻이 된다. | . | . | . . . Logistic regression&#50640;&#49436; &#44032;&#51109; &#51473;&#50836;&#54620; OR(odds rations)&#50752; B(&#54924;&#44480;&#44228;&#49688;)&#51032; &#44288;&#44228; . ln(질병O의 odds) = b0 + b1*X의 로지스틱 회귀 식에서 X=1을 대입 후, 양변에 exponentiate(e, 지수함수)을 취해주자. X=1이면, 위험요소 노출O의 상황이므로 risk를 p1이라고 표현한다(앞에서는 위험여부O일 때의 risk를 p1로 취급함) | . | X=0을 대입후, 위험요소 노출O의 상황이므로 risk를 p0이라 표현하고, 양변에 지수함수를 취한다. | OR(odds ratio)는 X=0일 때의 odds 분에 X=1일때의 odds (odds의 비율)이므로, 우항을 나눠보면 e^b1이 된다. | 결과적으로 위험요소 노출여부 변수(X)의 회귀계수B1에다가 e^x지수함수를 취해주면 -&gt; 질병에 대한 위험요소의 OR(odds ratio)다 | | . &#50516;&#44592; -&gt; &#54924;&#44480;&#44228;&#49688;&#50640;&#45796;&#44032; &#51648;&#49688;&#54632;&#47484; &#52712;&#54616;&#47732; [&#51656;&#48337;&#50668;&#48512;&#50640; &#45824;&#54620; &#54644;&#45817; &#50948;&#54744;&#50836;&#49548;&#51032; Odds ratio]&#45796; . multivariable logistic regression . 설명변수가 1-&gt; d개로 늘어났다. | 설변변수 1개일 때와 똑같은 식에다가 각 설명변수 + 곱해질 회귀변수를 더해주기만 하면 된다. | . -“Adjusted” logistic regression model이라고 부르기도 한다 . 설명변수 1개일 때의 OR &lt;-&gt; b간의 관계가 똑같다. 즉, Xj의 회귀계수에 지수함수 -&gt; 결과변수에 대한 j번째 위험요소의 OR (나머지 독립변수들은 고정) | . | . 만일 X1만 위험요소 노출여부라고 보고, 나머지 X2~Xd를 confounder들이라고 가정하면 e^b1 = 위험요소의 OR (단, 나머지 confounder 값들이 고정되어있을 때!) | . | . 주의점: sample size에 비해 너무 많은 독립변수들을 넣으면 안된다. 오버피팅: 내가 가진 데이터의 정보량에 비해, 너무 복잡한 모델(변수가 많은 모델)을 fitting하게 됨으로서, 그 데이터의 signal뿐만 아니라 데이터가 가진 noise까지 fitting에 사용되어 문제가 발생한다. | 기준은 없지만, 일반적으로 1개 독립변수 추가시 마다 환자 수 10~20명(데이터)가 필요하다 즉, 데이터 10개마다 1개 변수, 20개마다 1개 변수를 사용할 수 있다. | 예를 들어, 100명의 연구대상자를 가지고 연구한다 10으로 나누면 10개까지 독립변수 가능 | 20으로 나누면 5개까지 독립변수 가능 | . | . | . | . interaction&#47484; &#44256;&#47140; . 위험요소 X가 있을 때, X의 효과( = 질병과의 상관관계)를 OR(or RR)로 젤 수 있는데 X의 OR이, 다른 변수 A에 의해 달라질 때, X와 A간의 인터렉션이 있다고 한다. | . | X와 A간 인터렉션이 통계적으로 유의한가?도 판단해야한다. A값별 X의 y에 대한 OR이 통계적으로 다른가?를 판단해야한다. | 로지스틱 회귀분석의 옵션 중 interaction term을 넣어서 분석하면 된다. interaction term: 두 변수 X와 A를 곱한 변수(X X A) | . | . | . 왜 두 변수를 곱한 것이 interaction term이라는 로지스틱 회귀분석의 추가 변수가 되는가 앞에서 석면과 흡연간에 인터렉션이 있는가?를 본적 있다. | . | . my) confounder &#44050;&#48324;&#47196;, &#51064;&#53552;&#47113;&#49496; &#50976;&#48156; &#48320;&#49688; &#44050;&#48324;&#47196; RR, OR&#47484; &#48372;&#44256; &#44160;&#51221;&#54616;&#44256; &#54616;&#45348;.. . X석면(X1)의 효과가, A흡연(X2)에 따라 다른가?의 인터렉션에 관심있다고 가정하고 보면 로지스틱 모델 회귀식을 쓰되, 인터렉션 텀인 b3(X1 * X2)도 추가해서 작성하자 ln(질병O 그룹의 오즈) = b0 + b1X1(석면노출여부에 대한 term) + b2X2(흡연노출여부에 대한 term) + b3X1X2(두 변수를 곱한 인터렉션 term) | . | 이제 interaction을 발생시키는 A(흡연, X2)변수의 값별로 X의 OR을 봐야한다. X2 = 0 (흡연여부가 비흡연인 경우)일 때, X1의 OR(X1 앞에 달려있는 회귀계수에 지수함수 취하면 됨)을 보기 | X2 = 1 (흡연여부가 흡연인 경우)일 때, X1의 OR을 보기 X1의 회귀계수가 인터랙션 term때문에 (b1 + b3)X1으로 바뀌게 되었다. | . | | 이제 A값별 구한 OR들을 비교해보자. 비흡연자의 석면OR e^b1 vs 흡연자의 석면OR e^(b1+b3) | 만약, b3가 0이라면, 비흡연자와 흡연자의 석면OR이 동일해진다. | 즉, b3 = 0이라면 인터랙션이 없다라는 뜻이다. | . | b3 = 9인지 아닌지 검정 -&gt; 인터랙션 없는지 있는지 검정하는 것과 같다 -&gt; 흡연여부에 따른 석면OR이 변화가 있는지 없는지 검정하는 것과 같다 | | . R&#49892;&#49845;(adjustment &#48143; interaction &#44256;&#47140;&#54620; ) . logistric regression&#51012; &#51060;&#50857;&#54620; confounding&#44284; interaction &#50508;&#50500;&#48372;&#44592; . &#50948;&#54744;&#50836;&#49548;&#45432;&#52636;&#50668;&#48512;(X) &#51656;&#48337;&#50668;&#48512;(Y)&#47564; &#44256;&#47140;&#54616;&#44592; . head(dat1) . idicdexposuredobage1stageinageoutlung.cancernasal.cancerexposure.grpage1st.grp . 3 | 0 | 5 | 1889.019 | 17.4808 | 45.2273 | 92.9808 | 0 | 0 | 0 | 0 | . 4 | 162 | 5 | 1885.978 | 23.1864 | 48.2684 | 63.2712 | 1 | 0 | 0 | 0 | . 6 | 163 | 10 | 1881.255 | 25.2452 | 52.9917 | 54.1644 | 1 | 0 | 1 | 1 | . 8 | 527 | 9 | 1886.340 | 24.7206 | 47.9067 | 69.6794 | 0 | 0 | 0 | 0 | . 9 | 150 | 0 | 1879.500 | 29.9575 | 54.7465 | 76.8442 | 0 | 0 | 0 | 1 | . 10 | 163 | 2 | 1889.915 | 21.2877 | 44.3314 | 62.5413 | 1 | 0 | 0 | 0 | . # -&gt; logistic regression으로 보기 # 로지스틱 회귀분석은 glm()메서드를 이용한다. # - 칼럼만 입력하며, 자동완성 안되는 메서드임. # - family에 회귀 종류 기입 # - 회기분석은 메서드 결과를 변수에 받아놓고, summary()해서 보는게 좋다. obj1 &lt;- glm(nasal.cancer ~ exposure.grp, data = dat1, family = &quot;binomial&quot;) summary(obj1) . Call: glm(formula = nasal.cancer ~ exposure.grp, family = &#34;binomial&#34;, data = dat1) Deviance Residuals: Min 1Q Median 3Q Max -0.9263 -0.3651 -0.3651 -0.3651 2.3416 Coefficients: Estimate Std. Error z value Pr(&gt;|z|) (Intercept) -2.6750 0.1615 -16.567 &lt; 2e-16 *** exposure.grp1 2.0508 0.3584 5.722 1.05e-08 *** Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 (Dispersion parameter for binomial family taken to be 1) Null deviance: 386.72 on 678 degrees of freedom Residual deviance: 359.73 on 677 degrees of freedom AIC: 363.73 Number of Fisher Scoring iterations: 5 . &#54924;&#44480;&#48516;&#49437; &#44208;&#44284; &#48516;&#49437; . 제일 중요한 것은 Coefficents:의 회귀계수(코 에피션트) 부분이다. Coefficients: Estimate Std. Error z value Pr(&gt;|z|) b0 &lt;- (Intercept) -2.6750 0.1615 -16.567 &lt; 2e-16 *** # 상수항 b1 &lt;-exposure.grp1 2.0508 0.3584 5.722 1.05e-08 *** # b1의 추정치 . | . glm()의 결과물 obj -&gt; summary()가지고는 우리가 관심있는 measure of association인 e^b의 OR가 안보인다. exp( 각 회귀계수 Eistimaated 추정치)를 넣으면 직접계산도 가능하다. | . | . &quot;broom&quot;패키지dml tidy()를 이용하여 glm() -&gt; obj -&gt; tidy()로 회귀계수(Coefficient)들 대신 e^(b)의 OR을 구할 수 있다. | . | . . There is a binary version available but the source version is later: binary source needs_compilation broom 0.7.6 0.8.0 FALSE . installing the source package &#39;broom&#39; . library(broom) obj1 &lt;- glm(nasal.cancer ~ exposure.grp, data = dat1, family = &quot;binomial&quot;) # summary(obj1) # tidy(obj1) # 특별한 옵션을 주지 않으면, 그냥 b의 추정치가 나온다. # exponentiate = T 옵션을 주면, estimate(변수명)은 똑같지만, OR이 찍혀있게 된다. # tidy(obj1, exponentiate = T) # OR에 대한 신뢰구간(conf idential int erval)옵션까지 줄 수 있다. tidy(obj1, exponentiate = T, conf.int = T) . termestimatestd.errorstatisticp.valueconf.lowconf.high . (Intercept) | 0.06890756 | 0.1614641 | -16.567079 | 1.205399e-61 | 0.04944691 | 0.09326859 | . exposure.grp1 | 7.77439024 | 0.3584015 | 5.722172 | 1.051706e-08 | 3.78406082 | 15.55773863 | . intercept의 b0의 OR은 볼 필요 없다 | exposure.grp1(X)의 OR을 (e^회귀계수 없이) 바로 볼 수 있다. OR -&gt; estimate:7.77 | p.value -&gt; 1.051706e-08 | conf.low ~ conf.high | . | . &#50948;&#54744;&#50836;&#49548;&#45432;&#52636;&#50668;&#48512;(X)-&#48337;&#50668;&#48512;(Y) + @&#51032;&#49900;&#46104;&#45716; confounder(age1st.grp)&#44620;&#51648; &#44256;&#47140;&#54644;&#49436; &#47196;&#51648;&#49828;&#54001; &#54924;&#44480; &#47784;&#45944; . # confounder로 생각되는 변수(첫 노출 나이)를 + 공변량으로 넣어서 # -&gt; OR이 아니라 adjustment OR로 계산되도록 한다. obj2 &lt;- glm(nasal.cancer ~ exposure.grp + age1st.grp , data = dat1, family = &quot;binomial&quot;) tidy(obj2, exponentiate = T, conf.int = T) # exposure.grp1의 OR age1st.grp1dml OR이 각각 나온다. # 해석: age1st.grp1그룹의 값이 일정할 경우 -&gt; exposure.grp1의 OR이 6.86으로 추정된다 # OR의 p-value가 작고 + 신뢰구간까지 제시 . termestimatestd.errorstatisticp.valueconf.lowconf.high . (Intercept) | 0.04012872 | 0.2916948 | -11.024065 | 2.925420e-28 | 0.02151766 | 0.06810862 | . exposure.grp1 | 6.86108670 | 0.3635830 | 5.296908 | 1.177802e-07 | 3.30603509 | 13.86633962 | . age1st.grp1 | 2.31360264 | 0.3340699 | 2.510869 | 1.204342e-02 | 1.23213568 | 4.61419281 | . &#50948;&#54744;&#50836;&#49548;&#45432;&#52636;&#50668;&#48512;(X)-&#48337;&#50668;&#48512;(Y) + @ age1st.grp&#44032; confounder&#44032; &#50500;&#45768;&#46972; effective modifier&#47196; &#51032;&#49900;&#46104;&#49436; interaction term&#44620;&#51648; &#44256;&#47140;&#54644;&#49436; &#47196;&#51648;&#49828;&#54001; &#54924;&#44480; &#47784;&#45944; . # R에서는 a + b + a*b 대신 -&gt; a*b만 넣어주면, 각각의 main effect가 반영된 interaction term까지 고려 모델이 된다. obj3 &lt;- glm(nasal.cancer ~ exposure.grp * age1st.grp , data = dat1, family = &quot;binomial&quot;) tidy(obj3, exponentiate = T, conf.int = T) # 해석: interaction term을 의미하는 [exposure.grp1:age1st.grp1]는 OR이 중요한게 아니라 p-value가 중요하다. # -&gt; 3.02 x 10^-1 = 0.3 으로 유의하지가 않다. # --&gt; inetraction term(exposure.grp1:age1st.grp1)의 p-value가 유의하지 않으면 -&gt; interaction이 유의하지 않다로 해석한다. # --&gt; 첫노출나이 그룹에 따른, exposure이 바뀌는 것이 통계적으로 유의하진 않다. . termestimatestd.errorstatisticp.valueconf.lowconf.high . (Intercept) | 0.04460967 | 0.2949937 | -10.5419359 | 5.534766e-26 | 0.02364332 | 0.07594055 | . exposure.grp1 | 2.49074058 | 1.0945923 | 0.8337169 | 4.044406e-01 | 0.12977341 | 14.95214891 | . age1st.grp1 | 1.99412053 | 0.3529469 | 1.9555438 | 5.051892e-02 | 1.02220683 | 4.13027193 | . exposure.grp1:age1st.grp1 | 3.32556576 | 1.1660801 | 1.0304951 | 3.027777e-01 | 0.45951598 | 68.82990394 | . interaction term&#51060; &#50976;&#51032;&#54616;&#44172; &#45208;&#50728; &#44221;&#50864;?! &#51032;&#49900;&#48320;&#49688; 0&#51068;&#46412;&#50752; 1&#51068;&#46412;&#51032; OR&#51012; &#44033;&#44033; &#54869;&#51064;&#54620;&#45796;. . # -&gt; 만약, interaction이 유의한 경우라고 가정한다면??? # interaction을 일으키는 첫노출나이의 0일때의 OR 과 1일때의 OR을 확인해야한다. # -&gt; 각 변수들의 회귀계수를 구해야 -&gt; 각 OR을 알 수 있다. # summary(obj3) # 회귀계수를 포함한 전체 정보가 나온다. coef(obj3)# 회귀계수만 벡터정보로 얻을 수 있다. . &lt;dl class=dl-horizontal&gt; (Intercept) -3.10980466691791 exposure.grp1 0.912580089581693 age1st.grp1 0.690203115537809 exposure.grp1:age1st.grp1 1.20163981224723 &lt;/dl&gt; # -&gt; 단일 변수의 회귀계수로 OR을 구하면, interaction변수 0일 때의 OR임 exp(coef(obj3)[2]) . exposure.grp1: 2.4907405840833 # -&gt; 단일 변수의 회귀계수 + interaction term의 회귀계수의 합 에 exp exp( coef(obj3)[2] + coef(obj3)[4] ) . exposure.grp1: 8.2831215970951 &#50672;&#44396;&#50640;&#49436; Confounding&#44284; Interaction(effect modifier)&#47484; &#47564;&#45228;&#51012; &#46412; &#49444;&#44228; . 실제 연구 중 confounder와 effect modifier(interactio n유발변수)가 있다고 의심이 된다? . 일단은 confounder와 effect modifier 의심변수(A)을 무시하고, 관심있는 위험노출변수의 OR(crude OR)만 계산한다. | A변수의 값별로 따로 따로 OR (stratum-specific OR)을 계산한다. A변수=0은 a*b로 만든 회귀 모델 중 자신의 회귀계수로 OR | A변수=1은 a*b로 만든 회귀 모델 중 (자신의 회귀계수 + axb의 회귀계수)로 OR을 구했다. | . | 아래와 같이 경우를 나눠 판단한다. Stratum-specific OR들이 비슷하고 crude OR과도 비슷할 경우 confoundin이나 interactio이 없다 | . | Stratum-specific OR들은 비슷(interaction없다)하지만 crude OR과는 차이가 클 경우 A가 confounder이다. M-H OR(종합 OR)이나 adjusted OR(로지스틱 회귀를 이용)을 계산한다 | . | Stratum-specific OR이 많이 다르다 interaction이 있다. 로지스틱 회귀분석을 이용하여 interaction이 있는지 검정하고 A변수 값 별 OR을 보고한다 | . | | 2&#48516;&#54805; &#44208;&#44284;&#48320;&#49688;&#51032; &#53076;&#54840;&#53944; &#48516;&#49437; &#51228;&#54620;&#51216; . 2&#48516;&#54805; &#44208;&#44284;&#48320;&#49688;(O/X)&#47196;&#45716; &#51228;&#45824;&#47196; &#53076;&#54840;&#53944; &#48516;&#49437;&#51060; &#50504;&#46108;&#45796;? &#51060;&#49345;&#51201;&#51060;&#51652; &#50506;&#45796; . &#51060;&#48516;&#54805;&#51032; &#48156;&#48337;&#50668;&#48512; -&gt; &#48516;&#49437;&#49884;&#51216;&#50640;&#47564; &#44256;&#47140;&#54616;&#47732;, FU&#44592;&#44036; &#44592;&#51456;&#51060; &#50630;&#50612;&#49436; &#53685;&#44228;&#51201;&#51004;&#47196; invalid . 실제로 코호트 연구에서 2분형 변수가 ideal하진 않다. 그 이유는 많은 경우가 코호트 스터디 환자마다 follow up기간이 다르기 때문 . 동시에 시작해서 동시에 관찰이 끝나면 문제가 없지만 | 많은 경우, 연구 시작 -&gt; 환자 등록은 중간 중간 이루어져서 추가됨 반면, 연구가 끝나는/분석하는 시점은 딱 한 시점 | . | . 예를 들어, 1년마다 환자 등록이 각각된, 시작은 2010년 코호트 연구 . Q. 4번 환자가, 연구시점/분석시점(2015)엔 발병안했지만, 2016에 발병했다면? 어떻게 해석해야할까? | 2015 시점 분석시, 2,3번 발병 / 1,4번 발병안함 -&gt; 2016년엔 ?? . 4번이 2016년에 발병했다면?, 2번과 똑같이 3년만에 발병인데, 분석시점이후라서 카운팅 안해도 되는가? 공평한 분석이 아닌 것 같다. | . | . | FU(follow up) duration의 차이를 무시하고, 딱 분석시점에 잘라서 해도 되는 걸까?(코호트는 추가되는 환자등록이 다르고, 마지막 자르는 시점은 같음) . 각 환자별 동일한 기준으로 질병발병여부를 젠 것이 아니므로, 통계적으로 valid하지 않은 것이 된다. | . | . | . &#51060;&#48516;&#54805;&#51032; &#48156;&#48337;&#50668;&#48512; -&gt; &#48516;&#49437;&#49884;&#51216; &#44592;&#51456; FU&#44592;&#44036;&#47564; &#51228;&#51068; &#51687;&#51008;(&#51228;&#51068; &#52572;&#44540; &#46321;&#47197;)&#54872;&#51088; &#44592;&#51456;&#51004;&#47196; &#48148;&#44984;&#47732; &#53685;&#44228;&#51201;&#51004;&#47196; valid? but FU&#44592;&#51456;&#51012; &#45336;&#50612;&#44032;&#45716; &#51221;&#48372;&#46308;&#51012; &#48120;&#48152;&#50689; . Q. 발병되서 끝난 여부와는 상관없이 FU기간이 제일 짧은(분석시점에서 제일 가깝게 등록)한 환자를 기준으로 모든 환자를 똑같이 등록이후 같은 기간만 FU해서 판단한다면? 젤 짧은 4번 환자 2년 1번은 2년내 발병 X | 2번은 2년내 발병 X | 3번은 2년내 발병 O | 4번은 2년내 발병 X | . | 통계적으로는 valid하겠지만, 안타깝게도, 2번 환자가 FU기간 기준 내에선 발병X지만, 실제로 3년차에 발병O한다는 사실을 분석에 반영못하게 된다. 사실 정보를 가지고 있지만 반영 못하게 된다 | . | . &#49373;&#51316;&#51088;&#47308;&#48516;&#49437; &#44592;&#48277;&#51012; &#51060;&#50857;&#54616;&#47732;, &#53685;&#44228;&#51201; valid &amp; &#47784;&#46304; &#51221;&#48372; &#48152;&#50689; . 1번과 4번를 보면, 분석시점에 발병X뿐만 아니라 분석시점 이후에는 발병했을 수도/안했을 수 있고 모른다를 분석에 반영할 수 있다. . 코호트 분석에서 더 이상적이긴하지만, 하나의 토픽이라서 지금 다루진 않는다. | . | 만약, 생존자료분석을 이용하지 않는다면, 최근등록된 제일 짧은FU을 기준으로 삼는게 아니라 FU기간을 반영한 Person-time incidence 위주의 분석도 가능하지만 다루진 않는다 . | . &#53076;&#54840;&#53944; &#49828;&#53552;&#46356; &#45436;&#47928;&#50696;&#51228; . N E J med&#50640; &#48156;&#54364;&#46108; &#52380;&#49885;&#44288;&#47144; &#53076;&#54840;&#53944; . . 뉴질랜드 어느 마을에서 72년 4월 ~ 73년 3월까지 태어난 나이 1000명 중 90%가 참여 | 이후 5, 7, 9, 11, 13, 15, 18, 21, 26세에 FU skin-prick test: 알러지 테스트 | 폐기능 검사 | airway responsiveness : 천식관련 outcome | . | 천식 발병O/X를 나누기 위해 여러가지 outcome 정의(2분형 -&gt; 여러가지로) 발병이후 쭉 위징 : 펄시스턴스 위징 | 발병이후 쭉 위징있었다가 나아지면: 리미션 | 발병이후 쭉 위징 나았다가 다시 생기면: 릴랩스 | . | . &#44208;&#44284; &#54644;&#49437; . 모든 FU에 다 참여한 아기 -&gt; 613명 | 전체 FU에 다 참여하지 않은 아기 - &gt; 그외 로 나눠서 분석한다. | 모든 FU에 다 참여한 아기 대상으로 여러가지 정의했던 outcome(이분형X)에 대해 얼마나 발생했는지 본다 | . | . . 각 환자 특성별로 나누어 여러 outcome의 분포를 확인 | . | . &#53076;&#54840;&#53944; &#45436;&#47928;&#50640;&#49436; &#44288;&#49900;&#51080;&#45716; &#44208;&#44284;&#54644;&#49437;&#51008; OR &#48516;&#49437;&#54364;&#45796; . 2분형 결과변수는 아니였지만, 2가지 outcome만 OR을 계산하게 되었음. . | 1) 위험 요소 O인 경우가 (그렇지 않은 경우에 비해) OR이 몇 배고, 2) P value 통계적으로 유의한지 보고 3) 점추정값의 신뢰구간도 보자 . | 4) 해석은 (위험요소 O)~ 한 경우가 ~하지 않는 경우에 비해 outcome O될 확률이 OR 배였다 Persistence하고 Relapse에 대해 OR을 계산했는데, | 21세에 스모킹 O인 그룹이 (그렇지 않은 그룹에 비해) Persistence가 있을 오즈가 2.05배였다 | . | . 다변량 모델 = 컨파운딩 등을 보기 위해(나머지 설명변수 고정상태를 만드는 모델) OR이 유의한 설명 변수만 집어넣고 다시 모델을 만든 것. 각 변수에 대해 나머지 변수는 고정일 때로 해석가능하다 | (다변량모델에서, 나머지 변수들이 고정되어있는데도~) 21세 흡연여부가 -&gt; OR이 1보다 높고 통계적으로 유의하다. | . | . Cross-sectional Study . 딱 1시점에서 데이터를 보고 위험요소 노출 O/X 여부 및 질병 발병 O/X 여부를 보게 됨 변화하는 관심 인구집단의 한 시점의 스냅샷으로 | incidence(속도)를 볼 수 없고, prevalence만 보게 된다. 위험요소가 먼저였는지, 질병이 먼저였는지 알 수 없음 | . | . | . bias &#49373;&#44600; &#54869;&#47456;&#51060; &#45458;&#45796; . Temporal bias . 템포럴 바이러스는 위험요소노출 여부 vs 질병여부 어떤 것이 먼저인지 알 수 없을 때 오는 bias다 예를 들어, 운동 여부 vs CHD 발병 여부 CHD진단 받은 환자들이 운동을 늘렸을 가능성이 있다. 그 때 Crross-section study에 잡히면 ? 상관관계가 과소추정된다. | . | 운동량 적을 수록 -&gt; CHD 많이 발견되는 상관관계를 발견했을 지라도 운동량 적 -&gt; CHD 많? or CHD 많 -&gt; 운동량 적어짐 선후관계를 알 수가 없다 | . | . | . | . survival/selection bias(prevalence-incidence bias) . 서바이벌 바이어스 / 셀렉션 바이어스 / 프리벌런스-인시턴스 바이어스 라고도 한다. 위험요소 노출후 (질병O는 물론이고) 금방 사망해버린 환자들은 연구에 포함되기가 어렵다에서 오는 바이어스다 | 예를 들어, 흡연 -&gt; 폐기종 환자에 있어서 흡연에 의해 폐기종 발생 환자들은 비흡연 -&gt; 폐기종 환자들에 비해, 빨리 사망함 -&gt; Cross-sectional study에 포함되기 힘들어진다 | 살아남아 Cross-sectional study에 포함된 폐기종 환자들의 흡연률(흡연노출여부O)는, 전체 폐기종 발병 환자의 실제 흡연률보다 낮아지게 됨 -&gt; 흡연과 폐기종의 상관관계를 과소추정하게 된다. | . | . | . &#54620;&#44228;&#51216;&#51060; &#47566;&#51008; &#50672;&#44396; . bias를 많이 가질 수 밖에 없는 study이므로, Cross-sectional Study의 결과는 다른 연구 시간의 선후관계를 가진 파악 다른 연구로 가기 전의 전 단계로서, 살펴볼 가치가 있는 가설인지 확인용으로 쓴다. | . &#53356;&#47196;&#49828;-&#49465;&#49492;&#45328;&#50640;&#49436;&#51032; RR &amp; OR . 크로스-섹셔널 연구에서는 incidence 계산 불가 -&gt; risk 계산 불가 -&gt; Relative Ratio의 RR대신 Prevalence Ratio로 부른다. | OR에 들어가는 p1, p0가 risk가 아닌 prevalence -&gt; prevalence OR 로 부른다. | . &#51221;&#47532;&#54616;&#44592; . Cohort study는 연구자가 위험요소에 노출된 그룹과 노출되지 않은 그룹을 일정기간 동안 추적관찰하여, 두 그룹 간 질병 발생률 (incidence)이나 질병에 의한 사망률 등을 비교하는 연구이다 | Cohort study에서는 RR과 OR을 추정하고 신뢰구간을 계산할 수 있다 | Confounding이 있을 경우 Mantel-Haenszel 방법으로 OR을 계산하거나 로지스틱 회귀분석으로 Adjusted OR을 계산할 수 있다 | Interaction이 있을 경우 로지스틱 회귀분석으로 interaction의 유의성을 검정하고 stratum-specific OR을 계산할 수 있다 | Cross-section study에서는 prevalence ratio와 prevalence OR을 계산할 수 있다 | . cohort study &#50672;&#49845;&#47928;&#51228; . Q1. &#45796;&#51020; &#51473; cohort study&#50640; &#45824;&#54620; &#49444;&#47749;&#51004;&#47196; &#51201;&#51208;&#54616;&#51648; &#50506;&#51008; &#44163;&#51008;? . 관찰연구의 일종이다. 연구는 실험연구 vs 관찰연구로 나뉘는데 관찰만 한다. cf) 실험연구 아니면 관찰연구 -&gt; 현재시점 기준으로 이후(전향적) 아니면 이전(후향적) 관찰 -&gt; 이후든 이전이든 1시점만(cross-sectional) 보냐 vs 2시점 이상(Longitudinal-이후Cohort/이전Case-control)보냐 | . | . | 여러개의 질병을 동시에 연구할 수 없다. 위험요소 -&gt; 질병발생의 선후가 정해져 있어서 질병발생 시점이 명확 -&gt; incidence(질병발생 속도와 관련) 추정이 가능 | 위험요소 -&gt; 질병발생의 선후가 정해져 있어서 인과관계 추론에 결정적 단서 | 위험요소 -&gt; 질병발생의 선후가 정해져 있어서 위험요소 노출O/X이후 나올 수 있는 여러 질병들을 동시에 연구 가능하다.(타겟질병말고도 다른 질병이 나타나면 연구가능) | . | 희귀병은 연구하기 어렵다. . 코호트는 위험요소 -&gt; 질병발생의 선후가 정해져 있어서 희귀병은 기다려도 몇 명 발생안하므로, 많은 수의 연구대상자가 확보되어야하고, 계속 follow up해야한다 | 대안: retrospective cohort study 연구시작 시점 이후 발병하는 질병을 follow 하는 것은 동일하나, | 연구시작 시점 이전 위험요소 노출O/X를 &lt;기록(데이터),기억(인터뷰)&gt;를 통해 결정하는 것 질병발생률은 prospective / 위험요소 노출여부는 retrospective로서 2가지가 섞여있는 디자인이라고도 볼 수 있다. | 위험요소 노출O/X를 기다렸다가 나누었다가 할 필요가 없이 바로 질병발생률만 관찰하므로 전체적인 연구기간이 짧아진다. | 위험요소 -&gt; 질병발생의 선후가 정해져 있어서 질병 발생할때까지 계속 기다리다가 위험요소 노출여부가 중간에 바뀌어버릴 수 있다. 예&gt; 흡연으로 위험요소 노출O였다가, 연구 중간에 금연해서 not/un exposed group으로 가버릴 수 있다 | 대안: 위험요소 노출여부를 여러번 측정 -&gt; longitudinal study(여러번 측정시) | . | . | . | . | 위험요소 노출부터 질병 발병까지의 기간이 너무 긴 질병은 연구하기 어렵다. . | 정답 : 2 | 해설 : Cohort study에서는 여러개의 질병을 동시에 연구하는 것이 가능하다. | . Q2. &#45796;&#51020;&#51008; &#50612;&#46500; cohort study&#50640;&#49436; &#55137;&#50672;&#44284; CHD&#51032; &#44288;&#44228;&#47484; &#50508;&#50500;&#48372;&#44592; &#50948;&#54644;, &#55137;&#50672;&#51088; 300&#47749;, &#48708;&#55137;&#50672;&#51088; 500&#47749;&#51012; 10&#45380;&#44036; &#52628;&#51201;&#54616;&#50668; CHD &#48156;&#48337; &#50668;&#48512;&#47484; &#51312;&#49324;&#54620; &#44163;&#51060;&#45796;. . . RR(relative risk) = (10/300)/(10/500) = 1.67 | OR(odds ratio) = (290×10)/(490×10) = 0.59 | 이 데이터에서는 흡연자의 CHD 발병 위험이 더 높다. | 흡연 여부와 CHD 발병 여부가 독립인지 검정하려면 카이제곱 검정을 시행하면 된다. | &#54400;&#51060; . row -&gt; col 순으로 보고 위험요소2개 = interaction문제인지 / 위험요소1 질병여부1의 상관관계 문제인지 확인한다 위험요소노출O/X -&gt; 질병여부O/X 의 상관관계는 위험요소O/X에 따라 group을 나눈 -&gt; RR/OR로 판단한다. | . | 상관관계를 위한 RR, OR계산은 위험요소노출 O/X group별로 나눈 질병 risk인 p1/p0를 계산한다 . p1(위험요소 노출O risk) = 10/10+290 | p0(위험요소 노출O risk) = 10/10+490 | rr = p1/p0 = 500/300 = 1.67 | . | OR계산은 위험요소노출 O/X group별로 나눈 질병 odds(risk / 1-risk)를 구한뒤 비율을 구해야하지만 위험요소-질병 표에서는 a(oo)d(xx) / bc로 계산해버리면 된다. . a(oo) = 흡연-&gt;발병 = 10 | d(xx) = 흡연x-&gt;발병x = 490 | bc = 반대 대각선 = 10 x 290 | . | 추가적으로 범주(위험요소 노출O/X)형 범주형(질병O/X) -&gt; 독립성 검정으로 상관관계 없음을 검정할 수 도 있다.(카이제곱 검정) | 정답 : 2 | 해설 : 위의 표는 disease positive가 왼쪽이 아닌 오른쪽 열에 배치되어있다. 이를 일반적인 형태(disease positive가 왼쪽 열, exposed가 위쪽 행)로 바꾼 후 cross-product 공식으로 OR을 구하면 (10×490)/(10×290) = 1.69이다. | .",
            "url": "blog.chojaeseong.com/r/r%EA%B3%A0%EA%B8%89/dplyr/broom/tidy/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EC%BD%94%ED%98%B8%ED%8A%B8/cohort/%EB%8B%A8%EB%A9%B4%EC%A1%B0%EC%82%AC%EC%97%B0%EA%B5%AC/cross-sectional/2022/03/25/%EC%9D%98%EC%97%B0%EB%B0%A905)-Cohort-study-&-Cross-sectional-study.html",
            "relUrl": "/r/r%EA%B3%A0%EA%B8%89/dplyr/broom/tidy/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EC%BD%94%ED%98%B8%ED%8A%B8/cohort/%EB%8B%A8%EB%A9%B4%EC%A1%B0%EC%82%AC%EC%97%B0%EA%B5%AC/cross-sectional/2022/03/25/%EC%9D%98%EC%97%B0%EB%B0%A905)-Cohort-study-&-Cross-sectional-study.html",
            "date": " • Mar 25, 2022"
        }
        
    
  
    
        ,"post100": {
            "title": "의연방04) 컨파운딩과 상호작용",
            "content": "&#53685;&#44228;&#51201;&#52628;&#47200; &#51473;&#50836;&#44060;&#45392; 3&#44032;&#51648; &#51473; &#45208;&#47672;&#51648; 2&#44032;&#51648; . bias . | Confounding . | Interaction | &#51452;&#50836;&#50857;&#50612; . Confounding : 위험요소(X)와 질병(Y) 둘다와 상관관계가 있으면서, 위험요소의 결과도, 질병의 결과도 아닌 변수 . | Interaction : X가 Y에 끼치는 효과가, 다른 변수 A값에 따라 달라지는 경우 X와 A간에 interaction이 존재한다고 말한다. . | Additive model : 위험요소 X와 A에 둘다 노출되었을 때의 효과는, X에 노출되었을 때의 효과와 A의 노출되었을 때의 효과의 합이라는 모델 . | Multiplicative model : 위험요소 X와 A에 둘다 노출되었을 때의 효과는, X에 노출되었을 때의 효과와 A의 노출되었을 때의 효과의 곱이라는 모델 . | . Confounding . Association vs. causality . 상관관계가 인과관계를 의미하지 않는다. . 연구시, 상관관계가 발견되면, 이것이 진짜 상관관계인지 vs sampling error로서 우연(random error)이나 잘못된 연구디자인에 의한 에러(systematic error, bias)인지 먼저 판단해야한다 | . | 상관관계가 진짜다 판단된 경우에는 상관관계-&gt;인과관계로 연결되는지 vs 인과관계가 아닌 confounding 때문에 생겨난 -&gt; 상관관계인지 판단해야한다 | . | &#50696;&#49884; . . 커피섭취 - 췌장암의 상관관계 관측된 상태(진짜다)다 -&gt; 2가지 설명가능한 상황(가능성)이 존재하게 됨. . 커피섭취가 -&gt; 췌장암을 일으킨다(인과관계가 있다) | 커피섭취가 -&gt; 췌장암을 일으키진 않는데, 흡연이라는 confounder가 있어서 2가지를 동시에 발생시키다보니, 2가지가 상관관계가 있는 것처럼 보이게 만들었다 흡연 -&gt; 커피섭취 증가 | 흡연 -&gt; 췌장암 증가 (인과관계가 없음에도 불구하고,)커피 -&gt; 췌장암 증가의 상관관계를 높였다. | . | . | | my) . A -&gt; B 상관관계를 보면, C-&gt;A, C-&gt;B의 Confounding을 생각하자 | A -&gt; B 상관관계를 보면, Confounding생각후, 진짜 인과관계도 있으니 총 2가지 가능성을 생각하자 | . | . Confounding . X : 위험요소(risk factor) 또는 치료법 등 독립변수(설명변수) | Y : 질병이나 질병으로 인한 이벤트 등 결과변수 | C : confounder | . 여기에서는 편의상 X, Y, C가 모두 이분형 변수인 예제를 사용했으나, . 연속형 변수, 순서형 변수, 범주가 3개 이상인 변수들에 대해서도 모두 성립한다 . . 다음의 관계가 성립할 경우, C는 confounder이다. . C와 Y가 상관관계가 있으나, C가 Y의 결과는 아니다 | C와 X와 상관관계가 있으나, C가 X의 결과는 아니다 | . 즉, C가 x, y 모두와 각각 상관관계가 있으나, C가 x-&gt;c, y-&gt;c의 결과는 아닌 경우 . 가장 대표적인 경우가 C-&gt;X, C-&gt;Y의 인과관계인 경우다. | 또, C = X 상관관계 , C-&gt;Y의 경우도 있다. | 또, C = X 상관관계 , C-&gt;Y + X = Y 상관관계인 경우도 있다. | Confounding&#51064; &#44221;&#50864;&#51032; &#50696;&#49884; . C-&gt;X, C-&gt;Y&#51032; &#51064;&#44284;&#44288;&#44228; . . X(독립변수): 흰머리 -&gt; Y(결과변수): stroke에 대해 C -&gt; 흰머리, C -&gt; stroke를 일으키는 confounder 나이를 생각해보자. 흰머리가 많을수록 stroke가 많을 수도 있으며 상관관계는 있는 것처럼 나타난다.하지만, 둘간의 인과관계는 없다 | 나이라는 confounder가 C-&gt;X, C-&gt;Y로 인과관계로 영향을 끼치기 때문에 보이는 가짜 인과관계(보이는 상관관계)이다. | . | 그리고 X -&gt; Y인과관계인 경우도 생각하자. | | . C = X &#49345;&#44288;&#44288;&#44228; , C-&gt;Y &#51064;&#44284;&#44288;&#44228;&#51032; &#44221;&#50864; . . X(독립변수): 자녀의수 -&gt; Y(결과변수): 유방암에 대해 C =상관관계= 자녀의수, C -&gt; stroke를 일으키는 confounder 나이를 생각해보자. 자녀의수가 많을수록 유방암가 많을 수도 있으며 상관관계는 있는 것처럼 나타난다.하지만, 둘간의 인과관계는 없다 | 나이라는 confounder가 C=상관관계=X, C-&gt;Y 인과관계로 영향을 끼치기 때문에 보이는 가짜 인과관계(보이는 상관관계)이다. | . | 그리고 X -&gt; Y인과관계인 경우도 생각하자. | | . C = X &#49345;&#44288;&#44288;&#44228; , C-&gt;Y + X = Y &#49345;&#44288;&#44288;&#44228;&#51064; &#44221;&#50864; . . X(독립변수): 소득 -&gt; Y(결과변수): CHD에 대해 C =상관관계= 소득, C -&gt; CHD, 소득=상관관계=CHD를 일으키는 confounder 흡연를 생각해보자. 소득가 많을수록 CHD가 많을 수도 있으며 상관관계는 있는 것처럼 나타난다(소득은 모든 질병과 상관관계 있는 것처럼..많은 confounder가 운동/영양상태 등 존재).하지만, 둘간의 인과관계는 없다 | 흡연라는 confounder가 C=상관관계=X, C-&gt;Y 인과관계로 영향을 끼치기 때문에 보이는 가짜 인과관계(보이는 상관관계)이다. | . | 그리고 X -&gt; Y인과관계인 경우도 생각하자. | | . Confounder&#44032; &#50500;&#45772; &#44221;&#50864; . c&#45716; x,y &#47784;&#46160;&#50752; &#44288;&#44228;&#44032; &#51316;&#51116;&#54644;&#50556;&#54620;&#45796;. . . C는 x와 y, 모두와 (상관,인과)관계가 있어야한다 둘 중에 하나와는 관계가 없는 경우, coufounder라 할 수 없다. | high cholesterol diet는 X인 흡연과 상관(인과)관계가 없으므로 confounder라 할 수 없다. | no fruit은 비타민C부족을 거쳐야만 괴혈병과 관계를 가진다. C와 y사이 직접적인 관계는 없으므로 confounder라 할 수 없다. | . | c&#45716; x or y&#51032; &#44208;&#44284;&#50668;&#49436;&#45716; &#50504;&#46108;&#45796;. . . c는 x or y의 결과여서는 안된다. x가 C에 영향을 끼치는 경우, C는 confounder가 될 수 없다. | 흡연 -&gt; CHD 영향끼치는 기전 중 1가지가 fibrinogen이라는 물질의 함량을 높여서 CHD에 영향을 준다고 알려져있는데 x -&gt; C가 성립하므로 C는 confounder가 아니다. x -&gt; C -&gt; y가 성립하는 경우, 특별히 mediate라는 용어를 쓰기도 한다. | . | . | x:locomotor disease(운동기능장애)와 y:호흡기질환와의 상관관계를 본다고 할 때, 상관관계가 있는 것처럼 보일 수 있는데, C:입원이라는 factor때문에 그렇게 보일 수 있는데 x가 있어도 C입원 할 가능성이 높아지고, y가 있어도 C입원 할 가능성이 높아져서 confounder처럼 x,y의 상관관계가 있는것 처럼 보이기도 하는데 근데, C가 x,y에 영향을 주는게 아니라 x,y의 결과 -&gt; C가 된다면, 특별이 confounder가 아니라 collider라고 부른다. | . | . | . | &#44536;&#47111;&#45796;&#47732;? &#49892;&#51228; &#50672;&#44396;&#49884;&#50640;&#45716;? &#47924;&#50631;&#51012; confounder&#47484; &#48400;&#50556;&#54624;&#44620;? . X, Y 둘 다와 상관관계가 의심되는 변수 C가 있을 때, 이 변수 C가 X의 결과가 아니고, C가 Y의 결과가 아닌 것이 확실하면 -&gt; C가 confounder일 가능성을 염두에 두고 연구를 해야 안전하다. | . | 따라서 어떤 질병의 알려진 위험요소(risk factor)들은 모두 potential confounder이다 | 연령과 성별 역시 항상 potential confounder로 고려하는 것이 안전하다 어떤 종류의 위험요소(X)도 연령/성별에 영향 안받기 힘듬 | 어떤 종류의 질병(y)도 연령/성별에 영향 안받기 힘듬 | . | . Confounder&#49884; &#50948;&#54744;&#50836;&#49548;-&#51656;&#48337;&#44036;&#51032; RR&#44228;&#49328; &#49892;&#51204; &#50696;&#51228; . C&#50630;&#51060; RR&#44228;&#49328;: &#50612;&#46500; &#50948;&#54744;&#50836;&#49548;&#50752; &#51656;&#48337;&#51032; &#44288;&#44228; (&#50696; : &#55137;&#50672; &#8594; &#54588;&#48512;&#51656;&#54872;) . . 위험요소 - 질병과의 관계를 조사하였다. . 위험요소노출O 110명, 그 중 질병O 81명 (1) 위험요소 노출O의 경우의 Risk 계산 -&gt; 81/110 = 0.7364 | . | 위험요소노출X 210명, 그 중 질병O 28명 (2) 위험요소 노출X의 경우의 Risk 계산 -&gt; 28/110 = 0.1333 | . | (3) 랠러티브 리스크(RR) : (1) / (2) = 위험요소 노출O의 경우의 Risk / 위험요소 노출X의 경우의 Risk = 0.7364 / 0.1333 = 5.52 | . | (4) RR 해석: RR가 1보다 훨씬크다 -&gt; 위험요소 - 질병간의 상관관계가 강한 상관관계가 있다. 왜냐면? RR=5.52 -&gt; 위험요소노출O의 경우, 질병O의 확률이 5.52배 높아지기 때문 | . | . &#51060;&#48516;&#54805; &#48320;&#49688;&#51064; Confounder C&#44032; &#51080;&#45796;&#44256; &#54616;&#51088; (&#50696; : &#49457;&#48324;) . . . (1) row:위험요소 노출O/X별 col:질병O/X의 행렬표에 더 높은레벨의 칼럼에 Confounder=0/1 (X/O)를 추가한다 | (2) C=0인 경우만 먼저, RR을 계산한다. (분모분자 다 바뀜) (2-1) C=0에서 위험요소 노출O의 Risk = 질병O/위험요소O = 1 / 1+9 = 0.1 | (2-2) C=0에서 위험요소 노출X의 Risk = 질병x/위험요소X = 20 / 20+180 = 0.1 | (2-2) C=0에서 RR = 0.1/0.1 = 1 | . | (3) C=1인 경우만 RR을 계산한다 80/80+20 (위O Risk) / 8/8+2(위X Risk) = RR = 0.8/0.8 = | . | (4) C=0의 RR 과 C=1의 RR을 비교한다 | (5) C에 따른 RR을 비교한 해석: `C에 노출되지 않은경우와 C에 노출된 경우, 위험요소-질병간의 상관관계가 1로서 없는 것으로 나온다. 노출O/x 각 그룹의 질병risk가 같다는 얘기로서, 위험요소가 질병과 상관관계가 없다고 나온다. | confounder를 고려하지않고보면, 강한상관관계가 있는 것처럼 보였는데, confounder별로 따로 떼놓고 보면,상관관계가 없었다. -&gt; 진짜는 상관관계없는 것 | . | . (&#49345;&#44288;&#44288;&#44228;&#47484; &#51080;&#50612;&#48372;&#51060;&#44172; &#47564;&#46300;&#45716; &#45208;&#49244;) Confounding&#51012; &#45796;&#47336;&#45716; &#48277; . &#46356;&#51088;&#51064; &#45800;&#44228;&#50640;&#49436; &#47004;&#45924;&#54868;(c-&gt;x&#45130;&#44592;), &#47588;&#52845;(c-&gt;y&#45130;&#44592;) . 디자인단계에서 Randomize를 통해 confounder를 제거한다. 랜덤화: 각 연구대상자의 X값(위험요소노출 O/X 여부)자체를 랜덤으로 배정한다. C가 되려면 x,y모두와 관계가 있어야하는데, C-&gt;X로 가는 관계를 랜덤화로 끊어버려, c 성립조건을 없애버림 | . | 매칭: 질병o와 질병x를 각각 표집할 때, 연령/성별과 같은 confounder들을 미리 비슷하게 맞춰서 뽑는다. C-&gt;y로 가는 관계를 매칭으로 끊어버려, c 성립조건을 없앤다. | . | | . . &#45936;&#51060;&#53552; &#48516;&#49437; &#45800;&#44228;&#50640;&#49436; confounding&#48372;&#51221; . Stratification (&#49828;&#53944;&#47112;&#51060;&#46972;, &#49828;&#53944;&#47112;&#51060;&#54000;&#54588;&#52992;&#51060;&#49496;) . C=0, C=1처럼 각 Confounder값별로 스트레이라(Strata)를 따로 만들어서, 그 안에서 상관관계를 따로 따로 추정 아까의 경우, 상관관계를 RR을 이용해서 따로 추정했었음. | . | strata별로 RR 추정값이 비슷하고, 전체 RR과 비슷하면 -&gt; confounding이 없다고 생각할 수 있다. RR을 이용하거나 OR(오즈레이시오)를 이용해서 확인하면 된다. | . | | confounder의 값별로 RR or OR이 많이 다르다 -&gt; interaction(인터랙션)이 있다는 뜻 -&gt; interaction을 고려한 연구를 해야한다. | | . Adjustment (&#50612;&#51200;&#49828;&#53944;&#47676;&#53944;) . confounder를 공변량으로서, 회귀분석안에 집어넣는 것 회귀분석의 설명변수로서 confounder를 포함시키는 것 | . | 회귀분석에서 나온 X의 회귀계수의 해석: 나머지 confounder들이 고정되어있을 때, 나오는 X가 -&gt; Y에 끼치는 영향 멀타이 베리어블 애널리시스 했다.(멀타이 배리어블 모델을 썼다.) | 어저스티드 어날리시스를 했다.라고도 표현한다. | . | 이 분석(confounder들을 설명변수에 넣은 회귀분석을 하되, 주 목적은 X-&gt;Y, 나머지 고정)에서도 X-Y상관관계가 유의하다면, X가 Y에 대한 independent effect가 있다(역학용어, 통계의 독립성과는 다름)고 표현한다. confounder를 공변량으로 넣은 어저시티드 어날리시스의 결과와 공변량으로 넣지 않은 언어저스티드 어날리시스의 결과를 side by side로 나란히 보고하는 것이 좋다. 본 독자가 직접 판단할 수 있게 된다. | . | . | . Propensity score analysis(&#54532;&#47196;&#54172;&#49884;&#54000; &#49828;&#53076;&#50612; &#50612;&#45216;&#47532;&#49884;&#49828;) . causal inference(코절 인퍼런스)라고 불리는 더 넓은 범위의 통계적방법론의 일부이다. | 데이터를 잘 가공해서 -&gt; X에 랜덤화를 적용시킨 것 같은 virtual data를 만들어 X-Y분석 나중에 다른 강의에서 소개 | . | . Confounding &#45796;&#47344; &#46412; &#51452;&#51032;&#51216; . 없애는 것만이 능사가 아니다. . 많은 경우 꼭 없앨 필요없다. | 어떤 경우 이용을 할 수 도 있다. . 예를 들어, X - Y 상관관계가 관측된 상황이라고 치자. | X가 Y를 일으키는 인과관계는 없고, C라는 confounder에 의해 그렇게 관측될 뿐이다 라고 할지라도 만약, C(confounder)가? -&gt; my) Y가 관측이 굉장히 어려운 factor라면? | 역으로 X를 이용해서 Y질병이 발생하기 쉬운 사람들을 찾아낼 수 있다??? | y질병고위험군을 찾기위해, C땜에 생긴 상관관계라고 할지라도 -&gt; C덕분에 X를 이용해 Y를 발견할 수 있게 되는 것이다. | my) 찾기 힘든 y라면 -&gt; C에 의해 보이기용 X-Y 상관관계가 생기고 -&gt; X를 이용해서 Y 발견이 가능해진다. -&gt; C가 만들어낸 보이기용 상관관계가 인과관계가 아니더라도 유용하게 쓰임. | . | . | confounding이 오류가 아닌 그 자체로 이해되어야하는 상황도 있다. . X인종-Y심혈관계질환의 관계를 볼 때, confounder로서 비만도를 고려하게 되는데 X아시아인 - C비만도 낮은 경향 + C비만도 - Y심혈관계질환과 관계가 있음 -&gt; 비만도는 확실한 confounder임 | 그런데, C비만도의 효과를 제거하여 C비만도가 똑같은 아시아인vs백인을 비교해야할까? 강력한 confounder인 경우, C비만도가 똑같은 아시아인vs백인을 비교하는 것이 의미가 있을까? | 아시아인은 백인에 비해 날씬하다는 것도 특성에 포함되고 bmi도 당연히 낮을 것인데, 이것을 굳이 보정해서 비만도를 동일하게 만들어놓고 Y를 비교할까? | . | . | 강력한 confounder는, 있음을 이해하고, 고려해서 잘 해석하도록 해야한다. 고려안하고 해석하면 오류다! | . | . | . | . Interaction . &#50857;&#50612;&#49444;&#47749; . 꼭 인과관계가 아니라 상관관계에서도 적용이 되는 개념 말로 설명시, 인과관계/이분형 변수를 setup해두면 더 쉬워서 가정함 x,y,a 모두 범주3종류 이상 or 순서형 변수, 연속형 변수 모두에도 해당함 | . | . | 인터랙션: x가 -&gt; y에 끼치는 효과가, 타변수 A값에 따라 달라질 때, x와 a간에 interaction이 존재한다고 말한다. 잘못 쓰이는 경우가 많은 용어다 | 인터랙션을 다른 말로 effect modification이라고도 하는데, a값에 따라 x가 y에 끼치는 효과가 달라지므로, a가 X의 효과를 modify한다라고 말할 수 있기 때문이다. | 또 다른말로, heterogeneity of treatment effect(HTE)라고도 한다. x의 효과가 a값에 따라 달라지므로, x의효과가 a에 의해 나눠지는 그룹별로 hetero하다라고 말할 수 있기 때문이다. | . | . &#50696;&#51228;&#47484; &#53685;&#54620; interaction(Additive model) . . 흡연과 석면, 2가지 factor가 폐암에 끼치는 영향을 보려고 한다. my) 일단 y에 대해 2가지 x후보군이 세팅되어있다 (둘중에 하나는 x, 하나는 a(interaion 일듯) | my) 예제처럼 바로 확률인 risk를 제시할 수도 있지만, 과제처럼 만명당, 10만명당 incidence rate를 제시할 수도 있다. | my) risk는 이미 y(질병걸릴확률?)완료된 값 -&gt; 2개 factor들만 row/column으로 가서 2by2 table로 표현되었다. | . | 각 factor별 background(모든 위험요소노출X)에서 증가된 risk 구해놓기 . 2가지 위험factor(2 by 2)에 대해 둘 다 노출이 안된 risk = background risk를 계산(확인)한다. row 비흡연(위험노출X) &amp;&amp; column 석면노출안됨(위험노출X) -&gt; 0.0011 | . | background risk를 기준으로 석면노출에 의한 증가한 risk를 석면노출O risk - 석면노출X risk의 risk차이로 계산한다. background risk를 체크한 상태에서 row의 위험노출X를 기준으로 row방향으로 risk차이를 구하면, column에 있는 factor의 영향이 됨. | . | 마찬가지로 column의 위험노출X를 기준으로 column방향으로 risk차이 = 흡연으로 인해 증가된 risk를 구한다 | | 각 factor별이 아니라 2 factor모두에게 영향받을 때의 risk는? . additive model로서 additive effect를 가정할 경우, 폐암risk는? . background + 석면의영향(으로 증가된risk) + 흡연의 영향으로 계산한다 . 0.0011 + 0.00565 + 0.00.84 = 0.0151 | . | 이는, 비흡연일 때의 석면의 영향(+0.0056)이, 아래row의 흡연에서도 동일하게 영향을 미칠 것이라고 가정한 것 과 같다. . | 반대쪽에서 더해져도 마찬가지다. 이처럼 효과는 차곡차곡 더해질 뿐이니, 더해가면 된다는 것이 additive model이다. | . | 하지만, 실제 risk는 0.0151보다 훨씬 크다. 이 말의 뜻은 위험factor 2가지 동시에 노출되면, 각각의 효과보다 훨씬 더 나쁜 효과를 일으킨다는 말이다. factor간에 시너지가 일어났다 = interaction이 있다 = 석면의 효과가, 흡연여부에 따라 다르다 | 반대로 흡연의 효과가, 석면노출여부에 따라 다르다라고도 말할 수 있다. | . | . | | &#44536;&#47000;&#54532;&#47196; &#48376; interaction . x축에 올라가있는 A값에 따라~ X(legend)가 Y(y축)에 끼치는 영향(2그래프 차이)이 어떻게 바뀌는지 보자. | . . 목적: interfaction을 일으킬 factor A값에 따라 factor X가 Y(risk)에 끼치는 효과를 나타내는 것 ~에 따른 변화 -&gt; X축 -&gt; factor A가 x축에 오게 된다. | . | y축: chance of disease = 질병이 발생할 확률 -&gt; risk를 의미한다. | x축: unexposed, exposed = 예비 interaction 위험요소 A로서 노출X, O를 각각 나타냄 | legend로서 2개의 그래프: X-&gt;Y에 있어서 factor X의 노출X/O여부를 2개의 그래프로 나타낸 것 | . interaction&#51060; &#50630;&#45716; &#44221;&#50864;(2&#44536;&#47000;&#54532; &#54217;&#54665; = A&#45432;&#52636; &#51204;/&#54980; risk&#51613;&#44032; &#52264;&#51060; &#51068;&#51221;) . . interaction&#44536;&#47000;&#54532; &#54644;&#49437;&#48169;&#48277; . x축 1개 상황을 고정하여 위험요소A에 노출되지 않았을 때 . 위험요소X에 노출되지 않았을 때 &lt;-&gt; X에 노출되었을 때 차이를 보고 X노출에 의한 Y risk증가 효과(차이)를 확인한다. | . | x축 나머지 상황을 고정하여 위험요소A에 노출되었을 때의 -&gt; X노출에 의한 Y risk 증가 효과(차이)를 확인한다 . X에 노출되지 않았을 때보다, 노출되었을 때의 risk가 올라감을 확인한다. | . | . x축에 있는 예비 interaction factor A의 노출X/O에 따라 X에 노출X/O의 risk차이가 달라지는지 확인한다. (x축)factor A의 노출여부가 X의 노출 X/O의 risk 차이에 영향을 주지않고 == 동일한 risk를 가져간다. 즉, 인터렉션 그래프에서 x축에 있는 예비 인터렉션 factor A에 따라 risk변화가 나타나지 않으면 == 2개 그래프가 X축 여부에 따라 평행하면 == 인터랙션효과가 없는 것으로 판단하면 된다. | . | . | Interaction&#51060; &#51080;&#45716; &#44221;&#50864; = 2&#44060;&#51060;&#49345;&#51032; factor&#44032; &#44036;&#49453;&#54616;&#47732; Synergism&#51012; &#51068;&#51004;&#53412;&#45716; &#44221;&#50864; . . 2개의 factor와 모두 만나면, 각각 노출되는 것보다 효과가 더 커진다 = interfaction이 있는 것 | . &#54644;&#49437; . factor A에 노출되지 않았을 때 -&gt; 그래프차이를 보고 -&gt; X의 Y risk증가 효과를 확인한다. | factor A에 노출되었을 때 -&gt; 그래프차이를 보고 -&gt; X의 Y risk증가 효과를 확인한다. . | A 노출시 X-&gt;Y risk증가 효과가 더 많이 올라가는 것을 확인한다. . 평행하지않다 = 인터랙션 존재한다 = 시너지즘이 존재한다. | . | interaction&#51060; &#51080;&#51648;&#47564;(A&#45432;&#52636; &#51204;/&#54980; 2&#44536;&#47000;&#54532; &#54217;&#54665;X) X&#45432;&#52636; &#51204; A&#47564;&#51004;&#47196;&#45716; &#54952;&#44284;&#44032; &#51204;&#54784; &#50630;&#45716; &#44221;&#50864; . . &#54644;&#49437;(&#53945;&#51060;) . 특별히 X축 1상황부터 보는게 아니라, legend 1상황에 대해 X축 2상황을 같이본다. . | X에 노출되지 않은 경우에는, factor A의 y rist증가 효과가 전혀 없는 경우다 . factor A 는 Y의 risk에 영향을 끼치지 않는 것으로 본다. | . | 근데, X에 노출된 경우, A의 y risk증가효과가 나타난다. . 차이가 일정하지 않다 = 2그래프가 평행하지 않다 = factor A(x축)에 의해 x-&gt;y risk 증가효과가 있다. | . | . intraction&#51060; &#51080;&#51648;&#47564;, A&#47196; &#51064;&#54644; cross&#46104;&#45716; &#44221;&#50864; . . &#54644;&#49437; . factor A 값에 따라 X의 y risk증가효과의 방향이 바뀌어버린다 | . 먼저, X축의 factor A에 노출되지 않았을 경우를 먼저 보면, -&gt; X에 노출되었을 때 risk가 X에 노출되지 않았을 때의 risk보다 낮다 . X에 노출되었을 때 risk가 더 내려간다? -&gt; X는 y에 대해 protective effect가 있는 factor다 | . | factor A에 노출된 경우, X에 노출되었을 때 risk가 X에 노출되지 않았을 때의 risk보다 더 높아진다. . X가 y risk를 증가시키는, 나쁜영향을 주는 X라 볼 수 있다. | . | A값에 따라 x가 좋기도 했따가(y risk떨궈줌) or x가 안좋기도 했다가 하는 경우를 Antagonism이라고 부른다. | Additive vs. multiplicative . additive model: 2 factor에 모두 노출된 효과는 각 효과의 합 my) 2 by 2 표에서는, background risk 출발 -&gt; 한쪽 노출된 것에 -&gt; 다른쪽 효과도 노출된 방향으로 확률 그대로 더하면 된다. | . | multiplicative model(멀티 플리커티브 모델):2 factor에 모두 노출된 효과는 각효과의 곱 | . &#50696;&#51228;&#47484; &#53685;&#54620; interaction(multiplicative model) . . 위험요소 X와 A 2개가 있다. interfaction 보는 문제인 듯? | . | 위험요소 노출여부에 따라 1만명당 incidence rates를 조사했다. 앞에 문제들에선 risk(계산된 확률)이었는데, 여기는 확률이 너무 낮아서 10000만을 곱해 1만명당으로 줬다? | incidence는 기본적으로 xxx명당 새롭게 발생한 환자의 비율이며, risk(발생확률)과 거의 비슷한 개념으로 생각한다. | . | . 일단 background risk처럼 2 위험요소 모두 노출되지 않았을 경우부터 확인한다. -&gt; 3 | background에서 위험요소A만 노출(-&gt;)될 경우를 확인 및 변화량도 확인한다 3 -&gt; 9로 위험요소 A노출시 (만명당) +6명 효과 | . | background에서 위험요소X만 노출(↓)될 경우를 확인 및 변화량도 확인한다. 3 -&gt; 15로 위험요소 X노출시 (만명당) +15명 효과 | . | 빈칸에 들어갈 값은? 만약 additive model이라면 한쪽에서, 다른한쪽의 증가량 더해주면 되는데 | additive model&#51060;&#46972;&#47732;? . . 각 factor 노출시 변화량의 합 -&gt; 둘다 노출시 변화량의 개념으로 보는 것 == Attributable risks로 보는 것 둘다 노출되지 않았을 때가 기준이며, 0으로 만든다 -&gt; 전체 -3 | 자동으로 위험요소 노출시의 값 = 변화량(증가량)이 된다. | 둘다 노출시 interaction이 없다면 단순 합으로 계산된다. Attributable risks으로 보면 6+12 -&gt; 18 | 기존표에서 보면, X부터 노출되었다 치면 3-&gt;15로 온 다음, A에 의한 증가량(+6)을 더해 15-&gt; 21이 된다. | . | | . Multiplicative model&#51060;&#46972;&#47732;? . 각 factor 노출시 변화량의 곱 -&gt; 둘다 노출시 변화량의 개념으로 보는 것 == Relative risk의 개념으로 본다. . 둘다 노출되지 않았을 때가 기준이며, 0으로 만든다 -&gt; 곱의 개념이므로 기준점을 1로 만드는 전체 / 3을 한다 . | 자동으로 위험요소 노출시의 값 = 변화량(배수개념)이 된다. . A노출시 3배 증가 | X노출시 5배 증가 | . | 둘다 노출시 interaction이 없다면 두 변화량(배수)의 곱으로 계산된다. . 3배 X 5배 -&gt; 총 15배 | 기존표 3 x 15 -&gt; 45 | . | | . addtive+multiplicative &#51032; &#44228;&#49328;&#51008; interaction&#50630;&#51012; &#46412;&#47484; &#44032;&#51221;&#54616;&#44256; 2factor &#47784;&#46160; &#45432;&#52636;&#49884;&#51032; &#44050;&#51012; &#44228;&#49328;&#54620; &#44163;&#51060;&#45796;. &#49892;&#51228; &#47928;&#51228;&#50640;&#49436; &#51452;&#50612;&#51648;&#45716; &#49892;&#51228; &#44050;&#51012; &#48708;&#44368;&#54644;&#49436; &#52264;&#51060;&#44032; &#45208;&#47732; interaction&#51060; &#51316;&#51116;&#54616;&#45716; &#44163;&#51060;&#45796;. . addtive model의 (만명당) incidenrate 계산 -&gt; interaction없다는 가정하에 계산한 것 ?가 21보다 현저히 높거나 낮으면 interaction이 있는 것으로 판단 | . | multiplicative model의 (만명당) incidenrate 계산 -&gt; interaction없다는 가정하에 계산한 것 ?가 45보다 현저히 높거나 낮으면 interaction이 있는 것으로 판단 | . | . &#46384;&#46972;&#49436;, &#50612;&#46500; model&#51012; &#44032;&#51221;&#54616;&#45712;&#45264;&#50640; &#46384;&#46972;&#49436; interaction &#51316;&#51116; &#44592;&#51456;&#44050;&#51060; &#45804;&#46972;&#51256; &#54032;&#45800;&#51060; &#45804;&#46972;&#51652;&#45796;. . 실제값이 21이 주어졌다. additive 모델가정시 -&gt; interaction 없네? | multiplicative 모델가정시 -&gt; interaction 이 있는데? | . | 그럼 어떻게 model을 잡을까? 위험요소의 생물학적 작동기전에 따라 biological knowledge에 의해 결정되어야한다. | 근데, 사실 addtive model을 사용하는 경우가 많다(직관적 이해가 쉬워서) | 하지만, interaction 판단시, addtive model의 attributable risk보다는 RR, OR를 많이 사용한다. 그리고 RR, OR는 multiplicative model을 사용하는 것이 더 자연스럽다. 기본적으로 ratio는 더하기 빼기보다 곱하기 나누기 하는게 맞으므로 | . | 하지만, RR, OR에 log를 취하면, 자연스럽게 addtive model로 변하고, 그것을 이용한다 | . | . interaction &#44228;&#49328;&#49884; &#50976;&#51032;&#51216; . 예비 interaction factor인 A값별로 (subgroup을 나눔. 그래프상으론 X축) X-&gt;y에 끼치는 효과를 추정할 것인데 각 A값별 subgroup의 효과에 대한 p-value의 차이를 가지고 판단하는 것이 아니라 | 각 A값별 subgroup의 효과에 차이에 대한 p-value를 가지고 판단한다 | . | . &#51221;&#47532;&#54616;&#44592; . 위험요소(X)와 질병(Y) 둘 다와 상관관계가 있으면서, 위험요소의 결과도, 질병의 결과도 아닌 변수를 confounder라고 한다 confounder의 정의 | . | X와 Y간에 인과관계가 없어도 강력한 confounder가 있는 경우에는 X와 Y에 상관관계가 관측된다 이런 경우를 막기 위해 아래의 방법으로 confounding을 제거 | . | 연구 디자인 단계에서 confounding을 제거하는 방법에는 랜덤화와 매칭이 있다 | 데이터 분석 단계에서 confounding을 제거하는 방법에는 stratification, adjustment, propensity score analysis가 있다 | X가 Y에 끼치는 효과가, 다른 변수 A값에 따라 달라질 때 X와 A간에 interaction이 존재한다고 말한다 | Interaction의 종류에는 synergism, unilateralism, antagonism이 있다 | Additive model을 가정하느냐, multiplicative model을 가정하느냐에 따라 interaction 여부의 판단이 달라질 수 있다 | . &#50672;&#49845;&#47928;&#51228; . &#45796;&#51020; &#51473; &#44536;&#47548;&#51032; &#51228;&#51068; &#50948;&#51901;&#50640; &#51080;&#45716; &#51064;&#51088;&#44032; confounder&#44032; &#50500;&#45772; &#44221;&#50864;&#45716;? . . 정답 : 3 | 해설 : high cholesterol diet와 흡연 간에 상관관계가 없으므로 high cholesterol diet는 confounder가 아니다. my) 일단 C가 결과가 되면 안되고, C는 x, y모두와 인과or상관관계가 존재해야한다. | . | . &#45796;&#51020;&#51008; &#50948;&#54744;&#50836;&#49548; &#46160;&#44032;&#51648;(interfaction) A, B&#50640; &#45824;&#54620; &#45432;&#52636;&#50668;&#48512;&#50752; &#50612;&#46500; &#51656;&#48337;&#51032; &#47564;&#47749; &#45817; incidence&#51060;&#45796;. &#45796;&#51020; &#49444;&#47749; &#51473; &#50739;&#51648; &#50506;&#51008; &#44163;&#51008;? . . additive model을 가정한다면 A와 B간의 interaction은 없다. . | addtive model을 가정한다면 A의 효과는 B에 노출되었는지 여부에 따라서 달라진다. . | multiplicative model을 가정한다면 A와 B에 둘다 노출되었을 때 incidence는 만명 당 60명이다. . | multiplicative model을 가정한다면 A와 B간의 interaction이 존재한다. . | &#45236;&#54400;&#51060; . . 2번: addtive model을 가정한다면 A의 효과는 &lt;B에 노출되었는지 여부에 따라서&gt; 달라진다. = interaction인 존재한다는 말이다 하지만, 계산값 30 = 실제값 30으로 ineteraction이 없다고 판단된다 -&gt; A가 어떤질병에 끼치는 영향이 위험요소B의 값에 따라 달라지지 않는다 | . | . 정답: 2 | 해설 : additive model을 가정한다면 A, B에 노출되었을 때의 위험은 5 + (20 - 5) + (15 - 5) = 30이 맞고, 이것은 interaction이 없음을 의미한다. 즉, A의 효과는 B에 노출되었는지 여부에 관계없이 일정하다. | .",
            "url": "blog.chojaeseong.com/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%ED%86%B5%EA%B3%84%EC%A0%81%EC%B6%94%EB%A1%A0/confounding/interaction/2022/03/22/%EC%9D%98%EC%97%B0%EB%B0%A904)-Confounding-&-Interaction(%ED%86%B5%EC%B6%94%EA%B0%9C%EB%85%902,3).html",
            "relUrl": "/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%ED%86%B5%EA%B3%84%EC%A0%81%EC%B6%94%EB%A1%A0/confounding/interaction/2022/03/22/%EC%9D%98%EC%97%B0%EB%B0%A904)-Confounding-&-Interaction(%ED%86%B5%EC%B6%94%EA%B0%9C%EB%85%902,3).html",
            "date": " • Mar 22, 2022"
        }
        
    
  
    
        ,"post101": {
            "title": "람다 캡처링 문제",
            "content": "람다 캡쳐링 . 람다는 새로운 stack을 생성해서 처리한다 -&gt; 밖(heap)영역에 있던 변수 변경에 제한이 걸린다. . 밖에서 선언된 원시변수의 값 변경은 불가능하다 (값만 복사해와서 사용만 한다) . | 밖에서 선언된 컬렉션은 주소만 가지고 와서 처리하니, 주소값의 변경은 애초에 하지도 않으며, 이미 생성된 것에 대해 add/remove 등이 가능하다 . | **밖에서 재할당한 참조변수의 경우에 메서드 호출이 불가능했다. ** . 참조변수가 할당만 1번 했다면, 호출이 가능하다. | . . | . | 참고 블로그 . | .",
            "url": "blog.chojaeseong.com/java/lambda/%EB%9E%8C%EB%8B%A4%EC%BA%A1%EC%B2%98%EB%A7%81/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/21/%EB%B8%94%EB%9E%99%EC%9E%AD_%EB%9E%8C%EB%8B%A4-%EC%BA%A1%EC%B3%90%EB%A7%81.html",
            "relUrl": "/java/lambda/%EB%9E%8C%EB%8B%A4%EC%BA%A1%EC%B2%98%EB%A7%81/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/21/%EB%B8%94%EB%9E%99%EC%9E%AD_%EB%9E%8C%EB%8B%A4-%EC%BA%A1%EC%B3%90%EB%A7%81.html",
            "date": " • Mar 21, 2022"
        }
        
    
  
    
        ,"post102": {
            "title": "의연방03-2) 삐뚤림(bias)",
            "content": "Bias . &#53685;&#44228;&#51201; &#52628;&#47200; 3&#44032;&#51648; &#51473;&#50836;&#54620; &#44060;&#45392; &#52395;&#48264;&#51704; . Bias | Confounding | Interaction | Bias . bias : 데이터가 주는 에러인데, 우리는 알고 싶은 total population을 모두 조사할 수 없으니 일부인 sample을 취해서 (우리병원에 오는, n~m세만 보겠다) population을 보는데, 그 sample 중에서도 일부분만(actual subjects)만 관측이 되니 전체를 알고 싶은데, 일부분만 본다는 자체가 sampling error를 줄 수 밖에 없다 | . Sampling error . 일부만 보다보니 데이터가 주는 에러 sampling error는 2가지로 나누어진다. . random error : 랜덤하게 sample을 취할 때, 어제/오늘 완전히 같은 방법으로 뽑았는데도 대부분은 다르게 추출된다. randomness자체에서 오는 변동성에서 오는 에러, 우연에 의해서 발생하는 에러. 피할수 가 없음. 우연(chance)에 의해서 발생하는 에러 | 특정한 방향성이 없다: 상관관계가 더 크게 보이게 측정됨? 더 작게 측정됨? 상관관계를 에러에 의해 한쪽으로 보내진 않는 에러다. | 샘플 사이즈를 늘릴 수록 random error는 줄어든다: 피할수는 없지만 줄일 수 있다. ex&gt; 100만명을 알고 싶었는데, 10명씩 뽑는 실험? -&gt; 뽑을 때 마다 다르다 / 90만명씩 뽑는다? -&gt; 겹처서 sample마다 비슷한 특성을 가질 수 밖에 없다. | . | systematic error : 연구디자인, 수행방법, 분석방법에 의해 발생하는 에러 | 보통 한쪽 방향으로 작용한다: 상관관계를 실제보다 크게 보이게 하거나, 작게보이게 하는 에러다 | 샘플 사이즈를 늘려도 줄어들지 않는다 | . | Bias: sampling error 중에 systematic error에 의해 = 연구디자인, 수행방법, 분석방법에 의해 발생하는 에러 흔한, 유명한 바이어스만 살펴볼 것 | . | . Selection bias . my) &#44536;&#47353;&#51012; &#45208;&#45580; &#46412;, &#51060;&#48120; &#47956;&#44032;&#44032; &#51089;&#50857;&#54644;&#49436; &#44208;&#49457;&#46104;&#50612;&#51080;&#45716; &#44221;&#50864; . 내가 아무리 잘 뽑더라도, 그룹간 차이가 이미 systematic diffrence를 가지고 있는 그룹이라, 상관관계를 한쪽으로 방향성을 가지게 만드는, systematic bias를 가진다. . | 연구대상을 뽑을 때, 실제로 존재하지 않는 상관관계가, 있는 것처럼 발생한다. . 위험노출 그룹 vs 위험노출X 그룹 을 각각 뽑을 때처럼 그룹간 다를 수 밖에 없는, 다른 방식의 연구디자인으로 뽑은 경우 | . | cases vs controls 질병o, 질병x 사람에 대해서, 실제와 똑같은 표집이 아닌, 디자인상으로 다를 수 밖에 없는 방법으로 표집을 하는 경우 상관관계가 없음에도 있도록 보일 수 밖에 없음 | . | . | . | 예) Open surgery vs. robotic surgery 그룹을 각각 뽑는데 내가 아무리 잘 뽑으려고 해도 관찰연구의 경우, 두 그룹이 다를 수 밖에 없음. robotic surgery 그룹 == 비싼 수술을 받는 그룹 == 경제적으로 윤택 == 좀더 건강에 신경많이 씀(운동, 영양상태 더좋음) -&gt; 잘 뽑아도 시스테머릭 difference는 존재할 수 밖에없다. -&gt; 시스테머릭 에러가 발생한다 -&gt; 상관관계가 한쪽으로 더 보이게 한다 | . | . 해결하려면? 디자인 자체를 잘 해서, 비슷한 그룹을 표집되도록 해야한다. | RCT로 랜더마이즈하게 control trial를 해야한다. 환자들을 recruit한 뒤 -&gt; open vs robotic surgery받을 지를 랜덤하게 결정하게 해야한다.(원래는 잘사는 사람들이 robotic을 고르기 때문에, 그 전에 랜덤하게 줘야한다) 가만히 두면, 경향성을 가진체로 그룹이 결성되니, 미리 그룹결성을 랜덤하게 | social economy status에 따른 그룹선택을 못하게 -&gt; 미리 랜덤하게 선택되도록 하기 | . | . | | . nonresponse&#50640; &#51032;&#54644; &#48156;&#49373; (&#50948;&#54744;&#45432;&#52636;X&#47196; &#51088;&#49888;&#51080;&#50612;&#49436; &#51025;&#45813; &#50676;&#49900;&#55176; &#54620;&#51901;&#51060;, &#50948;&#54744;&#45432;&#52636;O&#47196; &#51908;&#47140;&#49436; &#49961;&#44624; &#50528;&#46308;&#48372;&#12599; &#50724;&#55176;&#47140; &#49345;&#44288;&#44288;&#44228;&#45796; &#45908; &#45458;&#50500;&#48372;&#51060;&#44172; &#46120;) . 예를들어, 천식환자를 조사할 때, 흡연자(위험노출환자)가 무응답할 확률이 높다. -&gt; 과소추정된다. -&gt; 흡연과 천식의 상관관계가 더 약하게 보이게 한다. . | 예) 천식 환자 중 흡연자가 비흡연자에 비해 무응답 비율이 높다면? . 일반적으로 무응답자는 응답자와 다른 특성을 가지고 있음이 알려져 있다 | 무응답률을 줄이기 위해 최대한 노력 | 무응답의 이유, 무응답자의 특성 파악을 위해 최대한 노력 | . | . Information bias . 연구를 위해 수집된 자료가 부정확해서 생기는 편향의 총칭 | Misclassification의 경우가 많으니 2가지를 살펴보자 | . nondifferential misclassification . 연구에서 비교하는 그룹 간 misclassification rate가 비슷한 경우 case를 -&gt; control로 잘못 분류 | control을 -&gt; case 잘못 분류 서로 비슷하게 잘못 분류됨 | . | . | 데이터에 노이즈가 많아짐 잘못된 입력된 것이 많을 때 노이즈가 많아진다고 한다. | . | Association이 실제보다 더 약하게 (OR 또는 RR이 1에 가깝게) 추정된다 상관관계다 더 줄어든다 == OR이나 RR이 실제보다 더 1에 가깝게 나온다 | . | . differential misclassification -&gt; &#51656;&#48337;O&#51064; case&#44032; &#45908; &#51096; &#44592;&#50613; or &#44592;&#50613;&#51012; &#45908; &#51096;&#48372;&#44256;(&#44592;&#54805;&#50500;&#52636;&#49328;&#49884; &#44284;&#44144;&#51032; &#51060;&#48292;&#53944;&#46308;)/&#45916; &#48372;&#44256;(HIV&#54872;&#51088;&#51032; &#44284;&#44144; &#49457;&#44221;&#54744;,&#50557;&#47932;)&#54632; . 연구에서 비교하는 그룹 간 misclassification rate가 다름 | . recall bias . case(질병O인 사람)가 control에 비해 과거의 일(event들)을 더 잘 기억함으로 발생하는 bias 예) 기형아 출산 여성은 정상아 출산 여성에 비해 임신 중 감염이나 이벤트를 더 잘 기억하는 경향 질병O인 사람으로서, 내가 낳은 아이가 기형아다 -&gt; 출산 준비하는 중 언제부터/왜/뭐가 잘못됬지 생각할 수 밖에 없다. 기억을 되짚어 보면서 더 잘 기억하게 됨 | . | . | . reporting bias . 기억자체를 잘하고/못하고 문제가 아니라, 기억을 똑같이 하더라도, 질병O인 사람이 그것을 과대포장or과소포장을 더 잘함 . | case가 control에 비해 과거일을 더 잘 보고하거나, 더 잘 누락함 . 예) HIV환자가 성경험이나 약물 사용에 대해 보고하지 않는 경향, case가 덜 보고하려함 | . | 예) 폐암환자가 흡연력, 음주량을 줄여서 보고하는 경향 case가 덜 보고하려함 | . | . | 사람이다 보니, 상대방에게 어떻게 보일 것인지 생각하다보니 이러한 bias가 발생함 . 사람이 아닌 컴퓨터, ARS 등을 이용한 설문이 bias를 줄여줄 수 있다. | . | . surrogate(&#50024;&#47196;&#44079;) interviews&#50640; &#51032;&#54620; bias -&gt; &#50500;&#45236;&#45716; &#51453;&#51008; &#45224;&#54200;&#51012; &#45908; &#51339;&#44172; &#48372;&#44256;&#54616;&#47140;&#54632; . 사망자의 배우자로부터 자료를 수집할 때, 아내들은 사망한 남편의 직업과 생활습관에 대해서 실제보다 더 좋게 보고하는 경향이 있음 | . surveillance bias -&gt; &#45236;&#44032; &#52824;&#47308;&#48277;&#51012; &#51228;&#49884;&#54620; &#52824;&#47308;&#44400;&#51012; &#45824;&#51312;&#44400;&#48372;&#45796; &#45908; &#51096; &#47784;&#45768;&#53552;&#54616;&#45796;&#48372;&#45768;(&#52824;&#47308;&#48277;&#50640; &#45824;&#54620; &#48512;&#51089;&#50857; &#46321;&#51012; &#51032;&#49885;&#54644;&#49436;) -&gt; &#50696;&#49345;&#54616;&#44256; &#51080;&#45912; &#51656;&#48337;&#51060; &#45908; &#51096; &#48156;&#44204;&#46104;&#45716; &#44221;&#54693; (&#52824;&#47308;&#48277;&#51032; &#48512;&#51089;&#50857; &#51656;&#48337;&#51060; &#50500;&#45768;&#46972;&#47732; &#44288;&#52272;&#47803;&#54616;&#44256; &#51648;&#45208;&#44052;&#51012; &#49688;&#46020;) . 치료군을 더 잘 모니터해서 질병 발생을 더 잘 찾아냄 내가 치료방법을 제시한 경우, 치료법의 부작용으로 나타나는 질병 때문에 -&gt; 그 군을 더 열심히 모니터링 하는 경향 -&gt; 발생해도 몰랐을 수 있는, 부작용으로 지켜보던 질병은 바로 잡아낸다. | . | 예) 경구 피임약과 혈전 정맥염(thrombophlebitis)의 관계 경구 피임약 처방을 해준 경우, 약의 부작용을 의식한 의사가 | . | . Bias&#47484; &#51460;&#51060;&#47140;&#47732; . 데이터 측정과 수집을 최대한 표준화, 자동화한다 | 가능한 경우 랜덤화(randomize) 한다 할수만 있다면, 이미 그룹이 원래특성을 가진 체 나누기 전에, 전체 환자군을 먼저 recruit해놓고 어느 치료법을 쓸 것인지 random하게 그룹을 나누어서, 경제적지위 등이 안녹아들게 하기 | 어떤 위험요소 노출을 할 것인지를 random하게 나누어서 그룹을 나누기 | . | . | 가능한 경우 눈가림(blinding)한다 | 무응답을 줄이고, 무응답자 특성 파악을 위해 노력한다 | bias를 줄일 수 있는 통계방법을 사용한다 | . &#51221;&#47532;&#54616;&#44592; . Absolute risk는 risk라고도 하며, 질병이 발생할 확률이다. | 질병과 위험요소 간의 상관관계를 파악하기 위해, relative risk, odds ratio, attributable risk 등을 사용한다. | Relative risk는 위험요소에 노출되었을 때의 위험이, 노출되지 않았을 때의 위험에 비해 몇배인지 나타낸다. | Odds ratio는 위험요소에 노출되었을 때의 오즈가, 노출되지 않았을 때의 오즈의 몇배인지 나타낸다. | Attributable risk among the exposed는 위험요소에 노출된 경우의 질병발생확률에서 노출되지 않았을 경우의 질병발생확률을 뺀 값이다. | Attributable risk for the population은 population 전체의 질병발생확률에서 위험요소에 노출되지 않은 그룹의 질병발생확률을 뺀 값이다. | 관심 모집단의 일부분인 샘플을 표집하는 과정에서 발생하는 error중, random error가 아닌 연구디자인, 수행, 분석방법에 의해 발생하는 systematic error가 bias이다. 샘플로 뽑아서 발생하는 error 중에 random에러가 아닌 systematic error가 bias다. | . | bias를 줄이기 위해서는 데이터 수집을 최대한 자동화, 표준화하고, 가능하면 랜덤화, 눈가림 하는 것이 좋다. 무응답을 되도록 줄이고, bias를 줄일 수 있는 통계방법을 사용하는 것도 좋다. | . &#50672;&#49845;&#47928;&#51228; . Q2 다음 중 bias에 대한 설명으로 옳지 않은 것은? . 연구 디자인, 수행, 분석방법에 의해 발생하는 에러이다. 우연(chance)에 의해서 발생하는 에러 -&gt; sampling error 중 random error | 연구 디자인, 수행, 분석방법에 의해 발생하는 에러이다. -&gt; sampling error 중 systematic error = bias | . | 샘플 사이즈를 늘리면 bias는 줄어든다. 샘플 사이즈를 늘릴 수록 random error는 줄어든다: 피할수는 없지만 줄일 수 있다. ex&gt; 100만명을 알고 싶었는데, 10명씩 뽑는 실험? -&gt; 뽑을 때 마다 다르다 / 90만명씩 뽑는다? -&gt; 겹처서 sample마다 비슷한 특성을 가질 수 밖에 없다. | systematic error = bias는 random error와 달리, 디자인의 문제라서, 샘플 수 늘려도 랜덤문제를 해결할 수 없다. | . | 데이터 측정과 수집을 표준화할수록 bias는 줄어든다. 데이터 수집을 최대한 자동화, 표준화하고, | 가능하면 랜덤화, 눈가림 하는 것이 좋다. | 무응답을 되도록 줄이고, | bias를 줄일 수 있는 통계방법을 사용 | | 위험요소에 대한 노출여부를 랜덤화하면 bias는 줄어든다. 치료법(case) vs 대조군 or 위험요소 노출여부 vs 대조군으로로 그룹을 나누는데, 2가지에 대해서는 랜덤화할 수 있으면 bias를 줄인다. | . | 정답 :2 해설 : bias는 샘플 사이즈를 늘려도 줄어들지 않는다. | . | . .",
            "url": "blog.chojaeseong.com/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%ED%86%B5%EA%B3%84%EC%A0%81%EC%B6%94%EB%A1%A0/bias/2022/03/20/%EC%9D%98%EC%97%B0%EB%B0%A903-2)-Bias(%ED%86%B5%EC%B6%94%EA%B0%9C%EB%85%901).html",
            "relUrl": "/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%ED%86%B5%EA%B3%84%EC%A0%81%EC%B6%94%EB%A1%A0/bias/2022/03/20/%EC%9D%98%EC%97%B0%EB%B0%A903-2)-Bias(%ED%86%B5%EC%B6%94%EA%B0%9C%EB%85%901).html",
            "date": " • Mar 20, 2022"
        }
        
    
  
    
        ,"post103": {
            "title": "강의)로또-캐싱/정펙매/조합/불변일급컬렉션",
            "content": "지금까지 클래스 . 지금까지의 Class는 객체를 찍어내는 Factory일 뿐이었다. | 조금 더 나아가서 객체 생성 Factory(찍어내는 템플릿)일 뿐만 아니라 객체의 능동적인 관리자의 역할도 할 수 있다. | . 제한적인 자바의 new 키워드 . java에서는 new키워드가 제한을 가지고 있다. 무조건 응답해야하며 | 무조건 객체가 생성되어야한다. | | . 정펙매로 Class를 객체(생성의) 능동적 관리자로 승격 . 정펙매를 통한 캐싱 -&gt; [new처럼 매번 새로 생성]안해도 되는 객체 생성 . 01 프로덕션 원시값을 포장 -&gt; [public 주생성자]만 빨간줄 자동생성 . 기본적으로 클래스내 원시값int를 인스턴스 변수 = 상태값으로 포장하여 선언하면 빨간줄로 생성자 만들라고 한다. . . . public class LottoNumber { //1. 내부 포장 상태값 -&gt; 빨간줄 private final int value; //2. 빨간줄 -&gt; add constructor parameter // -&gt; private으로 생성하면 좋겠지만, public으로 기본 생성함 public LottoNumber(final int value) { this.value = value; } } . | 02 도메인 Test코드에서 생성자를 테스트하는데, [new 키워드의 public 주생성자]는 템플릿일 뿐이며, 항상 new사용과 동시에 100% 객체를 새로 생성(하여 할당) 할 수 밖에 없다. . LottoNumberTest를 만들고 생성자 생성 연습시작 . go to test(직접지정 ctrl+shift+t)로 생성하거나 이동하기! . . | . | new키워드를 사용해한다면객체를 생성하는 public 주생성자로서 사용과 동시에 항상 객체를 100% 새로 생성해야만한다. . class LottoNumberTest { @Test void create() { //new 키워드(public주생)는 템플릿으로서, 항상 사용과 동시에 객체를 100% 새로 생성해야만 한다. final LottoNumber lottoNumber = new LottoNumber(1); final LottoNumber lottoNumber2 = new LottoNumber(2); } } . | 03 정펙매로 객체 생성을 능동적으로 관리(100% 생성이 아니라 재사용 = 캐싱) . 01 캐싱될 객체는 미리 생성자가 받는 raw파라미터가 제한된 범위로 예외처리 되어있다 . public class LottoNumber { private final int value; public LottoNumber(final int value) { // 생성자로 들어오는 재료인 raw파라미터에 대해 // 범위 검증(예외처리)를 해주면, 객체가 -&gt; 제한된 raw값 범위만 가지게 된다. // 제한된 raw값의 범위라면 미리 생성해두는 캐싱이 가능하다. if (value &lt; 1 || value &gt; 45) { throw new IllegalArgumentException(); } this.value = value; } } . 02 new키워드가 아니라 정적팩메(Class.of(, ), Class.from())를 사용하고, 정펙매 내부에서 캐싱한다. . 객체 생성을 100% 새로 생성하는 new Class대신 Class.of( , )나 Class.from()으로 생성해보자. . 빨간줄로 public static 정적 메서드 생성 . . | 파라미터명은 value로 수정해놓고 시작 . public static LottoNumber of(final int value) { throw new UnsupportedOperationException(&quot;LottoNumber#of not write.&quot;); } . | . | 03 캐싱은 &lt;외부에서 요청하며 메서드 파라미터로 들어오는 rawType, 현재 내부인 캐슁 객체Class&gt;로 hashMap 제네릭 타입을 결정 + 사이즈를 알면 initialcapacity로 미리 준다. + 정펙매 내부에서 만드는 척만 해서 변수추출 . 변수 블럭에서 적상하면 변수 추출안되니, 편의상 정펙매 내부에서 캐쉬 만드는 척하자 . 외부에서 들어오는 rawType과 동일한 Type으로 key타입을 맞춰줘야 꺼내쓸 수 있다. | . . | . 04 캐싱객체는 private + static final의 싱글톤으로서 상수처럼 미리 빈 map을 초기화해놓는다. . 변수추출로 변수Type이 자동생성되었다면, private static final로 싱글톤 형태의 빈 map을 클래스 변수로 선언하게 한다. . . . public class LottoNumber { private static final int MIN = 1; private static final int MAX = 45; private static final Map&lt;Integer, LottoNumber&gt; cache = new HashMap&lt;&gt;(45); private final int value; . | 05 캐싱의 핵심은 요청이 왔을 때, if없으면 -&gt; 빈 맵에 생성해서 넣고 || 맵에서 그외 꺼내주기인데, hashMap.computeIfAbsent(확인할 key, 없으면key 해당 value자리에 넣어줄 값 생성 Function)을 제공해주므로 없으면 new로 새로 생성 로직만 넣어주면 된다. . . 람다용 Function자리의 변수추천은 map의 keyType에 따라 바껴서 추천된다. Map&lt;Integer, 객체&gt;일 경우 -&gt; integer -&gt; {} 추천 | Map&lt;Long, 객체&gt;일 경우 -&gt; aLong -&gt; {}추천 | . | . public static LottoNumber of(final int value) { // 1. 정펙매로 부터 rawType변수로 요청이 온다. // -&gt; cache에서 없으면 map의 value에 넣어줄 값을 생성하는 람다식 --&gt; 있으면 꺼내주기 // 2. 없을 때, new 생성자로 객체새로 생성하는데, [람다에 쓰이는 변수명은 파라미터와 다르게] 수정만 해주면 된다. // -&gt; i를 눌러주면 알아서 integer -&gt; 로 람다 작성하라고 뜬다. return cache.computeIfAbsent(value, integer -&gt; new LottoNumber(integer)); } . 06 정펙매 사용순간부터는 주생성자 private으로 잠궈주기 . . public으로 남게 되면, 의도했던 능동적 객체관리와 다르게 코드가 돌아갈 수 있다. . 정펙매 사용으로 유도하고 기본생성자를 private로 막고 사용 . | 테스트를 위해 잠시 여기서는 허용 . | . | . 07 최종 필요한 것 정리 . private static final Map&lt;외부생성자로 들어올 rawType, 현재객체Class&gt; cache = new HashMap&lt;&gt; (갯수); . | 정펙매 내부에서 cache.compuateIfAbsent( 외부 key로 꺼낼 raw값, 없으면 key에 해당하는 value로 넣어줄 객체생성해줄 new 생성자 &amp; Function으로 객체 생성) . public class LottoNumber { private static final int MIN = 1; private static final int MAX = 45; private static final Map&lt;Integer, LottoNumber&gt; cache = new HashMap&lt;&gt;(45); . public static LottoNumber of(final int value) { return cache.computeIfAbsent(value, integer -&gt; new LottoNumber(integer)); } . | Q. 생성자 테스트를 위해 기본생성자를 private말고 default로 열어두어도 되나? . 테스트를 위해 생성자를 열어둬야하는데, 클래스 분리를 고려한다. 과하다 싶으면 -&gt; default를 열어주는 case도 있다. | . | . 04 캐싱 객체는 isSameAs로 비교하면 된다. . 메모리 주소까지 같은 것만 True로 나오기 때문에 캐싱된 것인지 검사를 isSameAs로 하면 된다. . @Test void create() { final LottoNumber lottoNumber = new LottoNumber(1); final LottoNumber lottoNumber2 = new LottoNumber(1); // isSameAs: 메모리 주소가 같은지, 오버라이딩된 VO도 같다고 안나옴. 더 엄격한 완전히 같은 객체일 때, True assertThat(lottoNumber).isSameAs(lottoNumber2); // false } . | . 05 삭제도 안되는데 cache? . 01 변수명을 cache -&gt; pool로 바꾸기 . 02 캐쉬 때문에 메모리가 가득찼을 때 GC대상으로 삭제시켜주는 hashMap인 -&gt; WeakHashMap으로 선언 . . private static final Map&lt;Integer, LottoNumber&gt; cache = new WeakHashMap&lt;&gt;(45); . 06 없을 때 생성 이 아니라 미리 만들고 -&gt; 요청시 조회get만? -&gt; static 블록 생기는게 짜증 . . . public class LottoNumber { private static final int MIN = 1; private static final int MAX = 45; private static final Map&lt;Integer, LottoNumber&gt; cache = new WeakHashMap&lt;&gt;(45); // 1. 미리 생성을 위한 static 블럭 static { for (int i = MIN; i &lt;= MAX; i++) { cache.put(i, new LottoNumber(i)); } } private final int value; public LottoNumber(final int value) { if (value &lt; MIN || value &gt; MAX) { throw new IllegalArgumentException(); } this.value = value; } public static LottoNumber of(final int value) { //return cache.computeIfAbsent(value, integer -&gt; new LottoNumber(integer)); // 2. 없으면 생성 과정이 없어지고 오로지 get으로 조회만 return cache.get(value); } } . static으로 인해 코드량도 늘어나서 처음 분석하는데 힘이 들어감. | . 여러 쓰레드에서 접근한다면? -&gt; ConcurrentHashMap + 미리 생성해두는게 좋다 . 참고) 블랙잭 카드 캐싱 . key 2개를 원소로 가지는 클래스를 두고 한다? | . . Map의 key를 String1개로 바꾸고 -&gt; toString()으로 2개를 더해서 key1개로 사용해도 된다 . . . | enum이라면, .name() + ,name()로 스트링으로 더해서 key1개로 만들면 된다. . | . 생성자가 많으면, 응집도가 높고 견고한 클래스가 된다. . 다른Type 추가 정펙매 . . 여러가지 방식으로 제공해주면 클라이언트 입장에서 사용하기 좋은 코드가 된다. | . 대박) 포장이 아닌 다른Type 입력 제공으로 인한 추가 정펙매 제공은 부생성자로서 위에 위치 + convert후 기존 정펙매(=기준 정펙매)를 호출한다. . 01 포장으로 인한 메서드 추가의 상황이라면 -&gt; [새기준 메서드 생성+내용복붙후 처리 완성]후 [기존 rawInput메서드는 포장후 새기준 호출]하도록 변경 . 02 다른Type입력을 위한 생성자/정펙매를 제공한다면 -&gt; 기존 생성자/정펙매가 기준 메서드라 생각하고 내부convert후 호출 . 새 기준 포장하는 파라미터 변화가 아니라 편의를 위해 다른 type의 입력을 제공한다고 치고 빨간줄 생성하자 . . | 포장이 아닐 경우, 다른Type메서드는 기준메서드가 아니다 -&gt; 부 생성자로서 기존생성자보다 위에 + 포장해서 기존생성자=기준메서드로 호출해준다. . . public class LottoNumber { private static final int MIN = 1; private static final int MAX = 45; private static final Map&lt;Integer, LottoNumber&gt; cache = new WeakHashMap&lt;&gt;(45); private final int value; public LottoNumber(final int value) { if (value &lt; MIN || value &gt; MAX) { throw new IllegalArgumentException(); } this.value = value; } //1. 다른Type입력 생성자 -&gt; 부생성자 -&gt; 위치는 [기존생성자=기준생성자]보다 위에 위치한다. public static LottoNumber of(final String value) { //2. convert해서 기존생성자=기준생성자를 호출해준다. return of(Integer.parseInt(value)); } public static LottoNumber of(final int value) { return cache.computeIfAbsent(value, integer -&gt; new LottoNumber(integer)); } } . | 정리) 너무 많은 Type Or 방식의 생성자는 제공하면 문제가 된다. but 일반적으로 생성자는 많은 것이 좋다. . 메서드와 다르게 많이 제공할 수록 좋단다. | . 다른Type 추가 생성자 . 여러 Type의 생성자 제공이라도 인스턴스 변수(상태값) 초기화는 주생성자 1개에서만 -&gt; 나머지는 위에서 주생성자를 convert후 -&gt; 기존 생성자를 this()로 호출만 해주는 부생성자들로 -&gt; 중복을 피하자 . . 자바만 부생성자라는 관례적이 이름이 있다. 무조건 주생성자에서만 인변을 초기화 하기 위해 관례적으로 지은 이름 | . | 다른언어는 무조건 주 생성자를 이용해서만 호출하도록 지원하는 것이 많다. | . 01 다른Type의 생성자 추가는 부생성자로서 convert후 this()로 주생성자를 호출해야한다. -&gt; 직접 주생성자의 역할인 인스턴스변수 초기화를 해주면 안된다 . 직접 주생성자의 역할인 인스턴스변수 초기화를 해주면 안된다. | . . . 02 다른Type용 생성자 -&gt; 부생성자 -&gt; 주생성자 위에 정의 + convert후 this로 주생성자호출-&gt; convert후 원래Type의 주생성자 코드(검증후 인변 초기화)를 반복하지마라. . 위치를 주생성자보다 위로 올려준다. . . | 대부분 다른 Type 으로서 String을 받아주므로 rawInput에 해당하는 rawValue로 네이밍 해보자. . //부 : rawValue public LottoNumber(final String rawValue) { //주 : value public LottoNumber(final int value) { . | convert만 하고, 원래Type이 했던 검증+ 인변 초기화해주면 똑같이 해주면 코드 중복이다. . 코드중복 = 나쁜 예 . | 생성자 내부코드는 주생성자를 호출해서 인스턴스 변수 초기화의 중복 = 코드 중복을 막자. . public LottoNumber(final String rawValue) { this(Integer.parseInt(rawValue)); } . . | . | 정리) 생성자 코드 중복 in 부생성자 -&gt; 인수 늘어날 때, 코드 변경될 때 -&gt; 모든 부생성자까지 다 초기화 해줘야한다 -&gt; 그러니 convert후 this() 주생성자를 호출해주자. . 주 생성자는 객체 초기화 프로세스의 유일한 장소 -&gt; 추가 생성자에서 초기화 하지말자 | . 상속 . . 상속 잘 사용 하기 (부작용이 크니까) . 상속은 나쁜 것이다? 고민을 해봐야한다. 내가 쓰레기처럼 쓰는 것은 아닌지.. | 스프링에서도 상속을 잘 쓴다. | . | . 상속 부작용 . 부모 변화(탑레벨 클래스 기능 변경) -&gt; 자식 모두 수정(하위 클래스 모두 변경) 안좋은 결합도가 높아짐. | 나쁜 것도 물려준다. 선택이 없다. | . | . 부-&gt;자로 상속되서 사용되는 변수/메서드는 부모 내부에서 정의되어 사용되는 메서드라도 자식에 오버라이딩된 메서드부터 찾는다. -&gt; 오버라이딩 전 메서드를 호출하는 방법이 없다? . 동일한 형태, 구조를 가질 예정이므로 is-a에 해당하여 상속을 했다. cf) has-a구조라면 조합을 사용한다. | . | 합리적으로 보이지만, 자식이 물려받고 오버라이딩 안한 length()호출시 부모 content()? 자식오버라이딩한 content() 어느것이 호출될까 자식에서 호출했으면 오버라이딩 된 것이 호출된다. | . | 사용하는 클라이언트는 구현안한 메서드라면, 내부 호출도 부모 것만 원할 수 도 있다. 따로 구현안하고 물려받은 메서드를 호출한다면, 내부에서도 부모 것만 사용하도록 원할 수 도 있다. | . | . 상속 문제점 예제 만들어보기 . 객체List 일급컬렉션( 포장 ) 요구사항이 없었다면? 컬렉션&lt;객체Type&gt;를 상속해서 컬렉션메서드의 기능을 다사용하도록 했다. . 객체List는 일급컬렉션으로 포장했었다. . public class LottoNumbers { private final List&lt;LottoNumber&gt; value; } . | 예전에는 extends 컬렉션&lt;원소Type&gt;을 통해 클래스를 생성했다. . . | 사용과 생성은 c+s+t로 지정한 go to test로 가서 생성하고 테스트하자. . . | 문제01) 부모인 컬렉션 기능 다 사용되서 좋아보이지만, 위험한+필요없는 기능들도 강제로 제공된다. . . 찍어보면 사용하지 필요없는 기능들도 다 물려받는다. . | 위험한 기능도 다 받은 상태라 클라이언트에도 노출되서 위험하다 . | . 문제02) 부모 물려받은 메서드에 오버라이딩해서 super.메서드()로 쓰고 있지만, 그 메서드의 내부 작동방식을 모른다 -&gt; add기능추가 후 addAll 기능추가 시 의도와 다르게 작동 . 02-1 가장 원초적인 super.메서드() ex&gt; .add() 의 경우, 기능을 추가해도 문제가 없다 . 오버라이딩부터 한다. . 선택할 메서드가 너무 많으면 add 를 검색하면 된다 . . | . | 부모에서 물려받은 것(super생략가능)을 쓰기 전에, 누적하는 기능 -&gt; 매 인스턴스마다 상태값을 누적할 인스턴스 변수도 필요하다. . 누적전에 0으로 초기화해야할텐데, int는 기본적으로 0으로 초기화 해준다. | . . . | 내부 상태값을 얻기 위해서 getter가 필요하다. . 이것도 generate 띄운 상태에서 검색으로 빠르게 생성할 수 있다. . . | . | public class LottoNumbers extends HashSet&lt;LottoNumber&gt; { private int addCount; @Override public boolean add(final LottoNumber lottoNumber) { addCount ++; return super.add(lottoNumber); } public int getAddCount() { return addCount; } } . class LottoNumbersTest { @Test void add() { final LottoNumbers lottoNumbers = new LottoNumbers(); lottoNumbers.add(LottoNumber.of(1)); lottoNumbers.add(LottoNumber.of(2)); lottoNumbers.add(LottoNumber.of(3)); lottoNumbers.add(LottoNumber.of(4)); lottoNumbers.add(LottoNumber.of(5)); lottoNumbers.add(LottoNumber.of(6)); assertThat(lottoNumbers.getAddCount()).isEqualTo(6); } } . 02-2 내부에서 add()를 사용하고 있는지도 모르고, addAll()를 오버라이딩 + 기능 추가하면 -&gt; 기능이 2배로 추가 된다. . addAll()을 호출하는 테스트를 만들어보자. . 새 자료구조 ex&gt; Set, List를 만들 땐 .of를 쓴다.** . | addAll()은 가변인자에 원소가 아니라 같은 자료구조의 묶음은 add한다. . ex&gt; 빈 셋 -&gt; 빈셋.addAll( 셋묶음 ) | . | 위에서 add로 여러번 선언한 것들 중 인자들만 복사해서, 활용할 수 있다. . @Test void addAll() { final LottoNumbers lottoNumbers = new LottoNumbers(); lottoNumbers.addAll(Set.of( LottoNumber.of(1), LottoNumber.of(2), LottoNumber.of(3), LottoNumber.of(4), LottoNumber.of(5), LottoNumber.of(6) )); assertThat(lottoNumbers.getAddCount()).isEqualTo(6); } . | . | addAlll() 갯수 세는 기능을 추가해보자. . Generate띄우고, over라이딩도 검색할 수 있다 . 오버라이딩할 메서드고 검색해서 오버라이딩하자. | . . . | . | add시마다 더해주는 기능을 추가 해보자. . @Override public boolean addAll(final Collection&lt;? extends LottoNumber&gt; c) { //넘어오는 단일객체를 원소로 가지는 Collection의 사이즈를 더해주자 addCount += c.size(); return super.addAll(c); } . | 6개가 더해져야하는데, 12가 나온다. . | 문제02 디버깅) sout로 찍어보기 -&gt; 정상이면 타고 올라가보기 . 디버깅으로서 일단, size가 잘못더해지는지 찍어볼 것이다. . @Override public boolean addAll(final Collection&lt;? extends LottoNumber&gt; c) { addCount += c.size(); System.out.println(&quot;c.size() = &quot; + c.size()); return super.addAll(c); } . . | 더해주는게 정상인데…? 메서드를 직접 까봐야한다. . 컨트롤 클릭으로 타고 올라가기 . . | . | 분석하기 . addAll()은 내부에서 매번 add()를 호출한다. | add()는 추상메서드로서 우리가 오버라이딩=재정의해준 add()가 호출되어, 개별 count기능까지 작동하게 된다. | | . 기본적으로 제공하는 api들 내부작동방식을 모르므로 상속후 기능 추가를 위한 재정의시 조심해서 사용해야하므로 상속을 비추한다. -&gt; 상속 대신 조합-&gt; 포장도.. 조합?! . 상속을 제거하고 기존 클래스(HashSet&lt;객체&gt;)의 인스턴스를 -&gt; 인스턴스 변수로 가지도록 바꾸자. . 필드 선언을 위해 변수추출부터 하고 싶다면 메서드 내부로 잠시 이동해서 하자 . . | 필드의 자료형은 shift+tab으로 앞으로 넘어와서 다형성을 적용시켜서 완성하자 . . | private가 아닌 메서드에서 선언했다면 접근제한자도 확인을 해주자. . . | 다시 필드 선언부로 가지고 오자. . | . | 상속에서 기능추가한 오버라이딩삭제 + super.대신 -&gt; value.로 변경해주자. . public class LottoNumbers { private final Set&lt;LottoNumber&gt; value = new HashSet&lt;&gt;(); private int addCount; public boolean add(final LottoNumber lottoNumber) { addCount++; return value.add(lottoNumber); } public boolean addAll(final Collection&lt;? extends LottoNumber&gt; c) { addCount += c.size(); return value.addAll(c); } public int getAddCount() { return addCount; } } . | 참고-&gt; .add()의 결과로는 boolean을 반환한다 -&gt; 호출시마다 if를 달아서 실패시 예외내야하는 건 아닌가? . 실패하는 케이스가 거의 없다 -&gt; 응답할 필요 없다. -&gt; 잘못 설계된 것으로 추정된다. capacity가 정해져있어도 내부적으로 resizing해서 실패를 안함. | . | . | 참고) super -&gt; 자식이 생성자 재정의할라고 갖다쓰는 것은 주생성자 쓰는 것처럼 가능하다 -&gt; but 메서드 호출까지 super를 호출한다면, 부모의 구조를 다알아야해서 결합도가 너무 커져 안좋다. . 조합 . 3기 예시 블로그 . 조합 블로그 | 블랙잭에서 조합 적용 블로그 그 사람의 branch -&gt; 적용안하고 인터페이스만 | . | [이펙티브 자바] 추상 클래스보다는 인터페이스를 우선하라 우테코에서 언급 | 인-추(코드중복제거?)-상속 | . | 매트 추상화 글 | 연록조합글 연록 다음 인터페이스와 골격구조 | . | 대놓고 추상-골격구현클래스으로 PR 리뷰 받았다! 젤 참고 | 동기인듯? 코드중복 제거 및 상태를 가지므로 추클이 더 적합 | 인터페이스 &gt; 추클의 옛날 글 | cf) 합성: 조합의 수만큼 클래스로 나누어서 외부에서 주입 어려움 -&gt; 블로그 | . public class Man { public void move() { System.out.println(&quot;걷는다&quot;); } public void eat() { System.out.println(&quot;먹는다&quot;); } } class SuperMan { private final Man man = new Man(); public void move() { man.move(); } public void eat() { man.eat(); } public boolean canTouchKryptonite(){ return false; } public void fly() { System.out.println(&quot;날아간다.&quot;); } } // 다형성을 위해서는 인터페이스나, 추상 클래스를 이용한 구현을 고려해보자. // 상속을 기능의 재활용보다는, 정제를 위해 사용하자! // 이런 경우에는 상속을 고려해보자. // 코드 재사용을 주목적으로 하기보다는 확장성, 유연성을 고려해야할때 // IS-A 관계가 명확할때 // 부모 메소드에 이미 구현된 내용이 절대 바뀌지 않는다고 확신이 들때 . | . . 상속은 is-a관계가 기본 조건(모두 내려받아야하고+내용변경만 재정의용) -&gt; 재사용성 . 앞서 예제인 Document도 완전 동일한 is-a관계지만, 상황에 따라 상속시 원하지 않는 결과를 가져올 수 있다. . | 더군다나 모두 받을 필요 없거나 + 더 추가될 기능이 있다면 상속은 포기해야한다. . . | . 안받아도 되거나 추가될 기능이 존재한다면, 상속은 ㅂㅂ2 extends는 확장개념이 아니라 refine개념(is-a로 일치하면서 일부만 바꿔쓰기용) . . 과거에, OOP 처음 나왔을 때는 재사용성 -&gt; 상속받아서 필요한 부분만 변경해서 쓰자.의 개념이었다. | 지금은 부작용이 많은 설계법 -&gt; 현대는 유연성이 더 중요 | . 추가 얘기거리 -&gt; class 생성자 final or abstract를 붙이자 . . . . 테스트를 위해 interface를 쓸 수 있다. 추상메서드 1개 -&gt; 바깥에서 람다로 구현 가능 -&gt; 테스트에서 람다로 추상메서드까지 구현 | 추상클래스도 가능?? -&gt; 가능해진다. 하지만 람다=익클처럼 사용이 오히려 부작용으로 작용한다. | . | 상속을 염두에 안두었다면 final을 붙여서 class를 설계하라. final을 붙여서 상속안되게 해라. | . | 최소 1곳 이상을 개별 구현해야하는 추상화된 메서드를 포함하고 is-a관계로 개별구현 빼고는 기능이 모두 똑같아서 상속해야하는 class라면 abstract 붙여서 설계해라. 추메 1개면 인터페이스로 가고 -&gt; 익클,람다,테스트가 가능한 것이 된다. | 추메 + @(상태or공통메서드)로 메서드 2개 이상이면 abstract를 붙혀 is-a관계의 상속만 가져갈 예정이라고 생각하자 | 일부자식이 추메를 기능 구현 안할라면 -&gt; 추상클래스로 만들지 말자 | . | . is-a의 abstract 상속 클래스에 -&gt; 일부자식만 새로운 기능추가의 확장 포인트가 생겨 필요하다? -&gt; final을 풀지말고 포장으로 확장해서 사용하면 된다 . class를 final class로 막아뒀다. -&gt; 상속 및 재정의가 불가능하다. . public final class LottoNumbers { private final Set&lt;LottoNumber&gt; value = new HashSet&lt;&gt;(); . | 기능을 추가해서 확장해야하는 경우가 생긴다면 -&gt; 기존 상속은 건들지말아야함. . | 자식들 모두 공통메서드 or 각각 모두 개별구현 가능이 아니라면 -&gt; 포장하는클래스를 파고 내부에서 확장하자 . | 좀더 세부적이고 확장된 이름으로 포장 클래스를 파서 확장하는 조합개념을 쓴다. . . 확장하고 싶은 클래스의 인스턴스를 인스턴스 변수로 가지게 한다. . public class SomeLottoNumbers { private LottoNumber lottoNumber; } . | . | 불변 일급컬렉션의 증감메서드 . VO처럼, 불변 일급컬렉션이라면 VO.증감() -&gt; 새객체 응답처럼 컬렉션.add/remove호출()시 가변 가능한 new 새컬랙션&lt;&gt;()을 복사한 새 컬렉션를 응답해줘야한다. . 기존 add: 기존 내부 포장 컬렉션에 add후 증감은 -&gt; 내부증감처리후 노응답 . public final class LottoNumbers { private final Set&lt;LottoNumber&gt; value = new HashSet&lt;&gt;(); public boolean add(final LottoNumber lottoNumber) { return value.add(lottoNumber); } } . | . 01 컬렉션의 add/remove()메소드를 호출받는 일급컬렉션 객체로 그대로 응답되어야한다. . 원래 add/remove boolean 응답 하나 사용안함 | . . public final class LottoNumbers { private final Set&lt;LottoNumber&gt; value = new HashSet&lt;&gt;(); //1. add/remove등 컬렉션의 증감호출시 -&gt; 응답이 일급컬렉션 자신이어야한다.(원래 add/remove boolean응답하나 사용안함) public LottoNumbers add(final LottoNumber lottoNumber) { return value.add(lottoNumber); } } . 02 가변 컬렉션을 new 키워드로 복사해준다 . . . 03 복사한 컬렉션에 add/remove등 컬렉션 증감해준다 . . 04 증감된 복사컬렉션으로 새 일급컬렉션을 만들어서 반환한다. -&gt; 생성자 필요 . . 05 대박) 재료(인자)에 의해 일급컬렉션에 [재료(컬렉션) 파라미터 생성자만 최초]로 생긴다면 그것을 주생성자로 -&gt; 파라미터 없이 내부 빈컬랙션으로 초기화 with this()의 부생성자도 같이 만들어주자. -&gt; 멋도 모르고 과거에 테코 등에서 쓴 기본생성자 = 주생성자this()를 이용한 빈 컬렉션으로 초기화 넣어주는 부생성자 . 필요에 의해 컬렉션을 재료로 받는 생성자가 생겼다. . . | 파라미터 받아 초기화 해주는 생성자가 생겨나는 순간, 인변의 선언과 동시에 초기화는 무용지물이 된다. . . | 기존 외부 인자(재료)없이 빈컬렉션으로 초기화하는 일급컬렉션의 사용이 에러가 난다. . 재료 사용 생성자가 주생성자 . | 처음에 멋도 모르고 쓴 것이 부생성자 . . | . | generate -&gt; construct -&gt; Select None으로 빠르게 파라미터 없는 빈 기본생성자를 생성해준다. . . . . . . | 재료받는 주생성자 this를 활용해서, 초기화용 빈 컬렉션을 주생성자의 재료에 넣어준다. . | 인변을 직접 초기화 해줬던 부분을 삭제한다. . | 05 원소 추가시마다 새 가변 컬렉션이 복사 후 add한 뒤 새 일급컬렉션 객체가 반환되므로 호출부에서는 원소추가/제거 메서드 호출후 다시 할당해야된다. -&gt; 확인은 .size()를 추가 정의해줘서 확인하면 된다. . VO의 경우 count +=1; -&gt; Count count = 는 호출부 그대로 두고 -&gt; +1의 증감부분에 새객체 반환 | . | 일급컬렉션의 경우 .add(원소) -&gt; 일급형 일급 = 는 호출부로 두고 -&gt; .add(원소)의 원소추가제거 부분에 복사된 가변 새컬렉션에 add해서 반환 | . | . public final class LottoNumbers { private Set&lt;LottoNumber&gt; value; public LottoNumbers() { this(new HashSet&lt;&gt;()); } public LottoNumbers(final Set&lt;LottoNumber&gt; value) { this.value = value; } public LottoNumbers add(final LottoNumber lottoNumber) { final Set&lt;LottoNumber&gt; lottoNumbers = new HashSet&lt;&gt;(value); lottoNumbers.add(lottoNumber); return new LottoNumbers(lottoNumbers); } } . 이제부터 일급컬렉션의 add는 새 일급 객체를 응답하므로 -&gt; 호출부에서는 할당으로 받아줘야한다. . 기존: 기존 내부값이 변했음 . | 불변: 변화된 새 컬렉션이 응답된다. -&gt; 기존값 변화가 아니라 새로 생기므로 1 변수에서 받아줘야한다. . . . | . | getter후 .size()때리지말고, .size()를 정의해서 사용하다가 필요없으면 지우자 . . | . void add() { LottoNumbers lottoNumbers = new LottoNumbers(); // lottoNumbers = lottoNumbers.add(LottoNumber.of(1)); lottoNumbers = lottoNumbers.add(LottoNumber.of(2)); lottoNumbers = lottoNumbers.add(LottoNumber.of(3)); lottoNumbers = lottoNumbers.add(LottoNumber.of(4)); lottoNumbers = lottoNumbers.add(LottoNumber.of(5)); lottoNumbers = lottoNumbers.add(LottoNumber.of(6)); assertThat(lottoNumbers.size()).isEqualTo(6); } . (변화 전 기존 객체의)불변 일급컬렉션의 장점 정리 . 기존 객체의 변화가 아니라 불변을 유지하면서 새로운 객체로 응답 한번 생성한 객체는 불변하며, 변화를 요구시 새로운 객체가 반환된다. | 기존 객체는 불변유지로 안전하다. | . | 그로 인해 final 사용할 때 처럼 동일하게 안정화된다. . 반대로 가변 객체는 여러 클래스에서 동시 접근(시간처 접근)시 굉장히 불안하다 . 다른데서 중간에 접근해서 내부값을 변화시키면, 또다른 곳에선 변화된 객체가 반영된다. | 포장(포인터의 포인터)은 업데이트 상태를 반영해주지만, 동시 접근시 불안해지니 기존 객체는 불변으로 접근 한곳에서는 복사본을 이용한 새 객체를 제공해준다. | . | 기존객체만 불면이고 호출시 복사된 새 객체를 제공해주니 DTO처럼 view에 막 던져도 안정적이다 . 건들이고 싶어도 기존 객체는 불변이라 못건들이게 되니 -&gt; view에서도 복사된 가변 새컬렉션을 새 객체로 넘겨주면 된다. | . | 불변객체를 map의 key로 사용하게 될 경우 식별자 변경의 문제가 발생하지 않는다. . key로 사용하는 객체는 불변객체여야한다. | . . | 도중에 실패하는 경우, 일부만 달라질 수 있다. -&gt; 기존 객체는 불변을 유지하게 해줘서 그런 문제(실패 원자성)를 막자. . | |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%A0%95%EC%A0%81%ED%8C%A9%ED%86%A0%EB%A6%AC%EB%A9%94%EC%84%9C%EB%93%9C/%EC%BA%90%EC%8B%B1/cache/%EC%83%81%EC%86%8D/%EB%B6%88%EB%B3%80%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/2022/03/20/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%8B%AC%ED%99%94.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%A0%95%EC%A0%81%ED%8C%A9%ED%86%A0%EB%A6%AC%EB%A9%94%EC%84%9C%EB%93%9C/%EC%BA%90%EC%8B%B1/cache/%EC%83%81%EC%86%8D/%EB%B6%88%EB%B3%80%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/2022/03/20/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%8B%AC%ED%99%94.html",
            "date": " • Mar 20, 2022"
        }
        
    
  
    
        ,"post104": {
            "title": "jupyter nbextension & toggle",
            "content": "nbextension 설치 . 관리자 권한으로 터미널 열기 . | 아래 커맨드 2개 치기 pip install jupyter_contrib_nbextensions . jupyter contrib nbextension install . | jupyter notebook 실행 후 [체크해제] disable configuration for nbextensions | Table of Contents 선택 | | jupyter용 toggle code . 클릭으로 토글할 수 있게 된다. from IPython.core.display import HTML display( HTML(&#39;&#39;&#39;&lt;script&gt; code_show=true; function code_toggle() { if (code_show){ $(&#39;div.input&#39;).hide(); } else { $(&#39;div.input&#39;).show(); } code_show = !code_show } $( document ).ready(code_toggle); &lt;/script&gt; &lt;form action=&quot;javascript:code_toggle()&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Click here to toggle on/off the raw code.&quot;&gt;&lt;/form&gt;&#39;&#39;&#39;) ) . | . 브라우저 지정(크롬 안될 경우) . cmd에서 config 파일 생성 jupyter notebook --generate-config . | 생성된 jupyter_notebook_config.py의 경로로 가서 열고, .browser 검색하여 아래처럼 수정 #c.NotebookApp.browser로 되어있는 주석을 풀고 windows10 크롬경로 + %s를 입력해주고 재시작 c.NotebookApp.browser = &#39;C:/Program Files (x86)/Google/Chrome/Application/chrome.exe %s&#39; . | 참고) 크롬을 기본 브라우저로 지정 . 크롬 열기 -&gt; 우측상단에 점점점 -&gt; 설정 | 내리다 보면 기본 브라우저 -&gt; 크롬으로 변경 |",
            "url": "blog.chojaeseong.com/configuration/jupyter/toc/nbextension/toggle/settings/2022/03/19/jupter_notebook_toc_setting.html",
            "relUrl": "/configuration/jupyter/toc/nbextension/toggle/settings/2022/03/19/jupter_notebook_toc_setting.html",
            "date": " • Mar 19, 2022"
        }
        
    
  
    
        ,"post105": {
            "title": "typora image uploader(picGo+token)",
            "content": "스샷 레포 생성 후 토큰 생성 . 레포 설정 참고 블로그 | . 빈 github_id로 로그인해서 스크린샷 레포를 만든다. . . | 프로필 &gt; Settings &gt; Developer settings로 넘어간다. . | Personal aceess tokens로 넘어와 &gt; Generate new token을 만든다. . 각종 필요한 설정을 해준다. . Note: 아무거나 . | Expiration: 무기한으로 . . | scopes . repo 전체 체크 . | write: packages 체크 . | admin:repo_hook 체크 . | write: discussion 체크 . . | . | 토큰을 챙겨놓는다. . | . | . | TYPORA에 적용 . . 서식 &gt; 이미지 &gt; 전역 이미지 설정 . when Insert : upload image로 선택 . | [x] 로컬 이미지에 위 규칙을 적용 체크 . | image Uploader: PicGo-Core(command line) 선택 . | Open Config File클릭후 아래 템플릿대로 작성 . 예시 | . { &quot;picBed&quot;: { &quot;current&quot;: &quot;github&quot;, &quot;github&quot;: { &quot;repo&quot;: &quot;is2js/screenshots&quot;, //변경 &quot;token&quot;: &quot;ghp_8nmOf//ymaH8bBHqXNsLRtoTHUEN8j1B6vh/&quot;, //변경 &quot;path&quot;: &quot;&quot;, &quot;customUrl&quot;: &quot;https://raw.githubusercontent.com/is2js/screenshots/main&quot;, //변경 &quot;branch&quot;: &quot;main&quot; } }, &quot;settings&quot;: { &quot;showUpdateTip&quot;: true, &quot;autoStart&quot;: true, &quot;uploadNotification&quot;: true, &quot;miniWindowOntop&quot;: true }, &quot;needReload&quot;: false, &quot;picgoPlugins&quot;: {} } . | | . 사용 중 레포지토리만 교체 . typora &gt; 서식 &gt; 이미지 &gt; 전역이미지 설정 &gt; Open config file &gt; . &quot;repo&quot;와 &quot;customUrl&quot;에서 폴더명만 바꿔주면 된다. . | 토큰은 계속 유지중이니.. 레포만 바꿔주면 끝. . . | . | .",
            "url": "blog.chojaeseong.com/configuration/typora/picgo/github-token/settings/2022/03/18/typora_screenshot_by_github_token.html",
            "relUrl": "/configuration/typora/picgo/github-token/settings/2022/03/18/typora_screenshot_by_github_token.html",
            "date": " • Mar 18, 2022"
        }
        
    
  
    
        ,"post106": {
            "title": "전략패턴 3(일급 수동생성 TestUtil)",
            "content": "일급컬렉션에 적용된 전략패턴의 수동 데이터 . 01 포장된 일급컬렉션 내부 변수(list&lt;단일객체&gt;)를 생성자에서 랜덤으로 생성하여 초기화하는 부분에 전략패턴 적용된 상태 . public class CardDeck { private final Deque&lt;PlayingCard&gt; playingCards; public CardDeck(final CardGenerator cardGenerator) { this.playingCards = cardGenerator.generate(); } . 02 문제는 수동으로 일급컬렉션 인스턴스 변수인 Deque&lt;PlayingCard&gt; playingCards = 를 테스트에서 case마다 가변변수 -&gt; Add or Push로 직접 만들어 줘야한다?! . 전략객체 주입 대신 전략메서드 응답값까지 넣어줘서 전략메서드를 무시하고 바로 처리되게 한다. . () -&gt; [Deque&lt;PlayingCard&gt; playingCards 미리 만들어서] | . private final Deque&lt;PlayingCard&gt; playingCards; public CardDeck(final CardGenerator cardGenerator) { this.playingCards = //전략메서드 호출() &lt;-- 자리에 람다 오른쪽 부분이 들어간다 // () -&gt; [전략메서드 호출()자리에 들어갈 수동 응답값] } . | . 빈 deque를 만든다. . | 수동으로 new PlayingCard(단일객체)를 만든다. . | 여러개 만들어서 빈 deque에 push한다. . @DisplayName(&quot;딜러가 버스트인 경우, 패배 결과 객체를 반환하는지 확인한다.&quot;) @Test void burst_dealer_lose() { //given PlayingCard card = new PlayingCard(Suit.CLUBS, Denomination.KING); PlayingCard burst1 = new PlayingCard(Suit.HEARTS, Denomination.KING); PlayingCard burst2 = new PlayingCard(Suit.HEARTS, Denomination.JACK); PlayingCard burst3 = new PlayingCard(Suit.HEARTS, Denomination.QUEEN); Deque&lt;PlayingCard&gt; rawCardDeck = new ArrayDeque&lt;&gt;(); rawCardDeck.push(card); rawCardDeck.push(burst1); rawCardDeck.push(burst2); rawCardDeck.push(burst3); cardDeck = new CardDeck(() -&gt; rawCardDeck); cardDeck.drawTo(dealer); cardDeck.drawTo(dealer); cardDeck.drawTo(dealer); cardDeck.drawTo(gambler); //when final GameResult result = GameResult.of(dealer, gambler); //then assertThat(result).isEqualTo(GameResult.LOSE); } . | 03) 대박) 수동으로 전략패턴 적용된 일급컬렉션 수동 생성하는 부분을 메서드 추출한 뒤 -&gt; 가변 인자 등 메서드화 해주자. . 01 (input)직접 넣어주는 단일객체는 인자로 받아 -&gt; (ouput)으로 원하는 일급이 나올 수 있게 -&gt; 메서드 추출부터 하자. . . . 02 직접 입력한 input(단일객체)들이 파라미터로 안나온다면-&gt; 파라미터 추출을 해주자. . 파라미터로 추출로 해줘야, 내부에 있던 실제 단일객체들이 외부에서 사용으로 빠져있다. . . | . . . 03 파라미터로 지역변수화 되었으니 변수는 이제 없애준다. . . private void createCardDeck(final PlayingCard card1, final PlayingCard card2, final PlayingCard card3, final PlayingCard card4) { Deque&lt;PlayingCard&gt; rawCardDeck = new ArrayDeque&lt;&gt;(); rawCardDeck.push(card1); rawCardDeck.push(card2); rawCardDeck.push(card3); rawCardDeck.push(card4); cardDeck = new CardDeck(() -&gt; rawCardDeck); cardDeck.drawTo(dealer); cardDeck.drawTo(dealer); cardDeck.drawTo(dealer); cardDeck.drawTo(gambler); } . 04 여러개 들어오는 단일객체에 대해서 null방지용으로 1 + 가변인자로 받아준다. . 첫번째 것만 직접 add . 가변인자는 배열로서 for문 / .stream 등을 활용한다. . addAll()같은 메서드가 있으면 바로 사용하면 된다. . | 예시 . public class CardFixtureGenerator { public static List&lt;Card&gt; createCards(Card firstCard, Card... remainCard) { final List&lt;Card&gt; cards = new ArrayList&lt;&gt;(); cards.add(firstCard); cards.addAll(Arrays.stream(remainCard) .collect(Collectors.toList())); return cards; } public static void pollCards(final CardDeck cardDeck, final int pollCount) { for (int i = 0; i &lt; pollCount; i++) { cardDeck.provideCard(); } } } . | . | . private void createCardDeck(final PlayingCard card1, final PlayingCard... cards) { Deque&lt;PlayingCard&gt; rawCardDeck = new ArrayDeque&lt;&gt;(); rawCardDeck.push(card1); for (PlayingCard card : cards) { rawCardDeck.push(card); } cardDeck = new CardDeck(() -&gt; rawCardDeck); cardDeck.drawTo(dealer); cardDeck.drawTo(dealer); cardDeck.drawTo(dealer); cardDeck.drawTo(gambler); } . | . 05 전략객체 대신 전메응답값이 포함된 람다를 주입하여 일급컬렉션 생성후 return으로 응답까지 . 생성외 부분은 다시 보낸다. . . . . | . private CardDeck createCardDeck(final PlayingCard card1, final PlayingCard... cards) { Deque&lt;PlayingCard&gt; rawCardDeck = new ArrayDeque&lt;&gt;(); rawCardDeck.push(card1); for (PlayingCard card : cards) { rawCardDeck.push(card); } return new CardDeck(() -&gt; rawCardDeck); } . 06 다른 곳에서도 쓸 수 있게 testutil &gt; xxxxFixtureGenerator &gt; public static method . 직접 잘라내서 붙여하므로 직접 고쳐줘야한다. . F6 move method는 (프로덕션 -&gt; 프로덕션 or Test -&gt; 프로덕션) 정도만 지원하는 것 같다. | . | public static 으로 만들어줘야 import후 객체생성없이 바로 갖다 쓰는 유틸이 된다. . | . . . . public class CardDeckFixtureGenerator { public static CardDeck createCardDeck(final PlayingCard card1, final PlayingCard... cards) { Deque&lt;PlayingCard&gt; rawCardDeck = new ArrayDeque&lt;&gt;(); rawCardDeck.push(card1); for (PlayingCard card : cards) { rawCardDeck.push(card); } return new CardDeck(() -&gt; rawCardDeck); } } . . 07 사용은 가변 변수 fixture &lt;—를 초기화해주는 해주도록 사용한다.(겹친다면 @beforeEach에서 초기화) . cardDeck = createCardDeck( new PlayingCard(Suit.CLUBS, Denomination.KING), new PlayingCard(Suit.HEARTS, Denomination.KING), new PlayingCard(Suit.HEARTS, Denomination.JACK), new PlayingCard(Suit.HEARTS, Denomination.QUEEN) ); . .",
            "url": "blog.chojaeseong.com/java/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/testutil/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/16/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4-3(%EC%9D%BC%EA%B8%89-%EC%88%98%EB%8F%99%EC%A0%84%EB%9E%B5-TestUtil).html",
            "relUrl": "/java/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/testutil/blackjack/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/16/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4-3(%EC%9D%BC%EA%B8%89-%EC%88%98%EB%8F%99%EC%A0%84%EB%9E%B5-TestUtil).html",
            "date": " • Mar 16, 2022"
        }
        
    
  
    
        ,"post107": {
            "title": "피드백) 1-2(로또) 코드리뷰",
            "content": "PR- 로또 미션 피드백(제이) . 참고 강의: 제이) 중간피드백 Service와 Controller . | PR1 . | PR2 . | . 구조 . Collections.unmodifiableList(issuedLotto); / issuedLotto인스턴스변수를 넘겨줌 . getter or 메서드 return으로 넘겨주는 list가issuedLotto라는걸 인스턴스변수로 사용한다면, 객체의 어떤 메서드로 issuedLotto를 조작하게되면 반환된 issuedLotto값이 바뀔거에요. 생성자에서 계산후 생성될 때부터 초기화되는 변수가 아니면 인스턴스 변수로 가지지 마라. 메서드에 의해 바뀐다 | my) Collections.unmodifiableList() 대신 List.of() 불변 복사 / new ArraysList&lt;&gt;()가변 변 복사를 사용하자. | . | . . | null처럼 아예 입력이 들어오지 않는 것은 view가 아니라 도메인에서 검증 . nullOrEmtpy와 format정도의 공통검증만 inputView로 옮기겠습니다! | . . | 일급의 getter에서는 외부에서 내부 포장변수 수정 못하도록 수정불가 타입으로 응답하기 . 방어적 복해서 넘기기 | . . . | 누적합 + 카운트는 stream으로 depth줄이기 . . | 도메인 내부에서 toDto 쓰지말 것 컨트롤러에서 from도메인 , to도메인 등을 써서 변환해야한다. | . | 서비스에서 필요에 의해 만들어진 특정 도메인을 관련 로직들은 결국 사용되는 변수를 포장하도록 클래스를 파고( 사용하는 스태틱 클래스를 파도 됨) 그 내부로 로직을 가져간다 . . | 로직의 결과로 나온 데이터가 추가 계산이 필요할 경우 클래스로 파서 포장하는 대신 그 생성과정은 생성자에 넣어라 . | 메인로직을 담당하는 service에서는 인스턴스변수를 두지말고 input -&gt; output의 스태틱 형태를 유지해라. 중요하지 않은 컨트롤러에서 도메인 변수를 생성후 -&gt; 서비스에 input으로 줘도 되니까 . | 컨트롤러에서는 outputView를 메인로직과 같이 묵지말고, 들어가는 input들이 서비스 메서드에 확실히 필요한 것들인지 한눈에 파악하게 작성 . . | Dto는 민감한 데이터, 불필요한 데이터를 짤라 넘기는 것인데, 작은 프로젝트들에서는 다 쓰인다. 넘겨도 된다~ dto를 항상 만들라고 하지말자~ | . | 빈 List가 가능한 자리에는 early return + Collections.emptyList() 활용 | . | 서비스가 비대해진다면, 도메인 로직을 포함하고 있는지 점검하기 . 도메인 로직은 도메인 (없으면 추출해서) 클래스에서 처리하기 | . | 다른 도메인과 추가 검증, 비교로직이 필요할 경우, 이미 포장된 도메인이라도 한번더 포장할 수 있다. . 입력받은 당첨Lotto + 보너스볼은 같이 다니며 + 검증도 요구된다 | . . 추가 로직 없이 단순히 같이 다니는 것들을 포장해서 2개의 상태값으로 보관할 수 있다.` 블랙잭에서 dealer + gamblers -&gt; Players -&gt; this.dealer + this.gamblers | 같이 다녀서 포장 -&gt; 필요할 땐, 각각 getter로 바로 줘도 된다. | . | . | 네이밍 . final priavate -&gt; 접근제한자 final 순으로… . | 상수 &lt;-&gt; 변수 개행 -&gt; class 생성후 개행도 해주기 . | 도메인Factory는 정펙매가 너무 커서 static클래스로 뺀 것 . | 다른 크루들 PR 참고 . 베루스 - 앨런 리차드 - 루피 케이 - 던 후니 - 엘런 . 구조 . Lotto내 상수 1_000이 Lottos, Money도 알아야한다? . public 상수로 ? (X) . | 여러 도메인이 아는 상수라도 각 도메인패키지내에 도메인상수들을 class로 관리하는 것도 좋은 방법이라고 생각해요 . 1_000원 이라는 것이 로또와 금액, Lottos가 모두 알아야 한다면 1_000원이라는 금액이 Lotto 에 있는 것이 맞는 것인가? 어쩔 수 없이 각 객체별로 공유해야하는 상수가 있다면 그 값은 누가 갖는게 맞는가? 에 대해서도 고민해보면 좋을 것 같아요. 지금처럼 로또가 같는 것도 방법이고, 도메인패키지내에 도메인상수들을 관리하는 것도 좋은 방법이라고 생각해요🙂 . | . | 포맷팅(변환)은 view(입력)에 따라 달라지니 중요하지 않은 controller에서! . convert를 도메인에서하면, 입력달라질 시 -&gt; 도메인도 같이 수정되어야한다. . | formating, convert는 자주 바뀌는 view에 따라 달라지니, 중요하지 않은 controller에서 . 포맷팅은 분명 현재 로또게임에서 중요한 로직이지만 입력과 도메인을 분리하기 위해서는 저는 Controller 패키지에서 담당하는 것이 맞다는 생각이 들어요🙂 추가로 DTO와 같은 객체들을 통해서 각 패키지나 레이어에서 필요로 하는 포맷을 재정의할 수도 있습니다. . | . | controller에서는 상태값을 가지지 말 것 . 다른 사용자는 다른 controller 인스턴스 객체를 가질 것이라고 생각해서 문제가 없다고 생각했어요. . 다른 사용자라도 여러 사용자가 같은 인스턴스 객체사용 가능 -&gt; 상태값 오염 가능 | . `synchronized`의 잠금을 통해 멀티쓰레드 환경에서 안정성을 보장할 수 있지만, 현재는 인스턴스변수를 가지지 않는 것으로 충분할 것 같아요. . | . | controller에서 도메인 객체(domain) 생성 메서드 &lt;-&gt; 출력(view)메서드을 1개 메소드로 묶지말 것 . controller에서 전체 로직에 대한 행위들이 프로그램 전체를 나눠서 설명할 수 있게 끔만 나눌 것 . controller전체를 너무 간결하게 나누지 말것 | 실행과 출력도 나눌 것 | . 비즈니스로직을 실행하는 행위와 출력하는 행위는 분리되는 것이 관심사가 분리되는 것이라 생각이 되어요. 두 가지의 역할이 하나의 메소드에 들어가는 것 보단, 각각 관리될 때 역할이 하나기 때문에 유지보수하기 용이한 코드가 아닐까 라는 생각을 하고 있습니다.🙂 . | . | 일급컬렉션도 컬렉션이라서 add 메서드 추가해도 된다! 가변 컬렉션, 불변 컬렉션 따로 있는 듯. | . | (베) . inputView에서 커스텀Exception을 쓰는 순간 -&gt; view에서 백엔드의 Exception을 의존하게 된다 -&gt; 쓰지말 것 . | List&lt;일급&gt;도 일급컬렉션으로 포장할 것 . | 뭔가 인스턴스 변수를 인자없이 기본생성자초기화해놓고 -&gt; FOR문돌면서 add의 가변값처럼 사용하지마라. -&gt; **일급 가변 생성을 정펙매를 통해 생성과 동시에 + 값할당기능을 제공할 수 있다. ** . // 잘못된 예 Statistic statistic = new Statistic(inputMoney); for (Lotto lotto : lottoes) { statistic.addRank(getRankBy(lotto)); } return statistic; . Statistic를 생성해놓고, 값을 추가하고있는데요. 객체가 가변값처럼 사용되고 있는 것 같아요. Statistic에서 정잭팩토리를 제공해서, 생성과 동시에 값을 할당하는형태로 만드는건 어떨까요? . | list를 합칠 때 -&gt; 빈 리스트(가변값)에 add를 대신하는 stream . 기존list.stream() + 새list.stream() -&gt; Stream.concat() -&gt; collect( collectingAndThen( toList(), 포장생성자::new ) . 2stream 을 1개 list로 변환해서 모으고 -&gt; 포장까지 할 수 있다.!! | . public Lottoes combine(Lottoes other) { List&lt;Lotto&gt; result = new ArrayList&lt;&gt;(); result.addAll(lottoes); result.addAll(other.lottoes); return new Lottoes(result); } // 변환후 public Lottoes combine(Lottoes other) { return Stream.concat(lottoes.stream(), other.lottoes.stream()) .collect(collectingAndThen(toList(), Lottoes::new)); } . | . | . | (리) . controller에서 input받을때의 안내문 -&gt; InputView.printException(exception); . | 미래를 예측해서 코드를 짤 필요 없다? (확장가능성을 미리 X) . | 콘솔 출력만 하는데 InputView 로 분류하신 이유가 있으실까요 ? . 사용자와 직접 커뮤니케이션 사용자의 요청을 컨트롤러로 전달 컨트롤러의 응답을 최종적으로 사용자에게 전달 콘솔 출력은 사용자에게 오류 메시지 혹은 결과를 전달하는 과정이기 때문에 View의 역할이라고 생각했습니다! 혹시 제가 조금 더 생각해봐야할 지점이 있을까요?! 😅 . | . | (후) . 컨트롤러의 코드는 시나리오로서 글처럼 읽을 수 있게 == input/output명확하게는 . 사용자 시나리오로 글처럼 읽을 수 있는 코드를 만들려고 노력하고있는데요. 이 부분은 돈을 생성하는게 아닌, 돈을 입력받는 부분이 아닐까요? . | 일급이 중복을 허용하지 않는다 -&gt; List대신 Set을 상태값으로 가져도 . 중복검사가 제거된다 -&gt; 갯수검사만 하면 됨. | LinkedHashSet을 쓰면 정렬도 | . | 도메인 검증은 도메인 기본 생성자에서 . 1~45의 숫자인게 도메인 규칙인데요. 이 부분이 &#39;생성하는 곳&#39;에서 검증되어야한다고 생각 . | inputview에서 반복해서 입력받기 가능. . 그러나 stream 작성하면 디버깅이 어려울 수도 있음. | . public static List&lt;List&lt;Integer&gt;&gt; inputManualLottos(final int counts) { System.out.println(INPUT_MANUAL_LOTTO_NUMBER); return IntStream.range(0, counts) .mapToObj(index -&gt; inputManualLotto()) .collect(Collectors.toList()); } . | (중복) 가변으로 list 추가로 받기 . 기존과 들어올 list 모두 stream으로 concat하여 불변형태로 합치기 | . | 스트림내 스트림은 가독성 -&gt; 메서드 분리 . | . | (후) . LottoNumber 정적메서드만 있는 static Factory 클래스로 싱글톤(service, cahce)를 대체하자. . 블로그 | . | LottoResult -&gt; Map을 초기화시켜놓고, 거기에 하나씩 put하는 형태인데요. 집계함수(groupingBy)도 고려해볼 수 있을 것 같아요. 🙂 . map을 put이 아니라 replace로? ㄴㄴ . //수정 전 final Map&lt;Rank, Integer&gt; rankResults = Rank.initResultMap(); for (Lotto lotto : lottos.getLottos()) { Rank rank = winLotto.matchResult(lotto); rankResults.replace(rank, rankResults.get(rank) + 1); } return new LottoResult(rankResults); . replace를 사용함으로써 initialize한 key값 외 예외적인 값이 들어올 상황을 방지 개인적으로 방어적인 코드보다, 빠른 피드백을 받을 수 있도록 예외를 던지는게 더 좋다고 생각하고있어요. 근본적으로 Rank.initResultMap();로 씨드를 만든 Map으로 put해주는 구조가 조금 특이하긴 하네요..🤔 . | . | map을 거꾸로 출력도 view에서!!해야함 - &gt; values().stream -&gt; view의 책임이라 inputView에서 . toReverseList 는 뷰에 의존적인 코드라고 생각해요. 거꾸로 순서가 필요한 건 뷰의 책임이라고 생각하는데, 뒤집어주는 건 뷰에서 처리하는게 좋을 것 같아요. . | toString()활용보다는 그냥 getter . | . | NEW_LINE = System.lineSeparator() 도 상수화 . | 역순으로 출력안하고 title만 하드코딩 + 개별요소만 get하는 sense . public class ResultView { public static void printResult(LottoResult lottoResult) { System.out.print(System.lineSeparator()); System.out.println(&quot;당첨 통계&quot;); System.out.println(&quot;&quot;); System.out.println(&quot;3개 일치 (5000원) - &quot; + lottoResult.getLottoResultByRank(FIFTH).getCount() + &quot;개&quot;); System.out.println(&quot;4개 일치 (50000원) - &quot; + lottoResult.getLottoResultByRank(FOURTH).getCount() + &quot;개&quot;); System.out.println(&quot;5개 일치 (1500000원) - &quot; + lottoResult.getLottoResultByRank(THIRD).getCount() + &quot;개&quot;); System.out.println(&quot;5개 일치 보너스 볼 일치(30000000원) - &quot; + lottoResult.getLottoResultByRank(SECOND).getCount() + &quot;개&quot;); System.out.println(&quot;6개 일치 (2000000000원) - &quot; + lottoResult.getLottoResultByRank(FIRST).getCount() + &quot;개&quot;); System.out.println( &quot;총 수익률은 &quot; + lottoResult.getRateOfReturn() + &quot;입니다.(기준이 1이기 때문에 결과적으로 &quot; + getWinOrLoseByLottoResultDto(lottoResult) + &quot;라는 의미임)&quot;); } private static String getWinOrLoseByLottoResultDto(LottoResult lottoResult) { if (lottoResult.getRateOfReturn() &gt; 1) { return &quot;이익&quot;; } return &quot;손해&quot;; } } . | 만약 역순 출력한다면? . map을 돌고 있으니, 각 요소들이 comparable 상속 중이면 .sorted(Comparator.reverseOrder()) . If your stream elements implements Comparable then the solution becomes simpler: ...stream() .sorted(Comparator.reverseOrder()) . | values()만 역순으로 하고 싶다면.. list로 바꿔서.. . List&lt;Rank&gt; ranks = Arrays.asList(Rank.values()); Collections.reverse(ranks); . | . | . docs . 어떠한 프로그램이다(요구사항), 혹은 실행결과 등도 같이 정의 . 문서에 이 프로그램이 그래서 어떠한 프로그램이다, 혹은 실행결과 등을 같이 보여준다면 프로그램을 훨씬 빠르게 이해할 수 있을 것 같아요. . 예시 . ## 요구 사항 가상으로 사용자가 로또를 구매하고 지난주 당첨 번호를 직접 입력하여 당첨이 얼마나 되는지 수익률이 몇인지 알 수 있는 프로그램입니다. - java로만 구현된 애플리케이션(jdk11버전) - 터미널에서 사용자가 구입금액, 지난주 당첨 번호를 입력하고 터미널에서 결과를 확인할 수 있다. - 로또는 1 ~ 45 중 랜덤으로 6개의 번호를 가진 로또를 발급한다. - 로또는 1장당 1000원이다. - 당첨기준은 실제 로또와 같다. ## 실행 결과 text 구입금액을 입력해 주세요.(1000원~20억원) 14000 . | ## 페어프로그래밍 컨벤션도 유지 . ## 페어 프로그래밍 컨벤션 - 10분 간격으로 역할을 바꾼다. - BDD 테스트 코드 작성 패턴으로 작성한다. - 테스트만 통과할 수 있을 정도로 TDD를 구현한다. - 커밋 단위를 README 기준으로 한다. . | . | . 네이밍 . 메서드 입력요구는 request (getMoney -&gt; requestMoney)?? 내부에서 print 로직을 포함하지 말 것 | print는 controller에서 뿌려주면 됨. | . | 상수는 재사용 뿐만 아니라 의미의 명확화의 관점도 포함된다. . 맞습니다. 깔끔하다면 계속 사용하셔도 됩니다! 다만 우리가 상수화를 할 때 단순히 재사용을 위해서 하는 것 뿐만아니라 의미를 알 수 없는 값에 이름을 부여해서 의미를 드러낸다라는 관점도 있다는 점을 알고 가시면 좋을 것 같아요! . | 사소하더라도 한 줄에는 . 1개 -&gt; stream은 한 줄씩 모두 띄워주는게 가독성이 좋은 것 같아요. 그 역할이 조금 더 뚜렷하게 보이는 것 같아서요. . public Lotto(List&lt;Integer&gt; numbers) { validateNumbers(numbers); this.numbers = numbers.stream().map(Number::new).collect(Collectors.toSet()); . 디미터의 법칙도 객체에게 메시지를 보내라!의 관점 . | 아래는 1줄에 . 1개이지만, 가독성을 위해 stream은 줄 띄우기 . map(Number::new).collect(Collectors.toSet()); . | . numbers.stream() // 스트림을 열고 .map(Number::new) // 가공하여 .collect(Collectors.toSet()); // 결과를 셋으로 만든다. . | Money가 VO가 아니라 검증이 추가되었다면 대명사 Money(X) -&gt; 로또에서만 사용되는 1_000단위의 금액 -&gt; LottoMoney로서 대명사 VO가 아니라 도메인임을 명시해줄 것 . 지금 Money는 로또를 구매하기 위한 금액이기 때문에 1000으로 나누어떨어져야한다는 제약사항이 있어요. 순수한 Money는 아니게 되는거죠. 그렇기때문에 개인적으로는 LottoMoney / PurchaseMoney 와 같이 이 금액은 구매를 위한 금액이고 제약사항이 있다라는 것을 명시할 수 있는 이름을 사용할 것 같아요. . | 특정 프로그램 패키지 안에 있더라도 클래스명에 명시 . 작은 프로그램이지만 앞으로 프로그램이 커질 때 각 클래스들의 패키지를 잘 안보게 되기도 하고, 코드 자체에서 드러나지 않기 때문에 놓치는 경우가 많더라구요. 이런 부분을 지양하고자 저는 후자를 선호합니다🙂 다만 네이밍이 길어지는 단점도 분명 존재하는 것 같습니다. . | 앞에 검증 등 포장되어있다면, 앞에 도메인명을 붙이자.! Number -&gt; LottoNumber | 포장되는 내부 인스턴스 변수를 클래스 그대로 따오지 말고 -&gt; value -&gt; getValue() . | 예외 던질때 메세지 피드백을 상세하게 어떤 값때문에 예외가 발생했는지 추가 | . | . 캐슁 . 캐슁 작업을 Lotto 생성자에서 해주다가 복잡해지니 정적 팩토리 메서드-&gt;클래스 LottoFactory로 뺐다. . 객체생성이 복잡한 경우 팩토리라는 키워드로 조금 더 공부해보시면 좋을 것 같아요. 맞습니다. 정적팩토리메소드를 통해 자동로또를 만들어낸다라는 의미를 잘 드러낼 수 있어요. 추후에 생성이 더 복잡해진다면 생성을 담당하는 LottoFactory와 같은 형태로 리팩토링하는 것도 방법인 것 같아요. . | 처음부터 미리 만들지말고, 생성할때마다 CACHE맵에서 검사후 없으면 반환 . private static final Map&lt;Integer, LottoNumber&gt; CACHE = new HashMap&lt;&gt;(); private final int number; private LottoNumber(int lottoNumber) { this.number = lottoNumber; } public static LottoNumber getInstance(int lottoNumber) { validateRange(lottoNumber); if (CACHE.containsKey(lottoNumber)) { return CACHE.get(lottoNumber); } LottoNumber newInstance = new LottoNumber(lottoNumber); CACHE.put(lottoNumber, newInstance); return newInstance; } private static void validateRange(int number) { if (isOutOfRange(number)) { throw new IllegalArgumentException(ERROR_MESSAGE_FOR_OUT_OF_RANGE_NUMBER); } } private static boolean isOutOfRange(int number) { return number &lt; MINIMUM_LOTTO_NUMBER || MAXIMUM_LOTTO_NUMBER &lt; number; } . | 캐슁은 맵을이용해라 IntStream -&gt; toMap( number -&gt; number, 그걸로 new 객체 생성자() ) . 이펙티브 자바, 아이템 28. 배열보다는 리스트를 사용하라를 한번 찾아보시는 것도 좋을 것 같네요 🙂 | . LOTTO_NUMBER_CACHE = IntStream.rangeClosed(MIN_LOTTO_NUMBER, MAX_LOTTO_NUMBER) .boxed() .collect(Collectors.toMap( number -&gt; number, LottoNumber::new) ); . 블로그 | . | . map . map 돌기: map.entrySet().stream().map( entry -&gt; entry.getKey(), entry.getValue() ) + getKey(enum)에 메서드 정의하여 추가로직 -&gt; sum() . public long getTotalProfit() { return result.entrySet() .stream() .mapToLong(entry -&gt; entry.getKey().multiply(entry.getValue())) .sum(); } . entry는 getKey()할 수 밖에 없으며, 하나의 맾핑된 key객체로서 .메서드( ) 로 메세지를 던진다. -&gt; .multiply( ) . 메서드를 어캐 정의했나 . public long multiply(int count) { return (long) price * count; } . public double getRateOfProfit(Money money) { long totalMoney = 0L; for (Map.Entry&lt;LottoRanking, Integer&gt; entry : result.entrySet()) { //요렇게도 사용할 수 있을 것 같네요🙂 public double getRateOfProfit(Money money) { long totalMoney = result.entrySet() .stream() .mapToLong(entry -&gt; entry.getKey().multiply(entry.getValue())) .sum(); return money.getRateOfProfit(totalMoney); } . | . | . | enumMap: HashMap보다 성능상에서 이점이 많은 것 같습니다. . Null값을 key로 가질 수 없다. | hashcode 충돌이 존재하지 않는다. | 단순 배열의 구조를 가진다. | Enum의 순서를 유지할 수 있다. | . 개인적으로 현재 EnumMap을 사용해서 위의 장점을 얻을 수 있다 라는 접근보단, 어떠한 코드를 구현하는데 있어서 조금 더 적절한 (그것을 위한 형태)가 있다면 사용해보는 것도 좋다라는 생각 . | findAny가 스트림이 직렬이면 findFirst와 동일하게 작동하는군요! . | (베) . 개인코드 -&gt; map초기화시 toMap() + Function.identity(), r-&gt;0이용 . private Map&lt;Rank, Integer&gt; emptyRankMap() { return Stream.of(Rank.values()) .collect(toMap(Function.identity(), r -&gt; 0)); } . | . | (리) . 비교 결과를 알아서 그룹별,갯수의 map에 담아주는 stream . private static Map&lt;Rank, LongSummaryStatistics&gt; getLottoResult(WinningLotto winningLotto, Lottos lottos) { Objects.requireNonNull(winningLotto, ERROR_MESSAGE_FOR_NULL_WINNING_LOTTO); Objects.requireNonNull(lottos, ERROR_MESSAGE_FOR_NULL_LOTTOS); return lottos.getLottos() .stream() .map(winningLotto::getRankByLotto) .collect(groupingBy(identity(), () -&gt; new EnumMap&lt;&gt;(Rank.class), summarizingLong(Rank::getPrize))); } . | map의 values()값만 sum by LongSummaryStatistics . private static long getTotalReturnByLottoResult(Map&lt;Rank, LongSummaryStatistics&gt; lottoResult) { return lottoResult.values() .stream() .mapToLong(LongSummaryStatistics::getSum) .sum(); } . | . | (후) . 누적합을 IntSream으로 변환해서 .sum() 하는게 &gt; reduce(0부터, 변환하면서 누적) 하는 것보다 깔끔하다. . IntStream 스트림을 사용하면 sum() 메서드 활용이 가능해서, 더 읽기좋을 것 같아요. 그리고 메서드체이닝(.)을 행 단위로 나눠주시면 더 읽기 좋습니다 👍 . //수정전 return rankResults.entrySet().stream().map(Entry::getValue).reduce(0, Integer::sum) * Lotto.LOTTO_PURCHASE_MONEY; //수정후 return rankResults.entrySet().stream() .mapToInt(Entry::getValue) .sum() * Lotto.LOTTO_PURCHASE_MONEY; . | . | . Factory . 개인적으로는 객체생성의 롤을 객체에게 전담하도록 하는 편이고, Lotto 와 같이 생성이 복잡한 일부분에 대해서만 팩토리를 사용하는 편이에요. 참고만 부탁드립니다 생성과 팩토리를 통한 생성 두가지가 모두 가능할 때, 이 코드를 유지보수하는 사람이 이 두가지를 적절하게 잘 이용하기 어렵다는 단점도 있을 것 같아요. 객체 생성에 대한 역할을 두 곳에서 관리하고 있기 때문에 | . | . | . test . Nested로 의미가 잘 드러나는 것 같아요🙂 . 여기서는 가독성이라는 측면이 더 중요한 것 같아요. 이 더 가독성이 좋다면 사용하시면 될 것 같습니다. | 똑같은 상태값 공유하는 것들만 다르게 setUp하는 용도로 쓰자. | . 저 개인적으로는 상태값을 공유하고 그 의미가 비슷한 것들은 @nested로 작성하고 이외에 독립적인 것들은 클래스내에 메소드로 작성하는 것 같아요🙂 - 페어와 팀원과 적절한 룰을 만들어가며 장단을 비교해가면 좋을 것 같습니다. . | . (베) . 테스트는 오히려 먼저 변수 선언 (or초기화)후 -&gt; 나중 할당하는 @beforeEach에서 초기화하기 위해 이용한 가변으로 선언 . //LottoesTest.java private static final Lotto[] LOTTOES = new Lotto[]{ Lotto.create(List.of(1,2,3,4,5,6)), Lotto.create(List.of(11,12,13,14,15,16)), Lotto.create(List.of(21,22,23,24,25,26)), Lotto.create(List.of(31,32,33,34,35,36)) }; 테스트 픽스쳐를 만들어주셨는데요. 지금은 큰 문제가 없지만 이 부분도 가변이 될 수 있어서요. 특정테스트에서 값이 변경되어 디버깅이 굉장히 어려워질 수 있습니다. 이 부분을 @BeforeEach로 빼보시는걸 추천해요🙂 . | . .copyOf() . (리) . 읽기전용을 의미하는 Collections.unmodifiableList()이라도, 원본이 바뀌면 따라 바뀐다. 할당받은 변수만 조작불가 -&gt; 원본과는 연결됨 . 생성자에서 검증에서 파라미터 원본값의 오염가능성 -&gt; 포장이 가진 내부 상태값은 연결고리를 끊고난 것을 주자. -&gt; this.value = List.copyOf() | . //수정 전 validateSize(lottoNumbers); validateDuplicate(lottoNumbers); this.lottoNumbers = Collections.unmodifiableList(lottoNumbers); //이 생성자를 사용하는 곳에서 생성자가 실행된 이후에 전달된 파라미터의 원본 값(지역변수이자 원본 값)에 list 를 조작한 뒤 디버깅을 해보시면 좋을 것 같아요 //수정 후 public Lotto(List&lt;LottoNumber&gt; lottoNumbers) { Objects.requireNonNull(lottoNumbers, ERROR_MESSAGE_FOR_NULL_LOTTO_NUMBERS); validateSize(lottoNumbers); validateDuplicate(lottoNumbers); this.lottoNumbers = List.copyOf(lottoNumbers); // 상태값에는 연결고리를 파라미터와 연결고리륵 } . unmodifiableList(anotherList) 로 선언한 참조변수, 즉 복사본 컬렉션에다가 요소를 추가거나 삭제하려고 할 경우, UnsupportedOperationException이 발생 . 그러나 원본 컬렉션에 요소를 추가 / 삭제할 경우, 복사본 컬렉션에서도 그대로 적용 . | 요약 . 원본 컬렉션과 주소값이 다르며 컬렉션 내부 요소들의 주소값은 동일하다. . | 원본 컬렉션에서 요소 추가, 삭제가 일어날 경우, 복사본 컬렉션에서도 적용된다. . | 복사본 컬렉션에서 요소 추가, 삭제를 시도할 경우 UOE 이 발생되며 실패한다. . | | . | List.copyOf(anotherList);를 통한 방어적 복사를 하려면 . 복사본 컬렉션에 대한 요소 추가 / 삭제 시도 시 UOE가 발생한다는 점은 unmodifiableList와 동일 | 그러나 원본 컬렉션에서 요소 추가 / 삭제 가 일어나도, 영향을 받지 않습니다 | 그럼에도 불구하고 copyOf()로 만들어낸 컬렉션이 완전한 불변이라고 볼 수는 없습니다. 왜냐하면 copyOf의 반환값으로 전달된 unmodifiable list에서 객체를 꺼내서, 그 객체 내부의 값을 변경할 경우, 아니면 외부에서 그 객체의 값을 변경할 경우에는 요소 까지 깊은 복사를 하지는 않았기 때문에 값이 변경됨. 원소들도 불변이여야지 완벽한 불변 | . | . | . new ArrayList&lt;&gt;(anotherList), new ArrayList&lt;&gt;() + addAll() 과 동일합니다. 컬렉션의 주소값은 달라지지만, 요소들의 주소값은 동일합니다. 따라서, 컬렉션 레벨의 요소 추가 / 삭제 는 공유되지 않지만, 요소 레벨의 요소 값 수정 등은 공유됩니다.new ArrayList&lt;&gt;(anotherList), new ArrayList&lt;&gt;() + addAll() 과 동일합니다. 컬렉션의 주소값은 달라지지만, 요소들의 주소값은 동일합니다. 따라서, 컬렉션 레벨의 요소 추가 / 삭제 는 공유되지 않지만, 요소 레벨의 요소 값 수정 등은 공유됩니다. . 공부용 코드 . package lotto; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; import org.junit.jupiter.api.Test; public class ListTest { @Test void modify_UOE() { String[] stringArray = {&quot;a&quot;, &quot;b&quot;}; // 배열 final List&lt;String&gt; stringList = Arrays.asList(stringArray); // 가변 스트링 final List&lt;String&gt; unmodifiableStringList = Collections.unmodifiableList(stringList); System.out.printf(&quot;unmodifiableStringList={}&quot;, unmodifiableStringList); // unmodifiableStringList.add(&quot;c&quot;); System.out.printf(&quot;unmodifiableStringList={}&quot;, unmodifiableStringList); } @Test void wrap_and_modify_original_and_get_unmodifiable() { String[] stringArray = {&quot;a&quot;, &quot;b&quot;}; // 배열 List&lt;String&gt; stringList = new ArrayList&lt;&gt;(Arrays.asList(stringArray)); // 가변 스트링 list //final List&lt;String&gt; unmodifiableStringList = Collections.unmodifiableList(stringList); //원본 List&lt;String&gt;을 포장해서 들고 있으면서, 반환만 Collections.unmodifiableList();시키면 UnmodifiableList unmodifiableList = new UnmodifiableList(stringList); List&lt;String&gt; returnedUnmodifiableList = unmodifiableList.getValue(); // a, b System.out.printf(&quot;returnedUnmodifiableList={ % s}%n&quot;, returnedUnmodifiableList.toString()); //add할때는 원본 list에 add -&gt; 이게 객체내부의 value에도 영향을 미칠까? stringList.add(&quot;c&quot;); // a, b, c -&gt; 원본을 고쳤는데, unmodifiableList만 못건들였지, 같이 수정됨. // -&gt; 쓰기불가지만, 컬렉션 주소를 공유 System.out.printf(&quot;returnedUnmodifiableList={ % s}%n&quot;, returnedUnmodifiableList.toString()); } @Test void wrap_and_modify_original_and_get_copyOf() { String[] stringArray = {&quot;a&quot;, &quot;b&quot;}; // 배열 List&lt;String&gt; stringList = new ArrayList&lt;&gt;(Arrays.asList(stringArray)); // 가변 스트링 list // 마찬가지로 원본을 들고 있으면서, 반환만 copyOf로 해주는 클래스 생성 final CopyOfList copyOfList = new CopyOfList(stringList); final List&lt;String&gt; returnedCopyOfList = copyOfList.getValue(); // a, b System.out.printf(&quot;returnedCopyOfList={ % s}%n&quot;, returnedCopyOfList.toString()); //add할때는 원본 list에 add -&gt; 이게 객체내부의 value에도 영향을 미칠까? stringList.add(&quot;c&quot;); // a, b -&gt; 원본을 고쳤는데도, 콜렉션주소가 공유되지 않아, returnedCopyOfList는 불변 System.out.printf(&quot;returnedCopyOfList={ % s}%n&quot;, returnedCopyOfList.toString()); } private class UnmodifiableList { private List&lt;String&gt; value; public UnmodifiableList(final List&lt;String&gt; value) { this.value = value; } public List&lt;String&gt; getValue() { return Collections.unmodifiableList(value); } } private class CopyOfList { private final List&lt;String&gt; value; public CopyOfList(final List&lt;String&gt; value) { this.value = value; } public List&lt;String&gt; getValue() { return List.copyOf(value); } } } . | . | . | . (후) . 페어 덕분에 copyOf에 대해 알게됐는데요, unmodifiable을 이용해서 반환하는 것만으로도 충분히 값 변환에 있어서 안정성을 보장할 수 있을 것 같은데 앨런은 Java 11에서 왜 Collections를 새로 생성해서 반환하는 copyOf를 만들었다고 생각하시나요? . copyOf도 unmodifiableList를 반환하지 않던가요? 😅 List.of()와 List.copyOf()에 어떤 차이가 있을까요? 둘다 불변을 보장하지만, 매개변수 받아주는 것 차이 - List.of 와 List.copyOf는 둘다 unmodifiableList를 반환하는 것은 같지만 전자는 리스트의 요소가되는 여러 매개변수를 받고 후자는 존재하는 리스트를 받아옵니다! copyOf를 사용하면 새로운 리스트를 만들어 unmodifiable로 반환 -&gt; 도메인에서 직접 unmodifiable을 사용하여 반환하는 것보다도 더 안전하게 리스트를 사용 코멘트 감사합니다! �업무에서 List.of()를 사용하고 있었는데, 조사해준덕분에 알게됐군요! copyOf를 활용 . | . for vs stream . 횟수가 적을 땐 for -&gt; 그 자체를 여러번 돌릴 땐 stream -&gt; 스레드 세이프라면 .parallel()도 선언해서..하면 더 빠르다. . | stream으로 전체 중 일부를 뽑는 랜덤을 구현 . 전체list -&gt; shuffle -&gt; stream + .limit()+ sorted() + 캐슁getInstance + tolist or .limit()대신 list상태에서 .subList() | . private static List&lt;LottoNumber&gt; getAutoLottoNumbers() { List&lt;Integer&gt; lottoNumbersForNewLotto = new ArrayList&lt;&gt;(lottoNumbers); Collections.shuffle(lottoNumbersForNewLotto); return lottoNumbersForNewLotto.stream() .limit(LOTTO_NUMBERS_SIZE) .sorted() .map(LottoNumber::getInstance) .collect(toList()); } . | .",
            "url": "blog.chojaeseong.com/java/feedback/review/%EB%A1%9C%EB%98%90/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/15/%ED%94%BC%EB%93%9C%EB%B0%B1)-1-2(%EB%A1%9C%EB%98%90)-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0.html",
            "relUrl": "/java/feedback/review/%EB%A1%9C%EB%98%90/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/15/%ED%94%BC%EB%93%9C%EB%B0%B1)-1-2(%EB%A1%9C%EB%98%90)-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0.html",
            "date": " • Mar 15, 2022"
        }
        
    
  
    
        ,"post108": {
            "title": "의연방03-1) 상관관계 측정",
            "content": "상관관계를 제는 측도와 바이어스 위험요소 &lt;-&gt; 질병간의 상관관계는 산점도로 나오는게 아니다 | risk개념을 알고 -&gt; RR/OR을 통해서 상관관계를 젠다 | . | . &#47785;&#52264; . Absolute risk | RR(Relative risk) &amp; OR(odds ratio) | Attributable risk | Bias | 상관관계를 제기 위해서는 Absolute risk 및 이와 비교하는 메져(RR(Relative risk) &amp; OR(odds ratio), Attributable risk)들이 필요하게 된다. | bias: 상관관계 및 인과관계를 추론할 때 쓰이는 3가지 개념 중 첫번째 개념이다. 나머지 2 개념은 다음시간에 알아본다. | . | . Absolute risk . incidence(특정기간, 인구집단내, 새롭게 질병발생, 환자 비율)와 비슷한 개념이다. 비율이라 보통 1000명당, 10만명당 으로 표현된다. | . | Absolute risk: 말그대로 질병이 발생할 0~1사이의 확률 incidence와 비슷해보이나 incidence: 확률에 x (단위)명당 개념 -&gt; 주로 양수? vs Absolute risk: 0~1사이의 확률 | 줄여서 Risk라고도 하니 Risk는 질병발생 확률(0~1사이)이다라고 생각하자 | incidence와 달리 특정기간이 없이 생략되기도 한다. risk도 기간을 명시하는게 원칙이긴 하지만 생략됨. 예) &quot;어떤 위험에 노출된 이후 -&gt; 3년내 이 질병이 발생할 리스크(확률)&quot; -&gt; 3년내 가 생략된다 특정기간이 없는 리스크는 시간을 따지지 않고, 아무리 오래걸리더라도 1번이라도 발생될 확률로 해석 하면 된다. | . | . | 근본적으로 같은 개념이다. incidence의 몇명당의 개념 때문에 단위가 차이나 보일 뿐 예) &quot;어떤 집단에서 어떤 질병의 risk가 0.003이다&quot; risk는 0.003으로 0~1사이 확률이지만 | 1000명당으로 보고 X 1000 하면 양수 3이 된다. -&gt; incidence는 1000명당 3명이다. | . | incidence = risk X 단위사람 수로 생각하면 된다. | . | . | . . Absolute risk &#44228;&#49328; &#50696;&#51228; . 위험요소 - 질병에 대한 Risk를 계산하기 위해서는 위험요소 노출시 risk(확률) | 위험요소 노출X시 risk(확률) 2CASE를 각각 구해서 비교한다 | . | 흡연자 1000 | 비흡연자 1000명 각각 찾아서, 10년간 FU(팔로우업)해서, CHD(관상동맥질환) 발생여부를 조사했다 흡연자 1000명 중 28명 CHD 발병 -&gt; 흡연자의 Absolute risk(확률) = 28/1000 = 0.028 | 비흡연자 1000명 중 17명 CHD 발병 -&gt; 비흡연자의 Absolute risk(확률) = 17/1000 = 0.017 | . | . &#51656;&#48337;&#44284; &#50948;&#54744;&#50836;&#49548;&#51032; &#49345;&#44288;&#44288;&#44228; &#44228;&#49328;&#51012; &#50948;&#54620; Risk&#48708;&#44368; . 위험요소와 질병의 상관관계를 조사한다? == 위험요소 노출 -&gt; 질병 Risk vs 위험요소 노출X -&gt; 질병Risk 각각 구해서 비교해야한다. | 위험요소의 (O/X) 2Case 모두에 대해 -&gt; 질병 발생여부(O/X)를 조사 -&gt; 각각의 Risk(확률) 계산 -&gt; 비교를 해야한다 흡연자(위험요소 노출)의 CHD(질병) 발생여부를 통한 Risk계산 | 비흡연자(위험요소 노출)의 CHD(질병) 발생여부를 통한 Risk계산 | . | . | 위-질 상관관계를 위한 -&gt; 위험요소 노출 Risk vs 위험요소 노출X Risk의 2case Risk비교 -&gt; 2가지 비교법이 있다. 상대적 비교 relative risk (RR) = risk ratio | odds ratio (OR) | | 절대적 비교 risk difference (RD) = attributable risk(역학) | | | . . RR &amp; OR . 질병과 위험요소의 상관관계를 위한 상대적 risk비교 | 임상paper에서 rr보다 OR이 더 자주 등장한다. OR은 몇이고, 해석을 하면 어떻다 | OR을 설명해보라고 하면 잘 못하는 사람들이 많다. | . | 이번 강의에서는 개념을 읽히고, 다음 강의에서는 스터디별로 계산법을 배운다. | . Relative risk (RR) . RR: (분자:)위험요소 노출 됬을 때 질병발생확률(risk)이 / (분모:)위험요소 노출X일때 질병발생확률(risk)의 몇배인가 -&gt; 노출시 질병발생확률risk가 몇배냐 공식도 단순하다. 위험요소 노출X 질병발생 확률(risk)이 분모 | . | . RR해석 . 1을 기준으로 분자 or 분모 더 큰 것에 집중 RR&gt;1 분자가 더 큰 경우:위험요소 노출 O 일때가 질병발생확률(risk)이 더 높다 -&gt; 노출시 risk 높으면 양의 상관관계가 있다. or 노출X시 risk가 높으면 상관관계 음으로 있다. | RR&lt;1 분모가 더 큰 경우:위험요소 노출 X 일때가 오히려 질병발생확률(risk)이 더 높다 -&gt; 노출안될 시 risk 높으면 음의 상관관계가 있다 반대면 상관관계 없는 것이 아니므로 조심 | . | . | 1이면 노출O, 노출X risk같다 -&gt; 아예 상관관계 없다 | . | RR=1 : 위험요소 노출됬을 때와 / 노출되지 않았을 때의 질병발생확률이 같다 . 위험요소 &lt;-&gt; 질병발생확률(=질병발생여부)와 관계가 별로 없다 | 노출되든 말든 발생확률이 동일하니까 | 랠러티브 리스크가 1에 가깝다 -&gt; 상관관계가 없다 | . | RR&gt;1 : 분자가 더크다 = 위험요소 노출될 때가 질병발생확률(risk)가 더 높다 -&gt; positive association의 관계 | RR&lt;1 : 분모가 더크다 = 위험요소 노출되지 않았을때가 오히려 질병발생확률(risk)가 더 높다 -&gt; negative association, protective effect 최종 해석은 위험요소 노출시 낮아진다로 해석하자 | 반대로 분자인 위험요소 노출 시가 -&gt;질병이 덜 발생한다 -&gt; 위험요소라고 했지만 오히려 반대로 낮춰주는 보호 효과 | . | . . RR &#50696;&#49884; . . 앞에서 Absolute Risk를 구했었다. -&gt; 그냥 risk로서 RR계산시 사용된다. RR은 분자 = 흡연(위험요소 노출)시 risk = 0.028 / 0.17 = 분모 = 비흡연시(위험요소 노출X) risk 로 계산한다 | RR(=1.65) &gt; 1 해석 분자가 더 크다 -&gt; 위험요소 노출시가 질병발생확률(risk)가 더 높다 -&gt; 흡연과 CHD는 양의 상관관계다 | . | RR은 더 큰 위험요소라도 최종적으로는 분자(위험요소 노출기준)기준으로 해석하며 1에서 떨어진 범위의 %만큼 질병 발생 확률(질병 위험)이 % 높/낮다로 해석한다 분자가 크니 = 더 큰 흡연시 1.65에서 65만큼 %를 사용해 -&gt; CHD 위험(질병발생 확률)이 65%만큼 높다 | 분모가 크다 = 더 큰 비흡연시 0.65에서 1에서 35 -&gt; 질병발생확률이 35%만큼 커진다 -&gt; 흡연시 35%만큼 낮아진다 | . | . | . Odds . RR는 위험요소 노출 case에 따른 2개 risk의 비율(분모가 위험요소노출X)였다. | odds ratio는 risk가 아닌 2개 odds의 비율이므로 odds부터구해야한다. odds: 분자 질병발생 확률p(risk)이 / 분모 질병발생 안할 확률(1-risk, 1-p)의 몇배인가 | cf) rr: 위험요소 노출O 질병발생확률 / 위험요소 노출X 질병발생확률의 몇배인가 | . | risk와 odds의 관계 risk: 질병발생 확률(0~1) 그 자체 | odds: 질병발생 확률 risk(p)가 / 질병발생안할 확률 1-risk(1-p)의 몇배인가 risk가 커지면, risk / 1-risk의 odds역시 커지게 된다. | p/1-p(0&lt;=p&lt;=1) 그래프를 보면 or p를 조절해보면 oods의 범위는 0(p작) ~ 무한대 사이 값(p커) | . | . | . Odds ratio(OR) . risk로 odds = risk/1-risk 를 구해놓은 상태에서 RR와 비슷하게 위험요소 노출O/X case를 각각 분자/분모의 기준으로 놓고 odds 2개의 비율로 odds ratio를 구할 수 있다. | odds도 위험여부 노출O / 노출X 2 case를 미리 구해놔야 -&gt; odds ratio를 분자/분모 나눠서 구한다 | . | odds ratio: (분자:)위험요소 노출O 일때의 odds 가 / (분모:)위험요소 노출X 시의 odds의 몇배인가 risk=질병발생확률이 아니라 거기서 나아가 구한 odds가 사용되는 것을 인지하자 | . | . OR 해석: risk대신 odds가 사용된 비율이지만, 상관관계 해석은 비슷하다. 왜냐면 risk와 odds는 비례하기 때문에 OR=1 : 위험요소와 질병 간 상관관계가 없다 분모=분자 같다 -&gt; 위험요소 노출여부와 관계없이 odds가 같다 -&gt; risk도 같다 -&gt; 상관관계 없다 | . | OR＞1 : 위험요소에 노출되면 질병발생확률이 높아진다(positive association) 분자가 크다 -&gt; 위험요소 노출시 odds가 크다 -&gt; odds크면 risk도 같이 커졌다는 말 -&gt; 위험요소-질병 양의 상관관계 | . | OR＜1 : 위험요소에 노출되면 질병발생확률이 낮아진다(negative association, protective effect) 분모가 크다 -&gt; 위험요소 노출 안될시 odds = risk가 크다 -&gt; 위험요소-질병 음의 상관관계다 | 해석 최종은 위험요소 노출시 더 낮아진다로 위험요소노출O로 해석끝낸다 | . | . | . . OR &#49688;&#49885;&#51221;&#47532; . . p1(p서브원): 위험요소 노출시 risk | p0(p서브제로): 위험요소 노출 안될시 risk my) 위험요소 노출여부에 따라 p1/p0로 나눈다 | . | RR = 위험요소 노출여부에 따라 구한 risk 2개 -&gt; 2case risk의 비율 = p1/p0 = 위험요소 노출시 risk는 노출안되시의 몇배인가? | OR = 위험요소 노출여부에 따라 구한 risk 2개로 -&gt; 위험요소 노출여부에 따라 구한 odds 2개를 계산 -&gt; 2case odds의 비율 | . OR(Odds Ratio) &#50696;&#49884; . . 위험요소 노출O/x에 따른 risk 2개(질병발생확률)가 구해졌는지 확인 문제에서 주어져있다. | 각 risk = (위험요소 노출 O 및 X에 대한 새롭게 질병발생자 수 / 인구 수) | . | risk 2개로, 각각(위험요소 노출O 및 X)의 질병odds 2개를 구한다 . 위험요소 노출시 odds = 흡연시 질병(CHD)odds = 흡연시risk / 1-흡연시risk 0.028/(1-0.028) = 0.029 | . | 위험요소 노출X시 odds = 비흡연시 질병(CHD)odds = 비흡연시risk/1 - 비흡연시risk 0.017/(1-0.017) = 0.017 | . | | 질병odds 2개로 위험요소 노출 Odds가 /위험요소노출X Odds의 몇배냐로 나눠서 구한다. . 흡연자 오즈 / 비흡연자오즈 = 0.028 / 0.017 = 1.7 | . | OR해석: 혹시 1보다 작아도 결국엔 분자 위주로 해석(위험요소 노출시 질병발생여부는 n배) . OR &gt; 1.7: 흡연을 하면, 안할경우 비해, CHD Odds가 1.7배이다 흡연을 하면, 안할경우 비해, (1보다 멀어진만큼인 0.7을 보고) CHD odds가 70% 더 높다 | . | . | RR vs. OR . 랠러티브 리스크(RR)은 해석이 직관적이다 -&gt; 질병 발생 확률(0~1)의 (위험요소 노출에 대한 O/X)비율이니까(위험노출시 몇배 더 발생하냐?) -&gt; 이해가 잘된다 | 그러나 스터디 종류에 따라서 추정이 불가능한 경우가 있다. 즉, bias없는 추정치를, 얻을 수가 없는 경우가 있다. | 예를 들어, case-control study가 그렇다. | . | . | 오즈 레이시오(OR)은 질병 발생 확률의 비율(몇배?)가 아니라 오즈라는 개념을 한번 더 이용해야하므로 직관적으로 와닿지 않고 해석이 어렵다 | 그런데도 불구하고, OR이 훨씬 더 많이 임상논문에서 사용/보고된다. OR은 수학적으로 굉장히 좋은 성질을 가지기 때문 매쓰매틱스 미라클 현상을 보여주기도 하고, 어려운 수학문제를 간단하게 만들어주는 성질이 있다. | case-control 같은 경우도, RR 추정자체가 불가능한데, OR은 추정할 수 있다. | 즉, 스터디 종류를 타지 않고 다 사용된다 | . | . | . | 다행인 점은 질병발생 확률(risk)가 작은 경우에는 RR==OR이 비슷한 성질이 있다. 예시도 RR = OR처럼 나왔다. risk가 너무 작은 값인데, 소수2까지 반올림하니 같아졌음. | 아주 흔한 질병인 고혈압, 당뇨가 아닌 경우라면,대부분의 질병이 질병발생 확률(risk)이 낮다. == 스터디 디자인 때문에 RR이 추정되지 않아도 OR을 쓰면 된다. | . | 공식에서 보면, Odds = p1/1-p1 or p0/1-p0에서, p가 아주 작아진다면 -&gt; 분모는 1에 가까워지고 -&gt; 값 자체는 p1 or p0로서 risk에 가까워진다. | . | . . Attributable Risk . 위험노출된 개개인(흡연자)에 인터벤션(금연보조제) 작동시, 얼만큼의 질병risk감소 효과가 있을까?라는 질문에 대한 답을 AR(e)로 구한다. . 위험노출된 개개인(흡연자)에 인터벤션(금연보조제) 작동시, 얼만큼의 질병risk감소 효과가 있을까? | 위험노출된 개개인(흡연자)에 인터벤션(금연보조제) 작동시, 얼만큼의 질병risk감소 효과가 있을까? | 위험노출된 개개인(흡연자)에 인터벤션(금연보조제) 작동시, 얼만큼의 질병risk감소 효과가 있을까? | . | risk비교 중에 위험요소 노출o/x 집단간 상대적 비교가 아니라 절대적 비교 메저다 . | 예를 들어 인터벤션을 1개 생각해보자. ex&gt; 금연보조제(intervention) . &quot;금연보조제는 -&gt; 흡연 - CHD위험을 얼마나 줄일 수 있을까?&quot; &quot;흡연하던 사람이, 금연을 하면, CHD위험이 얼마나 줄어들까?&quot;와 같은 질문이다. | . | 즉, intervention으로 위험요소 노출 -&gt; 노출X의 상황으로 만들었을 때, 질병위험을 보는 것이다. | . | . 일단 인터벤션 작용 전에 위험요소(흡연자)-질병(CHD)위험의 구성 모델을 쪼개서 생각해본다. 흡연자 - CHD위험: background 질병risk + 흡연 때문에 증가하는 질병risk 위험요소 노출(흡연)과 관계없는 background risk도 있다. | 여기에 위험요소 노출을 통해 risk를 더 올린다. | . | . | 인터벤션 금연보조제이 작용해서 risk를 줄일 수 있는 부분은 흡연 때문에 증가하는 질병risk부분만 해당한다. 금연보조제로 금연을 하더라도, background risk는 줄이지 못한다. | . | . 다시 정리해보면, 위험요소에 노출된 사람의 질병위험 = . background risk(노출되지 않은 사람의 질병위험) 밑에 그래프에서 오른쪽 초록색 부분 | . | 위험요소 노출 때문에 증가하는 risk 위험요소 노출 질병위험은 = background가 기본으로 있고 + 위험요소노출 때문에 background에서 추가로 떠안은 질병위험을 더 떠안게 된다. | . | | 인터벤션으로 줄일 수 있는 risk = 위험요소 노출 때문에 background risk에 추가로 떠안은(증가된) 질병위험 부분이다. . = 위험요소 노출된 사람의 (전체)질병위험 - background risk(노출되지 않은 사람의 질병위험) | = 예방을 통해 달성할 수 있는 포텐셜 | . | my) 위험요소 노출 risk != 위험요소 노출 때문에 증가된(background에서 추가된) risk | my) background risk = (말은)위험요소에 노출되지 않은 경우의 risk = (뜻은) 위험요소 때문에 증가한게 아니라 원래 가지고 있는 risk | . Attributable risk (among the exposed) = ARe = risk difference (RD) . Attributable risk는 아래 개념 때문에 등장한 개념이다. . 위험요소 노출된 사람의 (전체)질병위험 - background risk(말은, 노출되지 않은(노출과 상관없이 가지는?) 사람의 질병위험) | . | among the exposed는 노출된 사람에 한하여 Attributable risk를 계산한 다는 것이다. . 그렇다면, 교재의 위험요소에 노출되지 않은 사람의 질병위험 = 노출여부에 상관없이 background로 가지는 질병위험이라는 뜻이겠다. | among the exposed가 안붙는 Attributable risk도 뒤에 다룰 것이다. | . | ARe(xposed) = RD(Risk Diferrence) = . 위험요소에 노출된 경우의 질병발생확률 - 위험요소에 노출되지 않은 경우의 질병발생확률 이라고 표기하지만 | . | 위험요소 노출된 경우 risk(default background risk 포함된 전체risk) - 위험요소 노출되지 않은 경우 risk(background risk) | = 위험요소 때문에 (background risk에)추가적으로 떠안게 된 risk | . | . Attributable risk fraction (among the exposed) = AFe . ARe = 위험요소 노출 때문에 (background risk에)추가적으로 떠안게 된 risk자체를 report하기도 하지만 | AFe로서 ARe / 위험요소 노출된 경우 risk(default background risk 포함된 전체risk)를 나눠서(전체 중 일부를 나누는 것) . (bg risk포함)위험요소 노출 전체 risk 중 위험요소 노출 때문에 추가적으로 떠안게 된 risk는 전체 중 몇%를 차지하는 가를 의미하는 것을 사용하기도 한다 | . | 예를 들면, 흡연자로서 가지고 있는 전체 CHD risk 중 흡연 때문에 떠안은(증가된 risk는 몇프로를 떠안은 것인가 -&gt; AFe로 계산한다 . | . . AR, AF &#49688;&#49885; &#51221;&#47532; . . ARe = RD로서 risk차이 = 전체risk - backround risk로 계산 . 뭐야.. 전체 risk라고 생각했던 것이 위험노출시 risk = p1이고 | background risk는.. 진짜 위험노출 안됬을 때의 risk= p0였네... 까고보면,, p1 = p0(background risk) + @(추가로 떠안은risk)겠지? | 일단 background risk = p0로 계산하는 것을 외워두자. | . | . | AFe = ARe=RD=risk차이=p1-p0로 계산 해놓은 상태에서 . ARe / p1로 p1자체를 전체risk로 생각하고 나눈다 | (p1-p0)/p1 | 해석: 전체인 p1 중에 attributable risk가 몇프로를 차지하는가? | . | . Attributable risk &#50696;&#49884; . 구하고자 하는 것은: 흡연 때문에 증가한 Attributable risk = ARe = RD = risk차이 = 흡연 때문에 떠안은 risk 및 전체 risk에서 그 것의 비율(%) = AFe = ARe/p1 | . . risk 2개를 구한다. 흡연(위험노출): 28/1000 = 0.028 (p1 = 전체risk) | 비흡연(위험노출X): 17/1000 = 0.017 (p0 = background risk) | . | risk 2개의 차이(p1-p0)가 ARe(RD)다 ARe = 0.028 - 0.017 = 0.011 | . | ARe(RD)를 전체risk(backgroud + RD)를 의미하는 p1으로 나눠 위험요소로 인해 떠안은(증가한) risk는 전체risk의 몇퍼를 차지하는지를 AFe를 구해서 본다. AFe = ARe / p1(전체risk) = 0.011 / 0.028 = 0.392 -&gt; 39% | . | 해석:ARe, AFe는 인터벤션이 작동하여 위험요소 노출O-&gt;X가 되면, 감소되는 risk로서 해석하자. ARe, AFe = 절대적 비교 -&gt; 인터벤션이 나타날 차이 | . 흡연자 금연하면 CHD확률이 0.011(ARe)만큼 줄어든다. | 흡연자 금연하면 CHD확률이 39%(AFe*100) 감소한다 | | Attributable risk for the population = ARp or PAR . ARe: 위험노출된 개개인(흡연자)에 인터벤션(금연보조제) 작동시, 얼만큼의 질병risk감소 효과가 있을까? | ARp: 위험노출된 커뮤니티(도시)(의 흡연자들)에 인터벤션(금연보조제, 금연 프로그램들을 시민에 제공) 작동시, 얼만큼의 &lt;도시전체 incidence&gt; 감소 효과가 있을까? 예시:“시청에서 성공적인 금연 프로그램을 제공하면 도시 전체의 CHD incidence는 얼마나 낮아질까?” | . | . 도시 전체의 CHD incidence(risk?)도 개개인처럼 total risk(p1)과 background risk(p0) -&gt; 그로 인해 구하는 위험요소 때문에 떠안은(증가하는) risk개념이 있을 것이다. . 도시 전체의 CHD incidence = background incidence + 흡연 때문에 증가하는 incidence 흡연을 안해도 기본적으로 CHD는 발생한다 = bg incidence가 있다. | . | 흡연 때문에 증가하는 incidence만큼이 시청 금연프로그램(인터벤션)이 줄일 수 있는 risk의 potential이다 | . | 계산시 주의사항: . 도시든 커뮤니티든..간에 모든사람이 위험에 노출되진 않는다. -&gt; 비흡연자가 포함되어 있을 것이다. but 시청 금연 프로그램 = 인터벤션은 위험노출 O(흡연자)에 대해서만 CHD risk를 줄인다. | 즉, 파퓰레이션 = 흡연자 + 비흡연자로 구성되어있다. 만약, all 비흡연자라면 인터벤션인 금연프로그램 효과는 0으로 나올 것이다. | 흡연자가 많았다면, 인터벤션인 금연프로그램 효과가 크게 나올 것임. | . | . | 인구집단 전체(도시, 국가...)의 질병위험 = background risk + 위험요소노출 때문에 증가하는 risk 인구집단 전체의 관점에서 위험요소노출 때문에 증가하는risk = | 인구집단 전체의 질병위험 – 위험요소에 노출되지 않은 사람의 질병위험(bg로 추정) : potential for prevention 달성할 수 있는 예방효과 포텐셜 | . | . | . . ARp or PAR &#44277;&#49885; . ARp= 인구집단 전체 risk - 위험요소에 노출되지 않은 그룹의 질병발생확률(bg로 추정) | AFp= ARp / 인구집단 전체 risk | . . ARp or PAR &#49688;&#49885; &#51221;&#47532; . . ARp를 계산하기 위해서는 추가적으로 r위험요소에 노출된 사람의 비율 in 전체 population을 알아야하며, r을 가중평균하여 total risk(p)를 구한다 . 전체인구 중 r만큼의 사람만 위험요소에 노출 되었다고 가정한다면, | 인구집단 전체risk 계산법은 가중평균(weighted sum)을 이용한다 p = p1*r + p0*(1-r) (노출된사람비율r에 대해 p1의 risk를 가지고 있고~) | . | . | p를 구했으면 p - p0 (전체rist-노출되지X risk(bg))로 ARp를 구한다. . | ARp/p로 AFp를 구한다. | ARp &#50696;&#51228; . . 아까와 같은 예제이지만, 단, 이 국가의 흡연자 비율은 20%에서 r = 0.2이며 ARp에 대한 문제임을 알아채야한다 국가 레벨에서, Attributable Risk와 Attributable Risk Fraction을 구해보자. | . | . r이 얼만지 확인한다. r = 0.2 | . | risk 2개(p1, p0)가 있는지 확인한다. 28 / 1000 = 0.028 | 17 / 1000 = 0.017 | . | risk와 r로 가중평균을 통해 p(total risk in population)를 구한다. p = p1 X r + p0(1-r) = 0.028 X 0.2 + 0.017 X 0.8 = 0.019 (국가전체의 CHD 위험) | . | ARp는 p1-p0가 아니라 p-p0로 구한다. p - p0 = 0.019 - 0.017 = 0.002 | . | AFp는 ARp(p-p0) / p로 구한다 . ARp / p = 0.002 / 0.019 = 0.104 | . | 해석(AR, AF는 인터벤션으로 인해 위험노출X가 된다면, ARp,AFp만큼 risk가 낮아지는 것을 얘기) . 흡연자가 금연하면 국가 전체의 CHD incidence가 1000명당 2명 줄어든다 확률이 0.002 -&gt; 소수3째자리의 확률(risk)은 -&gt; X1000한 뒤 1000명당을 붙인다 | . | 흡연자가 금연하면 국가 전체의 CHD incidence가 10.4% 감소한다 | | RR vs AR, Af&#51032; &#48708;&#44368; &#50696;&#51228; . . 흡연/비흡연자의 10만명당 사망률을 조사했는데, **이것이 계산이 필요한 질병발생확률인 risk가 된다??? 10만명당 사망률을 == 새롭게 질병발생환자수/인구수인 risk를 미리 계산한 것으로 취급한다 사망률도 risk로 사용될 수 있다. | . | . | . 10만명당 사망률을 risk로 취급해서 보는데, 위험요소O/X 이전에, 질병도 2case 상태라서 -&gt; 질병 1개(Lung Caner)를 먼저 선택해서 보자 . 질병 1개에 대해서 위험요소 노출O/X의 RR, OR, AR 등을 해석해야한다 | . | 질병 1개 Lung Caner에 대한 RR은 위험노출O risk가 / 위험노출X risk의 몇배냐 (발생확률의 비율)다. . RR = risk1/risk0을 계산해야하는데, 사망률 == 미리계산된 risk (새롭게발생환자수/인구수)로 보자. 위험요소노출O risk = 흡연자 사망률 = 140 / 100,000 | 위험요소노출O risk = 비흡연자 사망률 = 10 / 100,000 | RR: 140 / 10 = 14(양의 상관관계) | . | . | 질병 1개에 대한RR의 해석: 기본적으로 발생확률이 몇배냐?를 물어면서 1을 기준으로 상관관계 없다(=)/ 양의 상관관계(&gt;1) / 음의 상관관계 or 프로텍트이펙트(&lt;1)의 상관관계로 해석하기 위해 사용된다. . 1에서 떨어진 만큼이며 위험요소O기준으로 최종 해석을 만든다. | (더 큰 분자 = )흡연시 (1에서 떨어진 만큼)140% LungCancer 사망률(원래는 위험)이 높다. | . | 이제 나머지 질병 1개 CHD에 대해서도 RR 계산 및해석한다. . risk -&gt; 사망률로 -&gt; 위험O(흡연): 669/100,000 | 위험X(비흡연): 413/100,000 | RR -&gt; risk1 / risk0 = 사망률1 / 사망률0 = 669 / 413 = 1.6 (양의 상관관계) | RR의 해석 -&gt; 흡연시 60% CHD 사망률이 높다 | | 각 질병순으로 AR(더 간단)을 계산해보자. . AR = 위험O/X의 risk차이 = 사망률차이 = (p아닌 경우) p1-p0 cf) ARp = r로 구하는 전체/위험X의 risk차이 = 사망률차이 = p(by r)-p0 | LungCancer AR: 140 - 10 = 130 | CHD AR: 669 - 413 = 256 | . | | 질병간 RR로 위험요소와의 상관관계 비교 vs 질병간 AR로 실제 값 차이 + 인터벤션적용시 낮아지는 효과 비교를 해석해보자. . RR: 폐암RR(14.0)이 &gt; CHD RR(1.6)보다 훨씬 랠러티브 리스크가 훨씬 크다. 일단 둘다 1보다 크기 때문에 두 질병 모두 흡연과 양의 상관관계가 있다. (RR=1 상관관계없음) | 폐암이 비흡에 비해 흡연의 사망(원랜 질.발)확률이 훨씬 크다. | RR이 크다 = 흡연(위험요소)-질병간 상관관계(양)가 폐암이 CHD 더 크다 흡연과의 상관관계가 폐암 &gt; CHD보다 더 강력하다 | . | . | AR: 폐암AR(130)보다 CHD AR(256)이 AR이 더 크다. AR1-실제 값차이는 흡연으로 인한 10만명당 사망자수가 CHD가 더 많다. | AR2-인벤효과로 낮아질 %는 금연시 10만명당 사망자 수(원래risk) CHD가 더 낮아질 것이다. | | . | RR과 AR의 차이가 나타는 이유? 다른 종류의 메저인 것은 맞는데... . 흡연자 중 폐암으로 사망 보다 &lt; CHD으로 사망하는 수가 훨씬 더 많아서 그렇다.???!!! risk1(p1)이 LungCaner보다 CHD가 압도적으로 많아서 생기는 현상 | my) 질병간 p1의 실제 값차이가 많이 나면 RR비교/AR비교가 달라진다? my) risk의 비율은 LungCander 압도적 -&gt; RR 압도적이나, 절대적인 수가 CHD비에 딸려서... -&gt; AR(risk비율이 아닌 양차이)은 딸린다. | . | . | . | RR, AR을 통해 알 수 있는 정보 RR을 보니, 흡연은 폐암과 관련이 많긴 하겠지만(RR=(risk비율)상관관계) | AR을 보니, 효과적인 인터벤션(금연치료)를 통해 risk(여기선 사망)을 낮출 수 있는 효과는 CHD가 더 많이 낮아춰 -&gt; 효과가 더 좋다(AR=(risk실제갑차이)반대로 인으로 인한 위험노출X가 될 때 risk를 더 줄인다.) 사망 예방효과로서,은 CHD로 인한 사망이 폐암으로 인한 사망보다 더 save될 것이다. | . | . | &#50672;&#49845;&#47928;&#51228;(RR, OR) . 주 3회 이상 운동한 65세 이상 성인은 100명 당 15명에서 당뇨병이 발병하였고, 주 3회 미만으로 운동한 65세 이상 성인은 100명 당 40명에서 당뇨병이 발병하였다고 하자. 다음 중 틀린 설명은? . 주 3회 이상 운동’라는 인자에 대한 당뇨병의 relative risk는 0.375이다. | 주 3회 이상 운동’라는 인자에 대한 당뇨병의 odds ratio는 약 0.26이다. | relative risk가 1보다 작으므로 주 3회 이상 운동하면 당뇨병 발병 확률이 낮아짐을 의미한다. | odds ratio가 0.26이므로 주 3회 이상 운동하면 당뇨병 발병 확률이 74% 감소함을 의미한다. | RR, OR문제라면, . 위험요소 노출O/X를 행으로 주되, RR, OR은 분자가 위험노출여부O이므로 O-&gt;X순으로 행을 만든다. 위의 문제의 경우 언급되는 것을 위험노출여부 O로 본다. 비록... 주3회이상운동으로 노출X인 것 같지만... 노출O로 본다. | . | 그 외 |노출여부| 전체n | 질병여부 O | (Absolute) risk | Odds|순으로 칼럼으로 가지는 테이블(table)을 작성한다. . //table template //노출여부그룹별 n수 + 질병환자수를 각각 줘서, risk를 a/n으로 계산할 경우 |노출여부| 전체n | 질병 O | (Absolute) risk | Odds| |||||| |흡연|n|a| a/n |r1/1-r1| |비흡연|m|b|b/n|r0/1-r0| //노출여부그룹별 risk를 바로주거나, risk소수점을 없애려고 x k 해놓은 경우 |노출여부| k명당 발생자수(risk에 k곱) | (Absolute) risk | Odds| ||||| |흡연|rr1| rr1 / k |r1 / 1-r1| |비흡연|rr0|rr0 / k|r2 / 1-r2| . | . | 노출여부 k명당 발생자수(risk에 k곱) (Absolute) risk Odds . 주3회이상운동 | 15 | 0.15 | 0.176 | . 주3회미만운동 | 40 | 0.40 | 0.666 | . 각 노출여부그룹별 risk 2개 계산 -&gt; odds 2개 계산 -&gt; 분자:위험(여기선 주3회이상운동이 기준이므로 위험o로 본다/분모:위험X로 몇배냐?를 1을 기준으로 1에서 멀어진 만큼 % 줘서 생각한다. . RR: risk1/ risk0 -&gt; 위험노출될 때가 질병발생확률이 몇배냐(비율)? 0.375 | . | OR: odds1/ odds0 -&gt; 위험노출될 때가 발생비율이 몇배냐?(risk랑 비슷?) 0.264 | . | . | 해석: 1 기준으로 위험노출여부O 하면 ~1에서 멀어진 만큼을 %로 주고 %만큼 높다 /낮다를 말하면 된다. . RR:0.375 &lt; 1 : 주3회이상운동(위험노출여부O)하면, 0.625x100 = 62.5%만큼 질병발생확률이 낮아진다 | OR: 0.264 &lt; 1: 주3회이상운동(위험노출여부O)하면, 0.736x100 = 73.6%만큼 당뇨병 발병 odds(!=발병 확률)가 낮아진다 . OR는 risk에서 한 개념 더 간 것이기 때문에 -&gt; 1에서 멀어진 만큼 해당 질병 발병 오즈가 낮/높아지는 것이다. | 해당 질병 발병 확률의 낮/높은 RR이 판단한다. | . | OR 해석 예) 흡연(위험노출여부O)을 하면, 안할경우 비해, (1보다 멀어진만큼인 0.7을 보고) CHD 발병 odds가 1.7 - 1 = 0.70 -&gt; 70% 더 높다 . | . | . 문제는.. OR은 질병발생확률이 아닌 질병발생Odds의 비율차이가 난다는 것으로 알아라는 교훈 | .",
            "url": "blog.chojaeseong.com/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EC%83%81%EA%B4%80%EA%B4%80%EA%B3%84/rr/or/2022/03/15/%EC%9D%98%EC%97%B0%EB%B0%A903-1)-Measures-of-Association.html",
            "relUrl": "/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EC%83%81%EA%B4%80%EA%B4%80%EA%B3%84/rr/or/2022/03/15/%EC%9D%98%EC%97%B0%EB%B0%A903-1)-Measures-of-Association.html",
            "date": " • Mar 15, 2022"
        }
        
    
  
    
        ,"post109": {
            "title": "강의) 네오 3단계 피드백(블랙잭 상속)",
            "content": "스타버즈 커피전문점을 통한 상속 이해 . 요구사항 . Starbuzz 커피 전문점은 커피와 차를 판매한다. 커피와 차를 준비하는 과정은 각각 다음과 같다. . 커피(coffee) 물을 끓인다. | 필터를 활용해 커피를 내린다. | 컵에 붓는다. | 설탕과 우유를 추가한다. | . | 차(tea) 물을 끓인다. | 차 티백을 담근다. | 컵에 붓는다. | 레몬을 추가한다. | . | . | . 기본 클래스 2개 작성 . Coffee 클래스부터 작성한다 . 요구사항은 /* 로 시작하도록 옮겨놓는다. . . . | 테스트에서 각각의 메서드부터 작성한다. . my) 전체를 모아두는 메서드는… 각각 작성하고 통합호출시 묶어주는 것일 듯? | . . | 메서드들을 한눈에 볼 모든 메서드 호출 메서드 정의하기 . 같은 인스턴스메서드(객체 행위) 단위로서, 현재까지 만든 객체 메서드(행위들)을 모두 한번에 호출해주는 메서드도 Test에서 만든 뒤, 테스트에서의 코드를 잘라내서 내부로 가져가자 . . . | 같은 객체가 호출하던 메서드를 한꺼번에 호출할려고 가져가면, -&gt; 바깥에서 만든 객체로 호출 빨간줄 뜬다. 지워주자. 현재 class내부 = 현재 객체this가 호출하고 있는 중 . . | 모든 메서드들보다위에 위치하도록, 가장 위로 올려준다. . | 비슷한 클래스 Tea클래스도 복붙해서 작성해주자 . public class Coffee { void prepareRecipe() { boilWater(); brewCoffeeGrinds(); pourInCup(); addSugarAndMilk(); } public void boilWater() { System.out.println(&quot;물을 끓인다.&quot;); } public void brewCoffeeGrinds() { System.out.println(&quot;필터를 활용해 커피를 내린다.&quot;); } public void pourInCup() { System.out.println(&quot;컵에 붓는다.&quot;); } public void addSugarAndMilk() { System.out.println(&quot;설탕과 우유를 추가한다.&quot;); } } . public class Tea { void prepareRecipe() { boilWater(); steepTeaBag(); pourInCup(); addLemon(); } public void boilWater() { System.out.println(&quot;물을 끓인다.&quot;); } public void steepTeaBag() { System.out.println(&quot;티백을 담근다.&quot;); } public void pourInCup() { System.out.println(&quot;컵에 붓는다.&quot;); } public void addLemon() { System.out.println(&quot;레몬을 추가한다.&quot;); } } . 상속으로 중복코드제거 -&gt; 공통메서드를 부모클래스를 만들어 올려서 제거(super를 생략하고 쓰는 것) . . boilWater()와 pourInCup() 2개 메서드가 중복이다. | . 클래스 다이어그램을 통해 본 코드 중복(메서드 중복) . . 중복된 메서드만 빼내서 따로 클래스로 분리한다. | . . 01 중복메서드만을 메서드로 가지는 부모클래스 만들기 . 중복된 2 메서드를 + 각각의 클래스명을 보고 부모클래스를 만든다. . . | 중복된 메서드 2개를 복사해서 가져온다. . . package starbuzz; public class CaffeineBeverage { public void boilWater() { System.out.println(&quot;물을 끓인다.&quot;); } public void pourInCup() { System.out.println(&quot;컵에 붓는다.&quot;); } } . | 02 자식들은 상속한 뒤, 중복메서드 -&gt; 공통메서드로 올렸으니 자식에서 공메 정의부 제거 -&gt; 자식들은 자신만의 메서드만 가지고 있기 -&gt; 사용은 super.생략하고 자기것처럼 쓰기 . . 자식들이 만약 상속한 상태에서 부모가 가져간 공통메서드들을 제거해줘야한다. | 부모가 줄 공통메서드를 삭제해도 빨간줄이 뜨지 않는다. | . 03 부모한테 공통적으로 물려받아 쓰는것들에 대해서는 super.을 붙혀도 된다. . ctrl+ 클릭하면 부모로 타고 올라간다. . | 부모한테 물려받아 쓰는 것들은 super.를 앞에 달아서 부모클래스한테 물려받아 쓰고 있는 메서드라고 써도 된다. . . | . my) 추상클래스로 만든다면, 강제 각자구현용 추상메서드를 추가할 수도 있다. . 참고) 상속대신 주입하는 조합으로 중복제거 . cf) 조합을 적용하여 중복코드를 객체로 박기(정리용) . [공통(중복)메서드를 뽑은 클래스]를 뽑는후 [조합으로 중복제거] like 전략패턴 . 참고 01 공통/중복 메서드들을 잘라내기해서 뽑아낸 클래스를 따로 만든다(상속의 부모클래스) . 아래 메서드 중에 boilWater()과 pourInCup()은 다른 곳과도 중복이라 뽑아낼 준비한다. | . public class Coffee { public void prepareRecipe() { boilWater(); brewCoffeeGrinds(); pourInCup(); addSugarAndMilk(); } . public class CaffeineBeverage { public void boilWater() { System.out.println(&quot;물을 끓인다.&quot;); } public void pourInCup() { System.out.println(&quot;컵에 붓는다.&quot;); } } . 중복된 메서드들을 빨간줄 상태 | . 참고 02 중복제거하고 싶은 클래스(Coffee)를 복붙해서 클래스2(Coffee2)를 만들어 조합적용을 준비한다. . . . 참고 03 조합은, 객체 생성자로부터 외부에서 받은 전략객체같은 조합객체를 받아서 상태로 가지고 있는다 (생성자 -&gt; 상태 초기화) . 나는 CoffeeTest에서 Coffee2 생성자 자동생성을 위해 코드를 작성하고 있다. | 참고 04 조합객체.공통메서드() 들을 호출시켜 중복을 제거한다. . . public class Coffee2 { private final CaffeineBeverage caffeineBeverage; public Coffee2(final CaffeineBeverage caffeineBeverage) { this.caffeineBeverage = caffeineBeverage; } public void prepareRecipe() { caffeineBeverage.boilWater(); brewCoffeeGrinds(); caffeineBeverage.pourInCup(); addSugarAndMilk(); } public void brewCoffeeGrinds() { System.out.println(&quot;필터를 활용해 커피를 내린다.&quot;); } public void addSugarAndMilk() { System.out.println(&quot;설탕과 우유를 추가한다.&quot;); } } . my) 조합으로 중복제거란, 전략패턴 중 전략1개만 외부에서 받는 형태인 것 같다. . 추상화 . 04 공통(중복)메서드를 뽑아 extrends 일반상속으로 사용하고 있다면, 이것 부모클래스를 활용해 [나머지 개별메서들을 추상화]하는 데 활용 할 수 있다.(공통메서드 없어도 빈 공통 클래스로 뽑아만 놓는다면) -&gt; 추상화 후보들(추상메서드 후보들)을 추상화 -&gt; 뽑힌다면 추상클래스로 변경해야한다. . 공통(중복)메서드들은 100% 똑같아서 뽑아서 클래스를 만들고 -&gt; super 생략하고 니것처럼 갖다쓸 수 있게뽑은 클래스에서 정의해줬다. 공통메서드 빼기 -&gt; 상속하기 -&gt; 개별 메서드 추상화 살펴보기의 차례다 | . | 나머지 서로 다른 작업들은??? 이제 메서드 추상화 후보 -&gt; 부모클래스도 추상클래스 후보들일 확인해서 추상화 해야한다. | . | . . 중복이 아닌 메서드들을 추상화에 도전해봐야한다. | . CF) 추상클래스 되는 순간 -&gt; 객체생성X -&gt; Test코드는 에러가 난다 . 공통메서드 추출한 부모 클래스 -&gt; 객체 생성가능 . | 공통메서드 + 추상화 메서드 포함 부모클래스 -&gt; 객체 생성 불가능. 상속만 이용가능 . . | . 05 구현부는 다르지만 메서드이름만 추상화 시도 -&gt; 커피를내린다 + 티백을 담근다의 추상화 -&gt; abstract returnType 내린다() 로 추상화 in 상위클래스 . 2개 메서드를 추상화해서 추상메서드를 정의한다. . . public class CaffeineBeverage { abstract void brew(); public void boilWater() { System.out.println(&quot;물을 끓인다.&quot;); } public void pourInCup() { System.out.println(&quot;컵에 붓는다.&quot;); } } . | 06 추상메서드를 가지는 순간 -&gt; 추상클래스로 바꾼다. . 추상화한 astract 메서드를 명시한 순간부터 추상클래스로 바꿔줘야 에러가 사라진다. . . . | 나머지 메서드도 추상화해주자. . . . | . my) 추상클래스 -&gt; 공통메서드뽑은 일반부모에 + 구현부는 다르지만 메서드 이름만 추상화하여 -&gt; 자식은 extends -&gt; super생략한 체, 부모에서 정의한 공통메서드 갖다쓰기 + 추상메서드 개별구현은 override 강제하도록 하는 일부 구현강제된 부모클래스로 해석하자. . 07 추상화가 끝났다면, -&gt; 추상화전 메소드들 정의부가 아닌 사용(호출)처부터 추상화된 이름으로 변경하여 메소드 호출하도록 바꿔준다. . 추상화된 메서드들은 -&gt; 오버라이딩으로 다시 적용해야한다. 일단 둔다. | 추상화된 메서드들을의 사용처부터 이름을 바꿔준다. | . 추상화후보 메서드들이 주석처리 되서 회색상태였다. 추상화된 이름의 메서드로 호출해주자. | ​ . . 08 추상화된 메서드 정의부는 impl(오버라이딩을 impl로) -&gt; 내용 옮겨 주고 - 삭제의 과정을 가진다. . Generate -&gt; Override을 하면 너무 많은 메소드가 잡히니 implements method를 통해 추상메서드만 구현하여 오버라이딩해준다. | . 오버라이딩이 아니라 impl로 오버라이딩 . . | 기존 개별 구체메서드들의 내용을 옮겨준다 . . . | 기존 구체메서드들은 삭제한다. . . | 동일하게 다른 클래스(Tea)에서도 추메 호출부 이름바꿔주기 -&gt; 추메 정의부 impl로 내용옮겨주고 삭제하기 를 진행해준다. . public class Tea extends CaffeineBeverage{ void prepareRecipe() { boilWater(); brew(); pourInCup(); addCondiments(); } @Override void brew() { System.out.println(&quot;티백을 담근다.&quot;); } @Override void addCondiments() { System.out.println(&quot;레몬을 추가한다.&quot;); } } . public class Coffee extends CaffeineBeverage{ public void prepareRecipe() { boilWater(); brew(); pourInCup(); addCondiments(); } @Override void brew() { System.out.println(&quot;필터를 활용해 커피를 내린다.&quot;); } @Override void addCondiments() { System.out.println(&quot;설탕과 우유를 추가한다.&quot;); } } . | 09 추상화를 끝내고 -&gt; 추상화 호출부 이름변경(통일)로 인한 공통(중복)메서드가 추가로 생길 수 있다 -&gt; 다시 부모로 빼준다. . 추상화 IMPL 오버라이딩된 정의부는 서로 다르게 구현되므로 이름은 같지만 공통메서드로 볼수 없다 . | 추상화 사용처()는 이름이 자식들이 같아지므로, 공통메서드/중복메서드가 생길 수 있다 -&gt; 보이면 부모 클래스로 빼면 된다. . . . | 메서드 순서 맞춰주기(현재 추상메서드만 위에서 정의해놨을 듯..) . . | 10 extends -&gt; 정의도 안되어있는데 super생략한 체로 공통메서드를 실제 내부 or 외부에서 인스턴스가 사용 확인해보기 . 현재 Coffee클래스 . **extends로 상속하고 있다. ** super는 생략되어있지만 부모로 빼놨던 공통메서드를 내부에서 쓰고 있다 | . | . public class Coffee extends CaffeineBeverage{ @Override void brew() { System.out.println(&quot;필터를 활용해 커피를 내린다.&quot;); } @Override void addCondiments() { System.out.println(&quot;설탕과 우유를 추가한다.&quot;); } } . | **메인 메서드를 만들고 -&gt; 상속한 자식클래스 인스턴스를 만든 뒤 ** . Coffee 내부에는 정의되어있지 않지만, 부모에게 상속된 공통 메소드를 바로 호출할 수 있다. | . public class Application { public static void main(String[] args) { final Coffee coffee = new Coffee(); coffee.prepareRecipe(); // 정의 안된 메서드인데 extends 공통메서드라면 바로 사용 가능 } } . | 추상화부터 하는 방법도 있다. 정답은 없다. 처음부터 완벽하게 추상화 x -&gt; 공통처리부분이 발견될 시 처리하는게 좋다. . cf) 추상클래스 인스턴스화(=구체화) 안되는 이유: 구현부 없는 추상메서드 때문에 추상클래스가 됬으므로..ㅋ -&gt; 구현부정의와 같이 객체를 만들어줄 수도 있다. . 공통메서드를 추출한 부모클래스를 활용해서, 구현부는 다르지만 이름만 공통으로 추상화하였다 = 추상메서드 들고 있다 = 추상클래스가 부모다 &gt; 인스턴스화 안된다. . | 인스턴스화를 하려면 내부에 구현부 없이 이름만 추상화한 추상메서드를 인스턴스화 하면서, {}]중괄호 블럭로 자식클래스처럼 바로 클래스 구현하면 된다. . . | 중괄호{}로 클래스를 구현하는 것을 람다 와 동일하게 익명클래스라 부른다. . . 익명클래스를 자식클래스와 동일하게 작성하더라도, 별개의 익명클래스다 | . | . quiz) 추상클래스는 추메가 무조건 있어야할까? . 추메 없어도 된다. . | 추메 없으면 객체 생성해도될까? -&gt; 구현부없는 놈을 안가지고 있어도 객체생성은 안안된다. . 구현할 내용이 없어도 { } 중괄호 블럭 가진체로 만들어야한다. | . | . 추메를 안가지는데 추상클래스를 구현했다면 고민해봐야한다. . 추메 -&gt; 구현부는 다르지만 공메를 가진 부모클래스에서 구현부제외 이름만 추상화해놓은 것 추메가 없다? 그냥 부모가 가진 공통메서드만 super생략 갖다쓰는 일반 상속이면 된다. | | . | . 업캐스팅 vs 다운캐스팅 . 업캐스팅 = 다형성 = 추상체로 변수,파라미터,응답값 받기 . 변수/파라미터/응답Type은 추상체(up)로 받을 수 있다. 구상체들을 한번에 처리할 수 있다. . | List쓸 때 많이 쓰는 업캐스팅개념이다. . . public class Application { public static void main(String[] args) { //업캐스팅 final CaffeineBeverage caffeineBeverage = new Tea(); final List&lt;Tea&gt; list = new ArrayList&lt;&gt;(); } } . | . 다운캐스팅 = 추상체상태에서 -&gt; 구상체로 돌아가 구상체만의 메서드/상태 사용가능해진다. . 01 구상체 or 자식만의 메서드는 편하게 가질 수 있다. . Tea에 Tea만의 메서드(some_t())가 있다고 치자. . . | 02 문제는 추상체/부모형으로 업캐스팅 된 상태에서는, 개별구상체 본인이라도, 메서드를 호출이 안된다. . . 업캐스팅된 부모타입이라면, Type자체가 부모상태라 안된다. | . 03 추상체 상태의 구상체를 (다운캐스팅)하면, 자신만의 메서드를 사용할 수 있다. . . 변수를 캐스팅하려면 괄호가 2개가 필요하다. . final CaffeineBeverage beverage = new Tea(); // beverage.some_t(); //(Tea)beverage.some_t(); ((Tea) beverage).some_t(); . | . 04 문제는 엉뚱한 구상체를 다운캐스팅해도 호출()된다 == 컴파일 타임에 처리 못하는 에러 -&gt; 캐스팅에러가 무섭다. -&gt; 신중하게 써야한다. -&gt; 다운캐스팅은 instanceof + .class.cast()메서드와 함께 !! . new Coffee 인스턴스 -&gt; 추상체 -&gt; (Tea)로 다운캐스팅 해도 some_t()가 호출시 에러는 안난다 == 컴파일시 에러가 안난다. . . public class Application { public static void main(String[] args) { final CaffeineBeverage beverage = new Coffee(); ((Tea) beverage).some_t(); } } . | 하지만 돌려보면, 캐스팅 에러가 난다. . | 다운캐스팅후 자신만의 메서드호출 -&gt; 반드시 instanceof로 직접 확인하고 호출해줄 것 . public static void main(String[] args) { final CaffeineBeverage beverage = new Coffee(); if (beverage instanceof Tea) { ((Tea) beverage).some_t(); } } . | 괄호2개 캐스팅 말고 가독성을 위해 -&gt; 해당클래스.class.cast( )로 다운캐스팅해서 써도 된다. . if (beverage instanceof Tea) { Tea.class.cast(beverage).some_t(); } . | isinstanceof도 가독성을 위해 아래와 같이 수정할 수 있다. . if (Tea.class.isInstance(beverage)) { Tea.class.cast(beverage).some_t(); } . | .",
            "url": "blog.chojaeseong.com/java/%EC%83%81%EC%86%8D/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4/%EC%A1%B0%ED%95%A9/%EC%BA%90%EC%8A%A4%ED%8C%85/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/15/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EC%83%81%EC%86%8D,%EC%A1%B0%ED%95%A9,%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4,%EC%BA%90%EC%8A%A4%ED%8C%85.html",
            "relUrl": "/java/%EC%83%81%EC%86%8D/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4/%EC%A1%B0%ED%95%A9/%EC%BA%90%EC%8A%A4%ED%8C%85/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/15/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-3%EB%8B%A8%EA%B3%84-%EC%83%81%EC%86%8D,%EC%A1%B0%ED%95%A9,%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4,%EC%BA%90%EC%8A%A4%ED%8C%85.html",
            "date": " • Mar 15, 2022"
        }
        
    
  
    
        ,"post110": {
            "title": "데분방02) 확률과 분포 및 기술통계",
            "content": "Probability and distribution . 3.1 Random Sampling . sample(1:40, 5) #(범위, 갯수) . &lt;ol class=list-inline&gt; 1 | 9 | 36 | 2 | 12 | &lt;/ol&gt; # 중복허용 여부는 replace=T가 있냐 sample(c(&quot;H&quot;, &quot;T&quot;), 10) . Error in sample.int(length(x), size, replace, prob): &#39;replace = FALSE&#39; 일때는 모집단보다 큰 샘플을 가질 수 없습니다 Traceback: 1. sample(c(&#34;H&#34;, &#34;T&#34;), 10) 2. sample.int(length(x), size, replace, prob) . sample(c(&quot;H&quot;, &quot;T&quot;), 10, replace=T) . &lt;ol class=list-inline&gt; &#39;T&#39; | &#39;T&#39; | &#39;T&#39; | &#39;H&#39; | &#39;T&#39; | &#39;T&#39; | &#39;H&#39; | &#39;H&#39; | &#39;T&#39; | &#39;T&#39; | &lt;/ol&gt; # 각 벡터별로 나올확률을 정해준다. # 각 원소들 뽑을 확률도 벡터로 직접 지정해줄 수 있다 prob= # -&gt; 이렇게 확률주고 뽑을 것이면, binomial 분포(이항분포)에서 뽑는 기능도 좋다 sample(c(&quot;succ&quot;, &quot;fail&quot;), 10, replace=T, prob = c(0.9, 0.1)) . &lt;ol class=list-inline&gt; &#39;succ&#39; | &#39;succ&#39; | &#39;fail&#39; | &#39;succ&#39; | &#39;succ&#39; | &#39;fail&#39; | &#39;succ&#39; | &#39;fail&#39; | &#39;succ&#39; | &#39;succ&#39; | &lt;/ol&gt; 3.2 &#49692;&#50676;&#48143; &#51312;&#54633;(Prob. Calculations and combinatorics) . 조합은 choose(n,r)으로 / 순열은 prod(n:r)로 바로 계산가능하다 | . # 1/ 40 C 5 1 / choose(40,5) . 1.51973836184363e-06 prod(5:1) . 120 # my) 팩토리얼은 nPr에서 -&gt; r 입력이 아니라 ( n-c+1)을 입력해줘야한다. prod(5:1) / prod(40:(40-5+1)) . 1.51973836184363e-06 3.3 Discrete distributions . 이항분포: 성공률이 p인 시행을, n번 반복시, 성공횟수 X라 할 때 -&gt; X는 X~b(n, p)를 따른다. . | 이항분포를 f(x)로 나타내면, 아래와 같다 . | . 3.4 &#50672;&#49549;&#48516;&#54252; Continuous distributions . 정규분포: 평균+분산으로 정해지는 분포. 평균을 중심으로 내려가는 벨 모양의 분포 | 3.5 The built-in distributions in R . R에서 제공하는 분포구해주는 함수 . | 확률밀도함수: Density or point probability . | 누적분포함수: Cumulated probability, distribution function | 퀀타일값: Quantiles | 정규/이항분포 등을 따를 때의 랜덤넘버: Pseudo-random numbers | . ※ For the normal distribution, these are named dnorm(확률밀도함수), pnorm(누적 확률함수 분포), qnorm(퀀타일), and rnorm(랜덤넘버) (density, probability, quantile, and random, respectively). . 3.5.1 Densities (&#48516;&#54252;&#46308; &#47560;&#45796; &#49884;&#44033;&#54868;) . &#51221;&#44508;&#48516;&#54252; with dnorm(x) . x &lt;- seq(-4,4,0.1) # 1. seq()으로 예시 x를 뽑았다. plot(x,dnorm(x),type=&quot;l&quot;) # 2. plot + x와 y로는 확률밀도함수 dnorm(x)로 그렸다. title(&quot;Normal distribution&quot;) . # 예시x대신 from, to를 지정해주는 curve()를 이용한다. # y값으로 dnorm(x) curve(dnorm(x), from=-4, to=4) . &#51060;&#54637;&#48516;&#54252; with d binom(x) . x &lt;- 0:50 # 1. x를 인덱싱으로 0부터 n까지 정수로만 구성하고 plot(x,dbinom(x,size=50,prob=.33),type=&quot;h&quot;) # plot + y값으로 d bi nom을 이용했다. . &#45572;&#51201;&#54869;&#47456;&#54632;&#49688;(&#50812;&#51901;&#45149;&#48512;&#53552; k&#51060;&#54616;&#44620;&#51648; &#54869;&#47456;) with p norm , p bi nom -&gt; p-value . 정규, 이항분포에 대한 누적확률분포를 예시를 듦 | 왼쪽끝부터 k이하까지의 면적 계산 함수 | . . # Q. X가 160보다 클 확률은?? # -&gt; 계산은 [k이하 확률]이 바로 나온다고 생각하자. # -&gt; 1(전체확률) - (160이하 확률) = 160이상 확률 # my) 정규분포에서 [확률분포 그림상] 확률변수가 k이상/이하 확률 계산은 -&gt; p norm으로 한다. # 중요! # my) [확률분포 그림] == [왼쪽 끝부터 k이하까지 누적되는 누적확률분포 p norm]으로 계산한다! # 분포그림상 문제 -&gt; 누적확률분포상 [왼쪽끝~k이하를 계산해주는 p norm]이용하기 1 - pnorm(160, mean=132, sd=13) # (왼쪽끝부터~k이하에서의 k , 정규분포m, 정규분포sd) . 0.0156261194284694 . # 20명의 환자에게, A/B 두가지 시험을 각각 함 # -&gt; 16명이 A를 더 좋아함. # -&gt; A가 더 좋은 treament인지에 대한 충분한 증거가 있는지 확인하기 # how? why? # **A가 더 좋은 treament다 == 나오는 확률이 반반보다 높을 것이다.로 증명하고 잇넹** # 1) A or Not A(B) 2가지 경우이며, 확률은 0.5 반반이라고 가정한다. -&gt; 이항분포 따른다. # 2) 귀무가설H0 -&gt; p = 0.5 확률 반반이라고 정한다.. why? # 3) p-value 계산 -&gt; 귀무가설H0(p=0.5)하에 [현재상황인 X=16명]이상일 확률을 구한다. # -&gt; 1 - P(X &lt;=15명이하) # --&gt; my) 더 좋은 치료는 아니다 == 확률 반반이다 상태로 -&gt; 현상황에서 꼭다리를 구함 # 4) [귀무가설하 꼭다리 = p-value]가 0.05보다 작다? -&gt; 귀무가설 반반은 틀린 것.. 0.5보다 클 것이다. -&gt; 더 좋은 치료다 1 - pbinom(15, size=20, prob=.5) # 계산결과가 p-value다 . 0.00590896606445312 &#51473;&#44036; &#45236; &#51221;&#47532;(&#45572;&#51201;&#54869;&#47456;&#48516;&#54252; &#54632;&#49688;) . 정규든 이항이든 누적확률분포는 현재 확률변수 X가 가진 분포에 대해 왼쪽끝 ~ k이하까지의 면적 계산해서 확률을 응답해준다. . | p-value 계산은 H0에서 k이상일 확률(꼭다리)를 물어볼 것이다. -&gt; . 1 - (왼쪽끝~k이하) by 누적확률분포 함수 pnorm or p bi nom | . | case와 확률이 둘다 0.5인 treatment에서 -&gt; 어떤 치료가 더 좋다?(반반 아니다)를 증명하려면? . P=0.5가 아니다를 증명해야하는데 | (1)뒤집어질 귀무가설P=0.5을 귀무가설로 잡고 -&gt; (2)해당하는 분포 함수를 만들고이항분포를 만들고 -&gt; (3)분포 함수내에서 p-value계산을 위해, H0의 x값 k를 구한 뒤, 1- (왼쪽끝~)k이하확률은 누적확률분포 함수에 k를 넣어서 -&gt; p-value(k이상 확률)을 구한다k이상의 꼭다리 계산후 -&gt; 꼭다리 계산결과 자체가 = p-value이며 p-value가 0.05가 낫다를 증명해야한다. | . | p norm이나 p bi nom 등의 누적확률분포 함수로 -&gt; 정규분포와 이항분포의 p-value를 계산할 수 있다. | . 3.5.3 &#53248;&#53440;&#51068; . 누적확률분포 함수의 inverse값이다. 표준정규분포Z~N(0,1)를 예를 든다면, 왼쪽 끝 ~ 0(평균)까지는 1/2이다. 즉 Pr(z&lt;=0) = 1/2 | 즉 파이(0) = 1/2 파이 역함수(1/2) = 0 | 여기서 1/2값이 0의 퀀타일?이다 | . | . | 누적확률분포 함수(왼쪽끝부터 x까지) 상에서 f(x) = 1/2을 만들어내는 x값은? 0이다 | . | . 누적확률분포 함수의 역함수라는 것을 이용하면, 퀀타일로 신뢰구간을 구할 수 있다. 95% CI(신뢰구간) for m이다? 표준 정규분포 양측 총 5% 내에 들 확률? | 표준 정규분포 각 측의 2.5%내에 들 확률? | 표준 정규분포 (왼쪽끝~ N 0.025) = 0.025가 되는 값? | 표준 정규분포 (반대편에서 ~N 0.975) = 0.025가 되는 값? | . | . | . &#53248;&#53440;&#51068; qnorm &#50696;&#49884; -&gt; 95% &#49888;&#47280;&#44396;&#44036; . xbar &lt;- 83 sigma &lt;- 12 n &lt;- 5 # S/루트(n) = 표준오차 sem &lt;- sigma/sqrt(n) sem . 5.3665631459995 my) qnorm : &#49888;&#47280;&#44396;&#44036;% / 100&#51032; &#44050;&#50640; &#45824;&#54644; , &#51060;&#48120; &#51221;&#54644;&#51652; Z&#48516;&#54252;&#50640;&#49436; &#54620;&#51901;&#45149; &#54869;&#47456;&#51012; 0.5&#51473;&#50521;&#50640;&#49436;&#48512;&#53552; &#48169;&#54693;&#45824;&#47196; &#51452;&#44592; . qnorm(0.025) 0.025 -&gt; 한쪽끝 2.5% -&gt; 양쪽 5%의 신뢰구간에 대해 | 0.5부터 면적확률을 계산해주는 데, 왼쪽으로 가면 음수 ex&gt; qnorm(0.025) = N0.025 &lt;-- N0.5 : 확률이 음수로 | 오른쪽으로 가면 양수로 반환해주니 ex&gt; N0.5 --&gt; N0.975 : 확률이 양수로 | . | xbar에서 편하게 더하기만 하면 된다. xbar± Z(0.975) * s/sqrt(n) xbar - Z(0.975) s/sqrt(n) = **`xbar +qnorm(0.025) s/sqrt(n)`** | xbar + Z(0.975) s/sqrt(n) = = **`xbar +qnorm(0.975) s/sqrt(n)`** | . | . | . | . qnorm(0.025) . -1.95996398454005 qnorm(0.5) . 0 xbar + (sem * qnorm(0.025)) . 72.481729513081 xbar + Z(0.975) * s/sqrt(n) = = xbar +qnorm(0.975) * s/sqrt(n) xbar + (sem * qnorm(0.975)) . 93.518270486919 3.5.4 RandomNumber . r norm: default 표준 정규분포 Z~N(0,1) | r norm(n, mean=, sd=) : 정규분포 | r bi nom : 이항분포 rbinom(10, size=120, prob =.5) | . | . 정규분포/t-분포/카이분포/F분포 찾아보기 | . rnorm(10) . &lt;ol class=list-inline&gt; 0.91390162693947 | 0.197128611021056 | 1.1335528255989 | 0.709275924616523 | -0.115762275017252 | 1.91254936747156 | 1.08309692608723 | -0.794788105164226 | 0.0598276849870534 | -1.55241979528304 | &lt;/ol&gt; rnorm(10) . &lt;ol class=list-inline&gt; -0.227831384148584 | -0.753542050751784 | 1.1823743666526 | 1.39377399777469 | -0.607646833536545 | -1.30226568123142 | 1.52846375432066 | -0.0665106816849702 | 1.64144343677273 | -2.75795542164768 | &lt;/ol&gt; rnorm(10, mean=7, sd=5) . &lt;ol class=list-inline&gt; 8.4584163642515 | -1.29043800908632 | 11.014151157234 | 3.98666408543523 | 5.17055737208387 | 11.476782263482 | 0.816515724660011 | 13.7678591561022 | 3.86224636280707 | 11.9287262076141 | &lt;/ol&gt; rbinom(10, size=120, prob =.5) . &lt;ol class=list-inline&gt; 55 | 56 | 64 | 67 | 62 | 53 | 64 | 57 | 68 | 72 | &lt;/ol&gt; rt(10) . Error in rt(10): 기본값이 없는 인수 &#34;df&#34;가 누락되어 있습니다 Traceback: 1. rt(10) . Chapter 4_Descriptive statistics and 2 graphics . 4.1 Summary statistics for a single group . x &lt;- rnorm(50) # 표준정규분포 랜덤 50개 . mean(x) # 평균 . -0.113144878217599 sd(x) #표준편차 . 1.00092515131641 var(x) # 분산 . 1.00185115853778 median(x) # 중앙값 . -0.0748168807075239 quantile(x) # 4분위 값 -&gt; 최소+최대, 1,3분위수, 중앙값 다 등장한다 . &lt;dl class=dl-horizontal&gt; 0% -2.25870254959727 25% -0.58611041134086 50% -0.0748168807075239 75% 0.541289193689699 100% 1.96959491742893 &lt;/dl&gt; pvec &lt;- seq(0, 1, 0.1) pvec . &lt;ol class=list-inline&gt; 0 | 0.1 | 0.2 | 0.3 | 0.4 | 0.5 | 0.6 | 0.7 | 0.8 | 0.9 | 1 | &lt;/ol&gt; quantile(x, pvec) . &lt;dl class=dl-horizontal&gt; 0% -2.25870254959727 10% -1.63786099119543 20% -0.82875522310902 30% -0.442599332809064 40% -0.339931037760649 50% -0.0748168807075239 60% 0.302324704146892 70% 0.48920157857546 80% 0.670332876024393 90% 0.999831758391866 100% 1.96959491742893 &lt;/dl&gt; In case there are missing values in data . library(&quot;ISwR&quot;) data(juul) . head(juul, 3) . agemenarchesexigf1tannertestvol . NA | NA | NA | 90 | NA | NA | . NA | NA | NA | 88 | NA | NA | . NA | NA | NA | 164 | NA | NA | . attach(juul) . mean(igf1) . &lt;NA&gt; mean(igf1, na.rm=T) . 340.167976424361 igf1 . &lt;ol class=list-inline&gt; 90 | 88 | 164 | 166 | 131 | 101 | 97 | 106 | 111 | 79 | 43 | 64 | 90 | 141 | 42 | 43 | 132 | 43 | 36 | 86 | 44 | 68 | 89 | 101 | 115 | 53 | 94 | 95 | 76 | 79 | 71 | 121 | 201 | 96 | 29 | 80 | 117 | 38 | 100 | 108 | 52 | 106 | 182 | 195 | 210 | 204 | 67 | &lt;NA&gt; | 68 | 148 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 98 | &lt;NA&gt; | 242 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 196 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 179 | &lt;NA&gt; | &lt;NA&gt; | 126 | &lt;NA&gt; | 142 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 236 | 148 | &lt;NA&gt; | 174 | 136 | 164 | 160 | 215 | &lt;NA&gt; | &lt;NA&gt; | 214 | &lt;NA&gt; | &lt;NA&gt; | 328 | 367 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 149 | &lt;NA&gt; | 187 | &lt;NA&gt; | 103 | &lt;NA&gt; | 145 | &lt;NA&gt; | 117 | 88 | &lt;NA&gt; | 186 | 235 | &lt;NA&gt; | &lt;NA&gt; | 300 | 188 | &lt;NA&gt; | 110 | 198 | 134 | 46 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 221 | 225 | &lt;NA&gt; | &lt;NA&gt; | 166 | 324 | &lt;NA&gt; | 146 | 485 | 152 | 278 | 315 | 206 | 624 | 318 | 187 | 141 | &lt;NA&gt; | 152 | 219 | 169 | &lt;NA&gt; | 115 | 223 | 295 | &lt;NA&gt; | 117 | 416 | &lt;NA&gt; | 149 | &lt;NA&gt; | 160 | 99 | &lt;NA&gt; | 490 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 101 | 238 | 283 | &lt;NA&gt; | &lt;NA&gt; | 279 | &lt;NA&gt; | &lt;NA&gt; | 171 | &lt;NA&gt; | &lt;NA&gt; | 224 | 174 | 179 | 104 | &lt;NA&gt; | &lt;NA&gt; | 279 | &lt;NA&gt; | &lt;NA&gt; | 222 | 156 | 288 | 269 | 262 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 264 | 240 | 126 | 158 | 258 | 146 | &lt;NA&gt; | 203 | 288 | &lt;NA&gt; | &lt;NA&gt; | 151 | 161 | 179 | 209 | &lt;NA&gt; | 292 | &lt;NA&gt; | 284 | 295 | &lt;NA&gt; | 138 | &lt;NA&gt; | 224 | 204 | 245 | 267 | 195 | 418 | 223 | 232 | 138 | 190 | &lt;NA&gt; | 234 | 218 | 272 | 367 | 239 | 222 | 163 | &lt;NA&gt; | 180 | 347 | 154 | &lt;NA&gt; | &lt;NA&gt; | 312 | 211 | 231 | 281 | 465 | 171 | 388 | &lt;NA&gt; | &lt;NA&gt; | 244 | 201 | 184 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 225 | &lt;NA&gt; | 280 | 179 | &lt;NA&gt; | 246 | 157 | 280 | 284 | &lt;NA&gt; | 201 | &lt;NA&gt; | 239 | 261 | &lt;NA&gt; | 329 | 227 | 271 | &lt;NA&gt; | 383 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 164 | &lt;NA&gt; | 417 | 781 | 214 | &lt;NA&gt; | 232 | &lt;NA&gt; | 194 | &lt;NA&gt; | 284 | 299 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 186 | 271 | 281 | &lt;NA&gt; | &lt;NA&gt; | 252 | 71 | &lt;NA&gt; | &lt;NA&gt; | 237 | 188 | 325 | 208 | 290 | 279 | 410 | 251 | &lt;NA&gt; | 153 | 269 | 299 | 163 | 348 | &lt;NA&gt; | 548 | &lt;NA&gt; | 269 | 493 | 258 | 419 | 387 | &lt;NA&gt; | &lt;NA&gt; | 336 | 233 | 447 | 565 | 549 | 400 | 432 | 271 | 868 | 266 | 279 | 491 | &lt;NA&gt; | 419 | &lt;NA&gt; | &lt;NA&gt; | 682 | 157 | 188 | 193 | 150 | &lt;NA&gt; | 493 | &lt;NA&gt; | &lt;NA&gt; | 495 | 345 | 167 | 915 | 488 | 422 | 287 | 374 | 242 | 363 | &lt;NA&gt; | &lt;NA&gt; | 290 | 275 | &lt;NA&gt; | 499 | 448 | &lt;NA&gt; | 652 | 490 | 504 | &lt;NA&gt; | 435 | 348 | 653 | 288 | 453 | &lt;NA&gt; | 743 | &lt;NA&gt; | 680 | 498 | 599 | 487 | &lt;NA&gt; | 701 | &lt;NA&gt; | 518 | &lt;NA&gt; | 517 | &lt;NA&gt; | 336 | 722 | 568 | 322 | 801 | 548 | 305 | 564 | 473 | 669 | &lt;NA&gt; | 377 | 311 | 533 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 374 | 349 | 747 | 443 | 590 | 581 | 470 | 391 | 668 | &lt;NA&gt; | 442 | &lt;NA&gt; | 600 | 838 | 608 | 559 | 449 | 619 | 393 | 366 | 503 | 364 | &lt;NA&gt; | 327 | 541 | 430 | &lt;NA&gt; | 488 | &lt;NA&gt; | 352 | 364 | 402 | &lt;NA&gt; | 349 | 447 | 477 | 483 | 504 | 581 | 518 | 412 | 558 | 737 | 501 | 479 | 321 | 488 | 417 | 479 | 391 | 696 | 480 | 484 | 457 | 406 | 632 | 551 | 603 | 473 | 461 | 785 | 553 | 738 | 362 | 453 | 616 | &lt;NA&gt; | 482 | &lt;NA&gt; | 371 | 517 | 285 | 520 | 434 | &lt;NA&gt; | 464 | 476 | 405 | 396 | 428 | 618 | 361 | &lt;NA&gt; | 467 | 360 | 469 | 429 | 505 | 398 | 491 | 419 | 389 | 440 | 496 | 389 | 535 | 312 | 389 | 407 | 404 | 489 | 420 | 444 | 476 | 525 | 390 | 768 | 364 | 419 | 318 | 444 | 500 | 440 | 421 | 523 | 434 | 355 | 290 | 358 | 503 | 360 | 450 | 503 | 462 | 368 | 528 | 397 | 387 | 518 | 364 | 409 | 492 | 412 | 495 | 471 | 286 | 630 | 259 | 326 | 394 | 431 | 421 | 356 | 332 | 291 | 418 | 293 | 223 | 286 | 238 | 232 | 296 | 241 | 217 | 354 | 307 | 190 | 261 | 236 | 292 | 242 | 246 | 395 | 347 | 248 | 261 | 223 | 356 | 304 | 261 | 183 | 172 | 215 | 205 | 107 | 178 | 185 | 221 | 176 | 170 | 256 | 257 | 232 | 158 | 203 | 174 | 223 | 171 | 203 | 89 | 176 | 135 | 193 | 150 | 151 | 191 | 159 | 138 | 133 | 197 | 168 | 167 | 139 | 174 | 134 | 105 | 160 | 92 | 222 | &lt;NA&gt; | 126 | 90 | 119 | 122 | 112 | 87 | 149 | 104 | 51 | 25 | &lt;NA&gt; | 250 | &lt;NA&gt; | &lt;NA&gt; | 179 | 163 | 191 | 106 | &lt;NA&gt; | &lt;NA&gt; | 218 | 151 | 173 | 171 | 190 | 153 | 139 | 205 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 168 | 200 | &lt;NA&gt; | 169 | 123 | 139 | 388 | 223 | 93 | &lt;NA&gt; | &lt;NA&gt; | 328 | &lt;NA&gt; | &lt;NA&gt; | 178 | 157 | 212 | &lt;NA&gt; | &lt;NA&gt; | 272 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 113 | 202 | &lt;NA&gt; | 278 | 228 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 235 | 405 | &lt;NA&gt; | &lt;NA&gt; | 190 | &lt;NA&gt; | 247 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 286 | &lt;NA&gt; | 187 | 209 | 196 | 137 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 202 | 223 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 177 | &lt;NA&gt; | 322 | 142 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 414 | 181 | &lt;NA&gt; | 304 | &lt;NA&gt; | 199 | &lt;NA&gt; | &lt;NA&gt; | 212 | 232 | 268 | 186 | 289 | &lt;NA&gt; | &lt;NA&gt; | 143 | &lt;NA&gt; | &lt;NA&gt; | 171 | &lt;NA&gt; | &lt;NA&gt; | 210 | 564 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 278 | 229 | 255 | 250 | 168 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 234 | &lt;NA&gt; | 307 | 233 | &lt;NA&gt; | 141 | 234 | 242 | 242 | 356 | 255 | &lt;NA&gt; | 180 | &lt;NA&gt; | 111 | &lt;NA&gt; | 296 | &lt;NA&gt; | 207 | 202 | 160 | &lt;NA&gt; | 254 | &lt;NA&gt; | &lt;NA&gt; | 127 | 144 | 135 | &lt;NA&gt; | 328 | 225 | &lt;NA&gt; | &lt;NA&gt; | 222 | 153 | &lt;NA&gt; | 301 | 363 | &lt;NA&gt; | 368 | &lt;NA&gt; | 163 | 144 | 152 | &lt;NA&gt; | 221 | 181 | 256 | 309 | 221 | &lt;NA&gt; | 386 | 185 | &lt;NA&gt; | 174 | 247 | 246 | 257 | 187 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 206 | 399 | &lt;NA&gt; | 270 | 212 | 340 | 243 | 259 | 304 | &lt;NA&gt; | 341 | 156 | 290 | 229 | 323 | &lt;NA&gt; | &lt;NA&gt; | 199 | 242 | 267 | 248 | 421 | &lt;NA&gt; | &lt;NA&gt; | 284 | &lt;NA&gt; | 387 | 290 | 158 | &lt;NA&gt; | 190 | 199 | 209 | 212 | &lt;NA&gt; | 271 | 186 | 215 | 224 | 243 | 199 | 383 | 504 | 272 | 171 | 254 | 257 | &lt;NA&gt; | &lt;NA&gt; | 553 | 338 | 220 | &lt;NA&gt; | 179 | 399 | 494 | &lt;NA&gt; | 262 | 259 | &lt;NA&gt; | &lt;NA&gt; | 168 | 347 | 122 | 187 | 459 | 464 | 187 | 229 | &lt;NA&gt; | 149 | 412 | &lt;NA&gt; | 349 | 259 | 184 | 104 | 278 | 439 | 95 | 573 | 196 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 281 | &lt;NA&gt; | 288 | 259 | 249 | 329 | 433 | 453 | 280 | &lt;NA&gt; | 488 | 853 | 447 | 228 | 352 | 690 | 308 | &lt;NA&gt; | 777 | 402 | 493 | 383 | 419 | &lt;NA&gt; | 316 | &lt;NA&gt; | 462 | 359 | 376 | 483 | 615 | 252 | 197 | &lt;NA&gt; | 322 | &lt;NA&gt; | &lt;NA&gt; | 354 | 347 | &lt;NA&gt; | 570 | 588 | &lt;NA&gt; | 390 | 762 | 495 | 474 | 363 | &lt;NA&gt; | 508 | &lt;NA&gt; | 442 | &lt;NA&gt; | &lt;NA&gt; | 177 | &lt;NA&gt; | &lt;NA&gt; | 469 | &lt;NA&gt; | 618 | 378 | 475 | 508 | 558 | &lt;NA&gt; | 322 | 193 | 416 | &lt;NA&gt; | 914 | 360 | 543 | 545 | 522 | 615 | 604 | 411 | 701 | 464 | 596 | 769 | &lt;NA&gt; | 591 | 635 | &lt;NA&gt; | &lt;NA&gt; | 400 | 699 | &lt;NA&gt; | 201 | 832 | 587 | 258 | &lt;NA&gt; | 556 | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | 687 | 473 | 426 | 630 | 271 | 505 | &lt;NA&gt; | &lt;NA&gt; | 474 | 526 | 611 | &lt;NA&gt; | &lt;NA&gt; | 689 | 434 | 504 | 565 | 526 | &lt;NA&gt; | 522 | &lt;NA&gt; | 579 | 722 | 830 | 321 | &lt;NA&gt; | &lt;NA&gt; | 651 | 486 | 535 | 502 | &lt;NA&gt; | 244 | 442 | &lt;NA&gt; | 475 | 648 | &lt;NA&gt; | 502 | &lt;NA&gt; | 420 | 439 | 622 | 351 | &lt;NA&gt; | 371 | 490 | 529 | &lt;NA&gt; | 374 | 639 | 609 | 639 | &lt;NA&gt; | 631 | 609 | 453 | 621 | &lt;NA&gt; | 504 | 439 | 576 | &lt;NA&gt; | 399 | &lt;NA&gt; | 296 | &lt;NA&gt; | 625 | 527 | 430 | 436 | &lt;NA&gt; | 359 | 842 | 491 | 478 | 193 | &lt;NA&gt; | 667 | 374 | 716 | 527 | 637 | 655 | 457 | &lt;NA&gt; | 493 | 728 | 281 | 485 | 443 | 722 | 370 | 737 | 514 | 574 | 549 | 704 | 558 | 733 | 821 | &lt;NA&gt; | 720 | 448 | 326 | &lt;NA&gt; | 497 | 492 | 425 | &lt;NA&gt; | &lt;NA&gt; | 438 | 894 | 330 | 547 | &lt;NA&gt; | 528 | 506 | 526 | 570 | 524 | 478 | 352 | 608 | 441 | 395 | 514 | 535 | 741 | 375 | 524 | 234 | 374 | 465 | 474 | 530 | 452 | 240 | 402 | 283 | 552 | 430 | 670 | 490 | 255 | 552 | 723 | 535 | 609 | 510 | 313 | 582 | 398 | 364 | &lt;NA&gt; | 468 | 348 | 435 | 345 | 595 | 363 | 397 | 574 | 362 | 344 | 385 | 560 | 372 | 497 | 366 | &lt;NA&gt; | 452 | 380 | 442 | 592 | 415 | 478 | 488 | 798 | &lt;NA&gt; | 346 | 416 | 414 | &lt;NA&gt; | 404 | 595 | 445 | 498 | 294 | 535 | &lt;NA&gt; | 556 | 339 | 560 | 496 | 392 | 428 | 491 | 553 | 578 | 464 | 262 | 406 | 404 | 256 | 394 | 363 | 247 | 461 | 290 | 463 | 477 | 446 | 425 | 443 | 387 | 445 | 398 | 488 | &lt;NA&gt; | 355 | 393 | 436 | 509 | 436 | 472 | 324 | 259 | 430 | 483 | 399 | 431 | 494 | &lt;NA&gt; | 686 | 428 | 550 | 387 | 526 | 401 | 338 | 345 | 476 | 338 | 266 | 376 | 352 | 481 | 261 | 407 | 517 | 298 | 409 | 411 | 274 | 294 | 466 | 379 | 347 | 408 | 497 | 263 | 406 | 391 | &lt;NA&gt; | 166 | 358 | 295 | 272 | 352 | 274 | 309 | 238 | 165 | 322 | 319 | 271 | 214 | 239 | 313 | 263 | 257 | 235 | 246 | 328 | 292 | 240 | 262 | 277 | 330 | &lt;NA&gt; | 105 | 167 | 314 | 273 | 232 | 158 | 159 | 174 | 215 | 202 | 268 | 245 | 180 | 200 | 220 | 233 | 206 | 331 | 169 | 130 | 262 | 100 | 249 | 170 | 156 | 251 | 220 | 174 | 144 | 154 | &lt;NA&gt; | 140 | 187 | 140 | 252 | 124 | 187 | 218 | 226 | &lt;NA&gt; | 106 | 217 | 135 | &lt;/ol&gt; #sum(igf1, na.rm=T) sum(!is.na(igf1)) # NA를 제외한 갯수 . 1018 summary(igf1) # NA의 갯수를 한번에 . Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s 25.0 202.2 313.5 340.2 462.8 915.0 321 . summary&#54980; &#50672;&#49549;&#54805;vs&#51060;&#49328;&#54805;(&#48276;&#51452;&#54805;) &#54869;&#51064;&#54644;&#48372;&#44592; . R에서 별말 없으면, 연속형, 양적인 변수로 알아먹게 됨 -&gt; 범주로 바꿔서 작업해야함 최소값 = 제1 사분위수 = 중앙값 등이 같은 칼럼들은 범주형 변수을 확률이 높다. menarche, sex 등 | . | . | . summary(juul) . age menarche sex igf1 Min. : 0.170 Min. :1.000 Min. :1.000 Min. : 25.0 1st Qu.: 9.053 1st Qu.:1.000 1st Qu.:1.000 1st Qu.:202.2 Median :12.560 Median :1.000 Median :2.000 Median :313.5 Mean :15.095 Mean :1.476 Mean :1.534 Mean :340.2 3rd Qu.:16.855 3rd Qu.:2.000 3rd Qu.:2.000 3rd Qu.:462.8 Max. :83.000 Max. :2.000 Max. :2.000 Max. :915.0 NA&#39;s :5 NA&#39;s :635 NA&#39;s :5 NA&#39;s :321 tanner testvol Min. :1.00 Min. : 1.000 1st Qu.:1.00 1st Qu.: 1.000 Median :2.00 Median : 3.000 Mean :2.64 Mean : 7.896 3rd Qu.:5.00 3rd Qu.:15.000 Max. :5.00 Max. :30.000 NA&#39;s :240 NA&#39;s :859 . &#52860;&#47100; &#53440;&#51077; &#48148;&#45012;&#51460; &#46412;&#45716;, detach&#54644;&#45459;&#44256; &#51089;&#50629;&#54620; &#46244;, &#45796;&#49884; attach . detach(juul) . juul$sex &lt;- factor(juul$sex, labels = c(&quot;M&quot;, &quot;F&quot;)) juul$menarche &lt;- factor(juul$menarche, labels = c(&quot;No&quot;, &quot;Yes&quot;)) juul$tanner &lt;- factor(juul$tanner, labels = c(&quot;I&quot;,&quot;II&quot;,&quot;III&quot;,&quot;IV&quot;,&quot;V&quot;)) . attach(juul) . summary(juul) . age menarche sex igf1 tanner Min. : 0.170 No :369 M :621 Min. : 25.0 I :515 1st Qu.: 9.053 Yes :335 F :713 1st Qu.:202.2 II :103 Median :12.560 NA&#39;s:635 NA&#39;s: 5 Median :313.5 III : 72 Mean :15.095 Mean :340.2 IV : 81 3rd Qu.:16.855 3rd Qu.:462.8 V :328 Max. :83.000 Max. :915.0 NA&#39;s:240 NA&#39;s :5 NA&#39;s :321 testvol Min. : 1.000 1st Qu.: 1.000 Median : 3.000 Mean : 7.896 3rd Qu.:15.000 Max. :30.000 NA&#39;s :859 . &#52860;&#47100; &#53440;&#51077;&#48320;&#44221;&#51012; factor(&#44060;&#48324;$&#52860;&#47100;, labels = c()) &#45824;&#49888; transform()&#51004;&#47196; &#54620;&#48264;&#50640; . # sex=factor(sex,labels=c(&quot;M&quot;,&quot;F&quot;)), # menarche=factor(menarche,labels=c(&quot;No&quot;,&quot;Yes&quot;)), # tanner=factor(tanner,labels=c(&quot;I&quot;,&quot;II&quot;,&quot;III&quot;,&quot;IV&quot;,&quot;V&quot;))) . 4.2 Graphics display of distributions . 4.2.1 histograms . x = rnorm(50) x . &lt;ol class=list-inline&gt; -0.523181786341978 | 0.451457907390337 | 0.275003001255217 | 0.292145234018122 | -1.39910743493551 | -0.416353150629471 | -1.08937239633716 | 1.96657592368326 | -0.201599720828973 | 1.40125665893491 | 0.325218628924169 | 0.845435392820938 | -0.683105163541711 | -0.988071064624355 | -0.45228104185852 | -0.942524710084633 | -0.918547984279348 | 0.364205532243233 | 0.417665383082668 | -0.359363252364594 | 0.0359407858682815 | 0.379495548445742 | -0.254258827503146 | -0.593111748793259 | -0.443019322919836 | 1.16352475108668 | 0.485397641806834 | 1.84447025212903 | 0.987331989657301 | 1.14334551872142 | -0.797547014691286 | 0.971883130172048 | 0.433487426805001 | -1.32271014386735 | -0.0683372759276903 | -0.703764792439601 | 0.720484325909687 | 0.63008004969353 | -1.03956573981155 | 0.288567819193043 | -0.303518327569541 | 0.741856949488032 | -0.98642745558575 | -0.753699493015343 | -1.73608056678819 | -0.70758248038827 | -0.712051236692159 | -0.254454553040855 | -0.0591021843256681 | 2.27270927596441 | &lt;/ol&gt; hist(x) . mid.age &lt;- c(2.5,7.5,13,16.5,17.5,19,22.5,44.5,70.5) acc.count &lt;- c(28,46,58,20,31,64,149,316,103) age.acc &lt;- rep(mid.age,acc.count) brk &lt;- c(0,5,10,16,17,18,20,25,60,80) hist(age.acc, breaks=brk) . 4.2.2 Empirical cumulative distribution -&gt; &#45936;&#51060;&#53552;&#44032; &#51221;&#44508;&#48516;&#54252; &#46384;&#47476;&#45716;&#51648; &#48372;&#44592; &#50948;&#54632; . x이하인 것의 갯수 시그마 I(X&lt;=x) . I(X &lt;= x): x보다 작거나 같으면 1, 아니면 0 | 그것들의 누적합 | . | x보다 작은 것의 누적 합 . | . n &lt;- length(x) n . 50 (1:n)/n . &lt;ol class=list-inline&gt; 0.02 | 0.04 | 0.06 | 0.08 | 0.1 | 0.12 | 0.14 | 0.16 | 0.18 | 0.2 | 0.22 | 0.24 | 0.26 | 0.28 | 0.3 | 0.32 | 0.34 | 0.36 | 0.38 | 0.4 | 0.42 | 0.44 | 0.46 | 0.48 | 0.5 | 0.52 | 0.54 | 0.56 | 0.58 | 0.6 | 0.62 | 0.64 | 0.66 | 0.68 | 0.7 | 0.72 | 0.74 | 0.76 | 0.78 | 0.8 | 0.82 | 0.84 | 0.86 | 0.88 | 0.9 | 0.92 | 0.94 | 0.96 | 0.98 | 1 | &lt;/ol&gt; # y는 총갯수에 대해 1,2,3,4... n 까지 나열하는데 값을 /50 -&gt; 0부터 1까지를 50등분? # x정규분포 50개의 값과 무관하게, # y는 0부터 1까지 점점 커지는 n등분 plot( sort(x), (1:n)/n) . # y는 0부터 1까지 점점 커지는 n등분 # type=&quot;s&quot;를 통해, 산점도를 계단식의 선으로 표현 plot( sort(x), (1:n)/n, type=&quot;s&quot; ) . # y는 0부터 1까지 점점 커지는 n등분 -&gt; n개의 x에 대해, 자신의 위치? # type=&quot;s&quot;를 통해, 산점도를 계단식의 선으로 표현 plot( sort(x), (1:n)/n, type=&quot;s&quot;, ylim=c(0,1) ) . library(&quot;stats&quot;) ecdf(x) . &lt;pre class=language-r&gt;structure(function (v) .approxfun(x, y, v, method, yleft, yright, f), class = c(&quot;ecdf&quot;, &quot;stepfun&quot;, &quot;function&quot;), call = ecdf(x))&lt;/pre&gt; 4.2.3 Q-Q plots (quantile versus quantile plots) -&gt; &#51221;&#44508;&#48516;&#54252; &#46384;&#47476;&#45716;&#51648; &#54869;&#51064; &#44536;&#47000;&#54532;2 . 정규분포를 따른다고 가정했을 때 vs 실제 엠피리칼 누적분포 정규분포를 따르면, 일직선으로 나온다. | . | . qqnorm(x) . 4.2.4 Boxplots . 원래그림 vs 로그변환그림으로 상자그림을 그려보자 | . library(ISwR) par(mfrow=c(1,2)) boxplot(IgM) boxplot(log(IgM)) # # 복구 par(mfrow=c(1,1)) . 4.3 Summary statistics by groups &#44536;&#47353;&#48324; &#53685;&#44228;&#47049; . tapply(&#51665;&#44228;&#48320;&#49688;, &#44536;&#47353;&#48320;&#49688;, &#51665;&#44228;&#54632;&#49688;) -&gt; &#44060;&#48324; &#51665;&#44228;&#44050; . attach(red.cell.folate) head(red.cell.folate, 3) # folate ventilation # 1 243 N2O+O2,24h # 2 251 N2O+O2,24h # 3 275 N2O+O2,24h # 그룹별 folate의 평균 tapply(folate,ventilation,mean) . The following objects are masked from red.cell.folate (pos = 3): folate, ventilation . folateventilation . 243 | N2O+O2,24h | . 251 | N2O+O2,24h | . 275 | N2O+O2,24h | . &lt;dl class=dl-horizontal&gt; N2O+O2,24h 316.625 N2O+O2,op 256.444444444444 O2,24h 278 &lt;/dl&gt; tapply(folate,ventilation,sd) . &lt;dl class=dl-horizontal&gt; N2O+O2,24h 58.7170880457421 N2O+O2,op 37.1217965321963 O2,24h 33.7564808592365 &lt;/dl&gt; tapply(folate,ventilation,length) . &lt;dl class=dl-horizontal&gt; N2O+O2,24h 8 N2O+O2,op 9 O2,24h 5 &lt;/dl&gt; &#44536;&#47353;&#54217; &#54217;&#44512;(xbar), n(length), s(&#54364;&#51456;&#54200;&#52264;) by tapply -&gt; cbind&#47196; &#47926;&#51008; &#44061;&#52404; &#47564;&#46308;&#44592; . xbar &lt;- tapply(folate, ventilation, mean) s &lt;- tapply(folate, ventilation, sd) n &lt;- tapply(folate, ventilation, length) cbind(mean=xbar, std.dev=s, n=n) . meanstd.devn . N2O+O2,24h316.6250 | 58.71709 | 8 | . N2O+O2,op256.4444 | 37.12180 | 9 | . O2,24h278.0000 | 33.75648 | 5 | . NA&#44032; &#54252;&#54632;&#46108; &#44536;&#47353;&#48324; &#53685;&#44228;&#45716; na.rm=T &#50741;&#49496;&#45347;&#50612; tapply . tapply(igf1, tanner, mean) . &lt;dl class=dl-horizontal&gt; I &lt;NA&gt; II &lt;NA&gt; III &lt;NA&gt; IV &lt;NA&gt; V &lt;NA&gt; &lt;/dl&gt; tapply(igf1, tanner, mean, na.rm=T) . &lt;dl class=dl-horizontal&gt; I 207.472668810289 II 352.671428571429 III 483.222222222222 IV 513.01724137931 V 465.334415584416 &lt;/dl&gt; aggregate : &#44536;&#47353;&#48324; &#44060;&#48324;&#51665;&#44228;(tapply) &#47568;&#44256; &#54620;&#44732;&#48264;&#50640; &#51665;&#44228; . aggregate( juul[c(&quot;age&quot;,&quot;igf1&quot;)], list(sex=juul$sex), mean, na.rm=T) . sexageigf1 . M | 15.38436 | 310.8866 | . F | 14.84363 | 368.1006 | . &#44536;&#47353;&#48324; &#53685;&#44228;&#45716; by&#44032; &#51228;&#51068; &#54200;&#54616;&#45796; . by( juul, juul[&quot;sex&quot;], summary) . sex: M age menarche sex igf1 tanner testvol Min. : 0.17 No : 0 M:621 Min. : 29.0 I :291 Min. : 1.000 1st Qu.: 8.85 Yes : 0 F: 0 1st Qu.:176.0 II : 55 1st Qu.: 1.000 Median :12.38 NA&#39;s:621 Median :280.0 III : 34 Median : 3.000 Mean :15.38 Mean :310.9 IV : 41 Mean : 7.896 3rd Qu.:16.77 3rd Qu.:430.2 V :124 3rd Qu.:15.000 Max. :83.00 Max. :915.0 NA&#39;s: 76 Max. :30.000 NA&#39;s :145 NA&#39;s :141 sex: F age menarche sex igf1 tanner testvol Min. : 0.25 No :369 M: 0 Min. : 25.0 I :224 Min. : NA 1st Qu.: 9.30 Yes :335 F:713 1st Qu.:233.0 II : 48 1st Qu.: NA Median :12.80 NA&#39;s: 9 Median :352.0 III : 38 Median : NA Mean :14.84 Mean :368.1 IV : 40 Mean :NaN 3rd Qu.:16.93 3rd Qu.:483.0 V :204 3rd Qu.: NA Max. :75.12 Max. :914.0 NA&#39;s:159 Max. : NA NA&#39;s :176 NA&#39;s :713 . 4.4 Graphics for grouped data &#44536;&#47353;&#45936;&#51060;&#53552;(1&#44060;&#52860;&#47100; &#48276;&#51452;&#48324;)&#50640; &#45824;&#54620; &#44536;&#47000;&#54532; . 4.4.1 Histograms &#44536;&#47353;&#48324; [&#48276;&#51452;&#54805; &#48712;&#46020;&#48516;&#54252;] &#48708;&#44368; by &#55176;&#49828;&#53664;&#44536;&#47016; . attach(energy) expend.lean &lt;- expend[stature==&quot;lean&quot;] # 범주종류별로 개별칼럼 만들기 by 인덱싱 expend.obese &lt;- expend[stature==&quot;obese&quot;] # 범주종류별로 개별칼럼 만들기 # 범주종류별 개별칼럼을 개별로 그리기 par(mfrow=c(2,1)) hist(expend.lean,breaks=10, xlim=c(5,13),ylim=c(0,4),col=&quot;white&quot;) hist(expend.obese,breaks=10, xlim=c(5,13),ylim=c(0,4),col=&quot;grey&quot;) par(mfrow=c(1,1)) . 4.4.2 Parallel boxplots &#44536;&#47353;&#48324; [&#49707;&#51088;&#54805; &#48516;&#54252;] &#48708;&#44368; . # boxplot(데이터 ~ 범주종류를 가진 범주칼럼) boxplot(expend ~ stature) . # boxplot(범주1칼럼, 범주2칼럼) boxplot(expend.lean, expend.obese) . 4.4.3 Stripcharts: &#44536;&#47353;&#48324; &#45936;&#51060;&#53552;&#44032; &#51201;&#51012; &#46416;, &#49345;&#51088;&#44536;&#47548;&#48372;&#45796;&#45716; raw&#45936;&#51060;&#53552; &#51649;&#51217; &#44536;&#47532;&#44592; . 데이터가 작은 그룹별 숫자 분포 | . opar &lt;- par(mfrow=c(2,2), mex=0.8, mar=c(3,3,2,1)+.1) stripchart(expend ~ stature) # 1x1 : stripchart(expend ~ stature, method=&quot;stack&quot;) # 1x2 stack stripchart(expend ~ stature, method=&quot;jitter&quot;) # 2x1 겹치는 것을 피하기 위해 약간 흔들어서 stripchart(expend ~ stature, method=&quot;jitter&quot;, jitter=.03) # 2x2 덜 세게 흔들기 par(opar) . . 4.5 Tables . 4.5.1 Generating tables . 알트만 자료를 예시데이터로 c() -&gt; matrix() byrow | matrix에 colnames, rownames 벡터로 넣어주기 | matrix에 row전체이름, col전체이름을 names(dimnames())에 벡터로 넣어주기 | matrix -&gt; table -&gt; dataframe으로 만들기 by as.data.frame(as.table( matrix )) | caff.marital &lt;- matrix(c(652,1537,598,242,36,46,38,21,218,327,106,67), nrow=3,byrow=T) caff.marital . 652 | 1537 | 598 | 242 | . 36 | 46 | 38 | 21 | . 218 | 327 | 106 | 67 | . colnames(caff.marital) &lt;- c(&quot;0&quot;,&quot;1-150&quot;,&quot;151-300&quot;,&quot;&gt;300&quot;) . rownames(caff.marital) &lt;- c(&quot;Married&quot;,&quot;Prev.married&quot;,&quot;Single&quot;) . caff.marital . 01-150151-300&gt;300 . Married652 | 1537 | 598 | 242 | . Prev.married 36 | 46 | 38 | 21 | . Single218 | 327 | 106 | 67 | . # 여기선 안보이는 듯 -&gt; matrix -&gt; table -&gt; dataframe으로 만들면 보이게 된다. names(dimnames(caff.marital)) &lt;- c(&quot;marital&quot;,&quot;consumption&quot;) . caff.marital . 01-150151-300&gt;300 . Married652 | 1537 | 598 | 242 | . Prev.married 36 | 46 | 38 | 21 | . Single218 | 327 | 106 | 67 | . . as.data.frame(as.table(caff.marital)) # 실제 작업을 한다면, 첫번째 case는 652만큼 더 읽어라? 로 작업? by rep . maritalconsumptionFreq . Married | 0 | 652 | . Prev.married | 0 | 36 | . Single | 0 | 218 | . Married | 1-150 | 1537 | . Prev.married | 1-150 | 46 | . Single | 1-150 | 327 | . Married | 151-300 | 598 | . Prev.married | 151-300 | 38 | . Single | 151-300 | 106 | . &lt;span style=white-space:pre-wrap&gt;Married &lt;/span&gt; | &lt;span style=white-space:pre-wrap&gt;&gt;300 &lt;/span&gt; | 242 | . Prev.married | &lt;span style=white-space:pre-wrap&gt;&gt;300 &lt;/span&gt; | &lt;span style=white-space:pre-wrap&gt; 21&lt;/span&gt; | . &lt;span style=white-space:pre-wrap&gt;Single &lt;/span&gt; | &lt;span style=white-space:pre-wrap&gt;&gt;300 &lt;/span&gt; | &lt;span style=white-space:pre-wrap&gt; 67&lt;/span&gt; | . table()&#54632;&#49688;&#47196; &#48276;&#51452;&#54805;&#51032; &#48712;&#46020;&#49688; &#44036;&#45800;&#54616;&#44172; &#49464;&#44592; . head(juul, 2) . agemenarchesexigf1tannertestvol . NA | NA | NA | 90 | NA | NA | . NA | NA | NA | 88 | NA | NA | . table(sex) . sex M F 621 713 . table( sex, menarche) . menarche sex No Yes M 0 0 F 369 335 . xtabs, ftable &#46020; &#48708;&#49847;&#54620; &#44592;&#45733;&#51076; . table &gt; xtabs&gt; ftable | . xtabs( ~ sex + menarche, data=juul) . menarche sex No Yes M 0 0 F 369 335 . 4.5.2 Marginal tables and relative frequency . table()의 결과 빈도표에 적용하는 margin.table()메서드 | . tanner.sex &lt;- table( tanner, sex ) tanner.sex . sex tanner M F I 291 224 II 55 48 III 34 38 IV 41 40 V 124 204 . margin.table( tanner.sex , 1) # 가로1 -&gt; 행별로 빈도수 총합 보기 (row그룹의 범주별 빈도만 보기) . tanner I II III IV V 515 103 72 81 328 . margin.table( tanner.sex , 2) # 세로2 -&gt; col그룹의 범주별 빈도만 보기 . sex M F 545 554 . prop.table( ) : table(&#48276;&#51452;&#48712;&#46020;&#54364;)&#50640; &#45824;&#54644; &#48708;&#50984;&#47196; &#48372;&#44592; . prop.table( tanner.sex, 1) . sex tanner M F I 0.5650485 0.4349515 II 0.5339806 0.4660194 III 0.4722222 0.5277778 IV 0.5061728 0.4938272 V 0.3780488 0.6219512 . prop.table( tanner.sex, 2) . sex tanner M F I 0.53394495 0.40433213 II 0.10091743 0.08664260 III 0.06238532 0.06859206 IV 0.07522936 0.07220217 V 0.22752294 0.36823105 . 4.6 Graphical display of tables . 4.6.1 Barplots : table&#47196; &#44396;&#54620; &#48276;&#51452;&#48324;&#48712;&#46020;&#54364;&#51032; &#49884;&#44033;&#54868; . matrix -&gt; margin.table -&gt; 범주형1개에 대한 종류별 빈도 -&gt; barplot | caff.marital # matrix . 01-150151-300&gt;300 . Married652 | 1537 | 598 | 242 | . Prev.married 36 | 46 | 38 | 21 | . Single218 | 327 | 106 | 67 | . total.caff &lt;- margin.table( caff.marital, 2) # 칼럼종류렬 빈도만 보기 total.caff . &lt;dl class=dl-horizontal&gt; 0 906 1-150 1910 151-300 742 &gt;300 330 &lt;/dl&gt; barplot( total.caff, col=&quot;white&quot;) . &#47564;&#50557; 2&#44060;&#51032; matrix &#48712;&#46020;&#54364;(table)&#51060;&#46972;&#47732;, &#51088;&#46041;&#51004;&#47196; stack barplot&#51012; &#44536;&#47536;&#45796; . t ( )는 행렬을 바꾸는 메서드 | beside=T : stack을 푸는 옵션 | prop.table( ,2): stack을 beside=T로 풀어줄 때, row=x축이 아닌 `col의 범주종류들별로 풀어진 상태 -&gt; prop.table( , 2)로 각 덩어리들의 합을 1로 가지는 비율로 그린다. | . caff.marital . 01-150151-300&gt;300 . Married652 | 1537 | 598 | 242 | . Prev.married 36 | 46 | 38 | 21 | . Single218 | 327 | 106 | 67 | . t(caff.marital) . MarriedPrev.marriedSingle . 0 652 | 36 | 218 | . 1-1501537 | 46 | 327 | . 151-300 598 | 38 | 106 | . &gt;300 242 | 21 | 67 | . par(mfrow = c(2,2)) barplot(caff.marital, col=&quot;white&quot;) # matrix형태의 barplot은 자동 stack barplot(t(caff.marital), col=&quot;white&quot;) # t()로 뒤집어서 반대가 stack으로 들어가고 stack은 x축으로 표기됨 barplot(t(caff.marital), col=&quot;white&quot;, beside = T) # stack을 푸는 옵션 barplot(prop.table(t(caff.marital),2) , col=&quot;white&quot;, beside = T) # 빈도수 -&gt; 비율로 바꾸는 옵션 # prop.table( ,2)로 주어서, 세로칼럼별 = stack이 풀려져있는 덩어리들별로.. 비율구해주기 par(mfrow=c(1,1)) . Using legend : 2&#44060;&#51060;&#49345;&#51032; &#52860;&#47100;&#51032; &#48712;&#46020; -&gt; 1&#44060;&#45716; stack or beside -&gt; legend&#47196; &#49444;&#47749;&#54644;&#51480;&#50556;&#54620;&#45796;. . row에 가있는 칼럼은 x축으로 범주종류들(그룹별)이 소개된다 col에 있던 -&gt; stack or beside 들은 legend.text = 에 colnames()로 받은 벡터를 넣어준다. | . | . barplot(prop.table(t(caff.marital),2) , col=&quot;white&quot;, beside = T, legend.text = colnames(caff.marital) ) . barplot(prop.table(t(caff.marital),2) , beside = T, legend.text = colnames(caff.marital), col = c(&quot;white&quot;, &quot;grey80&quot;, &quot;grey50&quot;, &quot;black&quot;) ) . 4.6.2 Dotcharts: barplot&#51032; &#45936;&#51060;&#53552;&#44032; &#51201;&#51012; &#46412; . 숫자형: boxplot -&gt; Stripcharts | 범주형: barplot -&gt; dotchats . | 빈도에 대해 한눈에 보인다. . | . dotchart(t(caff.marital), lcolor=&quot;black&quot;) # row가 왼쪽에 먼저 # col은 왼쪽에 depth넣고 . 4.6.3 Piecharts . 1개의 범주형에 대해 못그리니 직접 칼럼범주종류별? 행종류별? 인덱싱해놓고 거기서의 분포를 본다. | . opar &lt;- par(mfrow=c(2,2),mex=0.8,mar=c(1,1,2,1)) slices &lt;- c(&quot;white&quot;,&quot;grey80&quot;,&quot;grey50&quot;,&quot;black&quot;) # col=에 넣을 컬러들 미리 빼놓기 pie(caff.marital[&quot;Married&quot;,], main=&quot;Married&quot;, col=slices) pie(caff.marital[&quot;Prev.married&quot;,], main=&quot;Previously married&quot;, col=slices) pie(caff.marital[&quot;Single&quot;,], main=&quot;Single&quot;, col=slices) par(opar) . &#51221;&#47532;: &#44536;&#47353;&#48324;&#44536;&#47548; boxplot-stripchart or barplot-dotchart or piechart &#49440;&#53469; .",
            "url": "blog.chojaeseong.com/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EB%8D%B0%EB%B6%84%EB%B0%A91/%ED%99%95%EB%A5%A0%EA%B3%BC%EB%B6%84%ED%8F%AC/%EA%B8%B0%EC%88%A0%ED%86%B5%EA%B3%84/2022/03/15/02-%EB%8D%B0%EB%B6%84%EB%B0%A902)-%ED%99%95%EB%A5%A0%EA%B3%BC-%EB%B6%84%ED%8F%AC-and-Descriptive-statistics-and-graphics.html",
            "relUrl": "/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EB%8D%B0%EB%B6%84%EB%B0%A91/%ED%99%95%EB%A5%A0%EA%B3%BC%EB%B6%84%ED%8F%AC/%EA%B8%B0%EC%88%A0%ED%86%B5%EA%B3%84/2022/03/15/02-%EB%8D%B0%EB%B6%84%EB%B0%A902)-%ED%99%95%EB%A5%A0%EA%B3%BC-%EB%B6%84%ED%8F%AC-and-Descriptive-statistics-and-graphics.html",
            "date": " • Mar 15, 2022"
        }
        
    
  
    
        ,"post111": {
            "title": "TDD 6 로또(캐슁,Factory,전략)",
            "content": "캐슁 . 19 싱글톤을 이용한 [단일객체 CACHE] 적용과 TDD . 싱글톤을 이용한 CACHE 생성 2가지 방법(정리용) . 싱글톤 생성 방법 . static final으로 클래스 CACHE변수; 선언 . 바로 옆에서 = 할당하며 초기화 or 길어서 static { 클래스변수 = } 블럭(final도 가능)에서 초기화 바로 초기화하든, static블럭에서 초기화하든 null이 아닌 상태의 캐쉬변수 | . | 이후 정팩메로만 생성된 CACHE객체 or 생성된 CACHE자료구조에서 1개만 get하여 제공 이후 기본생성자는 CACHE 최초 초기화하며 채울때만 사용됨 | . | . private static final Map&lt;Integer, LottoNumber&gt; LOTTO_NUMBER_CACHE; static { LOTTO_NUMBER_CACHE = IntStream.rangeClosed(LOTTO_NUMBER_MIN, LOTTO_NUMBER_MAX) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } private final int number; public LottoNumber(final int inputNumber) { this.number = inputNumber; } public static LottoNumber from(final String inputNumber) { final int number = Integer.parseInt(inputNumber); validateLottoNumberRange(number); return LOTTO_NUMBER_CACHE.get(number); } . | static으로 클래스 CACHE변수; 선언 (no final) . 이후 정팩메에 synchronized달아주고 . | 정펙매내부에서 초기화 한번도 안된 최초 if (CACHE == null) 상태의 캐쉬변수일 때만, 기본생성자로 CACHE변수 초기화 | 정펙매로만 생성된 CACHE객체 or 생성된 CACHE자료구조에서 1개만 get하여 제공 | . private static Map&lt;Integer, LottoNumber&gt; LOTTO_NUMBER_CACHE; private final int number; private LottoNumber(final int number) { checkNumberRightRange(number); this.number = number; } public synchronized static LottoNumber valueOf(final int number) { checkNumberRightRange(number); if (LOTTO_NUMBER_CACHE == null) { LOTTO_NUMBER_CACHE = IntStream.rangeClosed(MIN_LOTTO_NUMBER, MAX_LOTTO_NUMBER) .boxed() .collect(Collectors.toMap(lottoNumber -&gt; lottoNumber, LottoNumber::new)); } return LOTTO_NUMBER_CACHE.get(number); } . | | Test에서부터 빨간줄로 넘어가 -&gt; 캐쉬 적용하기 . 캐쉬로 받아먹으려면 싱글톤 받아주는 정펙매(getInstance())로만 가져와야한다. . 네이밍을 그렇게 했어도 기본 생성자에 넣어줄 파라미터도 받아야한다. | . | 싱글톤의 동시성 잇슈를 처리하기 위해 synchronized를 접근제한자 &lt;-&gt; static 사이에 넣어준다. . public synchronized static void getInstance(final int value) { } . | 앞으로 정펙매로만 제공되어야하므로 도메인 검증을 여기로 옮기자. . 기존 도메인테스트가 new 기본생성자()로 진행되어있으니, 그냥 두고 -&gt; 맨 나중에 도메인검증을 정팩메코드로 + 기본생성자는 private + 검증은 삭제하도록 수정하자.. | . | . public LottoNumber(final int value) { // 지금은 임시로 살려둔다. 테스트를 나중에 바꿀 때 private로 변경 + 검증삭제 validate(value); this.value = value; } public synchronized static void getInstance(final int value) { //2. 검증은 여기로 옮긴다. 왜냐면, 앞으로 CACHE정팩메로만 제공될 것이기 때문. // - 정적안에 들어가므로 검증메서드가 static으로 바뀐다. validate(value); } . | CACHE의 static변수 선언을 직접 안하고 빨간줄생성 하기 위해, . 빨간줄로 if ( == null )부터 static 초기화 를 작성해줬다. 기본생성자는 이제 여기 캐쉬생성에서만 이용되어야한다. 원래는 private으로 바꾸고, TEST다 처내야함. | . | . | static 메서드 내 자동 생성시 constant = static final이므로 그냥 field -&gt; static필드로 생성하자. | . . public class LottoNumber { private static final int MIN = 1; private static final int MAX = 45; // 자동 생성한 CACHE field (static) private static Map&lt;Integer, LottoNumber&gt; CACHE; private final int value; public synchronized static void getInstance(final int value) { validate(value); //3. 캐쉬로 제공될 static 변수; 만 선언하고 -&gt; if null일 때 = 최초에만 초기화 시켜준다. // - Map으로 만들거면 // - 중간에 .map( number -&gt; )없이 맨 나중에 toMap으로 만들면 된다. // - intStream은 Integer가 아니다. toMap에 들어가려면 .boxed() 먼저 해주고 들어가야한다. // - toMap의 2번쨰 인자는 method reference만 사용 가능하다. new LottoNumber(Number하니 안되더라) if (CACHE == null) { CACHE = IntStream.rangeClosed(MIN, MAX) //.map( number -&gt; ) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } } . | 정팩메에서 캐쉬객체 or 캐쉬 자료구조.get()한 것을 응답해준다. . public synchronized static LottoNumber getInstance(final int value) { validate(value); if (CACHE == null) { CACHE = IntStream.rangeClosed(MIN, MAX) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } // 제공은 이제 기본생성자가 아닌, CACHE에서 제공해준다. return CACHE.get(value); } . | 검증이 넘어간 캐쉬 정팩메로 생성 테스트로 마무리 . @Test void cache_create() { assertDoesNotThrow(() -&gt; LottoNumber.getInstance(6)); } . 갯수만큼 일급&lt;List&gt; 생성 -&gt; 메인로직이 도메인 생성이라 static 일급Factory 를 거치도록 기능 분리 . static Service는 재료를 받아 메인로직의 흐름을 호출 및 처리한다. **일급생성은 일급 생성자에서 하면 되지만, 일급List 생성 with Money만큼은 단순히 한번 더 포장하는 것보다 복잡하다. ** 도메인 생성 로직을 서비스가 아닌도메인Factory.메서드()를 거친 뒤 -&gt; 그 응답값(일급의 리스트)을 필요에 따라 포장하던지 해야한다. | . | 도메인 생성의 역할이므로 service로직이 아니라 도메인 로직쪽이라 서비스는 호출만 해준다. | . | 앞으로 생성의 방법이 여러갈래 (Manual/Auto)로 외부에서 주입될 가능성이 높아도 도메인Factory에서 외부 생성타입 주입을 받아주는 역할을 해준다. | . 20 Service에서 복잡한 도메인 생성( 갯수만큼 일급List 생성)을 호출한다면, service에서 호출해주는 정적Static한 도메인Facotry가 도메인로직으로서 생성을 담당한다. . Service에서 생성로직을 호출하되, 메서드는 Factory가 가져간다. 가장 정제된 원시Type을 인자로 받는다. . 사정상 여기선 정제된input으로 new LottoMonety(3000)의 포장도메인 대신 장제된 원시값인 3000(원)을 인자로 넣어준다. . **원래는 new LottoMoney(도메인)을 넣어줘야하는데, 도메인 클래스 포장은 나중에 하고 정제된 input을 가정하고 원시값으로 호출해서 점점 포장해나가므로 ** 가장 원시값을 [포장도메인VO 입력 -&gt; 도메인.getter를 내부에 호출하는] 대신 바로 쓸 수 있는 원시값을 파라미터로 일단 제공해서 생성한다. | . | . . @Test void issue_lotto_by_money() { LottoService.issueByMoney(3000); } . | . 실제 Serivce내 도메인 생성관련 모든 로직은 도메인내부or도메인Factory에 일임시킨다. . Service내에서 class부터 생성해야한다면 . class -&gt; classTest -&gt; classTest에서 메서드 빨간줄 생성 -&gt; 메서드생성 | . public static void issueByMoney(final int money) { // input으로 money -&gt; money에게 횟수로 치면 몇번이냐 물어볼 예정임. final int count = money / 1000; LottoFactory.issueByCount(count); } . | 메서드 생성이 [컨셉과 파라미터가 잡힌 경우]는 프로덕션 빨간줄로 생성하되 ClassTest 빨간줄까지 가서 메서드 생성 완료하기! . 메서드 생성을 프로덕션에서 해야할 경우, 컨셉과 파라미터가 잡힌 경우, Test에서 메서드 생성하기가 쉽지 않다. . 프로덕션에서 메서드의 컨셉과 파라미터가 잡힌 경우 -&gt; 프로덕션 빨간줄로 메서드 생성하되 ClassTest-&gt;해당 메서드호출까지 작성 완료한다. . . | 클래스 생성후 바로 ClassTest생성 -&gt; 생성 원하는 메서드 호출까지 완료한 뒤 로직 작성할 것 . . | . | . [갯수(raw숫자)만큼 반복로직]은 VO로 바뀔 것 대비 [틀을 잡아 while로 돌리기] . 차후 미래에 VO로 포장시 . public static void issueLottoByCount(final int count) { Count count = new Count(number); while (count.isNotFinished()) { count = count.decrease(); // 반복되는 단일로직 issueLotto } } . | 현재 . VO count를 0까지 허용하면서, 깍아내려가다가, 0일 때, 튕겨나가게 할 것이다. | 그전까진 내부에서 1개씩 깍으면서 반복하기 | . public static void issueLottoByCount(int count) { while (count != 0) { count-=1; // 반복되는 단일 로직 issueLotto } } . . | . 내부에서 정의될, [1개당 도메인 생성]로직도 도메인Factory내 메서드로 정의 . 프로덕션내 메서드 정의 해야한다면, 빨간줄 생성후 ClassTest에서 메서드 호출까지 완료해라고 했다. . . | 프로덕션빨간줄 생성이라면 -&gt; private이라도 public수정후 TestGenerate로 ClassTest 생성 -&gt; 메서드호출까지 완료 시키기 . 메서드의 접근제한자를 private -&gt; public으로 수정 . 나중에 다 public 메서드들 조사하면 될 듯 -&gt; 테스트에서만 사용시 삭제or Private화 시키면 될 듯 | . . | private -&gt; public 수정후에는 Test메서드로 자동생성 됨. . | 생성된 테메에서 메서드 호출까지 완료하자 . . . | 21 CACHE된 단일 객체는 -&gt; Static한 [도메인Factory]의 Static {} 블럭에서 미리 뽑아놓을 수 있다. . 재료가 되는 도메인은 의존/갖다써도/상수는 public으로 바꿔써도 된다. . . public class LottoFactory { static { //1. Factory는 재료도메인을 의존해서 사용해도 된다. // -&gt; 재료 도메인내 상수를 public으로 바꿔서 Facotry에서 같이 쓰자. //2. 캐쉬된 것들을 static 블록에 다 모아놓는다. (랜덤구현은 [메서드 호출시 shffle + subList] IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(it -&gt; LottoNumber.getInstance(it)) .collect(Collectors.toList()); } . suffle과 subList를 통한 랜덤구현을 위해 []미리CACHE된 재료만 다 static{}블럭]에서 준비한다. . 준비물들을 미리 뽑아놓고 -&gt; 상수 추출을 한다. . | split 선언 &lt;-&gt; 초기화시키면 알아서 static블럭에서 초기화시켜 미리 준비되도록 한다. . . public class LottoFactory { private static final List&lt;LottoNumber&gt; LOTTO_NUMBERS; static { LOTTO_NUMBERS = IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(it -&gt; LottoNumber.getInstance(it)) .collect(Collectors.toList()); } . | 21 정해진 갯수에서 일부 랜덤이다? -&gt; 정해진 갯수 셔플 + subList(or .limit)으로 랜덤을 구현 . CACHE(static 싱글톤)을 이용한 static {}블럭에 준비된 랜덤준비물들을 랜덤이 필요한곳에서 shuffle + subList or .limit으로 구현하기 . public static Lotto issueLotto() { //3. [랜덤한 6개 뽑기] 구현을 [미리 준비된 cache 들] -&gt; shuffle &amp;&amp; 일부뽑기로 구현한다. Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } . | random한 일급 테스트 -&gt; getter후 size + 제한된 범위(단일객체의 경계값) 검사 . @Test void issueLotto_count() { final Lotto lotto = LottoFactory.issueLotto(); assertThat(lotto.getValue().size()).isEqualTo(6); } @Test void issueLotto_range() { final Lotto lotto = LottoFactory.issueLotto(); final ListIterator&lt;LottoNumber&gt; lottoNumberIterator = lotto.getValue().listIterator(); while (lottoNumberIterator.hasNext()) { assertThat(lottoNumberIterator.next()) .isGreaterThanOrEqualTo(LottoNumber.getInstance(1)) .isLessThanOrEqualTo(LottoNumber.getInstance(45)); } } . 22 다시 [횟수만큼 반복되는 도메인생성] 메서드 처리 . 단일 생성의 테스트를 마쳤다. . public static void issueLottoByCount(int count) { while (count != 0) { count -= 1; LottoFactory.issueLotto(); } } . | . 2번 이상의 add라면, 지역변수 가변 new ArrayList에 add해서 반환 . count만큼 반복해서 로또 발급후 add해서 반환해야한다. . public static ArrayList&lt;Lotto&gt; issueLottoByCount(int count) { final ArrayList&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (count != 0) { count -= 1; lottos.add(LottoFactory.issueLotto()); } return lottos; } . | 테스트에서, 랜덤한 3개 로또 발급에 대해 갯수정도만 테스트한다. . 단일 생성 테스트보다 더 밑으로 테스트를 옮겨주자. | . @Test void issue_by_count() { LottoFactory.issueLottoByCount(3); } . @Test void issue_by_count() { final List&lt;Lotto&gt; lottos = LottoFactory.issueLottoByCount(3); assertThat(lottos.size()).isEqualTo(3); } . | . 23 다시 Service로 돌아와 응답값 만들고 -&gt; 메서드 퉁 테스트 . public static List&lt;Lotto&gt; issueByMoney(final int money) { // input으로 money -&gt; money에게 횟수로 치면 몇번이냐 물어볼 예정임. final int count = money / 1000; return LottoFactory.issueLottoByCount(count); } . @Test void issue_lotto_by_money() { final List&lt;Lotto&gt; lottos = LottoService.issueByMoney(3000); assertThat(lottos.size()).isEqualTo(3000 / 1000); } . 서비스의 메인로직 진행 중 추가 로직(비교&amp;검증)이 발생하는데, 도메인의 영역이라면? -&gt; 대상들을 포장에 포장이라도 새로운 도메인으로 . 24 Service메서드 [파라미터들의 검증로직에 의한 개별 포장] 끝났는데, 또 [추가 검증 로직]이 서비스에 늘날려고 한다? . 포장된 일급과 단일의 검증인데도 또 포장? . **당첨로또와 보너스볼 번호는 중복되면 안되며므로 추가 검증 로직이 필요하고, 항상 붙어다닌다 -&gt; 2개 상태값을 가진 포장체 ** Lotto인데 굳이 포장해야하나? -&gt; 추가 검증이 필요하므로 일급vs단일의 검증인데도 2개 인변가지는 도메인으로 새로 포장 해야한다. 안그러면 서비스 ( or 컨트롤러)에 로직이 늘어난다. | . | 포장하기 전, [ service 테매 복붙]하고 case반영한 테메이름 바꾸고 -&gt; 메서드 추가해주기 . 테메 복붙해서 case반영해서 이름 바꿔주기 . | 포장해서 만들어나간다. . | 포장 도메인 만들어놓고, 생성자만 처리해준다. . 일단 하나는 value + 하는 구체적인 이름으로 적었다. | . public class WinningLotto { private final Lotto value; private final LottoNumber bonusNumber; public WinningLotto(final Lotto value, final LottoNumber bonusNumber) { this.value = value; this.bonusNumber = bonusNumber; } } . | 새롭게 포장된 파라미터를 받는 (차후 새 기준이 될)메소드도 추가 -&gt; 가장 위로 올린다. . 메서드 이름은 같고… 파라미터만 다른게 쌓여나간다. . 이놈이 새로운 | . . | 새 기준이 될 메서드를 가장 위로 올려보자. . . | . 직전 기준 메소드의 내용을 복붙 -&gt; 포장된 파라미터에 맞추어 빨간줄을 없앤다. (주로 getter로 임시처리) . 직전의 파라미터명과 비교해서 맞춰준다. | . 포장전 객체앞에다가 새롭게 포장.getter()을 통해 에러를 없앨 수 있다. . . | 포장 + 포장파라미터메서드 생성 -&gt; 새 기준 메서드로 지정하기- &gt; 전 메소드는 전 파라미터 -&gt; 포장후 호출하도록 변경 . . . public class LottoService { public static Rank match(final Lotto userLotto, final WinningLotto winningLotto) { final int matchCount = userLotto.match(winningLotto.getValue()); final boolean matchBonus = userLotto.contains(winningLotto.getBonusNumber()); return Rank.of(matchCount, matchBonus); } public static Rank match(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { return match(userLotto, new WinningLotto(winningLotto, bonusNumber)); } . 포장에 원하던 [생성자에 검증 로직 추가]후 테스트하기 . public WinningLotto(final Lotto value, final LottoNumber bonusNumber) { if (value.contains(bonusNumber)) { throw new IllegalArgumentException(&quot;당첨 번호와 보너스볼은 중복될 수 없습니다.&quot;); } this.value = value; this.bonusNumber = bonusNumber; } . 서비스에서 | . 서비스로 퉁 치던 테스트를 [도메인Test] 생성시 [경계값Test]하기 . WinningLottoTest 만들어서 경계값 테스트하기 . @ParameterizedTest @CsvSource({&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;}) void duplicate(final int bonusNumber) { assertThatThrownBy(() -&gt; new WinningLotto( new Lotto(1, 2, 3, 4, 5, 6), new LottoNumber(bonusNumber))) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;중복&quot;); } @ParameterizedTest @CsvSource({&quot;7&quot;, &quot;8&quot;, &quot;45&quot;}) void valid(final int bonusNumber) { assertDoesNotThrow(() -&gt; new WinningLotto( new Lotto(1, 2, 3, 4, 5, 6), new LottoNumber(bonusNumber))); } . | 새 기준 메서드에 임시처리(포장.getValue) 부분 메세지로 보내기 (과정) . 기존 임시처리 . public static Rank match(final Lotto userLotto, final WinningLotto winningLotto) { final int matchCount = userLotto.match(winningLotto.getValue()); final boolean matchBonus = userLotto.contains(winningLotto.getBonusNumber()); return Rank.of(matchCount, matchBonus); } . | . getter()를 제거해서 빨간줄을 낸다. . . | 기존 사용처에 대해 바로 변경이 아니라 메서드 생성 -&gt; 내부 내용 복사를 통해 백업한 체로 진행한다. . 이 경우, 새로운 메서드를 정의해주고, 기존 메서드 바로 밑으로 가져와서 비교하며 처리한다. | . . . | 새로운 기준을 만들어 나가며, 완성대면 완전히 대체한다. . //public int match(final Lotto other) { // return (int) other.value.stream() // .filter(this::contains) // .count(); //} public int match(final WinningLotto winningLotto) { return (int) winningLotto.getValue().value.stream() .filter(this::contains) .count(); } . | 나머지도 . //public boolean contains(final LottoNumber number) { // return value.contains(number); //} public boolean contains(final WinningLotto winningLotto) { return value.contains(winningLotto.getBonusNumber()); } . | 새 기준 메서드로 바꿨음에도 [기존메서드]가 다른데서 사용중인지 보고 가서 처리한다. . . 못바꾸는 부분이 있다면 그대로 둔다. | . 단일 결과의 메인로직(도1 vs 도2)을 여러번 돌리며 [결과값을 모으는 자료구조]도 포장하는 로직 . match()를 내부에서 여러번 호출하여 발생하는 것들을 map에 모아서 controller 응답한다. . | 결과값 map에 대한 계산로직도 포함될 예정이므로 생성될 자료구조(map)을 생성자에서 생성후 -&gt; 변수 포장하도록 class로 뺀다. . | . 25 단일결과by메인로직(도메인1 vs 도메인2)을 바깥에서 여러번 호출해서 발생하는 결과값을 저장할 새로운 자료구조가 나온다. -&gt; [결과값 저장 로직]을 생성자로 넘겨 -&gt; [최종 결과값 자료구조를 시작 상태값]으로 가지면서 + 관련로직을 메서드로 가지는 도메인3(Result도메인) 만들기 . 단일결과 로직(도메인1 vs 도메인2)인 메인 메서드의 파라미터 포장까지 완료된 상태여야만 -&gt; 바깥에서 여러번 돌릴 때, 포장된 것을 받을 수 있음 . 내부 단일결과를 유발하는 메인로직 메서드의 파라미터가 이미 포장이 끝났다. -&gt; 바깥에서 개별 결과값을 모으는 메서드도 포장된 값을 받는다. . 단일 결과(Enum)을 응답하는 메서드는 파라미터를 포장된 것을 받는다. | 바깥에서 결과값들을 모을 메서드 -&gt; 포장된 것을 받아야 편하다. | . @Test void get_result() { //1. 메인로직(match)를 여러번 호출해서 결과값을 받을 Service.메서드 // -&gt; 메인로직에 필요한 파라미터(Lotto여러개 + WinningLotto)는 넘겨줘야한다. final List&lt;Lotto&gt; lottos = List.of( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1, 2, 3, 4, 5, 7), new Lotto(1, 2, 3, 4, 7, 8) ); //0. 내부 메인로직(도1vs도2)의 파라미터 포장까지 완료되었을 때, // -&gt; 바깥에서 복수의 포장을 받아, 여러번 돌려 -&gt; 결과값을 저장할 수 있다. LottoService.getResult(lottos, new WinningLotto( new Lotto(1, 2, 3, 4, 5, 7), new LottoNumber(6))); } . | . 일단은 Service.Method내부에서 [메인로직을 돌리기]를 정의를 하다가 -&gt; 필요에 의해 옮기고 포장하자. . 현재 Service.getResult( , )에서 자료를 받아서, 현재는 서비스에서 호출하고 있던 메인로직(도1vs도2 비교)를 호출도 한다. . public static void getResult(final List&lt;Lotto&gt; lottos, final WinningLotto winningLotto) { //2. 일단 service내부에 도메인 계산로직을 작성한다. final List&lt;Rank&gt; results = lottos.stream() // 3. Service를 통해 돌리다보니, 1:1 단일결과(메인로직)을 호출할 수 밖에 없는데 // -&gt; 돌리는 이것 역시 서비스에서 호출하는 메서드였다. // -&gt; 만약, 결과값 모으는 곳으로 간다면 바뀌어야할 것 같다. .map(lotto -&gt; match(lotto, winningLotto)) .collect(Collectors.toList()); } . | 26 [결과값을 모은 List를 카운팅하는 새로운 응답(자료구조)] 만들기 . 단일 결과값들을 돌아가며 호출결과값 List를 모은다. | . Enum List -&gt; EnumMap에 카운팅하기(정리용) . List&lt;객체&gt;의 갯수를 객체를 key로 하는 hashMap Map&lt;객체, Integer&gt; 에 세야한다. | . 빈 Map 선언 및 초기화 . 객체의 Count을 원한다면 **&lt;객체key, Integer&gt;로 Map을 선언한다. ** (cf) 원시적으로는 직접 0으로 초기화 한다.) . EnumMap이라면 ( )생성자에 안에 Enum클래스.class(클래스 자체)를 지정해준다. | . final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); . 참고) . (원시적) 모든 객체key들 stream화해서 돌면서 -&gt; forEach -&gt; map.put(객체key, 0)으로 초기화해준다. . private final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); { Arrays.stream(Rank.values()).forEach(rank -&gt; result.put(rank, 0)); } . | . | EnumMap는 넣고난 뒤, 자동정렬되어있지만 . 일반map넣고 난 뒤, key순으로 정렬되어야하면(순서가 중요하면) hashMap대신 -&gt; linkedHashMap을 사용한다. | . private final LinkedHashMap&lt;Rank, Integer&gt; value = new LinkedHashMap&lt;&gt;(); . | . | 일급vs단일 로직을 먼저 수행한 -&gt; 응답결과List를 카운팅하는 3가지 방법 . 이제 갯수를 셀 결과값List(Enum List or 객체 List)들을 돌면서 카운팅한다. . 결과List(객체List)를 먼저 계산 -&gt; 돌면서 -&gt; . 이미 0으로 초기화해놓고 넣어놨어야한다. | map.put( 객체Key, map.get( 객체key )의 value + 1 ) | . { Arrays.stream(Rank.values()).forEach(rank -&gt; result.put(rank, 0)); } . result.put(rankPrize, result.getOrDefault(rankPrize, 0) + 1); . | 결과List(객체List)를 먼저 계산 -&gt; 돌면서 -&gt; . 미리 0 초기화 없이 알아서 직전value(없으면 0부터) 누적해주는 -&gt; map.merge( 객체key, 누적해넣을값, Integer.sum()으로 기존value와 누적방법 Bifunction ) | . result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after)) . final List&lt;Rank&gt; results = lottos.stream() .map(lotto -&gt; match(lotto, winningLotto)) .collect(Collectors.toList()); final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); results .forEach(rank -&gt; result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after))); . 결과값을 찍어보니 merge로 카운팅이 1개씩 잘 된다. | . | | EnumMap은 아니지만, 일급vs단일 –stream–&gt; 단일vs단일 결과값(객체key)을 뽑아낼 로직 + 카운팅을 동시에 해주는 일급.stream().collect(Collectors.groupingBy( 객체key를 뽑아낼 로직 , summingInt( value -&gt; 1) ) . 결과값List를 뽑는 로직 조차 일급.stream -&gt; 단일vs단일로 객체Key뽑기로직이 내부에 포함됨 . 결과값List를 미리 뽑지 않는다. -&gt; Collectors.groupingBy( , )의 **첫번째 인자에 ** | . // (1)결과값 List를 미리 뽑는 과정 -&gt; 생략됨. //final List&lt;Rank&gt; results = lottos.stream() // .map(lotto -&gt; match(lotto, winningLotto)) // .collect(Collectors.toList()); // (2) map을 미리 선언해두기 -&gt; 생략됨 //final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); // (3) 결과값List를 돌면서 -&gt; merge로 1씩 카운팅 -&gt; 생략됨 //results.stream() // .forEach(rank -&gt; result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after))); // 일급을 돌면서 -&gt; groupingBy(단일vs단일의 [결과값 = 객체key]를 뽑는 로직 , 1씩 누적합하는 로직) return lottos.stream() .collect(Collectors.groupingBy( lotto -&gt; match(lotto, winningLotto), Collectors.summingInt(value -&gt; 1))); . | 27 결과값을 모은 List를 카운팅하는 새로운 응답(자료구조)을 포장하는데 그 생성 과정을 생성자에 넣어서 시작부터 상태값으로 가지자 . 현재 상황 . public static Map&lt;Rank, Integer&gt; getResult(final List&lt;Lotto&gt; lottos, final WinningLotto winningLotto) { return lottos.stream() .collect(Collectors.groupingBy( lotto -&gt; match(lotto, winningLotto), Collectors.summingInt(value -&gt; 1))); } . | . 응답값 포장하기 . returntype 빨간줄 수정 -&gt; 생성 | 결과산출 로직은 포장결과값 생성자로 가져가되, new 포장결과( ) 로 생성되도록 재료추출은 있어야함. . . 대박) 메서드추출로 new 포장( , ) 생성자 or 결과class 정펙매 생성자 호출과 동시에 재료 추출하기 . . . 밖으로 나가서 아무거나 타자치면 invalid해도 완성된다. . . | . 새로운 응답값 을 시작부터 상태 관리되도록 생성자에서 처리해주고 초기화하도록 잘라내서 가져가기 . 기존에 추출된 새로운 응답값 자료구조 추출 로직을 -&gt; 결과값 포장클래스의 생성자로 가져간다. . . | 가져와서 파라미터 부분 + 내용부분만 잘 가져다 생성자로 만든다. . . | 서비스 정의된 에서 단일vs단일 메인 결과값match 로직을 서비스에서 -&gt; 결과 도메인인 여기로 가져오자 . . . . | 이제 생성자에서 뽑아진 result를 상태값으로 가지기 . . . public class LottoResult { private final Map&lt;Rank, Integer&gt; value; public LottoResult(final List&lt;Lotto&gt; lottos, final WinningLotto winningLotto) { final Map&lt;Rank, Integer&gt; value = lottos.stream() .collect(Collectors.groupingBy( lotto -&gt; match(lotto, winningLotto), Collectors.summingInt(count -&gt; 1))); this.value = value; } public static Rank match(final Lotto userLotto, final WinningLotto winningLotto) { final int matchCount = userLotto.match(winningLotto); final boolean matchBonus = userLotto.contains(winningLotto); return Rank.of(matchCount, matchBonus); } . | . | 새 결과값 포장이 끝났으면, Serivce 메서드 테스트 다시 해보기 . @Test void get_result() { //1. 메인로직(match)를 여러번 호출해서 결과값을 받을 Service.메서드 // -&gt; 메인로직에 필요한 파라미터(Lotto여러개 + WinningLotto)는 넘겨줘야한다. final List&lt;Lotto&gt; lottos = List.of( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1, 2, 3, 4, 5, 7), new Lotto(1, 2, 3, 4, 7, 8), new Lotto(1, 2, 3, 4, 7, 8), new Lotto(1, 2, 3, 4, 7, 8) ); final LottoResult result = LottoService.getResult(lottos, new WinningLotto( new Lotto(1, 2, 3, 4, 5, 7), new LottoNumber(6))); System.out.println(result); System.out.println(); } . . 28 결과값 포장Result class의 자체 테스트 . [새로운 응답값 생성로직]이 담긴 [생성자 자체 테스트] with [view에서 쓰일 수도 있는? 삭제될? Count getter(객체key)개발] . 결과값 Map을 만들 재료 중 일부만 setup에 준비한다. 여러 재료라면 가변쉬운것을 테스트에서 -&gt; 많고 복잡한 것을 setup에 고정 . class LottoResultTest { List&lt;Lotto&gt; lottos; @BeforeEach void setUp() { //new LottoResult(lottos, winningLotto); //새로운 응답값 생성(결과값 포장 클래스 생성자)에 필요한 재료 먼저 선언 // -&gt; case별 변동이 쉬운 winningLotto는 놔두고, lottos를 미리 만들어놓자. lottos = List.of( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1, 2, 3, 4, 5, 7), new Lotto(1, 2, 3, 4, 7, 8), new Lotto(1, 2, 3, 7, 8, 9) ); } . | count Map이라면, 맘 편하게 .getCount( 객체key )를 맘편하게 만들자 . 뷰에서 쓸 일 있으면 쓰고, 없으면 삭제하면 된다. default를 0으로 해서 count인 value값을 가져오자. . public Integer getCountByRank(final Rank rank) { return value.getOrDefault(rank, 0); } . | . | 해당 key의 Count를 꺼내와서 정확한지 확인하기 . 할수 있다면, debug 활용해서 내부값 까보면서 같이하면 될 듯. | . @Test void create() { //given -&gt; 1등이 1개 있도록 가정인자를 만들어줌 final LottoResult lottoResult = new LottoResult(lottos, new WinningLotto( new Lotto(1, 2, 3, 4, 5, 6), new LottoNumber(7) )); // map이 세고 있던 객체key를 넣어주고 -&gt; Count를 반환하는 메서드 개발 //when final Integer actual = lottoResult.getCountByRank(Rank.RANK_1); //then assertThat(actual).isEqualTo(1); } } . | 29 새응답 결과값(map)에 계산 로직 더하기 . Service에서 controller로 반환되므로 자체 ResultTest에서 시작 . ServiceTest가 아니라 ResultTest 추가 로직 메서드 개발 시작 | countMap 처리 deafult : value.entrySet() .stream() .map() . CountMap을 돌 때, 기본적인 으로 작성해서 돌아보자 . public void getPrize() { value.entrySet() .stream() .map() } . | map( -&gt; ) 로직에서 getter등장으로 보내야한다면 -&gt; 옆에 값도 같이 보내자. enum.getter * count(it.getValue()) -&gt; enum.메세제( it.getValue() ) . map안에서 enum.getXXX() * count숫자 를 계산해야하는데, getter대신 메세지보낼 때, 같이 보내버리자. . . | 없던 Enum필드도 this.필드명을 바로써서 빨간줄로 바로 생성 . 아직 상금필드를 enum에 정의 안해뒀다. this.필드명을 기입해서 빨간줄로 생성해버리자. . . . . . | ​ ​ . it.getKey()의 enum으로 메세지 보내도록 작성완료 | 누적한다면, matToInt( ) .sum() 일까? map().reduce( )일까? . map()으로 반환받은 int(stream&lt;Int&gt;)는 .sum()이 안된다. . | matToInt()로 반환받은 IntStream만 .sum()의 누적함수 적용된다. . . | . reduce의 불편함과 초기값장점 . mapToType - sum()이 아닌 경우 -&gt; map의 returnType에 따라 reduce(누적)에 type에 맞는 합(누적할연산자)메서드를 직접 넣어준다. . . | 직접 메서드와 초기값을 지정해주지만, stream이 비었어도 에러가 안나고 defaul값이 나온다. . . | . mapToType -&gt; .sum()의 편리함과 불편성(?-&gt; 없다) -&gt; 편한 것 쓰면 될듯 . mapToInt를 써서, .sum()할 stream이 없을 때에도 0이 default로 전달된다. . . | . 30 countMap에 NONE객체 존재 + orElse(NONE)가 있어야하는 이유 -&gt; 전체 갯수도 셀 수 있다. . 당첨못함 : 14명 / 1등: 1명 / 2등: 2명 -&gt; 총 17명의 갯수.. 만약 당첨 못했다고 안셌으면.. ㅠ_ㅜ 전체 로또 갯수를 셀 수 없게 된다. | . | . NONE(여기선 OUT)객체는 존재해야하며, 다른 것이 해당 없을 때도 반환되어야한다. . public enum Rank { RANK_1(2000_000_000, ((matchCount, matchBonus) -&gt; matchCount == 6)), RANK_2(30_000_000, (matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; matchBonus), RANK_3(1_500_000, (matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; !matchBonus), RANK_4(50_000, (matchCount, matchBonus) -&gt; matchCount == 4), RANK_5(5_000, (matchCount, matchBonus) -&gt; matchCount == 3), OUT(0, (matchCount, matchBonus) -&gt; matchCount &lt; 3), // 1. ; //... public static Rank of(final int matchCount, final boolean matchBonus) { return Arrays.stream(values()) .filter(it -&gt; it.condition.test(matchCount, matchBonus)) .findAny() .orElse(OUT); // 2. } . | 로또 전체 갯수를, NONE객체 포함한 COUNTMAP을 통해 구할 수 있다. . values()에 모든 로직이 counting 포함되어있따. . . public long getPrize() { final long totalPrize = value.entrySet() .stream() .mapToLong(it -&gt; it.getKey().getPrize(it.getValue())) .sum(); // 전체 로또 구매수를 countMap의 NONE까지 같이 센다. // -&gt; enum처럼 map도 둘다 values().stream 자동완성으로 돌 수 있다. final int purchasePrice = value.values().stream() .mapToInt(it -&gt; it) .sum() * 1000; return totalPrize; } . | . | long / int라도 둘자 정수니 한쪽에 (double)만 씌우면 된다. . // long vs int 든, int vs int든 나누기가 들어가면 한쪽에 (double)을 씌우자. return totalPrize / (double) purchasePrice; . public double getPrize() { final long totalPrize = value.entrySet() .stream() .mapToLong(it -&gt; it.getKey().getPrize(it.getValue())) .sum(); final int purchasePrice = value.values().stream() .mapToInt(it -&gt; it) .sum() * 1000; return totalPrize / (double) purchasePrice; } . | 31 나눗셈(하나 double)의 Test return되는 것과 같이 구성해버리기 . 0.0을 넣어도 되긴 하지만 당첨금(long) 0L / (double) 구입금액(int) 4000 으로 똑같이 줘서 구성하면 된다. | . @Test void name() { // create 테스트에 쓰던 것 그대로 활용 final LottoResult lottoResult = new LottoResult(lottos, new WinningLotto( new Lotto(11, 12, 13, 14, 15, 16), new LottoNumber(7) )); final double prize = lottoResult.getPrize(); //숫자 비교도 return되는 타입이랑 동일하게 expected주기 // -&gt; totalPrize / (double) purchasePrice; assertThat(prize).isEqualTo(0L / (double) 4000); } . 단위가 정해져 있는 것의 포장( LottoMoney ) . (1) 단위보다 작은지 검사 -&gt; (2) % 단위로 나눈 나머지 !=0 검사 . private static void validate(final int value) { if (value &lt; DIVIDE_UNIT) { throw new LottoMoneyLessException(value); } if (value % DIVIDE_UNIT != 0) { throw new LottoMoneyDivideException(value); } } . 32 대상의 필요성 확인후 포장 시작 . 메서드 실행시 정제된 input으로 money가 왔다고 가정했다. -&gt; 근데 실제로 필요한 건 money / 단위로 산출되는 횟수가 필요하다. . @Test void issue_lotto_by_money() { // new Money(3000) 예약 final List&lt;Lotto&gt; lottos = LottoService.issueByMoney(3000); // money.메세지() 보내서 횟수를 반환받아 그만큼 반복할 예정 assertThat(lottos.size()).isEqualTo(3000 / 1000); } . count도 뽑아내야한다. count도 결국엔 포장해야할 듯. | . public class LottoService { public static List&lt;Lotto&gt; issueByMoney(final int money) { // input으로 money -&gt; money에게 횟수로 치면 몇번이냐 물어볼 예정임. final int count = money / 1000; return LottoFactory.issueLottoByCount(count); } . | . Test에서 포장 시작( 정정: Money -&gt; LottoMoney ) . Test에서 빨간줄로 시작하며 생성하기 . public class Money { private final int money; public Money(final int money) { this.money = money; } } . | 참고) 포장으로 파라미터 달라지는 메테(포장-&gt;자동생성-&gt;끌올-&gt; 내용복붙후 새기준) vs case늘릴려고 복사해서 만드는 테메+메서드2(테매 복-&gt;case반영-&gt;메서드2복 -&gt;메서드2수정-&gt;메서드2통과-&gt; 메서드1대체하여 삭제) 등..은 서로 다른 것 . 생성한 예비 새 기준메서드를 기존메서드 위로 위치를 올린 뒤, 내용 복붙 -&gt; 포장한 것으로 처리되도록 -&gt; 기존메서드는 포장용으로 변경 . 메서드 파라미터를 바꾸는게 아니라, 메서드2로 생성하고 새 기준 메서드가 되도록 포장 파라미터로 처리되도록 한다. . 생성한 예비 새 기준메서드를 기존메서드위로 위치를 이동 | . . . . | ​ . 새메서드의 내용을 포장된 것으로 바꿀 때, 기존값.getter()로 대체해도 되지만 -&gt; 바로 [기존값으로 연산] -&gt; 포장.메서드() -&gt; 포장 내부에서 [this.값으로 연산]하도록 처리해야한다. . 기존메서드의 내용을 복붙해온 뒤 -&gt; 포장파라미터에 맞게 수정해준다. 필요시 getter를 처리했었는데를 연산이 바로 보이는 곳에서는 .메서드()로 처리 해줘도 된다. . . . | ​ . ​ . 기존메서드는 내부에서 파라미터포장+ 새기준 호출만 -&gt; 기존내용은 다 삭제 - &gt; 회색으로 안쓰인다면 버려도 됨. . . 기존메서드가 테스트 등에서도 안쓰이니 삭제 | . 줄어드는 횟수Count VO의 포장(정리용) . 33 count(VO, hasNext패턴 가진 것) 포장 . 미리 원시값도 줄어들 때 hasNext패턴을 만들어두었다. . 내 패턴으로는 0을 허용하면서 더 큰 n부터 줄어들되 0이 아닐때까지, 즉, 1까지도는 것이다. | . public static List&lt;Lotto&gt; issueLottoByCount(int count) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (count != 0) { count -= 1; lottos.add(LottoFactory.issueLotto()); } return lottos; } . 메서드에서부터 파라미터로 전해지도록 Count 포장 (포장은 테매 인자에서부터~ ) . 이름은 도메인Count로 만들어야한다. 포장하는 순간, 대명사가 아니다. . . | . 포장하기 . public class LottoCount { private final int value; public LottoCount(final int value) { this.value = value; } } . | VO는 equals/hC부터 . . count VO는 0까지는 허용해주도록 검증을 만든다. (for while문에서 0까지 간 뒤 0에서 탈출시킴) . public LottoCount(final int value) { if (value &lt; 0) { throw new IllegalArgumentException(&quot;0보다 작을 수 없습니다.&quot;); } this.value = value; } . 새기준메서드 새로 만들어, 기존메서드 위로 위치이동후, 내용복붙후, 처리 . . . . . 값자리에는 포장.getter()를 -&gt; 연산이 할만하면 바로 메세지를 . . . . 값의 연산 -&gt; 포장 안으로 잘라들고가서 this.값으로 연산 . getter지우고 메세지보내기 만약, 지우고 빨간메서드가 남아있다면 그대로 정의해도 된다. | 여기선 연산!=0이 남아있으니, 그에 맞는 의미있는 메서드를 지어준다. 0=Finish가 != 아직 Not이냐 | 남은 연산을 잘라내서 -&gt; 메서드만들고 -&gt; 내부에서 this.값으로 잘라낸 연산 처리 | . | 값의 재할당 -&gt; VO에서는 연산만 들고 들어가면서 메서드를 만들고, 포장 = 는 그대로 둔다. -&gt; 내부에서는this.값으로 연산한 뒤 =에 대해 새VO로 응답하는 [메세지]로 작성한다. . -= 1을 포장 처리하려면 . -1 을 내부로 들고 들어가서 this.값 -1으로 연산 | =은 새 VO를 반환 | . . . | = 놓아두고, -1만 들고 들어가면서, 연산과 관련된 메서드명으로 메세지를 보낸다. . . . . . | 연산을 들고들어갔더라도 바깥에서는 포장변수 = 이 새 VO응답을 기다리고 있으므로 내부연산 결과를 포장해서 응답해준다. . . . final을 풀어 재할당 가능하게 해준다. | . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(LottoFactory.issueLotto()); } return lottos; } . 포장전 기존메서드가 사용중이면 찾아가서, 수정해준다. . . . count가 사용중인데, 일단 money.getCount()의 반환값도 원시count으로 바꿔준다. . public int getCount() { return this.money / 1000; } . . public LottoCount getCount() { return new LottoCount(this.money / 1000); } . public static List&lt;Lotto&gt; issueByMoney(final Money money) { final LottoCount count = money.getCount(); return LottoFactory.issueLottoByCount(count); } . | . 새 기준메서드 완성시, 포장검증을 메서드로 퉁치는 테스트(-1이하에서 에러) . . 자체 도메인Test생성후 Count VO 검사 . 0까지 허용하여 음수 생성자 에러 | . @Test void create() { assertAll( () -&gt; { assertDoesNotThrow(() -&gt; new LottoCount(1)); assertDoesNotThrow(() -&gt; new LottoCount(0)); assertThatThrownBy(() -&gt; new LottoCount(-1)); } ); } . 1개 뽑 + 감소된 것 뽑 -&gt; 감소된 로직후 동일한지 비교 | . @Test void decrease() { final LottoCount lottoCount = new LottoCount(1); final LottoCount expected = new LottoCount(0); // 감소된 것 미리 뽑기 final LottoCount actual = lottoCount.decrease(); assertThat(actual).isEqualTo(expected); } . 랜덤구현 -&gt; 전략패턴으로 수동 더하기(정리용) . 34 [랜덤 최소단위 메서드]를 전략메서드로 바꿔 [수동]도 가능하게 하기 . 전략부위가 만약, 메서드화 안되어있으면(ex&gt;조건식) 메서드화 (추출 등) . 메서드명을 랜덤+수동다 포함하는 일반화 + 목적어 뺌(전략인페+구현전략들에 명시됨)된 전략메서드로 바꿔주기 | . 랜덤 최소단위 메서드 정의부 -&gt; 호출()부 찾기 . 랜덤 메서드 정의부 찾기 . | 랜덤 메서드의 호출부 찾기 . | ##### 랜덤 메서드 호출부에서 랜덤 메서드명을 -&gt; 수동포함하는 일반화된 전략메서드명() + 목적어 제거으로 변경 -&gt; 전략인페를 상속한 new 랜덤전략구현체 객체(). 전략메서드() 인척 빨간줄 생성해주기 . 일반화된 메서드명 상태에서 -&gt; 빨간줄로 외부주입된 랜덤전략구현체 객체 + 전략메서드()호출해준다. . 기존상태( 메서드명을 랜덤+수동다 포함하는 일반화된 + 목적어빠진 전략메서드명으로 바꿔주기) . . 전략메서드에 목적어 넣지마라 | . . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(issue()); } return lottos; } public static Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } . | . | 외부주입된 new 랜덤전략객체에서 호출한 전략메서드()인척 해서 빨간줄로 생성하기 . . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(new RandomLottoIssuer().issue()); } return lottos; } . . | 전략메서드도 작성 . | 랜덤전략객체.전략메서드()로 &lt;- [ 기존 랜덤 메서드 ]에 있던 랜덤 로직 옮겨주기 . public class RandomLottoIssuer { static final List&lt;LottoNumber&gt; LOTTO_NUMBERS; static { LOTTO_NUMBERS = IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(LottoNumber::getInstance) .collect(Collectors.toList()); } public static Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } } . 외부주입 전략객체를 -&gt; 외부파라미터로 받기 위해서 -&gt; 실제 전략인페 정의해주기 . 앞에서 정의한 랜덤전략객체를 보고 전략인페를 생성한다. . RandomLottoIssuer -&gt; LottoIssuer -&gt; 앞으로 xxxxLottoIssuer 등 . | 전략인페명으로 패키지를 만들어서 다같이 넣어주면 좋다. . . | . | 전략메서드명은 다 통일이다. 목적어없이 동사만 . issue() . | 특정전략메서드의 반환타입을 참고해서 추상메서드를 정의해준다. . 랜덤전략의 메서드 반환타입 보고 . | 정의부 복붙해와서 반환타입 + 메서드명빼고 다 달리기 . . . public interface LottoIssuer { Lotto issue(); } . | . | . | ​ . new 외부전략객체() 생성하던 곳으로 돌아가서 -&gt; 변수/파라미터는 추상체로 외부주입 받아, 추상체.전략메서드()하도록 한다. . 기존: 외부주입없이 + 구상체로 사용 . . public class LottoFactory { public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(new RandomLottoIssuer().issue()); } return lottos; } } . | 호출부 중 전략객체만 선택해서 파라미터로 추출 . 전략메서드를 제외한 전략객체만 선택해서 추출하면 된다. . | 추상체 이름과, 파라미터 Type모두 추상체로 바꿔준다. . . public class LottoFactory { public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount, final LottoIssuer lottoIssuer) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(lottoIssuer.issue()); } return lottos; } } . | 처음에는 내부에서 특정 전략객체를 만들어썻찌만 -&gt; 파라미터 추출하면 알아서 외부에서 주입된다 . 그 장소가 service라도 괜찮다. spring에서는 알아서 service에서 외부주입 받는다. . . public class LottoService { public static List&lt;Lotto&gt; issueByMoney(final Money money) { final LottoCount count = money.getCount(); return LottoFactory.issueLottoByCount(count, new RandomLottoIssuer()); } . | . 이제 전략인페를 impl 수동 구현만 -&gt; TDD에서 수동메서드 완성해보자. . 수동 전략impl 구현체를 생성한다. . . | 관련 테스트(LottoFactoryTest)로 가서, 해당메서드를 완성해야한다. . test에서 외부전략객체생성 후 전략메서드()호출해도 아무도일도 안일어날 것이다. . . | . | 미리 작성된 RandomLottoIssuer를 띄워놓고(tabmover -&gt; ctrl+alt+shift+D)로 참고하면서 내용을 채워나가면 된다. . . | ​ . ​ . ​ . ​ . ​ . 대박) 전략메서드 준비물을 [메서드() 인자]가 아닌 -&gt; 각 전략별 [전략객체 생성자/정펙매]에서 받아 준비해두자 . 랜덤로직을 랜덤전략객체에 옮기고 나니 랜덤에 필요한 것들이 생성자나 변수에서 처리되고 있었다. . 각 전략별 전략메서드 실행시 필요한 준비물은 각 전략객체 생성자/정펙매에서 파라미터로 받자 | . . public class RandomLottoIssuer implements LottoIssuer { static final List&lt;LottoNumber&gt; LOTTO_NUMBERS; static { LOTTO_NUMBERS = IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(LottoNumber::getInstance) .collect(Collectors.toList()); } public Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } } . | . 수동로또준비물은 수동 입력된 번호 List일 것이다. . . @Test void manual_issue() { // 전략들의 준비물은 전략메서드()에서는 따로따로 못받는다. -&gt; 전략객체 만들때 미리 준비되어있어야한다. //1. 수동로또전략의 준비물은 [1,2,3, 수동입력]이 있어야 -&gt; issue()로 [1,2,3, 수동로또]를 발급할 수 있을 것이다. // -&gt; input은 나중에 처리하고, 정제된rawInput을 생성자에서 받아주자. //final Lotto lotto = new ManualLottoIssuer().issue(); final Lotto lotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); } . 일단 가변인자로 받도록 만들어놨으니… 저렇게 처리했음. | . | 전략객체 생성시부터 준비물 -&gt; 변수에 받아준비해두자 . public class ManualLottoIssuer implements LottoIssuer { private final Integer[] value; public ManualLottoIssuer(final Integer... value) { this.value = value; } @Override public Lotto issue() { throw new UnsupportedOperationException(&quot;ManualLottoIssuer#issue not implemented.&quot;); } } . | 전략메서드에서 준비물을 사용해서 처리해주자. . public class ManualLottoIssuer implements LottoIssuer { private final Integer[] value; public ManualLottoIssuer(final Integer... value) { this.value = value; } @Override public Lotto issue() { //throw new UnsupportedOperationException(&quot;ManualLottoIssuer#issue not implemented.&quot;); //2. 전략객체가 생성시 받아둔 준비물을 가지고 전략메서드로 반환하자. return new Lotto(value); } } . | 가장 기본적인 일급테스트인 size + contains만 테스트 해줬다. . @Test void manual_issue() { final Lotto manualLotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); assertThat(manualLotto.getValue().size()).isEqualTo(6); } . @Test void contains() { final Lotto manualLotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); assertThat(manualLotto.getValue()).containsExactly( new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6) ); } . | 초대박) 테스트용 람다 전략은 전략객체 대신이 아니라 내부 전략메서호출()될 응답까지를 미리 주는 것 -&gt; 테스트에서 내부랜덤결과(전략메서드 응답type)을 외부 객체주입시 넣어줄 수 있다 . 전략객체를 주입받는 메서드(전략메서드 호출()부를 감싸는 메서드)에 new 전략객체를 입력해서 . 내부에서 서로다른 전략메서드() 호출 -&gt; 전략마다 다른 응답값을 사용하는 것이 기본 패턴인데 | . . . | 람다전략은 new전략객체 대신 ` () -&gt; 전략메소드의 응답(Lotto)`까지 한번에 주입한다. . 예시1: 전략객체가 들어가던 boolean응답 전략메소드의 전략객체 주입 . js.move(new RandomMoveConditionStrategy()); js.printPosition(); . public void move() { if(isMovable()){ this.position++; } } . 전략객체 대신 람다 () -&gt; boolean응답까지 미리 지정해서 전략자리에 대입 | . jk.move( () -&gt; true); jk.printPosition(); . | | 로또에 적용해보면, 2번째 인자로 전략객체를 받아 -&gt; 그에 맞는 전략메서드()내부 호출하는 issueLottoByCount( , ) . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount, final LottoIssuer lottoIssuer) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(lottoIssuer.issue()); } return lottos; } . | 여기에 2번째 인자에 테스트용 람다전략으로서 전략메서드 응답값을 포함한 람다전략을 대입하자 . @Test void lambda() { final List&lt;Lotto&gt; lottos = LottoFactory.issueLottoByCount( new LottoCount(1), () -&gt; new Lotto(1, 2, 3, 4, 5, 7)); // 외부 전략객체가 들어와야하는데, 람다(내부전략메소드 호출후 응답갑까지 미리)를 대입 assertDoesNotThrow(() -&gt; lottos.get(0).contains(new LottoNumber(7))); } . | 요약: [전략객체 ]자리에 내부.전략메서드()호출 끝난 응답값까지 구현하여 전달하는 람다전략 . 횟수만큼 자동 로또 생성 -&gt; 횟수를 수동+자동 나누어서 로또 생성 . 35 수동 로또를 input이 왔다고 치고, 나눠서 수동 + 자동 생성하기 . 포장이 끝난 상태라면, [메서드 파라미터 추가]는 정제된 input보다는 [포장]된 것으로 추가해주자. . 자동로또 만들어 주는 메서드에 수동로또를 파라미터에 추가하자 . 이 때, 정제된 input인 List.of(1,2,3,4)가 아니라 포장 끝났으니 실제 포장된 new Lotto()를 넣어주자. | . @Test void issue_with_money_and_manual() { // final List&lt;Lotto&gt; lottos = LottoService.issueByMoney(new Money(3000)); //1. 돈만 받아서, 알아서 횟수만큼 자동로또 -&gt; 돈 과 수동로또input을 같이 받도록 변경 // -&gt; 파라미터 다른 메서드를 만들고 -&gt; 그 다음 이름변경하자. (기존 코드 돌아가야되니 복붙개념으로 가야됨) // -&gt; 수동이 여러개일 수 있다 -&gt; 만약 리스트라면, 6개숫자리스트의 리스트가 들어올 것이다. // -&gt; **서비스 메서드에는 controller에서 도메인으로 이미 포장으로 변수를 받아놓고 호출되었을 것이다. // --&gt; 포장작업은 이미 끝내놨으니, 파라미터를 포장으로 받아도 된다. // --&gt; 서비스 메서드(메인로직)에서 이미 포장끝났다면 rawInput보다는 포장된 것을 파라미터로 던지자! // LottoService.issueByMoney(new Money(3000), List.of(1,2,3,4,5,6)); final List&lt;Lotto&gt; totalLotto = LottoService.issueByMoney(new Money(3000), List.of(new Lotto(1, 2, 3, 4, 5, 6))); . | 파라미터 변경하지말고, 메서드를 새로 생성 -&gt; 기존메서드위로 가져와서 내용복붙후 처리 . //2. 기존메서드 위로 올린 뒤, 내용 복붙해와서 처리해보자. public static List&lt;Lotto&gt; issueByMoney(final Money money, final List&lt;Lotto&gt; lottos) { //3. 자동을 돌릴 갯수가 돈/1000이 아니라 수동로또수만큼 빼야한다. //final LottoCount count = money.getCount(); final LottoCount totalCount = money.getCount(); //4. VO 증감 메서드는 항상 응답받을 준비를 한다. final LottoCount autoCount = totalCount.decrease(lottos.size()); //5. 기존에는 자동로또가 전체로또였다. 이;번엔 수동로또 + 자동로또 합쳐서 건네애햐한다. // return LottoFactory.issueLottoByCount(count, new RandomLottoIssuer()); //6. 수동로또는 파라미터로 넘어올 것이다. 자동만 갯수만큼 -&gt; 수동은 input에 의해 controller에서 생산 final List&lt;Lotto&gt; totalLottos = Stream.concat( lottos.stream(), LottoFactory.issueLottoByCount(autoCount, new RandomLottoIssuer()).stream() ).collect(Collectors.toList()); return totalLottos; } . 새 기준 메더드 완성시, 기존메서드 사용처확인해서 삭제 -&gt; 메서드 이름 변경 . //포장된 로또 리스트를 받도록 수정했는데, // 받기전 기존메서드에 빈 list를 넣어서 돌아가는지 확인되면 //-&gt; 기존 메서드 삭제 final List&lt;Lotto&gt; lottos = LottoService.issueByMoney(new Money(3000), Collections.emptyList()); . //기존메서드 잘 삭제되면, 메서드 이름변경 public static List&lt;Lotto&gt; issueByMoneyAndManualLotto(final Money money, final List&lt;Lotto&gt; lottos) { final LottoCount totalCount = money.getCount(); final LottoCount autoCount = totalCount.decrease(lottos.size()); final List&lt;Lotto&gt; totalLottos = Stream.concat( lottos.stream(), LottoFactory.issueLottoByCount(autoCount, new RandomLottoIssuer()).stream() ).collect(Collectors.toList()); return totalLottos; } . 생성된 전체로또가 수동로또 포함하는지 테스트 하기 . @Test void issue_with_money_and_manual() { final List&lt;Lotto&gt; totalLotto = LottoService.issueByMoneyAndManualLotto(new Money(3000), List.of(new Lotto(1, 2, 3, 4, 5, 6))); assertThat(totalLotto.size()).isEqualTo(3); assertThat(totalLotto).contains(new Lotto(1, 2, 3, 4, 5, 6)); } .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%BA%90%EC%8A%81/factory/%EC%A0%84%EB%9E%B5/tdd/%EA%B0%95%EC%9D%98/2022/03/14/TDD-6-%EB%A1%9C%EB%98%90(%EC%BA%90%EC%8A%81,Factory,%EC%88%98%EB%8F%99%EC%B6%94%EA%B0%80%EB%A7%88%EB%AC%B4%EB%A6%AC).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%BA%90%EC%8A%81/factory/%EC%A0%84%EB%9E%B5/tdd/%EA%B0%95%EC%9D%98/2022/03/14/TDD-6-%EB%A1%9C%EB%98%90(%EC%BA%90%EC%8A%81,Factory,%EC%88%98%EB%8F%99%EC%B6%94%EA%B0%80%EB%A7%88%EB%AC%B4%EB%A6%AC).html",
            "date": " • Mar 14, 2022"
        }
        
    
  
    
        ,"post112": {
            "title": "전략패턴 2(자동로또->수동)",
            "content": "전략 패턴 적용하기 . [랜덤 최소단위 메서드]를 전략메서드로 바꿔 [수동]도 가능하게 하기 . 전략부위가 만약, 메서드화 안되어있으면(ex&gt;조건식) 메서드화 (추출 등) . 메서드명을 랜덤+수동다 포함하는 일반화 + 목적어 뺌(전략인페+구현전략들에 명시됨)된 전략메서드로 바꿔주기 | . 랜덤 최소단위 메서드 정의부 -&gt; 호출()부 찾기 . 랜덤 메서드 정의부 찾기 . | 랜덤 메서드의 호출부 찾기 . | ##### 랜덤 메서드 호출부에서 랜덤 메서드명을 -&gt; 수동포함하는 일반화된 전략메서드명() + 목적어 제거으로 변경 -&gt; 전략인페를 상속한 new 랜덤전략구현체 객체(). 전략메서드() 인척 빨간줄 생성해주기 . 일반화된 메서드명 상태에서 -&gt; 빨간줄로 외부주입된 랜덤전략구현체 객체 + 전략메서드()호출해준다. . 기존상태( 메서드명을 랜덤+수동다 포함하는 일반화된 + 목적어빠진 전략메서드명으로 바꿔주기) . . 전략메서드에 목적어 넣지마라 | . . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(issue()); } return lottos; } public static Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } . | . | 외부주입된 new 랜덤전략객체에서 호출한 전략메서드()인척 해서 빨간줄로 생성하기 . . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(new RandomLottoIssuer().issue()); } return lottos; } . . | 전략메서드도 작성 . | 랜덤전략객체.전략메서드()로 &lt;- [ 기존 랜덤 메서드 ]에 있던 랜덤 로직 옮겨주기 . public class RandomLottoIssuer { static final List&lt;LottoNumber&gt; LOTTO_NUMBERS; static { LOTTO_NUMBERS = IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(LottoNumber::getInstance) .collect(Collectors.toList()); } public static Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } } . 외부주입 전략객체를 -&gt; 외부파라미터로 받기 위해서 -&gt; 실제 전략인페 정의해주기 . 앞에서 정의한 랜덤전략객체를 보고 전략인페를 생성한다. . RandomLottoIssuer -&gt; LottoIssuer -&gt; 앞으로 xxxxLottoIssuer 등 . | 전략인페명으로 패키지를 만들어서 다같이 넣어주면 좋다. . . | . | 전략메서드명은 다 통일이다. 목적어없이 동사만 . issue() . | 특정전략메서드의 반환타입을 참고해서 추상메서드를 정의해준다. . 랜덤전략의 메서드 반환타입 보고 . | 정의부 복붙해와서 반환타입 + 메서드명빼고 다 달리기 . . . public interface LottoIssuer { Lotto issue(); } . | . | . | ​ . new 외부전략객체() 생성하던 곳으로 돌아가서 -&gt; 변수/파라미터는 추상체로 외부주입 받아, 추상체.전략메서드()하도록 한다. . 기존: 외부주입없이 + 구상체로 사용 . . public class LottoFactory { public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(new RandomLottoIssuer().issue()); } return lottos; } } . | 호출부 중 전략객체만 선택해서 파라미터로 추출 . 전략메서드를 제외한 전략객체만 선택해서 추출하면 된다. . | 추상체 이름과, 파라미터 Type모두 추상체로 바꿔준다. . . public class LottoFactory { public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount, final LottoIssuer lottoIssuer) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(lottoIssuer.issue()); } return lottos; } } . | 처음에는 내부에서 특정 전략객체를 만들어썻찌만 -&gt; 파라미터 추출하면 알아서 외부에서 주입된다 . 그 장소가 service라도 괜찮다. spring에서는 알아서 service에서 외부주입 받는다. . . public class LottoService { public static List&lt;Lotto&gt; issueByMoney(final Money money) { final LottoCount count = money.getCount(); return LottoFactory.issueLottoByCount(count, new RandomLottoIssuer()); } . | . 이제 전략인페를 impl 수동 구현만 -&gt; TDD에서 수동메서드 완성해보자. . 수동 전략impl 구현체를 생성한다. . . | 관련 테스트(LottoFactoryTest)로 가서, 해당메서드를 완성해야한다. . test에서 외부전략객체생성 후 전략메서드()호출해도 아무도일도 안일어날 것이다. . . | . | 미리 작성된 RandomLottoIssuer를 띄워놓고(tabmover -&gt; ctrl+alt+shift+D)로 참고하면서 내용을 채워나가면 된다. . . | ​ . ​ . ​ . ​ . ​ . 대박) 전략메서드 준비물을 [메서드() 인자]가 아닌 -&gt; 각 전략별 [전략객체 생성자/정펙매]에서 받아 준비해두자 . 랜덤로직을 랜덤전략객체에 옮기고 나니 랜덤에 필요한 것들이 생성자나 변수에서 처리되고 있었다. . 각 전략별 전략메서드 실행시 필요한 준비물은 각 전략객체 생성자/정펙매에서 파라미터로 받자 | . . public class RandomLottoIssuer implements LottoIssuer { static final List&lt;LottoNumber&gt; LOTTO_NUMBERS; static { LOTTO_NUMBERS = IntStream.rangeClosed(LottoNumber.MIN, LottoNumber.MAX) .mapToObj(LottoNumber::getInstance) .collect(Collectors.toList()); } public Lotto issue() { Collections.shuffle(LOTTO_NUMBERS); return new Lotto(LOTTO_NUMBERS.stream() .limit(6) .sorted() .collect(Collectors.toList())); } } . | . 수동로또준비물은 수동 입력된 번호 List일 것이다. . . @Test void manual_issue() { // 전략들의 준비물은 전략메서드()에서는 따로따로 못받는다. -&gt; 전략객체 만들때 미리 준비되어있어야한다. //1. 수동로또전략의 준비물은 [1,2,3, 수동입력]이 있어야 -&gt; issue()로 [1,2,3, 수동로또]를 발급할 수 있을 것이다. // -&gt; input은 나중에 처리하고, 정제된rawInput을 생성자에서 받아주자. //final Lotto lotto = new ManualLottoIssuer().issue(); final Lotto lotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); } . 일단 가변인자로 받도록 만들어놨으니… 저렇게 처리했음. | . | 전략객체 생성시부터 준비물 -&gt; 변수에 받아준비해두자 . public class ManualLottoIssuer implements LottoIssuer { private final Integer[] value; public ManualLottoIssuer(final Integer... value) { this.value = value; } @Override public Lotto issue() { throw new UnsupportedOperationException(&quot;ManualLottoIssuer#issue not implemented.&quot;); } } . | 전략메서드에서 준비물을 사용해서 처리해주자. . public class ManualLottoIssuer implements LottoIssuer { private final Integer[] value; public ManualLottoIssuer(final Integer... value) { this.value = value; } @Override public Lotto issue() { //throw new UnsupportedOperationException(&quot;ManualLottoIssuer#issue not implemented.&quot;); //2. 전략객체가 생성시 받아둔 준비물을 가지고 전략메서드로 반환하자. return new Lotto(value); } } . | 가장 기본적인 일급테스트인 size + contains만 테스트 해줬다. . @Test void manual_issue() { final Lotto manualLotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); assertThat(manualLotto.getValue().size()).isEqualTo(6); } . @Test void contains() { final Lotto manualLotto = new ManualLottoIssuer(1, 2, 3, 4, 5, 6).issue(); assertThat(manualLotto.getValue()).containsExactly( new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6) ); } . | 초대박) 테스트용 람다 전략은 전략객체 대신이 아니라 내부 전략메서호출()될 응답까지를 미리 주는 것 -&gt; 테스트에서 내부랜덤결과(전략메서드 응답type)을 외부 객체주입시 넣어줄 수 있다 . 전략객체를 주입받는 메서드(전략메서드 호출()부를 감싸는 메서드)에 new 전략객체를 입력해서 . 내부에서 서로다른 전략메서드() 호출 -&gt; 전략마다 다른 응답값을 사용하는 것이 기본 패턴인데 | . . . | 람다전략은 new전략객체 대신 ` () -&gt; 전략메소드의 응답(Lotto)`까지 한번에 주입한다. . 예시1: 전략객체가 들어가던 boolean응답 전략메소드의 전략객체 주입 . js.move(new RandomMoveConditionStrategy()); js.printPosition(); . public void move() { if(isMovable()){ this.position++; } } . 전략객체 대신 람다 () -&gt; boolean응답까지 미리 지정해서 전략자리에 대입 | . jk.move( () -&gt; true); jk.printPosition(); . | | 로또에 적용해보면, 2번째 인자로 전략객체를 받아 -&gt; 그에 맞는 전략메서드()내부 호출하는 issueLottoByCount( , ) . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount, final LottoIssuer lottoIssuer) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(lottoIssuer.issue()); } return lottos; } . | 여기에 2번째 인자에 테스트용 람다전략으로서 전략메서드 응답값을 포함한 람다전략을 대입하자 . @Test void lambda() { final List&lt;Lotto&gt; lottos = LottoFactory.issueLottoByCount( new LottoCount(1), () -&gt; new Lotto(1, 2, 3, 4, 5, 7)); // 외부 전략객체가 들어와야하는데, 람다(내부전략메소드 호출후 응답갑까지 미리)를 대입 assertDoesNotThrow(() -&gt; lottos.get(0).contains(new LottoNumber(7))); } . | 요약: [전략객체 ]자리에 내부.전략메서드()호출 끝난 응답값까지 구현하여 전달하는 람다전략 .",
            "url": "blog.chojaeseong.com/java/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/13/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B42-%EC%A0%81%EC%9A%A9(%EC%88%98%EB%8F%99%EB%A1%9C%EB%98%90).html",
            "relUrl": "/java/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/13/%EC%A0%84%EB%9E%B5%ED%8C%A8%ED%84%B42-%EC%A0%81%EC%9A%A9(%EC%88%98%EB%8F%99%EB%A1%9C%EB%98%90).html",
            "date": " • Mar 13, 2022"
        }
        
    
  
    
        ,"post113": {
            "title": "Count VO 포장 과정(로또)",
            "content": "Count VO 포장 . 줄어드는 횟수Count VO의 포장 . 미리 원시값도 줄어들 때 hasNext패턴을 만들어두었다. . 내 패턴으로는 0을 허용하면서 더 큰 n부터 줄어들되 0이 아닐때까지, 즉, 1까지도는 것이다. | . public static List&lt;Lotto&gt; issueLottoByCount(int count) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (count != 0) { count -= 1; lottos.add(LottoFactory.issueLotto()); } return lottos; } . 메서드에서부터 파라미터로 전해지도록 Count 포장 (포장은 테매 인자에서부터~ ) . 이름은 도메인Count로 만들어야한다. 포장하는 순간, 대명사가 아니다. . . | . 포장하기 . public class LottoCount { private final int value; public LottoCount(final int value) { this.value = value; } } . | VO는 equals/hC부터 . . count VO는 0까지는 허용해주도록 검증을 만든다. (for while문에서 0까지 간 뒤 0에서 탈출시킴) . public LottoCount(final int value) { if (value &lt; 0) { throw new IllegalArgumentException(&quot;0보다 작을 수 없습니다.&quot;); } this.value = value; } . 새기준메서드 새로 만들어, 기존메서드 위로 위치이동후, 내용복붙후, 처리 . . . . . 값자리에는 포장.getter()를 -&gt; 연산이 할만하면 바로 메세지를 . . . . 값의 연산 -&gt; 포장 안으로 잘라들고가서 this.값으로 연산 . getter지우고 메세지보내기 만약, 지우고 빨간메서드가 남아있다면 그대로 정의해도 된다. | 여기선 연산!=0이 남아있으니, 그에 맞는 의미있는 메서드를 지어준다. 0=Finish가 != 아직 Not이냐 | 남은 연산을 잘라내서 -&gt; 메서드만들고 -&gt; 내부에서 this.값으로 잘라낸 연산 처리 | . | 값의 재할당 -&gt; VO에서는 연산만 들고 들어가면서 메서드를 만들고, 포장 = 는 그대로 둔다. -&gt; 내부에서는this.값으로 연산한 뒤 =에 대해 새VO로 응답하는 [메세지]로 작성한다. . -= 1을 포장 처리하려면 . -1 을 내부로 들고 들어가서 this.값 -1으로 연산 | =은 새 VO를 반환 | . . . | = 놓아두고, -1만 들고 들어가면서, 연산과 관련된 메서드명으로 메세지를 보낸다. . . . . | 연산을 들고들어갔더라도 바깥에서는 포장변수 = 이 새 VO응답을 기다리고 있으므로 내부연산 결과를 포장해서 응답해준다. . . . final을 풀어 재할당 가능하게 해준다. | . public static List&lt;Lotto&gt; issueLottoByCount(LottoCount lottoCount) { final List&lt;Lotto&gt; lottos = new ArrayList&lt;&gt;(); while (lottoCount.isNotFinish()) { lottoCount = lottoCount.decrease(); lottos.add(LottoFactory.issueLotto()); } return lottos; } . 포장전 기존메서드가 사용중이면 찾아가서, 수정해준다. . . . count가 사용중인데, 일단 money.getCount()의 반환값도 원시count으로 바꿔준다. . public int getCount() { return this.money / 1000; } . . public LottoCount getCount() { return new LottoCount(this.money / 1000); } . public static List&lt;Lotto&gt; issueByMoney(final Money money) { final LottoCount count = money.getCount(); return LottoFactory.issueLottoByCount(count); } . | . 새 기준메서드 완성시, 포장검증을 메서드로 퉁치는 테스트(-1이하에서 에러) . . 자체 도메인Test생성후 Count VO 검사 . 0까지 허용하여 음수 생성자 에러 | . @Test void create() { assertAll( () -&gt; { assertDoesNotThrow(() -&gt; new LottoCount(1)); assertDoesNotThrow(() -&gt; new LottoCount(0)); assertThatThrownBy(() -&gt; new LottoCount(-1)); } ); } . 1개 뽑 + 감소된 것 뽑 -&gt; 감소된 로직후 동일한지 비교 | . @Test void decrease() { final LottoCount lottoCount = new LottoCount(1); final LottoCount expected = new LottoCount(0); // 감소된 것 미리 뽑기 final LottoCount actual = lottoCount.decrease(); assertThat(actual).isEqualTo(expected); } .",
            "url": "blog.chojaeseong.com/java/vo/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/12/Count-VO-%ED%8F%AC%EC%9E%A5.html",
            "relUrl": "/java/vo/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/12/Count-VO-%ED%8F%AC%EC%9E%A5.html",
            "date": " • Mar 12, 2022"
        }
        
    
  
    
        ,"post114": {
            "title": "EnumMap으로 카운팅(로또결과)",
            "content": "EnumMap . Enum List -&gt; EnumMap에 카운팅 . List&lt;객체&gt;의 갯수를 객체를 key로 하는 hashMap Map&lt;객체, Integer&gt; 에 세야한다. | . 빈 Map 선언 및 초기화 . 객체의 Count을 원한다면 **&lt;객체key, Integer&gt;로 Map을 선언한다. ** (cf) 원시적으로는 직접 0으로 초기화 한다.) . EnumMap이라면 ( )생성자에 안에 Enum클래스.class(클래스 자체)를 지정해준다. | . final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); . 참고) . (원시적) 모든 객체key들 stream화해서 돌면서 -&gt; forEach -&gt; map.put(객체key, 0)으로 초기화해준다. . private final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); { Arrays.stream(Rank.values()).forEach(rank -&gt; result.put(rank, 0)); } . | . | EnumMap는 넣고난 뒤, 자동정렬되어있지만 . 일반map넣고 난 뒤, key순으로 정렬되어야하면(순서가 중요하면) hashMap대신 -&gt; linkedHashMap을 사용한다. | . private final LinkedHashMap&lt;Rank, Integer&gt; value = new LinkedHashMap&lt;&gt;(); . | . | 일급vs단일 로직을 먼저 수행한 -&gt; 응답결과List를 카운팅하는 3가지 방법 . 이제 갯수를 셀 결과값List(Enum List or 객체 List)들을 돌면서 카운팅한다. . 결과List(객체List)를 먼저 계산 -&gt; 돌면서 -&gt; . 이미 0으로 초기화해놓고 넣어놨어야한다. | map.put( 객체Key, map.get( 객체key )의 value + 1 ) | . { Arrays.stream(Rank.values()).forEach(rank -&gt; result.put(rank, 0)); } . result.put(rankPrize, result.getOrDefault(rankPrize, 0) + 1); . | 결과List(객체List)를 먼저 계산 -&gt; 돌면서 -&gt; . 미리 0 초기화 없이 알아서 직전value(없으면 0부터) 누적해주는 -&gt; map.merge( 객체key, 누적해넣을값, Integer.sum()으로 기존value와 누적방법 Bifunction ) | . result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after)) . final List&lt;Rank&gt; results = lottos.stream() .map(lotto -&gt; match(lotto, winningLotto)) .collect(Collectors.toList()); final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); results .forEach(rank -&gt; result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after))); . 결과값을 찍어보니 merge로 카운팅이 1개씩 잘 된다. | . | | EnumMap은 아니지만, 일급vs단일 –stream–&gt; 단일vs단일 결과값(객체key)을 뽑아낼 로직 + 카운팅을 동시에 해주는 일급.stream().collect(Collectors.groupingBy( 객체key를 뽑아낼 로직 , summingInt( value -&gt; 1) ) . 결과값List를 뽑는 로직 조차 일급.stream -&gt; 단일vs단일로 객체Key뽑기로직이 내부에 포함됨 . 결과값List를 미리 뽑지 않는다. -&gt; Collectors.groupingBy( , )의 **첫번째 인자에 ** | . // (1)결과값 List를 미리 뽑는 과정 -&gt; 생략됨. //final List&lt;Rank&gt; results = lottos.stream() // .map(lotto -&gt; match(lotto, winningLotto)) // .collect(Collectors.toList()); // (2) map을 미리 선언해두기 -&gt; 생략됨 //final EnumMap&lt;Rank, Integer&gt; result = new EnumMap&lt;&gt;(Rank.class); // (3) 결과값List를 돌면서 -&gt; merge로 1씩 카운팅 -&gt; 생략됨 //results.stream() // .forEach(rank -&gt; result.merge(rank, 1, (before, after) -&gt; Integer.sum(before, after))); // 일급을 돌면서 -&gt; groupingBy(단일vs단일의 [결과값 = 객체key]를 뽑는 로직 , 1씩 누적합하는 로직) return lottos.stream() .collect(Collectors.groupingBy( lotto -&gt; match(lotto, winningLotto), Collectors.summingInt(value -&gt; 1))); . | groupingBy의 가운데 인자에 EnumMap.class를 줄 수 있다. . final EnumMap&lt;GameResult, Integer&gt; dealerResult = gamblers.stream() .collect(Collectors.groupingBy( gambler -&gt; getResultPlayer(dealer, gamblerResult, gambler), () -&gt; new EnumMap&lt;&gt;(GameResult.class), // Map타입 가운데서 지정 Collectors.summingInt(count -&gt; 1) )); .",
            "url": "blog.chojaeseong.com/java/enummap/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/11/EnumMap.html",
            "relUrl": "/java/enummap/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/11/EnumMap.html",
            "date": " • Mar 11, 2022"
        }
        
    
  
    
        ,"post115": {
            "title": "데분방01) Basics and R environment",
            "content": "강의주소:https://lms.knou.ac.kr/dks/user/home/initUSTHomeIndex_GRSC.do?stLeftMenuId=0 | 선배블로그: https://insb.tistory.com/9?category=967351 작년 김성수 교수 강의로 진행 | . | . &#44592;&#48376; . R &#49548;&#44060; . 무료 | 대화형 프로그램 언어 | 객체지향 시스템 데이터, 변수, 행렬 등은 모두 객체 | 생성은 = or &lt;-로 생성 | . | . . x = 2:10 x . &lt;ol class=list-inline&gt; 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | &lt;/ol&gt; y &lt;- 3*x + 5 y . &lt;ol class=list-inline&gt; 11 | 14 | 17 | 20 | 23 | 26 | 29 | 32 | 35 | &lt;/ol&gt; a &lt;- 3:9 b &lt;- 3*a + 5 plot(a, b) . plot(a, b, pch=18) . R&#51032; &#50669;&#49324; . . 1980년대 S 언어 탄생 by AT&amp;T Bell Lab(c언어 개발한 연구소)에서 통계언어 S를 구현함 . 1998 ACM S/W 상을 John Chambers가 탐 &quot;Forever altered how people analyze, visualize and manipulate data 사람들이 어떻게 데이터 분석, 시각화, 다루는지를 영원히 바꾼 언어다 | . | . | 오클란드 대학의 Ross and Robert 교수 2명이 S 축소버전인 R &amp; R을 만듦 . | 1995년 Martin Maechler(마틴 매흘러)가 R&amp;R(이하카, 젠틀만)을 설득하여, linux처럼 오픈소스(GPL)로 쓰게 한 것인 R source code 발표 . | 1997년 8월 R core team 결성. 2000년 02월 29일 R version 1.0.0 발표 . 12월 R version 3.2.3 | | . | R &#45796;&#50868;&#48155;&#44592; . . base버전으로 다운 받기 | . &#51089;&#50629;&#50689;&#50669; &#51648;&#51221; . . getwd() . &#39;C:/Users/cho_desktop/2022_RProjects/대학원/1-01 데이터분석방법론 1&#39; setwd(&quot;.&quot;) . setwd( choose.dir() ) . Error in setwd(choose.dir()): missing value is invalid Traceback: 1. setwd(choose.dir()) . R studio &#49548;&#44060; . rsutdio.com | . R Commander &#49548;&#44060; . 메뉴 방식으로 처리된 R 패키지/ John fox가 개발 | . . &#44368;&#51116; . First step . install.packages(&quot;ISwR&quot;) . package &#39;ISwR&#39; successfully unpacked and MD5 sums checked The downloaded binary packages are in C: Users cho_desktop AppData Local Temp Rtmpo5uUeT downloaded_packages . library(ISwR) . Warning message: &#34;package &#39;ISwR&#39; was built under R version 3.6.3&#34; . plot( rnorm(1000), pch = 19) . 1.1.3 &#48289;&#53552;&#50672;&#49328; . weight &lt;- c(60, 72, 57, 90, 95, 72) height &lt;- c(1.75, 1.80, 1.65, 1.90, 1.74, 1.91) bmi &lt;- weight/height^2 . bmi . &lt;ol class=list-inline&gt; 19.5918367346939 | 22.2222222222222 | 20.9366391184573 | 24.9307479224377 | 31.3779891663364 | 19.7363010882377 | &lt;/ol&gt; . # 벡터c의 갯수 -&gt; length( ) xbar &lt;- sum(weight) / length(weight) xbar . 74.3333333333333 mean(weight) . 74.3333333333333 sqrt(sum((weight-xbar)^2) / (length(weight) - 1)) . 15.4229266569827 sd(weight) . 15.4229266569827 1.1.4 standard procedures . bmi . &lt;ol class=list-inline&gt; 19.5918367346939 | 22.2222222222222 | 20.9366391184573 | 24.9307479224377 | 31.3779891663364 | 19.7363010882377 | &lt;/ol&gt; t.test(bmi, mu=22.5) # H0: mu=22.5 / H1: mu!=22.5 # t값 , 자유도, p값 . One Sample t-test data: bmi t = 0.34488, df = 5, p-value = 0.7442 alternative hypothesis: true mean is not equal to 22.5 95 percent confidence interval: 18.41734 27.84791 sample estimates: mean of x 23.13262 . 1.1.5 Graph . . # color=&quot;대or소문자&quot; 대신 col=2번호를 줘도 된다. like pch=숫자 plot(height, weight, pch=2, col=&quot;RED&quot;) . # c벡터객체 1개 만들고 hh &lt;- c(1.65, 1.70, 1.75, 1.80, 1.85, 1.90) # lines로 선 그리기 lines(hh, 22.5*hh^2, col=&quot;BLUE&quot;, lty=2) # lty = line type -&gt; 2번은 점점점 타입 . Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet Traceback: 1. lines(hh, 22.5 * hh^2, col = &#34;BLUE&#34;, lty = 2) 2. lines.default(hh, 22.5 * hh^2, col = &#34;BLUE&#34;, lty = 2) 3. plot.xy(xy.coords(x, y), type = type, ...) . plot(height, weight, pch=2, col=&quot;RED&quot;) hh &lt;- c(1.65, 1.70, 1.75, 1.80, 1.85, 1.90) lines(hh, 22.5*hh^2, col=&quot;BLUE&quot;, lty=2) . 1.2 R languange essentials . # - 작따-&gt;큰따로 변환되서 표기된다. # - 여기선 큰따-&gt; 작따로 표기되네..like python c(&quot;Huey&quot;, &quot;Dewey&quot;, &quot;Louie&quot;) . &lt;ol class=list-inline&gt; &#39;Huey&#39; | &#39;Dewey&#39; | &#39;Louie&#39; | &lt;/ol&gt; c(&#39;Huey&#39;, &#39;Dewey&#39;, &#39;Louie&#39;) . &lt;ol class=list-inline&gt; &#39;Huey&#39; | &#39;Dewey&#39; | &#39;Louie&#39; | &lt;/ol&gt; c(T, T, F, T) . &lt;ol class=list-inline&gt; TRUE | TRUE | FALSE | TRUE | &lt;/ol&gt; bmi . &lt;ol class=list-inline&gt; 19.5918367346939 | 22.2222222222222 | 20.9366391184573 | 24.9307479224377 | 31.3779891663364 | 19.7363010882377 | &lt;/ol&gt; # 벡터 + 조건식 -&gt; 마스크가 된다. bmi &gt; 25 . &lt;ol class=list-inline&gt; FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | &lt;/ol&gt; cat( c(&quot;Huey&quot;, &quot;Dewey&quot;, &quot;Louie&quot;) ) . Huey Dewey Louie . cat( c(&quot;Huey&quot;, &quot;Dewey&quot;, &quot;Louie&quot;, &quot; n&quot;) ) . Huey Dewey Louie . . cat(&quot;What is &quot;R &quot;? n&quot;) . What is &#34;R&#34;? . &#50696;&#51228; &#52280;&#44256;&#51088;&#47308; &#49324;&#51060;&#53944; . 예제 파일을 들고 있는 블로그: https://booolean.tistory.com/913?category=807312 | . 1.2.5 Missing Value . R에서는 결측치를 NA로 표시한다. | . . wd &lt;- read.table(&quot;./data//01/wd.txt&quot;, sep = &quot; t&quot;, header=T) # &quot;./따옴표경로&quot; , sep=&quot;구분자&quot; , header=T (첫줄이 타이틀) wd . M1M2M3M4M5Y . 0.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 0.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 0.606 | 0.1273 | 0.494 | 0.522 | 0.920 | 0.570 | . 0.437 | 0.1591 | 0.446 | 0.423 | 0.992 | 0.450 | . 0.547 | 0.1135 | 0.531 | 0.519 | 0.915 | 0.548 | . 0.444 | 0.1628 | 0.429 | 0.411 | 0.984 | 0.431 | . 0.489 | 0.1231 | 0.562 | 0.455 | 0.824 | 0.401 | . 0.536 | 0.1473 | 0.410 | 0.430 | 0.978 | 0.423 | . 0.413 | 0.1182 | 0.592 | 0.464 | 0.854 | 0.475 | . 0.685 | 0.1564 | 0.631 | 0.564 | 0.914 | 0.486 | . 0.664 | 0.1588 | 0.506 | 0.481 | 0.867 | 0.554 | . 0.703 | 0.1335 | 0.519 | 0.484 | 0.812 | 0.519 | . 0.653 | 0.1395 | 0.625 | 0.519 | 0.892 | 0.492 | . 0.586 | 0.1114 | 0.505 | 0.565 | 0.889 | 0.517 | . 0.534 | 0.1143 | 0.521 | 0.571 | 0.889 | 0.502 | . 0.523 | 0.1320 | 0.508 | 0.412 | 0.919 | 0.508 | . 0.580 | 0.1249 | 0.546 | 0.608 | 0.954 | 0.520 | . 0.448 | 0.1028 | 0.522 | 0.534 | 0.918 | 0.506 | . 0.417 | 0.1684 | 0.405 | 0.415 | 0.981 | 0.401 | . 0.528 | 0.1057 | 0.424 | 0.566 | 0.909 | 0.568 | . nwd = wd nwd . M1M2M3M4M5Y . 0.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 0.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 0.606 | 0.1273 | 0.494 | 0.522 | 0.920 | 0.570 | . 0.437 | 0.1591 | 0.446 | 0.423 | 0.992 | 0.450 | . 0.547 | 0.1135 | 0.531 | 0.519 | 0.915 | 0.548 | . 0.444 | 0.1628 | 0.429 | 0.411 | 0.984 | 0.431 | . 0.489 | 0.1231 | 0.562 | 0.455 | 0.824 | 0.401 | . 0.536 | 0.1473 | 0.410 | 0.430 | 0.978 | 0.423 | . 0.413 | 0.1182 | 0.592 | 0.464 | 0.854 | 0.475 | . 0.685 | 0.1564 | 0.631 | 0.564 | 0.914 | 0.486 | . 0.664 | 0.1588 | 0.506 | 0.481 | 0.867 | 0.554 | . 0.703 | 0.1335 | 0.519 | 0.484 | 0.812 | 0.519 | . 0.653 | 0.1395 | 0.625 | 0.519 | 0.892 | 0.492 | . 0.586 | 0.1114 | 0.505 | 0.565 | 0.889 | 0.517 | . 0.534 | 0.1143 | 0.521 | 0.571 | 0.889 | 0.502 | . 0.523 | 0.1320 | 0.508 | 0.412 | 0.919 | 0.508 | . 0.580 | 0.1249 | 0.546 | 0.608 | 0.954 | 0.520 | . 0.448 | 0.1028 | 0.522 | 0.534 | 0.918 | 0.506 | . 0.417 | 0.1684 | 0.405 | 0.415 | 0.981 | 0.401 | . 0.528 | 0.1057 | 0.424 | 0.566 | 0.909 | 0.568 | . nwd[ nwd &gt; 0.9 ] = 99 . head(nwd) . M1M2M3M4M5Y . 0.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 0.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 0.606 | 0.1273 | 0.494 | 0.522 | 99.000 | 0.570 | . 0.437 | 0.1591 | 0.446 | 0.423 | 99.000 | 0.450 | . 0.547 | 0.1135 | 0.531 | 0.519 | 99.000 | 0.548 | . 0.444 | 0.1628 | 0.429 | 0.411 | 99.000 | 0.431 | . nwd[nwd == 99] = NA head(nwd) . M1M2M3M4M5Y . 0.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 0.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 0.606 | 0.1273 | 0.494 | 0.522 | NA | 0.570 | . 0.437 | 0.1591 | 0.446 | 0.423 | NA | 0.450 | . 0.547 | 0.1135 | 0.531 | 0.519 | NA | 0.548 | . 0.444 | 0.1628 | 0.429 | 0.411 | NA | 0.431 | . # is.na()는 데이터객체 전체에 대한 boolean mask(logical character)를 만든다. -&gt; 행렬mask -&gt; 행 or 열별로 접근해줘야한다. is.na(nwd) . M1M2M3M4M5Y . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | FALSE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . FALSE | FALSE | FALSE | FALSE | TRUE | FALSE | . rowSums( is.na(nwd) ) . &lt;ol class=list-inline&gt; 0 | 0 | 1 | 1 | 1 | 1 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | &lt;/ol&gt; colSums( is.na(nwd) ) . &lt;dl class=dl-horizontal&gt; M1 0 M2 0 M3 0 M4 0 M5 11 Y 0 &lt;/dl&gt; # -&gt; 행별로 제거하는 듯 싶다. # -&gt; na.omit()의 결과 &lt;기존 행번호&gt;가 같이 찍히니 확인하면 된다. na.omit(nwd) . M1M2M3M4M5Y . 10.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 20.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 70.489 | 0.1231 | 0.562 | 0.455 | 0.824 | 0.401 | . 90.413 | 0.1182 | 0.592 | 0.464 | 0.854 | 0.475 | . 110.664 | 0.1588 | 0.506 | 0.481 | 0.867 | 0.554 | . 120.703 | 0.1335 | 0.519 | 0.484 | 0.812 | 0.519 | . 130.653 | 0.1395 | 0.625 | 0.519 | 0.892 | 0.492 | . 140.586 | 0.1114 | 0.505 | 0.565 | 0.889 | 0.517 | . 150.534 | 0.1143 | 0.521 | 0.571 | 0.889 | 0.502 | . nwd . M1M2M3M4M5Y . 0.573 | 0.1059 | 0.465 | 0.538 | 0.841 | 0.534 | . 0.651 | 0.1356 | 0.527 | 0.545 | 0.887 | 0.535 | . 0.606 | 0.1273 | 0.494 | 0.522 | NA | 0.570 | . 0.437 | 0.1591 | 0.446 | 0.423 | NA | 0.450 | . 0.547 | 0.1135 | 0.531 | 0.519 | NA | 0.548 | . 0.444 | 0.1628 | 0.429 | 0.411 | NA | 0.431 | . 0.489 | 0.1231 | 0.562 | 0.455 | 0.824 | 0.401 | . 0.536 | 0.1473 | 0.410 | 0.430 | NA | 0.423 | . 0.413 | 0.1182 | 0.592 | 0.464 | 0.854 | 0.475 | . 0.685 | 0.1564 | 0.631 | 0.564 | NA | 0.486 | . 0.664 | 0.1588 | 0.506 | 0.481 | 0.867 | 0.554 | . 0.703 | 0.1335 | 0.519 | 0.484 | 0.812 | 0.519 | . 0.653 | 0.1395 | 0.625 | 0.519 | 0.892 | 0.492 | . 0.586 | 0.1114 | 0.505 | 0.565 | 0.889 | 0.517 | . 0.534 | 0.1143 | 0.521 | 0.571 | 0.889 | 0.502 | . 0.523 | 0.1320 | 0.508 | 0.412 | NA | 0.508 | . 0.580 | 0.1249 | 0.546 | 0.608 | NA | 0.520 | . 0.448 | 0.1028 | 0.522 | 0.534 | NA | 0.506 | . 0.417 | 0.1684 | 0.405 | 0.415 | NA | 0.401 | . 0.528 | 0.1057 | 0.424 | 0.566 | NA | 0.568 | . 1.2.6 Functions that create vectors . x &lt;- c(1,2,3) y &lt;- c(10, 20) c(x, y, 5) # 벡터객체와 값이 동등하게 1차원으로 연결된다. . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 10 | 20 | 5 | &lt;/ol&gt; # boolean + 숫자 -&gt; 숫자로 type 0/1로 바뀌어서 type통일 c(FALSE, 3) . &lt;ol class=list-inline&gt; 0 | 3 | &lt;/ol&gt; c(FALSE, &quot;abc&quot;) . &lt;ol class=list-inline&gt; &#39;FALSE&#39; | &#39;abc&#39; | &lt;/ol&gt; c(pi, &quot;abc&quot;) . &lt;ol class=list-inline&gt; &#39;3.14159265358979&#39; | &#39;abc&#39; | &lt;/ol&gt; seq(4, 9) . &lt;ol class=list-inline&gt; 4 | 5 | 6 | 7 | 8 | 9 | &lt;/ol&gt; oops &lt;- c(7, 9, 13) . rep(oops, 3) . &lt;ol class=list-inline&gt; 7 | 9 | 13 | 7 | 9 | 13 | 7 | 9 | 13 | &lt;/ol&gt; # - index순서대로 1번, 2번, 3번 반복복사 # - index별 반복회수도 벡터로 제공하면 된다. rep(oops, c(1,2,3)) . &lt;ol class=list-inline&gt; 7 | 9 | 9 | 13 | 13 | 13 | &lt;/ol&gt; rep(oops, 1:3) . &lt;ol class=list-inline&gt; 7 | 9 | 9 | 13 | 13 | 13 | &lt;/ol&gt; rep(1:2, c(10, 15)) . &lt;ol class=list-inline&gt; 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | &lt;/ol&gt; 1.2.7 Matrices and arrays . x &lt;- 1:12 x . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | &lt;/ol&gt; # 행렬이 된다. dim(x) = c(3, 4) x # 보이진 않지만, 1, 2, 3, 행 ,1 ,2 ,3 ,4 렬이 된다. . 1 | 4 | 7 | 10 | . 2 | 5 | 8 | 11 | . 3 | 6 | 9 | 12 | . # - 특히 byrow=를 T루로 주면, ncol없이 알아서 된다. matrix(1:12, nrow=3, byrow=T) . 1 | 2 | 3 | 4 | . 5 | 6 | 7 | 8 | . 9 | 10 | 11 | 12 | . LETTERS[1:3] . &lt;ol class=list-inline&gt; &#39;A&#39; | &#39;B&#39; | &#39;C&#39; | &lt;/ol&gt; rownames(x) &lt;- LETTERS[1:3] . x . A1 | 4 | 7 | 10 | . B2 | 5 | 8 | 11 | . C3 | 6 | 9 | 12 | . t(x) . ABC . 1 | 2 | 3 | . 4 | 5 | 6 | . 7 | 8 | 9 | . 10 | 11 | 12 | . # 1차원들을 -&gt; 눕혀서 행으로 더하는 rbind cbind(A = 1:4) . A . 1 | . 2 | . 3 | . 4 | . cbind(A = 1:4, B = 5:6, C = 9:12) . ABC . 1 | 5 | 9 | . 2 | 6 | 10 | . 3 | 5 | 11 | . 4 | 6 | 12 | . rbind(A=1:4,B=5:8,C=9:12) . A1 | 2 | 3 | 4 | . B5 | 6 | 7 | 8 | . C9 | 10 | 11 | 12 | . aa &lt;- cbind(A=1:4,B=5:8,C=9:12) aa . ABC . 1 | 5 | 9 | . 2 | 6 | 10 | . 3 | 7 | 11 | . 4 | 8 | 12 | . # - 좌or우 똑같은 크기의 상수를 붙이려면 상수로 bind하면 된다. cbind(1, aa) . ABC . 1 | 1 | 5 | 9 | . 1 | 2 | 6 | 10 | . 1 | 3 | 7 | 11 | . 1 | 4 | 8 | 12 | . factors(&#48276;&#51452;&#54805; &#51088;&#47308;) . 카테고리칼 변수는 인자로 만들어주는게 중요하다. 그 때 쓰는 것이 factor() | . pain &lt;- c(0, 3, 2, 2, 1) . # -&gt; levels=에는 [요인들과 동일한 값]으로 레벨을 정해서 매칭해놓는다. # -&gt; 연속적인 숫자벡터를 줬어도 &#39;0&#39;~&#39;3&#39;의 문자열로 정해진다. # -&gt; 매칭된 요인-레벨에 대해서, 레벨이름levels을 바꿔주면 요인들도 따라 바뀐다. fpain &lt;- factor(pain, levels = 0:3) fpain . &lt;ol class=list-inline&gt; 0 | 3 | 2 | 2 | 1 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;0&#39; | &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &lt;/ol&gt; # -&gt; 원본 값들이 레벨에 따른 해당 [라벨]로 바껴버린다. levels(fpain) &lt;- c(&quot;none&quot;, &quot;mild&quot;, &quot;medium&quot;, &quot;severe&quot;) fpain . &lt;ol class=list-inline&gt; none | severe | medium | medium | mild | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;none&#39; | &#39;mild&#39; | &#39;medium&#39; | &#39;severe&#39; | &lt;/ol&gt; &#49707;&#51088; -&gt; &#46972;&#48296; by&#50836;&#51064;&#45934; &#48148;&#44984;&#44592; . 변수 job, edu를 숫자 -&gt; 라벨(요인)으로 바꿔보자. . insurance = read.table(&quot;./data/01//insurance.txt&quot;, sep = &quot; t&quot;, header=T) . head(insurance) . idsexjobreligioneduamountsalary . 1 | m | 1 | 1 | 3 | 7.0 | 110 | . 2 | m | 2 | 1 | 4 | 12.0 | 135 | . 3 | f | 2 | 3 | 5 | 8.5 | 127 | . 4 | f | 3 | 3 | 5 | 5.0 | 150 | . 5 | m | 1 | 3 | 3 | 4.5 | 113 | . 6 | m | 2 | 1 | 2 | 3.5 | 95 | . insurance$job . &lt;ol class=list-inline&gt; 1 | 2 | 2 | 3 | 1 | 2 | 3 | 3 | 2 | 1 | 1 | 2 | 3 | 3 | -9 | 1 | 1 | 2 | 2 | 3 | 3 | 3 | &lt;/ol&gt; insurance = read.table(&quot;./data/01//insurance.txt&quot;, sep = &quot; t&quot;, header=T, na.strings = &quot;-9&quot;) . insurance$job . &lt;ol class=list-inline&gt; 1 | 2 | 2 | 3 | 1 | 2 | 3 | 3 | 2 | 1 | 1 | 2 | 3 | 3 | &lt;NA&gt; | 1 | 1 | 2 | 2 | 3 | 3 | 3 | &lt;/ol&gt; # (3) 덮어쓸 labels도 순서대로 동시에 준다. insurance$job &lt;- factor(insurance$job, levels = 1:3, labels = c(&quot;근로자&quot;, &quot;사무직&quot;, &quot;전문가&quot;) ) . insurance$job . &lt;ol class=list-inline&gt; 근로자 | 사무직 | 사무직 | 전문가 | 근로자 | 사무직 | 전문가 | 전문가 | 사무직 | 근로자 | 근로자 | 사무직 | 전문가 | 전문가 | &lt;NA&gt; | 근로자 | 근로자 | 사무직 | 사무직 | 전문가 | 전문가 | 전문가 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;근로자&#39; | &#39;사무직&#39; | &#39;전문가&#39; | &lt;/ol&gt; head(insurance) . idsexjobreligioneduamountsalary . 1 | m | 근로자 | 1 | 3 | 7.0 | 110 | . 2 | m | 사무직 | 1 | 4 | 12.0 | 135 | . 3 | f | 사무직 | 3 | 5 | 8.5 | 127 | . 4 | f | 전문가 | 3 | 5 | 5.0 | 150 | . 5 | m | 근로자 | 3 | 3 | 4.5 | 113 | . 6 | m | 사무직 | 1 | 2 | 3.5 | 95 | . insurance$edu2 &lt;- factor(insurance$edu, levels = 1:5, labels = c(&quot;무학&quot;, &quot;국졸&quot;, &quot;중졸&quot;, &quot;고졸&quot;, &quot;대졸&quot;) ) . insurance . idsexjobreligioneduamountsalaryedu2 . 1 | m | 근로자 | 1 | 3 | 7.0 | 110 | 중졸 | . 2 | m | 사무직 | 1 | 4 | 12.0 | 135 | 고졸 | . 3 | f | 사무직 | 3 | 5 | 8.5 | 127 | 대졸 | . 4 | f | 전문가 | 3 | 5 | 5.0 | 150 | 대졸 | . 5 | m | 근로자 | 3 | 3 | 4.5 | 113 | 중졸 | . 6 | m | 사무직 | 1 | 2 | 3.5 | 95 | 국졸 | . 7 | m | 전문가 | 2 | 4 | 4.0 | 102 | 고졸 | . 8 | f | 전문가 | 2 | 4 | 4.0 | 122 | 고졸 | . 9 | f | 사무직 | 3 | 4 | 4.5 | 140 | 고졸 | . 10 | m | 근로자 | 3 | 5 | 17.0 | 100 | 대졸 | . 11 | f | 근로자 | 1 | 3 | 22.0 | NA | 중졸 | . 12 | m | 사무직 | 1 | 2 | 5.5 | 106 | 국졸 | . 13 | m | 전문가 | 2 | 1 | 4.5 | 130 | 무학 | . 14 | m | 전문가 | 2 | 5 | 7.0 | 150 | 대졸 | . 15 | m | NA | 3 | 4 | 6.0 | 110 | 고졸 | . 16 | f | 근로자 | 3 | NA | 7.0 | 88 | NA | . 17 | m | 근로자 | 1 | 4 | 6.0 | 138 | 고졸 | . 18 | f | 사무직 | 1 | 5 | 5.0 | 110 | 대졸 | . 19 | m | 사무직 | 3 | 3 | 7.0 | 85 | 중졸 | . 20 | m | 전문가 | 3 | 4 | 9.5 | 110 | 고졸 | . 21 | m | 전문가 | 1 | 4 | 10.0 | 95 | 고졸 | . 22 | m | 전문가 | 2 | 3 | 12.0 | 88 | 중졸 | . 1.2.9 list . 객체들을 복합 오브젝트로 만들어준다. | . intake.pre &lt;- c(5260, 5470, 5640, 6180, 6390) intake.post &lt;- c(3910, 4220, 3885, 5160, 5645) . mylist &lt;- list(before=intake.pre, after=intake.post) mylist # df의 칼럼처럼 뽑아쓸 수 있게 모아준다. . $before &lt;ol class=list-inline&gt; 5260 | 5470 | 5640 | 6180 | 6390 | &lt;/ol&gt; $after &lt;ol class=list-inline&gt; 3910 | 4220 | 3885 | 5160 | 5645 | &lt;/ol&gt; mylist$before . &lt;ol class=list-inline&gt; 5260 | 5470 | 5640 | 6180 | 6390 | &lt;/ol&gt; dataframe . 복합 오브젝트 중에 행렬을 만든다. | text파일을 읽을 땐, 거의 df의 행렬로 만든다고 생각하면 된다. | . d &lt;- data.frame(intake.pre, intake.post) d . intake.preintake.post . 5260 | 3910 | . 5470 | 4220 | . 5640 | 3885 | . 6180 | 5160 | . 6390 | 5645 | . d$intake.pre . &lt;ol class=list-inline&gt; 5260 | 5470 | 5640 | 6180 | 6390 | &lt;/ol&gt; 1.2.11 indexing &#44592;&#45733; . 순서대로, 혹은 일부만 벡터/list/df의 특정index(또는 열)을 여러개 뽑아쓰는 기능 | . intake.pre[c(1,5)] . &lt;ol class=list-inline&gt; 5260 | 6390 | &lt;/ol&gt; intake.pre[- c(1,5)] . &lt;ol class=list-inline&gt; 5470 | 5640 | 6180 | &lt;/ol&gt; 1.2.12 Conditional selection . 인덱싱 처럼 대괄호를 쓰며, 인덱싱 명시 자리에 조건식을 넣는다. 데이터 순서를 (환자)id로 공유하는 list 데이터라면, 서로 다른 list &amp;&amp; 상관없어 보이는 데이터를 통해 만들기 가능한` boolean 벡터를 만들어서 대괄호에 넣는다. | . | . intake.post . &lt;ol class=list-inline&gt; 3910 | 4220 | 3885 | 5160 | 5645 | &lt;/ol&gt; intake.pre . &lt;ol class=list-inline&gt; 5260 | 5470 | 5640 | 6180 | 6390 | &lt;/ol&gt; # 1) [pre가 6000보다 컸]던 id의 환자들에 대해 # 2) post 수치는? intake.post[ intake.pre &gt; 6000 ] . &lt;ol class=list-inline&gt; 5160 | 5645 | &lt;/ol&gt; intake.post[ intake.pre &gt; 5500 &amp; intake.pre &lt;= 6200 ] . &lt;ol class=list-inline&gt; 3885 | 5160 | &lt;/ol&gt; # - 비운 행or렬 = 전체 d [ d$intake.pre &gt; 6000, ] . intake.preintake.post . 46180 | 5160 | . 56390 | 5645 | . 1.2.15 implicit loops . 내장된 반복을 가진 기능들 | . library(&quot;ISwR&quot;) . data(thuesen) . head(thuesen, 3) # 2개의 변수가 있는 데이터 투센 . blood.glucoseshort.velocity . 15.3 | 1.76 | . 10.8 | 1.34 | . 8.1 | 1.27 | . # - l을 붙이면, 각 변수들이 변수명을 가진 list()로 합쳐진다. like before=,after= lapply( thuesen, mean) . $blood.glucose 10.3 $short.velocity &lt;NA&gt; # - na.rm = T : 미싱밸류를.제거한 lapply( thuesen, mean, na.rm = T) . $blood.glucose 10.3 $short.velocity 1.32565217391304 # - 그냥 벡터형식으로 풀어진다. sapply(thuesen, mean, na.rm = T) . &lt;dl class=dl-horizontal&gt; blood.glucose 10.3 short.velocity 1.32565217391304 &lt;/dl&gt; # - 데이터를 바로 넣으면 안해준다. # - (데이터변수 , 그룹변수, 집계)순으로 지정해줘야한다. tapply(thuesen, mean, na.rm = T) . Error in unique.default(x, nmax = nmax): unique()는 오로지 벡터들에만 적용됩니다 Traceback: 1. tapply(thuesen, mean, na.rm = T) 2. lapply(INDEX, as.factor) 3. FUN(X[[i]], ...) 4. factor(x) 5. unique(x, nmax = nmax) 6. unique.default(x, nmax = nmax) . tapply(thuesen$blood.glucose, thuesen$short.velocity, mean, na.rm = T) . &lt;dl class=dl-horizontal&gt; 1.03 4.9 1.05 16.1 1.09 11.1 1.12 6.5 1.18 7.5 1.19 8.85 1.22 12.2 1.25 6.7 1.27 7.65 1.28 15.1 1.31 9.3 1.32 13.3 1.34 10.8 1.37 10.3 1.47 19.5 1.49 5.3 1.52 6.7 1.7 9.5 1.76 15.3 1.95 19 &lt;/dl&gt; data(energy) . energy . expendstature . 9.21 | obese | . 7.53 | lean | . 7.48 | lean | . 8.08 | lean | . 8.09 | lean | . 10.15 | lean | . 8.40 | lean | . 10.88 | lean | . 6.13 | lean | . 7.90 | lean | . 11.51 | obese | . 12.79 | obese | . 7.05 | lean | . 11.85 | obese | . 9.97 | obese | . 7.48 | lean | . 8.79 | obese | . 9.69 | obese | . 9.68 | obese | . 7.58 | lean | . 9.19 | obese | . 8.11 | lean | . tapply(energy$expend, energy$stature, mean, na.rm = T) . &lt;dl class=dl-horizontal&gt; lean 8.06615384615385 obese 10.2977777777778 &lt;/dl&gt; # - 1=row별 가로집계 / 2=col별 세로집계 m = matrix(rnorm(12), 4) # 2번째인자가 row수만 지정해주는 듯 m . 0.9182174 | -0.7425004 | 1.0621464 | . -1.0513366 | 0.8554100 | -0.2472357 | . -0.9116358 | -1.6340607 | -0.4725558 | . -0.1975745 | -0.1045159 | 1.0616053 | . # - 칼럼별 최소값 apply(m, 2, min) . &lt;ol class=list-inline&gt; -1.05133658709921 | -1.63406066310988 | -0.472555766861294 | &lt;/ol&gt; Sorting . 특정 변수에 대한 order객체를 만든 뒤 -&gt; boolean mask자리에 order mask를 인덱싱 자리에 넣어줘야한다. | . intake . prepost . 5260 | 3910 | . 5470 | 4220 | . 5640 | 3885 | . 6180 | 5160 | . 6390 | 5645 | . 6515 | 4680 | . 6805 | 5265 | . 7515 | 5975 | . 7515 | 6790 | . 8230 | 6900 | . 8770 | 7335 | . typeof(intake$post) . &#39;double&#39; o1 &lt;- order(intake$post) o1 . &lt;ol class=list-inline&gt; 3 | 1 | 2 | 6 | 4 | 7 | 5 | 8 | 9 | 10 | 11 | &lt;/ol&gt; typeof(o1) . &#39;integer&#39; intake$post . &lt;ol class=list-inline&gt; 3910 | 4220 | 3885 | 5160 | 5645 | 4680 | 5265 | 5975 | 6790 | 6900 | 7335 | &lt;/ol&gt; # -&gt; 해당칼럼에 대한 오름차순 order객체로 정렬 intake$post[o1] . &lt;ol class=list-inline&gt; 3885 | 3910 | 4220 | 4680 | 5160 | 5265 | 5645 | 5975 | 6790 | 6900 | 7335 | &lt;/ol&gt; intake$pre . &lt;ol class=list-inline&gt; 5260 | 5470 | 5640 | 6180 | 6390 | 6515 | 6805 | 7515 | 7515 | 8230 | 8770 | &lt;/ol&gt; intake$pre[o1] . &lt;ol class=list-inline&gt; 5640 | 5260 | 5470 | 6515 | 6180 | 6805 | 6390 | 7515 | 7515 | 8230 | 8770 | &lt;/ol&gt; R environment . Session management . ls(): 내 워크스페이스에 존재하는 모든 객체 | rm(): 데이터 객체 삭제 | . ls() . &lt;ol class=list-inline&gt; &#39;a&#39; | &#39;aa&#39; | &#39;b&#39; | &#39;bmi&#39; | &#39;d&#39; | &#39;energy&#39; | &#39;fpain&#39; | &#39;height&#39; | &#39;hh&#39; | &#39;insurance&#39; | &#39;intake.post&#39; | &#39;intake.pre&#39; | &#39;m&#39; | &#39;mylist&#39; | &#39;nwd&#39; | &#39;o1&#39; | &#39;oops&#39; | &#39;pain&#39; | &#39;thuesen&#39; | &#39;wd&#39; | &#39;weight&#39; | &#39;x&#39; | &#39;xbar&#39; | &#39;y&#39; | &lt;/ol&gt; rm(aa, b) # rm으로 데이터객체 삭제 -&gt; 콤마로 한번에 여러개 가능 . ls() . &lt;ol class=list-inline&gt; &#39;a&#39; | &#39;bmi&#39; | &#39;d&#39; | &#39;energy&#39; | &#39;fpain&#39; | &#39;height&#39; | &#39;hh&#39; | &#39;insurance&#39; | &#39;intake.post&#39; | &#39;intake.pre&#39; | &#39;m&#39; | &#39;mylist&#39; | &#39;nwd&#39; | &#39;o1&#39; | &#39;oops&#39; | &#39;pain&#39; | &#39;thuesen&#39; | &#39;wd&#39; | &#39;weight&#39; | &#39;x&#39; | &#39;xbar&#39; | &#39;y&#39; | &lt;/ol&gt; # df객체 속 변수를 바로 쓰는 방법은? # -&gt; session에 df자체를 attach해버리는 것 -&gt; 가진 칼럼들이 다 변수로 붙어진다? # --&gt; 함수들의 인자로 넣기 쉽게 하기 위함인듯? . head(thuesen, 3) . blood.glucoseshort.velocity . 15.3 | 1.76 | . 10.8 | 1.34 | . 8.1 | 1.27 | . attach(thuesen) . ls() . &lt;ol class=list-inline&gt; &#39;a&#39; | &#39;bmi&#39; | &#39;d&#39; | &#39;energy&#39; | &#39;fpain&#39; | &#39;height&#39; | &#39;hh&#39; | &#39;insurance&#39; | &#39;intake.post&#39; | &#39;intake.pre&#39; | &#39;m&#39; | &#39;mylist&#39; | &#39;nwd&#39; | &#39;o1&#39; | &#39;oops&#39; | &#39;pain&#39; | &#39;thuesen&#39; | &#39;wd&#39; | &#39;weight&#39; | &#39;x&#39; | &#39;xbar&#39; | &#39;y&#39; | &lt;/ol&gt; blood.glucose . &lt;ol class=list-inline&gt; 15.3 | 10.8 | 8.1 | 19.5 | 7.2 | 5.3 | 9.3 | 11.1 | 7.5 | 12.2 | 6.7 | 5.2 | 19 | 15.1 | 6.7 | 8.6 | 4.2 | 10.3 | 12.5 | 16.1 | 13.3 | 4.9 | 8.8 | 9.5 | &lt;/ol&gt; # - 인덱싱과 마찬가진데, 함수를 쓴다.?! thue2 &lt;- subset(thuesen, blood.glucose &lt; 7) thue2 . blood.glucoseshort.velocity . 65.3 | 1.49 | . 116.7 | 1.25 | . 125.2 | 1.19 | . 156.7 | 1.52 | . 174.2 | 1.12 | . 224.9 | 1.03 | . # - 로그값을 씌운 변수를 함수로 생성하여 반환 thue3 &lt;- transform(thuesen, log.gluc = log(blood.glucose)) head(thue3, 4) . blood.glucoseshort.velocitylog.gluc . 15.3 | 1.76 | 2.727853 | . 10.8 | 1.34 | 2.379546 | . 8.1 | 1.27 | 2.091864 | . 19.5 | 1.47 | 2.970414 | . # -&gt; 중괄호{}를 이용하여, 입력된 df내에서 변수생성/조작/중간변수 삭제가 가능하다. thue4 &lt;- within(thuesen, { log.gluc &lt;- log(blood.glucose) # + log씌운 칼럼 생성 m &lt;- mean(log.gluc) # 평균값 계산(중간변수) centered.log.gluc &lt;- log.gluc - m # 중간변수를 이용해 새로운 칼럼 추가 생성 rm(m) }) head(thue4) . blood.glucoseshort.velocitycentered.log.gluclog.gluc . 15.3 | 1.76 | 0.4818798 | 2.727853 | . 10.8 | 1.34 | 0.1335731 | 2.379546 | . 8.1 | 1.27 | -0.1541090 | 2.091864 | . 19.5 | 1.47 | 0.7244414 | 2.970414 | . 7.2 | 1.27 | -0.2718920 | 1.974081 | . 5.3 | 1.49 | -0.5782662 | 1.667707 | . The graphics system . 2.2.1 plot layout . x &lt;- runif(50,0,2) y &lt;- runif(50, 0,2) . plot( x, y, main=&quot;Main title&quot;, sub=&quot;subtitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;, ) . # -&gt; x, y좌표에 텍스트를 넣어준다. text(0.6, 0.6, &quot;text at (0.6, 0.6)&quot;) . Error in text.default(0.6, 0.6, &#34;text at (0.6, 0.6)&#34;): plot.new has not been called yet Traceback: 1. text(0.6, 0.6, &#34;text at (0.6, 0.6)&#34;) 2. text.default(0.6, 0.6, &#34;text at (0.6, 0.6)&#34;) . plot( x, y, main=&quot;Main title&quot;, sub=&quot;subtitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;, ) text(0.6, 0.6, &quot;text at (0.6, 0.6)&quot;) . abline(h=.6, v=.6, lty=2) . Error in int_abline(a = a, b = b, h = h, v = v, untf = untf, ...): plot.new has not been called yet Traceback: 1. abline(h = 0.6, v = 0.6, lty = 2) 2. int_abline(a = a, b = b, h = h, v = v, untf = untf, ...) . plot( x, y, main=&quot;Main title&quot;, sub=&quot;subtitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;, ) text(0.6, 0.6, &quot;text at (0.6, 0.6)&quot;) abline(h=.6, v=.6, lty=2) . # -&gt; -1부터 4숫자를, 각 side에 , 0.7크기로, -1~4의 위치에 적기 for (side in 1:4) mtext(-1:4, side=side, at=.7, line=-1:4) . Error in mtext(-1:4, side = side, at = 0.7, line = -1:4): plot.new has not been called yet Traceback: 1. mtext(-1:4, side = side, at = 0.7, line = -1:4) . plot( x, y, main=&quot;Main title&quot;, sub=&quot;subtitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;, ) text(0.6, 0.6, &quot;text at (0.6, 0.6)&quot;) abline(h=.6, v=.6, lty=2) for (side in 1:4) # -1부터 4숫자를, 각 side에 , 0.7크기로, -1~4의 위치에 적기 mtext(-1:4, side=side, at=.7, line=-1:4) . c(1:4) . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 4 | &lt;/ol&gt; 1:4 . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 4 | &lt;/ol&gt; mtext(paste(&quot;side&quot;, 1:4), side=c(1:4), line=-1, font=2) . Error in mtext(paste(&#34;side&#34;, 1:4), side = c(1:4), line = -1, font = 2): plot.new has not been called yet Traceback: 1. mtext(paste(&#34;side&#34;, 1:4), side = c(1:4), line = -1, font = 2) . plot( x, y, main=&quot;Main title&quot;, sub=&quot;subtitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;, ) text(0.6, 0.6, &quot;text at (0.6, 0.6)&quot;) abline(h=.6, v=.6, lty=2) for (side in 1:4) mtext(-1:4, side=side, at=.7, line=-1:4) mtext(paste(&quot;side&quot;, 1:4), side=c(1:4), line=-1, font=2) . 2.2.2 Building a plot from pieces . 각 축에 라벨 주기 | . plot(x, y) . # -&gt; 흰색으로 표시만 지우고 도화지만 그려놓는다는 의미 # 라벨도 &quot;&quot;로 다 지우고 # axes= F -&gt; 축도 그리지 말고 있어라. plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F ) . plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F) points(x, y) . # 2) axis(1) -&gt; 1번 축(x축)만 그려라 plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F) points(x, y) axis(1) . # 2) axis(1) -&gt; 1번 축(x축)만 그려라 # 3) axis(2, at= ) -&gt; 2번 축(좌 y축)에는 점을 직접 찍어준다. plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F) points(x, y) axis(1) axis(2, at=seq(0.2, 1.8, 0.2)) . # 2) axis(1) -&gt; 1번 축(x축)만 그려라 # 3) axis(2, at= ) -&gt; 2번 축(좌 y축)에는 점을 직접 찍어준다. # 4) box() -&gt; 4방향 축이 사각형으로 모두 그려진다. plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F) points(x, y) axis(1) axis(2, at=seq(0.2, 1.8, 0.2)) box() . # 2) axis(1) -&gt; 1번 축(x축)만 그려라 # 3) axis(2, at= ) -&gt; 2번 축(좌 y축)에는 점을 직접 찍어준다. # 4) box() -&gt; 4방향 축이 사각형으로 모두 그려진다. # 5) title() -&gt; main(위) sub(아래) xlab, ylab -&gt; 2개 축 라벨 plot(x, y, type=&quot;n&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, axes=F) points(x, y) axis(1) axis(2, at=seq(0.2, 1.8, 0.2)) box() title(main=&quot;Main title&quot;, sub = &quot;subttitle&quot;, xlab=&quot;x-label&quot;, ylab=&quot;y-label&quot;) . 2.2.3 Using par . 그래프 그릴 때 유용한 par문 | . ?par . par(mfrow=c(2,2)) # 한 화면을 2x2 로 나눠서 그린다. . par(mfrow=c(1,1)) . 2.2.4 Combinin plots . 그래프를 합치는(겹쳐그리는) 방법: 2번째 그래프에 add=T옵션 주기 정규분포 변수 -&gt; rnorm(갯수) | 정규분포 함수 -&gt; dnorm(변수) | . | hist그램 그린 후 -&gt; 정규분포를 겹쳐그려서 -&gt; 정규분포를 따르는지 확인 | . # - 안주면 각각의 그림이 2개로 나눠서 각각 그려진다. x &lt;- rnorm(100) # 정규분포(r norm)를 따르는 놈 100개 hist(x, freq=F) # 히스토그램: freq=F 를 주면 빈도대신 비율(밀도)가 y축을 차지한다. curve(dnorm(x), add=T) # 정규분포 함수dnorm(x) 를 curve로 그리는데, 겹쳐서 그려라 add=T # my) 정규분포 변수 -&gt; rnorm(갯수) # my) 정규분포 함수 -&gt; dnorm(변수) . # 다시 그리고 -&gt; add=T로 2번째 그림 그리고 h &lt;- hist(x, plot=F) h . $breaks [1] -3 -2 -1 0 1 2 3 4 $counts [1] 4 9 39 28 17 2 1 $density [1] 0.04 0.09 0.39 0.28 0.17 0.02 0.01 $mids [1] -2.5 -1.5 -0.5 0.5 1.5 2.5 3.5 $xname [1] &#34;x&#34; $equidist [1] TRUE attr(,&#34;class&#34;) [1] &#34;histogram&#34; . h &lt;- hist(x, plot=F) # 기존 hist plot 객체에서 y축 정보만 가져와 -&gt; 조작후 객체로 만든다. ylim &lt;- range(0, h$density, dnorm(0)) # 조작된 ylim으로 새로운 hist를 그린다. hist(x, freq=F, ylim=ylim) curve(dnorm(x), add=T) . 2.3 R programming . 함수를 정의하고 -&gt; .r 파일로 저장후 -&gt; source() 문으로 로딩한 뒤 -&gt; 사용 | . # -&gt; 이후 파일로 저장하기 위해 스트링으로 바꿈 func_string &lt;- &quot;hist.with.normal &lt;- function(x) { hist &lt;- hist(x, plot=F) s &lt;- sd(x) m &lt;- mean(x) ylim &lt;- range(0, h$dentisy, dnorm(0, sd=s)) hist(x, freq=F, ylim=ylim) curve(dnorm(x, m, s), add=T) }&quot; . filename &lt;- &quot;./01_p44.r&quot; fileConn &lt;- file(filename) writeLines(func_string, fileConn) close(fileConn) . source(filename) . ls() . &lt;ol class=list-inline&gt; &#39;a&#39; | &#39;bmi&#39; | &#39;d&#39; | &#39;energy&#39; | &#39;fileConn&#39; | &#39;filename&#39; | &#39;fpain&#39; | &#39;func_string&#39; | &#39;h&#39; | &#39;height&#39; | &#39;hh&#39; | &#39;hist.with.normal&#39; | &#39;insurance&#39; | &#39;intake.post&#39; | &#39;intake.pre&#39; | &#39;m&#39; | &#39;mylist&#39; | &#39;nwd&#39; | &#39;o1&#39; | &#39;oops&#39; | &#39;pain&#39; | &#39;side&#39; | &#39;thue2&#39; | &#39;thue3&#39; | &#39;thue4&#39; | &#39;thuesen&#39; | &#39;wd&#39; | &#39;weight&#39; | &#39;x&#39; | &#39;xbar&#39; | &#39;y&#39; | &#39;ylim&#39; | &lt;/ol&gt; x &lt;- rnorm(100) hist.with.normal(x) . 2.3.1 Flow control . R의 반복문 중 3가지 while 문 -&gt; 반복될 조건문 | repeat 문 -&gt; 탈출할 조건문 -&gt; while의 반대 | for 문 -&gt; 뿌려줄 벡터 -&gt; 그걸로 그림그리기 | | . y &lt;- 12345 # 1. while (조건) 식 으로 구하는 root x &lt;- y/2 while (abs(x*x-y) &gt; 1e-10 ) x &lt;- (x + y/x)/2 x . 111.108055513541 x^2 . 12345 # 1. while (조건) 식 으로 구하는 root # 2. repeat { 식 if 탈출조건 break} repeat{ x &lt;- (x + y/x)/2 if (abs(x*x-y) &lt; 1e-10) break } x . 111.108055513541 x &lt;- seq(0, 1, 0.5) plot(x, x, ylab=&quot;y&quot;, type=&quot;l&quot;) for ( j in 2:8 ) lines(x, x^j) . 2.4 Data entry . 김성수 2015 강의교안 저장된페이지 | 01 2015자료 데이터시각화.pdf에 코드 검색됨 | . text file: read.table, read.csv | excel file : read.xlsx ( package: xlsx) | install.packages(&quot;xlsx“) library(xlsx) drug.data = read.xlsx(&quot;c:/Rfolder/data/drug.xlsx&quot;, 1) # 1은 default인데, sheet번호다. edit(drug.data) # R전용 데이터에디터에 가져와서 조작하고 싶을 때 . &#48320;&#49688;&#44049; &#48320;&#54872;(recode) Method1 : &#51064;&#45937;&#49905; . (범위별 매핑 -&gt; ) recode = 변수 값 변환이라고 한다. | . 새 변수를 만들고 (할당으로 복사) | 인덱싱을 이용해서 범위별로 값 변환 | &#48320;&#49688;&#44049; &#48320;&#54872;(recode) Method2 : car&#54056;&#53412;&#51648;&#51032; recode()&#54632;&#49688; . 새 변수 만들어놓는 것은 똑같고 | recode()함수를 이용하여 범위를 간단하게 표현할 수 있다. . &quot; lo:40=1; 40:60=2;60:hi=3 &quot; | . | 1,2,3 범주형 자료이면서 순서형 변수 순서를 ordered()를 이용해서 factor-라벨로 준다. . 라벨을 주면 그래프에서도 나온다. | . | &#44050; &#46972;&#48296;(Value labels): &#49707;&#51088; -&gt; &#46972;&#48296;&#47196; &#48148;&#44984;&#44592; . 명목형 변수 -&gt; 순서 없는 일반 범주factor()를 이용해서 바꾼다. | 순서형 변수 -&gt; 순서를 가진 범주ordered()를 이용해서 바꾼다. |",
            "url": "blog.chojaeseong.com/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EB%8D%B0%EB%B6%84%EB%B0%A91/r%ED%99%98%EA%B2%BD/2022/03/11/01-%EB%8D%B0%EB%B6%84%EB%B0%A901)-Basics-and-R-environment.html",
            "relUrl": "/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EB%8D%B0%EB%B6%84%EB%B0%A91/r%ED%99%98%EA%B2%BD/2022/03/11/01-%EB%8D%B0%EB%B6%84%EB%B0%A901)-Basics-and-R-environment.html",
            "date": " • Mar 11, 2022"
        }
        
    
  
    
        ,"post116": {
            "title": "싱글톤으로 캐싱(로또번호)",
            "content": "싱글톤과 캐싱 . 싱글톤을 이용한 [단일객체 CACHE] 적용과 TDD . 싱글톤을 이용한 CACHE 생성 2가지 방법(정리용) . static final으로 클래스 CACHE변수; 선언 . 바로 옆에서 = 할당하며 초기화 or 길어서 static { 클래스변수 = } 블럭(final도 가능)에서 초기화 바로 초기화하든, static블럭에서 초기화하든 null이 아닌 상태의 캐쉬변수 | . | 이후 정팩메로만 생성된 CACHE객체 or 생성된 CACHE자료구조에서 1개만 get하여 제공 이후 기본생성자는 CACHE 최초 초기화하며 채울때만 사용됨 | . | . private static final Map&lt;Integer, LottoNumber&gt; LOTTO_NUMBER_CACHE; static { LOTTO_NUMBER_CACHE = IntStream.rangeClosed(LOTTO_NUMBER_MIN, LOTTO_NUMBER_MAX) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } private final int number; public LottoNumber(final int inputNumber) { this.number = inputNumber; } public static LottoNumber from(final String inputNumber) { final int number = Integer.parseInt(inputNumber); validateLottoNumberRange(number); return LOTTO_NUMBER_CACHE.get(number); } . | static으로 클래스 CACHE변수; 선언 (no final) . 이후 정팩메에 synchronized달아주고 . | 정펙매내부에서 초기화 한번도 안된 최초 if (CACHE == null) 상태의 캐쉬변수일 때만, 기본생성자로 CACHE변수 초기화 | 정펙매로만 생성된 CACHE객체 or 생성된 CACHE자료구조에서 1개만 get하여 제공 | . private static Map&lt;Integer, LottoNumber&gt; LOTTO_NUMBER_CACHE; private final int number; private LottoNumber(final int number) { checkNumberRightRange(number); this.number = number; } public synchronized static LottoNumber valueOf(final int number) { checkNumberRightRange(number); if (LOTTO_NUMBER_CACHE == null) { LOTTO_NUMBER_CACHE = IntStream.rangeClosed(MIN_LOTTO_NUMBER, MAX_LOTTO_NUMBER) .boxed() .collect(Collectors.toMap(lottoNumber -&gt; lottoNumber, LottoNumber::new)); } return LOTTO_NUMBER_CACHE.get(number); } . | Test에서부터 빨간줄로 넘어가 -&gt; 캐쉬 적용하기 . 캐쉬로 받아먹으려면 싱글톤 받아주는 정펙매(getInstance())로만 가져와야한다. . 네이밍을 그렇게 했어도 기본 생성자에 넣어줄 파라미터도 받아야한다. | . | 싱글톤의 동시성 잇슈를 처리하기 위해 synchronized를 접근제한자 &lt;-&gt; static 사이에 넣어준다. . public synchronized static void getInstance(final int value) { } . | 앞으로 정펙매로만 제공되어야하므로 도메인 검증을 여기로 옮기자. . 기존 도메인테스트가 new 기본생성자()로 진행되어있으니, 그냥 두고 -&gt; 맨 나중에 도메인검증을 정팩메코드로 + 기본생성자는 private + 검증은 삭제하도록 수정하자.. | . | . public LottoNumber(final int value) { // 지금은 임시로 살려둔다. 테스트를 나중에 바꿀 때 private로 변경 + 검증삭제 validate(value); this.value = value; } public synchronized static void getInstance(final int value) { //2. 검증은 여기로 옮긴다. 왜냐면, 앞으로 CACHE정팩메로만 제공될 것이기 때문. // - 정적안에 들어가므로 검증메서드가 static으로 바뀐다. validate(value); } . | CACHE의 static변수 선언을 직접 안하고 빨간줄생성 하기 위해, . 빨간줄로 if ( == null )부터 static 초기화 를 작성해줬다. 기본생성자는 이제 여기 캐쉬생성에서만 이용되어야한다. 원래는 private으로 바꾸고, TEST다 처내야함. | . | . | static 메서드 내 자동 생성시 constant = static final이므로 그냥 field -&gt; static필드로 생성하자. | . . public class LottoNumber { private static final int MIN = 1; private static final int MAX = 45; // 자동 생성한 CACHE field (static) private static Map&lt;Integer, LottoNumber&gt; CACHE; private final int value; public synchronized static void getInstance(final int value) { validate(value); //3. 캐쉬로 제공될 static 변수; 만 선언하고 -&gt; if null일 때 = 최초에만 초기화 시켜준다. // - Map으로 만들거면 // - 중간에 .map( number -&gt; )없이 맨 나중에 toMap으로 만들면 된다. // - intStream은 Integer가 아니다. toMap에 들어가려면 .boxed() 먼저 해주고 들어가야한다. // - toMap의 2번쨰 인자는 method reference만 사용 가능하다. new LottoNumber(Number하니 안되더라) if (CACHE == null) { CACHE = IntStream.rangeClosed(MIN, MAX) //.map( number -&gt; ) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } } . | 정팩메에서 캐쉬객체 or 캐쉬 자료구조.get()한 것을 응답해준다. . public synchronized static LottoNumber getInstance(final int value) { validate(value); if (CACHE == null) { CACHE = IntStream.rangeClosed(MIN, MAX) .boxed() .collect(Collectors.toMap(number -&gt; number, LottoNumber::new)); } // 제공은 이제 기본생성자가 아닌, CACHE에서 제공해준다. return CACHE.get(value); } . | 검증이 넘어간 캐쉬 정팩메로 생성 테스트로 마무리 . @Test void cache_create() { assertDoesNotThrow(() -&gt; LottoNumber.getInstance(6)); } .",
            "url": "blog.chojaeseong.com/java/%EC%8B%B1%EA%B8%80%ED%86%A4/%EC%BA%90%EC%8B%B1/cache/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/10/%EC%8B%B1%EA%B8%80%ED%86%A4%EA%B3%BC-%EC%BA%90%EC%89%AC(%EB%A1%9C%EB%98%90%EB%B2%88%ED%98%B8).html",
            "relUrl": "/java/%EC%8B%B1%EA%B8%80%ED%86%A4/%EC%BA%90%EC%8B%B1/cache/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/10/%EC%8B%B1%EA%B8%80%ED%86%A4%EA%B3%BC-%EC%BA%90%EC%89%AC(%EB%A1%9C%EB%98%90%EB%B2%88%ED%98%B8).html",
            "date": " • Mar 10, 2022"
        }
        
    
  
    
        ,"post117": {
            "title": "의연방02) 이환율과 사망률",
            "content": "&#47785;&#52264; . Measures of morbidity | Measures of mortality | 1강 연구진행의 단계에서 맨 처음 단계인 디스크립티브 스터디에서 쓸 수 있는 메저들이다. | . Measures of Morbidity(&#47784;&#48708;&#46356;&#54000; &#47700;&#51200;) . &#51656;&#48337;&#51032; &#48156;&#49373; &#51221;&#46020; . 질병 발생 정도(모비디티)의 측정은 크게 2가지 방법이 있다. 번역은 둘다 비율 같지만 다른 개념이다. Rate: 속도와 관련된 개념으로서 없었던 질병이 새롭게 &amp; 얼마나 빠른 속도로 퍼지고 하고 있는가 관련메저: Incidence | . | Proportion: 특정시점에서의 비율로서, 흐르고 있는 시간 중 딱 한 시점에서, 전체인구 중 질병 걸린 비율 관련메저 : prevalence | . | | . Incidence or Incidentce rate . 분모: 전체인구가 아니라 특정 기간동안 위험에 노출된 인구 수 위험에 노출된을 어떻게 정의? 언제든지 분자(새롭게 질병발생 환자)로 올라갈 수 있는 가능성이 있는 사람만 포함한다. | 즉, 새롭게 질병 발생이 가능한 사람만 분모에 ex&gt; 자궁암의 incidence rate 계산 -&gt; 자궁암 가능성이 있는 = 자궁이 있는 = 여성들만 분모에 넣어야한다(남성 빼야한다. 자궁적출술 여성은 빼야한다) | . | . | 분자: 새롭게 질병이 발생한 환자수 | 구체적으로 1000명당 인씨던트 레이트 -&gt; 분자/분모에 * 1000 . 1000대신 다른 숫자도 원하는 대로 곱해줘서 N명당 incidence rate으로 명명한다. . . | . | . incidence rate&#51032; &#48516;&#47784;&#51032; &#47928;&#51228; . incidence rated의 분모에는 특정기간 동안이라는 말이 붙어있는데, 연구자 관심기간 아무기간이나 설정할 수 있다. ex&gt; 1년, 5년, 한달... 마음대로 . | 특정기간은 맘대로 정했는데, 중간에 사라지는 사람이 있다 == 모든 사람이 관측되지 않았다의 문제가 있다. . 이사 감, 사라 짐. -&gt; 분모 중 일부만 관찰된다면? | 아래 사진은 5년동안, 5명의 환자 중 2명만 관찰되고 3명은 사라짐 사라진 사람이 질병이 새로 발생됬어도 포함안되게 된다. | . | . | . Person-time . 일부시간만 관측된 사람이 존재한다? 분모의 단위를 특정기간 ~ 새로운 환자수의 사람 수가 아니라 | person-time이라는 시간(구간)동안 관찰된 환자수새로운 분모를 적용한다. | 첫 1년 -&gt; 5명 다 관찰: year1 - 5 py | 2번째 1년 -&gt; 4명 관찰: yaer2 - 4 py | 마지막엔 py값만 다 더한다. 다 관찰되었다면 사람수 x 시간 수 = 25py이지만, 합친 결과 17py로 관찰되었다 -&gt; 일부만 관찰된 사람이 있었다. | 17py를 incidence rate의 분모로 쓴다. | . | . | . 연구자가 정한 특정기간동안 모든 사람 다 관측시 -&gt; 분모가 사람 수 Cumulative incidence 또는 incidence proportion이라고도 한다. | . | 연구자가 정한 특정기간동안 일부기간만 관찰되는 사람 1명이라도 존재시 -&gt; 분모가 py (Cumulative incidence와 구분해주기 위해서) incidence density, person-time incidence rate라고 한다. | . | incidence를 보면 분모를 보고 몇명당인지/몇py인지를 먼저 봐서 계산방법을 이해하자 | . Prevalence . rate가 아닌 proportion에 관련된 것으로 시간이 지나감을 고려하지 않고, 특정 시점만 잡아서 이야기한다. 특정 시점에, 관심집단내 질병에 걸려있는 사람의 비율 | 경우에 따라 N명당 -&gt; * N해주면 된다. | . | . Incidence vs. prevalence &#52264;&#51060; . 분자에 집중해보기 . prevalence 분자는 시간이 지나감을 고려하지 않으므로 어제 질병 걸린 사람과 몇십년전 질병 걸린 사람이 섞여있다. . 특정 시점 -&gt; 한 지점만 보기 때문에 언제 병에 걸렸는지는 상관 없게 된다. | . | incidence분자에는 특정기간동안 새롭게 발병한 new case만 들어간다. . | | . . 그림으로 보면, 관심있는 파퓰레이션(파란색)이 있을 때 특정시점에 질병을 가진 사람 = 주황색 | 특정시점에 질병을 가지고 있지 않은 사람 = 노란색 prevalence: 주황색 / 파란색 | . | 정해진 특정시점에 질병 없는 노란색을 시작으로 1년간 follow-up한다고 쳤을 때, incidence: 노란색(2nd, at baseline) 중 새롭게 발생한 빨간색테두리의 주황색(2nd) / 전체 노란색(2nd, at baseline) incidence는 분자가 새롭게 발생해야하기 때문에, 애초에 시작점에서 질병 발생위험을 가지고 있지만 질병이 없는 환자를 대상으로 한다 | . | . | . | . Incidence: 어떤 기간동안 새롭게 발병한 질병에 대한 것이므로 -&gt; 질병이 없는 사람이 새로 질병이 발생할 가능성에 대한 정보를 준다 -&gt; 질병에 걸릴 확률/위험에 대한 정보를 준다. risk(위험)의 척도 | 어떤 질병의 원인, etiology를 파악하고 싶을 때 유용 | . | Prevalence: 프리벌런스는 옛날에 걸린사람 + 지금 걸린 사람을 섞어서 다 포함하고 있기 때문에, 새로운 질병이 얼마나 발생하기 쉬운지에 대한 정보는 없고, 지금 상태에서 영향을 받고 있는 사람/고통받고 있는 사람이 어느정도냐를 제는 것 burden의 척도 | 원인보다는 집단내 메디컬서비스, 자원을 어떻게 배분할 것인가, 헬스 서비스 관련 정책을 어떻게 결정할 것인지(어디 질병 프로그램에 돈을 더 투자할 것인지 결정)에 유용 | 질병의 위험은 인씨던스가 더 유용하지만, **경우에 따라 인씨던스를 알기 어려운 질병도 있다. ex&gt; 천식 -&gt; 정의도 떨어지지 않고, 증상도 서서히 드러나기 때문에 언제부터 발병했는지 판단불가 -&gt; new case인지 알기 어려우므로 인씨던스 계산이 어렵다 -&gt; 집단간의 비교나 시간에 따른 비교가 어려우므로 특정시점에서 계산해버리는 prevalence를 계산이 더 유용하다 | . | . | . 공식: Prevalence = Incidence × Duration of disease Incidence가 시간에 따라 변하지 않고, | prevalence가 너무 높지 않고 | 인구유입과 유출이 같은 경우 성립 성립한다 질병 앓는 기간 x 인씨던스를 곱해서 프리벌런스를 구한다. | 대충 서로 비례한다고 직관적으로 생각할 수 있다. | . | . | 직관(공식처럼 비례)과 어긋나는 경우 . 인쓰던스는 높지만 x 상수역할을 하던 Duration of disease가 아주 짧은 경우(금방 치료or사망) -&gt; 인씨던스가 높아도 prevalence가 낮다 . | 인씨던스가 아주 낮지만 x 상수역할을 하던 Duration of disease가 아주 긴 경우(오래동안 치료되지 않은 체 생존하고 있음) -&gt; 인씨던스가 낮아도 prevalence가 높다 . . | . | . Measures of Mortality(&#49324;&#47581;&#47456;) . &#49324;&#47581;&#45936;&#51060;&#53552; . 사망데이터는 생각해보면, proportion 및 prevalence의 개념이 의미가 없다 . 언젠간 모두 사망하므로 -&gt; 언젠가 모두 사망O로 바뀜 -&gt; 사망 O/X의 비율보다는 사망시점(언제 사망)이 중요하므로 mortality rate를 본다. | . | Mortality Rate(사망률) . Risk of dying(사망 위험의 측도) | Disease severity(시비리티)의 측도 (이 질병에 걸렸을 때 사망 률 높다 -&gt; 질병의 심각도 높다) | 치료 효과의 측도: 반대로 확줄어든다면 좋은 치료의 측도도 된다. | Incidence rate의 proxy(대체자)로 기능할 수도 있다 조건 1) 치명률이 높은 병 | 조건 2) 투병기간이 짧은 병 새롭게 걸렸는데 금방 + 사망하는 병 -&gt; 발병 인씨던스와 사망과 비슷한 이벤트가 된다. -&gt; 사망률을 인씨던스 레이트 대신 쓰게 된다. | . | . | . | . . Mortality rate &#50668;&#47084; &#44228;&#49328;&#48277; . 국가통계에서는 보통사망률이라 부르는 사망률 계산법 사망률 = 보통사망률 = mortality rate = crude(보정하지 않은) death rate | 특정기간이라 적혀있지만, 사망률은 보통 1년을 많이 써써 연간사망률을 많이 쓴다. 연간사망률은 7월1일을 중앙시점으로 본다. | . | 중앙시점 인구수를 사용하는 이유: incidence rate는 py를 분모에 넣어 계산하기도 했었지만, 기간 평균 인구수에 대한 접근으로서 중앙시점 인구수를 사용 | . | . Specific mortality rate (subgroup &#49324;&#47581;&#47456;) . . 사망률을 집단 전체가 아니라 나이or성별or진단명으로 나눠진 subgroup에 대해서만 구할 수 도 있다. | age-specific rate : 분자와 분모에 같은 나이 조건을 걸어야 한다 예&gt; 10세 미만 아동의 연간사망률 -&gt; 분모도 10세 미만의 그해 7월1일 아동수 -&gt; 분자도 10세미만의 | . | Disease-specific mortality의 예 : 분모는 전체인구수 -&gt; 분자만 특정질병으로 사망 인구수 | . &#52824;&#47749;&#47456; (Case-fatality) (&#52992;&#51060;&#49828;-&#54168;&#51060;&#53448;&#47532;&#54000;) . 사망률(7월1일 전체 인구수)에 비해 치명률의 분모는 특정 질병을 가진 사람이 대상이다 곱하기 100을 하는 퍼센티지 개념을 많이 쓴다. | . | 어떤 질병에 걸린 사람 중 몇프로가 죽었냐?에 대한 것이다. 질병의 심각도에 대한 측도: 심각한 병이면 치명률이 높다 | 치료 효과의 측도: 좋아지만 치명률이 낮아진다. | . | . . Years of potential life lost . 줄여서 YP LL, 최근에 많이 쓰는 측도 | 나이가 많은 사람이 사망하는 것보다 어린 사람이 사망하는 것이 더 큰 손실임을 반영한 측도 | 계산할 때는 기대수명부터 계산하고 -&gt; 사망한 사람의 나이에서 뺀 뒤 총합 기대수명 계산법을 정하느냐에 따라 달라지니 먼저 확인한다. | . | . 아래 그림은 10만명당사망률에 대한 age-adjusted mortality rate vs YPLL비교 표 그냥 보면 Heart disease(심장병)가 제일 사망률이 높아보인다 mortality rate로만 보면, Heart disease(심장병)이 167 가장 큰 원인 같고, Accidents(사고사)를 보면, 40.5으로 1/4정도 밖에 안되는 것 같다 | 하지만, YPLL도 같이 보게 되면 Accidents(사고사)가 더 높다 -&gt; 어린사람이 더 큰손실이라는 YPLL개념 없이보면, 사망률은 1/4정도 였지만, YPLL로는 조금 더 높았다 -&gt; 사고사 한 사람이 젊은 사람들이 더 많아서 그로인한 손실이 높게 평가되었다` | Suicide도 심장병의 1/10정도였지만, YPLL로 보면 1/3수준으로 손실을 높제 잡아줬다 -&gt; 젊은 사람이 많았다. 심장병에 의한 사망률을 줄이는 것도 중요하지만, YPLL을 보니, 사고사+자살을 방지하는 정책이 포텐셜라이프(기대수명)을 더 늘리는 방법일 수 있다. | . | . | . | . &#49324;&#47581;&#47456;&#51032; &#48708;&#44368; . 사망률 비교시 항상 주의해야할 것은 나이라는 팩터다. 사망관련 자료를 볼 때 + 임상자료에서 생존분석시 항상 설명변수로 들어간다` 나이가 사망과 관련성이 깊은 인자이기 때문 | . | 다른 집단간 사망률 비교 -&gt; 집단간 나이 분포차이부터 고려 . 예시&gt; 1000명당 사망률 모든 나이대 : 백인 9.95 , 흑인 7.35명 사망 -&gt; 이렇게 보면 흑인이 더 의료서비스 접근성이 낮다거나 접근후 인종차별때문에 흑인이 좀 더 사망할 것 같은데, 이상하게 백인이 사망률이 높은 것 같다고 생각할 수 있다. | 나이대로 쪼개보면, 왜 이런 결과가 나왔는지 확인할 수 있다. 각 연령대 모두에서 흑인의 사망률이 더 높다. 오직 85세 이상에서만 백인이 더 높다 | 85세이상 그룹때문에, all alges에서 백인의 사망률이 더 높은 것처럼 보이게 된 것이다. | 이런 현상의 원인: 백인은 85세이상이 많았다(많이 살아남은 것) -&gt; 그만큼 많이 죽었다. 흑인은 85세이상이 너무나 적었다. -&gt; 이미 더 젊은 나이세 흑인들이 사망했지만, 그게 반영되지 않았음. + 85세 이상그룹이 인구수만 많이 측정되어 많이 반영되었다. -&gt; 전체적으로 백인 사망률이 더 높은 것처럼 보이게 된 것 | . | 이렇게 전체사망률을 crude death rate로 비교하게 되면, 집단간의 사망률 비교가 정확하지 않게 된다. | . | . . | . Age-adjustment . 예제 데이터 . 2개의 집단, 인구 수 전체=90만명, 1년간사망자 수 = A집단 860 vs B집단 1130 | . | Q. 어느쪽이 사망률이 높은가? . 전체적으로 봤을 때는, B집단의 사망자수가 많으니 -&gt; B집단의 사망률이 더 높은 것처럼 보인다. | 각 나이 그룹별 10만명당 사망률을 계산해보자. 각 나이 그룹별 사망자수 / ( 전체인구수 ) X 10만 -&gt; 10만명당 사망률 | . | 하지만, 나이 효과를 보정해서 보면 달라진다 | . | . Direct age adjustment &#50696;&#49884; . 각 집단별(칼럼) / 연령그룹별(행) / 인구수(칼1)와 10만명당 사망률(칼2) | . 그룹별 10만명당 사망률에 대해, 연령분포를 통한 보정을 하기 위해서는 . 먼저 표준집단을 상정해야한다. 국가 인구통계에서 나온 것으로 정할 수 도 있고 | 인구 수가 비슷한 2집단의 경우 -&gt; 두 집단의 합 =표준집단으로 잡을 수 있다. 각 그룹별 인구수합 -&gt; 3그룹 다 합치면 90 + 90 = 총 180만명이 표준집단 | . | . | 구해놓은 그룹별 / 집단별 10만명당사망자률을 이용해서 -&gt; 표준집단 나이분포라면 몇명이 사망했을지 표준집단이라면 사망자 수를 구한다 . 각 그룹별로 A,B서로 다른 나이분포를 가지고 있으니 -&gt; 미리 구해둔 사망률 + 표준집단으로 인구수 통일 -&gt; 사망자 수 계산 | ex&gt; 0-49집단: 80만명(800,000) X 각 집단의 10만명당 사망률(10만명당 12 = 12 / 100,000) . . | . | 기대되는 사망자수를 각 집단별로 각각 구한 뒤 다 더해준다. . | 각 집단별로 나온 기대되는 사망자수에다가 / 표준인구 총합을 나눈 뒤, X 10만을 곱해서 각 집단의 10만명당 age-adjusted mortality rate를 구한다. . | 전체적으로 사망률을 봤을 땐, B집단의 사망자수가 많으니 -&gt; B집단의 사망률이 더 높은 것처럼 보였지만, . 10만명당 에이지-어저스티드 모탈리티 레잇을 이용해서 보면, B집단보다 A집단의 사망률이 더 높다. | crude 모탈리티 레잇을 본 것과는 반대의 결과가 나온다. | . | | . Direct age adjustment &#51452;&#51032;&#51216; . 앞의 예처럼, 인구 수가 비슷하면 합을 이용하는 hypothetical population(하이포 세티칼 파퓰레이션)으로 실존하지 않는 가상의 인구집단을 만들어서 할 수 도 있다. | 아니면, 인구조사통계를 이용할 수 있다. | 주의점: 표준집단은, 비교하려는 비교집단이 너무 드라마틱하게 다르면, 비현실적인 통계량이 될 수 있다. . | 나이 말고도 다른 특성(성별, SES 등)의 분포 보정에도 사용할 수 있다. . | . . Indirect age adjustment . Direct age adjustment의 적용이 불가능할 때가 있다. . 이럴 때는 사실 할 수 있는 것이 많지는 않다 | . | 관심집단의 사망률을 -&gt; 이미 잘 알려진 참조집단과 비교하고 싶을 때 사용한다. . 관심집단의 전체 사망률만 알고 있고, 연령그룹별 인구 수는 알고 있으나, 연령그룹별 사망률을 모를 때 | 참조 집단의 연령그룹별 사망률이 있다고 가정할 때, 그것을 이용한다 | . | 참조집단의 연령별 사망률이 있고, 그것을 이용해, 몇명이 사망했을 것이라고 기대되는지 계산후, 그것의 비율로 계산한 SMR을 이용한다. 분모: 특정기간동안, 참조집단과 같은 연령별사망률을 가졌더라면 발생됬을거라 기대되는, 사망자의 수 | 분자: 특정기간동안, 실제로 관측된, 사망자의 수 | 곱하기 100한 뒤 % | . | . Indirect age adjustment &#50696;&#49884; . . A를 참조집단, B집단을 관심집단이라고 가정한다. . A집단은 참조집단으로서 연령그룹별 10만명당 사망률(사망률 분포)이 알려져있다 연령그룹별로 10만명당 몇명씩 사망했는지도 다 알려져있다. | . | B집단은 연령그룹별 인구수 + 실제 총 사망자수만 알고 있지만, 연령그룹별 사망자수는 모른다 연령그룹별로 1130명이 어떻게 분포하는지 모른다. 연령그룹별 10만명당 사망자수를 모른다. | . | . | Q. A집단과 비교해서 관심집단 B의 사망자률이 더 높을까? . | . B의 각 연령그룹별 인구수에서 X 참조집단 A의 10만명당 사망률을 가졌더라면 -&gt; 몇명이 죽었을까? 기대되는 사망자 수 를 계산한다 B집단에서는 참조집단의 연령그룹별 사망률을 참고 했을 때, 36명이 죽었을 거라 기대할 수 있다. | . | 1.의 방법으로 각 연령그룹별 사망자 수를 각각 구한 뒤 -&gt; 다 더한 기대되는 총 사망자수를 구한다. 참고로 실제 총 사망자수는 이미 알고 있는 상태에서, A집단 참조 기대되는 총 사망자수를 구한 상태다 기대되는 총 사망자수: 1,376 | 실제 총 사망자수 : 1,130 | . | . | 실제 총 사망자수 / A집단의 연령그룹별 사망률 참조 기대되는 총 사망자수를 계산하여 1보다 큰지 작은지 확인한다. 기대되는 것을 분모에 두고 -&gt; 기대되는 것 대비 0.82 &lt; 1-&gt; 기대의 82%만 사망했다. -&gt; B집단의 사망률이 A집단의 0.82로 사망률이 더 낫다 | . | &#51221;&#47532;&#54616;&#44592; . . 크게 인씨던스와 프리벌런스로 질병률을 계산했다. 인씨던스: 특정기간동안 위험 노출 인구집단 내 -&gt; 새롭게 질병 발생 비율 인씨던스의 분모를 계산시, 모든 기간이 아니라 일부만 관찰되는 환자 존재시 -&gt; 분모를 person 대신 person-time으로 계산하며 -&gt; person-time incidence rate이라 한다 | 질병 발생하는 속도 = 새롭게 질병발생하는 것에 대한 얘기 -&gt; risk의 척도 | . | 프리벌런스: 고정된 특정시점에서 질병에 거린 사람의 비율 특정시점에서 얼마나 힘든상탠지 -&gt; burden의 척도 | . | . | 모탈리티 레잇: 특정기간동안 발생한 사망자수를 / 특정기간 중앙시점의 인구수로 나눈 것 년간사망률 -&gt; 7월1일 인구수로 나눈다. | 그외 모탈리티를 보는 것으로는 case-fatality라던가 YPLL의 메저도 있다. | . | 집단간의 모탈리티 레잇을 비교시 반드시 연령분포를 고려해서 비교해야한다 연령분포 차이를 보정하는 2가지 방법이 있다. direct age adjustment : age-adjusted mortality rate | indirect age adjustment : SMR | . | . | . &#50672;&#49845;&#47928;&#51228; . 1&#48264; . . 다음 중 질병률에 대한 설명으로 틀린 것은? . 1 Incidence는 질병이 발생하는 속도에 대한 측도이다. . 2 Incidence를 계산하기 위해서는 관심집단의 구성원들이 모두 관심기간 내내 관측되어야 한다. . 3 Prevalence의 분자에는 방금 질병에 걸린 사람과 아주 오래 전에 질병에 걸린 사람이 섞여있다. . 4 Incidence가 높아도 질병이 금방 치료되거나 질병으로 인해 빨리 사망하게 되면 prevalence가 낮을 수 있다. . 정답입니다. 정답 : 2 해설 : 관심집단의 구성원 일부가 관심기간 중 일부분에서만 관측된 경우, person-time incidence를 사용할 수 있다. . 2&#48264; . . 다음 중 발병시점을 정확히 알기 어려운 질병의 위험을 평가할 때 incidence rate을 대신하여 disease-specific mortality rate를 사용하는 것이 적절한 경우는? . 1 치명율이 높고 투병기간이 긴 질병 . 2 치명율이 높고 투병기간이 짧은 질병 . 3 치명율이 낮고 투병기간이 긴 질병 . 4 치명율이 낮고 투병기간이 짧은 질병 . 정답입니다. 정답 : 2 해설 : 치명율이 높고 투병기간이 짧은 질병은 질병의 발생이 사망으로 이어지는 비율이 크고 시간차가 적기 때문에 mortality rate가 incidence rate의 proxy로서 기능한다. . 2&#48264; &#48512;&#50672;&#49444;&#47749; . 상관없는 개념이야기 . age-specific rate : 분자와 분모에 같은 나이 조건을 걸어야 한다 예&gt; 10세 미만 아동의 연간사망률 -&gt; 분모도 10세 미만의 그해 7월1일 아동수 -&gt; 분자도 10세미만의 | . | Disease-specific mortality의 예 : 분모는 전체인구수 -&gt; 분자만 특정질병으로 사망 인구수 | . | incidencate rate 대신 prevalence를 쓰는 예-&gt; 천식 . 천식 -&gt; 정의도 떨어지지 않고, 증상도 서서히 드러나기 때문에 언제부터 발병했는지 판단불가 -&gt; new case인지 알기 어려우므로 인씨던스 계산이 어렵다 -&gt; 집단간의 비교나 시간에 따른 비교가 어려우므로 특정시점에서 계산해버리는 prevalence를 계산이 더 유용하다 | . | incidencate rate 대신 (Disease-specific) mortality rate를 사용하는 경우 . 치명율이 높고 빨리 사망해서 인씨던스의 새롭게 발생 과 == 사망률의 이벤트가 비슷해진 경우 | 치명률이 높고 투병이가 짧은 질병 | . | . | . 3&#48264; . 다음은 2021년 A집단과 B집단의 연령별 인구분포와 사망자수이다. 두 집단을 합한 인구집단을 표준집단으로 해서 A집단과 B집단의 1000명당 age-adjusted mortality rate를 구하여라. . . &#45236;&#54400;&#51060; . . 표준집단 구하기: 두 인구수의 합 -&gt; 총 표준집단 인구수 : 18000 | 표준집단이였다면 기대되는 사망자수(해당 집단의 1000명당 사망률 X 표준집단 인구수)를 연령별로 집단별로 구하기 . 문제에서 주어진 단위(1000명당)으로 사망률도 계산할 것 | 각 연령그룹별/집단별 1000명당 사망률 부터 구하기 - 1000을 곱해서 %같은 률 A: 10 / 5000 1000 = 2 | B: 9 / 3000 1000 = 3 | A: 21 / 3000 1000 = 7 | B: 45 / 5000 1000 = 9 | A: 17 / 1000 1000 = 17 | B: 21 / 1000 1000 = 21 | . | 표준집단을 인구수로 가정 &amp;&amp; 구한 1000명당 사망률을 반영해 표준집단이었더라면 기대되는 사망자수 구하기 - 1000을 나눠서 실제 수 A: 2 x 8000 / 1000 = 16 | 3 X 8000 / 1000 = 24 | A: 7 x 8000 / 1000 = 56 | 9 X 8000 / 1000 = 72 | A: 17 x 2000 / 1000 = 34 | 21 X 2000 / 1000 = 42 | . | . | 집단별 기대되는 사망자수 더하기 . A: 106 | B: 114 | . | 각 집단별로 나온 기대되는 사망자수 / 표준인구 총합을 나눈 뒤, X 단위(1000)을 곱해서 각 집단의 단위명당 age-adjusted mortality rate를 구한다. . A: 106 / 18000 * 1000 = 5.8888 -&gt; 소수 2번째자리까지 반올림 -&gt; 5.89 | B: 138 / 18000 * 1000 = 7.6666 -&gt; 7.67 | . | &#51221;&#45813; . . &#44228;&#49328; &#50696;&#51228; &#52280;&#44256; . Direct age adjustment 예시 | 그룹별 10만명당 사망률에 대해, 연령분포를 통한 보정을 하기 위해서는 . 먼저 표준집단을 상정해야한다. 국가 인구통계에서 나온 것으로 정할 수 도 있고 | 인구 수가 비슷한 2집단의 경우 -&gt; 두 집단의 합 =표준집단으로 잡을 수 있다. 각 그룹별 인구수합 -&gt; 3그룹 다 합치면 90 + 90 = 총 180만명이 표준집단 | . | . | 구해놓은 그룹별 / 집단별 10만명당사망자률을 이용해서 -&gt; 표준집단 나이분포라면 몇명이 사망했을지 표준집단이라면 사망자 수를 구한다 . 각 그룹별로 A,B서로 다른 나이분포를 가지고 있으니 -&gt; 미리 구해둔 사망률 + 표준집단으로 인구수 통일 -&gt; 사망자 수 계산 | ex&gt; 0-49집단: 80만명(800,000) X 각 집단의 10만명당 사망률(10만명당 12 = 12 / 100,000) . . | . | 기대되는 사망자수를 각 집단별로 각각 구한 뒤 다 더해준다. . | 각 집단별로 나온 기대되는 사망자수에다가 / 표준인구 총합을 나눈 뒤, X 10만을 곱해서 각 집단의 10만명당 age-adjusted mortality rate를 구한다. . | 전체적으로 사망률을 봤을 땐, B집단의 사망자수가 많으니 -&gt; B집단의 사망률이 더 높은 것처럼 보였지만, . 10만명당 에이지-어저스티드 모탈리티 레잇을 이용해서 보면, B집단보다 A집단의 사망률이 더 높다. | crude 모탈리티 레잇을 본 것과는 반대의 결과가 나온다. | . | | .",
            "url": "blog.chojaeseong.com/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EC%9E%84%EC%83%81%EC%97%B0%EA%B5%AC/2022/03/09/%EC%9D%98%EC%97%B0%EB%B0%A902)-Morbidity-and-Mortality.html",
            "relUrl": "/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EC%9E%84%EC%83%81%EC%97%B0%EA%B5%AC/2022/03/09/%EC%9D%98%EC%97%B0%EB%B0%A902)-Morbidity-and-Mortality.html",
            "date": " • Mar 9, 2022"
        }
        
    
  
    
        ,"post118": {
            "title": "일급컬렉션관련 가,불변 List",
            "content": "01 Test코드 등 add/remove 허용 가변List는 new ArrayList&lt;&gt;()로 생성 . 테스트코드에서 .add()해야하는데 Arrays.asList(전체단위만 가변ex&gt;set, replace) 나 List.of(아예 조작 불가)로 초기화 하면 UOE 예외가 발생한다. . add 등 조작이 당장 필요한 List는 new ArraysList&lt;&gt;( );로 초기화할 것 | . @Test void 일급컬렉션_생성자가_파라미터로_list를_받는경우_방어적복사_테스트() { //1. 외부에서 일급컬렉션의 포장변수(List&lt;객체&gt;)로 넘겨줄 [add가능한 가변List]를 생성 // - List.of()는 add/remove 등을 제공하지 않으니 Arrays.List()로 생성했다가 UOE 뜸. 역시 불변 //List&lt;LottoNumber&gt; lottoNumbers = List.of(new LottoNumber(1), //List&lt;LottoNumber&gt; lottoNumbers = Arrays.asList(new LottoNumber(1), // -&gt; 테스트에 add 등 조작하는 가변List는 new ArraysList()&lt;&gt;;로 초기화해서 사용할 것 List&lt;LottoNumber&gt; lottoNumbers = new ArrayList&lt;&gt;(); lottoNumbers.addAll( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6) )); } . | . 02 input 가정인자(검증후 완료된 인자) 등 add/remove 불허 불변List(List.of()) . 참고 블로그 | TDD할 때, input으로 넘어온다고 가정한 인자로서 List를 받을 때 Arrays.asList(1,2,3)이 아니라 List.of(1,2,3)을 쓰더라 | . | . 결론 . List.of() , List.copyof( list )는 add/remove등 **조작시 ** UnsupportedOperationException발생시키는 불변List | 모든 가변 조작(add/remove, set/replace) 불허 | null도 불허 | . | 반면 Arrays.asList는 add/remove만 안되는 전체는 가변List를 제공 통채로 add하는 set, replace 가능) | null허용 + | . | 둘다 add안되니.. 테스트용 가변 객체리스트 생성시에도.. add하면서 테스트하면 안될 듯. | . returnType . List.of()는 10개까진 가변인자 없이 하나하나 받아서 -&gt; ImmutableCollections.ListN()을 반환한다. . add(), remove(), set(), replace()처럼 삽입, 삭제, 변경작업을 하게 될시 UnsupportedOperationException예외가 발생는 불변 자료구조 = 이름 그대로 Immutable한 Collection을 반환해준다. | . static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6) { return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6); } . java9부터 제공한다. . | 인자의 갯수( 0개 / 1~2개 / 3개이상N/ List )에 따라서 다른방식 메서드를 반환한다. . . . | . | 반면에 Arrays.asList()는 가변인자를 받으며 -&gt; new ArraysList&lt;&gt;()를 반환한다. . public static &lt;T&gt; List&lt;T&gt; asList(T... a) { return new ArrayList&lt;&gt;(a); } . 가변인자는 내부 배열로 관리됨 | 추상메서드 AbstractList&lt;E&gt;를 extends하지만, add+remove만 메서드 오버라이딩 하지 않는다. AbstractList의 add()와 remove() 메서드를 확인해본 결과 서브클래스에서 해당 메서드를 오버라이딩 하지 않았다면, UnsupportedOperationException예외가 발생된다. Arrays.asList()의 리턴되는 ArrayList는 삽입, 삭제로 이뤄지는 구조적인 변경을 허용하지 않고 내부 원소들의 값을 변경하는건 허용하는걸 알 수 있다. | . | set() setter메서드만 오버라이딩함. | . | . | . 03 일급컬렉션의 List&lt;객체&gt; 파라미터를 받는 생성자 or 컬렉션을 return하는 getter의 return문에서의 방어적 복사 -&gt; 불변List.copyOf( list ) or add 등 가변 new ArraysList&lt;&gt;( list ) . 만약, 생성자가 파라미터 List&lt;객체&gt;를 받으면, 외부 원본 list의 메모리주소가 들어오니 끊고 재생성해라. . list를 내부 포장할 때, 만약 생성자 파라미터로 내부 포장하는 변수와 동일한 형태의 List&lt;객체&gt;가 들어오면, 외부에서 온 List의 메모리주소로서, 끊고 재생성해줘야 오염이 안된다. list는 callByReference 로서 파라미터에 지역변수로 선언되어도 외부의 메모리주소를 가지고 있다. | this.value = 파라미터로 온 list는 메모리 주소만 대입하여 포장되어있지만, 외부 변화에 오염된다. | . @Test void 일급컬렉션_생성자가_파라미터로_list를_받는경우_방어적복사_테스트() { //1. add될 가변 &amp;&amp; 방어적복사로인한 메모리주소 끊음(재발급)안하면 일급컬렉션 내부 변수도 오염시키는 // -&gt; &lt;외부 원본 List&gt; List&lt;LottoNumber&gt; lottoNumbers = new ArrayList&lt;&gt;(); lottoNumbers.addAll( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6) )); //2. 일급은 외부list를 생성자로 넘겨받아 --방어적복사없이 --&gt; this.value에 넣은 상태다. final Lotto lotto = new Lotto(lottoNumbers); //3. 일급컬렉션말고, 원본에 1개를 더한다. lottoNumbers.add(new LottoNumber(7)); //4. getter로 내부 상태값의 길이를 가져와보자. 6개여야하는데... 7개가 되어있을 것이다. final int size = lotto.getSize(); //5. 7하니까 통과 ... -&gt; 외부list를 add했는데 -&gt; 일급컬렉 포장변수가 가변으로 변해버렸다. assertThat(size).isEqualTo(7); } . | 파라미터로 오는 외부List의 메모리주소를 끊는 방법 2가지 불변 일급 : List.copyOf( otherList ) | 가변 일급: new ArraysList&lt;&gt;( ohterList )로 반환받아서 this.value에 넣어주자. | public Lotto(final List&lt;LottoNumber&gt; value) { if (value.size() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개여야 합니다.&quot;); } if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 중복해서 입력할 수 없습니다.&quot;); } //this.value = value; // 불변하는 일급컬렉션으로 -&gt; 1번째 방어적 복사 적용 this.value = List.copyOf(value); } . // 외부 add에도 6개라고 에러났다. org.opentest4j.AssertionFailedError: expected: 7 but was: 6 Expected :7 Actual :6 &lt;Click to see difference&gt; . | . 참고) 포장(VO or 일급컬렉션) 변수명: value, 상수 MIN/MAX . 값의 포장은 앵간하면 value를 인스턴스 변수(상태값)으로 쓴다. 그래야 getter시 LottoNumber.getValue() 형태로 잘 빠진다. | 만약, LottoNumber.getLottoNumber()가 될 수 도.. | . | 상수도 마찬가지로 도메인Class.이 앞에 붙는다고 생각하고 도메인내에서 편하게 짓자 LottoNumber.LOTTO_NUMBER_MIN이 될 수도.. | LottoNumber.MIN으로 MIN, MAX 편하게 쓰자. | . | . public class LottoNumber { private static final int MIN = 1; private static final int MAX = 45; private final int value; //LottoNumber.getValue()가 맞다.(o) -&gt; LottoNumber.getLottoNumber() (X) public LottoNumber(final int value) { validate(value); this.value = value; } //LottoNumber.MIN 이 맞다.(o) -&gt; LottoNumber.LOTTO_NUMBER_MIN (X) //Integer.MAX_VALUE (o) private void validate(final int value) { if (value &lt; MIN || value &gt; MAX) { throw new IllegalArgumentException(&quot;로또 번호의 범위가 아닙니다.&quot;); } . 일급이 중복 허용 안한다면 단일List가 대신 단일Set으로 정의해도 된다. . List&lt;단일&gt;의 value를 Set&lt;단일&gt;로 바꾼다. . | 테스트에서 생성도 Set.of( 단일1, 단일2 )형식으로 사용한다. . . | Set에 들어가므로 해쉬코드로 비교하는 자료구조용 단일객체는 equals/hashCode 오버라이딩이 되어있어야한다. . VO뿐만 아니라 단일값 포장객체는 그냥 다 오버라이딩 해주자. | . |",
            "url": "blog.chojaeseong.com/java/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%EB%B0%A9%EC%96%B4%EC%A0%81%EB%B3%B5%EC%82%AC/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/08/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98%EA%B4%80%EB%A0%A8-List-%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/java/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%EB%B0%A9%EC%96%B4%EC%A0%81%EB%B3%B5%EC%82%AC/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/08/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98%EA%B4%80%EB%A0%A8-List-%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Mar 8, 2022"
        }
        
    
  
    
        ,"post119": {
            "title": "의연방01) 임상연구 소개",
            "content": "&#51076;&#49345;&#50672;&#44396; . &#51076;&#49345;&#50672;&#44396;&#46976; . 임상연구: 사람의 질병을 이해, 예방, 치료하고 건강을 증진하기 위한 학문 사람의 질병에 대한 학문 | 사람이 아닌 동물실험 연구도 도움 될 수 있다. 실험실에서 세포, 분자단위 연구도 도움 될 수 있다. Labloratory Research와도 겹치게 된다. | . | 큰 인구집단에 적용한다고 하면, 예를들어, 특정 질병에 취약한 high risk 집단은 어떤 계층인가, 질병의 outcome을 향상시키기 위해서 어떤 의료시스템 변화를 implement해야할 것인가와 연결되어 있다. Population Research와도 겹치게 된다. | . | . | . &#51076;&#49345;&#50672;&#44396;&#51032; &#51333;&#47448; . 치료 | 예방 | 진단 | 스키리닝 | 삶의질 | 유전학 | (큰 인구집단) 역학 연구까지 종류가 다양하다 | &#44288;&#47144;&#48516;&#50556; . 기초과학(생물학, 화학, 유전학...) | 역학 | 통계학 | Psychometrics: 임상연구에서 쓰이는 각 변수들의 measurement들이 얼마나 신뢰도가 있느냐 관련 | Physiology of resarch( &#50672;&#44396; &#54644;&#48512;&#46020; ) . Designing Clinical Research 4판에 나오는 내용 | . . 알고 싶은 세계: truth in the universe . 그 중 알고 싶은 것 총 2가지 (0) research question | 어떤 집단에 대한 궁금증인가 (1) target population | 어떤 현상에 관심이 있나 (2) phenomena of interest | . | 알고 싶으니 연구계획을 세운다: study plan . 알고 싶은 target population의 전체를 연구하는 경우는 거의 없다 -&gt; 일부 의도된 샘플: intended sample | 관심 현상을 알기 위해선 변수를 관측: intended variables | . | 연구계획대로 되지 않은다: actual study . 의도한 샘플과 비슷할 수도 있거나 다를 수 있는, 실제 조사/관찰한 subject들 : actual subjects | 의도한 변수와 비슷할 수도 있거나 다를 수 있는, : actual measurements | . | . 실제로는 3가지 : 알고싶은 세계 -&gt; 의도한 연구 -&gt; (의도가)실제로 수행/관측된 것 3가지의 간극을 좁혀야한다. 각각은 얼마나 가까운가에 대한 것 : validity 알고싶은 세계 &lt;-&gt; 의도한 연구가 얼마나 가까운가 : External validity | 의도한 연구 &lt;-&gt; 실제 연구가 얼마나 가까운가 : internal validity | . | . | . &#51339;&#51008; &#51076;&#49345;&#50672;&#44396; . 좋은 연구는 이 2가지 validity가 최대화된 연구 -&gt; 어떻게 하면 맥시마이즈 할 수 있을까? | . &#50672;&#44396;&#44228;&#54925;&#49436; . 연구 구조가 적혀있는 설계도 | 연구비 심사나 IRB를 위해 작성하는 경우가 많다 | 그러나 근본적인 목적은 연구를 과학적/효율적으로 도와주는 도구가 된다. | . &#50672;&#44396;&#44228;&#54925;&#49436; &#44396;&#49457; . &#50672;&#44396;&#51656;&#47928;(Research question) . 연구를 통해 답하고자하는 질문 | 연구의 목적 연구 시작전 명시되어야하고, 구체적일 수록 좋다. | . | . 연구 해부도내에서는 truth in the universe에 해당하는 것 | 좋은 연구질문을 정하는 기준 FINER . Feasible(피져블): 실제 수행 가능한가? 실제 연구에 들어가는 비용과 시간을 감당할 수 있고,환자를 모집할 수 있는가 | 연구자의 능력/자원/경험치가 연구하기에 충분한가? 연구질문이 아무리 좋아도 피져블 하지 않으면 성공할 수가 없음. | . | . | Interesting: 연구자 본인에게 흥미로운 주제인가 더불어, 관련분야 연구자들의 흥미를 끌 만한 주제인가 | . | Novel(노블): 기준연구와 비교시 새로운점이 있나 기존연구와 다른점이 있는가 | 기존연구의 단점을 보완하는가 | 완전히 새로운 가설을 만들어 내는가 | . | Ethical(에띠컬): 윤리적인가 윤리적 연구 기본원칙에 충실한가 | IRB 규정을 준수하는가 | . | Relevant(렐러번트): 연구계획서에 significant에 해당하는 항목 . 얼마나 과학/환자 돌보는데 기여하는가 | 얼마나 새로운 지식을 창출하고, 미래연구를 촉진시키는 가 | . . . | | . &#50672;&#44396; &#48176;&#44221;&#44284; &#51473;&#50836;&#49457; . 이미 무엇이 알려져있는가 | 무엇이 안알려져있어서 이 연구질문이 중요한가 | 이 연구를 하면 어떤 종류의 지식을 | 이 연구가 어떤 prractical impact(실제 가이드라인, 보건정책에 영향)을 끼칠 것이가 | . &#50672;&#44396;&#46356;&#51088;&#51064; . 종류가 많고, 새로운 디자인이 개발되고 있어 정리될 순 없지만, 대략적으로 파악할 수 있는 그림이다. | . 크게 2가지 . Experimental(실험) : 내가 연구대상에 무엇인가를 가하거나 해서 -&gt; 연구대상을 따라가며 관찰 . 가하면서 연구대상을 따라가며 관찰하니 특성상 Prospective한 study일 수 밖에 없다. | intervention등을 가한 다음, 이후에 일을 관찰하니 Longitudinal study일 수 밖에 없다. | . | Observational(관찰): 가하지 않음 따라감 -&gt; prospective가 될 수도 retrospective가 될 수도 . prospective: 가하진 않지만 지금부터 따라가면서 살펴보는 Longitudinal: 지금부터 따라가면서 현재-&gt;미래 2시점 연결해관찰 = Cohort Study | . | retrospective: 가하진 않지만 지금부터 과거로 따라가면서 살펴보는 Longitudinal: 지금부터 과거로 따라가면서 현재-&gt;과거 2시점 연결해관찰 = Case-control study | . | cross-sectional: p/r관계없이, 시점을 2개이상 보지않고,딱 1시점만 보는 것 | . | | . 연구의 목적에 따라 좋은 디자인의 기준이 달라지지만 | 좋은 디자인: internal/external validity를 높이는 디자인 나쁜 디자인을 통계기법으로 극복해낼순 없다. -&gt; 처음부터 잘 골라서 연구설계해야한다. | . | . &#50672;&#44396;&#45824;&#49345;&#51088; . 알고 싶은 환자군 전체 Target population이 있고 | 그 전체를 알 수 없으니 일부를 뽑은 게 study sample(study subjects)이라 한다. 연구계획서는 study sample이 어떤 집단이 될 것인지 적어야한다. | 반드시 inclusion/exclusion criteria(크라이테리아)로 명시해줘야한다. | . | . inclusion criteria . 인구학적 특성: 성별/나이에 대한 것 | 임상적 특성: 내가 관심있는 질병에 따라 결정되어지는, 대상의 임상기준? | 지리학적 또는 행정적 특성: 내가 실제 연구 수행하는 장소와 시간 | 시간적 특성: 내가 실제 연구 수행하는 장소와 시간 | exclusion criteria . 연구대상자가 안되는 사람의 기준 | . . Follow Up 안될 가능성이 높은 사람은 제낀다. ex&gt; 알콜중독자, 이사갈 사람 | 양질 데이터 제공이 어려운 사람은 제낀다. ex&gt; 언어 문제, 지적장애인 | (drug study시) adverse effects를 겪을 가능성이 높은 사람은 제낀다 ex&gt; 암환자, 임산부 | 연구 해부도에서, 가운데 부분이 연구대상자 내가 알고 싶은 타켓파풀레이션 | 그 중 일부를 어떻게 뽑겠다 계획 | 실제 recruit되는 환자 간격을 줄여야한다. | . | . | . 예시 chd환자 전체(타겟 파퓰레이션)를 보고 싶지만 | 실제로는 recruit하게 되는(인텐디드 샘플) 내가 일하는 곳의 intended sample으로만 제한된다 타겟 파퓰레이션과 괴리가 생기게 된다. -&gt; 이 차이를 줄이기 위해, 모든병원 or 병원 갯수를 늘리는 식으로 노력하여 더 제네럴라이즈하게 시도할 수 있지만, 비용과 시간과 노력이 많이 들게 된다. | 즉 external validity를 맥시마이즈 하는 것이 중요하지만, 비용/시간/노력의 문제 때문에 적당한 타협점을 찾아야한다. | . | recruit하려고 했던 subjects들 중에 실제로 연구에 동의(액츄얼 스터디 샘플)해서 데이터를 제공한 환자들을 Actual Study sample이라고 한다. intended sample과 차이가 있을 수 있는데, 차이가 적을 수록 좋다 | 만약, recruite하려고 하는 사람들 중 매우 일부만 동의 등으로 차이가 커질 수록 internal validity가 해를 입게 된다. | . | . | . &#48320;&#49688; . outcome: 결과변수, 반응변수 관심 질병유무 /심각도/이벤트 유무/건강상태 | . | 설명변수: 독립변수 . outcome과 관련되는 여러가지 factor들 . . | . | &#53685;&#44228;&#51201; &#44256;&#47140;&#49324;&#54637; . 가설: 가장 중요한 것으로서, research question을 통계적으로 testable한 가설로 바꿔줘야한다. . 귀무가설과 대립과설이 무엇과 무엇인지 / 어떻게 검증할 것인지 나와야한다. | . | 통계분석 계획: 가설이 나오난 뒤에, 이 가설을 어떤 테스트로 검정할 것인지 정하는 것 . 가설 증명을 통한 r.q.에 답하기 위한 통계적 방법을 구체적으로 기술해야 됨. | . | 연구 대상자 수: 위에서 정해진 통계적 방법이, 가설을 증명하기 위해 필요한 샘플 사이즈 . 내가 보이려고 하기 위한 대립가설이 사실일 경우에, p밸류가 0.05보다 작게 나올 확률인 power가 80~90%로 확보되기 위해서 몇명의 환자를 조사해야하는지 | . | . &#51076;&#49345;&#50672;&#44396;&#51032; &#45800;&#44228; . &#45800;&#44228; . 딱 정해진 것은 없지만 3가지로 책에서 서술한다. | . . 디스크립티드 스터디: 관심있는 질병과 특성이 and/or 어떤 식의 분포로 나타나는지 기술하는 스터디 . 관심 질병= 미표기 or 관련 특성=한국 CHD환자의 일주일당 생선섭취량 | 이러한 현상이 있다. | . | 애널리틱 스터디: 관심 질병과 관련 특성의 상관관계/인과관계가 있는지 보는 연구 . 관심 질병= 심장발작여부와 - 관련 특성=한국 CHD환자의 일주일당 생선섭취량이 관련있는가? . | 상관 관계가 확인이 되면 (-&gt; 인과 관계가 먼저 완전히 확립되면 더 좋겠지만), 인과 관계를 확립을 확실히하기 위해 아래 다음단계인 클리니컬 트라이얼스로 넘어간다. . | . | 클리니컬 트라리얼스: 관심있는 intervention이 추가되어 그 효과를 확인하는 연구이다. . 특히, RCT를 하게되면 인과관계를 확실히 확인할 수 있다. | 한국 CHD환자 대상 - 인터벤션1:fish oil보충제 vs 플라시보 투약한 것에 비해 outcome이 좋은가?(심장발작 횟수가 줄어드는가?)를 진행한다. | . | 교수님 생각으로 전계되는 단계 | . 처음 내가 관심있는 현상에 대해서 디스크립션해야한다 | 그 다음에는 관심있는 특성과 관심있는 질병과의 어쏘시에션(상관관계)를 보게 된다. | 어쏘시에션을 확인한 상태에서 코잘리티(인과관계)를 보고 넘어가는 경우 vs 코잘리티를 못보고 넘어가는 경우가 있다 . 프리딕션 모델로 가는 경우 2가지 . 관심질병-관심인자(특성)과의 어쏘시에이션이 충분히 보였다 -&gt; 코잘리티를 굳이 보이지 않더라도, 상관관계 높은 인자를 이용한 예측모델을 만들 수 있다. association모델에서 바로 prediction모델로 갈 수 있다.! | . | 어쏘시에이션 -&gt; 여러 방법을 통해 코절하다고 결론이 나온 경우 -&gt; 프리딕션으로 넘어가기 | | 인터벤션 리서치로 넘어가는 경우 2가지 코잘리티를 확실하게 보이지 않더라도, 단지 상관관계만 보인 상태에서, 인과관계가 있을 것이라는 강한 믿음 or 근거를 가지고 intevention으로 넘어가기 | 어쏘시에이션 확인 후, 여러 통계기법 + 정황으로 코잘리티를 보인 상태에서, 인터벤션으로 넘어가기 | | | 인터벤션(주로 RCT로 함)의 효과가 확인되었다면, 같은 인터벤션에 대한 효과들을 모아 메타분석을 한다. 같은 인터벤션이지만, 다른 위치, 환자군 등을 모아봄 | . | 내가 연구하려는 주제가 있을 때, 어느 정도까지 연구되어있는지 임상연구의 단계를 찾아보고, 다음 단계에서 내가 해야할 것은 무엇인지를 확인하면 된다. 예를 들어, association이 밝혀지지 않은 주제 -&gt; 바로 RCT나 Prediction하도록 단계를 건너띄어선 안된다. | . | . &#49345;&#44288;&#44288;&#44228;&#50752; &#51064;&#44284;&#44288;&#44228; . &#49345;&#44288;&#44288;&#44228; vs &#51064;&#44284;&#44288;&#44228; &#50696;&#49884; . 어떤 자료 2개가 상관관계가 엄청 높았다 -&gt; 바로 인과로 가면 안된다. 우주기술에 투자할수록 -&gt; 자살률이 높다?? -&gt; 이렇게 결론 내리진 않는다. | 우연에 의한 것인지 확인? / 시간이라는 컨파운딩 팩터가 있어서 시간이 증가하면서 경제 발달 -&gt; 정부는 투자많이 / 인구늘어남 -&gt; 자살수 늘어남 | . | 컨파운더에 의한 상관관계로 결론 | . | . . 상관관계가 관측됨 이 상관관계가 진짜인가? /우연 or 잘못된 연구디자인 때문은 아닌가부터 의심한다 | . | 진짜 상관관계가 판단됨 a가 b를 일으키는 코잘리티인가? / [보이지 않지만, 실제 b를 일으키면서 &amp;&amp; 동시에 a에도 영향을 주고 있는 confounding factor]때문에 생겨난 서로간의 인과관계는 없지만 [보이는 상관관계]인지판단 해야한다 | . | &#49345;&#44288;&#44288;&#44228; &#48156;&#44204;&#49884;, &#53076;&#51096;vs&#52980;&#54028; &#50696;&#49884; . 연구했는데 커피 -&gt; 췌장암의 상관관계가 있는 것으로 관측되어었다(상관관계가 진짜이라고 가정) 커피섭취가 -&gt; 실제로 췌장암에 영향을 미치는 코절리티가 있는 경우 | 보이지 않는 컴파운딩 팩터 때문에, 인과없이, 보이기만 하는 상관관계인 경우 보이지 않는 흡연이라는 실제 췌장암의 증가원인 &amp;&amp; 커피 섭취의 증가원인인 컴파운딩 팩터가 있음 | 흡연하는 사람이 커피를 많이 마시는 경향도 있어서, a와 b 둘다 영향을 주기 때문에, 커피섭취가 -&gt; 췌장암에 영향을 주는 인과가 없더라도 해당 보이는 상관관계를 유발시킨다. 커피-&gt;췌장암 영향 있을 수도 없을 수도 있지만, 컨파운딩 때문에 이렇게 보이는 상관관계를 만드는게 아닌가 고민을 해봐야한다. | . | . | | . &#51064;&#44284;&#44288;&#44228; &#54032;&#45800; &#44032;&#51060;&#46300;&#46972;&#51064; . 인과관계 판단이 쉽지 않으므로, 담배-&gt;폐암 인과증명시 제시 된 것들이다. | 하지만, 칼같이 정해지는 것이 아니라 종합적으로 고려되어야한다. 시간이 지나면서 계속 수정되고 있다. | . 템포럴 릴레이션쉽: 선후관계가 명확해야한다. 원인이 선행해야한다. | . | 상관관계가 강해야한다. 약한 순간 인과관계이긴 어렵다 | . | 도스-리스폰스 릴레이션쉽: . 세부 섭취량(음식)/투약량(약)에 따라 outcome과 관련있어야한다 | 인과관계가 확실한 경우에도 나타나지 않는 경우도 있으니 100% 만족안해도 된다. ex&gt; 적은 양에는 효과X -&gt; 역치 넘으면 효과O 있는 경우, -&gt; 인과는 있는데 적은량에서는 dose가 무시됨 | . | . | 레플리케이션 오브 파인딩스: . 내 연구에서 상관관계-&gt;인과관계를 발견했어도, 바로 인과관계 있다고 말할 수 없다. 다른 연구/환자군/서브그룹에서도 일관된 상관관계가 나타날 때 -&gt; 인과관계 있다고 말할 수 있다. | . | 바이얼로직 플러져빌리티: 생물학적 그럴듯한 설명이 있어야한다. . | 컨시덜레이션 오브 얼터네이트 익플레내이션스: 다른 설명이 가능한지도 살펴봐야한다 . 인과관계가 아니라 사실은 다른 컨파운딩이 숨어있는 것은 아닐까? | 인과가 뒤바뀐 것은 아닐까? | . | 쎄세이션 오브 익스포져: 원인이 되는 exposure 중단시 -&gt; 결과도 중단 되어야한다. . 하지만, 도스-리스폰스 릴레이션쉽처럼, 인과관계일 때도 성립안하는 경우가 가끔 있다. 흡연이 -&gt; emphysema에 영향을 미치는 인과는 사실이나 | 흡연 중단 -&gt; emphysema 해결은 안된다. | . | . | 컨시스턴시 위드 아덜 날러지: 이 질병/환자군에 대해 알고 있는 다른 지식과 컨시스턴시 해야한다 . | 스페서피서티 오브 더 어소시에이션: . 원인이 일으키는 결과가 1개 여야한다. 다른 결과들도 일으키면 안된다. | 회색: 논의가 많이 되는 부분이다. ex&gt; 미국담배회사: 담배 -&gt; 폐암외 여러질병일으킴 -&gt; 스페서피서티 오브 더 어소시에이션를 만족하지 않으므로 인과관계 아니라고 주장함. | . | . | 다른 가이드라인이 많고, 절대적인 기준은 없다. | 우리 데이터가 가진 전체적인 패턴을, 다른 지식과 종합해서 인과관계인지 판별해해야한다. | . &#51221;&#47532;&#54616;&#44592; . 임상연구는 사람의 질병을 이해, 예방, 치료하고 건강을 증진하기 위한 학문이다. . 사람에 대한 학문이다. | . | 좋은 임상연구는 validity가 최대화된 연구이다. . Internal validity는 연구 내에서 일어난 일에 대해 올바른 결론을 내렸는가에 관한 것이고, | External validity는 연구 결과가 연구 밖 real world에 적용될 수 있는가에 관한 것이다. 두 validity를 최대한 연구가 좋은 연구이다 | . | . | 연구계획서는 연구의 구조가 적혀있는 설계도이다. 연구계획서는 . 연구질문(research question), | 연구 배경과 중요성, | 디자인, | 연구대상자, | 변수, | 통계적 고려사항으로 이루어진다. | . | 임상연구의 많은 부분은 상관관계를 확인하고 그로부터 인과관계에 대한 추론을 끌어내기 위한 노력이며, 경우에 따라 예측모델이나 중재연구(intervention study)의 단계로 이어진다. . | 상관관계로부터 인과관계를 성립시키기 위한 몇가지 기준이 있지만, 기계적으로 적용하여 인과관계가 있다고 결론내릴 수 있는 절대적인 기준은 없으며, 관측된 데이터의 전체적인 패턴을 종합적으로 고려하여 인과관계에 대한 결론을 내려야 한다. . | &#53300;&#51592;&#47784;&#51020; . . . .",
            "url": "blog.chojaeseong.com/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EC%9E%84%EC%83%81%EC%97%B0%EA%B5%AC/2022/03/07/%EC%9D%98%EC%97%B0%EB%B0%A901)-%EC%9E%84%EC%83%81%EC%97%B0%EA%B5%AC-%EC%86%8C%EA%B0%9C.html",
            "relUrl": "/r/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/%EC%9D%98%EC%97%B0%EB%B0%A9/%EC%9E%84%EC%83%81%EC%97%B0%EA%B5%AC/2022/03/07/%EC%9D%98%EC%97%B0%EB%B0%A901)-%EC%9E%84%EC%83%81%EC%97%B0%EA%B5%AC-%EC%86%8C%EA%B0%9C.html",
            "date": " • Mar 7, 2022"
        }
        
    
  
    
        ,"post120": {
            "title": "TDD 5 로또(Method부터 시작)",
            "content": "메서드의 파라미터(값-&gt;일급) 및 응답값(제한된 종류의 분기 응답) 포장시 TDD . 메서드의 파라미터(값-&gt;일급) 및 응답값 포장시 TDD [메서드 내부 포장후 -&gt;새 기준메서드 호출] 및 [Client 배려 by 메서드 파라미터 포장 완성된 후 client일급생성 내부(List.of)부터 가변인자 생성자 추가] . 01 메변1) 검증 등 필요에 의한 값 포장시, [메서드복붙]후 [파라미터 수정] -&gt; 에러해결 -&gt; client 인자 변경 . 기존 테스트들이 인자를 안바꿔도 유지되도록 전체 복사후 인자만 바꾼 새 기준 메서드를 만들고 에러 해결후 포장 객체로 메서드 호출 변경 . 기존 테스트는 유지한 체 값List를 받다가 . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { . | 새 테스트에서 검증 등 필요에 의해 값을 1개 포장 . final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, new LottoNumber(100)) . | 포장 Class, ClassTest생성 . public class LottoNumber { private final int value; public LottoNumber(final int value) { this.value = value; } } . class LottoNumberTest { } . | 객체비교를 위해, equals,hC 오버라이딩 . | 메서드 복붙 -&gt; 파라미터 정의 변경 . public static int start(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { . | 검증 요구 새 테스트에 한해, 복붙한 새 메서드 인자를 포장시키도도록 노가다 . @Test void over() { assertThatThrownBy(() -&gt; LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(100)), List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(7)), new LottoNumber(6) )).isInstanceOf(IllegalArgumentException.class); } . | 검증, 필요에 의한 포장 테스트 -&gt; thr 나야 통과하는 테스트 . 포장 생성자에 검증을 안 넣어준 상태므로 테스트를 통과못한다. | 원래 포장 객체 생성자 1개로만 테스트를 해야하는데, 여기서는 메서드 전체 호출로 퉁친다. | . | 02 도메인 속 검증 등 포장에 의해 thr나는 메서드() 테스트 작성 . 생성자 쪽에서 validate해준다. . public LottoNumber(final int value) { validate(value); this.value = value; } private void validate(final int value) { if (value &lt; 1 || value &gt; 45) { throw new IllegalArgumentException(&quot;로또 번호의 범위가 아닙니다.&quot;); } } . | 테스트해서 thr나게 된다. . @Test void over() { assertThatThrownBy(() -&gt; LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(100)), List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(7)), new LottoNumber(6) )).isInstanceOf(IllegalArgumentException.class); } . | 03 (필요에 의해 포장이 발생된) 메서드 테스트를 넘어서서 도메인 전용Test에서 경계값들 테스트 . class LottoNumberTest { @ParameterizedTest @ValueSource(ints = {0, 46, -1, 100}) void range(final int value) { assertThatThrownBy(() -&gt; new LottoNumber(value)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;범위&quot;); } } . 04 메변2) [기존 rawInput메서드]는 [파라미터만 유지]한체 내부에서 포장 -&gt; 새 기준 메서드 호출 하는 [포장후 호출메서드]로 변경 . rawInput을 받는 곳의 파라미터명에 raw를 달아 -&gt; 원래 네이밍은 포장후 변수로 받아줄 준비를 한다 . public static int match(final List&lt;Integer&gt; rawUserLotto, final List&lt;Integer&gt; rawWinningLotto, final int rawBonusNumber) { . | 내용물에 대해선 포장된 것으로 처리되는 메서드가 남아있으니, rawInput은 받아서 stream().map(포장생성자).collect()의 List&lt;포장&gt;만해서 그쪽으로 넘겨주기만 한다. . public static int match(final List&lt;Integer&gt; rawUserLotto, final List&lt;Integer&gt; rawWinningLotto, final int rawBonusNumber) { final List&lt;LottoNumber&gt; userLotto = rawUserLotto.stream() .map(LottoNumber::new) .collect(Collectors.toList()); final List&lt;LottoNumber&gt; winningLotto = rawWinningLotto.stream() .map(LottoNumber::new) .collect(Collectors.toList()); return match(userLotto, winningLotto, new LottoNumber(rawBonusNumber)); } . | 요약: 값을 단일객체 포장한다면, 메서드복붙후 포장인자 -&gt; 에러처리 -&gt; rawInput메서드는 내부포장용으로 변경 . 05 메변3) 객체간 검증(갯수, 중복) 등 필요에 의해 List.of앞에 [new 일급()]으로 포장 . [메서드 수정]은 포장후 기준호출해주는 메서드가 아니라 포장인자를 받는 기준 메서드로 . 기준메서드에 List.of( 단일, 객체, 들) -&gt; 갯수 초과 유발(필요에 의한 검증) . rawInput을 받아 포장후 기준메서드 호출해주기도 하지만, 제깍적인 수정을 위해서 포장된 인자를 직접 받아서 내부에서 바로 처리하는 메서드를 수정해줘야한다. . 하나하나 다 쏴줘야, 메서드는 그렇게 오는지 알 수 있다(노가다) | . @Test void lotto7() { assertThatThrownBy(() -&gt; LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6), new LottoNumber(7)), // 갯수 초과 . 갯수를 초과해서 넣었다. 에러가 나야 통과인데, 현재는 에러가 안날 것이다. 포장해야한다. | . | 파라미터의 갯수 검증은, 받는 메서드 내부에서도 해줘도 될 것 같지만.. [검증은 다 쏴서 포장한 도메인 생성자에서] . 관련 로직도 아닌데, if가 계속 쌓이게 될 것이다. 메서드 내 파라미터를 받아 검증하는 것을 지양하자. | 검증이 필요하면, 포장 -&gt; 도메인 분리 -&gt; 도메인 생성자에서 | . | . 복수개 검증을 위해 List.of( ) 앞에 new 일급() 생성자를 씌워서 포장 시작 . 객체List인 List.of()를 new일급() 생성자를 씌워 일급객체를 만든다. . @Test void lotto7() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(2), . | 일급객체도 상태가 1개 라면, value로 네이밍 -&gt; 나중에 .getValue()로 getter를 쓸 생각 . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final List&lt;LottoNumber&gt; value) { this.value = value; } } . | 검증의 순서는 중복검사보다는 갯수가 있다면 갯수가 먼저다 . public Lotto(final List&lt;LottoNumber&gt; value) { // 중복검사(distinct.count != )보다 갯수검사(size != )가 선행되어야 한다. // (1) 일단 6개가 들어오고 -&gt; 거기서 중복검사 해야한다. // (2) 7개가 들어왔는데 -&gt; 중복검사 해봤자 의미 없다. if (value.size() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개여야 합니다.&quot;); } if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 중복해서 입력할 수 없습니다.&quot;); } this.value = value; } . | 또다시 기존 메서드 유지되도록 전체복사후 인자만 바꾼(list-&gt;포장) 새 기준메서드만들고 -&gt; 에러해결(.getValue()) -&gt; client 호출 변경 . 복붙후 파라미터 변경 . public static int start(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { . | **내용물들은 일단 list에 난 빨간줄을 .getValue()를 붙여서 해결한다. ** . 나중에 도메인 로직으로 들어갈 후보들이다. . 도메인에 넣으면 getter없이 바로 value를 쓰게 된다. | . . | 앞에 getter를 붙이면 빨간줄이 사라진다. . . | . List.of(단일, 객체, 들)을 모두 new일급() 다싼 뒤 -&gt; List&lt;단일&gt;메서드의 파라미터 . | 06 새 기준(일급) 메서드 에러 제거(getValue()) 후, 도메인(일급)에 [필요에 의한 검증(갯수)]시 에러나도록 도메인 검증 작성 -&gt; 메서드 테스트로 퉁치기(일급자체 테스트는 client배려로 test도 배려되면) . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), new Lotto(List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6))), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class) } . 아직!) 일급자체Test List.of() 제거된 가변인자 등의 client 배려(내려가며 생성자 추가) 끝나고 일급 도메인 테스트 하자! . 07 새 기준 메서드(일급이 파라미터, 수정 등 적용 대상) 완성 -&gt; 기존 메서드의 내부에서 포장해서 새기준을 호출하도록 변경 . 변경 전: 파라미터는 포장 전인데, 모든 로직이 다 있는 상태 . | 변경 후: 일급을 파라미터로 받는 이후 수정 등이 적용될new 기준 메서드을 내부에서 호출하도록, 파라미터만 유지해서 기존 테스트코드들 유지 . public static Rank match(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { // 이제 로직은 새 기준메서드에 양보됨. // 새 기준 메서드(포장객체)를 내부에서 호출만 해줌. return match(new Lotto(userLotto), new Lotto(winningLotto), bonusNumber); } . | . 08 client배려1) 메서드 이전 [단일... 가변인자 일급 생성자를 추가]하는데, client List.of ()입력 제거 -&gt; List&lt;단일&gt; to 단일... 파라미터 -&gt; 내부에서 list포장후 기본생성자 호출 . 현재 client 호출 . LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), . | . 일급의 기본 생성자는 그대로 단일List + 검증로직을 보유하고 있는다. . 기존 일급 기본 생성자: 단일List + 검증 로직이 모여있다. 계속 유지되어서 호출되어야한다. . public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . | . client배려 1번은 호출시 clinet가List을 제거하고 -&gt; 파라미터에 가변인자를 받도록 한 뒤 -&gt; 내부에서는 가변인자(배열)을 List로 포장해서 this()로 호출하도록 일급 생성자 추가 . . 추가된 일급의 가변인자 생성자 . public class Lotto { private final List&lt;LottoNumber&gt; value; //단일객체를 가변인자로 받도록 생성자 추가 public Lotto(final LottoNumber... value) { this(Arrays.stream(value).collect(Collectors.toList())); } public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . | . 요약: 기본생성자(단일객체List + 검증) 외에 가변인자(단일객체...) 생성자를 만들어 client의 List.of()호출부터 제거하자. . 가변인자로 내부에서 List화 -&gt; client List.of()가 제거된 모습 . LottoService.start( new Lotto(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), . | . 09 client배려 2) 단일... 가변인자 일급생성자 직후 바로 값... 가변인자 일급생성자를 추가한다. . new 일급( List.of( 단일, 객체) ) new 일급( 단일, 객체 ) : by 단일... 가변인자 + stream List포장 후 this기본생성자 호출 new 일급( 값1, 값2 ) by 값.. 가변인자(int라면 Integer…) + stream map단일객체생성 -&gt; List포장후 this기본생성자 호출 | . | . | 단일… 가변인자 -&gt; 단일객체stream -&gt; 단일객체List가운데 단일객체stream을 값... 가변-&gt; 값 stream + map으로 만들수 있으니 값… 가변 생성자도 추가 . public class Lotto { private final List&lt;LottoNumber&gt; value; //2. new Lotto( 원시값, 가변으로) -&gt; List.Of() + new단일()생성자 제거 public Lotto(final Integer... value) { this(Arrays.stream(value).map(LottoNumber::new).collect(Collectors.toList())); } //1. new Lotto( 단일객체, 가변으로) -&gt; List.Of제거 public Lotto(final LottoNumber... value) { this(Arrays.stream(value).collect(Collectors.toList())); } public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . | . . stream에서 mapToObj가 뜨는 이유는 integer가 아닌 int -&gt; 객체로 가기 때문 -&gt; 애초에 파라미터로 들어오는 원시값들을 int… 대신 Integer...로 box된 타입으로 받을 수 있다. . . 이제 원시값으로 일급을 만들 수 있게 된다. . . 요약: 값... 가변-&gt; 값 stream + map으로 단일... -&gt; 단일객체stream을 만들수 있으니 값.. 가변인자 생성자 추가해서 clinet의 단일...가변입력도 값... 입력으로 대체하자 . 메서드 테스트로 퉁 | . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1,2,3,4,5,6), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class); } . 요약2: 메서드 파라미터 포장이 끝난 직후부터, client배려1 List.of 제거 by 단일... -&gt; client 배려2 new단일() 제거 by 값... . 10 일급자체(경계값)Test는 client배려1,2가 끝난 뒤 -&gt; new 일급 ( 값 가변인자) 로 하면 편하다 . 개수(count) 검사 -&gt; 중복(duplicate) 검사 순으로 . @Test void count_valid() { assertDoesNotThrow(() -&gt; new Lotto(1, 2, 3, 4, 5, 6)); } @Test void count_under() { assertThatThrownBy(() -&gt; new Lotto(1, 2, 3, 4, 5)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } @Test void count_over() { assertThatThrownBy(() -&gt; new Lotto(1, 2, 3, 4, 5, 6, 7)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } @Test void duplicate() { assertThatThrownBy(() -&gt; new Lotto(1, 1, 3, 4, 5, 6)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } . 11 메서드 내부 일급.getValue()는 메서드화하여 도메인내부 로직으로 옮겨갈 후보들 . 일급.메서드( 객체 )로 메세지를 던질 때, 일급을 좌항(메서드 호출하는 놈) 우항에는 내부 찢어질 일급 or 단일(파라미터)을 배치하여 value.list메서드()를 사용하며, 재활용 가능성을 생각하자. . 일급.getter vs 일급 or 일급.getter vs 단일 로직이면 메서드화해서 도메인 로직으로 옮겨가는데, 일급vs일급부터 처리한다. . 일급.메서드( 찢일 or 단일) -&gt; value(일급내부 list).입장에서 넘어온or넘어와돌고있는 단일을 List(value)의 메서드로 컨트롤할 수 있다. | . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { //일급내부list. list메서드 ( 단일 ) if (value.contains(lottoNumber)) { matchCount += 1; } } return matchCount; } . | 일급.getter() vs단일이 외부에 존재했다면 메서드화 하면 . value. list메서드( 단일 )로 내부정의 되므로 일급vs일급 중 value.list메서드( 돌고있는 단일)로 메서드가 재활용 될 가능성이 있으니 잘 확인해서 대체해주면 된다. | . public boolean contains(final LottoNumber number) { return value.contains(number); } . | . 일급.list메서드( 단일 )의 메서드가 추가된다면, -&gt; 내부 상태(value)를 사용하는 내부 정의 메서드인 객체없이 호출되는 메서드가 value.list메서드( 단일 )을 대체한다. . value.contains( lottoNumber ) -&gt; contains(lottoNumber) . 객체없이 호출되는 메서드가 있다면 내부에서 정의된, 내부 상태(value)를 이용하는 메서드로 생각하자. (this.)value가 쓰이는 메서드구나 | . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { //if (value.contains(lottoNumber)) { // 객체없이 호출된다? 내부상태가 쓰이는 내부 정의 메서드구나~! if (contains(lottoNumber)) { matchCount += 1; } } return matchCount; } . | . 응답값 포장 . 12 응답값도 포장할 수 있다. 만약, 제한된 종류 + if분기마다 달라지는 응답값라면 ENUM응답 포장후 응답에 필요한 input들로 정펙매 를 호출한 뒤 내부로 분기 옮겨 응답한다. 이후 if분기를 처리해줄 &lt; input-&gt;필드들 - 응답값&gt;을 매핑한다. . int를 포장한 뒤 -&gt; 관련된 if분기 로직을 포장한 도메인으로 넘기면, 메서드 if문이 사라진다., | . . 제한된 종류의 응답 값포장은 Enum을 활용한다. 메서드 응답을 빨간줄로 바꿔 생성하자. . 만약, 제한되지 않았다면? class Rank로, 현재는 제한된 종류의 값 응답이므로 Enum으로 매핑해서 if를 대신하게 해보자. . . | 연속된 상수라면, Enum명_ 순서를 활용하면 된다. . 1,2,3,4,5등 -&gt; 등을 Enum으로 만들고 등_1,2,3,4,5; 로 선언해보자. | . package lotto; public enum Rank { RANK_1, RANK_2, RANK_3, RANK_4, RANK_5; } . | . 13 응답에 대한 분기로직을 어떻게 응답class/응답Enum으로 넘길까? . . 메서드 응답부에서 원하는 포장된 응답값인 Enum객체을 뽑아 응답해주는 return Enum.정펙매of (,)완성하기 . 결과적으로 정펙매인 Enum.from() or Enum.of( , , )로 Enum객체를 응답해야한다. . 원하는 Enum객체가 응답될 수 있도록 필요한 인자들을 생각해서 받아들인다. | 실제로 입력값이 될 것들을 가지고 있는 사용부인 메서드 응답부에서 부터 시작 | . | . 응답부에서 Enum.정팩메로 해당하는 포장응답값을 return해 줄 예정이다. . 필요한 input들이 뭐가 있는지 살펴본다. | 메서드호출의 결과값이 있다면, input이 명확하도록 따로 변수로 뽑아주자. | . . 정팩메로는 Enum이라는 포장된 응답값을 가져올 것이기 때문에 return과 같이 작성한다. | . . | 값 응답 로직을 -&gt; 포장응답값 정펙매로 잘라내서 처리하기 . 이제 값 응답로직을 그대로 잘라붙혀넣기 한다. . 이동후 | . . | 14 정팩메 내부로 옮긴 분기에 대해, 응답[값]들을 [Enum객체]로 수정해주기 -&gt; 없는 값(0, None)에 대해서도 OUT,NONE객체 만들어서 응답해주기 . 아직 바꾸기 전 응답로직 . if (matchCount == 6) { return 1; } if (matchCount == 5 &amp;&amp; matchBonus) { return 2; } if (matchCount == 5) { return 3; } if (matchCount == 4) { return 4; } if (matchCount == 3) { return 5; } return 0; . | 수정 + NONE객체 추가후 . package lotto; public enum Rank { RANK_1, RANK_2, RANK_3, RANK_4, RANK_5, OUT; public static Rank of(final int matchCount, final boolean matchBonus) { if (matchCount == 6) { return RANK_1; } if (matchCount == 5 &amp;&amp; matchBonus) { return RANK_2; } if (matchCount == 5) { return RANK_3; } if (matchCount == 4) { return RANK_4; } if (matchCount == 3) { return RANK_5; } return OUT; } } . public static Rank match(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { final int matchCount = userLotto.match(winningLotto); final boolean matchBonus = userLotto.contains(bonusNumber); return Rank.of(matchCount, matchBonus); } . | . 15 메서드 [포장된 응답] 테스트 작성하기 . 여러분기므로 1case에 대한 -&gt; 1예상값 마다 테매를 작성해야한다. . @Test void match_1() { //given, when final Rank rank = LottoService.match( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1, 2, 3, 4, 5, 6), new LottoNumber(7) ); //then assertThat(rank).isEqualTo(Rank.RANK_1); } . 16 if분기를 enum정팩매 내부 values().stream+filter( 정펙매input vs 매핑값과 비교 조건식)으로 제거하기 . 정팩메 input으로 들어올 데이터들 中 1개를 골라 (매핑 예정인) Enum객체의 필드로 넣어준다. . 정펙매로 여러 데이터가 들어와 사용가 들어오지만 of( matchCount, matchBonus) . . 매핑에 사용될 쉬운 변수 1개만 선택하여, 정펙매 내부 values().stream.filter 분기에서 비교할 것이다. Enum객체가 필드로 가지고 있으면 되며, 그 필드 기준으로 매핑값도 차후 배정된다. | . | . 쉽게 Enum의 필드에 넣기 위해서는 일단 ENUM(1) 객체 옆에 빨간줄로 원시형 예제작성해준다. . . | 생성자를 생성해주면서 input과 똑같이 네이밍후 빨간줄 this.필드명 = 필드; 초기화를 이용해서 필드를 생성한다. . . . . | 나머지 객체도 데이터를 넣어준다. . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0); private final int matchCount; Rank(final int matchCount) { this.matchCount = matchCount; } public static Rank of(final int matchCount, final boolean matchBonus) { if (matchCount == 6) { return RANK_1; } . | Enum정팩메 내 [제한된종류의 모든 if분기]를 values().stream + filter with input vs 매핑field로 분기 없애기 . 특수한 경우, 정팩매에서 ENUM매핑값 뽑기도 전에, early return해준다. . 특수한 경우로서 2등과 3등을 먼저 필드는 안됬지만 사용해야하는 변수 matchBonus로 홀로 true인 2등을 early return한다. . public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } . | . Enum내에서 values()는 Enum객체배열을 응답하며 거기에 배열.stream자동완성 사용하여 EnumStream 만들어 객체전체를 돌리기 . . . . 제한된 종류의 if분기를 values().stream (for) + filter(it -&gt; input vs 매핑field 비교) 대체하기 . public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); . 기존 if분기들 이제 삭제 | . enum sense: 각 enum객체끝은 마지막도 콤마(,) 그 다음라인(;) + .findAny()후 .orElse( NONE객체 ) . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0), ; . return Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); . 17 Bi(비.아이.) Predicate&lt; , &gt;로 input된 2개 값을 다 사용하는 1개의 람다식필드 &amp;&amp; filter속 예비 조건식(.test(a,b)로 실행)을 만들어 -&gt; [enum의 1 필드 매핑]에 사용되는 Type을 함수형인터페이스로 사용하여 -&gt; 정펙매 내부 들어오는 2개값 모두 사용하는 enum 만들기 . BiPredicate Type은 1개 함수를 가진 인터페이스 = 함수형 인터페이스 중 2개 인자를 받아 실행대기 중인 조건식을 제공해주고 -&gt; .test( a, b)를 통해 외부인자를 받아서 조건식을 실행한다. .test(a, b)에 정팩메로 들어온 input2개를 넣어주면 된다. | . | . 아직 BiPredicate 적용안한 기존 코드 (상금도 매핑 안된 상태) . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0), ; private final int matchCount; Rank(final int matchCount) { this.matchCount = matchCount; } public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } return Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); } } . Enum필드에 2인자 람다식인 BiPredicate를 넣어서 생성하기 . 이번엔 Enum()객체안에 input 중 1개 6,5,4.. 대신에 input 2필드 다 써서 1개 람다식을 만들어 예제로 넣어주자. 이왕이면 다중커서로 한번에 다 입력해주자. | . | 아쉽게도 BiPredicate는 직접 필드입력 -&gt; private final 필드 변수 생성 -&gt; 생산자 자동완성로 가야한다. (원래는 예제 -&gt; 생산자 -&gt; 빨간줄 this.필드 생성) . 원래 객체( 원시값 등 쉬운 Type)을 빨간줄 필드로 넣으면, 생성자에 파라미터 공짜 -&gt; this.로 필드 공짜 생성 | . BiPredicate 작성 . 받은 인자 2개는 if분기에 쓰였던 input값 2개다. -&gt; 원래 Enum의 매핑 쉬운 상수 응답값 6, 5, 4...와 비교해야한다. | . public enum Rank { RANK_1(((matchCount, matchBonus) -&gt; matchCount == 6)), RANK_2((matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; matchBonus), RANK_3((matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; !matchBonus), RANK_4((matchCount, matchBonus) -&gt; matchCount == 4), RANK_5((matchCount, matchBonus) -&gt; matchCount == 3), OUT((matchCount, matchBonus) -&gt; matchCount &lt; 3), ; . | 필드 직접 입력 private final . 제네릭 타입은 들어올 인자들의 Type(정팩메로 들어올 Type)을 Boxing한 타입 + 네이밍은 condition으로 실행될 조건식임을 인지시킴 | . private final BiPredicate&lt;Integer, Boolean&gt; condition; . . | 생성자 자동완성 . | values().stream + filter분기에서 .test( , )로 정펙매 인자를 받아 조건식 실행 . public static Rank of(final int matchCount, final boolean matchBonus) { return Arrays.stream(values()) .filter(it -&gt; it.condition.test(matchCount, matchBonus)) .findAny() .orElse(OUT); } . 18 응답값의 포장(리팩토링)이 다 끝났으면, 자체 도메인Test(Enum은 정펙매 테스트) . @Test void rank_1() { final Rank rank = Rank.of(6, false); assertThat(rank).isEqualTo(Rank.RANK_1); } @Test void rank_2() { final Rank rank = Rank.of(5, true); assertThat(rank).isEqualTo(Rank.RANK_2); } @ParameterizedTest @CsvSource({&quot;5,false,RANK_3&quot;, &quot;4, false, RANK_4&quot;, &quot;3, false, RANK_5&quot;}) void rank_3_5(final int matchCount, final boolean matchBonus, final Rank expected) { final Rank rank = Rank.of(matchCount, matchBonus); assertThat(rank).isEqualTo(expected); } .",
            "url": "blog.chojaeseong.com/java/enum/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/07/TDD-5-%EB%A1%9C%EB%98%90(Service.method%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91).html",
            "relUrl": "/java/enum/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/03/07/TDD-5-%EB%A1%9C%EB%98%90(Service.method%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91).html",
            "date": " • Mar 7, 2022"
        }
        
    
  
    
        ,"post121": {
            "title": "강의) 네오 2단계 로또 피드백",
            "content": "세팅 . 패키지 생성 (각종 설정 후) . 프로젝트 생성 했다면 . main&gt;java와 | test&gt;java 밑에 패키지 생성(lotto)부터 해주기 | . | 시작점 고르기 (game, service) . 시작점 찾기 로또번호부터 구현할 수 있느냐? | 로또부터? | 정제된 rawInput을 받은 Game, Service부터 구현해서 객체/도메인도출을 천천히 처음부터 객체 도출은 어려울 수 있다. | . | . | Service method TDD . run()테메에서 static한 Service.start()메서드로 메인흐름 시작하기 . LottoServiceTest를 만들고 . | 테스트 메소드명도 편하게 run() . | Service클래스의 static메소드명도 run() start()로 만들면서 시작한다. . . | 요구사항에 따른 [정제 rawInput]을 Controller내 service가 가정 인자로 사용하여 -&gt; Service 흐름 시작하기 . 테스트해야하므로 메인흐름을 가진 메서드는 controller로 응답까지 해줘야한다. . service는 상태를 안가지므로 객체 - 예상객체 비교X, 응답값 - 예상값으로 비교해야한다. | . public class LottoServiceTest { @Test void run() { //사용자의 로또번호 //당첨번호 // 보너스번호 // -&gt; 당첨 등수 응답 LottoService.start(); } } . 로직에 필요한 인자(정제된 input)를 가상으로 넣어주기 | . LottoService.start( List.of(1, 2, 3, 4, 5, 6), List.of(1, 2, 3, 4, 5, 6), 7 ); . 로직결과로 응답까지 해줘야 테스트가 된다. | . | . 가정인자에 따른 1 case만 1응답하도록 짠 뒤 테스트 . 가정인자( 6개 일치) = 1case를 넣어줬으니 -&gt; 1응답을 반환하도록 일단 1 case만 짠다. . 테스트할 메서드는 처음에는 무조건 응답되도록 void를 수정한다. 어떤 형으로 응답할지를 생각해서 정의시 기입한다. . . | 3개이상의 긴 인자는 콤마 다음부터 내려서 이쁘게 정리해주자. . public class LottoService { public static int start(final List&lt;Integer&gt; integers, final List&lt;Integer&gt; integers1, final int i) { } } . public class LottoService { public static int start(final List&lt;Integer&gt; integers, final List&lt;Integer&gt; integers1, final int i) { } } . | 메서드 파라미터 이름을 바꿔준다. . | 아직 도메인을 몰라서 클래스로 분리 못하겠다면, 메인 로직을 rawInput 가지고 짠다. . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { } } . | 1case에 대한 1응답을 해주는 로직을 완성한다. . if가 포함된 1응답이라면, return 0; 같은 default 응답도 넣어준다. | . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { // 몇개 일치하는지 돌면서 누적시켜야한다 // - 돌아가야하는 놈을 우측 파라미터+for문에 // - 전체를 가지고 contains 확인해야하는 놈을 좌변에 int matchCount = 0; for (Integer lotto : userLotto) { if (winningLotto. contains(lotto)) { matchCount += 1; } } // 일단 가정 인자에 따른 1 case통과 코드만 짠다. // 나중에는 matchCount 갯수에 따라 싹다 분기해서 응답해야한다.(리팩 대상) if (matchCount == 6) { return 1; } return 0; // 1case 응답인데, if를 포함해서 응답했다. -&gt; 1외 default return 0;도 해주자. } . | 1응답이 나오는지 test한다. . public class LottoServiceTest { @Test void run() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, 6), List.of(1, 2, 3, 4, 5, 6), 7 ); assertThat(rank).isEqualTo(1); } } . | [테메] 복붙후 2case에 맞게 가정인자+예상값 바꾼 테스트 메서드 만들기 . 복붙 전, 각 case로 테메명 바꿔주고 난 뒤 복붙하기 . 현재 run()으로 되어있는 테스트메서드명을 case를 반영해서 바꿔주고 난 뒤 복붙 . 복붙하는 이유: 기존 테스트가 계속 돌아가도록 하기 위함. | . @Test //void run() { void rank1() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, 6), List.of(1, 2, 3, 4, 5, 6), 7 ); assertThat(rank).isEqualTo(1); } . | . 복붙후 가정인자+예상값을 2case에 맡게 수정 . 1등 반환case 1개 이후에는 -&gt; 복붙후 가정인자를 바꾼 case변경을 하면서 새로 짜야한다. . 테스트메서드 명을 case에 맡게 복사해준다. | 가정인자 및 예상값을 -&gt; 2case에 맞게 수정해준다. | @Test void rank2() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, 6), List.of(1, 2, 3, 4, 5, 7), // 2등에 맞게 가정인자 수정 6 // 2등에 맞게 가정인자 수정 ); assertThat(rank).isEqualTo(2); // 2등에 맞게 예상값 수정 } . | [메서드 복붙]후 2case 예상값을 응답하도록 메서드2를 수정 . 메서드2로 복붙한다. . 단축키 shift + alt + → 및 ↓를 활용해서 복사하고 | 단축니 shift + alt + F로 정렬해서 | . public static int start2(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { . | 메서드2가 case2예상값을 만들도록 짠다. . public static int start2(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { int matchCount = 0; for (Integer lotto : userLotto) { if (winningLotto.contains(lotto)) { matchCount += 1; } } if (matchCount == 6) { return 1; } if (matchCount == 5 &amp;&amp; userLotto.contains(bonusNumber)) { return 2; } return 0; } . | 테메2가 메서드2를 사용하도록 수정한 뒤 테스트한다. . @Test void rank2() { final int rank = LottoService.start2( . | [기존 테메]도 [메서드2]로 돌아가는지 확인한다. . @Test void rank1() { final int rank = LottoService.start2( . [메서드2]를 [메서드]로 완전히 대체한다. . 기존 메서드 회색 비활성화된 메서드를 안전삭제(alt+del)한다. | 메서드2 -&gt; 메서드(F2 2번)로 이름을 바꿔서 완전히 대체한다. | [2case이후 테메]는 복붙후 한번에 처리해보자. . [다case]테메명 + @ParaemeterizedTest를 통해 가정인자+ 예상값들을 변경시키며, 그에 맞는 응답을 하도록 [메서드 원본]을 수정해서 통과되도록 만들자. . 가정인자가 2개, 예상값 1개, 총 3개 인자가 case에 따라 바뀐다. . List.of() | bonusNumber . | expected | @CsvSource 혹은 @MethodSource를 통해 여러 파라미터를 받아야한다. . @ParameterizedTest @MethodSource(&quot;provideWinningLottoAndExpected&quot;) void rank3_to_5(){ . public static Stream&lt;Arguments&gt; provideWinningLottoAndExpected() { return Stream.of( Arguments.of(List.of(1, 2, 3, 4, 5, 7), 8, 3), // 3등 Arguments.of(List.of(1, 2, 3, 4, 7, 8), 9, 4) , // 4등 Arguments.of(List.of(1, 2, 3, 7, 8, 9), 10, 5) // 5등 ); } . @ParameterizedTest @MethodSource(&quot;provideWinningLottoAndExpected&quot;) void rank3_to_5(final List&lt;Integer&gt; winningLotto, final int bonusNumber, final int expected) { // 파라미터 추가 + 가정인자/예상값 다 변경 -&gt; 테스트시 에러나야 정상 final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, 6), winningLotto, bonusNumber ); assertThat(rank).isEqualTo(expected); } . | 바뀐 가정인자 + 예상값에 대응하도록 원본 메서드를 1,2case에 비추어 수정 . if (matchCount == 6) { return 1; } if (matchCount == 5 &amp;&amp; userLotto.contains(bonusNumber)) { return 2; } if (matchCount == 5) { return 3; } if (matchCount == 4) { return 4; } if (matchCount == 3) { return 5; } . | service 메서드 완성후 회고 . 여기까지 통과시키고 난 뒤, 가정인자로 들어오는 놈들에 대해 도메인 지식이 쌓였을 것이다. 가정인자로 들어오는 List에 대해 개별Integer는 개별 객체 LottoNumber라는 객체로도메인 분리할 수 있겠다. | LottoNumber List 6개를 모아서 Lotto라는 객체로 도메인 분리모아볼 수 있겠다. | . | . 구현된 Service method의 가정인자 리팩토링 . 도메인 지식을 높이기 위해서, 가정하고 넣어주는 인자가 rawInput인체로 빨리 돌아가기만 하는 코드를 짠 상태다. . | 유지보수, 계속 봐야하는 코드라면 리팩토링해야한다. . | . 입력인자 예외처리에 의한 도메인 추출 인지 . 테스트코드가 가정인자+예상값의 변화 없이 개별 도메인 생성자 호출자체에서 문제이기 때문에, 개별도메인으로 가서 테스트 된다. | . [입력인자] [가장 작은 단위]의 숫자(로또번호)가 범위를 벗어나는 경우 . 기존 rank1~5 테스트라도 복붙해서 메서드명을 over로 바꿔고 범위를 벗어나는 경우에 대한 가정인자 + 예상값이 아니라 user입력인자를 바꿔서 만들어주자. . 사용자 입력에 대한 예외에 대한 테스트의 경우, service메서드의 가정인자 변화가 문제가 아니라 입력인자에 실수가 반영된 것이기 때문에 객체로 도메인 분리해서 도메인 검증해야한다. | . @Test void over() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, 100), // 사용자 입력인자만 예외인자로 변화 -&gt; 100 입력 List.of(1, 2, 3, 4, 5, 7), // 가정인자 변화X 6 ); assertThat(rank).isEqualTo(2); // 예상값 변화X } . | [입력인자] 가장 작은 단위가 상호작용한 [일급]에서 중복 문제 . 테메 복붙후 이름변경duplicate . | 입력인자에서 중복이 되도록 입력 . 예외 테스트 는 가정인자 + 예상값의 변화가 없는 상태임. | . @Test void duplicate() { final int rank = LottoService.start( List.of(1,1,1,1,1,1), // 사용자 입력인자만 예외인자로 변화 -&gt; 1이 list내 중복 됨. List.of(1, 2, 3, 4, 5, 7), // 가정인자 변화X 6 ); assertThat(rank).isEqualTo(2); // 예상값 변화X } . | Service.메서드() 사용시 발견된 값들의 예외처리 -&gt; 개별 도메인에서 테스트하면서 처리되어야함. . 도메인을 풍부하게 -&gt; 도메인으로 추출 분리후 도메인 내에서 검증 . | 서비스메서드 사용하면서, 그 service(메인로직) 흐름내에서 if로 하지말자. 자기 도메인내에서 if없이 개별로 처리되어야한다. . 잘못된 예(service에서 인자로 넘어온 도메인들의 예외처리) | . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { if (userLotto.get() &gt; 45) { throw new IllegalArgumentException(&quot;범위 초과&quot;); } . | . 메서드인자 리팩토링1) 최소단위 값 검증 때문에 포장하도록 Service.메서드() 수정 . Service.메서드() [최소단위 값] 1개만 new 생성자()로 싸서, Class와 ClassTest를 정의 . Service.메서드() 로직을 사용하던 곳에서 예외발생 상황을 가정했던 곳에서 new 생성자()를 씌워서 Class -&gt; ClassTest까지 만들어보자. . @Test void over() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, new LottoNumber(100)), // 검증이 필요한 곳 -&gt; class로 도메인분리 -&gt; 생성자부터 씌워서 만들어나가기 . | 값을 1개만 포장하는 경우, 변수명을 value로 잡아서 getValue()등 이름을 어색하지 않게 하자. . 생성자로 클래스 생성후, 상태값 직접 지정해줘야한다. | . package lotto; public class LottoNumber { public LottoNumber(final int value) { } } . public class LottoNumber { private final int value; public LottoNumber(final int value) { this.value = value; } } . | classTest도 바로 만들기 . class LottoNumberTest { } . | Service.method()의 [포장]된 [입력인자]버전의 메소드를 만들기 위해 메소드1복붙 . 기존테스트를 통과하는 메소드2의 개발이 아니라 인자가 달라지는 동일명의 메소드를 개발하는 것이므로 메소드명 동일하게 복붙한다. . 기존 포장안한 테스트가 그대로 통과한 상태를 유지할 수 있다. | 포장이 실패할시 바로 돌아갈 수 있다. | 메소드2로 지어도 상관없을 것 같긴하다. | . . | . 메소드 파라미터 정의를 원시형 -&gt; 포장형으로 바꿔주기 . 메소드의 파라미터 정의부를 원시형을 모두 포장 형으로 바꿔준다. . int, Integer -&gt; LottoNumber | . public static int start(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { . | 내부도 다 타입을 바꿔준다. . 에러가 안나는 듯 하지만, 포장class에서도 기본 제공되는 contains()는 비교/포함여부 되려면 equals/hashCode가 오버라이딩 되어있어야 에러가 안난다. | 최소단위 포장은 equals/hashCode생각 | . public class LottoService { public static int start(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { int matchCount = 0; for (LottoNumber lotto : userLotto) { if (winningLotto.contains(lotto)) { matchCount += 1; } } . | 포장용 Service메소드에서 사용되는 값들 모두 포장해서 전달해주기 . 현재 생성을 위해 1개만 포장된 상태다. 수동으로 다 포장해줘야한다. . @Test void over() { final int rank = LottoService.start( List.of(1, 2, 3, 4, 5, new LottoNumber(100)), // 사용자 입력인자만 예외인자로 변화 -&gt; 100입니다. List.of(1, 2, 3, 4, 5, 7), // 가정인자 변화X 6 ); assertThat(rank).isEqualTo(2); // 예상값 변화X } . 포장 후 | . @Test void over() { final int rank = LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5),new LottoNumber(100)), List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5),new LottoNumber(7)), new LottoNumber(6) ); assertThat(rank).isEqualTo(2); // 예상값 변화X } . | Exception 나는 것을 의도하여 포장했다면 에러가 나야한다 assertThat -&gt; assertThatThrownBy()의 테스트 코드 바꾸기 . 응답 vs 예상값비교 구조에서 () -&gt; exception발생구조로 테스트메서드를 바꿔주자. . @Test void over() { assertThatThrownBy(() -&gt; LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(100)), List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(7)), new LottoNumber(6) )).isInstanceOf(IllegalArgumentException.class); } . | 포장한 도메인 생성자에 예외처리 검증 넣어주기 . 예외 발생 안했다 -&gt; 예외발생시키는 검증을 도메인에 넣어준다. . public LottoNumber(final int value) { validate(value); this.value = value; } private void validate(final int value) { if (value &lt; 1 || value &gt; 45) { throw new IllegalArgumentException(&quot;로또 번호의 범위가 아닙니다.&quot;); } } . | [Service.method()에서의 검증]이 끝났으면 [단일 도메인에서 본격 검증]하러 classTest로 직접가서 [경계값 테스트]하기 . 시간 관계상 Service.method()에서 통채로 테스트하지만, 포장ClassTest에서 직접 경계값 주위로 테스트해야한다. | . class LottoNumberTest { @ParameterizedTest @ValueSource(ints = {0, 46, -1, 100}) void range(final int value) { assertThatThrownBy(() -&gt; new LottoNumber(value)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;범위&quot;); } } . 예외 발생을 위한 포장 회고 . Service.메서드()에서 테스트했지만, LottoNumber로는 더이상 over되는 번호는 오지않겠구나. 심리적 안정감을 얻었다. | . | . 포장 입력인자 메소드 사용시 애로사항 . Service.메서드() 사용시 모든 원시값을 new 포장( )으로 일일히 감싸줘야한다. . LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(100)), List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(7)), new LottoNumber(6) )); . | 포장된 입력인자가 아니라 -원시값 입력인자를 그대로 사용하되, 메소드 내부에서 한꺼번에 포장객체로 변환시키자 . | . [정제된 rawInput을 받던 테매들이 사용하던 service.method()] 내부 개조로 한번에 포장해서 포장인자 메서드 호출해주기 . 기존에 작성된[ 정제된 rawInput을 받던 메소드]의 내용물은 삭제 . 기존 테스트를 위해 정제된 원시값을 받던 메소드 . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { int matchCount = 0; for (Integer lotto : userLotto) { if (winningLotto.contains(lotto)) { matchCount += 1; } } . | . 원시값 인자 네이밍 -&gt; 내부stream으로 한번에 포장 -&gt; return 포장 인자 메서드() 호출 . **기존 내용물은 삭제(포장된 것으로 처리되도록 통일해야됨) ** . public static int start(final List&lt;Integer&gt; userLotto, final List&lt;Integer&gt; winningLotto, final int bonusNumber) { } . | **원시값 인자 +raw네이밍 붙이기 ** . 각 원시인자 기존 네이밍 -&gt; 포장인자로 갈 때 기존 네이밍으로 받아줘야 -&gt; ``포장메서드 호출시 기존 네이밍으로 가기 때문에 **원시 인자 네이밍 앞에 raw`를 붙혀준다** | . public static int start(final List&lt;Integer&gt; rawUserLotto, final List&lt;Integer&gt; rawWinningLotto, final int rawBonusNumber) { } . return 포장된 인자를 받는 새 메소드()호출 응답은 그대로 나가야하므로 return 유지 | . | . public static int start(final List&lt;Integer&gt; rawUserLotto, final List&lt;Integer&gt; rawWinningLotto, final int rawBonusNumber) { final List&lt;LottoNumber&gt; userLotto = rawUserLotto.stream() .map(LottoNumber::new) .collect(Collectors.toList()); final List&lt;LottoNumber&gt; winningLotto = rawWinningLotto.stream() .map(LottoNumber::new) .collect(Collectors.toList()); return start(userLotto, winningLotto, new LottoNumber(rawBonusNumber)); } . | . 의의: Service를 사용하는 client를 편안하게 해줘야한다.(내부로 가기전에 포장해서 호출해주는 놈이 있다면) = client는 원시값도 입력받아 도메인은 모르게 해주는게 낫다 . client쪽, view쪽, 중요하지 않은쪽, 잘변하는 쪽은 도메인, 포장값 사용없이 원시값으로만 service.메서드()를 호출하고, 내부에서 포장 좋다. 포장을 서비스내에서 한번 거쳐서 하는 방법을 여기선 안내해줬다. | 원래 중요하지 않은쪽이 -&gt; 중요한 것을 생성/사용/리턴하는 방향은 허용된다. | . | 생각이 다를 수 있다. 외부에서 무조건 감싸서 로직에 보내줘야한다라고 생각할 수도 있다. | but 사용하는 client입장에서는.. 내부포장으로 편안한게 좋다 | . | my) controller에서 도메인 사용해도 되지만 내부 포장만 해주는 로직이 따로 존재한다면, 원시값을 넘겨도 될 듯? | . | . 메서드 인자 리팩토링2) 최소단위 [묶음]의 예외 처리 -&gt; 일급 포장하여 검증 . 초과된 [포장 최소단위의 갯수 문제] -&gt; [포장인자 메소드]를 가진 [테매]를 복붙하여 Exception 발생시키기 . 현상황에서 포장인자를 받던 메소드를 복붙하여 포장객체의 갯수 문제를 발생시켜보자. . 아무래도.. 최소단위객체의 범위문제에서 작성된 메소드를 복붙해서 고쳐야함… | . @Test void lotto7() { assertThatThrownBy(() -&gt; LottoService.start( List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6), new LottoNumber(7)), // 갯수 초과 List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6)), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class); } . | 갯수를 초과했음에도 불구하고 아직 묶음에 대한 검증이 안되기 때문에 예외발생이 안된다. . . | 앞에서도 그렇고, 예외처리를 Service.method() 내부에서 if로 편하게 해주고 싶은데, 여기서 하면 모든 인자들에 대한 예외처리가 if로 한곳에 쌓일 것이다. . **각 검증은 도메인 추출된 class를 만들어서 그곳에서 한다. ** | . public static int start(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { // 여기서 갯수처리를 해주고 싶으나.. if (userLotto.size() != 6) { throw new 예외 } // 2번째 인자도 예외처리를 로직실행 메서드 내부에서 인자를 받아서 처리하고 싶으나.. if (winningLotto.size() != 6) { throw new 예외 } // 인자들마다 모든 검증들이 if로 여기(사용메서드)에 쌓여갈 것이다. 따른 검증 역시 여기서 해야한다. . | . [객체의 갯수or중복 등 복수 검증]을 위한 List&lt;도메인&gt;을 포장하는 일급포장의 시작 . 복수검증 문제가 발생하는 곳에가서 new 일급()부터 시작 . Service.method()에서 원시값 List -&gt; 단일객체 List가 인자로 들어가는 곳에서 **new 일급( ) ** -&gt; Class -&gt; ClassTest까지 생성해준다. . @Test void lotto7() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(2), . | 생성자로 들어오는 이름도value로 네이밍하여 생성자에서 초기화 . ClassName. 가 PREFIX인 것 및 .getValue() 생각하기 | . public class Lotto { public Lotto(final List&lt;LottoNumber&gt; lottoNumbers) { } } . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final List&lt;LottoNumber&gt; value) { this.value = value; } } . | 나머지도 List -&gt; 일급으로 들어가도록 service.method수정 . . | 들어오는 포장인자(List&lt;단일&gt;) 메서드 복붙 백업후 -&gt; 일급인자로 받도록 method 파라미터 정의부 개조 . 기존 List&lt;단일&gt;으로 들어오던 메서드 전체를 복붙한다. 기존 테스트 유지?를 위해, 일급으로 바꾸기전 List도 들어올 수 있도록 백업해둔다. ![image-20220305003021893](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220305003021893.png) | . | 기존 List&lt;단일&gt;으로 들어오던 메서드의 파라미터 정의부만 정의해준 일급들어오도록 수정한다. . public class LottoService { public static int start(final List&lt;LottoNumber&gt; userLotto, final List&lt;LottoNumber&gt; winningLotto, final LottoNumber bonusNumber) { . 수정후 | . public static int start(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { . | 내부 빨간줄 수정 ( 단일List -&gt; 일급으로 인한 -&gt; 기본적으로 앞에 .getValue()의 getter가 요구됨.) . 일단 getter로 다 처리해놓자. 리팩토링 요구됨. 객체 메세지 던져서 통신. . | 상태값을 value로 네이밍해줬어도, .getValue()의 빨간줄을 리팩토링으로 생성 후 return this.value;까지 직접 입력해줘야된다. . . | 앞에 getter를 붙이면 빨간줄이 사라진다. . . | . | 일급용 메서드가 완성되었으면 | [일급 인자를 받는 Service.method()]가 완성되었으면, [일급이라는 도메인 내부 생성자에 단일List간 복수검증]을 넣어준다. . 일급 도메인인 Lotto의 생성자에서 상태값 초기화 전에 검증을 넣어준다. . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final List&lt;LottoNumber&gt; value) { this.value = value; } . 도메인 검증 추가 | . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . | 도메인 생성자에 넣어준 검증(중복) 을, Service.method()의 인자검증으로 통채로 . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), new Lotto(List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6))), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class) } . | 포장(단일)에 포장(일급) 후 client가 너무 불편? -&gt; Client를 배려해줘라. . 일급 생성자가 받는 new일급(List&lt;단일&gt;)의 인자를 -&gt; 단일... 가변인자로 받고 내부에서 List.Of대신 모아주는 포장용 생성자 추가 . 현재 일급까지 포장해야하는 Service메서드 테매 . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(List.of(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), new Lotto(List.of(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6))), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class) } . 인자 1개만 떼서 보기 | . new Lotto(List.of(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1))), . | [Client] 일급 생성자에 들어가는 List.of() 혹은 Set.of() 제거해주는 -&gt; [메서드내부] 가변인자(알아서 배열) -&gt; this + Arrays.stream().collect(Collectors.toList or toSet ())) ) . client에서 List.of(단일,객체)나 Set.of(단일, 객체)대신 단일객체를 콤마로 나열만 해서 넘겨주면, 알아서 List or Set으로 내부에서 모아주는 . 내부에서 포장해준 뒤, 포장 인자용 메서드를 다시 한번 호출해주는 메서드 파라미터 -&gt; 인자만 복사해서 껍데기 메서드 생성 -&gt; 내부에서 포장후 호출 다시 포장인자메서드를 재호출 | 일급 생성자 -&gt; List.Of, Set.of를 제거하여 생성자를 추가 생성 -&gt; 가변인자를 받도록 정의 -&gt; 배열을 stream collect로 List나 set으로 포장만해서 this( , )로 미리 정의해둔 &amp;&amp; 뒤에 존재하는 포장인자용 생성자 호출 | . | . . . public class Lotto { private final List&lt;LottoNumber&gt; value; public Lotto(final LottoNumber... value) { this(Arrays.stream(value).collect(Collectors.toList())); } public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . 이제 new Lotto() 일급의 생성자에서 2가지 다 받을 수 있게 된다. List.of( , ,, ) 대신 -&gt;그냥 , , ,의 가변인자를 넣어줘도 알아서 List로 포장하게 된다. | . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1), new LottoNumber(1)), new Lotto(new LottoNumber(1), new LottoNumber(2), new LottoNumber(3), new LottoNumber(4), new LottoNumber(5), new LottoNumber(6)), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class); } . | 가변인자(List.of제거) + 단일객체생성자 제거의 일급 내부에 2번의 포장 생성자도 추가해서 client를 편하게 해주자. . new 일급( ) 생성자에 client에서 List.Of() 제거하고 가변인자만 받도록 내부에서 포장해주는 생성자를 추가해줬었다. . //1. new Lotto( 단일객체, 가변으로) -&gt; List.Of제거 public Lotto(final LottoNumber... value) { this(Arrays.stream(value).collect(Collectors.toList())); } . | 이번에는 client 단일객체 생성자 제거하고 단일객체 생성에 필요한 raw원시값을 가변인자로만 받도록 수정해보자. . stream에서 mapToObj가 뜨는 이유는 integer가 아닌 int -&gt; 객체로 가기 때문 -&gt; 애초에 파라미터로 들어오는 원시값들을 int… 대신 Integer...로 box된 타입으로 받을 수 있다. | . public class Lotto { private final List&lt;LottoNumber&gt; value; //2. new Lotto( 원시값, 가변으로) -&gt; List.Of() + new단일()생성자 제거 public Lotto(final Integer... value) { this(Arrays.stream(value).map(LottoNumber::new).collect(Collectors.toList())); } //1. new Lotto( 단일객체, 가변으로) -&gt; List.Of제거 public Lotto(final LottoNumber... value) { this(Arrays.stream(value).collect(Collectors.toList())); } public Lotto(final List&lt;LottoNumber&gt; value) { if (value.stream().distinct().count() != 6) { throw new IllegalArgumentException(&quot;로또 번호는 6개입니다.&quot;); } this.value = value; } . | 이제 단계별로 생성자를 만들어서, 기존 테스트의 인자들이 모두 돌아가게 만들었다. . 이제 원시값으로 일급을 만들 수 있게 된다. | . . @Test void duplicate() { assertThatThrownBy(() -&gt; LottoService.start( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1,2,3,4,5,6), new LottoNumber(7) )).isInstanceOf(IllegalArgumentException.class); } . | client입장에서 코드를 사용하게 엄청 편해진다. | . my) 메서드의 [인자만 포장후 호출용 메서드] or 일급 등의 생성자를 [인자만 다르게 정의하고 내부는 포장해서] client를 편하게 만들어줬다. . 가변인자 사용시 주의해야한다. . 가변인자는 배열을 내부적으로 만들어서 사용하기 때문에, 메모리 잇슈가 있을 수 있다. . | 그래서 .of()메서드들은 11개부터 가변인자를 사용하고 10개까지는 인자를 하드코딩으로 받는다. . | . | . 일급 테스트는 Service.Method()에서 완성된 [가변인자생성자] 시리즈가 완성된 후에 해주자. . [Service.method()에서의 단일/일급 퉁치는 검증] + [일급의 포장용 가변인자 생성자] 끝났으면 [단일 도메인Test]에서 본격 [경계값 테스트]하기 . Lotto라는 일급도메인 테스트를 만든다. . . | Service.method()에서 퉁치며 만들던 갯수/중복 테스트를 case별로 테매명에 반영하면서 만들어본다. . 가변인자는 parameter로 내려보내질 못하네 | 갯수먼저 검사 -&gt; 중복 검사 중복부터하면? distinct.count() != 6에서 list의 size검사도 같이 일어나 중복에 걸리게 된다. | . | . @Test void count_valid() { assertDoesNotThrow(() -&gt; new Lotto(1, 2, 3, 4, 5, 6)); } @Test void count_under() { assertThatThrownBy(() -&gt; new Lotto(1, 2, 3, 4, 5)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } @Test void count_over() { assertThatThrownBy(() -&gt; new Lotto(1, 2, 3, 4, 5, 6, 7)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } @Test void duplicate() { assertThatThrownBy(() -&gt; new Lotto(1, 1, 3, 4, 5, 6)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;6개&quot;); } . | Service.메서드의 이름 수정 . start -&gt; match | . 일급으로 바꿨더니, 서비스 메서드 내부에 도메인 로직이? -&gt; 메서드 분리로 역할 분리 . getter가 있으면 도메인내부로직임을 의심한다. | . 일급vs일급 or 일급vs단일의 로직(도메인 로직-특히 getter써놓은부분)이 Service.method()내부에 있는지 확인한다. getter가 있으면 의심해본다. . Lotto와 Lotto를 비교하는 로직이 보인다. 같은 도메인끼리의 비교를 서비스내에서 할 필요가 없다. 같은 놈끼리는 더더욱 메세지를 보내서 getter의 존재없이 비교되도록 + 도메인을 풍부하게 해준다. . 비교로직을 도메인으로 넣고, matchCount만 받아오자. | . public class LottoService { public static int start(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { int matchCount = 0; for (LottoNumber lotto : userLotto.getValue()) { if (winningLotto.getValue().contains(lotto)) { matchCount += 1; } } . | matchCount는 서비스가 가지고 있어야하는데, 비교해서 누적하는 부분만 도메인 로직이다. . | 서비스내 도메인 로직을 도메인 내부 메서드로 옮긴다. . getter로 꺼내서 억지로 하던 것이, 파라미터로 서로를 비교해도 바로 상태값을 갖다 쓸 수 있다. 일단 옮길 도메인내 메서드부터 만든다. . 서비스에서 갖다쓸 예정이니 서비스에서 빨간줄로 만들어도 될듯? | . . 같은 것끼리의 비교는 other로 파라미터를 네이밍해주자 파라미터 other(일급)이 other.value(같은도메인 getter)로 list가 되면서 찢어진다. | . | . . 돌면서 누적하는 것은 초기화 후 누적하는 폼의 가변변수를 쓸 수 밖에 없다? | . . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lotto : other.value) { if (value.contains(lotto)) { matchCount += 1; } } return matchCount; } . | 포장과정에서 빠르게 처리하여 생긴 포장.getter.메서드()가 서비스메서드내 보인다면, 도메인로직으로 (내부 value.메서드()가 되도록)넘겨준다. . . 서비스메서드내 포장(도메인).getter가 보인다. . 넘겨줄 수 없을까? | getter()를 지워 getValue().메서드를 포장.메서드()로 빨간줄을 생성하여 대체한다. | . . . 파라미터(매개변수) 이름으로 bonusNumbe는 너무 구체적이다. 팀원입장에서 시그니쳐보고 쓸건데, 좀더 추상적이면서, 넓게… 메서드 입장에서는 구체적인 bonus라는 것을 모른다. LottoNumber 역시 클래스랑 완전 동일해서.. value를 일급이 이미썼으니 -&gt; number로 네이밍 해준다. | . . 바깥에서 포장.getValue().contains로 사용됬던 것을 -&gt; 포장.contains메서드 -&gt; 도메인 내부에서 getter없이 value.contains로 사용하도록 만든다. | . . | 서비스로직에 geValue()를 달고 있는 것ㅇ 도메인 로직으로 옮겨가며되면, 포장(도메인).getValue()가 비활성화 되며 -&gt; alt+del로 안전삭제 해준다. . | 일급과 단일의 메서드가 정의됬다면 -&gt; 일급vs일급에서도 사용될 가능성이 있다. . 서비스 로직에 있던 일급.contains(단일)의 메서드가 정의되었다면 . 일급vs단일은 일급내에서 파라미터/우항이 찢어지는 일급vs일급 비교메서드에서 쓰일 가능성이 높다. | . . 정의했으면, 찾아서 대체해준다. | . | 객체없이 호출되는 메서드 -&gt; 순수묶음 or [내부 포장된 변수](현재는 일급을 get한 단일List)가 쓰이는 내부 메서드 . contains( xxx) | (현재 도메인의 포장하는 변수)가 생략된체로 cotains()하고 있구나 생각 | . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { //value:[일급] lotto:찢어진 일급이 돌고 있는 [단일] // [일급 내부] 메서드 contains는 // [일급의 getter(단일List)된 value가 내부에서 쓰이는] 메서드로서, // 들어오는 단일에 대해 [현재 일급의 단일List]가 &lt;파라미터 단일&gt;을 포함하는지 // my) 객체없는 메서드 -&gt; 순수묶음 or [내부 포장된 변수](현재는 일급을 get한 단일List)가 쓰이는 내부 메서드 // if (value.contains(lotto)) { // 객체없이 호출된다? 내부상태가 쓰이는 내부 정의 메서드구나~! if (contains(lottoNumber)) { matchCount += 1; } } return matchCount; } public boolean contains(final LottoNumber number) { return value.contains(number); } . | . 응답값도 포장할 수 있다. 만약, 제한된 종류 + if분기마다 달라지는 응답값라면 ENUM응답 포장후 응답에 필요한 input들로 정펙매 를 호출한 뒤 내부로 분기 옮겨 응답한다. 이후 if분기를 처리해줄 &lt; input-&gt;필드들 - 응답값&gt;을 매핑한다. . int를 포장한 뒤 -&gt; 관련된 if분기 로직을 포장한 도메인으로 넘기면, 메서드 if문이 사라진다., | . . 제한된 종류의 응답 값포장은 Enum을 활용한다. 메서드 응답을 빨간줄로 바꿔 생성하자. . 만약, 제한되지 않았다면? class Rank로, 현재는 제한된 종류의 값 응답이므로 Enum으로 매핑해서 if를 대신하게 해보자. . . | 연속된 상수라면, Enum명_ 순서를 활용하면 된다. . 1,2,3,4,5등 -&gt; 등을 Enum으로 만들고 등_1,2,3,4,5; 로 선언해보자. | . package lotto; public enum Rank { RANK_1, RANK_2, RANK_3, RANK_4, RANK_5; } . | . 응답에 대한 분기로직을 어떻게 응답class/응답Enum으로 넘길까? . . 메서드 응답부에서 원하는 포장된 응답값인 Enum객체을 뽑아 응답해주는 return Enum.정펙매of (,)완성하기 . 결과적으로 정펙매인 Enum.from() or Enum.of( , , )로 Enum객체를 응답해야한다. . 원하는 Enum객체가 응답될 수 있도록 필요한 인자들을 생각해서 받아들인다. | 실제로 입력값이 될 것들을 가지고 있는 사용부인 메서드 응답부에서 부터 시작 | . | . 응답부에서 Enum.정팩메로 해당하는 포장응답값을 return해 줄 예정이다. . 필요한 input들이 뭐가 있는지 살펴본다. | 메서드호출의 결과값이 있다면, input이 명확하도록 따로 변수로 뽑아주자. | . . 정팩메로는 Enum이라는 포장된 응답값을 가져올 것이기 때문에 return과 같이 작성한다. | . . | 값 응답 로직을 -&gt; 포장응답값 정펙매로 잘라내서 처리하기 . 이제 값 응답로직을 그대로 잘라붙혀넣기 한다. . 이동후 | . . | 정팩메 내부로 옮긴 분기에 대해, 응답[값]들을 [Enum객체]로 수정해주기 -&gt; 없는 값(0, None)에 대해서도 OUT,NONE객체 만들어서 응답해주기 . 아직 바꾸기 전 응답로직 . if (matchCount == 6) { return 1; } if (matchCount == 5 &amp;&amp; matchBonus) { return 2; } if (matchCount == 5) { return 3; } if (matchCount == 4) { return 4; } if (matchCount == 3) { return 5; } return 0; . | 수정 + NONE객체 추가후 . package lotto; public enum Rank { RANK_1, RANK_2, RANK_3, RANK_4, RANK_5, OUT; public static Rank of(final int matchCount, final boolean matchBonus) { if (matchCount == 6) { return RANK_1; } if (matchCount == 5 &amp;&amp; matchBonus) { return RANK_2; } if (matchCount == 5) { return RANK_3; } if (matchCount == 4) { return RANK_4; } if (matchCount == 3) { return RANK_5; } return OUT; } } . public static Rank match(final Lotto userLotto, final Lotto winningLotto, final LottoNumber bonusNumber) { final int matchCount = userLotto.match(winningLotto); final boolean matchBonus = userLotto.contains(bonusNumber); return Rank.of(matchCount, matchBonus); } . | . 메서드 [포장된 응답] 테스트 작성하기 . 여러분기므로 1case에 대한 -&gt; 1예상값 마다 테매를 작성해야한다. . @Test void match_1() { //given, when final Rank rank = LottoService.match( new Lotto(1, 2, 3, 4, 5, 6), new Lotto(1, 2, 3, 4, 5, 6), new LottoNumber(7) ); //then assertThat(rank).isEqualTo(Rank.RANK_1); } . if분기를 enum 매핑으로 제거하기 . 정팩메 input으로 들어올 데이터들 中 1개를 골라 (매핑 예정인) Enum객체의 필드로 넣어준다. . 정펙매로 여러 데이터가 들어와 사용가 들어오지만 of( matchCount, matchBonus) . . 매핑에 사용될 쉬운 변수 1개만 선택하여, 정펙매 내부 values().stream.filter 분기에서 비교할 것이다. Enum객체가 필드로 가지고 있으면 되며, 그 필드 기준으로 매핑값도 차후 배정된다. | . | . 쉽게 Enum의 필드에 넣기 위해서는 일단 ENUM(1) 객체 옆에 빨간줄로 원시형 예제작성해준다. . . | 생성자를 생성해주면서 input과 똑같이 네이밍후 빨간줄 this.필드명 = 필드; 초기화를 이용해서 필드를 생성한다. . . . . | 나머지 객체도 데이터를 넣어준다. . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0); private final int matchCount; Rank(final int matchCount) { this.matchCount = matchCount; } public static Rank of(final int matchCount, final boolean matchBonus) { if (matchCount == 6) { return RANK_1; } . | Enum정팩메 내 [제한된종류의 모든 if분기]를 values().stream + filter with input vs 매핑field로 분기 없애기 . 특수한 경우, 정팩매에서 ENUM매핑값 뽑기도 전에, early return해준다. . 특수한 경우로서 2등과 3등을 먼저 필드는 안됬지만 사용해야하는 변수 matchBonus로 홀로 true인 2등을 early return한다. . public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } . | . Enum내에서 values()는 Enum객체배열을 응답하며 거기에 배열.stream자동완성 사용하여 EnumStream 만들어 객체전체를 돌리기 . . . . 제한된 종류의 if분기를 values().stream (for) + filter(it -&gt; input vs 매핑field 비교) 대체하기 . public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); . 기존 if분기들 이제 삭제 | . enum sense: 각 enum객체끝은 마지막도 콤마(,) 그 다음라인(;) + .findAny()후 .orElse( NONE객체 ) . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0), ; . return Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); . Bi(비.아이.) Predicate&lt; , &gt;로 input된 2개 값을 다 사용하는 1개의 람다식필드 &amp;&amp; filter속 예비 조건식(.test(a,b)로 실행)을 만들어 -&gt; [enum의 1 필드 매핑]에 사용되는 Type을 함수형인터페이스로 사용하여 -&gt; 정펙매 내부 들어오는 2개값 모두 사용하는 enum 만들기 . BiPredicate Type은 1개 함수를 가진 인터페이스 = 함수형 인터페이스 중 2개 인자를 받아 실행대기 중인 조건식을 제공해주고 -&gt; .test( a, b)를 통해 외부인자를 받아서 조건식을 실행한다. .test(a, b)에 정팩메로 들어온 input2개를 넣어주면 된다. | . | . 아직 BiPredicate 적용안한 기존 코드 (상금도 매핑 안된 상태) . public enum Rank { RANK_1(6), RANK_2(5), RANK_3(5), RANK_4(4), RANK_5(3), OUT(0), ; private final int matchCount; Rank(final int matchCount) { this.matchCount = matchCount; } public static Rank of(final int matchCount, final boolean matchBonus) { if (matchBonus &amp;&amp; matchCount == 5) { return RANK_2; } return Arrays.stream(values()) .filter(it -&gt; matchCount == it.matchCount) .findAny() .orElse(OUT); } } . Enum필드에 2인자 람다식인 BiPredicate를 넣어서 생성하기 . 이번엔 Enum()객체안에 input 중 1개 6,5,4.. 대신에 input 2필드 다 써서 1개 람다식을 만들어 예제로 넣어주자. 이왕이면 다중커서로 한번에 다 입력해주자. | . | 아쉽게도 BiPredicate는 직접 필드입력 -&gt; private final 필드 변수 생성 -&gt; 생산자 자동완성로 가야한다. (원래는 예제 -&gt; 생산자 -&gt; 빨간줄 this.필드 생성) . 원래 객체( 원시값 등 쉬운 Type)을 빨간줄 필드로 넣으면, 생성자에 파라미터 공짜 -&gt; this.로 필드 공짜 생성 | . BiPredicate 작성 . 받은 인자 2개는 if분기에 쓰였던 input값 2개다. -&gt; 원래 Enum의 매핑 쉬운 상수 응답값 6, 5, 4...와 비교해야한다. | . public enum Rank { RANK_1(((matchCount, matchBonus) -&gt; matchCount == 6)), RANK_2((matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; matchBonus), RANK_3((matchCount, matchBonus) -&gt; matchCount == 5 &amp;&amp; !matchBonus), RANK_4((matchCount, matchBonus) -&gt; matchCount == 4), RANK_5((matchCount, matchBonus) -&gt; matchCount == 3), OUT((matchCount, matchBonus) -&gt; matchCount &lt; 3), ; . | 필드 직접 입력 private final . 제네릭 타입은 들어올 인자들의 Type(정팩메로 들어올 Type)을 Boxing한 타입 + 네이밍은 condition으로 실행될 조건식임을 인지시킴 | . private final BiPredicate&lt;Integer, Boolean&gt; condition; . . | 생성자 자동완성 . | values().stream + filter분기에서 .test( , )로 정펙매 인자를 받아 조건식 실행 . public static Rank of(final int matchCount, final boolean matchBonus) { return Arrays.stream(values()) .filter(it -&gt; it.condition.test(matchCount, matchBonus)) .findAny() .orElse(OUT); } . 응답값의 포장(리팩토링)이 다 끝났으면, 자체 도메인Test(Enum은 정펙매 테스트) . @Test void rank_1() { final Rank rank = Rank.of(6, false); assertThat(rank).isEqualTo(Rank.RANK_1); } @Test void rank_2() { final Rank rank = Rank.of(5, true); assertThat(rank).isEqualTo(Rank.RANK_2); } @ParameterizedTest @CsvSource({&quot;5,false,RANK_3&quot;, &quot;4, false, RANK_4&quot;, &quot;3, false, RANK_5&quot;}) void rank_3_5(final int matchCount, final boolean matchBonus, final Rank expected) { final Rank rank = Rank.of(matchCount, matchBonus); assertThat(rank).isEqualTo(expected); } . 리팩토링(가변변수 0에 조건만족시 갯수 누적) . 직전까지의합 0가변변수에 조건 만족시 add 1 -&gt; stream + filter + count . 변경 전: 0이라는 int 가변변수를 먼저 선언해놓고 -&gt; 돌면서 조건만족시 -&gt; 가변변수에 += 1;하는 행위 | . // 일급 Lotto public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { if (contains(lottoNumber)) { matchCount += 1; } } return matchCount; } . stream의 filter + count로 원하는 조건의 갯수를 누적된 상태로 바로 뽑을 수 있다. | . // 미리 가변 변수 int = 0;을 선언하지말고 조건만족시를 다 count()로 갯수만 반환받는다. // - long이 기본 타입이라.. 캐스팅 해야한다. public int match(final Lotto other) { // 우항, 파라미터를 찢는 놈이라고 했으니, other.value.stream()으로 찢었다. return (int) other.value.stream() .filter(it -&gt; contains(it)) .count(); } . stream없이 for+if 에서 if를 메서드분리 -&gt; 누적변수없이도 응답 가능=갯수니까 return 1 or 0; . 변경 전 . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { if (value.contains(lottoNumber)) { matchCount += 1; } } return matchCount; } . | . for문 내부 if는 메서드 추출로 통채로 빼기 -&gt; if가 바깥쪽 가변변수 조작한다면? return = 메서드추출()로 받아진다. . . 원래 if 내부에서 바깥의 가변변수를 건들였으니 if가 있던 자리 -&gt; 바깥 가변변수 = 메서드추출()로 return받도록 짜여졌다. . 메서드추출했는데 변수에 리턴받는다? -&gt; 내부에서 바깥의 가변변수를 건들였던 것을 뱉어준 것 | . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { matchCount = getMatchCount(matchCount, lottoNumber); } return matchCount; } private int getMatchCount(int matchCount, final LottoNumber lottoNumber) { if (value.contains(lottoNumber)) { matchCount += 1; } return matchCount; } . | . 메서드추출로 튀어나온 (내부에서 사용되던 바깥선언의) 가변변수는 무조건 가변 = 메서드()형태다 . 원래 if문 내부에서 가변변수++, 가변변수+=1를 해줬었는데… 추출된 것은 무조건 변수 = 메서드()형태인 이유는 . 추출된 메서드의 파라미터로 가변변수가 들어간다. . for (LottoNumber lottoNumber : other.value) { matchCount = getMatchCount(matchCount, lottoNumber); } . | 가변변수가 파라미터에서 선언되는 이름만 똑같은 지역변수가 되는데, 이름은 같아도 바깥 가변변수와는 전혀 다른 것이다. . . | . | . 갯수 증가의 가변++/가변+=1 은 메서드추출시 파라미터(=지역변수)로 안가도 return 1 or 0만 해주면 되므로 [추출메서드에서 파라미터 삭제] -&gt; 이후 가변 = 이 아닌 가변 += 으로 바꿔주면 된다. . 파라미터=지역변수를 없애고, 지역변수++자리를 return 1로 아니면 return 0;으로 대체하자. . private int getMatchCount(int matchCount, final LottoNumber lottoNumber) { if (value.contains(lottoNumber)) { matchCount++; } return matchCount; } . // 지역변수 지우고, 걸리면 갯수증가용 1 , 안걸리면 0 을 반환 private int getMatchCount(final LottoNumber lottoNumber) { if (value.contains(lottoNumber)) { //matchCount++; return 1; } return 0; } . | 메서드 추출 기능 자체의 문제가 가변+= 메서드리턴()이 안되서 -&gt; 가변을 파라미터로 받은 뒤, 지역변수++, 지역변수+= 후 return되는 문제였다. . 가변 = 메서드 추출()부분을 가변 += 메서드 추출()-1or0리턴;으로 바꿔주자. | . public int match(final Lotto other) { int matchCount = 0; for (LottoNumber lottoNumber : other.value) { //matchCount = getMatchCount(matchCount, lottoNumber); //matchCount = getMatchCount(lottoNumber); matchCount += getMatchCount(lottoNumber); } return matchCount; } . | .",
            "url": "blog.chojaeseong.com/java/%EB%A1%9C%EB%98%90/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/06/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-2%EB%8B%A8%EA%B3%84-%EB%A1%9C%EB%98%90-%ED%94%BC%EB%93%9C%EB%B0%B1.html",
            "relUrl": "/java/%EB%A1%9C%EB%98%90/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/06/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-2%EB%8B%A8%EA%B3%84-%EB%A1%9C%EB%98%90-%ED%94%BC%EB%93%9C%EB%B0%B1.html",
            "date": " • Mar 6, 2022"
        }
        
    
  
    
        ,"post122": {
            "title": "의연방00) 데이터 클리닉 특강",
            "content": "강의 교재 사이트: https://rpubs.com/biostat81/DataPrep_CRM | 데이터셋 보유되어있음(data/특강/example_dataset.csv) | . &#46972;&#51060;&#48652;&#47084;&#47532; &#49444;&#52824; . install.packages(&#39;dplyr&#39;) . also installing the dependencies &#39;ellipsis&#39;, &#39;fansi&#39;, &#39;pkgconfig&#39;, &#39;purrr&#39;, &#39;cli&#39;, &#39;utf8&#39;, &#39;generics&#39;, &#39;glue&#39;, &#39;lifecycle&#39;, &#39;magrittr&#39;, &#39;R6&#39;, &#39;rlang&#39;, &#39;tibble&#39;, &#39;tidyselect&#39;, &#39;vctrs&#39;, &#39;pillar&#39; . There are binary versions available but the source versions are later: binary source needs_compilation fansi 0.4.2 1.0.2 TRUE cli 2.5.0 3.2.0 TRUE utf8 1.2.1 1.2.2 TRUE generics 0.1.0 0.1.2 FALSE glue 1.4.2 1.6.2 TRUE lifecycle 1.0.0 1.0.1 FALSE magrittr 2.0.1 2.0.2 TRUE R6 2.5.0 2.5.1 FALSE rlang 0.4.11 1.0.2 TRUE tibble 3.1.1 3.1.6 TRUE tidyselect 1.1.1 1.1.2 TRUE pillar 1.6.0 1.7.0 FALSE dplyr 1.0.6 1.0.8 TRUE Binaries will be installed package &#39;ellipsis&#39; successfully unpacked and MD5 sums checked package &#39;fansi&#39; successfully unpacked and MD5 sums checked package &#39;pkgconfig&#39; successfully unpacked and MD5 sums checked package &#39;purrr&#39; successfully unpacked and MD5 sums checked package &#39;cli&#39; successfully unpacked and MD5 sums checked package &#39;utf8&#39; successfully unpacked and MD5 sums checked package &#39;glue&#39; successfully unpacked and MD5 sums checked package &#39;magrittr&#39; successfully unpacked and MD5 sums checked package &#39;rlang&#39; successfully unpacked and MD5 sums checked package &#39;tibble&#39; successfully unpacked and MD5 sums checked package &#39;tidyselect&#39; successfully unpacked and MD5 sums checked package &#39;vctrs&#39; successfully unpacked and MD5 sums checked package &#39;dplyr&#39; successfully unpacked and MD5 sums checked The downloaded binary packages are in C: Users cho_desktop AppData Local Temp RtmpC2VGFd downloaded_packages . installing the source packages &#39;generics&#39;, &#39;lifecycle&#39;, &#39;R6&#39;, &#39;pillar&#39; . install.packages(&#39;tableone&#39;) . also installing the dependencies &#39;bit&#39;, &#39;prettyunits&#39;, &#39;glue&#39;, &#39;bit64&#39;, &#39;withr&#39;, &#39;progress&#39;, &#39;cli&#39;, &#39;clipr&#39;, &#39;vroom&#39;, &#39;tzdb&#39;, &#39;DBI&#39;, &#39;gtools&#39;, &#39;forcats&#39;, &#39;hms&#39;, &#39;readr&#39;, &#39;cpp11&#39;, &#39;stringi&#39;, &#39;Matrix&#39;, &#39;survival&#39;, &#39;lattice&#39;, &#39;minqa&#39;, &#39;numDeriv&#39;, &#39;mitools&#39;, &#39;class&#39;, &#39;proxy&#39;, &#39;gdata&#39;, &#39;haven&#39;, &#39;stringr&#39;, &#39;tidyr&#39;, &#39;survey&#39;, &#39;MASS&#39;, &#39;e1071&#39;, &#39;zoo&#39;, &#39;gmodels&#39;, &#39;nlme&#39;, &#39;labelled&#39; . There are binary versions available but the source versions are later: binary source needs_compilation glue 1.4.2 1.6.2 TRUE withr 2.4.2 2.5.0 FALSE cli 2.5.0 3.2.0 TRUE clipr 0.7.1 0.8.0 FALSE vroom 1.4.0 1.5.7 TRUE tzdb 0.1.1 0.2.0 TRUE DBI 1.1.1 1.1.2 FALSE gtools 3.8.2 3.9.2 TRUE hms 1.0.0 1.1.1 FALSE readr 1.4.0 2.1.2 TRUE cpp11 0.2.7 0.4.2 FALSE stringi 1.6.1 1.7.6 TRUE Matrix 1.3-3 1.4-0 TRUE survival 3.2-11 3.3-1 TRUE lattice 0.20-44 0.20-45 TRUE class 7.3-19 7.3-20 TRUE proxy 0.4-25 0.4-26 TRUE haven 2.4.1 2.4.3 TRUE tidyr 1.1.3 1.2.0 TRUE survey 4.0 4.1-1 FALSE MASS 7.3-54 7.3-55 TRUE e1071 1.7-6 1.7-9 TRUE nlme 3.1-152 3.1-155 TRUE labelled 2.8.0 2.9.0 FALSE tableone 0.11.2 0.13.0 FALSE Binaries will be installed package &#39;bit&#39; successfully unpacked and MD5 sums checked package &#39;prettyunits&#39; successfully unpacked and MD5 sums checked package &#39;glue&#39; successfully unpacked and MD5 sums checked . Warning message: &#34;cannot remove prior installation of package &#39;glue&#39;&#34;Warning message in file.copy(savedcopy, lib, recursive = TRUE): &#34;C: Users cho_desktop anaconda3 Lib R library 00LOCK glue libs x64 glue.dll를 C: Users cho_desktop anaconda3 Lib R library glue libs x64 glue.dll로 복사하는데 문제가 발생했습니다: Permission denied&#34;Warning message: &#34;restored &#39;glue&#39;&#34; . package &#39;bit64&#39; successfully unpacked and MD5 sums checked package &#39;progress&#39; successfully unpacked and MD5 sums checked package &#39;cli&#39; successfully unpacked and MD5 sums checked package &#39;vroom&#39; successfully unpacked and MD5 sums checked package &#39;tzdb&#39; successfully unpacked and MD5 sums checked package &#39;gtools&#39; successfully unpacked and MD5 sums checked package &#39;forcats&#39; successfully unpacked and MD5 sums checked package &#39;readr&#39; successfully unpacked and MD5 sums checked package &#39;stringi&#39; successfully unpacked and MD5 sums checked package &#39;Matrix&#39; successfully unpacked and MD5 sums checked package &#39;survival&#39; successfully unpacked and MD5 sums checked package &#39;lattice&#39; successfully unpacked and MD5 sums checked package &#39;minqa&#39; successfully unpacked and MD5 sums checked package &#39;numDeriv&#39; successfully unpacked and MD5 sums checked package &#39;mitools&#39; successfully unpacked and MD5 sums checked package &#39;class&#39; successfully unpacked and MD5 sums checked package &#39;proxy&#39; successfully unpacked and MD5 sums checked package &#39;gdata&#39; successfully unpacked and MD5 sums checked package &#39;haven&#39; successfully unpacked and MD5 sums checked package &#39;stringr&#39; successfully unpacked and MD5 sums checked package &#39;tidyr&#39; successfully unpacked and MD5 sums checked package &#39;MASS&#39; successfully unpacked and MD5 sums checked package &#39;e1071&#39; successfully unpacked and MD5 sums checked package &#39;zoo&#39; successfully unpacked and MD5 sums checked package &#39;gmodels&#39; successfully unpacked and MD5 sums checked package &#39;nlme&#39; successfully unpacked and MD5 sums checked The downloaded binary packages are in C: Users cho_desktop AppData Local Temp RtmpC2VGFd downloaded_packages . installing the source packages &#39;withr&#39;, &#39;clipr&#39;, &#39;DBI&#39;, &#39;hms&#39;, &#39;cpp11&#39;, &#39;survey&#39;, &#39;labelled&#39;, &#39;tableone&#39; . library(plyr) library(dplyr) . Warning message: &#34;package &#39;plyr&#39; was built under R version 3.6.3&#34;Warning message: &#34;package &#39;dplyr&#39; was built under R version 3.6.3&#34; Attaching package: &#39;dplyr&#39; The following objects are masked from &#39;package:plyr&#39;: arrange, count, desc, failwith, id, mutate, rename, summarise, summarize The following objects are masked from &#39;package:stats&#39;: filter, lag The following objects are masked from &#39;package:base&#39;: intersect, setdiff, setequal, union . library(tableone) . Error in library(tableone): there is no package called &#39;tableone&#39; Traceback: 1. library(tableone) . &#44592;&#52488; &#53945;&#44053; . . aa &lt;- 1:5 # 벡터 bb &lt;- as.factor(aa) # 벡터 -&gt; factor cc &lt;- as.character(aa) # 벡터 -&gt; 케릭터 . bb # factor형 변수 # levels라는 한줄이 더 나온다. # 범주형변수 factor로 인식시켜줘야, 범주의 갯수와 종류를 print해준다. . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 4 | 5 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &#39;4&#39; | &#39;5&#39; | &lt;/ol&gt; cc # 문자형이라서 큰따옴표로 나온다 in R studio . &lt;ol class=list-inline&gt; &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &#39;4&#39; | &#39;5&#39; | &lt;/ol&gt; aa # numeric은 가감승제가 가능하다. . aa + 1 # 더하면 벡터 전체에 일괄 적용 된다. . &lt;ol class=list-inline&gt; 2 | 3 | 4 | 5 | 6 | &lt;/ol&gt; bb + 1 # 팩터형 변수에는 가감승제를 해줄 수 없다. . Warning message in Ops.factor(bb, 1): &#34;&#39;+&#39; not meaningful for factors&#34; . &lt;ol class=list-inline&gt; &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;/ol&gt; cc + 1 # 케릭터형 변수에는 가감승제를 할 수 없다. . Error in cc + 1: 이항연산자에 수치가 아닌 인수입니다 Traceback: . typeof(aa) . &#39;integer&#39; typeof(bb) # factor형은 내부에서 integer로 저장한다. . &#39;integer&#39; typeof(cc) . &#39;character&#39; . . dd &lt;- data.frame( aa, bb, cc) # 개별 벡터들을 넣어주면, 변수=&gt;칼럼이 된다. dd . aabbcc . 1 | 1 | 1 | . 2 | 2 | 2 | . 3 | 3 | 3 | . 4 | 4 | 4 | . 5 | 5 | 5 | . # data.frame은 type이 달라도 모아서 사용할 수 있다. . summary(dd) # aa: 연속형변수 -&gt; 기본? 통계가 잘 나온다 # bb: 각 범주에 갯수를 표시한 범주형 변수 -&gt; 도수분표표 # cc: 캐릭터변수 -&gt; 길이에다가 설명 # 데이터클리닝 최종목표 : summary에 넣었을 때 정상적으로 나와야함. . aa bb cc Min. :1 1:1 1:1 1st Qu.:2 2:1 2:1 Median :3 3:1 3:1 Mean :3 4:1 4:1 3rd Qu.:4 5:1 5:1 Max. :5 . . &#54056;&#53412;&#51648; &#49444;&#52824; &#48143; &#47196;&#46300; . dply r &#54056;&#53412;&#51648;&#51032; &#54028;&#51060;&#54532;&#46972;&#51064;&#47484; &#51060;&#50857;&#54620; &#45936;&#51060;&#53552;&#53364;&#47532;&#45789; . &#54028;&#51060;&#54532;&#46972;&#51064; &#49444;&#47749; . aa . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 4 | 5 | &lt;/ol&gt; log(aa) . &lt;ol class=list-inline&gt; 0 | 0.693147180559945 | 1.09861228866811 | 1.38629436111989 | 1.6094379124341 | &lt;/ol&gt; aa %&gt;% log() . &lt;ol class=list-inline&gt; 0 | 0.693147180559945 | 1.09861228866811 | 1.38629436111989 | 1.6094379124341 | &lt;/ol&gt; # 체이닝해서.. 여러가지 작업을 할 경우, 그 과정을 알 수 있다. round( sum( log(aa) ) ) . 5 # 왼쪽부터 읽는 것 &lt;-&gt; 호출 순서가 다른 것을 # 파이프라인으로 순서대로 읽고 실행되게 aa %&gt;% log() %&gt;% sum() %&gt;% round() . 5 &#51089;&#50629;&#50689;&#50669; &#51648;&#51221; &#46321; . &#45936;&#51060;&#53552;&#53364;&#47532;&#45789; . &#47196;&#46300; &#51204;, &#45936;&#51060;&#53552;&#47484; &#51069;&#44592;&#51204;&#50857;&#51004;&#47196; &#48708;&#45012;&#51452;&#44592; . . # 데이터를 객체에 저장 dat0 &lt;- read.csv(&#39;./data/특강//example_dataset.csv&#39;) # stringAsFactors = F) # R버전 4이하인 경우 수행해야함. . head(dat0) . idagesexRecur..1..Recur..0..Censored.OP_dateRecur_datelocal_6mCA19.9CEATNMCCIadc_decreaseadc_5_decreasevolume_changeapt_1_meanapt_1_95padc_1_meanadc_1_5p . 1 | 79 | 1 | 1 | 2014-07-07 | 2014-08-10 | 1 | 4490 | 8.7 | 5 | 1 | 8.83908844 | 1.8832245 | -2.357226849 | 5.167 | 2.840 | 89.37554932 | 53.85543 | . 2 | 54 | 0 | 0 | 2013-05-07 | 2018-07-07 | 1 | 37.8 | 2.5 | 4 | 1 | -2.473731995 | 6.4843369 | 140.736618 | 2.967 | 3.753 | 130.4454651 | 82.87475 | . 3 | 31 | 1 | 0 | 2016-05-06 | 2020-01-11 | 0 | 36.6 | 3.0 | 5 | 1 | 24.08946228 | 11.6069794 | 57.76787567 | 2.444 | 3.114 | 127.4504852 | 84.46223 | . 4 | 39 | 1 | 1 | 2015-11-25 | 2017-08-03 | 0 | 65 | 16.6 | 4 | 2 | 42.83881378 | 0.7782211 | 3.21591568 | 2.952 | 3.651 | 114.5146027 | 74.28822 | . 5 | 50 | 1 | 1 | 2015-02-09 | 2016-06-01 | 1 | 38.9 | 4.0 | 5 | 1 | 5.897392273 | 2.9760971 | -3.059473038 | 0.628 | 1.795 | 99.98454285 | 75.61291 | . 6 | 69 | 1 | 1 | 2015-06-22 | 2016-02-12 | 1 | 5.9 | 4.5 | 5 | 1 | na | 11.0519104 | 26.99385071 | 5.167 | 3.646 | 144.8905334 | 95.49654 | . view() &#48712; &#45936;&#51060;&#53552;&#44032; NA&#47196; &#51064;&#49885;&#46104;&#45716;&#51648; &#54869;&#51064;&#54616;&#44592; . view(dat0) # 엑셀 저장 실수로 빈 데이터가 NA로 차있다. -&gt; 50행까지만 읽자. . Error in view(dat0): 함수 &#34;view&#34;를 찾을 수 없습니다 Traceback: . # dat0 &lt;- read.csv(&#39;./data/특강//example_dataset.csv&#39;) # 빈 데이터는 제끼기 dat0 &lt;- read.csv(&#39;./data/특강//example_dataset.csv&#39;, nrow=50) . id&#44032; &#50976;&#45768;&#53356;&#54620;&#51648; (&#51473;&#48373;distinct.count) &#54869;&#51064; &#54616;&#44592; . head(dat0) . idagesexRecur..1..Recur..0..Censored.OP_dateRecur_datelocal_6mCA19.9CEATNMCCIadc_decreaseadc_5_decreasevolume_changeapt_1_meanapt_1_95padc_1_meanadc_1_5p . 1 | 79 | 1 | 1 | 2014-07-07 | 2014-08-10 | 1 | 4490 | 8.7 | 5 | 1 | 8.83908844 | 1.8832245 | -2.357226849 | 5.167 | 2.840 | 89.37554932 | 53.85543 | . 2 | 54 | 0 | 0 | 2013-05-07 | 2018-07-07 | 1 | 37.8 | 2.5 | 4 | 1 | -2.473731995 | 6.4843369 | 140.736618 | 2.967 | 3.753 | 130.4454651 | 82.87475 | . 3 | 31 | 1 | 0 | 2016-05-06 | 2020-01-11 | 0 | 36.6 | 3.0 | 5 | 1 | 24.08946228 | 11.6069794 | 57.76787567 | 2.444 | 3.114 | 127.4504852 | 84.46223 | . 4 | 39 | 1 | 1 | 2015-11-25 | 2017-08-03 | 0 | 65 | 16.6 | 4 | 2 | 42.83881378 | 0.7782211 | 3.21591568 | 2.952 | 3.651 | 114.5146027 | 74.28822 | . 5 | 50 | 1 | 1 | 2015-02-09 | 2016-06-01 | 1 | 38.9 | 4.0 | 5 | 1 | 5.897392273 | 2.9760971 | -3.059473038 | 0.628 | 1.795 | 99.98454285 | 75.61291 | . 6 | 69 | 1 | 1 | 2015-06-22 | 2016-02-12 | 1 | 5.9 | 4.5 | 5 | 1 | na | 11.0519104 | 26.99385071 | 5.167 | 3.646 | 144.8905334 | 95.49654 | . length(unique(dat0$id)) . 50 . &#47785;&#54364;&#51064; summary&#50640; &#45347;&#50612;&#48372;&#44592; . summary(dat0) . id age sex Recur..1..Recur..0..Censored. Min. : 1.00 Min. :25.00 Min. :0.00 Min. :0.00 1st Qu.:13.25 1st Qu.:49.25 1st Qu.:0.00 1st Qu.:0.00 Median :25.50 Median :58.50 Median :1.00 Median :0.00 Mean :25.50 Mean :56.44 Mean :0.66 Mean :0.44 3rd Qu.:37.75 3rd Qu.:65.75 3rd Qu.:1.00 3rd Qu.:1.00 Max. :50.00 Max. :79.00 Max. :1.00 Max. :1.00 OP_date Recur_date local_6m CA19.9 CEA 2011-12-29: 1 2018-07-07: 3 Min. :0.00 &lt;1.0 : 2 Min. : 0.630 2012-01-27: 1 2019-11-15: 2 1st Qu.:0.00 10.8 : 2 1st Qu.: 1.450 2012-03-13: 1 2019-11-19: 2 Median :0.00 5.9 : 2 Median : 2.500 2012-08-14: 1 2012-04-09: 1 Mean :0.46 10.7 : 1 Mean : 5.574 2012-09-20: 1 2012-08-29: 1 3rd Qu.:1.00 11.4 : 1 3rd Qu.: 4.150 2013-05-07: 1 2013-05-28: 1 Max. :1.00 12.1 : 1 Max. :115.900 (Other) :44 (Other) :40 (Other):41 TNM CCI adc_decrease adc_5_decrease Min. :1.00 Min. :0 42.83881378 : 9 Min. :-6.717 1st Qu.:3.00 1st Qu.:1 -2.473731995: 4 1st Qu.: 2.566 Median :4.00 Median :2 -1.790367126: 1 Median :11.329 Mean :3.56 Mean :2 . : 1 Mean :10.998 3rd Qu.:4.00 3rd Qu.:3 0.423 : 1 3rd Qu.:15.638 Max. :5.00 Max. :6 10.24687958 : 1 Max. :63.617 (Other) :33 volume_change apt_1_mean apt_1_95p adc_1_mean n/a : 2 Min. : 0.628 Min. :1.267 : 1 -12.57099533: 1 1st Qu.: 1.831 1st Qu.:2.517 100.3332748: 1 -14.51074219: 1 Median : 2.510 Median :3.034 100.7850723: 1 -2.133106232: 1 Mean : 3.129 Mean :3.065 101.1288986: 1 -2.357226849: 1 3rd Qu.: 3.100 3rd Qu.:3.650 106.94384 : 1 -20.45214844: 1 Max. :27.473 Max. :5.437 107.4796753: 1 (Other) :43 (Other) :44 adc_1_5p Min. : 53.86 1st Qu.: 75.78 Median : 85.10 Mean : 85.03 3rd Qu.: 92.43 Max. :116.59 . . # Recur -&gt; 변수명 짧게 # 날짜 -&gt; character로 인식함 #local_6m # ca19.9 -&gt; 케릭터로 인식됨. . &#48320;&#49688;&#47749; &#44596; &#44163;&#48512;&#53552; &#52376;&#47532; . dat0$Recur..1..Recur..0..Censored. . # 클리닝하명 dat1에 &lt;- . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) . &#45216;&#51676;&#54805;&#51004;&#47196; &#48148;&#45012;&#51452;&#44592; . dat0$OP_date . &lt;ol class=list-inline&gt; 2014-07-07 | 2013-05-07 | 2016-05-06 | 2015-11-25 | 2015-02-09 | 2015-06-22 | 2017-02-10 | 2012-09-20 | 2016-05-20 | 2017-05-19 | 2016-01-11 | 2015-11-24 | 2012-08-14 | 2016-07-13 | 2015-08-31 | 2015-12-16 | 2015-02-04 | 2015-07-23 | 2015-10-23 | 2011-12-29 | 2016-10-18 | 2012-01-27 | 2017-11-14 | 2017-07-27 | 2015-05-22 | 2015-02-26 | 2017-05-17 | 2016-03-14 | 2017-03-14 | 2016-09-20 | 2014-08-08 | 2016-10-12 | 2016-07-22 | 2016-01-26 | 2016-05-23 | 2017-06-29 | 2016-09-28 | 2017-09-05 | 2016-02-29 | 2013-12-20 | 2012-03-13 | 2015-09-10 | 2014-07-31 | 2015-01-27 | 2014-05-23 | 2017-08-21 | 2014-05-09 | 2015-07-21 | 2015-02-03 | 2015-09-07 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;2011-12-29&#39; | &#39;2012-01-27&#39; | &#39;2012-03-13&#39; | &#39;2012-08-14&#39; | &#39;2012-09-20&#39; | &#39;2013-05-07&#39; | &#39;2013-12-20&#39; | &#39;2014-05-09&#39; | &#39;2014-05-23&#39; | &#39;2014-07-07&#39; | &#39;2014-07-31&#39; | &#39;2014-08-08&#39; | &#39;2015-01-27&#39; | &#39;2015-02-03&#39; | &#39;2015-02-04&#39; | &#39;2015-02-09&#39; | &#39;2015-02-26&#39; | &#39;2015-05-22&#39; | &#39;2015-06-22&#39; | &#39;2015-07-21&#39; | &#39;2015-07-23&#39; | &#39;2015-08-31&#39; | &#39;2015-09-07&#39; | &#39;2015-09-10&#39; | &#39;2015-10-23&#39; | &#39;2015-11-24&#39; | &#39;2015-11-25&#39; | &#39;2015-12-16&#39; | &#39;2016-01-11&#39; | &#39;2016-01-26&#39; | &#39;2016-02-29&#39; | &#39;2016-03-14&#39; | &#39;2016-05-06&#39; | &#39;2016-05-20&#39; | &#39;2016-05-23&#39; | &#39;2016-07-13&#39; | &#39;2016-07-22&#39; | &#39;2016-09-20&#39; | &#39;2016-09-28&#39; | &#39;2016-10-12&#39; | &#39;2016-10-18&#39; | &#39;2017-02-10&#39; | &#39;2017-03-14&#39; | &#39;2017-05-17&#39; | &#39;2017-05-19&#39; | &#39;2017-06-29&#39; | &#39;2017-07-27&#39; | &#39;2017-08-21&#39; | &#39;2017-09-05&#39; | &#39;2017-11-14&#39; | &lt;/ol&gt; # 이것으로 확인한다. -&gt; 안되면 케릭터로 잘못 된 것임 dat0$OP_date + 1 . Warning message in Ops.factor(dat0$OP_date, 1): &#34;&#39;+&#39; not meaningful for factors&#34; . &lt;ol class=list-inline&gt; &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;NA&gt; | &lt;/ol&gt; as.Date(dat0$OP_date, format = &quot;%Y-%m-%d&quot;) + 1 # 에러 안나면 성공임. . &lt;ol class=list-inline&gt; 2014-07-08 | 2013-05-08 | 2016-05-07 | 2015-11-26 | 2015-02-10 | 2015-06-23 | 2017-02-11 | 2012-09-21 | 2016-05-21 | 2017-05-20 | 2016-01-12 | 2015-11-25 | 2012-08-15 | 2016-07-14 | 2015-09-01 | 2015-12-17 | 2015-02-05 | 2015-07-24 | 2015-10-24 | 2011-12-30 | 2016-10-19 | 2012-01-28 | 2017-11-15 | 2017-07-28 | 2015-05-23 | 2015-02-27 | 2017-05-18 | 2016-03-15 | 2017-03-15 | 2016-09-21 | 2014-08-09 | 2016-10-13 | 2016-07-23 | 2016-01-27 | 2016-05-24 | 2017-06-30 | 2016-09-29 | 2017-09-06 | 2016-03-01 | 2013-12-21 | 2012-03-14 | 2015-09-11 | 2014-08-01 | 2015-01-28 | 2014-05-24 | 2017-08-22 | 2014-05-10 | 2015-07-22 | 2015-02-04 | 2015-09-08 | &lt;/ol&gt; &#54028;&#51060;&#54532;&#46972;&#51064;&#51004;&#47196; &#53364;&#47532;&#45789;&#44284;&#51221; &#52628;&#44032;&#54616;&#44592; . # mutate( = )덮어써주기 . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate(OP_date=as.Date(OP_date, format = &quot;%Y-%m-%d&quot;)) # + 1) . mutate() &#45824;&#49888; mutate_at( vars(&#44057;&#51008;&#51089;&#50629;&#54624;, &#52860;&#47084;&#46308;), list(~&#51201;&#50857;&#54632;&#49688;(.&#51004;&#47196; &#52860;&#47100;&#45824;&#52404;)) &#47196; &#50668;&#47084;&#52860;&#47100; &#54620;&#48264;&#50640; &#52376;&#47532;&#54616;&#44592; . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) . summary(dat1) . id age sex Recur Min. : 1.00 Min. :25.00 Min. :0.00 Min. :0.00 1st Qu.:13.25 1st Qu.:49.25 1st Qu.:0.00 1st Qu.:0.00 Median :25.50 Median :58.50 Median :1.00 Median :0.00 Mean :25.50 Mean :56.44 Mean :0.66 Mean :0.44 3rd Qu.:37.75 3rd Qu.:65.75 3rd Qu.:1.00 3rd Qu.:1.00 Max. :50.00 Max. :79.00 Max. :1.00 Max. :1.00 OP_date Recur_date local_6m CA19.9 Min. :2011-12-29 Min. :2012-04-09 Min. :0.00 &lt;1.0 : 2 1st Qu.:2015-01-28 1st Qu.:2016-06-25 1st Qu.:0.00 10.8 : 2 Median :2015-11-08 Median :2018-03-13 Median :0.00 5.9 : 2 Mean :2015-08-11 Mean :2017-09-21 Mean :0.46 10.7 : 1 3rd Qu.:2016-09-05 3rd Qu.:2019-10-12 3rd Qu.:1.00 11.4 : 1 Max. :2017-11-14 Max. :2020-01-11 Max. :1.00 12.1 : 1 (Other):41 CEA TNM CCI adc_decrease Min. : 0.630 Min. :1.00 Min. :0 42.83881378 : 9 1st Qu.: 1.450 1st Qu.:3.00 1st Qu.:1 -2.473731995: 4 Median : 2.500 Median :4.00 Median :2 -1.790367126: 1 Mean : 5.574 Mean :3.56 Mean :2 . : 1 3rd Qu.: 4.150 3rd Qu.:4.00 3rd Qu.:3 0.423 : 1 Max. :115.900 Max. :5.00 Max. :6 10.24687958 : 1 (Other) :33 adc_5_decrease volume_change apt_1_mean apt_1_95p Min. :-6.717 n/a : 2 Min. : 0.628 Min. :1.267 1st Qu.: 2.566 -12.57099533: 1 1st Qu.: 1.831 1st Qu.:2.517 Median :11.329 -14.51074219: 1 Median : 2.510 Median :3.034 Mean :10.998 -2.133106232: 1 Mean : 3.129 Mean :3.065 3rd Qu.:15.638 -2.357226849: 1 3rd Qu.: 3.100 3rd Qu.:3.650 Max. :63.617 -20.45214844: 1 Max. :27.473 Max. :5.437 (Other) :43 adc_1_mean adc_1_5p : 1 Min. : 53.86 100.3332748: 1 1st Qu.: 75.78 100.7850723: 1 Median : 85.10 101.1288986: 1 Mean : 85.03 106.94384 : 1 3rd Qu.: 92.43 107.4796753: 1 Max. :116.59 (Other) :44 . &#50672;&#49549;&#54805;&#51064;&#45936; character&#51064; &#50528;&#46308; . dat0$CA19.9 # 피검사 랩value # ~보다 작다(&lt;1)로 입력되는 경우가 많은데, 숫자가 아닌 . &lt;ol class=list-inline&gt; 4490 | 37.8 | 36.6 | 65 | 38.9 | 5.9 | 23.3 | 53.2 | 19.8 | 84.7 | 4860 | 50.2 | 15.9 | 18.9 | &lt;1.0 | 59.4 | 12.6 | 81.4 | 2500 | 6.6 | 71.1 | 4.3 | 68.7 | 11.4 | 10.8 | 10.8 | 5.9 | 3.3 | 14.4 | 47.9 | 25.6 | 134.1 | 10.7 | 472 | 160.6 | 23.2 | 20.4 | 3.4 | 55.3 | 9.2 | 5.1 | 12.1 | 2647 | 24.5 | 17.9 | 33.8 | 5.8 | 5.6 | &lt;1.0 | 99.3 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;&lt;1.0&#39; | &#39;10.7&#39; | &#39;10.8&#39; | &#39;11.4&#39; | &#39;12.1&#39; | &#39;12.6&#39; | &#39;134.1&#39; | &#39;14.4&#39; | &#39;15.9&#39; | &#39;160.6&#39; | &#39;17.9&#39; | &#39;18.9&#39; | &#39;19.8&#39; | &#39;20.4&#39; | &#39;23.2&#39; | &#39;23.3&#39; | &#39;24.5&#39; | &#39;25.6&#39; | &#39;2500&#39; | &#39;2647&#39; | &#39;3.3&#39; | &#39;3.4&#39; | &#39;33.8&#39; | &#39;36.6&#39; | &#39;37.8&#39; | &#39;38.9&#39; | &#39;4.3&#39; | &#39;4490&#39; | &#39;47.9&#39; | &#39;472&#39; | &#39;4860&#39; | &#39;5.1&#39; | &#39;5.6&#39; | &#39;5.8&#39; | &#39;5.9&#39; | &#39;50.2&#39; | &#39;53.2&#39; | &#39;55.3&#39; | &#39;59.4&#39; | &#39;6.6&#39; | &#39;65&#39; | &#39;68.7&#39; | &#39;71.1&#39; | &#39;81.4&#39; | &#39;84.7&#39; | &#39;9.2&#39; | &#39;99.3&#39; | &lt;/ol&gt; . replace&#47196; &#47928;&#51088;&#50676;&#49707;&#51088; -&gt; &#49707;&#51088;&#47196; &#48148;&#45012;&#51452;&#44592; . replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)#위치 #바꿀값 # 숫자로 바꿔졌찌만, 칼럼 전체가 케릭터(팩터)라 &quot;1&quot;로 들어갈 듯 # 칼럼 전체가 응답된다. . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . &lt;ol class=list-inline&gt; 4490 | 37.8 | 36.6 | 65 | 38.9 | 5.9 | 23.3 | 53.2 | 19.8 | 84.7 | 4860 | 50.2 | 15.9 | 18.9 | &lt;NA&gt; | 59.4 | 12.6 | 81.4 | 2500 | 6.6 | 71.1 | 4.3 | 68.7 | 11.4 | 10.8 | 10.8 | 5.9 | 3.3 | 14.4 | 47.9 | 25.6 | 134.1 | 10.7 | 472 | 160.6 | 23.2 | 20.4 | 3.4 | 55.3 | 9.2 | 5.1 | 12.1 | 2647 | 24.5 | 17.9 | 33.8 | 5.8 | 5.6 | &lt;NA&gt; | 99.3 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;&lt;1.0&#39; | &#39;10.7&#39; | &#39;10.8&#39; | &#39;11.4&#39; | &#39;12.1&#39; | &#39;12.6&#39; | &#39;134.1&#39; | &#39;14.4&#39; | &#39;15.9&#39; | &#39;160.6&#39; | &#39;17.9&#39; | &#39;18.9&#39; | &#39;19.8&#39; | &#39;20.4&#39; | &#39;23.2&#39; | &#39;23.3&#39; | &#39;24.5&#39; | &#39;25.6&#39; | &#39;2500&#39; | &#39;2647&#39; | &#39;3.3&#39; | &#39;3.4&#39; | &#39;33.8&#39; | &#39;36.6&#39; | &#39;37.8&#39; | &#39;38.9&#39; | &#39;4.3&#39; | &#39;4490&#39; | &#39;47.9&#39; | &#39;472&#39; | &#39;4860&#39; | &#39;5.1&#39; | &#39;5.6&#39; | &#39;5.8&#39; | &#39;5.9&#39; | &#39;50.2&#39; | &#39;53.2&#39; | &#39;55.3&#39; | &#39;59.4&#39; | &#39;6.6&#39; | &#39;65&#39; | &#39;68.7&#39; | &#39;71.1&#39; | &#39;81.4&#39; | &#39;84.7&#39; | &#39;9.2&#39; | &#39;99.3&#39; | &lt;/ol&gt; as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . &lt;ol class=list-inline&gt; 28 | 25 | 24 | 41 | 26 | 35 | 16 | 37 | 13 | 45 | 31 | 36 | 9 | 12 | &lt;NA&gt; | 39 | 6 | 44 | 19 | 40 | 43 | 27 | 42 | 4 | 3 | 3 | 35 | 21 | 8 | 29 | 18 | 7 | 2 | 30 | 10 | 15 | 14 | 22 | 38 | 46 | 32 | 5 | 20 | 17 | 11 | 23 | 34 | 33 | &lt;NA&gt; | 47 | &lt;/ol&gt; dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . summary(dat1) . id age sex Recur Min. : 1.00 Min. :25.00 Min. :0.00 Min. :0.00 1st Qu.:13.25 1st Qu.:49.25 1st Qu.:0.00 1st Qu.:0.00 Median :25.50 Median :58.50 Median :1.00 Median :0.00 Mean :25.50 Mean :56.44 Mean :0.66 Mean :0.44 3rd Qu.:37.75 3rd Qu.:65.75 3rd Qu.:1.00 3rd Qu.:1.00 Max. :50.00 Max. :79.00 Max. :1.00 Max. :1.00 OP_date Recur_date local_6m CA19.9 Min. :2011-12-29 Min. :2012-04-09 Min. :0.00 Min. : 2.00 1st Qu.:2015-01-28 1st Qu.:2016-06-25 1st Qu.:0.00 1st Qu.:12.75 Median :2015-11-08 Median :2018-03-13 Median :0.00 Median :24.50 Mean :2015-08-11 Mean :2017-09-21 Mean :0.46 Mean :24.27 3rd Qu.:2016-09-05 3rd Qu.:2019-10-12 3rd Qu.:1.00 3rd Qu.:35.25 Max. :2017-11-14 Max. :2020-01-11 Max. :1.00 Max. :47.00 NA&#39;s :2 CEA TNM CCI adc_decrease Min. : 0.630 Min. :1.00 Min. :0 42.83881378 : 9 1st Qu.: 1.450 1st Qu.:3.00 1st Qu.:1 -2.473731995: 4 Median : 2.500 Median :4.00 Median :2 -1.790367126: 1 Mean : 5.574 Mean :3.56 Mean :2 . : 1 3rd Qu.: 4.150 3rd Qu.:4.00 3rd Qu.:3 0.423 : 1 Max. :115.900 Max. :5.00 Max. :6 10.24687958 : 1 (Other) :33 adc_5_decrease volume_change apt_1_mean apt_1_95p Min. :-6.717 n/a : 2 Min. : 0.628 Min. :1.267 1st Qu.: 2.566 -12.57099533: 1 1st Qu.: 1.831 1st Qu.:2.517 Median :11.329 -14.51074219: 1 Median : 2.510 Median :3.034 Mean :10.998 -2.133106232: 1 Mean : 3.129 Mean :3.065 3rd Qu.:15.638 -2.357226849: 1 3rd Qu.: 3.100 3rd Qu.:3.650 Max. :63.617 -20.45214844: 1 Max. :27.473 Max. :5.437 (Other) :43 adc_1_mean adc_1_5p : 1 Min. : 53.86 100.3332748: 1 1st Qu.: 75.78 100.7850723: 1 Median : 85.10 101.1288986: 1 Mean : 85.03 106.94384 : 1 3rd Qu.: 92.43 107.4796753: 1 Max. :116.59 (Other) :44 . &#47928;&#51088;&#50676;&quot;.&quot;&#44284; &quot;na&quot;&#51060;&#44032; &#46308;&#50612;&#44032;&#51080;&#45716; &#49707;&#51088;&#54805; &#48320;&#49688; -&gt; &#44208;&#52769;(&#45824;&#47928;&#51088; &quot;NA&quot;)&#51004;&#47196; &#52376;&#47532;&#54644;&#48372;&#51088;. . dat0$adc_decrease . &lt;ol class=list-inline&gt; 8.83908844 | -2.473731995 | 24.08946228 | 42.83881378 | 5.897392273 | na | 12.79924774 | 42.83881378 | 10.24687958 | 16.47277069 | 3.877372742 | 17.01249695 | 4.098892212 | 42.83881378 | 30.9415741 | 11.229599 | 42.83881378 | 37.16684723 | 25.70823669 | -2.473731995 | 40.03754425 | 17.24663544 | 5.312309265 | 33.87471008 | 42.83881378 | 26.80117798 | 6.082252502 | 35.74214172 | 42.83881378 | 21.19241333 | 15.09790039 | 7.512702942 | 9.244918823 | 25.51950836 | 42.83881378 | . | 22.15099335 | 12.68886566 | 17.57089233 | 42.83881378 | 70.52548981 | 10.59333801 | -1.790367126 | 19.15110016 | -2.473731995 | 0.423 | 42.83881378 | 15.3989563 | -2.473731995 | 40.38618469 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;-1.790367126&#39; | &#39;-2.473731995&#39; | &#39;.&#39; | &#39;0.423&#39; | &#39;10.24687958&#39; | &#39;10.59333801&#39; | &#39;11.229599&#39; | &#39;12.68886566&#39; | &#39;12.79924774&#39; | &#39;15.09790039&#39; | &#39;15.3989563&#39; | &#39;16.47277069&#39; | &#39;17.01249695&#39; | &#39;17.24663544&#39; | &#39;17.57089233&#39; | &#39;19.15110016&#39; | &#39;21.19241333&#39; | &#39;22.15099335&#39; | &#39;24.08946228&#39; | &#39;25.51950836&#39; | &#39;25.70823669&#39; | &#39;26.80117798&#39; | &#39;3.877372742&#39; | &#39;30.9415741&#39; | &#39;33.87471008&#39; | &#39;35.74214172&#39; | &#39;37.16684723&#39; | &#39;4.098892212&#39; | &#39;40.03754425&#39; | &#39;40.38618469&#39; | &#39;42.83881378&#39; | &#39;5.312309265&#39; | &#39;5.897392273&#39; | &#39;6.082252502&#39; | &#39;7.512702942&#39; | &#39;70.52548981&#39; | &#39;8.83908844&#39; | &#39;9.244918823&#39; | &#39;na&#39; | &lt;/ol&gt; dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . summary(dat1) . id age sex Recur Min. : 1.00 Min. :25.00 Min. :0.00 Min. :0.00 1st Qu.:13.25 1st Qu.:49.25 1st Qu.:0.00 1st Qu.:0.00 Median :25.50 Median :58.50 Median :1.00 Median :0.00 Mean :25.50 Mean :56.44 Mean :0.66 Mean :0.44 3rd Qu.:37.75 3rd Qu.:65.75 3rd Qu.:1.00 3rd Qu.:1.00 Max. :50.00 Max. :79.00 Max. :1.00 Max. :1.00 OP_date Recur_date local_6m CA19.9 Min. :2011-12-29 Min. :2012-04-09 Min. :0.00 Min. : 2.00 1st Qu.:2015-01-28 1st Qu.:2016-06-25 1st Qu.:0.00 1st Qu.:12.75 Median :2015-11-08 Median :2018-03-13 Median :0.00 Median :24.50 Mean :2015-08-11 Mean :2017-09-21 Mean :0.46 Mean :24.27 3rd Qu.:2016-09-05 3rd Qu.:2019-10-12 3rd Qu.:1.00 3rd Qu.:35.25 Max. :2017-11-14 Max. :2020-01-11 Max. :1.00 Max. :47.00 NA&#39;s :2 CEA TNM CCI adc_decrease adc_5_decrease Min. : 0.630 Min. :1.00 Min. :0 Min. : 1.00 Min. :-6.717 1st Qu.: 1.450 1st Qu.:3.00 1st Qu.:1 1st Qu.:10.75 1st Qu.: 2.566 Median : 2.500 Median :4.00 Median :2 Median :22.50 Median :11.329 Mean : 5.574 Mean :3.56 Mean :2 Mean :20.67 Mean :10.998 3rd Qu.: 4.150 3rd Qu.:4.00 3rd Qu.:3 3rd Qu.:31.00 3rd Qu.:15.638 Max. :115.900 Max. :5.00 Max. :6 Max. :38.00 Max. :63.617 NA&#39;s :2 volume_change apt_1_mean apt_1_95p adc_1_mean n/a : 2 Min. : 0.628 Min. :1.267 : 1 -12.57099533: 1 1st Qu.: 1.831 1st Qu.:2.517 100.3332748: 1 -14.51074219: 1 Median : 2.510 Median :3.034 100.7850723: 1 -2.133106232: 1 Mean : 3.129 Mean :3.065 101.1288986: 1 -2.357226849: 1 3rd Qu.: 3.100 3rd Qu.:3.650 106.94384 : 1 -20.45214844: 1 Max. :27.473 Max. :5.437 107.4796753: 1 (Other) :43 (Other) :44 adc_1_5p Min. : 53.86 1st Qu.: 75.78 Median : 85.10 Mean : 85.03 3rd Qu.: 92.43 Max. :116.59 . &quot;n/a&quot; &#52376;&#47532; volume_change&#51032; &#47928;&#51228; . dat0$volume_change . &lt;ol class=list-inline&gt; -2.357226849 | 140.736618 | 57.76787567 | 3.21591568 | -3.059473038 | 26.99385071 | 15.75263786 | -14.51074219 | 35.89277363 | -23.29013634 | -24.1180644 | n/a | 14.30595779 | n/a | 61.12881088 | 80.11054611 | 29.39501953 | 80.77587891 | -42.23847198 | 68.45624542 | 64.41679382 | 116.6783257 | 8.413768768 | 14.72431612 | 7.143749237 | 1.901952744 | 33.4467752 | 118.6039994 | 119.1181564 | 3.223827362 | 80.79081726 | -28.04677582 | -6.659473419 | 39.32578278 | -2.133106232 | 71.6211853 | 88.36875153 | 23.59248352 | 4.665237427 | 21.60439301 | 51.39668274 | 40.27851391 | -12.57099533 | -5.537094116 | 91.3113327 | 24.23391724 | 12.77226639 | 34.60077667 | -20.45214844 | 125.2863274 | &lt;/ol&gt; &lt;summary style=display:list-item;cursor:pointer&gt; Levels: &lt;/summary&gt; &lt;ol class=list-inline&gt; &#39;-12.57099533&#39; | &#39;-14.51074219&#39; | &#39;-2.133106232&#39; | &#39;-2.357226849&#39; | &#39;-20.45214844&#39; | &#39;-23.29013634&#39; | &#39;-24.1180644&#39; | &#39;-28.04677582&#39; | &#39;-3.059473038&#39; | &#39;-42.23847198&#39; | &#39;-5.537094116&#39; | &#39;-6.659473419&#39; | &#39;1.901952744&#39; | &#39;116.6783257&#39; | &#39;118.6039994&#39; | &#39;119.1181564&#39; | &#39;12.77226639&#39; | &#39;125.2863274&#39; | &#39;14.30595779&#39; | &#39;14.72431612&#39; | &#39;140.736618&#39; | &#39;15.75263786&#39; | &#39;21.60439301&#39; | &#39;23.59248352&#39; | &#39;24.23391724&#39; | &#39;26.99385071&#39; | &#39;29.39501953&#39; | &#39;3.21591568&#39; | &#39;3.223827362&#39; | &#39;33.4467752&#39; | &#39;34.60077667&#39; | &#39;35.89277363&#39; | &#39;39.32578278&#39; | &#39;4.665237427&#39; | &#39;40.27851391&#39; | &#39;51.39668274&#39; | &#39;57.76787567&#39; | &#39;61.12881088&#39; | &#39;64.41679382&#39; | &#39;68.45624542&#39; | &#39;7.143749237&#39; | &#39;71.6211853&#39; | &#39;8.413768768&#39; | &#39;80.11054611&#39; | &#39;80.77587891&#39; | &#39;80.79081726&#39; | &#39;88.36875153&#39; | &#39;91.3113327&#39; | &#39;n/a&#39; | &lt;/ol&gt; dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), # 마지막엔 더블형변환해야하니 as.double부터 volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . 범주형인데, 연속형으로 표기되어있는 -&gt; mutate_at&lt;/h4&gt; local_6m , sex? | . &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), # 마지막엔 더블형변환해야하니 as.double부터 volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA))) %&gt;% mutate_at(vars(sex, Recur, local_6m, TNM, CCI), list(~as.factor(.))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . summary(dat1) . id age sex Recur OP_date Min. : 1.00 Min. :25.00 0:17 0:28 Min. :2011-12-29 1st Qu.:13.25 1st Qu.:49.25 1:33 1:22 1st Qu.:2015-01-28 Median :25.50 Median :58.50 Median :2015-11-08 Mean :25.50 Mean :56.44 Mean :2015-08-11 3rd Qu.:37.75 3rd Qu.:65.75 3rd Qu.:2016-09-05 Max. :50.00 Max. :79.00 Max. :2017-11-14 Recur_date local_6m CA19.9 CEA TNM CCI Min. :2012-04-09 0:27 Min. : 2.00 Min. : 0.630 1: 2 0: 3 1st Qu.:2016-06-25 1:23 1st Qu.:12.75 1st Qu.: 1.450 2: 5 1:16 Median :2018-03-13 Median :24.50 Median : 2.500 3:12 2:15 Mean :2017-09-21 Mean :24.27 Mean : 5.574 4:25 3:12 3rd Qu.:2019-10-12 3rd Qu.:35.25 3rd Qu.: 4.150 5: 6 4: 3 Max. :2020-01-11 Max. :47.00 Max. :115.900 6: 1 NA&#39;s :2 adc_decrease adc_5_decrease volume_change apt_1_mean Min. : 1.00 Min. :-6.717 Min. : 1.00 Min. : 0.628 1st Qu.:10.75 1st Qu.: 2.566 1st Qu.:12.75 1st Qu.: 1.831 Median :22.50 Median :11.329 Median :24.50 Median : 2.510 Mean :20.67 Mean :10.998 Mean :24.50 Mean : 3.129 3rd Qu.:31.00 3rd Qu.:15.638 3rd Qu.:36.25 3rd Qu.: 3.100 Max. :38.00 Max. :63.617 Max. :48.00 Max. :27.473 NA&#39;s :2 NA&#39;s :2 apt_1_95p adc_1_mean adc_1_5p Min. :1.267 : 1 Min. : 53.86 1st Qu.:2.517 100.3332748: 1 1st Qu.: 75.78 Median :3.034 100.7850723: 1 Median : 85.10 Mean :3.065 101.1288986: 1 Mean : 85.03 3rd Qu.:3.650 106.94384 : 1 3rd Qu.: 92.43 Max. :5.437 107.4796753: 1 Max. :116.59 (Other) :44 . &#53888;&#50612;&#45716; &#44050;&#46308;(LabValue&#46308;)&#51012; log&#48320;&#54872; . CA19.9 정상치는 거기서 거기인데, 이상인 경우 수천배로 팍 튀는 경우 -&gt; 데이터의 분포가 너무 길어져 원본으로는 다른변수와의 관계가 깨진다. | . hist&#47484; &#44536;&#47140;, &#44537;&#49548;&#49688;&#47564; &#50628;&#52397; &#53888;&#45716; &#44163;&#51012; &#54869;&#51064;&#54616;&#51088;. . hist(dat1$CA19.9) . &#12615;&#12615; . hist( log) . log.&#51012; &#48537;&#50668; &#49352;&#47196;&#50868; &#48320;&#49688;&#47196; &#52628;&#44032; . 0이 있으면 다른 값 or 1로 바꿔서 로그취해야함. | . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA)), # 여기(mutate)다 추가 log.CA19.9 = log(CA19.9), log.CEA=log(CEA) # 위에다 추가 ) %&gt;% mutate_at(vars(sex, Recur, local_6m, TNM, CCI), list(~as.factor(.))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . 36&#48516; &#48148;&#51060;&#45789; CA19 &#52628;&#44032; by ifelse -&gt; asfactor&#51089;&#50629;&#50640;&#46020; &#48320;&#49688; 1&#44060; &#52628;&#44032; . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA)), log.CA19.9 = log(CA19.9), log.CEA=log(CEA), CA19.9.group=ifelse(CA19.9&gt;37, 1, 0), # 칼럼 생성 ) %&gt;% mutate_at(vars(sex, Recur, local_6m, TNM, CCI, CA19.9 # factor화 추가 ), list(~as.factor(.))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . ply r &#51012; &#53685;&#54644; mapvalue (1,2&#47484; &#47926;&#50612; -&gt; TNM.b&#52860;&#47100;&#51004;&#47196;)&#50416;&#44592; . from 원래 카테고리 -&gt; to = 합칠거명 같은이름으로 순서대로 차례대로 카테고리 ) | 다시 범주형 만드는 곳에서 처리 | . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA)), log.CA19.9 = log(CA19.9), log.CEA=log(CEA), CA19.9.group=ifelse(CA19.9&gt;37, 1, 0), TNM.b = mapvalues(TNM, from=c(1,2,3,4,5), to=c(&quot;1or2&quot;, &quot;1or2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)), # 카테고리 합치기 ) %&gt;% mutate_at(vars(sex, Recur, local_6m, TNM, CCI, CA19.9, TNM.b # 추가 ), list(~as.factor(.))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . dat1 &lt;- dat0 %&gt;% rename(Recur=Recur..1..Recur..0..Censored.) %&gt;% mutate_at(vars(OP_date, Recur_date), list(~as.Date(., format = &quot;%Y-%m-%d&quot;) )) %&gt;% mutate(CA19.9=as.double(replace(dat0$CA19.9, dat0$CA19.9 == &quot;&lt;1.0&quot;, 1)), adc_decrease=as.double(replace( adc_decrease, adc_decrease==&quot;na&quot; | adc_decrease==&quot;.&quot;, NA)), volume_change=as.double(replace(volume_change, volume_change==&quot;n/a&quot;, NA)), log.CA19.9 = log(CA19.9), log.CEA=log(CEA), CA19.9.group=ifelse(CA19.9&gt;37, 1, 0), TNM.b = mapvalues(TNM, from=c(1,2,3,4,5), to=c(&quot;1or2&quot;, &quot;1or2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)), CCI.b = mapvalues(CCI, from=c(0,1,2,3,4,6), to=c(&quot;0or1&quot;, &quot;0or1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;&gt;=4&quot;, &quot;&gt;=4&quot;)), ) %&gt;% mutate_at(vars(sex, Recur, local_6m, TNM, CCI, CA19.9, TNM.b # 추가 ), list(~as.factor(.))) . Warning message in `[&lt;-.factor`(`*tmp*`, list, value = 1): &#34;invalid factor level, NA generated&#34; . &#50668;&#44592;&#49436;&#48512;&#53552;&#45716; &#47803;&#46384;&#46972;&#44048; . # as.factor가 아닌 factor로 어떤 순서대로 카테고리를 하고싶은지 인식시켜준다 # 아래에서 as.factor부분에서 빼준다. . 45&#48516;&#48512;&#53552; &#47803;&#46384;&#46972;&#44048;.. . 48&#44620;&#51648; &#53364;&#47532;&#45789;&#51008; &#45149; . library(&quot;tableone&quot;) . tableone&#51004;&#47196; &#49789;&#44172; table&#47564;&#46308;&#44592; . var1&lt;-c(&quot;Recur&quot;, &quot;RFS&quot;, &quot;local_6m&quot;, &quot;age&quot;, &quot;sex&quot;, &quot;CA19.9&quot;, &quot;log.CA19.9&quot;, &quot;CA19.9.group&quot;, &quot;CEA&quot;, &quot;log.CEA&quot;, &quot;TNM&quot;, &quot;TNM.b&quot;, &quot;CCI&quot;, &quot;CCI.b&quot;, &quot;adc_decrease&quot;, &quot;adc_5_decrease&quot;, &quot;volume_change&quot;, &quot;apt_1_mean&quot;, &quot;apt_1_95p&quot;, &quot;adc_1_mean&quot;, &quot;adc_1_5p&quot;) . tobj&lt;-CreateTableOne(vars = var1, data=dat1) summary(tobj) . Warning message in ModuleReturnVarsExist(vars, data): &#34;The data frame does not have: RFS Dropped&#34; . ### Summary of continuous variables ### strata: Overall n miss p.miss mean sd median p25 p75 min max skew kurt age 50 0 0 56.4 12.6 58.5 49.2 66 25.0 79 -0.47 -0.3 log.CA19.9 50 2 4 2.9 0.8 3.2 2.5 4 0.7 4 -1.12 0.5 CA19.9.group 50 2 4 0.2 0.4 0.0 0.0 0 0.0 1 1.48 0.2 CEA 50 0 0 5.6 16.3 2.5 1.4 4 0.6 116 6.63 45.5 log.CEA 50 0 0 1.0 0.9 0.9 0.4 1 -0.5 5 1.81 5.8 adc_decrease 50 2 4 20.7 11.5 22.5 10.8 31 1.0 38 -0.31 -1.3 adc_5_decrease 50 0 0 11.0 12.2 11.3 2.6 16 -6.7 64 1.74 6.0 volume_change 50 2 4 24.5 14.0 24.5 12.8 36 1.0 48 0.00 -1.2 apt_1_mean 50 0 0 3.1 3.7 2.5 1.8 3 0.6 27 6.06 40.2 apt_1_95p 50 0 0 3.1 0.9 3.0 2.5 4 1.3 5 0.40 0.5 adc_1_5p 50 0 0 85.0 11.5 85.1 75.8 92 53.9 117 0.05 0.5 ======================================================================================= ### Summary of categorical variables ### strata: Overall var n miss p.miss level freq percent cum.percent Recur 50 0 0.0 0 28 56.0 56.0 1 22 44.0 100.0 local_6m 50 0 0.0 0 27 54.0 54.0 1 23 46.0 100.0 sex 50 0 0.0 0 17 34.0 34.0 1 33 66.0 100.0 CA19.9 50 2 4.0 2 1 2.1 2.1 3 2 4.2 6.2 4 1 2.1 8.3 5 1 2.1 10.4 6 1 2.1 12.5 7 1 2.1 14.6 8 1 2.1 16.7 9 1 2.1 18.8 10 1 2.1 20.8 11 1 2.1 22.9 12 1 2.1 25.0 13 1 2.1 27.1 14 1 2.1 29.2 15 1 2.1 31.2 16 1 2.1 33.3 17 1 2.1 35.4 18 1 2.1 37.5 19 1 2.1 39.6 20 1 2.1 41.7 21 1 2.1 43.8 22 1 2.1 45.8 23 1 2.1 47.9 24 1 2.1 50.0 25 1 2.1 52.1 26 1 2.1 54.2 27 1 2.1 56.2 28 1 2.1 58.3 29 1 2.1 60.4 30 1 2.1 62.5 31 1 2.1 64.6 32 1 2.1 66.7 33 1 2.1 68.8 34 1 2.1 70.8 35 2 4.2 75.0 36 1 2.1 77.1 37 1 2.1 79.2 38 1 2.1 81.2 39 1 2.1 83.3 40 1 2.1 85.4 41 1 2.1 87.5 42 1 2.1 89.6 43 1 2.1 91.7 44 1 2.1 93.8 45 1 2.1 95.8 46 1 2.1 97.9 47 1 2.1 100.0 TNM 50 0 0.0 1 2 4.0 4.0 2 5 10.0 14.0 3 12 24.0 38.0 4 25 50.0 88.0 5 6 12.0 100.0 TNM.b 50 0 0.0 1or2 7 14.0 14.0 3 12 24.0 38.0 4 25 50.0 88.0 5 6 12.0 100.0 CCI 50 0 0.0 0 3 6.0 6.0 1 16 32.0 38.0 2 15 30.0 68.0 3 12 24.0 92.0 4 3 6.0 98.0 6 1 2.0 100.0 CCI.b 50 0 0.0 &gt;=4 4 8.0 8.0 0or1 19 38.0 46.0 2 15 30.0 76.0 3 12 24.0 100.0 adc_1_mean 50 0 0.0 1 2.0 2.0 100.3332748 1 2.0 4.0 100.7850723 1 2.0 6.0 101.1288986 1 2.0 8.0 106.94384 1 2.0 10.0 107.4796753 1 2.0 12.0 108.1219025 1 2.0 14.0 108.4807739 1 2.0 16.0 109.8269577 1 2.0 18.0 110.6593323 1 2.0 20.0 112.250946 1 2.0 22.0 112.6311264 1 2.0 24.0 113.6343842 1 2.0 26.0 114.5146027 1 2.0 28.0 116.6255951 1 2.0 30.0 116.9603348 1 2.0 32.0 119.7995605 1 2.0 34.0 121.1716843 1 2.0 36.0 123.4509964 1 2.0 38.0 123.5778046 1 2.0 40.0 125.6047516 1 2.0 42.0 125.8717575 1 2.0 44.0 127.4504852 1 2.0 46.0 128.1634064 1 2.0 48.0 128.2574005 1 2.0 50.0 128.8485718 1 2.0 52.0 129.5490875 1 2.0 54.0 129.7754059 1 2.0 56.0 130.4454651 1 2.0 58.0 131.0157623 1 2.0 60.0 131.2865448 1 2.0 62.0 133.0798645 1 2.0 64.0 134.7369385 1 2.0 66.0 137.2429199 1 2.0 68.0 137.4812317 1 2.0 70.0 138.7712097 1 2.0 72.0 139.8694763 1 2.0 74.0 140.6768646 1 2.0 76.0 142.7576294 1 2.0 78.0 144.4676361 1 2.0 80.0 144.8905334 1 2.0 82.0 146.3157654 1 2.0 84.0 149.0292358 1 2.0 86.0 152.9427185 1 2.0 88.0 154.0635529 1 2.0 90.0 154.9950104 1 2.0 92.0 82.6672821 1 2.0 94.0 89.37554932 1 2.0 96.0 99.98454285 1 2.0 98.0 n/a 1 2.0 100.0 . . # 범주형 변수들의 요약통계량이 나온다. 갯수와 % . print(tobj) . Overall n 50 Recur = 1 (%) 22 (44.0) local_6m = 1 (%) 23 (46.0) age (mean (SD)) 56.44 (12.60) sex = 1 (%) 33 (66.0) CA19.9 (%) 2 1 ( 2.1) 3 2 ( 4.2) 4 1 ( 2.1) 5 1 ( 2.1) 6 1 ( 2.1) 7 1 ( 2.1) 8 1 ( 2.1) 9 1 ( 2.1) 10 1 ( 2.1) 11 1 ( 2.1) 12 1 ( 2.1) 13 1 ( 2.1) 14 1 ( 2.1) 15 1 ( 2.1) 16 1 ( 2.1) 17 1 ( 2.1) 18 1 ( 2.1) 19 1 ( 2.1) 20 1 ( 2.1) 21 1 ( 2.1) 22 1 ( 2.1) 23 1 ( 2.1) 24 1 ( 2.1) 25 1 ( 2.1) 26 1 ( 2.1) 27 1 ( 2.1) 28 1 ( 2.1) 29 1 ( 2.1) 30 1 ( 2.1) 31 1 ( 2.1) 32 1 ( 2.1) 33 1 ( 2.1) 34 1 ( 2.1) 35 2 ( 4.2) 36 1 ( 2.1) 37 1 ( 2.1) 38 1 ( 2.1) 39 1 ( 2.1) 40 1 ( 2.1) 41 1 ( 2.1) 42 1 ( 2.1) 43 1 ( 2.1) 44 1 ( 2.1) 45 1 ( 2.1) 46 1 ( 2.1) 47 1 ( 2.1) log.CA19.9 (mean (SD)) 2.95 (0.81) CA19.9.group (mean (SD)) 0.21 (0.41) CEA (mean (SD)) 5.57 (16.28) log.CEA (mean (SD)) 0.99 (0.89) TNM (%) 1 2 ( 4.0) 2 5 (10.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) TNM.b (%) 1or2 7 (14.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) CCI (%) 0 3 ( 6.0) 1 16 (32.0) 2 15 (30.0) 3 12 (24.0) 4 3 ( 6.0) 6 1 ( 2.0) CCI.b (%) &gt;=4 4 ( 8.0) 0or1 19 (38.0) 2 15 (30.0) 3 12 (24.0) adc_decrease (mean (SD)) 20.67 (11.49) adc_5_decrease (mean (SD)) 11.00 (12.19) volume_change (mean (SD)) 24.50 (14.00) apt_1_mean (mean (SD)) 3.13 (3.70) apt_1_95p (mean (SD)) 3.07 (0.88) adc_1_mean (%) 1 ( 2.0) 100.3332748 1 ( 2.0) 100.7850723 1 ( 2.0) 101.1288986 1 ( 2.0) 106.94384 1 ( 2.0) 107.4796753 1 ( 2.0) 108.1219025 1 ( 2.0) 108.4807739 1 ( 2.0) 109.8269577 1 ( 2.0) 110.6593323 1 ( 2.0) 112.250946 1 ( 2.0) 112.6311264 1 ( 2.0) 113.6343842 1 ( 2.0) 114.5146027 1 ( 2.0) 116.6255951 1 ( 2.0) 116.9603348 1 ( 2.0) 119.7995605 1 ( 2.0) 121.1716843 1 ( 2.0) 123.4509964 1 ( 2.0) 123.5778046 1 ( 2.0) 125.6047516 1 ( 2.0) 125.8717575 1 ( 2.0) 127.4504852 1 ( 2.0) 128.1634064 1 ( 2.0) 128.2574005 1 ( 2.0) 128.8485718 1 ( 2.0) 129.5490875 1 ( 2.0) 129.7754059 1 ( 2.0) 130.4454651 1 ( 2.0) 131.0157623 1 ( 2.0) 131.2865448 1 ( 2.0) 133.0798645 1 ( 2.0) 134.7369385 1 ( 2.0) 137.2429199 1 ( 2.0) 137.4812317 1 ( 2.0) 138.7712097 1 ( 2.0) 139.8694763 1 ( 2.0) 140.6768646 1 ( 2.0) 142.7576294 1 ( 2.0) 144.4676361 1 ( 2.0) 144.8905334 1 ( 2.0) 146.3157654 1 ( 2.0) 149.0292358 1 ( 2.0) 152.9427185 1 ( 2.0) 154.0635529 1 ( 2.0) 154.9950104 1 ( 2.0) 82.6672821 1 ( 2.0) 89.37554932 1 ( 2.0) 99.98454285 1 ( 2.0) n/a 1 ( 2.0) adc_1_5p (mean (SD)) 85.03 (11.48) . print(tobj, showAllLevels = T) . level Overall n 50 Recur (%) 0 28 (56.0) 1 22 (44.0) local_6m (%) 0 27 (54.0) 1 23 (46.0) age (mean (SD)) 56.44 (12.60) sex (%) 0 17 (34.0) 1 33 (66.0) CA19.9 (%) 2 1 ( 2.1) 3 2 ( 4.2) 4 1 ( 2.1) 5 1 ( 2.1) 6 1 ( 2.1) 7 1 ( 2.1) 8 1 ( 2.1) 9 1 ( 2.1) 10 1 ( 2.1) 11 1 ( 2.1) 12 1 ( 2.1) 13 1 ( 2.1) 14 1 ( 2.1) 15 1 ( 2.1) 16 1 ( 2.1) 17 1 ( 2.1) 18 1 ( 2.1) 19 1 ( 2.1) 20 1 ( 2.1) 21 1 ( 2.1) 22 1 ( 2.1) 23 1 ( 2.1) 24 1 ( 2.1) 25 1 ( 2.1) 26 1 ( 2.1) 27 1 ( 2.1) 28 1 ( 2.1) 29 1 ( 2.1) 30 1 ( 2.1) 31 1 ( 2.1) 32 1 ( 2.1) 33 1 ( 2.1) 34 1 ( 2.1) 35 2 ( 4.2) 36 1 ( 2.1) 37 1 ( 2.1) 38 1 ( 2.1) 39 1 ( 2.1) 40 1 ( 2.1) 41 1 ( 2.1) 42 1 ( 2.1) 43 1 ( 2.1) 44 1 ( 2.1) 45 1 ( 2.1) 46 1 ( 2.1) 47 1 ( 2.1) log.CA19.9 (mean (SD)) 2.95 (0.81) CA19.9.group (mean (SD)) 0.21 (0.41) CEA (mean (SD)) 5.57 (16.28) log.CEA (mean (SD)) 0.99 (0.89) TNM (%) 1 2 ( 4.0) 2 5 (10.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) TNM.b (%) 1or2 7 (14.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) CCI (%) 0 3 ( 6.0) 1 16 (32.0) 2 15 (30.0) 3 12 (24.0) 4 3 ( 6.0) 6 1 ( 2.0) CCI.b (%) &gt;=4 4 ( 8.0) 0or1 19 (38.0) 2 15 (30.0) 3 12 (24.0) adc_decrease (mean (SD)) 20.67 (11.49) adc_5_decrease (mean (SD)) 11.00 (12.19) volume_change (mean (SD)) 24.50 (14.00) apt_1_mean (mean (SD)) 3.13 (3.70) apt_1_95p (mean (SD)) 3.07 (0.88) adc_1_mean (%) 1 ( 2.0) 100.3332748 1 ( 2.0) 100.7850723 1 ( 2.0) 101.1288986 1 ( 2.0) 106.94384 1 ( 2.0) 107.4796753 1 ( 2.0) 108.1219025 1 ( 2.0) 108.4807739 1 ( 2.0) 109.8269577 1 ( 2.0) 110.6593323 1 ( 2.0) 112.250946 1 ( 2.0) 112.6311264 1 ( 2.0) 113.6343842 1 ( 2.0) 114.5146027 1 ( 2.0) 116.6255951 1 ( 2.0) 116.9603348 1 ( 2.0) 119.7995605 1 ( 2.0) 121.1716843 1 ( 2.0) 123.4509964 1 ( 2.0) 123.5778046 1 ( 2.0) 125.6047516 1 ( 2.0) 125.8717575 1 ( 2.0) 127.4504852 1 ( 2.0) 128.1634064 1 ( 2.0) 128.2574005 1 ( 2.0) 128.8485718 1 ( 2.0) 129.5490875 1 ( 2.0) 129.7754059 1 ( 2.0) 130.4454651 1 ( 2.0) 131.0157623 1 ( 2.0) 131.2865448 1 ( 2.0) 133.0798645 1 ( 2.0) 134.7369385 1 ( 2.0) 137.2429199 1 ( 2.0) 137.4812317 1 ( 2.0) 138.7712097 1 ( 2.0) 139.8694763 1 ( 2.0) 140.6768646 1 ( 2.0) 142.7576294 1 ( 2.0) 144.4676361 1 ( 2.0) 144.8905334 1 ( 2.0) 146.3157654 1 ( 2.0) 149.0292358 1 ( 2.0) 152.9427185 1 ( 2.0) 154.0635529 1 ( 2.0) 154.9950104 1 ( 2.0) 82.6672821 1 ( 2.0) 89.37554932 1 ( 2.0) 99.98454285 1 ( 2.0) n/a 1 ( 2.0) adc_1_5p (mean (SD)) 85.03 (11.48) . # 하지만 치우친 [기울어진 분포]의 연속형변수는 [ median, IQR ]를 뽑아야한다. print(tobj, showAllLevels = T, nonnormal = c(&quot;CA19.9&quot;, &quot;CEA&quot;)) . level Overall n 50 Recur (%) 0 28 (56.0) 1 22 (44.0) local_6m (%) 0 27 (54.0) 1 23 (46.0) age (mean (SD)) 56.44 (12.60) sex (%) 0 17 (34.0) 1 33 (66.0) CA19.9 (%) 2 1 ( 2.1) 3 2 ( 4.2) 4 1 ( 2.1) 5 1 ( 2.1) 6 1 ( 2.1) 7 1 ( 2.1) 8 1 ( 2.1) 9 1 ( 2.1) 10 1 ( 2.1) 11 1 ( 2.1) 12 1 ( 2.1) 13 1 ( 2.1) 14 1 ( 2.1) 15 1 ( 2.1) 16 1 ( 2.1) 17 1 ( 2.1) 18 1 ( 2.1) 19 1 ( 2.1) 20 1 ( 2.1) 21 1 ( 2.1) 22 1 ( 2.1) 23 1 ( 2.1) 24 1 ( 2.1) 25 1 ( 2.1) 26 1 ( 2.1) 27 1 ( 2.1) 28 1 ( 2.1) 29 1 ( 2.1) 30 1 ( 2.1) 31 1 ( 2.1) 32 1 ( 2.1) 33 1 ( 2.1) 34 1 ( 2.1) 35 2 ( 4.2) 36 1 ( 2.1) 37 1 ( 2.1) 38 1 ( 2.1) 39 1 ( 2.1) 40 1 ( 2.1) 41 1 ( 2.1) 42 1 ( 2.1) 43 1 ( 2.1) 44 1 ( 2.1) 45 1 ( 2.1) 46 1 ( 2.1) 47 1 ( 2.1) log.CA19.9 (mean (SD)) 2.95 (0.81) CA19.9.group (mean (SD)) 0.21 (0.41) CEA (median [IQR]) 2.50 [1.45, 4.15] log.CEA (mean (SD)) 0.99 (0.89) TNM (%) 1 2 ( 4.0) 2 5 (10.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) TNM.b (%) 1or2 7 (14.0) 3 12 (24.0) 4 25 (50.0) 5 6 (12.0) CCI (%) 0 3 ( 6.0) 1 16 (32.0) 2 15 (30.0) 3 12 (24.0) 4 3 ( 6.0) 6 1 ( 2.0) CCI.b (%) &gt;=4 4 ( 8.0) 0or1 19 (38.0) 2 15 (30.0) 3 12 (24.0) adc_decrease (mean (SD)) 20.67 (11.49) adc_5_decrease (mean (SD)) 11.00 (12.19) volume_change (mean (SD)) 24.50 (14.00) apt_1_mean (mean (SD)) 3.13 (3.70) apt_1_95p (mean (SD)) 3.07 (0.88) adc_1_mean (%) 1 ( 2.0) 100.3332748 1 ( 2.0) 100.7850723 1 ( 2.0) 101.1288986 1 ( 2.0) 106.94384 1 ( 2.0) 107.4796753 1 ( 2.0) 108.1219025 1 ( 2.0) 108.4807739 1 ( 2.0) 109.8269577 1 ( 2.0) 110.6593323 1 ( 2.0) 112.250946 1 ( 2.0) 112.6311264 1 ( 2.0) 113.6343842 1 ( 2.0) 114.5146027 1 ( 2.0) 116.6255951 1 ( 2.0) 116.9603348 1 ( 2.0) 119.7995605 1 ( 2.0) 121.1716843 1 ( 2.0) 123.4509964 1 ( 2.0) 123.5778046 1 ( 2.0) 125.6047516 1 ( 2.0) 125.8717575 1 ( 2.0) 127.4504852 1 ( 2.0) 128.1634064 1 ( 2.0) 128.2574005 1 ( 2.0) 128.8485718 1 ( 2.0) 129.5490875 1 ( 2.0) 129.7754059 1 ( 2.0) 130.4454651 1 ( 2.0) 131.0157623 1 ( 2.0) 131.2865448 1 ( 2.0) 133.0798645 1 ( 2.0) 134.7369385 1 ( 2.0) 137.2429199 1 ( 2.0) 137.4812317 1 ( 2.0) 138.7712097 1 ( 2.0) 139.8694763 1 ( 2.0) 140.6768646 1 ( 2.0) 142.7576294 1 ( 2.0) 144.4676361 1 ( 2.0) 144.8905334 1 ( 2.0) 146.3157654 1 ( 2.0) 149.0292358 1 ( 2.0) 152.9427185 1 ( 2.0) 154.0635529 1 ( 2.0) 154.9950104 1 ( 2.0) 82.6672821 1 ( 2.0) 89.37554932 1 ( 2.0) 99.98454285 1 ( 2.0) n/a 1 ( 2.0) adc_1_5p (mean (SD)) 85.03 (11.48) . ?CreateTableOne . # createtableone에서 strata에 그룹을 나눈 칼럼명 options(width = 300) tobj2&lt;-CreateTableOne(vars = var1, data=dat1, strata=&quot;CA19.9.group&quot;) print(tobj2) . Warning message in ModuleReturnVarsExist(vars, data): &#34;The data frame does not have: RFS Dropped&#34; . Stratified by CA19.9.group 0 1 p test n 38 10 Recur = 1 (%) 15 (39.5) 7 (70.0) 0.172 local_6m = 1 (%) 20 (52.6) 3 (30.0) 0.358 age (mean (SD)) 56.34 (12.56) 58.80 (13.62) 0.591 sex = 1 (%) 24 (63.2) 9 (90.0) 0.213 CA19.9 (%) 0.352 2 1 ( 2.6) 0 ( 0.0) 3 2 ( 5.3) 0 ( 0.0) 4 1 ( 2.6) 0 ( 0.0) 5 1 ( 2.6) 0 ( 0.0) 6 1 ( 2.6) 0 ( 0.0) 7 1 ( 2.6) 0 ( 0.0) 8 1 ( 2.6) 0 ( 0.0) 9 1 ( 2.6) 0 ( 0.0) 10 1 ( 2.6) 0 ( 0.0) 11 1 ( 2.6) 0 ( 0.0) 12 1 ( 2.6) 0 ( 0.0) 13 1 ( 2.6) 0 ( 0.0) 14 1 ( 2.6) 0 ( 0.0) 15 1 ( 2.6) 0 ( 0.0) 16 1 ( 2.6) 0 ( 0.0) 17 1 ( 2.6) 0 ( 0.0) 18 1 ( 2.6) 0 ( 0.0) 19 1 ( 2.6) 0 ( 0.0) 20 1 ( 2.6) 0 ( 0.0) 21 1 ( 2.6) 0 ( 0.0) 22 1 ( 2.6) 0 ( 0.0) 23 1 ( 2.6) 0 ( 0.0) 24 1 ( 2.6) 0 ( 0.0) 25 1 ( 2.6) 0 ( 0.0) 26 1 ( 2.6) 0 ( 0.0) 27 1 ( 2.6) 0 ( 0.0) 28 1 ( 2.6) 0 ( 0.0) 29 1 ( 2.6) 0 ( 0.0) 30 1 ( 2.6) 0 ( 0.0) 31 1 ( 2.6) 0 ( 0.0) 32 1 ( 2.6) 0 ( 0.0) 33 1 ( 2.6) 0 ( 0.0) 34 1 ( 2.6) 0 ( 0.0) 35 2 ( 5.3) 0 ( 0.0) 36 1 ( 2.6) 0 ( 0.0) 37 1 ( 2.6) 0 ( 0.0) 38 0 ( 0.0) 1 (10.0) 39 0 ( 0.0) 1 (10.0) 40 0 ( 0.0) 1 (10.0) 41 0 ( 0.0) 1 (10.0) 42 0 ( 0.0) 1 (10.0) 43 0 ( 0.0) 1 (10.0) 44 0 ( 0.0) 1 (10.0) 45 0 ( 0.0) 1 (10.0) 46 0 ( 0.0) 1 (10.0) 47 0 ( 0.0) 1 (10.0) log.CA19.9 (mean (SD)) 2.74 (0.79) 3.75 (0.07) &lt;0.001 CA19.9.group (mean (SD)) 0.00 (0.00) 1.00 (0.00) &lt;0.001 CEA (mean (SD)) 6.13 (18.55) 4.15 (4.59) 0.740 log.CEA (mean (SD)) 0.99 (0.90) 1.03 (0.93) 0.926 TNM (%) 0.308 1 1 ( 2.6) 1 (10.0) 2 3 ( 7.9) 1 (10.0) 3 11 (28.9) 1 (10.0) 4 17 (44.7) 7 (70.0) 5 6 (15.8) 0 ( 0.0) TNM.b (%) 0.231 1or2 4 (10.5) 2 (20.0) 3 11 (28.9) 1 (10.0) 4 17 (44.7) 7 (70.0) 5 6 (15.8) 0 ( 0.0) CCI (%) 0.304 0 1 ( 2.6) 2 (20.0) 1 13 (34.2) 2 (20.0) 2 10 (26.3) 4 (40.0) 3 10 (26.3) 2 (20.0) 4 3 ( 7.9) 0 ( 0.0) 6 1 ( 2.6) 0 ( 0.0) CCI.b (%) 0.635 &gt;=4 4 (10.5) 0 ( 0.0) 0or1 14 (36.8) 4 (40.0) 2 10 (26.3) 4 (40.0) 3 10 (26.3) 2 (20.0) adc_decrease (mean (SD)) 20.83 (11.55) 21.60 (11.41) 0.853 adc_5_decrease (mean (SD)) 11.24 (11.82) 10.80 (14.62) 0.922 volume_change (mean (SD)) 22.58 (13.56) 32.00 (13.00) 0.056 apt_1_mean (mean (SD)) 3.19 (4.20) 3.08 (1.23) 0.935 apt_1_95p (mean (SD)) 2.96 (0.75) 3.54 (1.25) 0.064 adc_1_mean (%) NaN 1 ( 2.6) 0 ( 0.0) 100.3332748 1 ( 2.6) 0 ( 0.0) 100.7850723 1 ( 2.6) 0 ( 0.0) 101.1288986 1 ( 2.6) 0 ( 0.0) 106.94384 0 ( 0.0) 1 (10.0) 107.4796753 1 ( 2.6) 0 ( 0.0) 108.1219025 0 ( 0.0) 1 (10.0) 108.4807739 1 ( 2.6) 0 ( 0.0) 109.8269577 0 ( 0.0) 0 ( 0.0) 110.6593323 1 ( 2.6) 0 ( 0.0) 112.250946 0 ( 0.0) 1 (10.0) 112.6311264 1 ( 2.6) 0 ( 0.0) 113.6343842 1 ( 2.6) 0 ( 0.0) 114.5146027 0 ( 0.0) 1 (10.0) 116.6255951 1 ( 2.6) 0 ( 0.0) 116.9603348 1 ( 2.6) 0 ( 0.0) 119.7995605 1 ( 2.6) 0 ( 0.0) 121.1716843 1 ( 2.6) 0 ( 0.0) 123.4509964 1 ( 2.6) 0 ( 0.0) 123.5778046 1 ( 2.6) 0 ( 0.0) 125.6047516 1 ( 2.6) 0 ( 0.0) 125.8717575 1 ( 2.6) 0 ( 0.0) 127.4504852 1 ( 2.6) 0 ( 0.0) 128.1634064 1 ( 2.6) 0 ( 0.0) 128.2574005 0 ( 0.0) 1 (10.0) 128.8485718 0 ( 0.0) 0 ( 0.0) 129.5490875 1 ( 2.6) 0 ( 0.0) 129.7754059 1 ( 2.6) 0 ( 0.0) 130.4454651 1 ( 2.6) 0 ( 0.0) 131.0157623 1 ( 2.6) 0 ( 0.0) 131.2865448 1 ( 2.6) 0 ( 0.0) 133.0798645 1 ( 2.6) 0 ( 0.0) 134.7369385 1 ( 2.6) 0 ( 0.0) 137.2429199 1 ( 2.6) 0 ( 0.0) 137.4812317 1 ( 2.6) 0 ( 0.0) 138.7712097 1 ( 2.6) 0 ( 0.0) 139.8694763 0 ( 0.0) 1 (10.0) 140.6768646 1 ( 2.6) 0 ( 0.0) 142.7576294 1 ( 2.6) 0 ( 0.0) 144.4676361 0 ( 0.0) 1 (10.0) 144.8905334 1 ( 2.6) 0 ( 0.0) 146.3157654 0 ( 0.0) 1 (10.0) 149.0292358 0 ( 0.0) 1 (10.0) 152.9427185 1 ( 2.6) 0 ( 0.0) 154.0635529 1 ( 2.6) 0 ( 0.0) 154.9950104 0 ( 0.0) 1 (10.0) 82.6672821 1 ( 2.6) 0 ( 0.0) 89.37554932 1 ( 2.6) 0 ( 0.0) 99.98454285 1 ( 2.6) 0 ( 0.0) n/a 1 ( 2.6) 0 ( 0.0) adc_1_5p (mean (SD)) 84.85 (11.42) 84.70 (12.29) 0.972 . &lt;/div&gt; .",
            "url": "blog.chojaeseong.com/r/r%EA%B3%A0%EA%B8%89/%EC%9D%98%EC%97%B0%EB%B0%A9/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/datacleaning/2022/03/05/%EC%9D%98%EC%97%B0%EB%B0%A900)-dataclinining(tableone,-22-03-05).html",
            "relUrl": "/r/r%EA%B3%A0%EA%B8%89/%EC%9D%98%EC%97%B0%EB%B0%A9/%ED%86%B5%EA%B3%84/%EB%8C%80%ED%95%99%EC%9B%90/datacleaning/2022/03/05/%EC%9D%98%EC%97%B0%EB%B0%A900)-dataclinining(tableone,-22-03-05).html",
            "date": " • Mar 5, 2022"
        }
        
    
  
    
        ,"post123": {
            "title": "강의) 네오 2단계 List + 제네릭",
            "content": "리스트 . 테스트부터 만든다. . test&gt;java에서 class를 앞에 패키지.를 붙혀 만들면 패키지 + class를 동시에 만들 수 있다. list.ListTest | . | . public class ListTest { @Test void name() { new ArrayList&lt;&gt;(); } } . | ArrayList vs LinkedList . ArrayList . arrayList는 내부에 단순 배열을 가지고 있다. 배열을 사용하기 좋게 감싼 일급컬렉션 . transient Object[] elementData; // non-private to simplify nested class access . 배열을 그냥 쓰면, 배열크기가 고정되어있지만, 일급으로 만들어서 크기를 유동적으로 증가 감소, 복사해서 대체해주기 등을 한다. | . private Object[] grow(int minCapacity) { return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); } . | LinkedList . 배열이 아니라 시작과 끝노드를 가지고 있으며 연결되어있다. . transient Node&lt;E&gt; first; /** * Pointer to last node. */ transient Node&lt;E&gt; last; . | 연결되어있으므로 배열 공간에 미리할당할 필요없이 하나씩 node를 추가하면 된다. . | 저장 -&gt; 접근 방식 . . 배열의 arrayList: 인덱스로 한번에 접근가능하다. 인덱스로 한번에 중간원소 접근가능 -&gt; 빠르다. 메모리 공간을 미리 할당해야하므로, 메모리 딸리는 상황에서는 데이터 추가시 느릴 수 있다. | . | 중간원소 삭제시 인덱스를 한칸식 다 땡겨줘야하므로 시간이 오래 걸린다. | 중복처리 방식 리스트 안에 리스트를 넣는방식 이용 | 크기가 커지면 리스트 안에 트리를 넣는 방식 이용 | 사이즈에 맞게 다르게 사용되어서.. api를 사용하는게 좋다. | . | . | 노드의 LinkedList: 통해서 가야하는 줄줄이 노드. 타고가야하는 줄줄이 노드는 중간원소 접근 -&gt; 느리다. | 중간원소 삭제시 편하게 삭제 | . | 하드디스크의 물리적으로 순차적인 접근 . 옛날 하드디스크 = 물리적으로 순차적으로 메모리 배열 -&gt; arraylist와 마찬가지 방식 -&gt; 유리했었음 요즘은 linkedList가 메모리 파편화된 node들의 집합이어도 별 상관없어졌다. | . | . 제네릭 . list처럼 다양한type을 관리하는 경우, 특정type으로 고정시킬 수 있다. 제네릭이 멀까? 컴파일 타임(핵심)에 처리가 되서, 그 때 버그를 잡아낼 수 있다. | 클래스를 변수로 만들기? | . | . | . 제네릭은 컴파일 타임에 처리된다. . 1을 arrayList에 넣고 출력하는 코드를 작성하고 실행시켜 컴파일 . @Test void name() { final ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); integers.add(1); System.out.println(integers); } . | out(build)부터 시작되는 컴파일코드로 가서 shift2번 &gt; show bytecode를 쳐서 내부적으로 실행된 코드를 확인해보자. . . // access flags 0x0 name()V @Lorg/junit/jupiter/api/Test;() L0 LINENUMBER 9 L0 NEW java/util/ArrayList DUP // ArrayList 생성할 때, 제네릭정보는 없다. INVOKESPECIAL java/util/ArrayList.&lt;init&gt; ()V ASTORE 1 L1 LINENUMBER 10 L1 ALOAD 1 ICONST_1 INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer; // integer가 들어갈 때, Object로 들어간다. -&gt; 컴파일 될 때 알아서 Type으로 떨어진다. 컴파일 타임까지만 Type실수하지않게 도와주는 것. 런타임 때는 안도와준다. INVOKEVIRTUAL java/util/ArrayList.add (Ljava/lang/Object;)Z POP L2 LINENUMBER 12 L2 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 1 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)V L3 LINENUMBER 13 L3 RETURN L4 LOCALVARIABLE this Lgeneric/GenericTest; L0 L4 0 LOCALVARIABLE integers Ljava/util/ArrayList; L1 L4 1 // signature Ljava/util/ArrayList&lt;Ljava/lang/Integer;&gt;; // declaration: integers extends java.util.ArrayList&lt;java.lang.Integer&gt; MAXSTACK = 2 MAXLOCALS = 2 . | 결과적으로 외부에서 타입을 지정할 수 있게하는 기술이다. . 생성시에는 타입없이 내부에서 생성 | 외부인 변수에 할당시 타입지정 | . ArrayList&lt;Integer&gt; integers = new ArrayList(); . 외부에서 타입을 맘대로(나 인티져 넣을거야, 나 스트링 넣을 거야~)지정해서 편하게 사용한다. | . final ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); final ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;(); . | 장점 . (사용시 특정타입으로 제한하여) 타입안정성을 얻을 수 있다. | 캐스팅해서 사용하던 것을 자동으로 처리되도록 됨. | my) [여러 타입가능한 자료구조]사용시 get하면 object로 내려와 (1) 타입확인 (2) 다운캐스팅 해서 사용했어야 했는데 사라지게 된다. . jdk 5부터 추가되었다. | 다른type, 다른형을 막아주기 때문에 특별한 이유가 없으면 여러타입가능 자료구조는 무조건 generic을 사용해라 | . @Test void name() { final List integersNoGeneric = new ArrayList(); integersNoGeneric.add(1); // 여러타입 가능한 것에 대해 제네릭으로 타입을 안정해준다면, // 1. &lt;받아올 때&gt; Object형으로 내려온다. -&gt; &lt;받아 사용하는 쪽에서&gt; 다운캐스팅 해야 쓸 수 있다. final Object o = integersNoGeneric.get(0); // -&gt; [넣은 것과 동일한 형으로 직접 다운 캐스팅]해야줘야 다시 해당 type으로 사용할 수 있다. final Integer integer = (Integer) integersNoGeneric.get(0); // 2. 다른 Type을 넣어버릴 수 도 있어서 type불안정하다. integersNoGeneric.add(&quot;1&quot;); // -&gt; &lt;사용하는 쪽, 타입까지 직접확인해줘야&gt;해서 -&gt; 사용할 때 [넣은 것과 동일한지 type확인도 미리] 다운캐스팅전에 해줬어야했다. final Object o1 = integersNoGeneric.get(0); if (o1 instanceof Integer) { final Integer o11 = (Integer) o1; } } . Type과 제네릭은 영역 좁히는게 반대다? . ArrayList는 구현체 List가 인터페이스(추상체) . type을 받아줄 변수는 인터페이스(추상체)로 받아야, 메서드들이 분기를 대신하는 구상체(전략객체)를 받을 수 있는 추상체(인터페이스) 파라미터로 정의되어있음을 인지해야한다. | . my) Type의 경우) 정의하는 변수와 파라미터는 전체 분기들을 내포되도록 추상체로 받고, 사용하는 할당과 메소드호출 인자에는 분기가 결정된 구상체를 넣어주자. . 파라미터를 분기결정된 구상체로 받는다면? . 다른 구상체들을 못받는다. | . void 파라미터를_분기결정된_구상체로_넣는경우(ArrayList&lt;Integer&gt; value) { System.out.println(value); } . // 1. default로 변수추출시 ArrayList 풀로 형이 정해지는데 final ArrayList&lt;Integer&gt; integersArrayList = new ArrayList&lt;&gt;(); // 2. vs 정의하는 변수와 파라미터는 전체분기들을 내포하는 추상체로 받아라 -&gt; 할당과 메소드호출인자에는 분기결정한 구상체를 넣어주자. final List&lt;Integer&gt; integersList = new ArrayList&lt;&gt;(); //3. 정의하는 메소드파라미터를 분기결정된 구상체 -&gt; 해당 구상체밖에 못들어온다. 파라미터를_분기결정된_구상체로_넣는경우(integersArrayList); // 에러안남. 파라미터를_분기결정된_구상체로_넣는경우(integersList); // 에러남 (구상체 정의 -&gt; 추상체를 넣음) } . | 파라미터를 분기내포하는 추상체(인터페이스)로 받는다면? . 파라미터를 추상체로 받는다? -&gt; 분기들을 내포하여 구상체들을 다 받을 수 있는 상황 | 인터페이스로 분리해서 내가 어떤이점을 얻고 있지? 잘활용하고 있나 고민할 것 전략패턴에서는, 파라미터를 전략인터페이스로 정의후 | 호출시점에 전략객체.전략메서드() 호출시켜서 실시간성 부여 | 사용하는 메인에서 메서드호출시 new 구상체를 던져 분기를 정해줌 | . | . void 파라미터를_분기내포하는_추상체로_넣는경우(List&lt;Integer&gt; value) { System.out.println(value); } . 파라미터를_분기내포하는_추상체로_넣는경우(integersArrayList); // 에러안남. 파라미터를_분기내포하는_추상체로_넣는경우(integersList); // 이것도 에러 안남. //메소드 호출시, 여러분기들의 구상체를 다 받을 수 있다. . | 선언시, 변수 생략된T &lt;&gt; 형 + 파라미터, 클래스 &lt;T&gt;형의 제네릭에서의 추상체 &lt;—&gt; 호출시구상체 &lt;특정형&gt; 을 지정해서 사용한다. . my) intellij의 생성자 파라미터를 T로 지정하여 Generic을 생성한 선T -&gt; 호구지 (선언시 T형 -&gt; 호출시 구상형을 지정해서 사용) . 호출부에서 T형을 집어넣을 수 없으니 -&gt; 일단 아무형이나 넣어서 생성자에 넣고 내부에서 T로 바꿔서 정의한다. | T형으로 파라미터를 받아도, T는 빨간줄이다. 빨간줄 [Create type T paramter] 를 통해 class 전체를 선택해서 클래스자체도 Class&lt;T&gt;형으로 지정해준다. 필드가 아닌, 파라미터 속 T에 대해서만 해당 T형 파라미터 자동생성이 활성화된다. | . | . 제네릭 추상체 &lt;T&gt;형으로 box클래스 정의하기 . 외부에서 생성자를 통해 빨간줄로 생성할 땐, 아무형이나 집어넣고 -&gt; 내부에서 T형으로 정의후 -&gt; Create T type parameter를 통해 class에도 &lt;T&gt;로 선언되도록 해야한다. (선T호구지) | . 제네릭 추상체 &lt;T&gt;형 클래스 만들기 . class Box&lt;T&gt; { private final T value; // 1. T형 변수을 감싸는 클래스 box를 만든다. T형이란 미정이므로 -&gt; 2. 클래스 정의시 &lt;T&gt; 제네릭을 달아줘야한다. //3. T형변수를 변수를 생성자를 통해 초기화하고 public Box(final T value) { this.value = value; } //4. T형 변수를 getter로 응답한다. public T getValue() { return value; } } . | my) 제네릭은 Type과 반대로, 변수 및 생성자에서는 제네릭 구상체 인 &lt;특정형&gt; 변수에 , 할당(사용)시 생략된T형&lt;&gt;을 넣어줘, 변수와 생성자에서 좁힌다. . 제네릭 추상체 생략된T형 &lt;&gt;변수, 제네릭 구상체 &lt;특정형&gt; 변수 각각 생성자 대입해보기 . 변수가 제네릭 구상체이라면, 할당도 해당하는 형밖에 못넣는다. | . @Test void name2() { final Box&lt;String&gt; stringBox = new Box&lt;&gt;(&quot;&quot;); //final Box&lt;String&gt; stringBox = new Box&lt;&gt;(1); // 제네릭은 변수와 생성자에서 좁힌다. 할당시 제네릭추상체-생략된T&lt;&gt;형으로 넓게준다. } . | 할당(사용)시 생략된T형&lt;&gt;을 넣지만, 좁히는 변수와생성자 자리에 들어간&lt;특정형&gt; 변수가 추상체인 인터페이스라면, 넓히는 할당 자리에 &lt;특정형 인터페이스의 구상체형들&gt; 들도 할당가능하다 . 넓은 할당자리에 특정형을 집어넣으면 해당 클래스만 사용가능해진다. . 무엇이든 다 들어갈 수 있는 제네릭 추상체 Box&lt;T&gt;에 대해서 제네릭 구상체 Box&lt;특정형&gt;을 지정해줬지만, 그 특정형이 구상체들을 가진다면 우변에서 구상체들의 할당이 가능하다 . // 8.제네릭에서는 생략된T형인 Box&lt;&gt;에 비해 Box&lt;특정형&gt;은 제네릭구상체다. -&gt; 할당이 &lt;특정형&gt;의 자체 및 그 구상체들만 가능해진다. // -&gt; Animal이 제네릭 특정형으로 들어가 그 제네릭 구상체가 되었더라도, 그것의 구상체들인 Dog, Cat은 할당될 수 있다. new Box&lt;Animal&gt;(); final Box&lt;Animal&gt; animalBox = new Box&lt;Animal&gt;(); . | 좌항 좁히는 변수가 &lt;특정형&gt;의 제네릭구상체라면 -&gt; 마찬가지 좁히는 생성자에 들어갈 변수도 특정형으로 처리되어야함. 할당(사용, 특정분기)은 생략된T형(제네릭추상체)의 기본생성자 호출 불가 . 변수만 좁히고, 할당은 안좁혔을 때 -&gt; 기본 생성자에 인자가 들어간다면 넓은 할당형에 쓰던 것이 생성자로 들어갈 예정이니 에러가난다 -&gt; 인자를 안받는 생성자를 만들어줘서 생략된T형의 인자가 못들어가게 막아주자. . List(추상) = ArrayList(구상)는 내가 특정분기를 우항에서 할당하여 사용하는 것이다. . 하지만 현 상황에서는 제네릭 구상체인 Box&lt;Animal&gt; (구상) = new Box &lt;&gt; () (추상:생략된T형)을 넣는 것은 정반대로 주는 것 | **좌변 변수정의에서 구상체 특정형으로 제한되어있다면, 뭔짓을 한들 생략된 T형 = 제네릭추상체 사용시, 생성자에 건네주는 것으로 class내부 T형 변수를 초기화해줄 수 없기 때문이다. ** | . // 9. 좁히는 변수만 좁히고, 할당은 안좁혔을 때 -&gt; 기본 생성자에 인자가 들어간다면 넓은 할당형에 쓰던 것이 생성자로 들어갈 예정이니 에러가난다 final Box&lt;Animal&gt; animalBox = new Box&lt;&gt;(); // 생성자쪽에서 에러 // -&gt; 인자를 안받는 생성자를 만들어줘서 생략된T형의 인자가 못들어가게 막아주자. // -&gt; default생성자(파라미터T가 안되니, 파라미터를 아예 안받고, 내부 T형은 null로 초기화시켜주는)를 추가해주자. public Box() { this(null); } . final Box&lt;Animal&gt; animalBox = new Box&lt;&gt;(); . 마치 제네릭 구상체 변수에 제네릭추상체 할당이 가능해 보이지만, 생성자가 파라미터를 외부에서 아예 안받고 내부적으로 자체 처리해서 제네릭추상체를 감당하고 있기 때문에 그렇게 보이기만 할 뿐이다. 특수처리되어서 에러는 사라졌으나 사용은 불가하다.?! | . | . | . 할당시 제네릭구상체&lt;특정형&gt;을 지정해주면, 내부의 모든 것이 T-&gt;특정형으로 바뀐다. 할당은 변수보다 넓어야하니 변수는 더 좁은 특정형or특정형의 구상체들로 받아줘야할 것이다. . // 11. 이미 좁힌 제네릭변수가 있을 때, 할당은 생략된T형 &lt;&gt;으로 넓게 줄 수 있다. (넓은 형으로 들어갈 생성자만 잘 처리되면) final Box&lt;Animal&gt; animalBox2 = new Box&lt;&gt;(); // 12. 할당에서 특정형을 제네릭구상체로 지정해주면, 내부의 모든 로직이 해당 classType으로 바껴서 // 12-1. 동일형으로 좁힌 변수에는 잘들어간다. final Box&lt;Animal&gt; animalBox3 = new Box&lt;Animal&gt;(); // 12-2. 만약 넓은 할당쪽이 더 좁아졌다면? (좁힌 변수보다 더 좁은) Type과 다르게 안들어가진다. -&gt; 변수와 생성자가 더 좁아야한다. final Box&lt;Animal&gt; animalBox4 = new Box&lt;Dog&gt;(); // 에러 . 좁았던, 제네릭 변수정의 - 생성자 인자의 관계에선, Type처럼 변수-추상체라면, 생성자인자-구상체의 관계를 가진다. . //13. 할당시 생략된T형&lt;&gt; -&gt; 변수-생성자 인자 관계에서는, Type처럼 변수 추상체 - 생성자=메서드호출 구상체가 가능하다. //13-1. 할당시 생략된 T&lt;&gt;으로 내부가 T로 구성된 데이터에, 좁은 생성자 인자를 넣어줄 때, 추상체에 구상체가 들어가므로 괜춘하다. final Box&lt;Animal&gt; animalBox4 = new Box&lt;&gt;(new Dog()); //13-2. 할당이 넓은 상태라면, 변수-추상체 생성자-구상체로서 동일한 것도 생성자로 넣을 수 있다. final Box&lt;Dog&gt; animalBox5 = new Box&lt;&gt;(new Dog()); . 실사용 와일드카드 . 실사용은 좁은 변수제네릭에 와일드카드를 지정해주고 넓은 할당은 생략된T형이 기본인 상태에서, 넣어줄 생성자에 변수의 좁은제네릭에 들어있는 구상체or상속or와일드카드 범위의 객체를 넣어 사용해줘야한다. . //14. 넓은 제네릭할당에 대해 new Box&lt;&gt;(); //14-1. 좁은 변수의 제네릭에 와일드카드(upper bound) 적용주자. final Box&lt;? extends Animal&gt; extendsAnimalBox = new Box&lt;&gt;(); //14-1-1. 실사용은 변수에 대해 생성자에 넣어줄 놈은 더 구상체로 넣어주면 된다. final Box&lt;? extends Animal&gt; extendsAnimalBox2 = new Box&lt;&gt;(new Animal(){}); final Box&lt;? extends Animal&gt; extendsAnimalBox3 = new Box&lt;&gt;(new Dog()); . 상속자 자리에 와일드카드변수(제네릭추상체) 구현체를 상속한 것들도 넣어줄 수 있다. . //15. [Animal의 구현체인 Dog]를 상속한 것들도 제네릭 상속자 자리에 넣어줄 수 있다. // -&gt; 술을 먹어서 개가 된 돌범(상속) 정의 class Dolbum extends Dog { } . //15-2. 제네릭 변수-상속자의 관계는 구상체 자식들 하위단계를 다 넣어줄 수 있다. final Box&lt;? extends Animal&gt; extendsAnimalBox4 = new Box&lt;&gt;(new Dolbum()); . 넓은 할당쪽 제네릭은 사실, 생성자에 들어갈 객체의 범위가 default다. . 할당쪽 제네릭은 와일드카드 사용불가 | 특정형 사용시, 생성자도 그걸로 | 생성자를 넣어줄 시, 그거랑 동일한 것이 default | . 와일드카드에 대해, 상속자들어갈놈 -&gt; 할당제네릭의 default가 안정해줄 경우, 어떤 Type으로 잡힐까? . 제일 defaultType은 제일 상단이 나온다. Type입장에서는 열려있는 최고 부모를 변수type으로 받아줘야한다. | . | . //16. 와일드카드에 대해, 상속자들어갈놈 -&gt; 할당제네릭의 default가 안정해줄 경우, 어떤 Type으로 잡힐까? final Box&lt;? extends Animal&gt; extendsAnimalBox5 = new Box&lt;&gt;(); //16-1. upperbound를 가진 extends 와일드카드의 경우, 제일 상단인 Animal이 나오고 final Animal value = extendsAnimalBox5.getValue(); final Box&lt;? super Animal&gt; superAnimalBox5 = new Box&lt;&gt;(); //16-2. lowerbound를 가진 super의 경우, 제일 하단인 Animal이 나올 것 같지만, // -&gt; 역시 제일 상단인 Object가 나온다. // --&gt; 와일드카드의 default는 제일 위아래쪽 상관없이 상단 bound ~ Object까지 나오게 된다. final Object value2 = superAnimalBox5.getValue(); . 제네릭의 클변 메파 정의/ 좁 변수(와) + 메파 제한자(와X) -&gt; 생성자/ 넓 할당 . Type은 정의하는 변수, 메서드 파라미터에는 추상체를 / 사용하는 할당, 메소드호출에는 구상체를 넣어서 분기처리를 밖으로 제거해줄 수 있다. | . 제네릭은 정의(class 속 변수, method 파라미터)는 T(E)로 / 변수(와일드카드)와 method 파라미터는 &lt;T&gt; (&lt;E&gt;) 좁게 + 생성자(좁힌 것의 구현체&amp;자식들) + / 할당은 넓게(default로 두면 알아서 생성자에 사용되는 구현체에 맞게) . 메소드 파라미터는 제네릭E로 정의해주지만 (클래스 변수 타입 T형처럼) /히는 작업이 접근제한자와 응답사이에 좁은 꺽쇠&lt;E&gt;로 정의 (좁은 변수Type처럼) . //1. T는 클래스의 변수 정의하느라 썼으니 // -&gt; 파라미터는 E로 받지만, 제한자 쪽에다가 꺽쇠붙인 &lt;E&gt;로 좁혀준다. // -&gt; &lt;E&gt;는 별다르게 좁혀주지 않는 default 어느타입이든 가능임. public &lt;E&gt; void some(E e) { } . //2. 제네릭은 변수에 좁게 정의하고, 그 와일드카드에 해당 범위의 객체를 생성자에 넣어주니, 변수까지 정의해서 객체를 생성한다. new Box&lt;&gt;(); final Box&lt;? super Animal&gt; superAnimalBox6 = new Box&lt;&gt;(); final Object value1 = superAnimalBox.getValue(); // 와일드카드에 구상체 객체를 않넣어주면, T형의 인스턴스변수를 Object로 잡아 반환한다. final Box&lt;?&gt; value6 = superAnimalBox; //객체는 ? 와일드카드에 그냥 넣어줄 수 있다? value6.some(&quot;&quot;); // E는 기본적으로 Object부터 시작하여 -&gt; 메서드호출시 어떤Type이든지 호출 가능해진다. value6.some(1); // E는 기본적으로 Object부터 다 받을 수 있다. . 좁은 변수처럼, 메소드 파라미터는 제한자 쪽에서 좁힌 Type &lt;E&gt;에 와일드카드 or 직접 꺽쇠에 제한을 걸수 있다. . 잘보면 응답Type void보다 앞쪽에서, 파라미터에 대한 와일드카드 제한을 거는 것이다. | . //3. 메서드의 파라미터의 좁힘 제한은 응답Type앞쪽에서 꺽쇠&lt;E&gt;제네릭으로 걸 수 있다. public &lt;E extends String&gt; void some(E e) { } //4. value6.some(&quot;&quot;); // string 이하로 제한건 E에는.. string 및 string상속한 것만 들어간다. value6.some(1); // 에러 . 참고) E는 와일드카드 범위내에서 사용된 Type이 추론끝나면 컴파일 타임에서 해당Type으로 대체되어 사라진다. . 참고) 정의를 해주는 class옆 꺽쇠 + method파라미터용 앞쪽 꺽쇠에서는 와일드카드 사용이 안된다. 변수 제네릭에서만 와일드카드 가능 . // 와일드카드 사용 좁힘시 에러 public &lt;? extends String&gt; void some(E e) { } // 와일드카드 사용시 에러 class Box2&lt;? extends Animal&gt; { } . 추가 메서드 파라미터 E를 좁힐 땐, 와일드카드가 아닌 꺾쇠&lt;E extends &gt;로 좁히며, super불가 + 와이드카드 불가다.. . 메서드에서 class와 동일한 타입추론 변수를 사용해도 된다. but… . public &lt;T&gt; void some(T t) { } . 메서드 파라미터의 변수는 지역변수라 … class쪽과 다르다. . //2. class내부에서 동일한 타입추론 변수T를 사용한 메서드는.. 파라미터로 T가 추론된 Dog형만 사용가능할까? // -&gt; class정의시에서는 T로 똑같은게 사용된 것 같지만, 메서드 파라미터의 변수 -&gt; 지역변수 -&gt; class 제네릭 타입변수 T랑은 별개다. // -&gt; 타입추론한 Dog와 별개로, 제한안걸린 T로서 모든 타입이 다들어간다. dogBox.some(new Object()); dogBox.some(1); dogBox.some(&quot;1&quot;); . E로 바꿔도 똑같이 지역변수로 적용되므로… 개별적 처리가 된다. | 되도록이면 이름 중복 안되게 하는게 좋다. | . P-E C-S(제네릭와일드카드 사용처) . 생성관련된 메소드의 파라미터에 대해서는 extends 상속한 것들만 들어올 수 있게 ArrayList의 생성자 파라미터 정의시 | ArrayList의 add메서드들의 파라미터 정의시 | . | 소비하는 곳에서는 super를 써서 제네릭을 정의해라 | . ArrayList를 타고 들어가서 ? extends가 어디서 사용되는지 검색 해보자. . 생성자 파라미터에서 E의 상속한 자식들(extends)만 들어오도록 제한을 걸어준다. . . | add의 파라미터할때도 ? extends를 사용한다. . . | . ? super는 소비되는 곳에서 사용된다. . super는 어떤 값이든 들어와도 되며, 소비되는 곳에 사용된다. . 소비만 되므로, 실제 어떤 타입인지 중요하지 않다. | . . | action은 람다 학습시 필요하다. . 람다로 넘겨줄 때, Consumer, Predicate 사용시 많이 이용된다. | . public void forEachRemaining(Consumer&lt;? super E&gt; action) { . | .",
            "url": "blog.chojaeseong.com/java/list/%EC%A0%9C%EB%84%A4%EB%A6%AD/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/05/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-2%EB%8B%A8%EA%B3%84-list%EC%99%80-%EC%A0%9C%EB%84%A4%EB%A6%AD.html",
            "relUrl": "/java/list/%EC%A0%9C%EB%84%A4%EB%A6%AD/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/05/%EA%B0%95%EC%9D%98)-%EB%84%A4%EC%98%A4-2%EB%8B%A8%EA%B3%84-list%EC%99%80-%EC%A0%9C%EB%84%A4%EB%A6%AD.html",
            "date": " • Mar 5, 2022"
        }
        
    
  
    
        ,"post124": {
            "title": "제이) 중간피드백 Service와 Controller",
            "content": "Service . 일반 코드로 작성하는 안티 패턴 싱글톤이 아닌 스프링에서는 전용 싱글톤으로 유지되어야한다. | 상태(인스턴스 변수)를 가지면 안된다. 스프링의 service는 유저별 객체생성하면 감당이 안되므로 싱글톤으로 관리 되는데, 수많은 유저가 -&gt; 1개 싱글톤의 상태를 오염시킬 것이 뻔하기 때문이다. | controller -&gt; 재료들을 service 메소드 파라미터로 받아서 지역 변수로 처리되어야한다. | . | 원래 service를 사용한다면? Controller -&gt; inputDto -&gt; 도메인을 return하는 toDomain -&gt; service는 domain을 받는다. 상태로 유지는 X -&gt; 레포지토리 dto를 service에 넘기는 것을 지양해야한다 dto -&gt; toDomain -&gt; service controller는 클라이언트 레이어쪽 &lt;—&gt; service는 도메인이 포함된 레이어 쪽 | . | 레포지토리는 지엽적인 구상체들이 다 올 수 있는 Interface로 쌓여있다. | 도메인 생성에 필요한 데이터를 가져다 주는 것이 레포지토리 인터페이스 | 도메인은 레포지토리에게 질의만(findByName, findById) | . | . | input -&gt; 도메인으로 받은 controller에서 service.흐름로직( 도메인1, 도메인2)로 service로 흐름을 가져가되, input/output 흐름이 잘 잡히도록 짜면 된다. . | 검증이 controller에 있어도 되긴 되지만, 최대한 controller에서의 로직은 걷어내서 Factory or 도메인 로직에 넣어준다. 도메인을 풍부하게 해주자 . | 서비스에서 전략객체 바로 생성사용 가능? spring -&gt; bean에서 언제든지 사용가능하게 관리해줄 것이므로 **주입없이 바로 사용해도 ** | . | Controller와 의존성 . 의존성 개념에 따르면 중요하지 않은 = 잘 변하는= view와 맞닿은 controller가 중요한 도메인을 생성-&gt;사용해도 된다. . 중요한 것 의존=생성/(인자로)사용/리턴 (X)&gt; 중요하지 않은 것(쉽게 변하는것) (X) - domain내부에서 dto를 return하는 toDto() 하면 안된다. - domain내부에서 view(String)과 관련된 메소드를 작성하면 안된다. 중요하지 않은 것 의존=생성/(인자로)사용/리턴(O)&gt; 중요한 것 - controller에서 도메인을 (인자로)생성후 사용해도 된다. - dto에서 도메인을 from인자로 사용해도 된다. - dto에서 도메인을 return하는 toDomain()해도 된다. . | controller에서 도메인을 생성/인자로사용해도 되며 -&gt; service에는 도메인or값으로 넘겨준다. . | Service to Controller . Controller는 중요하지 않은 것으로서 중요한 도메인을 받아 써도 된다. 프로젝트가 커지면 Dto로 반환해준다. jpa를 쓰게 되면, 영속성 관리 때문에, 도메인을 view단으로 보내면 안된다. | . | view에서는 도메인에 있는 정보를 짤라 일부만 써야하는데, 필드를 날릴 순 없으니 민감/불필요한 필드가 짤려진 dto로 보낸다. | 도메인의 정보가 다쓰인다면 도메인객체를 그대로 넘겨도 된다. view에 map을 넘겨줘도 된다. 알아서 변환되서 내려간다. | map을 각 key필드 + value필드로 쪼갠 뒤 -&gt; dto클래스를 만들어서 -&gt; 객체dto를 넘겨도 된다. | . | . | Method시 들어갈 때 필요한 것들 -&gt; 뭐가 나오는지 명확하게 . 나중에는 returnType -&gt; 메서드명 -&gt; 파라미터의 시그니쳐만 보고 메서드를 갖다쓰기 때문에, 잘 정의되어 있어야한다. . 안 좋은 예 -&gt; 잘못 메서드 추출한 예 . lottoService.calculateResult(inputView.getBonusNumber()); . 보너스를 넣으면 -&gt; 당첨 결과가 나온다? -&gt; (X) 결과는 산 로또 + 당첨번호 + 보너스가 들어가서 -&gt; 당첨결과가 나와야한다. | . | . final Money totalMoney = getMoney(); final List&lt;Lotto&gt; issuedManualLotto = buyManualLotto(totalMoney); final Result result = issueLotto(totalMoney, issuedManualLotto); . | . xxxxFactory . **xxxxFactory 는 판매원이자 xxxxMachine** Lotto를 용지로만 본다면, 복잡한 생성과정은 판매원/Machine인 Factory에게 | . | 생성로직이 복잡하고 중요하기 때문에 클래스로 분리한 것 . 간단하면 따로 Factory로 분리할 필요가 없다. | . . | .",
            "url": "blog.chojaeseong.com/java/%ED%94%BC%EB%93%9C%EB%B0%B1/mvc/dto/service/controller/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/04/%ED%94%BC%EB%93%9C%EB%B0%B1_2-1(%EB%A1%9C%EB%98%90-%EC%A4%91%EA%B0%84)_%EC%A0%9C%EC%9D%B4_service%EC%99%80-controller.html",
            "relUrl": "/java/%ED%94%BC%EB%93%9C%EB%B0%B1/mvc/dto/service/controller/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/03/04/%ED%94%BC%EB%93%9C%EB%B0%B1_2-1(%EB%A1%9C%EB%98%90-%EC%A4%91%EA%B0%84)_%EC%A0%9C%EC%9D%B4_service%EC%99%80-controller.html",
            "date": " • Mar 4, 2022"
        }
        
    
  
    
        ,"post125": {
            "title": "TDD 4 자경(controller~view~검증)",
            "content": "ControllerTest for 컨트롤러와 service 형태 결정 . (test)Controller는 InputView를 파라미터로 받는다. . Controller -&gt; ControllerTest에서 컨트롤러 생성 | . controller = new Controller(new InputView()); . (prod)Controller 생성자 내부 new Service( inputXX ) 초기화 . 01 모든 입력을 한번에 다 -&gt; new Service( InputView.getInputDto() ) . 개별 try/catch는 안될 것이다. 처음부터 재입력받는 로직이 필요하다면, 여기를 함수화하고 재귀 걸어주면 될듯 | . | . public Controller(final InputView inputView) { //1-1. 서비스 생성시 inputView에서 한꺼번에 inputDto로 받는 경우 racingService = new RacingService(inputView.getInputDto()); . 01-1 inputDto.of( 개별getInput() , 개별getInput()) 형태로 return . 개별input에서는 출력문 | 기본 scanner input받아서, 공통 NullOrEmpty + 숫자면포맷 | split(,-1)+trim or parseInt의 정제된 형으로 변환 | 원시값 return | | . public class InputView { private static Scanner SCANNER = new Scanner(System.in); //1-3. getINputDto내부에서 사용될 개별 getXXX는 getInput()스캐너에 의존한다. private String getInput() { return SCANNER.nextLine(); } //1-2. 모든 input들을 InputDto.of에 넣어서 InputDto로 반환해주는 작업. // -&gt; dto는 일단 of(모든 속성들을 원시값으로) 받아서 -&gt; new dto( 원시값, 들로 생성)해야한다. public InputDto getInputDto() { return InputDto.of(getNames(), getRound()); } //1-4. 개별 getInput들은 출력 + 공통input검증(nullOrEmpty/format)이 생성된다. // 개별 getInput들은 4단계가 있다고 했다 (1)출력 (2) nullOrEmypy 검증 (3) format검증후convert or split+trim 변환 (4) return public List&lt;String&gt; getNames() { System.out.println(&quot;이름을 입력해주세요&quot;); final String input = getInput(); Validators.checkNullOrEmpty(input); return Arrays.stream(input.split(&quot;,&quot;, -1)) .map(String::trim) .collect(Collectors.toList()); } public int getRound() { System.out.println(&quot;몇 회 진행하겠습니까?&quot;); final String input = getInput(); Validators.checkNullOrEmpty(input); Validators.checkValidFormat(input); return Integer.parseInt(input); } } . 01-2 InputDto는 of 정펙매 -&gt; 생성자 -&gt; 원시값필드 -&gt; getter순으로 정의 . public class InputDto { private final List&lt;String&gt; names; private final int round; public InputDto(final List&lt;String&gt; names, final int round) { this.names = names; this.round = round; } //1-5. of에서 개별input다 받았으면, 그걸로 new생성자 -&gt; 필드 -&gt; getter까지 다 만든다. public static InputDto of(final List&lt;String&gt; names, final int round) { return new InputDto(names, round); } public List&lt;String&gt; getNames() { return names; } public int getRound() { return round; } } . 02 순차적이라면 new Service( 첫input ) -&gt; 메서드파라미터 ( 담input ) . setter금지령으로 인해 -&gt; 메인로직에 필요한 데이터는 생성자에서 객체 생성시 받아 -&gt; 인변에 넣어줘야한다. Controller는 service를 관리하고 있으며, 생성시service 초기화해줘야한다. 그 service 초기화시 받을 input -&gt; 좀있다가 받을 input이 따로 있는 경우 | . | . | . 02-1 첫 입력만 일단 생성자에서 개별input()으로 받는다. . public Controller(final InputView inputView) { // 첫 입력만 일단 생성자에서 개별input()으로 받는다. racingService = new RacingService(inputView.getNames()); . 02-2 개별input() in InputView 정의 . public List&lt;String&gt; getNames() { System.out.println(&quot;이름을 입력해주세요&quot;); final String input = getInput(); Validators.checkNullOrEmpty(input); return Arrays.stream(input.split(&quot;,&quot;, -1)) .map(String::trim) .collect(Collectors.toList()); } . 02-3 그에 따라 Service의 생성자 정의 . public RacingService(final List&lt;String&gt; carNames) { this.cars = new Cars(carNames); } . 원래 service 생성자는.. 일급 및 VO 개발시, 다 받아주는 것으로 정했었다. 여기에 추가해준다. . public RacingService(final List&lt;String&gt; carNames, final int round) { this.cars = new Cars(carNames); this.round = new Round(round); } . | . 03 inputView 콘솔입력(공통검증)부터의 테스트 -&gt; new Controller + InputStream(null불가) . new Controller( new InputView )를 던지면 . Controller생성자에서 inputView.콘솔input() 이 호출된다. | 여러개 개별input()이 포함되어있다면, 그만큼 SequenceInputStream을 던져야한다. | . // 1. 콘솔의 개별input()호출 -&gt; 공통 검증 public Controller(final InputView inputView) { racingService = new RacingService(inputView.getNames()); // 2.정제된 input으로 -&gt; 도메인생성 -&gt; 내부에서 도메인 검증 public RacingService(final List&lt;String&gt; carNames, final int round) { this.cars = new Cars(carNames); . | **테스트는 inpustream에 null은 넣지못하므로 &quot;&quot;빈칸만 테스트한다. ** . 전체 다 맞는 것 + 개별input 갯수만큼 sequence를 만들어줘야하므로 끝나면 가장 마지막에 테스트할 예정으로 바꾼다. | . | . @Test void controller_input_test() { final String argument = &quot;&quot;; final InputStream input = new ByteArrayInputStream((argument + &quot; n&quot;).getBytes()); System.setIn(input); assertThatThrownBy(() -&gt; new Controller(new InputView())) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;빈칸&quot;); } . 재귀추가시 fail 뜨게 되므로 valid한 input을 다시 넣어두자. . @Test void input_null_or_empty_test() { final String argument1 = &quot;&quot;; // 틀 final String argument2 = &quot;재성, 재경&quot;; // 맞아서 재귀 통과 final InputStream input1 = new ByteArrayInputStream((argument1 + &quot; n&quot;).getBytes()); final InputStream input2 = new ByteArrayInputStream((argument2 + &quot; n&quot;).getBytes()); final SequenceInputStream sequenceInputStream = new SequenceInputStream(input1, input2); System.setIn(sequenceInputStream); assertThatThrownBy(() -&gt; new Controller(new InputView())).isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;빈칸&quot;); } . 04 null를 직접하고 싶다면 바로 메서드 유틸Validators.checkNullorEmtpy 자체를 테스트하자. . @Test void input_null_or_empty_in_validator() { assertThatThrownBy(() -&gt; Validators.checkNullOrEmpty(null)) .isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;빈칸&quot;); } . ServiceTest again for 넘어온 정제된input으로 도메인 검증 . 도메인 검증은 controller 생성자에서 inpuView.개별input()에서 건너오는 정제된 input을 받아 관리 도메인으로 넣어주는 Service 생성자에서 한다 . //controller racingService = new RacingService(inputView.getNames()); //service public RacingService(final List&lt;String&gt; carNames) { this.cars = new Cars(carNames); } . | . new Service() -&gt; service.메서드()에서 받아주는 input 순서대로 도메인 검증하기 . new Service( inputView.개별input() )을 호출하면서 내부 ` this.cars = new Cars(carNames);` 도메인 생성자 호출되므로, | inputView.개별input() 자리에 원하는 인자로 테스트한다. | . | . 01 inputView.개별input() 자리에 valid 테스트 데이터 입력 . ServiceTest에서 inputView.개별input()을 받는 곳을 호출하되, 값만 임의로 넣어서 테스트한다. . @Test void valid_domain1_input_check() { //new RacingService(inputView.getNames()) //this.cars = new Cars(carNames); //given final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); //when,then assertDoesNotThrow(() -&gt; new RacingService(names)); } . | . 02 invalid한 테스트 작성하면서, 예외발생토록 도메인 검증 작성 . **invalid한 경우부터는 도메인 검증을 만들고, 예외를 발생시켜야한다. ** . | 도메인 만의 검증을 추가한다. . 복수/일급이라면 복수에 대한 것만 추가한다. | validate( 정제input ) -&gt; 모든 검증 나열하고 나중에, 메서드 추출하기 | . public Cars(final List&lt;String&gt; names) { // 2-5-2. 개별 도메인 검증 메서드 생성 validate(names); this.cars = names.stream() .map(name -&gt; new Car(name)) .collect(Collectors.toList()); } private void validate(final List&lt;String&gt; names) { long distinctCountOfNames = names.stream().distinct().count(); if (distinctCountOfNames != names.size()) { //2-5-3. thr 이후 해당 에외클래스() 생성 -&gt; 필요 예외 상속후 생성자만 메세지 파라미터 없이 정의 -&gt; 내부에서 super(&quot;message&quot;) throw new IllegalArgumentException(&quot;중복값을 입력할 수 없습니다.&quot;); //throw new DuplicateNameException(); } } . | . 03 커스텀 예외클래스 만들기 . thrw new 다음에 발생시킬 에러에 예외 클래스를 명시하고 . 상속할 기존 예외클래스를 extends한 뒤 | 부모예외클래스에서 필요했던 파라미터를 생성자로 받든지 or 내부에서 제공할 것으로, 파라미터 없는 생성자를 정의해주고 | 부모 생성자를 그대로 빌려 super() 내부에서 부모가 필요했던 상수를 생성자 내부에서 정의해주자. | . public class NameDuplicatedException extends IllegalArgumentException { public NameDuplicatedException() { super(&quot;이름이 중복될 수 없습니다.&quot;); } } . | . 04 invalid 테스트 . valid: 올바른_도메인이_들어올_경우를_확인한다 | invalid: 도메인이_중복된_경우_예외를_발생시킨다 | . @Test void invalid_domain2_input_exception_check() { //given final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재성&quot;); //when,then assertThatThrownBy(() -&gt; new RacingService(names)) .isInstanceOf(NameDuplicatedException.class) .hasMessageContaining(&quot;중복&quot;); } . 05 개별input~서비스객체 생성 -&gt; 재귀메서드화 in Controller생성자 . 에러시 재입력 받게 하기 위함. . public Controller(final InputView inputView) { //racingService = new RacingService(inputView.getNames()); getNames(inputView); } private void getNames(final InputView inputView) { try { racingService = new RacingService(inputView.getNames()); } catch (Exception e) { System.out.println(&quot;[ERROR] &quot; + e.getMessage()); getNames(inputView); } } . | . 재귀달린이후 테스트: 틀-&gt;맞으로 구성된 SequenceInputStream . 재귀 달린 순간부터 SequenceInputStream아니어서, 1번 틀리면 ControllerTest 안끝남. . @Test void input_null_or_empty_test() { // final String argument = &quot;&quot;; // final InputStream input = new ByteArrayInputStream((argument + &quot; n&quot;).getBytes()); // // System.setIn(input); final String argument1 = &quot;&quot;; // 틀 final String argument2 = &quot;재성, 재경&quot;; // 맞아서 재귀 통과 final InputStream input1 = new ByteArrayInputStream((argument1 + &quot; n&quot;).getBytes()); final InputStream input2 = new ByteArrayInputStream((argument2 + &quot; n&quot;).getBytes()); final SequenceInputStream sequenceInputStream = new SequenceInputStream(input1, input2); System.setIn(sequenceInputStream); assertThatThrownBy(() -&gt; new Controller(new InputView())).isInstanceOf(IllegalArgumentException.class) .hasMessageContaining(&quot;빈칸&quot;); } . | 문제는.. 추가되는 재귀input -&gt; 기존꺼 계속 Sequnece 이어져야함 -&gt; 재귀는 가장 나중에 달던가 [TDD는 하지말자.] . | . 06 메서드 파라미터로 들어오는 개별input과 이미 생성[되었을] service객체 . 이미 controller생성자 위쪽에서, 서비스 생성과 동시에 받아주는 input으로 service객체를 생성한 상태이므로, valid한 앞쪽 개별input을 미리 만들어주고, service객체를 만들어서 테스트해줘야할 듯 싶다. . 먼저 개발된 valid_domain1_input으로 service객체를 먼저 만들면서 메서드 + domain2_input을 넣어주도록 한다. . | 그래야 메서드(initDomain2()) 개발이 된다. . | . @Test void valid_domain2_input_check() { //given final List&lt;String&gt; validNames = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); final int round = 4; //when,then assertDoesNotThrow(() -&gt; new RacingService(validNames).initiateRound(round)) } . | service의 생성자에서 못받은 개별input을, service관리 인변에 넣어주자. . public void initiateRound(final int round) { this.round = new Round(round); } . | 07 invalid case -&gt; 도메인 검증 추가 작업 반복 . @Test void invalid_domain2_input_range_exception() { //given final List&lt;String&gt; validNames = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); final int round = -1; //when,then assertThatThrownBy(() -&gt; new RacingService(validNames).initiateRound(round)) .isInstanceOf(RoundRangeException.class) .hasMessageContaining(&quot;0회 이상&quot;); } . 08 개별input 재귀화 -&gt; TDD는 하지말것 . getRound(inputView); private void getRound(final InputView inputView) { try { racingService.initRound(inputView.getRound()); } catch (Exception e) { System.out.println(&quot;[ERROR] &quot; + e.getMessage()); getRound(inputView); } } . ControllerTest (재귀 올 개발 후 ) . 01 재귀작성 완료후 [개별input ALL 맞-&gt;맞 ]으로 컨트롤러 생성자 테스트 . 재귀가 추가됨에 따라, controller생성시 추가 &amp;&amp; 맞는 것으로 맞춰줘야하는 input이 늘어나기 때문에, controller생성으로 인한 input테스트는 가장 나중에 해야할 것 같다. . 개별input개수만큼 SequenceInputStream으로 들어가게 해준다. | . @Test void controller_input_test() { final String argument1 = &quot;재성, 재경&quot;; // 틀 final String argument2 = &quot;5&quot;; // 맞아서 재귀 통과 final InputStream input1 = new ByteArrayInputStream((argument1 + &quot; n&quot;).getBytes()); final InputStream input2 = new ByteArrayInputStream((argument2 + &quot; n&quot;).getBytes()); SequenceInputStream sequenceInputStream = new SequenceInputStream(input1, input2); System.setIn(sequenceInputStream); assertDoesNotThrow(() -&gt; new Controller(new InputView())); } . | . 02 컨트롤러 생성자withInput 전체를 셋업 올리고 -&gt; Controller.run (new OuputView()) 개발 . Controller controller; @BeforeEach void setUp() { final String argument1 = &quot;재성, 재경&quot;; // 틀 final String argument2 = &quot;5&quot;; // 맞아서 재귀 통과 final InputStream input1 = new ByteArrayInputStream((argument1 + &quot; n&quot;).getBytes()); final InputStream input2 = new ByteArrayInputStream((argument2 + &quot; n&quot;).getBytes()); SequenceInputStream sequenceInputStream = new SequenceInputStream(input1, input2); System.setIn(sequenceInputStream); controller = new Controller(new InputView()); } @Test void controller_run() { controller.run(new OutputView); } . public class OutputView { } . //controller public void run(final OutputView outputView) { //outputView의 기본 프린터 기능 쓰면서 //메인로직 //메인로직이후 service에게서 결과받은 것 -&gt; ouputView가 인자로 받아서 처리 } . 03 controller.run()내부에 service로직 + OuputView처리 . public void run(final OutputView outputView) { outputView.printStartMessage(); while (racingService.isContinuable()) { racingService.race(new RandomNumberGenerator()); racingService.decreaseRound(); } outputView.printRoundResult(racingService.getCurrentCars()); outputView.printWinner(racingService.getWinners()); } . 04 OutputView 결과받아 출력 작성 with OutputView Test . setup . OutputStream output; @BeforeEach void setUp() { output = new ByteArrayOutputStream(); System.setOut(new PrintStream(output)); // output.toString() -&gt; actual 로서 print된 스트링을 받아올 수 있게 된다 } . output에 들어갈 결과(dto or dtoList)를 만들어서 output에 뿌려주기 . @Test void name() { //(1)outputView.printRoundResult(racingService.getCurrentCars()); // racingService.getCurrentCars() -&gt; List&lt;CarDto&gt; 만들어주기 //controller.run()에 사용되던 dto결과들을 단일dto.of() -&gt; dto list -&gt; dtos 까지 직접 만들어준다. final CarDto 재성 = CarDto.of(&quot;재성&quot;, 1); final CarDto 재경 = CarDto.of(&quot;재경&quot;, 2); final List&lt;CarDto&gt; cars = Arrays.asList(재성, 재경); //(2) outputView객체 만들어서 print뿌려주기( output에 박히게 됨 ) new OutputView().printRoundResult(cars); //(3) print뿌려진 output.toString()과 예상string을 비교하기 // -&gt; sout는 System.lineSeparator()로 줄바꿈한다. // -&gt; 내부string은 n로 작성되면 -&gt; n 잡으면 된다. assertThat(output.toString()).isEqualTo(&quot;재성 : - n재경 : -- n&quot; + System.lineSeparator()); } . @Test void name2() { final CarDto 재성 = CarDto.of(&quot;재성&quot;, 1); final CarDto 재경 = CarDto.of(&quot;재경&quot;, 0); final List&lt;CarDto&gt; cars = Arrays.asList(재성, 재경); final CarsDto carsDto = new CarsDto(cars); new OutputView().printRoundResult(cars); assertThat(output.toString()).isEqualTo(&quot;재성 : - n재경 : n&quot; + System.lineSeparator()); } . @Test void name3() { //outputView.printWinner(racingService.getWinners()); // racingService.getWinners() -&gt; CarsDto 만들어주기 final CarDto 재성 = CarDto.of(&quot;재성&quot;, 2); final List&lt;CarDto&gt; cars = Arrays.asList(재성); final CarsDto carsDto = new CarsDto(cars); new OutputView().printWinner(carsDto); assertThat(output.toString()).isEqualTo(&quot;재성&quot; + System.lineSeparator()); } . @Test void name4() { //outputView.printWinner(racingService.getWinners()); // racingService.getWinners() -&gt; CarsDto 만들어주기 final CarDto 재성 = CarDto.of(&quot;재성&quot;, 2); final CarDto 재경 = CarDto.of(&quot;재경&quot;, 2); final List&lt;CarDto&gt; cars = Arrays.asList(재성, 재경); final CarsDto carsDto = new CarsDto(cars); new OutputView().printWinner(carsDto); assertThat(output.toString()).isEqualTo(&quot;재성, 재경&quot; + System.lineSeparator()); } . Application으로 controller.run(new OutputView()) 실행 . import controller.Controller; import view.InputView; import view.OutputView; public class application { public static void main(final String[] args) { final Controller controller = new Controller(new InputView()); controller.run(new OutputView()); } } .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/28/TDD-4-controller~inputview~%EB%8F%84%EB%A9%94%EC%9D%B8%EA%B2%80%EC%A6%9D.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/28/TDD-4-controller~inputview~%EB%8F%84%EB%A9%94%EC%9D%B8%EA%B2%80%EC%A6%9D.html",
            "date": " • Feb 28, 2022"
        }
        
    
  
    
        ,"post126": {
            "title": "TDD 3 자경(단일Dto~Service)",
            "content": "Controller와 Service . Controller는 도메인Service 의존하며, 생성자에서 같이 초기화된다. . controller의 생성자에서 inputView와 outputView와 함께, 생성된 or 생성한 service객체를 받아준다. . public GameController(GameService gameService, InputView inputView, OutputView outputView) { //controller가 알고 있던 빈 service객체에 this.gameService = gameService; // 외부에서 받음 this.inputView = inputView; this.outputView = outputView; } . | 컨트롤러 생성시 inputView객체를 받고 . 받은 inputView를 생성자에서 이용하여 inputView.getDto() 등의 데이터를 인자로 받아 Service를 생성한다. | 한번에 input을 받을 수 있을 경우, input에서 getDto로 Service로 다 가져온다. | outputView는 controller 작동시 인자로 받아서 사용된다. | . public GameController(InputView inputView) { //controller가 알고 있던 빈 service객체에 //외부에서 받은 InputView를 이용하여 service를 생성하여 초기화 racingGame = new RacingGame(inputView.getInitDto()); } public void run(OutputView outputView) { playGame(outputView); endGame(outputView); } public static void main(String[] args) { GameController controller = new GameController(new InputView()); controller.run(new OutputView()); } . | 컨트롤러 생성시 컨트롤러 생성자에서 service도 데이터없이 먼저 생성한다. . service가 필요한 데이터는 메서드의 인자로 받아서 service에 set한다. | . public RacingController() { racingService = new RacingService(); } // 한꺼번에 input을 dto로 받는게 아니라면, 개별로 -&gt; 메서드를 통해 input을 따로 입력받는다. racingController.generateRacingCars(carNameInput()); public static void main(String[] args) { RacingController racingController = new RacingController(); racingController.generateRacingCars(carNameInput()); int round = roundInput(); RacingCarOutput.printRoundResultMessage(); race(racingController, round); racingController.checkWinners(); } . | Controller[생성]시 inputView 받 -&gt; Service는 input데이터 받는 안받든 초기화하여 생성. + [작동]시 결과가져 줄OuputView를 받아 전달 . inputView에서 재입력 or 나눠서 받아야하는 경우가 아니라면 new Service( inputView.getInitDto() ) 생성시 받아 생성 | 먼저 서비스부터 생성되고 이후 순서대로 데이터를 set해야하는 경우, 먼저 서비스를 생성 new Service() 이후, 메서드 사용하면서 초기화 | . 객체 -&gt; Service까지 TDD . 단일 객체 TDD . 참고: TDD2 자동차경주 블로그 / DTO 단계별 적용 + 테스트 . 인자 없는 생성자 new Car() + 응답하는 메서드 + 값으로 비교부터 시작해서, 블로그 글을 보고 완성한다. | when 객체 와 생성자로 만든 예상객체를 비교한다. | . @Test void car_move_1step() { final Car car = new Car(&quot;재성&quot;, 0); car.move(4); assertThat(car).isEqualTo(new Car(&quot;재성&quot;, 1)); } @Test void car_move_2step() { final Car car = new Car(&quot;재성&quot;, 0); car.move(4); car.move(4); assertThat(car).isEqualTo(new Car(&quot;재성&quot;, 2)); } @Test void car_move_stop() { final Car car = new Car(&quot;재성&quot;, 0); car.move(3); assertThat(car).isEqualTo(new Car(&quot;재성&quot;, 0)); } . | . 필요시 도메인 검증 테스트 . 단일 Dto TDD . 완성된 단일 객체 -&gt; 꽁꽁 싸멘 일급컬렉션으로 가기 전에, List&lt;단일Dto&gt;가 있어야 일급컬렉션 결과조회 by toDto()로 가능할 것 같다. | . 단일객체의 모든 인스턴스 변수(필드)을 원시값으로 받는 Dto.of( , )로 받도록 정팩매부터 설계하고, getter로 뽑는 확인만 해주자. . final CarDto 재성 = CarDto.of(&quot;재성&quot;, 1); // Car의 모든 필드을 원시값으로 받아 만든다. assertThat(재성.getName()).isEqualTo(&quot;재성&quot;); . private final String name; private final int position; public CarDto(final String name, final int position) { this.name = name; this.position = position; } public static CarDto of(final String name, final int position) { return new CarDto(name, position); } public String getName() { return name; } public int getPosition() { return position; } @Override public boolean equals(final Object object) { . | 일급 TDD . 단일객체들 생성 -&gt; list에 넣기 -&gt; 일급 or 서비스에 넣기 -&gt; 단일객체 조정 -&gt; 그대로 반영 | . 정제가상 재료로 셋업 . input으로 들어오는 List&lt;String&gt;으로 split 정제되어 들어온다고 가정하고 setUp에 세팅한다. . Cars cars; @BeforeEach void setUp() { final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); cars = new Cars(names); } . | 필요시 도메인 검증 테스트 . input에서부터 정제된 데이터(split, convert)가 들어왔을 때, 검증하자. | . 기능 결과 확인용 toDto() 부터 . 일급은 쌓여져있어서 확인이 힘들다. -&gt; toDto()로 List&lt;단일Dto&gt;로 가져와서 확인한다. . 개발1: .getCurrentCars()로서 List&lt;단일Dto&gt;를 가져온다. | . @Test void toDto() { //3-3. 일급의 기능개발 전, 확인이 될 수 있게 현재 객체들을 Dto List로 가져오는 기능 // -&gt; 내부에서 dto가 단일객체를 이용하도록 짤 것 final List&lt;CarDto&gt; currentCars = cars.getCurrentCars(); // assertThat(currentCars.get(0)).isEqualTo(CarDto.of(&quot;재성&quot;, 0)); // List의 검사는 contains, containsOnly로도 검사할 수있따. assertThat(currentCars).contains(CarDto.of(&quot;재경&quot;, 0)); } . | . 일급.toDto()를 통한 메서드 기능 테스트 . 각종 확인 방법 . 일급.toDto() contains ( 예상객체 by Dto.of) | 일급.toDto() containsOnly ( 예상객체1, 2 by Dto.of) isEqualTo ( Arrays.asList(예상객체1, 2 by Dto.of)) | . | 일급.toDto() .get( index) isEqualTo ( **예상객체 by Dto.of **) | 일급.메서드() -&gt; 객체 isEqualTo ( **예상객체 by Dto.of **) | 단일Dto.from( 객체 1개 ) 개발 .getter() isEqualTo ( 값 ) | . @Test void race_move_1step() { cars.race(5); assertThat(cars.getCurrentCars()).contains(CarDto.of(&quot;재성&quot;, 1)); } @Test void race_move_0step() { cars.race(3); assertThat(cars.getCurrentCars()).contains(CarDto.of(&quot;재성&quot;, 0)); } @Test void get_max_position_cars() { cars.race(4); final Car maxPositionCar = cars.getMaxPosition(); assertThat(CarDto.from(maxPositionCar).getPosition()).isEqualTo(1); } . | . 단일Dto.from( 응답객체 ) 개발 -&gt; (객체비교불가상황)응답 값 1개만 getter 추출 -&gt; 값 비교 테스트 . 현재 maxPosition인 Car객체 (List)를 뽑기 위해 중간, Car객체 1개 추출 로직을 테스트해야한다. . actual에서 단일객체 1개마 뽑히는 상황 -&gt; 단일객체1 to 단일Dto로 바로 가도록 단일Dto.from() 정펙매를 만들어줘야 -&gt; 값을 추출할 수 있다. | 필드 1개만 알고 있는 상황을 확인해야하므로, max인 값을 가진 Car를 뽑아내기 때문에, 임의로 CarDto.of( , , )로 만들 수 없는 상황 | . @Test void get_max_position_car() { cars.race(4); final Car maxPositionCar = cars.getMaxPosition(); // 이름은 모름, position만 1인 것을 아는 상황. -&gt; 값으로 비교해야함 -&gt; Dto에서 뽑아내야함. } . public static CarDto from(final Car car) { return new CarDto(car.getName(), car.getPosition()); } . @Test void get_max_position_car() { cars.race(4); final Car maxPositionCar = cars.getMaxPosition(); //my) &lt;일부 속성(이름제외된 숫자속성)만 변화되어, 객체==만든 예상객체&gt;의 비교가 불가능할 경우, // 실제 객체를 -&gt; dto변형 후 값을 뽑아내 -&gt; 값 대 값으로 확인할 수 도 있다. assertThat(CarDto.from(maxPositionCar).getPosition()).isEqualTo(1); } . | . 일급의 응답(List&lt;객체&gt;)는 -&gt; 한방에 DtoList or 복수Dto로 한방에 . 일급이 사용되는 serivce에게는 DtoList or 복수 Dto로 응답해야한다. . 어차피 응답은 객체List로 오니 -&gt; 복수Dto.from( List&lt;객체&gt;)로 한방에 돌리자. | 내부에서 이미 개발된 stream 단일객체 + 단일Dto.from( 단일객체) -&gt; list로만 만들어주면 된다. | 대신 dto용 getter에 이름을… get()로 단순화시키자. | . @Test void get_max_position_cars() { cars.getWinners(); } . //일급 응답이 객체리스트? -&gt; 한방에 복수Dto.from만들기 public List&lt;Car&gt; getWinners() { final Car maxPositionCar = getMaxPosition(); return this.cars.stream() .filter(car -&gt; car.isSamePosition(maxPositionCar)) .collect(Collectors.toList()); } . // 이미 단일Dto.from이 개발된 상황이라면, // 객체리스트 -&gt; 복수Dto 한방에 개발한다. return CarsDto.from(this.cars.stream() .filter(car -&gt; car.isSamePosition(maxPositionCar)) .collect(Collectors.toList())); . public static List&lt;CarDto&gt; from(final List&lt;Car&gt; cars) { // 단일Dto List로 일단 만든 뒤 -&gt; 생성자 호출 예정 return cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList()); } . return CarsDto.from(this.cars.stream() .filter(car -&gt; car.isSamePosition(maxPositionCar)) .collect(Collectors.toList())); . private final List&lt;CarDto&gt; carsDto; public CarsDto(final List&lt;CarDto&gt; carsDto) { this.carsDto = carsDto; } public static CarsDto from(final List&lt;Car&gt; cars) { return new CarsDto(cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList())); } //public List&lt;CarDto&gt; getCarsDto() { public List&lt;CarDto&gt; get() { return carsDto; } . dtoList .get() -&gt; Dto List -&gt; 1개 뽑아서 값 비교..(현재 이름모르고 1개 값만 아는 상태) | . @Test void get_max_position_cars() { cars.race(4); cars.race(4); cars.race(4); final CarsDto winnerCars = cars.getWinners(); //복수Dto.get() -&gt; List &lt;단일Dto&gt; assertThat(winnerCars.get().get(0).getPosition()).isEqualTo(3); } . | . Service 객체 TDD . inputView로부터 오는 도메인의 재료를 컨트롤러 내부에서 생성될 때, 생성자로 될 때 받을지 | 객체생성 후, generate로 | | input재료들 -&gt; 받아서 생성자를 통한 일급 or List단일로의 변환 생성도 서비스 안에서 이루어진다. 필요재료라 인스턴스 변수로 관리해야한다. | . | . 재료없이 service객체 셋업 (원래 미리 생성 in 컨트롤러) . 컨트롤러에서 사용한다고 생각하자. . | 일단 컨트롤러 생성자에서부터 미리 서비스를 미리 생성시킬 예정이다. . 재료가 한번에 오면 initDto -&gt; service미리 생성시킬 시 받아주면 되는데 . @BeforeEach void setup() { racingGame = new RacingGame(InitDto.of(&quot;juri,hunch&quot;, &quot;5&quot;)); } . | 그게 아니라면, service.generate일급()처럼, 원재료를 일급/List객체로 변환하는 작업도 service가 담당한다. . public RacingController() { racingService = new RacingService(); } . | . | 셋업에 서비스 미리 생성 . RacingService racingService; @BeforeEach void setUp() { racingService = new RacingService(); } . | . input재료들을 받는 service 생성자도 만들어, 셋업에서 관리변수 채워놓기. . input을 나중에 받더라도.. 미리 만들어져있어야하구나. 그래야 꺼내는 기능만을 확인할 수 있다. . | service안에 관리 변수에 뭐가 들어있어야… 확인이 된input원재료 -&gt; 관리 변수 (Cars cars)를 통채로 받아주는 놈을 임시로 만들자. . 검증은 각 도메인 내에서 할 것임. 변환생성해주는 서비스에서 하지말자. | . @BeforeEach void setUp() { final List&lt;String&gt; carNames = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;, &quot;아라&quot;); racingService = new RacingService(carNames); } . private Cars cars; public RacingService(final List&lt;String&gt; carNames) { this.cars = new Cars(carNames); } . | . 기능 결과 확인용 일급.toDto() 호출 함수부터 . 서비스는 내부에 인스턴스변수로 일급 (or 객체List)를 관리한다. . 일급이나 객체List를 확인하는 방법은 toDto로 미리 정의해놓았다. | 이것을 부르는 메서드(getCurrent일급())를 먼저 TDD한다. 이름만 get일급()이지, toDto한 List&lt;Dto&gt;를 가져온다. | . | . @Test void get_current_cars() { racingService.getCurrentCars(); } . public class RacingService { public void getCurrentCars() { this.cars.getCurrentCars(); } } . public class RacingService { private Cars cars; public List&lt;CarDto&gt; getCurrentCars() { return this.cars.getCurrentCars(); } } . java @Test void get_current_cars() { final List currentCars = racingService.getCurrentCars(); . assertThat(currentCars).contains(CarDto.of(&quot;재성&quot;, 0)); } . | . 미리 안넣어놓고, 차후 setter역할의 service.generate()로 input재료 -&gt; 해당도메인 객체(일급) 변환 생성 TDD . 서비스는 해당도메인의 기능을 모아둔 것이다. 일단 해당도메인으로 변환시킨다. . 서비스.해당도메인생성( input재료) -&gt; 내부 관리 인스턴스 변수(일급orList)에 set되는 것을 확인해야한다. | 그것을 빼쓰라고 만든게 일급.toDto()있으니, 서비스에서 일급DTO내놔 메서드를 호출해서 컨트롤러에 제공해준다. | . @Test void generate_cars() { //given: input에서 오는 원재료 final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); //when racingService.generateCars(names); } . public class RacingService { public void generateCars(final List&lt;String&gt; names) { this.cars = new Cars(names); } } . public class RacingService { private Cars cars; public void generateCars(final List&lt;String&gt; names) { this.cars = new Cars(names); } } . @Test void generate_cars() { //given: input에서 정제된 원재료 final List&lt;String&gt; names = Arrays.asList(&quot;재성&quot;, &quot;재경&quot;); racingService.generateCars(names); //when //then assertThat(racingService.getCurrentCars()).contains(CarDto.of(&quot;재성&quot;, 0)); } . | . 필요시 전략객체 service에서 생성하여, 메서드의 파라미터로 넣어주기 . 들어간 Service 변수(인스턴스 변수, 필요 변수)확인 테스트 . 관리(인스턴스) 변수 중 VO는 getDto없이 asssertThat().extracting으로 내부 인변 바로 뽑아 확인하기 . input정제 VO 원시값까지 받아주는 service 생성자 추가 생성 . @Test void get_round() { racingService = new RacingService(carNames, 5); } . VO 객체 개발 . //서비스 생성자 추가 public RacingService(final List&lt;String&gt; carNames, final int round) { this.cars = new Cars(carNames); this.round = new Round(round); } //VO 개발 public class Round { private final int round; public Round(final int round) { this.round = round; } @Override public boolean equals(final Object object) { . VO를 받아서 생성하는 service를 초기화 후, extracting으로 객체 뽑아서 1:1비교 . 기존 서비스는 노인자 -&gt; names(stringList-&gt;일급) -&gt; names 포함한 VO까지 받아서 처리 | . @Test void get_round() { racingService = new RacingService(carNames, 5); //when, then assertThat(racingService).extracting(&quot;round&quot;).isEqualTo(new Round(5)); } . 메인로직 TDD . 메인로직 실행 . 일급.메서드()를 실행시키는 단순로직 . 응답 값이 없는 실행 메서드다? 사용객체와 예상객체로 비교 | 랜덤값이 포함되어있으면, 그만큼 빼줘야한다… 하지만, 그냥 빼면… 일괄 적용되므로, 인터페이스로 빼고 -&gt; 필요한 곳에서 전략메서드 호출()하도록 뺀다. 테스트에선 전략객체 대신 최종 결과값만 넣어주면 됨. (여기선 생략) | . | . @Test void race() { racingService = new RacingService(carNames, 5); racingService.race(); racingService.race(); assertThat(racingService.getCurrentCars().get(0).getPosition()).isEqualTo(2); } . 전략 인페 + 전략메소드 정의 | 전략을 구현한 랜덤인페 + 메소드 정의 | 전략메소드 호출시점에만, 메소드 호출하여 랜덤 시행 + 그외에는 전략객체만 파라미터로 수정 | 테스트에선 람다식으로 인자 없이 랜덤한 return값을 직접 지정 () -&gt; return을 준다. | | . 메인로직 실행 횟수(VO)의 iterator TDD . service가 만들어질 때나, 만들어진 이후 가지고 set되어야할 VO는 service내부 관리 변수 확인 테스트에서 처음 등장했다. . @Test void get_round() { racingService = new RacingService(carNames, 5); assertThat(racingService).extracting(&quot;round&quot;).isEqualTo(new Round(5)); } . | 컨트롤러에서 service.메인로직()을 service.hasNext(VO)만큼 돌려야한다. . | . 01 service. isContinuable() -&gt; Vo.isNotFinish() -&gt; true/false를 테스트한다. . hasNext패턴의 while()문에 들어갈 조건부이다. . @Test void vo_is_continuable() { racingService = new RacingService(carNames, 5); final boolean isContinuable = racingService.isContinuable(); assertThat(isContinuable).isTrue(); } @Test void vo_is_not_continuable() { racingService = new RacingService(carNames, 0); final boolean isContinuable = racingService.isContinuable(); assertThat(isContinuable).isFalse(); } . //Service public boolean isContinuable() { return this.round.isNotFinish(); } //Round public boolean isNotFinish() { return this.round &gt; 0; } . | . 02 service.play메인로직() 내부에서 -&gt; 메인객체.메인로직() 와 동시에 돌아갈 + VO감소로직 VO.getNext(); 처리 . VO감소 -&gt; 감소된 VO반환하여 service관리 VO를 덮어쓰기 . 이 과정이 while문 true 내부 메인로직 돌아갈 때 같이 돌아가야한다. | . @Test void vo_can_decrease() { racingService = new RacingService(carNames, 4); //프로덕션코드에서는, 반복될 메인로직 실행부 메서드와 같이, race실행시 round감소를 같이시켜줘야한다. //racingService.play(); racingService.playWIthRoundDecrease(); } . //Service public void playWIthRoundDecrease() { //1. 메인(일급)객체.race() //2. decrease된 vo를 받아와야함 *값만 변화(round.decrease())하면 안됨 round = round.getNext(); } . //Round public Round getNext() { // 여기서는 0보다 커야한다는 검증이 있으면 0으로 갈때 에러가 나니 조심! // 검증은 hasNext패턴을 가지는 VO는 무조건 검증을 정팩메에 주자~ return new Round(this.round - 1); } . @Test void vo_can_decrease() { racingService = new RacingService(carNames, 4); //프로덕션코드에서는, 반복될 메인로직 실행부 메서드와 같이, race실행시 round감소를 같이시켜줘야한다. //racingService.play(); racingService.playWIthRoundDecrease(); //내부의 round값이 변화되기 때문에 -&gt; 응답 값이 아닌 사용객체 vs 예쌍객체로 비교해야한다. assertThat(racingService).extracting(&quot;round&quot;).isEqualTo(new Round(3)); } . | . 랜덤응답의 범위 TDD(단위테스트) . 랜덤을 생성하는 메서드를 학습하는 단위테스트 범위내로 들어오나? -&gt; isBetween(a, b) -&gt; a&lt; = &lt;= b의 검사 | . | . 값 1개의 랜덤: @RepeatedTest() + .isBetween . //사용할 객체 만들고 RandomNumberGenerator randomNumberGenerator; @BeforeEach void setUp() { randomNumberGenerator = new RandomNumberGenerator(); } //응답값의 범위 확인을 여러번 @RepeatedTest(100) void range_test() { assertThat(randomNumberGenerator.generate()).isBetween(0, 9); } . List의 랜덤: iterator의 hasNext패턴 -&gt; 객체비교 . @Test void Random_숫자범위_검사() { // 원래는 랜덤으로 차있는 list -&gt; iterator final ListIterator&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 44, 45).listIterator(); // 랜덤값들을 돌면서 검사 while (numbers.hasNext()) { assertThat(numbers.next()) .isGreaterThanOrEqualTo(1) .isLessThanOrEqualTo(45); } } .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/26/TDD-3-%EB%8B%A8%EC%9D%BCDto-~-Service.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/26/TDD-3-%EB%8B%A8%EC%9D%BCDto-~-Service.html",
            "date": " • Feb 26, 2022"
        }
        
    
  
    
        ,"post127": {
            "title": "TDD 2 자동차경주(객체Dto)",
            "content": "실패하는 코드를 짜는 이유? 통과하는 코드를 짜려고 하면, case단위가 아니라 다 짜야해서 너무 커진다. | case 만드는 것이 목적 -&gt; 실패 case부터 만든다. | . | 테스트코드도 복잡도를 낮춘다. | . 기능 요구사항 복붙후 정리 . 복붙 . 각 자동차에 이름을 부여할 수 있다. 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다. 자동차 이름은 쉼표(,)를 기준으로 구분한다. 자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한명 이상일 수 있다. . 제목(##) + 앞에 체크박스 만들기 . ## 요구사항 - [ ] 각 자동차에 이름을 부여할 수 있다. - [ ] 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다. - [ ] 자동차 이름은 쉼표(,)를 기준으로 구분한다. - [ ] 자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한명 이상일 수 있다. . 각 요구사항들을 테스트코드 DisplayName으로 작성하기도 한다. | . 키워드 뽑기 . ## 요구사항 - [ ] 각 자동차에 이름을 부여할 수 있다. - [ ] 전진하는 자동차를 출력할 때 자동차 이름을 같이 출력한다. - [ ] 자동차 이름은 쉼표(,)를 기준으로 구분한다. - [ ] 자동차 경주 게임을 완료한 후 누가 우승했는지를 알려준다. 우승자는 한명 이상일 수 있다. - 자동차 - 이름 - 자동차 이름은 쉼표(,)를 기준 - 전진 - 게임 - 우승 - 우승자는 한명 이상 . 키워드 관계 재배치 . 객체인지 vs 메서드인지 vs 세부 요구사항인지 | 객체 중에 이름만 다르게 뽑을지 -&gt; 뽑는 것은 관리자 객체에서 우승한 자동차 -&gt; 자동차 중 뽑은 것 -&gt; 자동차 경주(관리자) | . | . - 자동차 - 전진: 자동차가 하는 것이니 객체가 아닌 메서드 - 우승한 자동차: 따른 객체인지 vs 자동차 중 뽑아서 이름만 다르게? - 우승자는 한명 이상: 세부 요구사항 - 이름 - 이름은 쉼표(,)를 기준: 세부 요구사항 - 자동차 게임: 자동차에서 우승한 자동차 뽑는 것은 이상하니, 게임이 관리하면서 뽑도록 - 우승한 자동차: 따른 객체인지 vs 자동차 중 뽑아서 이름만 다르게? - 우승자는 한명 이상: 세부 요구사항 . 시작점 고르기 . 자동차 게임 -&gt; 관리자부터 하기엔 잘 모름 | 자동차 -&gt; 핵심이자 간단한 단위 객체 진짜 잘 모르겠으면 이름부터 해도 된다. | . | . 출력, View에 대한 요구사항은 무시하고 객체 설계부터 시작 . UI, view를 맨나중에 붙이면, 객체다운 객체가 완성됨. | . TDD 시작 . 정의 없는 default생성자 사용 / 응답 하는 메서드부터 . TDD 시작점을 new Car();의 생성자에서 부터 시작하는 경우가 많다. . 보통은 Car car = new Car();의 생성자로 TDD를 시작한다. 여기서 시작해서 테스트 코드로 변하게 된다. | . | . @Test void 생성자_검사() { //방법1. 생성시 예외발생안함. assertDoesNotThrow(() -&gt; new Car(재성)); //방법2. 생성한 것이 null이 아님. final Car car = new Car(&quot;재성&quot;); assertThat(car).isNotNull(); } . | 여기서는 객체 생성자와 동시에 상수 먼저 응답하는 기능 메서드를 주 테스트로 시작한다 . 움직였을 때, 1칸 움직였다고 -&gt; 상수 1을 응답할거라 가정하고 작성한다. | . //1. 객체+Test로 테스트 class 작성 public class CarTest { @Test //2. (생성자 따로 검사하는게 아닌) 객체의 기능으로 메서드 명 먼저 작성 void move() { //3. 없어도 객체 생성자 호출 final Car car = new Car(); //4. 객체 기능을 호출하되, 테스트에 용이하도록 &lt;호출시 응답 결과값&gt;이 있을 거라 예상 -&gt; assertThat( actual )에 바로 값 넣어주기 //car.move() //5. 기대하는(나와야하는) 응답 값을 .isEqualTo( expected )에 넣어주기 assertThat(car.move()).isEqualTo(1); } } . | 컴파일 에러들을 잡는다. . 예상하는 응답값을 상수로 바로 나오도록 먼저 작성한다. | . public class Car { public int move() { return 1; } } . | 테스트를 돌려서, 상수 1로 응답하는지 확인한다. . | . case 추가(누적 -&gt; 응답 expected 변경 2) . 복붙으로 다른 Test case(메서드 맨끝_네임 수정)를 작성하며 안돌아가는 코드 구현 . 1칸 움직여서 1 반환하는 case도 있지만, 2번 움직이는 or 안 움직이는 케이스도 있음. . 메서드를 복붙해서 case를 나눈다 | . @Test void move_go() { final Car car = new Car(); assertThat(car.move()).isEqualTo(1); } @Test void move_go2() { final Car car = new Car(); //1. car.move(); //2. assertThat(car.move()).isEqualTo(2); // 2를 응답해줘야함. } . | . 기존 작성된 메서드를 메서드2로 복붙한 뒤 구현 . 기존 코드는 돌아가도록 하는 상태(move() 그대로 두기)에서 move() -&gt; move2()로 복붙한 뒤, 직전꺼도 포함해서 다 돌아가도록 구현 . package domain; public class Car { public int move() { return 1; } public int move2() { return 1; } } . 누적되려면, 저장할 변수가 필요해서 필드(인변)를 선언하여 거기다가 가지고 있도록 한다.. | . public int move2() { return position++; } . public class Car { private int position; public int move() { return 1; } public int move2() { return ++position; } } . | . 복붙 수정 메서드2를 사용해서 통과시켜본다. . 복붙new Test method 에서 복붙 method2()를 사용해서 통과시킨다. . @Test void move_go2() { final Car car = new Car(); //1. car.move2(); //2. assertThat(car.move2()).isEqualTo(2); } . | . 기존case도 수정 메서드2로 변경해보고 -&gt; 기존메서드()는 회색띄운 뒤 삭제 . 처음 테스트도 .move2()를 사용하게 한 뒤 테스트 . | 테스트 통과하면 기존 move()는 사용안되서 회색 떠있음 -&gt; alt + del로 안전삭제 . @Test void move_go() { final Car car = new Car(); assertThat(car.move2()).isEqualTo(1); } @Test void move_go2() { final Car car = new Car(); //1. car.move2(); //2. assertThat(car.move2()).isEqualTo(2); } . | . 최종 수정메서드2 -&gt; 매서드로 이름 변경 . .move2()가 -&gt; .move()를 대체하는 순간 . @Test void move_go() { final Car car = new Car(); assertThat(car.move()).isEqualTo(2); } @Test void move_go2() { final Car car = new Car(); //1. car.move(); //2. assertThat(car.move()).isEqualTo(2); } } . | . case 추가(조건 따라 stop -&gt; expected는 stop일때 나와야하는 값으로 미리 넣어두기 0) . 복붙 Test case 추가 ( 설계전 해당 case expected입력해서 error) . move_stop케이스 추가 -&gt; expected 0을 응답하도록 작성하기 . @Test void move_stop() { final Car car = new Car(); //1. 1번움직였는데 &gt; 0을 응답해야하는 경우도 처리 assertThat(car.move()).isEqualTo(0); } . | . 메서드2()로 복사해서 다시 처리 . 해당 조건일 때만 움직이게 해준다. . public int move2() { if (ThreadLocalRandom.current().nextInt(10) &gt;= 4) { position += 1; } return position; } } . | . 내부 랜덤 포함 메서드는 테스트 실행시마다 결과가 다르다. . 특정 테스트 바깥에 커서를 두고 전체 테스트 실행 랜덤이 껴있는 경우 돌릴 때 마다 다르게 결과 | . | . 랜덤은 가능한 구조로 바꿔주기 . 랜덤부분만 파라미터화시켜 밖으로 빼준다. . 기존 . public int move() { if (ThreadLocalRandom.current().nextInt(10) &gt;= 4) { position += 1; } return position; } . | 파라미터화시켜 밖으로 빼기 . 자동으로 사용중이던 부분(랜덤)이 –&gt;메소드 사용처로 이동된다. | . public int move(final int number) { if (number &gt;= 4) { position += 1; } return position; } . assertThat(car.move(ThreadLocalRandom.current().nextInt(10))).isEqualTo(0); . | . 사용처의 랜덤생성을 특정 상수로 바꾼다. . 랜덤은 프로덕션 코드에서만 사용되므로 추출되어 사용처로 옮겨간 랜덤부분을 테스트에서는 상수로 변경한다. . @Test void move_go2() { final Car car = new Car(); car.move(5); assertThat(car.move(5)).isEqualTo(2); } @Test void move_stop() { final Car car = new Car(); assertThat(car.move(3)).isEqualTo(0); } } . | . 랜덤 뿐만 아니라 랜덤포함조건자체를 객체의 역할로 . 객체가 테스트를 위한 랜덤부분 외부 파라미터로 추출 뿐만 아니라 . | if 조건에 따른 다른 역할을 하는 객체로 취급하고 싶다면 if조건 자체를 인터페이스로 추출할 수 있다. . 전략패턴은 대체가능한 다른전략을 넣는 부분을 인터페이스 -&gt; 전략메서드로 추출해놓는다. | . 바뀔 수 있는 부분을 잡아서 상태에 맞게 메소드로 추출해놓는다. . | 인터페이스 XXXXStrategy + 이름만 가진 추상메서드를 만든다. . | 특정Strategy의 이름을 정해서 impl구상클래스를 추출메소드를 복붙해서 구현한다. . | 특정전략의 메소드가 사용된 곳마다 —&gt; 다른전략을 허용하는 추상화된 인터페이스 객체를 인자로 받은 뒤 -&gt; 추상체.추출메소드()호출로 수정한다. . | 이제 에러난 부분을 타고가면서, *내부 매개변수 정의에 사용된 추상 인자를 호출하는 외부 인자 자리에 new 특정전략()를 넣워준다. . | 테스트에서 다른전략으로 조건부의 상수인 람다함수로 () -&gt; true를 대입하여 움직임을 확인한다. . | | . 확인을 위한 응답 값(조회)이 실제 필요한지 의심해봐야한다 . 내부 position만 바뀌면 되는데, 테스트를 위해 응답하고 있지는 않은지 의심하자. | . 응답하는 것도 1가지 일(조회)다. 위치변경(테스트할 기능) + 조회 2가지 일을 하는 move() . 포지션을 조회하고 싶다면 또다시 car.move()를 호출해서 확인해야하나? 변하면서 조회되므로 이상하다. . public int move(final int number) { if (number &gt;= 4) { position += 1; } return position; } . | 조회는.. 응답 말고도 다른 방법이 있다. 값으로 만드는 객체로 비교 . | . 조회 메서드가 아니라면, 테스트 끝난 후, 응답 값 제거리팩토링 . 메서드2() 복붙 생성하여, 응답이 제거된 메서드2 생성 . public int move(final int number) { if (number &gt;= 4) { position += 1; } return position; } public void move2(final int number) { if (number &gt;= 4) { position += 1; } } . | Test에서는 assertThat()에 응답 값을 넣어줘야하는데? . assertThat(car.move(3)).isEqualTo(0); . | . 응답 값 대신 [해당객체]를 / expected 예상값 대신 예상값으로 생성한 + equals옵라된 [예상객체]를 . 예상값으로 예상객체를 만들어줄 생성자를 추가한다. . | 기존에는 default 생성자로서, 인자 없이 만들었다. Select None으로 기존 것도 사용가능하게 빈 default 생성자를 따로 정의해주자. . . public Car() { } . | 생성된 객체로 비교하기 위해, equals, hashCode를 옵라이딩 . | 응답 없는 메소드2로 치환 후, 객체.메서드2호출 - assertThat(객체). (예상객체) 로 비교 . 이제 전부 응답없는 메소드2로 치환 -&gt; actual 응답 자리에서 빼주기 . @Test void move_go() { final Car car = new Car(); car.move2(4); // 1.actual에는 실제응답 대신, 객체를 assertThat(car).isEqualTo(new Car(1)); // 2. 예상값으로 만든 예상객체 } . | 기존 assertThat( 응답값 ) .isEqualsTo ( 예상값) . assertThat(car.move(4)).isEqualTo(0); . | assertThat( 사용객체 ) .isEqualsTo ( 예상객체) . ar.move2(4); assertThat(car).isEqualTo(new Car(1)); . | . 생성자도… 테스트를 위한 생성자인지 고민 -&gt; 그렇다면 .getPosition() 대신 .position()으로 마무리? . get이라는 네이밍을 빼서 내부에 position이 있는지 모르게 하는게 핵심 | . 외부추출랜덤은 상위 객체 테스트를 막는다 . 자동차.move()의 내부 랜덤 추출 -&gt; 자동차.move(랜덤사용) -&gt; 자동차.move(랜덤사용)을 호출하는 자동차경주가 내부 랜덤을 포함하게 됨. | . 상위 객체(관리자) Test -&gt; List&lt; 테스트끝난객체&gt; 를 받도록 생성 -&gt; 돌면서 시켜야함. . 단일 테스트가 끝난 단일객체에 대해서 일급 컬렉션 생성 전 LIst&lt;단일&gt;을 사용 == 세팅by생성자( List&lt;단일객체&gt; )하는 상위객체, 관리자객체를 Test서부터 만든다. . 필요한 것은 set을 생성자에서 받는다. | 다 못받으면, 필요기능의 메서드 파라미터로 | . @Test void name() { final List&lt;Car&gt; cars = Arrays.asList(new Car(), new Car()); final RacingGame racingGame = new RacingGame(cars); } . public class RacingGame { public RacingGame(final List&lt;Car&gt; cars) { } } . public class RacingGame { private final List&lt;Car&gt; cars; public RacingGame(final List&lt;Car&gt; cars) { this.cars = cars; } } . | 관리자=상위객체에서 메서드() -&gt; list를 돌며 단일객체 메서드 시키기 . public class RacingGame { private final List&lt;Car&gt; cars; public RacingGame(final List&lt;Car&gt; cars) { this.cars = cars; } public void start() { cars.forEach( car -&gt; car.move(ThreadLocalRandom.current().nextInt(10))); } } . | Car만 테스트는 가능하고, 그 상위객체인 RacingGame은 테스트가 불가능한 상태다. . 원한다면 다시 랜덤부분을 파라미터로 추출하면 된다. | 어디까지 테스트가능 구조로 할지는 자기가 선택하는 것 | 상위객체도 테스트 가능한 구조로 만들고 싶다면, 파라미터화시켜 외부로 빼면 된다. | . | 가장 끝단의 객체를 찾고, 테스트 불가 부분을 밖으로 뺀다. . . 한단계 더 올리면, RacingGame도 테스트가 가능해진다. . . | 랜덤, 특정 날짜에만 작동 등이 테스트하기 힘든 코드다. . 외부로 분리해서 주입한다. | . | . .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/%EA%B8%B0%EB%8A%A5%EA%B5%AC%ED%98%84%EB%AA%A9%EB%A1%9D/2022/02/24/TDD-2-%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/%EA%B8%B0%EB%8A%A5%EA%B5%AC%ED%98%84%EB%AA%A9%EB%A1%9D/2022/02/24/TDD-2-%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Feb 24, 2022"
        }
        
    
  
    
        ,"post128": {
            "title": "피드백) 1-1(자동차경주) 코드리뷰",
            "content": "자경 미션 피드백 . PR 1차 피드백 | PR 2차 피드백 리뷰어: 코니 | . | . 네이밍 . if절에 들어가는 메서드명은 is~, has~로 시작하자. | VO의 새객체 반환 메서드네이밍을 toNextRound()로 잡았다. to는 괜찮을까? toString, toDto 같이 형 변환시에만 사용하자.. 또 바꿔야겟넹.. getNextRound() | . | Util이라는 추상적인 이름 대신 Validator처럼 구체적인 이름으로 클래스 잡기 . | 조건문 전체가 아니라, 일부 값 비교에서도 네이밍을 변수로 추출하는게 좋다 . private static void checkDuplicated(List&lt;String&gt; carNames) { if (carNames.stream().distinct().count() != carNames.size()) { long distinctCountOfCarNames = carNames.stream().distinct().count(); if (distinctCountOfCarNames != carNames.size()) { . | 추출할 때, 메서드의 인자는 구체적으로X 좀더 추상적으로 정의해주기 | . 체크 . 메소드 사용 순서대로 배치후 commit -&gt; 커밋전 체크리스트화 structure(alt+7) | . | 불필요 공백 제거후 coimmit | 테스트 코드 돌리고 commit @parameterizedTest &lt;-&gt; @Test | . | intellij 상수, 변수추출을 private으로 최초 1번 옮겨주기 | 유틸이라도 해당 class에서만 사용된다면, private 으로 변경해줘야한다. . | static 유틸 클래스는 private생성자로 객체생성없음을 명시해주기 | 상수 &lt;-&gt; 멤버변수 개행 1줄 넣어주기 . | 전략메서드에는 인페/클래스명에 있는 목적어(number)를 repeat할 필요없다. 동사(generate)만 | . 검증 . 실수로 기입된 내부공백(Blank) 검사는 문자열숫자의 format검사가 있다면 안해도 된다. . | 부정조건문 없애자 . | . 생성자 . static 유틸 클래스는 private생성자로 객체생성없음을 명시해주기 . | 접근제한자 기본은 private으로 바꿔주기 . | 도메인은 input이외에 자체 검증 -&gt; input에서는 공통검증 / 도메인 자체검증 생성자 . | 생성자 로직 private 기본 생성자 | public from( 원본 List&lt; Car&gt;) + Cars검증로직(중복 등) | public fromNames or fromInput(List&lt; String &gt;) + Cars검증로직(중복 등) | . | 테스트에서 단일-&gt; 단일List 만든 뒤, 단일 조정 by메서드 -&gt; 단일List에 반영 -&gt; 반영된 단일List로 일급컬렉션 생성 | 불변을 위해 포인터의 포인터 사용을 막아야하는데, 테스트에서는 포포를 사용할 수 있게 inputString List가 아닌 단일객체List로부터 만드는 생성자(정펙매) 추가 | . | . 기본 . split은 2번재 인자를 줘야, ,, 를 안씹고 간다. -&gt; split( , -1) . String[] split = &quot;,,&quot;.split(&quot;,&quot;); // count 0 String[] split1 = &quot;,,a&quot;.split(&quot;,&quot;); // 3 String[] split2 = &quot;,a,&quot;.split(&quot;,&quot;); // 2 String[] split3 = &quot;a,,&quot;.split(&quot;,&quot;); // 1 . | split후 trim까지 해서 반환해야 a, a를 다른 것으로 인식한다. -&gt; split(,-1).map(String::trim) . return Arrays.stream(value.split(delimiter, -1)) .map(String::trim) .collect(Collectors.toList()); . | convert나 split관련 기본api가 충분하면, 유틸 메서드로 따로 빼지말고 그냥 사용하자. 지식만 늘어난다. . | 조건문의 전략객체(Functional interface)에는 () -&gt; 람다식으로 테스트한다. . | . VO, DTO . Dto는 controller에 일단 넣어준다. . | ROUND는 hasNext패턴으로 줄어가는데, 생성자 검증은 1이상 &lt;-&gt; 1씩 줄여가니 0까지는 감. 생성자에서 검증하되, 새객체 반환은 검증없는 private 기본생성자이용 | . | DTO는 VO나, 포장객체 없이 only 원시값들로 필드가 구성 -&gt; Dto사용을 위한 원본 getter에서는 VO-&gt;value까지 최종반환시킨 getter . | VO를 가진 단일객체의 compareTo에 원시값 비교 x -&gt; VO로 비교 -&gt; VO도 비교가능하게 . | 정펙매 생성자 중간에 VO가 등장할 경우, getter()를 써도 된다. . | VO는 검증/불변을 위해 래핑한 것이므로, 도입했다고 굳이 정펙매를 외부에 오픈안해도 된다 . private Cars getCars() { try { return Cars.fromNames(InputView.getCarNames()); //Cars.fromNames(Names.fromInput(InputView.getCarNames())); . 같은 context에서 사용될 일이 없는, 객체 생성 가운데 활용되는 객체들은 구현을 드러내지 않는 것이 좋을 것 같습니다! | . | . 테스트 . DTO의 테스트는 view처럼 자주 바뀌는 DTO에 대해 테스트를 생각해본다. . | DisplayName은 너무하다 싶을정도로 자세히 쓴다. . class NameTest { //@DisplayName(&quot;이름이 1자 미만, 5자 초과일 경우&quot;) //@DisplayName(&quot;자동차 이름이 1자 미만, 5자 초과하여 유효하지 않은 경우&quot;) @DisplayName(&quot;자동차 이름이 1자 미만, 5자 초과하여 유효하지 않은 경우 예외가 발생한다&quot;) . 이정도로 결과까지 명확하게 서술하면 더 좋습니다. | . | @ValueSource의 빈 문자열과 @EmptySource가 같은 값을 제공하지 않나요? . @EmptySource @ValueSource(strings = {&quot;&quot;, &quot;Wishoon&quot;, &quot;123456&quot;}) . | .",
            "url": "blog.chojaeseong.com/java/feedback/review/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/23/%ED%94%BC%EB%93%9C%EB%B0%B1)-1-1(%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC)-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0.html",
            "relUrl": "/java/feedback/review/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/23/%ED%94%BC%EB%93%9C%EB%B0%B1)-1-1(%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC)-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0.html",
            "date": " • Feb 23, 2022"
        }
        
    
  
    
        ,"post129": {
            "title": "강의) 네오 1단계 자경 피드백",
            "content": "final 키워드로 값의 변경을 막아라 . 값은 final로 재할당금지 -&gt; 재사용 금지 . . main 메소드 template 인 psvm의 인자에도 final을 붙혀준다. . . | 메서드 내부에서 코드 중간에서 가변 변수를 수정할 때, 위에 재할당 등의 수정이 되었었나 확인해야한다. final로 재할당(재사용)이 불가능한 불변 값사용하다가, 변수의 재사용이 필요할 경우 새 변수를 만들어서 쓰자. | . | 모든 지역변수, 인자에 final을 붙이자. . . | . final 객체의 내부 속성변화 메서드 -&gt; 변한 속성으로 만든 새 객체로 응답 . 객체의 경우는 final로는 완벽한 불변을 못만든다. . final 값와 달리 final 객체는 메소드 등에 의해 내부가 변할 수 있다.(포인터의 포인터에서 껍데기 포인터1) | . | 객체를 불변으로 만든 법상태변화를 일으키는 기능들은 새로운 객체를 반환하도록 정의하자. . 상태변화 시켰던 메서드의 void returnType에 해당 객체를 응답(return)하도록 수정 . public void move() { this.position++; } public Car move() { this.position++; } . | 변화된 상태로 new생성자()로 호출하여 -&gt; 새로운 객체를 반환시킨다. . public Car move() { return new Car(this.position + 1); } public Car(final int position) { this.position = position; } . | | . 객체, 컬렉션(껍데기포인터1)등은 응답시 copy해서 응답하라 . my) 포인터1의 포인터2에 의해 변경될 수 있으니, 껍데기 포인터1 자체를 copy해서 응답해라 . 컨밴션 중 하나가 된다. . final을 붙이는 것은 컨벤션이며 팀 안에서는 따르는게 좋을 수 도 있다. 내 생각에 타당하지 않으면 얘기를 꺼내서 바꿀 수 있다. | . | 컨벤션이라면, 비효율적이라도 그대로 가는 경우가 많다. 디자인 패턴 역시, 효율적이거나 좋은 코드라서 뿐만 아니라, 커뮤니케이션을 줄이는 컨밴션이기 때문에 좋기도 하다. | . | . 참고 글 . 후디 블로그 | . 객체를 객체스럽게 사용해라 . 아래와 같이 getter와 setter만 있는 객체를 구현하지 않는다. | setPosition()같은 setter 대신 move()의 역할로 분리해야한다. | getter()는 안쓰는게 좋은데, setter()는 100% 확정적으로 안쓰는게 좋다. setter() == 생성자 == pushed 로 외부에서 주입은 X | 특히 불변객체의 경우는 속성 변화 -&gt; 새 객체로 응답해야하니, setter란 개념이 없다. | . | view에서 사용하는 getter()는 필수적이다. view에서 getter()안쓰기 위해 toString() 쓰는 것은… 좀 아니다. | getter()쓰지마라라는 말은 도메인에서 getter() 쓰는 대신, 객체에 메세지를 던지면서 협력하라는 뜻이다. | 객체를 직접 사용하지말고, View에서는 dto로 값만 꺼내써라 | . | Q. view에서 cars.get(0).getPosition()은 가능한가요? . my) 디미터법칙 위반이다 -&gt; 책임을 2번째 놈에게 위임해야됌 . | index 0 은 무엇을 말하는지 모른다. . | 가져오려는 이유가 무엇인지 부터 물어보고 싶다. . 우승자를 구하려는 이유라면 메세지를 던지는 식으로 바꿔보자. cars.getWinners() | . | . | .get + .get이 이어지는 경우가 있는데 의심을 해봐야한다. . 점 1개로 줄이도록 해보자. . cars.getFirst().getPosition(); cars.getFirstPosition(); . | 첫번째 포지션 -&gt; 의미가 애매하다 -&gt; 위너로 바꾸자. . cars.getWinners(); . | . | . | . 객체.getXXX()대신 new XXX( 객체 )를 던지는 클래스로 만드는 방법도 . **getter()대신 객체를 생성자로 던져 class를 만들어볼까? ** . new Winner(cars); . | . 객체를 던졌어도, 객체.setter() 등의 주입 대신 역할위임을 하자. . public class Racing { ... public int run(Car car) { int num = random.nextInt(11); int position = car.getPosition(); if (num &gt;= 4) { position++; } car.setPosition(position); return position; } } . car.setPosition(position);대신에 car 내부로 역할이 위임되어서 내부에서 했으면 좋겠다. | . 인변의 접근제한자는 private으로 고정 -&gt; 객체상태에 대한 접근은 제한 . getter()도 지금 허용할까말깐데.. 인변에 접근은 절대 안시킨다. | . . 그렇다면 public, protected는 왜 있는 걸까? 과거에는 의도가 있어서 만들었는데, 요즘에는 필요없다고 느껴졌을 수 가 있음. | 과거에는 왜 여러 접근제한자를 만들었을까? | public으로 열여있으면, getter/setter 동시허용이나 마찬가지다. 어디서든 접근하면 -&gt; 불안해야 한다. | 이 역할만 하면 좋겠다. | 변수를 public으로 열어두면, 변했는지 안했는지 직접 보고 확인해야하는 비용이 든다. | 변수를 public으로 열어두지말고, method를 열어주어 캡슐화된 속성변화를 만들어내자. | . | . | . (내부)랜덤요소는 단위 테스트하기 힘들다. . 내부에 random은 테스트하기 힘들다. . . | . 밖에서 받아오는 메서드로 변경한다. . 테스트하기 힘든 내부 랜덤은 일단 밖에서 주어지는 파라미터로 변경 한다. . 파라미터 추출 단축키 ctrl+shit+P | . public void move() { if (getRandomNo() &gt;= 4) { this.position++; } } car.move(); . public void move(final int number) { if (number &gt;= 4) { this.position++; } } car.move(car.getRandomNo()); // 자동으로 메서드의 인자도 바뀐다. . | 문제점: 밖에서 받아오는 랜덤이 . 단일객체.move( 밖 ) | 일급컬렉션.move( 밖 ) cars.forEach( car -&gt; car.move( 밖 ) ) -&gt; .. | . | 일급컬렉을 사용하는 클래스에서도 ( 밖 ) | 어디 밖까지 빼서 받아올지가 끝이 없다 -&gt; 적절한 경계를 잡아준다. | . | 질문: . car.move ( 밖 )도 테스트 했는데, cars.move ( 밖 ) 도 테스트해야할까? 마음의 평화가 중요함. 자기가 생각해 봐야함. | . | 리뷰어에게는 설계가 담근 readme의 링크와 같이 보낸다. | . | 받아오는 인자를 전략메소드를 가진 인터페이스로 변경하여 -&gt; 랜덤외에 구상 전략객체들도 입력가능하게 만든다. . public interface MovableStrategy { boolean isMove(); } . 인변 수는 최소화한다. . 최대 2개 정도로… . | 기존 인변으로 만들어낼 수 있는 것은, 변수로 선언하지 않는다. . public class RacingGame { private List&lt;Car&gt; cars; private List&lt;String&gt; winners; . | my) 인변으로 둔다 -&gt; 바깥에서(or default값으로) 받아와 알고있고, 의존해야하는 것 . 그게 아니라면, 시간이 좀 걸리더라도, 기존 인변들도 만든다. | 관리포인트를 늘리면 좋은가? 그냥 그때그때 실시간으로 만드는게 좋은 것 같다. | 현대에는 메모리/컴퓨팅 비용성능 «&lt; 인력의 유지보수성 | DB를 이용하는 시점에서 변수 -&gt; 성능을 위한 캐싱을 하기도 한다. | . | . ### setter는 사용을 자제해라 -&gt; 생성자에서 초기화 후 더이상 변경안한다. . 인스턴스 변수는 생성자 초기화 후에 불변을 유지하기 위해 setter는 사용을 자제한다. | setter의 문제점은? 역할을 하지 못하게 된다. | 어디서든 변경되어 -&gt; 내 의도와 다르게 동작한다. | 유지보수성이 떨어진다. | . | . 비즈니스 로직과 UI 로직의 분리 . View관련 코드는 도메인에 넣지말라는 소리 . 90%는 도메인에 View관련 코드를 넣었었다. . public class Car { private int position; ... private void print(int position) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; position; i++) { sb.append(&quot;-&quot;); } System.out.println(sb.toString()); } } . | . | 리뷰를 받으면서 점점 분리한다. . | 왜 분리할까? 그냥 출력하도록 도메인에서 메서드 만들면 되는거 아닌가? . getter쓰지말라고 해서 -&gt; 객체.역할부여()로 출력역할 만들었더니 | 역할부여는 도메인 &amp;&amp; getter없이 하는게 맞지만, 변경이 자주 일어나는 view로직을 예외다. | . | View관련 로직 . 출력관련 역할부여(책임)를 도메인에서 안시킨다. 아예 정의하지말고 도메인은 객체만 넘겨라. . 출력 책임은 객체가 가지게 하지마라 | &lt;변경 빈번&gt; UI변경 -&gt; &lt;변경없어야할 소중한, 중요도가 높은&gt; 도메인에 여파를 일으키면 큰일이 나기 때문 | . | dto로 getter로 값만 꺼내쓰게 할 것이다 . | . | . Collection 활용 로직 처리 . Car 목록에서 최종 우승자를 구하는 로직이다. 이 코드를 Collection 기능을 사용해 어떻게 리팩터링할 것인가? . public class ResultView { private Cars cars = null; private String getTopRankedCar(List&lt;Car&gt; carList) { String topCarString = &quot;&quot;; cars = new Cars(carList); int maxPosition = getMaxPosition(carList); for (int i = 0; i &lt; carList.size(); i++) { if (cars.getPosition(i) == maxPosition) { topCarString += cars.getCarName(i) + &quot;, &quot;; } } return topCarString.substring(0, topCarString.length() - 2); } private int getMaxPosition(List&lt;Car&gt; carList) { int maxPosition = 0; cars = new Cars(carList); for (int i = 0; i &lt; carList.size(); i++) { if (maxPosition &lt; cars.getPosition(i)) { maxPosition = cars.getPosition(i); } } return maxPosition; } } . | . 기본 api를 이용해서 다짜지 말자 . Collection을 활용해 로직을 구현할 때 직접 구현하려 하지 말고 먼저 Collection API를 통해 해결할 수 있는 방법이 있는지 찾는다. 방법을 찾았는데 해결 방법을 찾지 못하는 경우만 직접 구현한다. . . 경계값을 테스트한다. . 다 하는게 아니라 경계값만 테스트 . 모든 테스트 X | . @Test public void 랜덤숫자가_4이상일때만_움직인다() { Car car = new Car(); assertFalse(car.shouldMove(0)); assertFalse(car.shouldMove(1)); assertFalse(car.shouldMove(2)); assertFalse(car.shouldMove(3)); assertTrue(car.shouldMove(4)); assertTrue(car.shouldMove(5)); assertTrue(car.shouldMove(6)); assertTrue(car.shouldMove(7)); assertTrue(car.shouldMove(8)); assertTrue(car.shouldMove(9)); } . | . 테스트 픽스처 생성 . 테스트를 반복적으로 수행할 수 있게 도와주고 매번 동일한 결과를 얻을 수 있게 도와주는 ‘기반이 되는 상태나 환경’을 의미한다. 여러 테스트에서 공용으로 사용할 수 있는 테스트 픽스처는 테스트의 인스턴스 변수 혹은 별도의 클래스에 모아 본다. . 중복제거를 위해 하면 된다. | junit의 @beforEach를 사용하면 된다. 테스트 픽스쳐의 일종이다. | . public class RacingGameTest { private final String[] testNames = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}; private final int testPosition = 5; private final String resultSamePositionString = &quot;, b&quot;; private final String resultWinnersString = &quot;a, b&quot;; RacingGame racingGame; private final Car firstWinner = new Car(testPosition, &quot;a&quot;); private Car secondWinner; private final List&lt;Car&gt; cars = new ArrayList&lt;Car&gt;(); ... } . | . 과정 실습 . 추후 미션이 진행 되면, 복잡해지고 객체가 많아질 경우, 코드를 분리해야됨. . @Test void move() { final Car car = new Car(&quot;재성&quot;); } . | 비슷한 환경의 테스트를 복사해서 case를 나눈다고 가정하자. . @Test void move_go() { final Car car = new Car(&quot;재성&quot;); } @Test void move_stop() { final Car car = new Car(&quot;재성&quot;); } . | 객체의 생성이 반복된다면, Generate &gt; Setup method를 선택해서 @BeforeEach를 생성하자. . @BeforeEach void setUp() { } @Test void move_go() { final Car car = new Car(&quot;재성&quot;); } @Test void move_stop() { final Car car = new Car(&quot;재성&quot;); } . | 공통되는 객체생성코드를 beforeEach로 뺀다 . @BeforeEach void setUp() { final Car car = new Car(&quot;재성&quot;); } @Test void move_go() { } @Test void move_stop() { } . | ctrl+.(show context action)을 눌러서 split declation and assignment를 통해 . 변수 선언은 변수재활용을 위해 클래스변수로 클래스변수에 넣고 매번 초기화한다 -&gt; 변수 재활용한다 -&gt; 변수 재할당한다 -&gt; final은 안된다. | . | 할당만 beforeEach에서 매 테스트마다 새로운 것으로 분리한다. | . @BeforeEach void setUp() { final Car car; car = new Car(&quot;재성&quot;); } . class ApplicationTest { //final Car car; // 매 테스트마다의 재활용 = 재할당 Car car; @BeforeEach void setUp() { car = new Car(&quot;재성&quot;); } . | 픽스쳐가 많아지면, 공통이 맞는지 확인한다. . | . 특정상태를 만들어주기 위한 반복코드 -&gt; 생성자로 상태 바로 만들기 . 과도하게 반복해서 만든다? . public class RacingGameResultTest { @Test public void check_ranking_if_correct() { List&lt;Car&gt; cars = new ArrayList&lt;&gt;(); Car car1 = new Car(&quot;pobi&quot;); Car car2 = new Car(&quot;crong&quot;); Car car3 = new Car(&quot;honux&quot;); car1.move(); car1.move(); car2.move(); car2.move(); car2.move(); car3.move(); cars.add(car1); cars.add(car2); cars.add(car3); ... } } . 단순반복의 경우, 반복문+메서드 호출로 해결할 수도 있지만, 그렇지 않은 경우가 많다. | 상태를 만들기 위해 복잡한 과정이 많은 경우, 상태를 바로 만들어주는 생성자를 만들 수 있다. 여기선, move()테스트가 아니라 우승자를 찾는게 목적이기 때문에, 목적 달성을 위해, 다른 것은 바로 상태를 만드는 생성자를 만들수 도 있음. | 현재는 move()호출방식에 따라 테스트가 의존하여, 변하면 테스트코드가 깨질 수 도 있다. | 테스트를 위해 생성자를 만들지만, 그게 진짜 테스트만을 위한 코드인지 생각해봐야한다. | . | . public Car(final String name, final int position) { this.name = name; this.position = position; } List&lt;Car&gt; cars = new ArrayList&lt;&gt;(); // Car car1 = new Car(&quot;pobi&quot;); // Car car2 = new Car(&quot;crong&quot;); // Car car3 = new Car(&quot;honux&quot;); Car car1 = new Car(&quot;pobi&quot;, 2); Car car2 = new Car(&quot;crong&quot;, 3); Car car3 = new Car(&quot;honux&quot;, 1); // car1.move(); // car1.move(); // car2.move(); // car2.move(); // car2.move(); // car3.move(); cars.add(car1); cars.add(car2); cars.add(car3); . 이 코드가 프로덕션 코드에서 사용되지 않더라도, 객체관점+객체역할에서 봤을 때, 테스트를 위한 기능이 아닐 수 있다. 객체 관점에서 자연스러우면 괜찮다. | position default값을 지정해주는 관점에서 괜찮다. | . | 테스트만을 위한 메서드추가는 문제가 더 큰데, 생성자는 객체를 만드는 방법일 뿐이므로 생성자는 많아도 괜찮다. 충분히 납득이 가능하다. | . | . | 생성자는 여러개 만들면, 인자 많은 것을 주생성자로 취급하고 인자 적은 생성자 -&gt; 위쪽에 위치하고 default값을 this에 넣어주는 부생성자 . // 부 생성자는 주 생성자(name, position)보다 더 앞에 위치하며, 뒤쪽의 주 생성자를 this( , )로 사용한다. public Car(final String name) { this(name, 0); } public Car(final String name, final int position) { this.name = name; this.position = position; } . | 생성자가 너무 많아지거나, 같은 시그니쳐 or 이름을 주고 싶을 때 -&gt; 정팩메로 분리 고려 . | . getter없이 구현 가능? . setter/getter 메서드를 사용하지 말라는 것은 핵심 비지니스 로직을 구현하는 도메인 객체를 의미한다. 도메인 Layer -&gt; View Layer, View Layer -&gt; 도메인 Layer로 데이터를 전달할 때 사용하는 DTO(data transfer object)의 경우 setter/getter를 허용한다. . | 아예 없이 toString으로 구현하는 분들도 있지만, 도메인 Layer에서 사용하는 getter를 만들지마라 == 비즈니스 로직를 위한 getter를 이용하지마라 . 도메인 대신 DTO 구현시 getter/setter는 허용한다. . | DTO라도 setter는 생성자에서 초기화하는 것으로 대신한다. | view에서는 열어야한다. | . | 접근제한자는 최소한으로 열고 시작한다. . | getter로 받아와서 하지말고, 역할을 부여해서 시키는 것 -&gt; 그래야 협력한다. . | . 객체안에서 toDTO를 만들지마라 . 내부에서 toDto()를 만든다? 모델에서 DTO를 알면 왜 안좋을까? | DTO는 뷰에 종속적인 객체 -&gt; view처럼 변경이 많다 -&gt; 도메인에 영향을 줌 | 객체 안에서 DTO를 생성하지마라 | 객체는 밥줄이라 아껴야하고, DTO는 막쓴다. | . | . 테스트를 위한 코드는 구현코드에 분리 . 테스트용 편의 메서드를 구현 코드에서 구현하지마라 | . 생성자로 주입하는 건 괜찮고, setter는 안좋냐? . 똑같은 내부 코드(행위)보다는 역할이나 시점을 봐야한다. | setter가 하나라도 존재하면 내부 상태변화 기능.move()을 따로 가지는 객체지만, 객체를 믿을 수 없게 된다. 기능으로 내부 변하는 것도 좀 그런데… 언제든지 변화시키는 믿을 수 없는 객체가 된다. | . | .",
            "url": "blog.chojaeseong.com/java/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/23/%EA%B0%95%EC%9D%98_%EB%A0%88%EB%B2%A81_1%EB%8B%A8%EA%B3%84_%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_%EB%84%A4%EC%98%A4_%EA%B0%95%EC%9D%98(%EC%99%84).html",
            "relUrl": "/java/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC/%EA%B0%95%EC%9D%98/%ED%94%BC%EB%93%9C%EB%B0%B1/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/23/%EA%B0%95%EC%9D%98_%EB%A0%88%EB%B2%A81_1%EB%8B%A8%EA%B3%84_%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_%EB%84%A4%EC%98%A4_%EA%B0%95%EC%9D%98(%EC%99%84).html",
            "date": " • Feb 23, 2022"
        }
        
    
  
    
        ,"post130": {
            "title": "Console 입력-검증-생성자 정리",
            "content": "콘솔 프로그램 입력/검증/생성자 . 자동차경주 1,2차 피드백(1단계 미션)후 콘솔입력 -&gt; 검증 -&gt; 개별 모델 생성자 구조를 생각해보았다. . | 아직 Dto - domain 의존은 해결되지 않은 상황 . 나중에 참고할 것: DTO를 의존 하는 domain 문제 PR | . | . InputView . 재활용 SCANNER . 스캐너를 사용하는 public static getInput() . private static final Scanner SCANNER = new Scanner(System.in); public static String getInput() { return SCANNER.nextLine(); } . | 4단계 InputView.getXXX() . 개별 모델input들을 의미하는 getXXX()는 4단계로 구성됨. . public static List&lt;String&gt; getCarNames() { OutputView.printRequestInstruction(REQUEST_CARS_NAME); List&lt;String&gt; carsName = Arrays.stream(getInput().split(SPLIT_DELIMITER, -1)) .map(String::trim) .collect(Collectors.toList()); Validator.validateCarNames(carsName); return carsName; } public static String getRound() { OutputView.printRequestInstruction(REQUEST_ROUND_VALUE); String inputRound = InputView.getInput(); Validator.validateInputNumber(inputRound); return inputRound; } . OuputView.print( 안내메세지 ) . | 스캐너를 사용해서 받은, 복수형이면 split(,-1) by Arrays.stream( ).map().collect() / 단수형이면 그냥 . List&lt;String&gt; or String | . | 복수형이면 실제이름XXXX를 붙이고 / 단수형이면 Input(String) or InputNumber(StringNumber)를 붙인 . Input루트의 공통검증: Validator.validate~ -&gt; 재료는 List&lt;String&gt; 아니면 String(Number)로 무조건 String타입을 검증대상으로 보게 정했다. . 복수형이면 check복수형(개별Empty, 중복) -&gt; for validateInput or validateInputNumber의 단수 공통검증 . private Validator() { // 유틸클래스는 따로 객체생성안한다는 private생성자로 표시 } public static void validateCarNames(List&lt;String&gt; carNames) { checkCarNamesEmpty(carNames); checkDuplicated(carNames); for (String carName : carNames) { validateInput(carName); } } . | 단수형이면 String이냐 StringNumber냐에 따라서 다르게 . String: NullOrEmpty + IncludeBlank | StringNumber: NullOrEmpty + Format(넣으면 IncludeBlank안넣어도 된다) | private static void validateInput(String carName) { checkNullOrEmpty(carName); checkIncludeBlank(carName); } public static void validateInputNumber(String inputRound) { checkNullOrEmpty(inputRound); checkValidFormat(inputRound); } . | | | return List&lt;String&gt; or String(2번) . | | Controller . try/catch . 입력받을 때, 입력 예외발생시 다시 입력받기 받으려면 **getXXXX()가 ** . 검증을 포함하는 부분시켜서 | 재귀호출하는 하도록 메서드화되어 있고 그부분을 try/catch로 쌓여있여있어야하는데, | . | getXXX() + 받아서 모델의 (정펙매)생성자 호출하는 과정까지 try/catch로 감싸면, 도메인 자체검증도 try/catch의 재귀에 걸려 도메인 자체검증 예외발생시에도 재입력받을 수 있게 된다. . 객체 생성로직( 자체 검증 -&gt; 객체 생성)까지 포함시켰으니, 해당 메서드는 try성공시 객체를 returnType으로 | . private Cars getCars() { try { return Cars.fromInput(InputView.getCarNames()); } catch (IllegalArgumentException e) { OutputView.printErrorMessage(e); return getCars(); } } private Round getRound() { try { return Round.fromInput(Integer.parseInt(InputView.getRound())); } catch (IllegalArgumentException e) { OutputView.printErrorMessage(e); return getRound(); } } . RacingGame racingGame = RacingGame.createRacingGame( getCars(), getRound(), new RandomNumberGeneratePolicy() ); . | . Controller getXXX(): InputView.getXXX() 응답 String -&gt; convert+생성자객체생성+try/catch . 대신, 중간에 필요한 객체의 생성자까진 노출할 필요는 없다. . public class RacingGameController { public void startRacing() { RacingGame racingGame = RacingGame.createRacingGame( getCars(), // InputView의 getXXX()는 무조건 String -&gt; 중간 객체(Name)도 다 노출... private Cars getCars() { try { return Cars.fromNames(Names.fromInput(InputView.getCarNames())); . 지금은 Cars를 만들기 위해 Names의 존재를 알아야 하는 상황인데요, 사실 Names는 Cars 안에서만 사용되고 있죠. 그렇다면 Names의 존재가 바깥에 노출될 필요가 있을까요? 구현을 드러내고 있는 건 아닐까요? 원시값 포장한 것은 굳이 생성자를 안드러내도 된다. | . | . private Cars getCars() { try { return Cars.fromInput(InputView.getCarNames()); public static Cars fromInput(List&lt;String&gt; InputNames) { Names names = Names.fromInput(InputNames); return new Cars(names.getNames( . | . 생성자 . 01 private 기본생성자 . 복수( List&lt;단일&gt;) ex&gt; Cars . private Cars(List&lt;Car&gt; cars) { this.cars = cars; } . 단일객체 (포장객체들, Name+Position ) ex&gt; Car . private Car(Name name) { this.name = name; this.position = Position.from(DEFAULT_POSITION_VALUE); } . 일급컬렉션 (List&lt;원시&gt;) ex&gt; Names . private Names(List&lt;Name&gt; names) { this.names = names; } . StringNumber (int ) ex&gt; Round . private Round(int roundNum) { this.roundNum = roundNum; } . String (String ) ex&gt; Name . private Name(String name) { this.name = name; } . 복수Dto (List&lt;CarDto&gt;) ex&gt; CarsDto . private CarsDto(final List&lt;CarDto&gt; carsDto) { this.carsDto = carsDto; } . 단일Dto (원시값들) ex&gt; CarDto . public CarDto(String name, int position) { this.name = name; this.position = position; } . 02 .fromInput ( only String or List&lt;String&gt; ) . inputView에서 기본검증을 거치고 난 뒤, 자체 검증만 필요한 친구들 만약, stream.map 단일객체생성자 등장시 -&gt; 단일객체로 검증이 옮겨짐 | . | . 복수( List&lt;단일&gt;) ex&gt; Cars . public static Cars fromInput(List&lt;String&gt; InputNames) { Names names = Names.fromInput(InputNames); return new Cars(names.getNames().stream() .map(Car::fromName) .collect(Collectors.toList())); } . 단일객체 (포장객체들, Name+Position ) ex&gt; Car . // . 일급컬렉션 (List&lt;원시&gt;) ex&gt; Names . 자체검증하는 대신, stream상에서 단일객체에서 검증이 옮겨짐. | . public static Names fromInput(List&lt;String&gt; names) { return new Names(names.stream() .map(Name::from) .collect(Collectors.toList())); } . StringNumber (int ) ex&gt; Round . public static Round fromInput(int inputRound) { validateRound(inputRound); return new Round(inputRound); } . String (String ) ex&gt; Name . // . 복수Dto (List&lt;CarDto&gt;) ex&gt; CarsDto . // . 단일Dto (원시값들) ex&gt; CarDto . // . 03 .from( 원본재료 ) . 복수 . input없이 프로덕션내부 or 테스트에서 사용된다. -&gt; 유틸화된 공통검증 + 자체 검증 만일, 원본재료가 포장된 객체라면, 자체검증은 포장객에게 갈 수 있다. | . | . public static Cars from(List&lt;Car&gt; cars) { return new Cars(cars); } . VO 는 .from(원본 1개만) . 정팩메 1개 -&gt; input이지만 .from + 유일 자체 검증 생성자 | . public static Position from(int position) { validatePosition(position); return new Position(position); } . 복수( List&lt;단일&gt;) ex&gt; Cars . test코드에서 Car -&gt; Cars로 바로 생성하기 위해 | . public static Cars from(List&lt;Car&gt; cars) { return new Cars(cars); } . 단일객체 (포장객체들, Name+Position ) ex&gt; Car . 일급컬렉션, 복수 쪽에서는 stream을 통해 원본 List -&gt; 단일객체 List -&gt; 일급으로순으로 가기도 한다. | . public static Car fromName(Name name) { return new Car(name); } . 일급컬렉션 (List&lt;원시&gt;) ex&gt; Names . test코드용 | . public static Names from(List&lt;Name&gt; names) { validateNames(names); return new Names(names); } . StringNumber (int ) ex&gt; Round . test를 안하고, controller에서 마지막에 convert시킬거라을 input원본 받을일이 없음. | . // . String (String ) ex&gt; Name . 복수, 일급컬렉션의 Names에서 stream으로 만들어지는 과정 | 테스트용 | . public static Name from(String name) { checkValidLengthOfName(name); return new Name(name); } . 복수Dto (List&lt;CarDto&gt;) ex&gt; CarsDto . 일급컬렉션 내부에서 toDto()호출시 ** List&lt;단일&gt; **유일 필드-&gt; List&lt;단일Dto&gt; 변환후 기본생성자로 복수Dto로 만들어줌 -&gt; from일급컬렉 | 공통적인 기본 private List&lt;단일Dto&gt;를 호출해줄 public -&gt; .from | public static CarsDto fromCars(final List&lt;Car&gt; cars) { //todo: 5. cars -&gt; carsdto의 정펙메( List&lt;Car&gt; ) -&gt; List&lt;CarDto&gt; -&gt; 일급 생성자 // carsDto의 생성자는 car list(cars)를 받아서 -&gt; cardto list -&gt; 일급 dto를 만드는 곳 final List&lt;CarDto&gt; carDtos = cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList()); return new CarsDto(carDtos); } public static CarsDto from(final List&lt;CarDto&gt; carsDto) { return new CarsDto(carsDto); } . 단일Dto (원시값들) ex&gt; CarDto . 복수or일급컬렉션에서 stream에서 Car -&gt; CarDto시 사용될 .from원본( 1:1원본) | OuputView 테스트에서 원시값 필드들로 생성하는단일Dto -&gt; 복수Dto | public CarDto(String name, int position) { this.name = name; this.position = position; } .",
            "url": "blog.chojaeseong.com/java/console/input/validation/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/22/%EC%BD%98%EC%86%94%EC%9E%85%EB%A0%A5_%EA%B2%80%EC%A6%9D_%EC%83%9D%EC%84%B1%EC%9E%90(%EC%99%84).html",
            "relUrl": "/java/console/input/validation/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/22/%EC%BD%98%EC%86%94%EC%9E%85%EB%A0%A5_%EA%B2%80%EC%A6%9D_%EC%83%9D%EC%84%B1%EC%9E%90(%EC%99%84).html",
            "date": " • Feb 22, 2022"
        }
        
    
  
    
        ,"post131": {
            "title": "DTO 단계별 적용(자동차경주)",
            "content": "단일DTO . 참고 DTO 쓴 PR | . 01 Controller의 OutputView.print( )에 List&lt;단일Dto&gt; 반환해주기 . OutputView.printResultEveryRound(racingGame.getCurrentCars()); . 관리자객체에서도 List&lt; 단일객체 &gt;나오는 일급에 들어가지 않았으므로 그대로 여기서 return될 타입이 List&lt; 단일Dto &gt;를 예상하자 | . public List&lt;CarDto&gt; getCurrentCars() { return this.cars.getCurrentCars(); } . 02 일급 속 List&lt;단일객체&gt;를 stream.map으로 List&lt;단일Dto&gt;로 변환 . public List&lt;CarDto&gt; getCurrentCars() { return this.cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList()); } . 03 Dto 변환 정펙메는 from(단일객체) -&gt; 모든 속성들 원시값까지 나눠서 get . 이 때, Car는 VO Name, Position이라도, Dto의 속성 및 getter()는 순수 원시값만 가지고 뱉어낸다. 예를 들어, car.getName()은 Name(VO) return이 아니라 this.name.getName()의 원시값을 return해야 CarDto가 생성자에서 개별속성들을 원시값으로 받아먹을 수 있다. | . | . public class CarDto { private final String name; private final int position; public CarDto(String name, int positiion) { this.name = name; this.position = positiion; } public static CarDto from(Car car) { return new CarDto(car.getName(), car.getPosition()); } public String getName() { return this.name; } public int getPosition() { return this.position; } } . 04 OutputView는 List&lt;단일Dto&gt;를 받아서 getter들로 출력 로직 작성 . public static void printResultEveryRound(List&lt;CarDto&gt; currentCars) { for (CarDto currentCar : currentCars) { System.out.println(currentCar.getName() + &quot; : &quot; + collectDash(currentCar.getPosition())); } System.out.println(); } . 일급Dto . 01 일급.toDto()를 통한 List&lt;단일Dto&gt;자리를 일급Dto로 교체 . 단일Dto는 List -&gt; steram -&gt; map 가운데만 등장했으나 | 일급Dto는 this.일급.toDto()의 책임이 주어진다. | . public CarsDto getCurrentCars() { //return this.cars.getCurrentCars(); return this.cars.toDto(); . 02 일급Dto 정펙매 공식 재료는 일급 내부에 있는 List&lt;단일객체&gt; (No List&lt;단일Dto&gt;) . 단일Dto는 Car가 모르고, 내부에서 이용안한다. Cars내부에서 List&lt;CarDto&gt; 만들 때 map에서 사용된다. | 일급Dto는 Cars가 알고 이용하여, 내부에서 변환환다. | 일급내부의 단일객체 List만 건네주면, 내부에서 단일Dto -&gt; 일급Dto 한번에 변환후 생성 다해준다. List&lt;단일Car&gt; —정팩메List&lt;단일Dto&gt;—&gt; CarsDto | . | . // todo: 4. Cars의 toDto()함수는 &lt;&lt;Cars내부지만 CarsDto를 알고, 의존하여&gt;&gt; [CarsDto의 정팩메]를 호출 Cars -&gt; CarsDto로 변환한다. // my) Cars는 CarsDto와 그 정팩메를 알고 있다! public CarsDto toDto() { return CarsDto.fromCars(cars); // from List&lt;단일객체CarDto&gt; vs from다른것 Cars } . 일급Dto 정펙매의 재료가 List&lt;단일Dto&gt;가 아니라 List&lt;단일객체&gt;만 있으면, 내부에서 단일Dto List -&gt; 일급Dto까지 간다. | . public static CarsDto fromCars(final List&lt;Car&gt; cars) { // 필요재료가 List&lt;단일Dto&gt;가 아니라 List&lt;단일객체&gt;만 있으면, 내부에서 단일Dto List -&gt; 일급Dto까지 간다. final List&lt;CarDto&gt; carDtos = cars.stream() .map(car -&gt; CarDto.from(car)) .collect(Collectors.toList()); return new CarsDto(carDtos); } . 03 일급Dto의 getter 네이밍은 get()으로 줄여주자. . 안줄이면. XXXsDto.getXXXsDto() -&gt; get으로 네이밍 줄여주기 | 단일Dto는 개별속성 getter()가 목적이라 Dto.get속성() | . public List&lt;CarDto&gt; get() { return carsDto; } . 04 OutputView내부 List&lt;단일Dto&gt; 사용 -&gt; 일급Dto.get() . //public static void printRacingRecord(List&lt;CarDto&gt; cars) { // for (CarDto car : cars) { public static void printRacingRecord(CarsDto carsDto) { for (CarDto car : carsDto.get()) { . DTO테스트 . 01 Dto를 사용하는 OutputView의 Test로 테스트한다. . ByteArrayOutputStream 변수 + setOut에 설정하기 차후 print명령을 내놓고 -&gt; output.toString()에서 확인하기 | . | . private final ByteArrayOutputStream output = new ByteArrayOutputStream(); @BeforeEach public void setUp_streams() { System.setOut(new PrintStream(output)); } . 02 [원시속성들]로 단일Dto 만드는 깡통 [정펙매of ] 정의 . 메서드로만 변환되는 deafult값의 position필드도 다 받도록 한다. (Dto는 깡통) | 1개 이상의 속성들을 받아야하므로 .of()의 정펙매로 개발한다. | . public static CarDto of(final String name, final int position) { return new CarDto(name, position); } . 03 프로덕션에 없던, 일급Dto의 정펙매from ( List&lt;단일Dto&gt;) 정의 . 프로덕션에서는 일급내부 List&lt;단일&gt; —일급Dto정펙매–&gt; (List&lt;단일Dto변환 -&gt;) 일급Dto 테스트에선 단일Dto 출발 -&gt; List&lt;단일Dto&gt;를 받아 일급Dto 생성해줄 정펙매 필요함. | . | . public static CarsDto from(final List&lt;CarDto&gt; carsDto) { return new CarsDto(carsDto); } . 04 output.toString()은 변수로 못받는다. 바로 확인 . //given final CarsDto carsDto = CarsDto.from(Arrays.asList(CarDto.of(&quot;재성&quot;, 1), CarDto.of(&quot;재경&quot;, 1))); //when: output.toString을 이후 actual변수에 따로 못받음. OutputView.printRacingRecord(carsDto); //then assertThat(output.toString()).contains(&quot;재성 : -&quot; + System.lineSeparator() + &quot;재경 : -&quot;); . final CarsDto carsDto = CarsDto.from(Arrays.asList(CarDto.of(&quot;재성&quot;, 1), CarDto.of(&quot;재2&quot;, 1))); // 우승자가 2명인 상황이라 가정해야됨. &gt; Winner들만 모인 CarsDto를 넘겨받는다. OutputView.printRacingResult(carsDto); assertThat(outputStream.toString()).contains(&quot;재성, 재2가 최종 우승했습니다&quot;); .",
            "url": "blog.chojaeseong.com/java/dto/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/22/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_DTO_%EB%8B%A8%EA%B3%84%EB%B3%84-%EC%A0%81%EC%9A%A9(%EC%99%84).html",
            "relUrl": "/java/dto/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/22/%EC%9E%90%EB%8F%99%EC%B0%A8%EA%B2%BD%EC%A3%BC_DTO_%EB%8B%A8%EA%B3%84%EB%B3%84-%EC%A0%81%EC%9A%A9(%EC%99%84).html",
            "date": " • Feb 22, 2022"
        }
        
    
  
    
        ,"post132": {
            "title": "동일성vs동등성(equals, hashCode)",
            "content": "동일(ㅣ)성 = (I)dentity = 메모ㄹ(ㅣ)주소 . 반대로 동등성 = equality = 정해준 값이 같은지 . | equals는 equality가 아닌메모리 주소(identity) 비교가 default라서 오버라이딩 해야한다. . == = 메모리 주소로 비교 = default equals . public boolean equals(Object obj) { return (this == obj); } . | = = 값으로 비교 = 오버라이딩 equals . | . | . 세팅 . public class Car { private final String name; private int position; // 부 생성자는 주 생성자(name, position)보다 더 앞에 위치하며, 뒤쪽의 주 생성자를 this( , )로 사용한다. public Car(final String name) { this(name, 0); } public Car(final String name, final int position) { this.name = name; this.position = position; } } . 오버라이딩 전 default equals -&gt; 메모리비교 . @Test void before_overriding_equals_test() { //1. 오버라이딩 전 deafult equals : 같은 메모리 주소만 true final Car 재성 = new Car(&quot;차&quot;); final Car 석영 = new Car(&quot;차&quot;); assertThat(재성).isEqualTo(석영); //Expected :domain.Car@29647f75 //Actual :domain.Car@355ce81c // -&gt; 서로 다른 객체(메모리주소)를 가져서 deafult equals로는 같다고 할 수 없음. } . 오버라이딩후 equals -&gt; 지정한 값으로 비교 . final Car 재성 = new Car(&quot;차&quot;); final Car 석영 = new Car(&quot;차&quot;); assertThat(재성).isEqualTo(석영); // true . hashCode도 같이 오버라이딩 하는 이유? . hashCode메서드는 실제 메모리 주소 -&gt; 정수값으로 반환해주는 함수이다. 자료구조 등에 사용될 때, 이 hashCode기준으로 같냐/틀리냐를 판단한다. | . | 값 같으면 -&gt; 같은 객체를 만족시켜주기 위해서는 같다의 기준을 바꿔줬었다. 같다의 기준을 메모리 주소 비교 -&gt; 값 비교로 equals 오버라이딩으로 바꿔줘야했지만, | . | 이번엔 자료구조 등이 받아서 읽을해쉬코드 기준을 객체의 메모리주소정수 반환이 아닌 -&gt; 객체(Car)가 가진 값(name)의 메모리 주소 정수 반환로 바꿔준다. cf) 값의 메모리주소 -&gt; 같은 문자열이면 다 같다 | . | . 자료구조들도 같은 객체로 인식 . 쉽게 말해서, 반환되는 hashCode도 값 기준으로 바꿔서, 값 같다 -&gt; 객체의 해쉬코드 같다를 만들어버린다. . 그렇지 않으면, equals는 True로 나올지 몰라도, 자료구조는 다른 객체로 인식하는 상태가 된다. | . @Test void before_overriding_hashcode_test() { final Car 재성 = new Car(&quot;차&quot;); final Car 석영 = new Car(&quot;차&quot;); final HashSet&lt;Car&gt; set = new HashSet&lt;&gt;(); set.add(재성); set.add(석영); assertThat(set.size()).isEqualTo(1); //Expected :1 //Actual :2 // hashCode를 객체기준-&gt;값기준으로 정의해주지 않으면, 자료구조들은 다른 객체로 인식한다. } . hashCode오버라이딩 후 | . @Test void after_overriding_hashcode_test() { //2. final Car 재성 = new Car(&quot;차&quot;); final Car 석영 = new Car(&quot;차&quot;); final HashSet&lt;Car&gt; set = new HashSet&lt;&gt;(); set.add(재성); set.add(석영); assertThat(set.size()).isEqualTo(1); // true } .",
            "url": "blog.chojaeseong.com/java/equals/hashcode/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/%EB%8F%99%EC%9D%BC%EC%84%B1%EA%B3%BC-%EB%8F%99%EB%93%B1%EC%84%B1(%EC%99%84).html",
            "relUrl": "/java/equals/hashcode/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/%EB%8F%99%EC%9D%BC%EC%84%B1%EA%B3%BC-%EB%8F%99%EB%93%B1%EC%84%B1(%EC%99%84).html",
            "date": " • Feb 21, 2022"
        }
        
    
  
    
        ,"post133": {
            "title": "java final 세팅과 사용법",
            "content": "final 키워드로 값의 변경을 막아라 . final 세팅 in IDE, 지역 변수, 메소드 파라미터 . 지역변수, 파라미터 모두 final로 생성되도록 하자 설정 &gt; Editor &gt; Code style &gt; java &gt; Code generation &gt; Make ~ final 체크박스 2개 | . | main 메소드 template 인 psvm의 인자에도 final을 붙혀준다. . 설정 &gt; live template or psvm 검색 &gt; final 붙여주기 | . . | . final 값 -&gt; 재할당을 막아 불변 . 메서드 내부에서 코드 중간에서 가변 변수를 수정할 때, 위에 재할당 등의 수정이 되었었나 확인해야한다. final로 재할당(재사용)이 불가능한 불변 값사용하다가, 변수의 재사용이 필요할 경우 새 변수를 만들어서 쓰자. | . | 모든 지역변수, 인자에 final을 붙이자. . . | final로 값을 초기화(선언후 할당)하는 방법은 2가지다 . //1. final변수 선언과 동시에 &amp;&amp; 할당 -&gt; final은 재할당 불가 -&gt; 변수재사용시 새객체 반환할 것 final int i = 2; i = 4; // java: cannot assign a value to final variable i //2. final변수 먼저 선언 -&gt; 이후 할당 // 생성자 등에서 값을 외부에서 받아와 추가 로직(convert or default 대입 등 특수 case(if) 존재)이후 초기화 final int number; number = 5; . | . final 객체 -&gt; 메서드로 내부 변화 가능 -&gt; 메서드를 항상 새 객체로 응답 . 객체의 경우는 final로는 완벽한 불변을 못만든다. . final 값와 달리 final 객체는 메소드 등에 의해 내부가 변할 수 있다.(포인터의 포인터에서 껍데기 포인터1) | . | 객체를 불변으로 만든 법상태변화를 일으키는 기능들은 새로운 객체를 반환하도록 정의하자. . 상태변화 시켰던 메서드의 void returnType에 해당 객체를 응답(return)하도록 수정 . // 내부변화되는 final 객체 public void move() { this.position++; } // 1. 일단 응답을 동일 객체로 만들어주기 public Car move() { this.position++; } . | 변화된 상태로 new생성자()로 호출하여 -&gt; 새로운 객체를 반환시킨다. . //2. 응답 객체를, 변화된 값으로 새로 만들어서 응답 -&gt; 내부 값은 변화 없다. public Car move() { return new Car(this.position + 1); } //3. 생성자를 통해 응답할 객체를 만들어준다. 내부 값의 변화는 없게 한다. public Car(final int position) { this.position = position; } . | | . final 메서드, 클래스 -&gt; 자식이 못 쓰게 . package domain; final public class FinalParent { final void finalMethod() { final String asdfasdf = &quot;asdfasdf&quot;; } } . package domain; //2. final 클래스는 자식이 상속이 안된다. // java: cannot inherit from final domain.FinalParent public class FinalChild extends FinalParent { //1. final 메소드는 자식이 오버라이딩 못된다. -&gt; 코어 부분에서 변경을 원치 않는 메소드를 명시할 때 사용 //java: cannot find symbol, symbol: class FinalParent @Override protected void finalize() throws Throwable { super.finalize(); } } . final 컬렉션(내부 변경api를 제공하는 껍데기포인터1) 등은 응답시 copy(unmodifiable) 해서 응답하라 . my) 포인터1의 포인터2에 의해 변경될 수 있으니, 껍데기 포인터1 자체를 copy해서 응답해라 | 컬렉션을 반환할 때, 메모리주소가 공유되니, 어디서든 같은 컬렉션이 변경되는 위험이 있다. copy해서 전혀 다른 메모리의 컬렉션으로 응답하자. | . | . List&lt;String&gt; names = List.of(); // unmodifiableList names.add(&quot;텍스트&quot;) // 예외발생 . - 내가 만든 일급컬렉션이라면 불변(내부 변화 기능 제공 않함)이 되겠지만, **일반 컬렉션이라면, 반환시 메모리주소가 공유된다. -&gt; `unmodifiableList`로 copy된 메모리를 반환시켜 테스트 등 변화가 발생하게 하자.** . 컨밴션 중 하나가 된다. . final을 붙이는 것은 컨벤션이며 팀 안에서는 따르는게 좋을 수 도 있다. 내 생각에 타당하지 않으면 얘기를 꺼내서 바꿀 수 있다. | . | 컨벤션이라면, 비효율적이라도 그대로 가는 경우가 많다. 디자인 패턴 역시, 효율적이거나 좋은 코드라서 뿐만 아니라 커뮤니케이션을 줄이는 컨밴션이기 때문에 좋기도 하다. | . | . 참고 글 . 후디 블로그 | .",
            "url": "blog.chojaeseong.com/java/final/%EB%8B%A8%EC%B6%95%ED%82%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/final_%EC%84%B8%ED%8C%85%EA%B3%BC_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/java/final/%EB%8B%A8%EC%B6%95%ED%82%A4/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/final_%EC%84%B8%ED%8C%85%EA%B3%BC_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Feb 21, 2022"
        }
        
    
  
    
        ,"post134": {
            "title": "comparable vs comparator",
            "content": "참고 블로그1 | 참고 블로그2 | . 세팅 . public class Car { private final String name; private int position; public Car(final String name, final int position) { this.name = name; this.position = position; } public String getName() { return name; } public int getPosition() { return position; } } . 기준없이 정렬 . 기준없이 문자열 리스트 정렬 . 문자열은 값이므로 알아서 기준 없이 알아서 정렬된다. . @DisplayName(&quot;정렬기준 없이 문자열 리스트 정렬&quot;) @Test void noStandard_stringList_sort() { final List&lt;String&gt; strings = Arrays.asList(&quot;acd&quot;, &quot;abc&quot;, &quot;dca&quot;); // Collections.sort() 와 .reverse() Collections.sort(strings); System.out.println(strings); // [abc, acd, dca] Collections.reverse(strings); System.out.println(strings); // [dca, acd, abc] } . | String은 이미 내부에서 Comparable을 구현 -&gt; compareTo 오버라이딩 하여 정렬기준을 제시하고 있기 때문 . public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { //... public int compareTo(String anotherString) { byte v1[] = value; byte v2[] = anotherString.value; if (coder() == anotherString.coder()) { return isLatin1() ? StringLatin1.compareTo(v1, v2) : StringUTF16.compareTo(v1, v2); } return isLatin1() ? StringLatin1.compareToUTF16(v1, v2) : StringUTF16.compareToLatin1(v1, v2); } . | . 기준없이 객체 리스트 정렬 . 객체를 넣은 List는 아예 정렬 대상이 안되고 컴파일 에러가 난다. . | 반드시 먼저 정렬기준을 정해줘야한다. . @DisplayName(&quot;정렬기준 없이 객체 리스트 정렬&quot;) @Test void noStandard_carList_sort() { final List&lt;Car&gt; cars = Arrays.asList( new Car(&quot;재성&quot;, 1), new Car(&quot;재경&quot;, 2), new Car(&quot;아라&quot;, 3) ); //2. // no suitable method found for sort(java.util.List&lt;domain.Car&gt;) // method java.util.Collections.&lt;T&gt;sort(java.util.List&lt;T&gt;,java.util.Comparator&lt;? super T&gt;) is not applicable Collections.sort(cars); System.out.println(cars); Collections.reverse(cars); System.out.println(cars); } } . | . 객체에 정렬 기준 주기 . 01 sort()에 안넣어줘도 되는 수동 기준 Comparable . 수동적인 내부 기준인 만큼, 까봐야알고, 수정할려면 다 도메인 내부를 다 바꿔야한다. | . 자기자신 Type의 Comparable을 구현한다. . public class Car implements Comparable&lt;Car&gt; { . | 비교할 원시값Type에 맞게 compareTo를 재정의한다. . int면 Integer.compare( this.xxxx , other.xxxx ) | string이면, 내부 자기가 구현한 this.compareTo(other)를 사용 | . @Override public int compareTo(final Car otherCar) { return this.name.compareTo(otherCar.name); } . | .sort()만 해서 오름/내림차순 확인해보기 . @DisplayName(&quot;comparable -&gt; name 기준으로 객체 리스트 정렬&quot;) @Test void noStandard_carList_sort() { final List&lt;Car&gt; cars = Arrays.asList( new Car(&quot;재성&quot;, 1), new Car(&quot;재경&quot;, 2), new Car(&quot;아라&quot;, 3) ); //3. Collections.sort(cars); System.out.println(cars); // [아라 3, 재경 2, 재성 1] Collections.reverse(cars); System.out.println(cars); // [아라 3, 재경 2, 재성 1] } . | compareTo . 참고 블로그 | . 숫자형 비교 . 기준 값과 비교대상이 동일한 값일 경우 0 . | 기준 값이 비교대상 보다 작은 경우 -1 . | 기준 값이 비교대상 보다 큰 경우 1 . Integer x = 3; Integer y = 4; Double z = 1.0; System.out.println( x.compareTo(y) ); // -1 System.out.println( x.compareTo(3) ); // 0 System.out.println( x.compareTo(2) ); // 1 System.out.println( z.compareTo(2.7) ); // -1 . | . | 숫자형 중 Int의 비교 . compareTo() 대신 Integer.compare(, ) 사용 . int x = 4; int y = 5; Integer.compare(x,y); . | . | 문자열 -&gt; String클래스가 이미 오버라이딩 해놓은 compareTo()이용 . (첫글자 같으면서) 비교대상이 기준에 포함되면 -&gt; 길이의 차이를 return한다. . | (첫글자가 다르면서) 비교대상이 기준에 포함되면 -&gt; 서로 다른 문자열이 시작되는 위치(첫위치)에서 아스키코드 값 차이 . | 포함이 안되는 문자열끼리 비교는 그냥 첫글자의 아스키코드 차이 . String str = &quot;abcd&quot;; // 1) 비교대상에 문자열이 포함되어있을 경우 System.out.println( str.compareTo(&quot;abcd&quot;) ); // 0 (같은 경우는 숫자나 문자나 0을 리턴) System.out.println( str.compareTo(&quot;ab&quot;) ); // 2 System.out.println( str.compareTo(&quot;a&quot;) ); // 3 System.out.println( str.compareTo(&quot;c&quot;) ); // -2 System.out.println( &quot;&quot;.compareTo(str) ); // -4 // 2) 비교대상과 전혀 다른 문자열인 경우 System.out.println( str.compareTo(&quot;zefd&quot;) ); // -25 System.out.println( str.compareTo(&quot;zEFd&quot;) ); // -25 System.out.println( str.compareTo(&quot;ABCD&quot;) ); // 32 . | . | in stream: .집계( ::compareTo) 기준으로 바로 사용 가능 . .집계( 기준이 되어줄 메서드 )로 집계기준으로 바로 사용할 수 있다. | . list.stream() .max(Car::compareTo) .collect(Collectors ... ); . 단점: 정렬기준 변화시 모두 수정 + 까봐야 앎 + 네이밍 . 다른 개발자들이 implements Comparable&lt;Car&gt; 만 보고도어떤 기준으로 정렬될지 모른다. -&gt; 지식으로서 compareTo를 다 까봐야한다. | 그리고 이 기준이 바뀌지 않을 거라 장담할 수 없다. 구현부 compareTo를 하나하나 수정해줘야한다. | 네이밍 수정을 못함. compareTo보다 더 직관적인 네이밍 필요 | . 02 .sort( , ) 2번째 인자에 넣어주는 능동적 기준 Comparator . list.sort()의 첫번째 인자 혹은 Arrays.sort(, )나 Collections.sort(, )의 두번째 파라미터로 comparator를 받는 메소드가 오버로딩 되어있다. 따라서 수동적 기준인 natural ordering 으로 정렬하기 원할 경우, compareTo만 정의해서 기준으로 넣어주면 되고 | 정렬 기준을 동적으로 할당하고 싶을 경우, .sort( , )1~2번째 파라미터로 Comparator를 정의해서 전달하자. | . | . comparator 직접 구현 for 네이밍 . new Comparator롤 작성한 뒤-&gt; &lt;Car&gt;의 클래스만 입력해주고 -&gt; implements메소드 -&gt; compare만 선택한다. . new Comparator&lt;Car&gt;() . | **getter()도.. 들어가서.. 불러와서.. 비교시킨다. ** . 문자열이면, compareTo() String클래스꺼 | 인트면, Integer.compare() | . java new Comparator() { @Override public int compare(final Car o1, final Car o2) { return o1.getName().compareTo(o2.getName()); } }; . | 변수로 받아서 정렬기준 객체의 네이밍을 완성한다. . final Comparator&lt;Car&gt; carNameComparator = new Comparator&lt;&gt;() { @Override public int compare(final Car o1, final Car o2) { return o1.getName().compareTo(o2.getName()); } }; final Comparator&lt;Car&gt; carPositionComparator = new Comparator&lt;&gt;() { @Override public int compare(final Car o1, final Car o2) { return Integer.compare(o1.getPosition(), o2.getPosition()); } }; . | .sort( , )의 2번째 인자에 능동적으로 기준을 넣어준다. . Collections.sort(cars, carNameComparator); System.out.println(cars); // [아라 3, 재경 2, 재성 1] Collections.sort(cars, carPositionComparator); System.out.println(cars); // [재성 1, 재경 2, 아라 3] . | Comparator.api + getter() for 가장편함. . 따로 impl하거나 new 구현할 필요 없이, sort()의 2번째 인자에 바로 넣어준다. | Comparator.comparing() .reversed()를 붙혀 역순 지정가능 | . Collections.sort(cars, Comparator.comparing(Car::getName)); System.out.println(cars); // [아라 3, 재경 2, 재성 1] Collections.sort(cars, Comparator.comparing(Car::getName) .reversed()); System.out.println(cars); // [재성 1, 재경 2, 아라 3] Collections.sort(cars, Comparator.comparing(Car::getPosition)); System.out.println(cars); // [재성 1, 재경 2, 아라 3] Collections.sort(cars, Comparator.comparing(Car::getPosition) .reversed()); System.out.println(cars); // [아라 3, 재경 2, 재성 1] . Comparator.api + getter() in stream . max ( Comparator.comparingInt ( 클래스::getter )) . 정리 . Comparable 보다는 Comparator를 사용하여 정렬 기준만큼은 도메인에서 제외시켜 외부에 위치시켜 변경에 유연하게 만든다. | 외부에서는 comparable -&gt; compareTo -&gt; .sort() 수동적 내부 기준으로 정렬시 밖에서 보면 무엇을 기준으로 정렬되는지 모른다. . | Comparator 는 도메인 클래스에 변경을 가하지 않고도 변경에 유연해진다. | 정렬 기준을 코드 자체로 나타내기 때문에 협업에도 더 좋은 것 같다. | . | .",
            "url": "blog.chojaeseong.com/java/comparable/comparator/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/comparable_vs_comparator(%EC%99%84).html",
            "relUrl": "/java/comparable/comparator/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/21/comparable_vs_comparator(%EC%99%84).html",
            "date": " • Feb 21, 2022"
        }
        
    
  
    
        ,"post135": {
            "title": "git강의(upstream, git객체)",
            "content": "준의 git 강의 . upstream . . 기본적으로 최초push에서는 local -&gt; origin의 연결에 local에 대한 상대적 상류(upstream) 를 -u로 명시해줘야한다. . | -u는 --set-upstream으로 상대적인 상류를 표기한 것이다. . | . | 일반적으로 origin에 대한 origin이 upstream이라고 별칭한다. 미션repo(upstream) -&gt; fork repo(origin) -&gt; clone repo(local) | . | 최초 명시해준 것처럼 upstream은 downstream에 대해 상대적인 것이다. | . | 깃허브 초기 메세지 박스를 보면 -u가 있는데 상대적 상-하 관계를 설정하는 upstream설정을 요약한 단어다 . 없으면 push가 안된다. | 내 local의 remote인 origin이라는 원천이라는 upstream으로 사용한다 보통은 원천(origin)보다 위쪽(stream)은 없다. | 하지만, fork로 가운데origin이 생기면서, 원본 repo를별칭stream을 사용하게 된다. | 우테코의 경우, 미션repo를 fork해해서 origin보다 더 상위단계가 생기므로 upstream | . | . . 여러개의 downstream이 존재함을 안보이더라도 생각해야한다. git clone시((origin &lt;-&gt; local)에는 origin을 알고 있기 때문에 자동으로 stream관계가 설정되어 push할 때 -u를 통한 upstream 설정은 안해도 된다. | . | . | . –help명령어와 git 객체 . 퀴즈1 . O . git help메세지들을 잘 보자. . .git안에 깃 저장소를 초기화 했습니다. | ls -al 숨긴 파일, 폴더 보면 .git이 깃 저장소(로컬 저장소)가 보인다. | . . tree .git/으로 로컬저장소의 구조를 보면 | . | 명령어 도움말은 명령어 + --help를 뒤에 달면된다. . | . | 퀴즈2 . blob은 파일으로 생각하자. . | 답은 5번 . branch는 commit객체에 대한 참조만 가지고 있다. | . . | commit . 커밋 = 작업 디렉토리 스냅샷 = 세이브 포인트 | 돌아가기 위한 포인트.. commit + push만 하지말자 | 돌아가기 위한 정보를 어떻게 담고 있을까 | . . | add시 생성객체, commit시 생성객체를 나누었다. . . add하면, git이 a.txt를 관리대상으로 인식한다. 아까는 없었던, index와 object가 추가 된다. | . | . . commit하면, tree(파일관련), commit(tree를 담고 있는)객체까지 만들어서 2개가 더 만들어진다. | . . | 퀴즈3 . . git은 변경사항만 저장한다? 흔한 오해 -&gt; 파일을 통채로 저장한다! | 엄청 뒤로 갈 때, 변경사항만으로 추적? -&gt; 연산 엄청 많아진다. 그냥 속도측면을 중요시해서 통채로 저장 = 객체로 관리 | 원본 파일마다 tree객체를 가지고 있다. 통채로 저장해놓고, 그것들을 관리하기 위한 커밋이 가진다. 마지막 commit상태의 blob을 본다. | 변경사항을 저장하는게 아니라서.. | . | . | . | . | .",
            "url": "blog.chojaeseong.com/git/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/17/%EC%A4%80)-upstream%EA%B3%BC-git%EA%B0%9D%EC%B2%B4-%EA%B0%95%EC%9D%98(%EC%99%84).html",
            "relUrl": "/git/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/17/%EC%A4%80)-upstream%EA%B3%BC-git%EA%B0%9D%EC%B2%B4-%EA%B0%95%EC%9D%98(%EC%99%84).html",
            "date": " • Feb 17, 2022"
        }
        
    
  
    
        ,"post136": {
            "title": "그림판으로 보는 git협업 미션",
            "content": "git-mission . https://github.com/woowacourse/retrospective/discussions/4 . 미션repo 관리자와 fork하는 페어1과 페어2가 있다. 관리자(upstream) - 페어1,2(origin) - 각 로컬(local) 형태로 구성할 예정 | . | . 관리자는 github에서 repo(git-mission)를 파고, readme.MD를 작성한다. . README.md # 백엔드팀 . . | pair1, pair2가 각각 관리자의 repo( 예정upstream) -&gt; fork(origin) -&gt; clone(local)한 뒤 . main만 있던 repo안에 작업용 각자의 {github_id}로 . | 미션repo(관리자repo)는 main만 일단 유지한다고 가정하며, . | 작업자들은 main fork -&gt; main clone -&gt; local main외 local {본인github_id}를 파서 작업하자. . git checkout -b is2js&lt;github_id&gt; . git branch -a . . 우테코와 같이 특수한 경우(관리자 repo가 main이외에 개별 br를 다 가지고 있는 경우) 작업자들은 학습사이트를 통해 생성된 main + 수많은 {본인github_id} fork -&gt; --single-branch하여 {본인github_id} clone ** -&gt; local {본인github_id} 외에 **step1 을 파서 작업한다. | . | . | . | pair1부터 readme.md를 수정 -&gt; pair2는 대기(파일 수정해도 됨) . 파일수정 . | add + commit . | (clone해왔지만, br바꿨기 때문에) push with origin과의 upstream 최초 설정 . git push --set-upstream origin is2js&lt;github_id&gt; . . | . | pair1은 [fork repo]의 main외 작업br{github_id} -&gt; [원본repo] main에 PR을 날릴 수 있다. . 보통 fork -&gt; clone -&gt; 작업br 파기 -&gt;(origin입장에서 new br인)작업br push -&gt; fork 작업br to 원본 main br로 PR in github | . | 관리자의 merge in github . | pair2가 conflict를 내기 위해 관리자 최신main from pair1 or pair1 최신을 가져오지 않고 . pair1이 작업끝내기 전에 같은 파일에 작업시작 | . . | pair2의 무지성 PR -&gt; conflict를 github가 알려준다. . 공통 작업자가 있다면, 같은 파일 수정 가능성이 있다면, PR전에 pair나 upstream의 pull부터 해야함. | github에서 PR을 만드려고 하면 conflict를 알려준다. | . | **pair2는 최신소스가 업데이트된 원본repo를 받아오기 위해 local &lt;-&gt; 원본repo upstream으로 등록하고, 받아와야한다. ** . pair1을 pair로 등록하고 받아와도 될 것 같은데, 중심은 원본repo에서 받아온다. . | 중간 다리인 fork는 주고/받을 때 별 영향이 없다. local과 원본repo가 연결되어야 최신소스를 받으니, upstream라는 별칭으로 원격저장소를 추가하여 연결한다. . . git remote -v # fork -&gt; clone으로 형성된 origin = fork레포만 연결되어있다. git remote add upstream&lt;원본레포 별칭&gt; &lt;원본레포 URL&gt; git remote -v git fetch upstream # fetch는 커밋내역만 가져오는데 [원격저장소별칭]만으로 가져올 수 있다. # 가져올 br이 있는지 확인한다. git branch -a git merge upstream/main # 가져올 [원격저장소별칭/br] 형태로 merge를 요청한다. . | . | 가져와서 conflict를 (vscode 등에서) 해결하고, 다시 fork(origin)으로 push -&gt; github에서 PR을 날리면 된다. . git push origin is2js{github_id} . . | 우테코의 코드리뷰는 더 복잡하다. . 원본repo의 관리자 -&gt; 리뷰어들이 merge를 담당한다 . | fork전, 우테코 학습사이트를 통해 원본repo에 main외 내 {github_id}로 하면서 PR의 최종merge가 각자의 {github_id}로 되도록 먼저 생성한다. . | fork하면, main + 모든 리뷰이들의 {github_id}들이 있다. -&gt; 내 {gihub_id}의 br만 로컬로 clone해와야한다. . git clone -b is2js&lt;내github_id&gt; --single-branch https://github.com/is2js/java- racingcar.git&lt;url&gt; . | clone후, 내입장에서의 main branch인 {github_id}에서 작업용=리뷰어br인 step1부터 파서 시작한다. . | 만약, 페어가 있다면 한 곳의 step1을 선택한 다음, 작업이 끝나면 찢어진 뒤 . pair라는 별칭으로 git remote add pair &lt;URL&gt;을 하고 | fetch -&gt; merge하여 작업된 pair의 코드를 가져온 뒤, 작업을 시작한다. | . | . . |",
            "url": "blog.chojaeseong.com/git/%ED%98%91%EC%97%85/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/17/git_%EA%B7%B8%EB%A6%BC%ED%8C%90%EC%9C%BC%EB%A1%9C_%EB%B3%B4%EB%8A%94_%ED%98%91%EC%97%85%EB%AF%B8%EC%85%98(%EC%99%84).html",
            "relUrl": "/git/%ED%98%91%EC%97%85/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/17/git_%EA%B7%B8%EB%A6%BC%ED%8C%90%EC%9C%BC%EB%A1%9C_%EB%B3%B4%EB%8A%94_%ED%98%91%EC%97%85%EB%AF%B8%EC%85%98(%EC%99%84).html",
            "date": " • Feb 17, 2022"
        }
        
    
  
    
        ,"post137": {
            "title": "코드리뷰 방법 2단계(step1 PR merge이후)",
            "content": "그 전 1단계 마무리 . local의 step1 브랜치에서 local commit만 한다. | 각종 검토후 push한 뒤, 최초PR을 날린다. (local step1 —&gt;) forkrepo step1 -&gt; 원본repo is2js | . | 최초PR이후, local commit만하다가, 2번쨰 push부터는 피드백 반영된다. | 리뷰어는 PR을 merge . **리뷰어는 ** . Push하여 피드백 반영된 fork-step1 —&gt; 원본-is2js의 PR을 merge시키는 권한이 있다. . 피드백 최종반영 fork step1 to 원본 is2js PR후 N번 피드백push . | 리뷰어의 PR을 merge . . | . | . | . 1단계완성br {github_id} -&gt; local 반영 . 참고문서: 코드리뷰 3단계 | . local 먼저 {github_id} checkout . . local branch를 일단 is2js{github_id}로 넘어온다. . . git checkout is2js&lt;github_id&gt; . | . 원본repo와 동기화 . 원본repo를 별칭upstream으로 remote add . . 현재 local에 달린 git remote 확인하기 . origin: fork레포 | (B라면, pair: A의 repo) | . git remote -v . 결과 . origin https://github.com/is2js/java-racingcar.git (fetch) origin https://github.com/is2js/java-racingcar.git (push) pair https://github.com/Wishoon/java-racingcar.git (fetch) pair https://github.com/Wishoon/java-racingcar.git (push) . | . | 원본(미션)repo를 upstream이라는 별칭으로 원격저장소 등록해주기 . git remote add upstream&lt;별칭&gt; https://github.com/woowacourse/java-racingcar.git&lt;원본(미션)repo&gt; . git remote add upstream https://github.com/woowacourse/java-racingcar.git . 결과 . git remote add upstream https://github.com/woowacourse/java-racingcar.git git remote -v origin https://github.com/is2js/java-racingcar.git (fetch) origin https://github.com/is2js/java-racingcar.git (push) pair https://github.com/Wishoon/java-racingcar.git (fetch) pair https://github.com/Wishoon/java-racingcar.git (push) upstream https://github.com/woowacourse/java-racingcar.git (fetch) upstream https://github.com/woowacourse/java-racingcar.git (push) . | . | . fetch로 원본repo상 merge된 내 br {github_id} -&gt; {remotes/별칭/내br}으로 가져오기 . . fetch로 원본repo상에 리뷰어에 의해 merge된 is2js를 -&gt; local is2js로 가져오기 . git fetch upstream&lt;별칭&gt; is2js&lt;가져올br명&gt; . 결과 . git fetch upstream is2js remote: Enumerating objects: 1, done. remote: Counting objects: 100% (1/1), done. remote: Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (1/1), 2.22 KiB | 759.00 KiB/s, done. From https://github.com/woowacourse/java-racingcar * branch is2js -&gt; FETCH_HEAD * [new branch] is2js -&gt; upstream/is2js . | . | git branch -a를 확인해보면 remotes/별칭/{merge된 내br=github_id}로 생성되었다. . git branch -a . 결과 . . | . | . rebase(1줄 이어붙merge)로 {fetch한 원격br}을 -&gt; {로컬br}과 동기화 . . 원격br -&gt; 로컬br에 끊어진 이후부터 &lt;merge와 달리 1줄&gt;로 이어붙이는 작업인 것 같다. . git rebase upstream/is2js . 결과: fetch한 remotes/upstream/is2js랑 local의 is2js랑 완전히 동일해졌다. . . | 참고로 rebase는 커밋 n개 합치기용(-i) or merge를 깨끗하게( . merge와 비교 장점: 커밋해쉬 유지 및 흐름 유지되어 돌아갈 수 있음 | 단점: merge라는 불필요커밋을 생성함. | . | rebase 장점: 주는놈위에 받는놈위주로 정리가 됨. 깨끗한 커밋 히스토리가 됨. | . | . | . | . 2단계 br 생성하기 . step2 br 생성과 동시에 checkout . 최신화(fetch -&gt; rebase)된 is2js{github_id}에서 받아와 생성되도록 한다. . git checkout -b step2 . | . 이후 step2에 작업후 add/commit/push-&gt;PR-&gt;push반복-&gt;merge . 나는 step1에 작업하던 것이 남아서 step2에서 merge받았다. . . | . step1 삭제 . 1단계 br은 이제 삭제한다. . git branch -d step1 . | .",
            "url": "blog.chojaeseong.com/git/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%ED%98%91%EC%97%85/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/16/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-2%EB%8B%A8%EA%B3%84(%EC%99%84).html",
            "relUrl": "/git/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%ED%98%91%EC%97%85/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/16/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-2%EB%8B%A8%EA%B3%84(%EC%99%84).html",
            "date": " • Feb 16, 2022"
        }
        
    
  
    
        ,"post138": {
            "title": "생성자와 일급컬렉션(사용이유, 테스트)",
            "content": "생성자 규칙 . 나만의 규칙 . 생성 루트가 여러개 ex&gt; List&lt;String&gt; or List&lt;Car&gt;인 일급컬렉션 private 필요속성(만) 받는 기본생성자 | public fromStrings( List&lt; String &gt; ) inputView에서 검증을 하고 오므로 검증없이 -&gt; List&lt;객체&gt;로 변환 -&gt; 생성자 | . | public from객체(List&lt; 객체 &gt;) test등에서 단일객체 -&gt; List add되어 들어오는데, 복수 검증(중복)을 추가후 -&gt; 생성자 | . | | VO, 단일객체라도 숫자형이라면 -&gt; inputView에서 형변환후, 해당형으로 검증되도록 inputView에서 따로 검증안한다면, public 생성자에서 검증까지 다 처리하면 될 듯함. inputView에서는 VO는 형변환하고나서 -&gt; 검증하자. | . | inputView 검증해야하는 상황이라면? -&gt; 형변환후 int만 검증 public 기본생성자(원본 타입) with 노검증(for inputView거친 뒤 controller or 숫자VO 연산) | public fromNumber(원본타입) with 검증(for 테스트 or int직접생성) | | | . 일급컬렉션 생성자와 사용이유 . 생성자 2+1개 . fromXXXX: InputView에서 검증된 List&lt; String &gt;를 받는 public 정적팩토리메서드 . InputView.getXXX() 에서 검증 후 들어오는 ** -&gt; **List&lt; String &gt;으로 들어올 것이기 때문에 .fromStrings( )형식으로 작성한다. . String List -&gt; 단일객체 List로 변환되어 -&gt; 기본 생성자를 부른다. | . public static Cars fromNames(List&lt;String&gt; values) { //input에서 검증하고 와서, 변환만 List&lt;Car&gt; cars = values.stream() .map(value -&gt; Car.from(value)) .collect(Collectors.toList()); return new Cars(cars); } . | . from: 테스트 등에서 List&lt; 단일객체 &gt;를 받는 public 정적팩토리메서드 . 기본생성자는 private하게 유지하기 위해, 테스트용 public 기본 생성자 from ( List&lt; 단일객체 &gt;로 생각하자. . 따로 개별 검증은 필요 없고(단일객체 생성시 이미 검증) -&gt; 중복검사 등만 필요 | . public static Cars from(List&lt;Car&gt; cars) { //중복 검증 등 return new Cars(cars); } . | . 기본생성자: private + List&lt; 단일객체 &gt; . inputView 검증-&gt; fromStrings . | test -&gt; from -&gt; 복수검증 . | 기본생성자는 일단 검증 없이 생성만 하는 역할을 하게 한다. . private Cars(List&lt;Car&gt; cars) { this.cars = cars; } . | . 쓰는 이유 4가지 . 참고 블로그 | . 01 검증 통과해야만 생성 가능한 자료구조(비지니스 종속 자료구조) . 흩어져있는 검증 기능들을 외울 수 없다. 신입사원이 와도 바로 작동하도록 하는 객체를 만들어야한다. . | 해당, util등에서 처리할게 아니라 검증 만족시 생성가능한 자료구조를 만들어 신입사원도 쓸 수 있게 해야한다. . public static Cars from(List&lt;Car&gt; cars) { Validator.validateCarsName(getCarNames(cars)); return new Cars(cars); } . | . 02 setter/add 등이 없는 불변구조 . List는 add, map은 put 등의 메서드를 제공하는데 . 일급컬렉션으로 감싸서 생성자와 getter류 기능만 제공하도록하고 setter 등을 제공하지 않음녀 불변구조가 된다. . | 자료구조에 final을 붙혀도 해당 context에서 재할당만 불가 -&gt; add, put 등은 가능함. . cf) 일급컬렉션에 변수는 1개이며, final이 붙어서 최초생성이후 변경할 수 없게 한다. | . private final List&lt;Car&gt; cars; . | . | . 03 상태(변수)와 행위(기능)을 자료구조와 함께 한 class에 다 모으기(냉무) . 05 이름을 가지는 자료구조가 됨.(냉무) . 일급컬렉션 테스트 . 단일객체 -&gt; 일급컬렉션 순서대로 생성 . 단일객체 -&gt; 일급컬렉션 순서대로 생성하도록 전역변수 -&gt; @BeforeEach에서 List&lt; Car &gt;를 받으면서 중복 등 다수검증하는 from으로 생성한다. | 단일 객체생성은 여기서는 다루지 않지만, 검증이 들어간 로직으로 해야할 듯. | . | . //1. 일급컬렉 Test: @BeforeEach에서 단일객체 개별생성 후(그래야 개별조작 가능 -&gt; 반영) List에 담아놓기 Car 코니; Car 재성; Cars cars; @BeforeEach void setUp() { 코니 = new Car(&quot;코니&quot;); 재성 = new Car(&quot;재성&quot;); cars = Cars.from(Arrays.asList(코니, 재성)); } . given자리에 단일객체 조작을! when에서는 일급컬렉 기능을! . given자리에 일급컬렉션과 공유된 개별 객체들을 조작후 -&gt; 테스트한다. . @Test void getMaxposition_method_test() { //given -&gt; 단일객체를 조작 코니.move(() -&gt; true); 재성.move(() -&gt; false); //when Car actualMaxPositionCar = getMaxPositionCar2(); //then assertThat(actualMaxPositionCar).isEqualTo(코니); } // private하며 메서드 내부의 메서드 -&gt; 복사하고, 인자를 바꿔주자. private Car getMaxPositionCar2() { Car maxPositionCar = Arrays.asList(코니, 재성).stream() .max(Car::compareTo) .orElseThrow(() -&gt; new IllegalArgumentException()); return maxPositionCar; } . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%ED%85%8C%EC%8A%A4%ED%8A%B8/%EC%83%9D%EC%84%B1%EC%9E%90/2022/02/15/%EC%83%9D%EC%84%B1%EC%9E%90_%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98_%EC%82%AC%EC%9A%A9%EC%9D%B4%EC%9C%A0_%ED%85%8C%EC%8A%A4%ED%8A%B8(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98/%ED%85%8C%EC%8A%A4%ED%8A%B8/%EC%83%9D%EC%84%B1%EC%9E%90/2022/02/15/%EC%83%9D%EC%84%B1%EC%9E%90_%EC%9D%BC%EA%B8%89%EC%BB%AC%EB%A0%89%EC%85%98_%EC%82%AC%EC%9A%A9%EC%9D%B4%EC%9C%A0_%ED%85%8C%EC%8A%A4%ED%8A%B8(%EC%99%84).html",
            "date": " • Feb 15, 2022"
        }
        
    
  
    
        ,"post139": {
            "title": "commit.template과 message양식",
            "content": "commit.template 활용하기 . template(.gitmessage.txt) 생성 . 이미 지정된 commit.template의 터미널에서 확인 . 없으면 원하는 경로에서 .gitmessage.txt를 생성하면 됨. | . git config --global commit.template . C: Users cho_desktop .gitmessage.txt에 지정 해놨었다. . cf) 적용 코드 . git config --global commit.template C: Users cho_desktop .gitmessage.txt . | . | . | 해당 경로(윈도우의 경우, 풀 경로)로 가서 커밋.템플릿을 생성/수정한다. . .gitmessage.txt . #commit전: inspect code.../F8/함수 순서/public test만/depth/필요개행/불필요개행/매직넘버/Test #fix | feat | build | chore | ci | docs | style | refactor | perf | test: ##### Subject 50 characters ## don&#39;t finish with . ##-&gt;| ######## 본문은 한 줄에 최대 72 글자까지만 입력 ########################### -&gt; | # 제목에서 한줄 띄고, 여러줄운 &quot;- 내용1 - 내용2&quot; , &quot;무엇을&quot; &quot;왜&quot; 기술 &gt;&gt; &quot;어떻게&quot; 72자 제한 ################################ # 꼬릿말은 아래에 작성: ex) #이슈 번호 # COMMIT END # &lt;타입&gt; 리스트 # feat : 기능 (새로운 기능) # fix : 버그 (버그 수정) # refactor: 리팩토링 # style : 스타일 (코드 형식, 세미콜론 추가: 비즈니스 로직에 변경 없음) # docs : 문서 (문서 추가, 수정, 삭제) # test : 테스트 (테스트 코드 추가, 수정, 삭제: 비즈니스 로직에 변경 없음) # chore : 기타 변경사항 (빌드 스크립트 수정 등) # # 제목 첫 글자 -&gt; 대문자 # 제목 명령문 # 제목 끝에 마침표(.) 금지 # 제목과 본문을 한 줄 띄워 분리하기 # 본문은 &quot;어떻게&quot; 보다 &quot;무엇을&quot;, &quot;왜&quot;를 설명한다. # 본문에 여러줄의 메시지를 작성할 땐 &quot;-&quot;로 구분 # . | . | . 생성 템플릿 적용하기 . global 설정 . 명령어를 통해 지정 . git config --global commit.template C: Users cho_desktop .gitmessage.txt . | .gitconfig의 [commit]블럭안에 template을 직접 수정 . [commit] template = C: Users cho_desktop .gitmessage.txt . | repository별 설정 . ~/.gitconfig를 사용하는 대신 해당 repository안에 있는 .git/config에 위에서 설명한 [commit]블락을 추가 . [commit] template = C: Users cho_desktop .gitmessage.txt . | .",
            "url": "blog.chojaeseong.com/git/%ED%98%91%EC%97%85/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/2022/02/15/commit.template%EA%B3%BC-%EC%96%91%EC%8B%9D-%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/git/%ED%98%91%EC%97%85/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/2022/02/15/commit.template%EA%B3%BC-%EC%96%91%EC%8B%9D-%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Feb 15, 2022"
        }
        
    
  
    
        ,"post140": {
            "title": "pycharm 세팅 및 단축키",
            "content": "세팅 . 일반적인 것은 intellij에서 가져온다. | . 시작시 최근 프로젝트 reopen 해제 . settings &gt; appearance &amp; behavior &gt; system settings &gt; [ ] reopen projects on startup 체크해제 | . powershell 권한 문제 해결 . settings &gt; tool &gt; terminal에 가서 기본 powershel(=window powershell)을 직접 설치한 7버전이상의 powershell로 변경한다 | 아래 참고블로그를 바탕으로 remote에 실행정책에서 권한확인을 삭제한다. 코딩도장 | 벨로그 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine . 플러그인 . | . | Vscode Keymap 설치 및 intellij 설정 가져오기 . intellij F1&gt; export settings | vscode keymap 플러그인 설치 | pycharm F1&gt; import settings | Pylint 설치 . plugin에서 검색하여 설치 | View &gt; Tool Windows &gt; pylint 체크 | Black 설치 . 로컬python에 black설치 -&gt; external tools에 추가 . pylint와 같은 위치에 설치되어있을 것이니 pylint의 경로부터 살펴본다. . local python은 %homepath% anaconda3 Scripts 폴더에 깔려있다. . . | . | black을 anaconda3로 설치하고 경로를 확인한다. . conda install black . powerShell에서는 which(linux) / where(cmd) 대신 Get-command [프로그램명]로 바로 검색할 수 있다. . . 혹은 약자인 gcm [프로그래명]으로 찾을 수 있다. | . . | . . C: Users cho_desktop anaconda3 Scripts black.exe | . | settings &gt; Tools &gt; External tools에 black 추가하기 . Program: C: Users cho_desktop anaconda3 Scripts black.exe . | Arguments: $FilePath$ | Working directory: $ProjectFileDir$ | 파이참 Tools &gt; External tools &gt; Black으로 포맷팅 확인해보기 문자열 싱글 따옴표 -&gt; 더블 따옴표로 바뀌는지 확인 | . | . . | File Watchers에 Black 추가하여 실시간 반영 . settings &gt; tools &gt; File Watchers . | + &gt; custom &gt; . Name: Black | File type: python | Score(deafult): Project Files | Program: black 경로 | Arguments: $FilePath$ | Output path to : $FilePath$ | Working directory: $ProjectFileDir$ | Advanced Options에서 auto-save edited files to trigger the watcher 체크 확인 | . | External Tool로 등록한 Black의 단축키로 반영 . keymap &gt; external tool검색 &gt; black 확인하여 단축키 설정 | ctrl + shift + alt + B(assign) 참고 | . | . live template 외 . repr(객체 print시 출력되는)를 항상 재정의해야하는데, return될 템플릿을 repr로 지정해놓는다. f&quot;{self.__class__.__name__}({self.$FILED_NAME$!r}, $END$)&quot; . | . 단축키 . move statement: 메서드 이동 단축키 지정 Move staetment Down : alt + shift + PgUp | Move staetment Up: alt +shift + PgUp | . | alt + shift + o: optimize import 리포맷팅 해도 import는 정렬안해주는데, 해당 기능을 이용해야한다. | . | (드래그 후)ctrl + alt + F8(assign) : Evaluate Expression 기존 quick evluate expression을 삭제하고 배정한다. | 디버깅시 의심Line F9 -&gt; 디버깅 -&gt; 수정해볼 부분만 드래그후 Evaluate Pression (Ctrl + Alt + F8)** ctrl + shift + enter를 치면 아래 watcher부분에 기록을 남긴다. | . | . | ctrl + shift + alt + B(assign): black 포맷터 실행 . | 생성자 및 필드 추가 과정 client에서 해당 객체로 필드들 노란줄 작성하고 | action으로 add field를 해주어, None상태로 바로 enter쳐서 확정짓는다. 파라미터 추출시 default value의 변수명이 자동으로 바뀌기 때문에 다음에 바꿔줄 것 | . | None들을 하나하나 ctrl + alt + p로 파라미터 추출한 뒤 | None을 삭제후 alt + /를 직전단어를 추출해서, 필드명과 파라미터명을 맞춘다. | 모든 필드의 값들을 파라미터 추출하고 난 뒤,ctrl + F6으로 enter + tab + space를 활용해서 default값 사용을 체크해제 시킨다. | | _필드와 property 추가 과정 client에서 해당 객체로 필드들 _필드명으로 작성하고 | action add field 부터 필드 추가과정을 따른다. | 다시 client코드의 _필드에 &gt; add property를 사용해서 property코드도 추가한다. | | .setter 추가 과정 property가 정의된 상태에서 client에서 객체.property = &quot;값&quot;을 할당하여 작성해야만 action에 create propery가 추가로 생기며 누르면 .setter가 자동 정의 된다. | | ctrl + shift + del: unwrap(if/while 등) or remove if/while의 내부영역만 남기고, 바깥의 if/while을 제거해준다. | . | .",
            "url": "blog.chojaeseong.com/pycharm/settings/shortcut/2022/02/13/pycharrm_settings_shortcut.html",
            "relUrl": "/pycharm/settings/shortcut/2022/02/13/pycharrm_settings_shortcut.html",
            "date": " • Feb 13, 2022"
        }
        
    
  
    
        ,"post141": {
            "title": "intellij 협업 세팅",
            "content": "인텔리제이 세팅 . buildType &amp; assertj라이브러리 . build Type: gradle -&gt; intellij . gradle검색후 build and run intellij로 바꿔주기 빌드 속도 및 TestName표기 | . | new projects에서 세팅 안됨 | . build.gradle 라이브러리에 assertj 추가 및 refresh . build.gradle의 dependency에 assertj 라이브러리 넣어주고 refresh 하기 . // Assertions testImplementation &#39;org.assertj:assertj-core:3.22.0&#39; testImplementation &#39;org.junit.jupiter:junit-jupiter-params:5.4.2&#39; // lombok compileOnly &#39;org.projectlombok:lombok&#39; annotationProcessor &#39;org.projectlombok:lombok&#39; . | Ctrl+Shift+O 또는 우측상단에 떠있을 코끼리버튼을 클릭해줘야 반영이 된다. . 단축키는 keymap에서 덮어써줘야 작동됨. | . | . gradle 정상 test . . shift 2번 or f1 -&gt; gradle task선택 gradle clean 수행 | gradle test 수행 | | [Test 설정] live template에 assert문 추가해놓기 . @Test 대신 @ParameterizedTest for 여러case 를 쓰기 위해서 아래 의존성을 추가해야한다. // Assertions testImplementation &#39;org.assertj:assertj-core:3.22.0&#39; testImplementation &#39;org.junit.jupiter:junit-jupiter-params:5.4.2&#39; . | as+all assertAll( () -&gt; assertThat(actual).isEqualTo(expected$END$), () -&gt; assertThat(actual).hasSize() ); . | as+that Assertions.assertThat(actaul).isEqualTo(expected$END$); . | as+notthr Assertions.assertDoesNotThrow(() -&gt; $WHEN$) . | as+thr Assertions.assertThatThrownBy(() -&gt; $WHEN$) .isInstanceOf($EXCEPTION$.class) .hasMessage(&quot;$MESSAGE$&quot;); . | given : option에 있는 reformat ~ style 체크할 것 //given //when $END$ //then . | methodSource: option에 있는 reformat ~ style 체크할 것 return Stream.of( Arguments.of($END$), Arguments.of() ); . | dynamicTest: @DisplayName(&quot;큰테스트이름&quot;) @TestFactory Stream&lt;DynamicTest&gt; collectionsOfDynamicTest() { return Stream.of( dynamicTest(&quot;테스트케이스1&quot;, () -&gt; { // given // when $END$ // then assertThat(actual).isEqualTo(expected); }), dynamicTest(&quot;테스트케이스2&quot;, () -&gt; { // given // when // then assertThat(actual).isEqualTo(expected); }) ); } . 루틴 설정(1회성으로 보임) . | . ends with a line break . Editor &gt; General &gt; on Save 탭 &gt; ends with a line break에서 해당 박스를 체크한다. | . ​ . Code style(우테코) . 우테코javastyleXML, naverConventionXML 다운로드 프로젝트폴더 최상단에 넣어준다. | . | Editor &gt; code style &gt; Scheme &gt; 톱니바퀴 &gt; Import Scheme &gt; Intellij IDEA XML intellij-java-wooteco-style.xml 선택해주기 | . | SQL warning 워닝 제거 . 참고 사이트 | . Warning 검출 끄기 DAO 등의 sql 작성문으로 가서 ctrl + . &gt; Uninject language or reference 를 선택한다. | . | 프로젝트 SQL dialect 설정하기 for 자동완성 by 해당SQL로 인식후 문법 자동완성 Settings - Languages &amp; Frameworks - SQL Dialects or shift 2번(F1) &gt; sql dialects 선택 | Global 말고 Project SQL dialect를 테스트용 H2로 선택 | | schema.sql에서 H2를 DataSource로 지정하여 session에서 테이블들 생성 for String sql속 table 및 칼럼 인식후 자동완성 의존성에 h2추가 확인하기 runtimeOnly &#39;com.h2database:h2&#39; . | application.yml에서 h2 인메모리(mem) url(url: jbdc:h2:mem:maindb)으로 지정 / username 등 설정 확인 후 `펼쳐놓기 . | scheme.sql파일에서 configure data source 클릭 or shift 2번(F1)에서 data source검색하여 Data source... 선택 . Data source from url에 application.yml의 url을 복붙해서 설정도 가능하다고 한다. | . | h2를 추가하고, 기본 remote로 지정된 option을 내장형(In-memory)로 변경하고, username(sa), database(maindb) 등 입력해준다. . | schema.sql로 와서 실행버튼 &gt; 생성한 data source DB설정 &gt; schema.sql 선택후 실행시켜 data source에 session으로 메모리 테이블 실제 생성시켜준다. . | 이제 dao등에서 table을 인식하여 칼럼까지 자동완성할 수 있다. . | 연결이 끊기면 schema.sql -&gt; ctrl+shift+F10(run) -&gt; target data source 설정해서 연결해주면 된다. | | 시작시 최근 프로젝트 reopen 해제 . settings &gt; appearance &amp; behavior &gt; system settings &gt; [ ] reopen projects on startup 체크해제 | . 1회성 설정 . New Project setup . File &gt; New Projects Setup &gt; Settings for New projects&gt; . . | . Save Actions (개행+imort최적화) . Plugins &gt; market &gt; save actions를 검색해서 설치한다. . import최적화(삭제) + 리포맷팅 자동 . | . file Encoding . 3가지 전부 UTF-8확인 | . tab (4space) . **Editor &gt; Code style &gt; java &gt; tabs and indents &gt; ** [ ] Use tab character 체크해제 | Continuation indent 8-&gt;4 | . | OS마다 tab의 크기가 다르므로 space를 사용하게 tab사용 체크해제하는 것 | . File and Code Templates &gt; method body template . 베루스 추천 . | settings &gt; File and Code Templates &gt; code 탭에서 . implemented + new Overriden Method Body부분에 | . ##if ( $RETURN_TYPE != &quot;void&quot; )return $DEFAULT_RETURN_VALUE;#end throw new UnsupportedOperationException(&quot;${SIMPLE_CLASS_NAME}#${METHOD_NAME} not implemented.&quot;); throw new UnsupportedOperationException(&quot;${SIMPLE_CLASS_NAME}#${METHOD_NAME} not write.&quot;); . ## 오버라이딩은 그냥 쓴다. 부모의 것 상속 받을 때인데, super() 등 메서드 그대로 호출시켜줘야함. ##throw new UnsupportedOperationException(&quot;${SIMPLE_CLASS_NAME}#${METHOD_NAME} not override.&quot;); . Auto Import . | Editor &gt; general &gt; auto import 검색 후 . Always -&gt; Ask로 변경(복붙후 library 선택) | Add unambiguous import on the fly 체크 . | Optimize imports on the fly (for current project) 체크 . . | . | . parameter name hints . Editor &gt; general &gt; code completoin 검색 후 &gt; Parameter Info 탭 &gt; [x] show parameter name hints on completion 체크 | . usages 표기 . preferences - editor - inlay hints - java - code vision usages 2가지체크 | . | . go to test . keymap &gt; go to test 검색 후 단축키 지정 : ctrl+shift+ T -&gt; 나머지 remove 테스트 없으면 생성, 있으면 이동 시켜주게 된다. | . | . lombok 라이브러리 이후 @anno적용 안될 때 . lombok 라이브러리를 추가한 후 Settings &gt; Build &gt; Compiler &gt; Annotation Processors 에서 [x] Enable annotation processing 을 체크해야 롬복을 사용할 수 있다.(안될 경우) | . | . final 및 private . method의 파라미터 앞에 final . Editor &gt; Code style &gt; java &gt; Code generation &gt; [x] make ~ final 체크박스 2개 | . 변수 추출시 final (최초 1회) . 추출할 때, ctrl + alt + v를 **2번 눌러서, ** Declare final체크 | . | . (private) 상수를 private로 추출(최초 1회) . 추출할 때, ctrl + alt + c를 **2번 눌러서, ** public -&gt; private로 옮겨놓기 | . | . [TEST 설정] Test Method template 수정하기 . Editor &gt; file and code templates 검색 &gt; Code탭 &gt; JUnit Test Method에 아래 코드 추가 . @org.junit.jupiter.api.DisplayName(&quot;&quot;) 2번 한글메서드로 작성하기 위해 주석처리로 추가됨. | . | . . | Editor &gt; file and code templates 검색 &gt; Code탭 &gt; JUnit Test Class에서 class위에 아래 코드 추가 . @SuppressWarnings(&quot;NonAsciiCharacters&quot;) | @DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class) | . | 파라미터 힌트 항상 보이게 하기 . settings &gt; Parameter hint검색 &gt; Editor &gt; Inlay Hints &gt; Java &gt; Parameter hints &gt; Paramters with names ~ 체크 | . | . keymap 추출하고 사용하기 . F1(search everywhere)에서 export settings를 검색한다 . | Select None을 한번 누르고 keymaps(schemes)만 선택 한 뒤, 저장경로에서 settings.zip에 날짜기입까지 해주고 OK로 export한다. . 사용시에는 반대로 F1 &gt; import settings를 검색한 뒤, zip을 선택만 해주면 된다. . | 까보면, plugins까지 다 포함되어있다. . | . . | Font . editor &gt; font &gt; jetbrain Mono -&gt; fira code + ligature 허용 | . 한글 워닝 제거 . Editor &gt; inspections &gt; non-ascii검색 &gt; 체크해제 | . . 페어 컨벤션(링크) . 구글 스프레트 시트 링크로 매번 업데이트 된 것 활용하기 | . .editorConfig for windows에서도 LF로 저장 . 다양한 에디터들에게 공통적인 코드컨벤션을 적용시킨다. 적용시 windows에서도 LF로 저장되게 한다. | . | 루트에서 NEW &gt; EditorConfig 검색후 생성한다. . | 아래 내용을 복붙한다. . # top-most EditorConfig file root = true [*] # [encoding-utf8] charset = utf-8 # [newline-lf] end_of_line = lf # [newline-eof] insert_final_newline = true [*.bat] end_of_line = crlf [*.java] # [indentation-tab] indent_style = tab # [4-spaces-tab] indent_size = 4 tab_width = 4 # [no-trailing-spaces] trim_trailing_whitespace = true [line-length-120] max_line_length = 120 . | . checkstyle . 일단 LF로 push하기 위한 git 전역설정이 되어있어야한다. . 윈도우에서는 git commit시 CRLF로 새줄을 저장하지만, 위 설정을 통해 push시에는 LF로 올라가게 한다. . Git은 커밋할 때 자동으로 CRLF를 LF로 변환해주고 | windows로 clone하면 다시 LF가 CRLF가 됨 | . git config --global core.autocrlf true . | . | 없다면 플러그인 Plugins 에서 CheckStyle-IDEA검색 후부터 설치한다. . CheckStyle-IDEA 설치 | 프로젝트 최상단에 naver-checkstyle-rules.xml를 위치시키고 | Tools &gt; Checkstyle에서 버전을 8.24 이상으로, | Scan Scope를 All sources(including tests)로 맞추고 - 테스트 한글함수를 위해서 tests 포함안해도 될 듯? | +를 눌러, 위에서 편집해준 naver-checkstyle-rule를 추가해준다. | naver-checkstyle-rule을 선택해준다. | . | . | 네이버핵데이 컨벤션 및 CheckStyle 적용하기 . 요약 . Settings &gt; Editor &gt; Code style &gt; Java &gt; Scheme &gt; 톱니바퀴 &gt; import Scheme &gt; (ideaProject폴더에 다운받아놓은 )InteliJ ~ .xml 파일 찾아 적용 cf) code style&gt; java에서 use tab character를 풀어야 4스페이스가 된다. Tab 사용하도록 체크하자. | | 파일을 저장 할 때마다 포멧터 자동 적용설정 by Save Actions plugin을 활용하면 파일을 저장하는 순간 포멧터를 자동 적용할 수 있다. File &gt; Settings ( Ctrl + Alt + S ) &gt; Plugins 메뉴로 이동 | Marketplace 탭에서 ‘Save Actions’ 로 검색 | Save Actions&#39; plugin의 상세 설명 화면에서 [Install]` 버튼 클릭 | IntelliJ를 재시작 | File &gt; Settings &gt; Other Settions &gt; Save Actions 메뉴로 이동 | 아래 항목을 체크 Activate save actions on save | Optimize imoprts | Refomat file | . | | 플러그인 CheckStyle-IDEA 플러그인을 검색 후 설치 Tools &gt; CheckStyle에서 Checkstyle version을 8.24 이상, Scan Scope를 All sources (including tests) 로 설정 | Configuration file에 다운받고 수정한 XML 파일(ideaProject폴더에 다운받아놓은 naver~checkstyle rule.xml)을 추가 | 하단에 checkstyle 창(단축키 직접지정 alt+shift+k)로 코드짜고 확인하기 | | | . . . intellij용 xml파일 다운로드 | 설치가이드 https://naver.github.io/hackday-conventions-java/#intellij-formatter | 나는 지금 플러그인 : google-java-format&gt; android 버전을쓰고있는데.. 취소시킴 | . | checkStyle적용하기 . CheckStyle은 Java 코드를 작성 할 때 규칙(이 경우 코딩 컨벤션)들을 선언해두고 이를 어길 시 에러 또는 경고를 뿜어내어 개발자로 하여금 컨벤션을 강제로 지킬 수 있도록 도와주는 코딩 컨벤션 검사 도구다. 네이버 핵데이 Java 코딩 컨벤션을 적용할 시 다음을 제외한 나머지들에 대한 컨벤션을 검사할 수 있다. . 한국어 발음대로의 표기 금지 | 클래스 이름에 명사 사용 | 인터페이스 이름에 명사/형용사 사용 | 메서드 이름은 동사/전치사로 시작 | 테스트 클래스는 ‘Test’로 끝남 | 대괄호 뒤에 공백 삽입 | 주석문 기호 전후의 공백 삽입 | . | 적용방법 . Naver CheckStyle Rules XML 파일을 다운받는다. 나는 프로젝트 최상단($rootDir)에 이를 추가했다. . 내문서 &gt; IdeaProjects폴더에 저장함. | . | 우선 나는 다른 규칙을 덮어쓸 생각이 없어서 여기를 참고하여 XML 파일에서 다음을 삭제했다. 이를 삭제하지 않으면 다음 단계에서 suppressionFile 변수에 파일을 할당해야한다. . &lt;module name=&quot;SuppressionFilter&quot;&gt; ​&lt;property name=&quot;file&quot; value=&quot;${suppressionFile}&quot;/&gt; ​&lt;property name=&quot;optional&quot; value=&quot;false&quot;/&gt; &lt;/module&gt; . | . | ide에 적용하기 . File &gt; Settings &gt; Plugins 메뉴에서 CheckStyle-IDEA 플러그인을 검색 후 설치한다. | Tools &gt; CheckStyle에서 Checkstyle version을 8.24 이상, Scan Scope를 All sources (including tests) 로 설정한 후 Configuration file에 다운받고 수정한 XML 파일을 추가하자 | 이제 우리가 설정한 코딩 컨벤션을 어기는 코드를 작성하면 다음과 같이 경고 표시가 나타난다. | | . | .",
            "url": "blog.chojaeseong.com/intellij/%EC%9A%B0%ED%85%8C%EC%BD%94/%ED%98%91%EC%97%85/2022/02/13/intellij_%ED%98%91%EC%97%85%EC%84%B8%ED%8C%85(%EC%99%84).html",
            "relUrl": "/intellij/%EC%9A%B0%ED%85%8C%EC%BD%94/%ED%98%91%EC%97%85/2022/02/13/intellij_%ED%98%91%EC%97%85%EC%84%B8%ED%8C%85(%EC%99%84).html",
            "date": " • Feb 13, 2022"
        }
        
    
  
    
        ,"post142": {
            "title": "intellij plugin, shortcut(keymap)",
            "content": "인텔리제이 플러그인 및 단축키 . 의존성 확인하는 법 . 우측의 gradle 탭 선택 타자 쳐서 바로 하위 패키지 검색 바로 안됨 | . | 상단 버튼 중 Analyze dependencies..선택 여기서 검색하면 나온다. | . | 플러그인 . vscode keymap검색 install . keymap탭 가서 VSCode로 바꾸기 | . | key Promoter X 설치 vscode keymap 바꾼것도 보여준다. | | Rainbow Brackets . | .ignore : 우클릭으로 ignore파일을 만들어주는데, . 우클릭 &gt; new &gt; ignore file &gt; .gitignore파일 &gt; 선택하면 됨. | 자동완성도 해줌. | . | cobalt2 theme . | translation . Plugin &gt; MarketPlace &gt; Translation검색 . | Tools 내부에 있음. 기본적인 세팅은 구글번역 . | 단축키 일부 재정의 . 공부용 영-&gt;한 번역기: ctrl+shift+ Y 아무것도 없는 곳에 두고 누르면 code with me 단축키 | . | 코딩작명용 한-&gt;영 즉시번역 : ctrl+shift+X Translate and Replace: 설정창에 묻혀서 단축키 재정의 (ctrl+shift+x)-&gt; 다른것 remove) | . | . | | sonalint shift2번 후 plugin 검색 or 설정에서 plugin -&gt; market을 선택한 뒤 sonalint검색 | 설치후 아래 탭에서 sonalint null체킹 등 기능 이용하기 | | Codota . 검색후 설치한 뒤, 자동완성시 % 보여주고 + snippet 검색 가능 . . . | . | prgoress bar검색후 마리오로 설치 . . | TabMover 설치후 . 파일 띄우기: ctrl+alt+shift+ D | 복사후 이미 떠있는 반대창에 종속시키키: ctrl+ 이후 ctrl+alt+shift + Up | . | atom material icons검색하여 설치 . | . | UnitVisualizer (1.7.1) : class의 package이동시 classTest파일도 같이 package이동 . project속 파일도 왼쪽아래 살짝 표시된다. . . | . | 단축키(vscode keymap기준) . shift 2번 : 전체 검색(유지) vscode F1 | . | keymap 들어가서 move To opposite group검색후 ctrl+shift+ 오른화살표지정하기 ctrl + 이후 넘기기..왼쪽넘기기 기능 자체는 없나보다. | alt+shift+0으로 세로로 넘기기 가능 | . | alt+shift+F : reformat code -&gt; 한파일내 패키지 or 폴더 선택후 alft+shift+F | . | keymap 들어가서 back검색후 ctrl+u지정하기 | ctrl + .으로 메인메소드 내용을 extract method 호돌스에서 봄. | 메소드 분리 및 패키지명 작성하고 폴더이동시키기 | . | 신세계) alt+insert로 생성자를 만듬 | **신세계) 메서드사용을 위한 객체 만들 때(인스턴스화) 할 때, ** new 클래스명(); 기입후 ctrl+.으로 local변수 자동(선택후)생성하자. | 객체.메서드();기입후 ctrl+.으로 메서드결과값 받는 변수 자동(선택후)생성 | . | keymap -&gt; extend line selection -&gt; ctrl+L을 추가해서 사용하기 라인 선택하기 shift+alt+아래화살표로 복사할때,, 라인 선택해서해야.. 꼬임없을 듯 | . | . | shift+ alt+ F10: 실행할 class파일 선택해서 실행 ctrl+alt+F10은 바로 실행. | . | shift + alt + x: 현재 파일들 다 close | shift + alt + a : 긴글 주석? . | alt + ~ : git관련 명령어들 목록나옴 . | ctrl + F11 or ctrl+shift+{key}로 북마크 지정 -&gt; ctrl+해당번호로 이동 | keymap -&gt; show bookmaks검색후 -&gt; CTRL+SHIFT + F11 으로 지정함 | . | ctrl + f3 : 같은단어 이동가능한 검색한 상태로 만들기 == ctrl+f f3 : 같은 단어 다음으로 이동 | shift + f3 : 같은단어 이전 단어로 이동 | . | shift + F5 : 실행중인 작업 종료 ctrl + F5 : 실행 | shift + alt + f10 : main함수 골라서 실행 | . | alt + 7: 현재파일 Structure(메소드 등) 한눈에 보기 alt + 7 띄운 상태로 alt + shift + PgUP/pgDn으로 메서드 이동시키기 getter/setter 등 | . | 유틸메서드로 빼기, 상수 옮기기 : f6으로 편하게 | . | 리팩토링 alt+ctrl+c : 값을 상수로 등록해버리기 | alt+ctrl+m : 코드를 메서드화 시키기 2번 눌르면 창으로 하는 듯 | . | alt+ctrl+v: new 클래스()까지 입력후 참조변수 바로 생성 | alt+ctrl+p: 클래스내 변수/메서드 사용을 -&gt; 작성중인 메서드의 파라미터로 빼고 싶을 때 ex&gt; 테스트를 위해 내부랜덤요소를 파라미터로 받도록 설게 | . | . | 축약어 iter | fori 추가 | itar | ifn | inn | . | F8: 오류바로 찾아가기 | ctrl+f -&gt; F3 or shift + F3 : 검색항목 순서대로 찾아가기 . | alt + del : 메소드 등 안전하게 지우기 . | keymap -&gt; refresh gradle dependen~검색 후 -&gt; shift+ c+a + G로 추가해서 사용 gradle에 추가한 라이브러리 재갱신시킬 때!! | . | keymap -&gt; checkstyle -&gt; alt+shift+k로 지정함 naver checkstyle 적용해보기 위함임. | . | F3 -&gt; 함수단위로 건너띄기 검색후 F3 : 다음 검색결과로 넘어가기 shift는 이전으로 넘어가짐. | . | . | ctrl+Tab : 직전창 왔다갔다하기 shift 안눌러도됨. | 메인로직(controller) 옆에서, readme &lt;-&gt; 세부작업중 파일싱글톤관리자, 서브화면 왓따갔다 하면 좋음 | . | ctrl+shift+alt+ I 후 -&gt; unused desc 검색후 -&gt; test파일 제외 체크 -&gt; 사용하지 않는 험수들 손수 제거하기 safe delete하니까..ㅠㅠ 설정 꼬였음. . | File -&gt; invalidate cache 캐쉬삭제 &amp; restart 해서 처리.. . | . | 라이브 템플릿 추가하기 싱글톤용 -&gt; sgt으로 생성 외부에서 메인로직관리싱글톤Class.getInstance()로 작성후 | 클래스 생성 후 sgt으로 채워주기 | . | 검증하며 무한호출하는 재귀 getInput InputView.getInput()작성후 getMany or getOne | . | 랩핑클래스용 | 이넘용 | . | keymap에서 Toggle case검색후 vscode의 대문자(U), 소문자(L)에 해당하는 것 2개를 다 추가해주기 . ctrl+alt+U , ctrl+alt+L | . . | try/catch등 한방에 씌우기: ctrl+alt+t . | ctrl+alt+O : library 적용안될 때 refresh시키는 단축키 덮어주기 default 단축키로 지정되어있지만, 겹치는게 많아서 잘 적용이 안되더라. 다른거 remove하면서 덮어준다. | . | ctrl+F2 : 동일단어 한번에 전체 선택 . | ctrl+space x 2 : 기존 navigate error 역할인 F8이 너무 멀어서 추가함 keymap -&gt; navigate error검색후 add ctrl+space + second stroke ctrl+space 추가 -&gt; 기존 F8 leave | . | alt+2: 북마크창 ctrl+shift+숫자 지정후 -&gt; 바로 alt+2 띄우는 버릇 들이기 | . | 플러그인 translation설치후 ctrl+shift+x : 변수 번역하기 . | 플러그인 tabMover설치후 TabMover 파일 띄우기: ctrl + alt + shift + D | 이미 창이 나뉜 상태에서 커서를 좌우왔다갔다 : ctrl + alt + shift + [ or ] 프로젝트 왔다갔다 : shift만 빼고 ctrl + alt + [ or ] | . | 탭을 좌우왔다갔다: ctrl + alt + shift + PgUp or PgDn으로 가운데 창 복사 후 떠있는 반대창에 종속시키키: ctrl+ 이후 ctrl + alt + shift + PageUp | . | . | 탭 순서 좌우왔다갔다 : ctrl + alt + shift + ← or → | . | alt + F12 : 구현부 즉시보기 . | ctrl + R2번 : 최근파일 -&gt; 최근파일 중 수정된 것만 보기 . | POSTFIX completion .if .while | . | .stream | .reqnonull | .sout .souf : 조심 블로그에 { % 찍히면 안됨 | .soutv | . | .try | .format | .par: 괄호 달기 | . | keymap &gt; go to test 검색 후 단축키 지정 : ctrl+shift+ T -&gt; 나머지 leave 테스트 없으면 생성, 있으면 이동 시켜주게 된다. | . | 중복코드 등 확인 analyze: shift2번 -&gt; inspect code...검색 &gt; ok누르면 찾아준다. . | ctrl+alt+F: 필드(인변, 클변)로 추출 (new HashMap등 제네릭 작성후 뽑을 때 유리할 듯) | 생성자에서 초기화해주는 필드 작성시? | . | ctrl+F6: 시그니처(파라미터 추가/삭제/위치변경을 스마트하게) . 대박) 추상클래스 등 부모에서 상태값 선언전에 generate로 대충 생성후 -&gt; change signature로 proteced( or public)으로 생성자 리팩토링하여 수정하면 -&gt; extends 자식들에게 super()로 내부에서 직접 갖다호출할 수 있게 정의까지 해준다. . . | . | . | 메서드 이동: keymap &gt; move statement검색후 &gt; 키맵 지정해주기 remove해도 됨. . . Move staetment Down : alt + shift + PgUp . | Move staetment Up: alt +shift + PgUp . 주의) 코드가 아니라 구현부 괄호에서 작동한다. . 코드라인이 이었다면 ctrl+shit+ 를 통해 구현부 시작 괄호로 이동하해서 입력(alt+shift+PgUp/Dn)한다 . | 아래 code line에서는 작동안함 . | . | 참고) 메서드 내부 코드를 옮긴다면 alt+up/down보다 더 유용하게 code line도 이동시킬 수 있다. . | . | . | 상속/추상화 관련 작업후 다이어그램 보기: . 프로덕션의 패키지 폴더를 클릭한 상태로 ctrl+alt+shift + U . | 최근에는 ctrl+shift+ ;를 1~2번 눌러 BreadCrumb로 진입한 다음, 거기서 c+a+s+ U2번 정도 갈겨서 띄운다 . | 모드 . 기본 추상화/상속구조도 볼 때: edge create mode + field &amp; method는 기본적으로 켜두자 . . | . ​ . | 생성자 열어두기 여부를 통해 생성 경로를 포함한 추상화/상속 관계도를 볼 때 . field + 생성자 + show dependency껏다키기 -&gt; route edge는 선택 기본 필드+메서드+크레이이션 모드 | 생성자만 | 필드 + 생성자 | 필드 + 생성자 + show dependency | 필드 + 생성자 + show dependency 꺼서 보기 생성자 표기정리 좌물쇠 열림: public -&gt; 외부에서 생성 가능 | 빨간색 좌물쇠 잠김: private | 노란색 자물쇠 잠김: protected -&gt; 중간카테고리 추상클래스의 상태+생성자+getter물려줄 때, 생성자도 super()로 물려줘서 물려준 상태값을 초기화 | 회색 점 : default -&gt; 몰아놓은 package내에서만 생성가능 | . | * : final | 초록 빈 육면체 : 추클 | 파란 꽉찬 육면체 : 클래스 | . | . | . | 자동 업데이트 안되며, 껐다가 새로 다이어그램 띄워야한다. . returnType이 메서드 우측에 표기되나, null/throw처럼 확실하지 않으면 ?가 붙는다. | . . | . | ctrl+H: 찾아서(ctrl+f) 바꾸기 . ctrl + shift + h : 전체에서 찾아 바꾸기 -&gt; 쓸일 많이 없을 듯? | . | ctrl + F12 : 추상메서드의 개별 구현메서드 구현 선언부 다 표기해서 골라가기 . 보통 F12누르면.. 추상체의 추메로밖에 안가서 불편 | . . | 이름 리팩토링 with Test까지: 해당 파일 클래스명 클릭 -&gt; F2 -&gt; alt + a -&gt; tab2번 enter로 Okay *rename Test까지 뜰 때, Test도 같이 바꾸도록 Select All의 alt + A로 선택후 okay클릭 or 탭2번 | . | ctrl+alt+v : 변수추출을 우항-&gt; 좌항 변수 자동완성뿐만 아니라 긴 파라미터 위에다가 변수로 추출할 때 쓰자. . . | git history보기 : alt + ~ &gt; show history . | 코드창 빼고 다 닫기: shift + ESC . | breadCrumb 열기 : ctrl+shit+ ; . 같은 프러덕션 내 or 같은 테스트내 이동, 이걸로 움직이고 생성/삭제해도 괜찮을 듯; cf) 프 &lt;-&gt; 테 간의 이동 : go to test로 이동 ctrl+alt+T | . | . | 블럭지정을 포함한 F1 + tab or F1 + tabtabtab : 클래스명 or 메서드명 검색 . 특정단어 블럭지정 -&gt; 그 단어로 class명/method명 검색 by F1후 tab F1만 누르면 전체검색 | tab한번해서 class검색 | tab 총 3번해서 Symbols로 가면 변수 or 메서드 검색 | . | . | 오른쪽에 새창 띄우고, 왼쪽으로 커서 넘기는 새로운 방법 . 새로 오른쪽에 복제로 띄우기 ctrl + . 왼쪽으로 커서 넘어와서 (tabmover 플러그인의 c+a+s+[ ) 후 . | 왼쪽창을 Open in Opposite Group을 ctrl+alt+left로 재정의 한다음 복제후 왼쪽으로 커서 왼쪽으로 넘어오는 용도로 쓴다. . . 끄기 or ctrl+PgUp orctrl+PgDn으로 다른창으로 넘어가기 | . | | 요약 . ctlr+ 복제 -&gt; ctrl+alt+Left로 (왼쪽창을 여는 fake로)왼쪽창으로 커서 넘기기 이후론 왼쪽창 끄거나 다른창으로 넘어가기 | . | . | | 다른 window에서 editor로 넘어올 땐 Escape(ESC) . | 파라미터 힌트 완성 띄우기: ctrl+ alt+ space 파라미터 힌트 with names랑은 다른 것 | 좀 이상함. | . | related problem이 뜬 경우 . 클릭안하면 ctrl+.로 안먹는다. . | 대박Show related problembs): ctrl+space2번 or F8로 가면 노란색워닝(+전구)에서 ctrl+. . | 만약 2개 이상의 에러인 경우, alt+3의 Find창에 뜨는데 끄려면 확인후 ctrl+shift+F4 . 대박) 확인시 shift+enter로 2번째창에 띄우기 | . . | . | 대박2) 파일 아이콘 을 shift + Enter열기 : 우측에 복사해서 띄움… . | 현재 창제외 모두 종료: alt+ (X)닫기클릭 **alt + ctrl+w로 단축키 지정해주기 ** **keymap &gt; close ohter 검색후 &gt; ** Close Ohter Tabs: alt + ctrl+w | Reopen closed Tabs: shift + ctrl+w | . | . | . | 최근파일ctrl+r 2번해서 을 열어놓고 검색 + shift + endter로 우측창에 띄우기까지 하기 최근파일에서 특정 파일 검색으로 편하게 띄우기 | 특정파일의 Test등 옆에서 봐야할 파일을 shift+ Enter로 우측창에 띄우기 사실 테스트는 ctrl+ 복사 -&gt; 우측 창을 ctrl+shift+T의 go to test로 이동하는게 더 쉽다. | . | 특정파일 중에 README와 Test 등 단일로 빠르게 찾아 띄우기 기능이 좋다. readme | test | . | . | 테스트 with Coverage : alt+shift+ F10or F9(debug) -&gt;all Test -&gt; ` → Coverage 선택해서 Test돌리기` . . | ctrl+shift+ [+]: keymap &gt; expend all 검색후 &gt; 보이는 것 다 지정해줌 . 프로젝트 창에서 켜지말 것. 다 열림 | . . | 추클/인터페이스의 usage(바로 아래) vs impl(아래 최하의 구현체까지) 확인방법 . Shift + F12: usage로서, 추클인 경우, 적은 수의 extends로 사용한 자식들만 확인할 수 있다. . 중카/추클의 부모클래스에서 usage로 확인하면, extends한 같은 레벨의 자식들을 볼 수 있다. . | 같은레벨의 자식들이 뭐가 있는지 확인할 수 있다. . . | . | Ctrl + F12 : impl로서, impl한 추클의 extends자식들까지 -&gt; 중카-추클로 연결된 자식들포함 하위 구현체들 모두 . . | . | 현재파일 내 사용처 아래 녹색 띄우기 : Ctrl + F7 . | 모든 사용처 아래 Find창에 띄우기 : Alt + F7 F12만으로 부족한 모든 사용처를 read/write별로 알려준다. ctrl + F7을 하면, 해당 파일안에서 녹색으로 사용처를 띄워준다. | . | alt + 3에 해당하는 Find창에 띄워진다. 참고 단축키 alt+3: find창 띄우기 | ctrl + shift + [+] : 창 전체 expand하기 (Expand all 지정해준 것) | ctrl + shift + F4 : 아래창 1개 끄기 | . | . | 이미 사용중인 메서드 삭제시 usage 확인 후 -&gt; alt+F7로 사용중인 곳 미리 띄워놓기 . | **추상체가 paramter로 쓰여 구상체가 주입되는 부 찾을 때, alt+F7 &gt; Method parameter declaration ** | . | 메서드 파라미터 선언부에서 파라미터 순서변경: ctrl+alt+shift+화살표 만약, 일반적인 커서에서 ctrl+alt+shift+화살표 : 창이동 by TabMover | 메서드 파라미터 선언부에서 ctrl+alt+shift+화살표 : 파라미터 위치(순서)변경 | . | ParameterInfo : Ctrl+Shift+ Space 단순 파라미터 Type정보를 바로 알 수 있다! | . | 대박) 직전test Return : keymap &gt; rerun &gt; rerun 중 3번째 것 매핑 ctrl + shift+ alt+ R 새로고침아이콘 없는 것 | . | 생성자내에서 파라미터에서 ctrl+. 필드 추출 및 생성자 초기화 선택 가능 | 파라미터에서 ctrl+. -&gt; Replace constructor factory method : 정펙매로 빼는 것 가능 말만 replace지, 기본생성자는 private변경후 pulic 정적팩토리메서드 자동생성해준다. | . | | rerun : 단축키 ctrl +shift+ alt + R로 지정해주기 test 실패시 수정후 바로 테스트 재실행 | application 재실행 | . | shift+esc : 아래정보창 끄기 | delegate : 다른 클래스로 추출 for 조합 keymap &gt; delegate검색 &gt; [Refactor] Extract delegate &gt; ctrl+alt + D로 | 나는 무의식 중에 shift2번 + delegate로 사용함 | . | null가능성이 없는데 @Nullable 애노테이션 때문에 warning 뜨면 -&gt; suppress for method로 명시해주기 . | 메서드 생성시 cr~을 검색하면 바로 시킬 수 있다. . | ctrl+shift+k : 잘라내기(shift+ del)가 아닌 한 줄 삭제 잘라내기로 한 줄 삭제를 사용할 경우, 들고 있던 복사한 내용이 사라진다. | . | ctrl+shift+F9 : recompile for HTML 실시간 수정html이 웹에 반영된다. | java는 하더라도 서버를 재시작해야 웹에 반영되므로 아직까진 모르겠음. | . | ctrl + alt + N : 인라인 리팩터링 변수 인라인 -&gt; 변수에 커서를 데고 인라인 리팩토링하면, 변수로 뽑아 놓은 우항의 값들 -&gt; 변수는 사라지고 값이 각 변수자리에 직접 들어간다 변수 추출의 반대 | . | 메서드 인라인 -&gt; 메서드에 커서를 데고 인라인 리팩토링하면, 메서드 내부 return되던 로직들이 -&gt; 메서드는 사라지고 내부로직이 직접 들어간다 메서드 추출의 반대 메서드로 따로 존재하던 로직 | 메서드가 사라지고, 메서드 내부 로직이 들어온다. | . | 메서드 내부 로직이 바로 꺼내져 와서 context의 문제도 생기므로 잘 안쓸 듯. | . | | ctlr+shift+ DEL in html tag : 내부 태그는 놔두고, 해당 중간 태그 or 바깥 태그 등 일부 태그만 벗겨내서 지운다. java 등에선 사용 안됨. | . | class에 커서 데고 + F6 : inner class [바깥으로] 이동 [추출] python은 기본적으로 같은 .py내부에 inner class를 만든다. -&gt; 다 만들고 나서 class에 커서 데고 추출한다. | java에서도 public static 메서드만 추출했었는데, inner class도 추출된다. 말이 class추출이지 새로운 파일을 만든다. | . | . | alt + [ctlr + w] : 현재창 빼고 다 끄기 ( = alt + 파일닫기) shift + alt + x: 열린창 다 끄기 | cf) shift + alt + a : java + html 여러줄 한번에 주석(pycharm에선 안됨) | . | shift + ctrl + U : Run탭으로 가기 ctrl + u의 직전커서로 이동으로 하다가, 앞으로 갈려고 발견함 | vscode에서는 출력으로 간다. | f4 : run이 테스트일 때, 해당 테스트로 jump | . | cf) intellij default toString(String concat(+)) and equals and hashCode(java.util.Objects.equals and hashCode (java 7+)) 성능좋다고 builder로 바꿨다가. toString을 통한 java객체비교에 메모리 주소가 붙어서 안될 수 도 잇음. 컨벤션의 문제도 다시 String concat(+)로 돌림 | . | equals and hashCode도 intellij default가 있어서 봐꿨는데 다시 기본 java.util.Objects.equals and hashCode (java 7+)로 바꿈 intellj default는 기본이 아님 | . | . | ctrl + O(열기) -&gt; ctrl + 2 : 프로젝트 열기 -&gt; 현재 프로젝트 폴더에 진입 . | shortcut pdf 단축키 (Ctrl + K, Ctrl +R) 제거 제거 안하면, ctrl + k, r의 윈도우 탐색기로 열기가 안됨. | . | 단축키로 윈도우폴더 열어 새로운 폴더 -&gt; 윈도우터미널(wt -d .) 열기 ctrl+shift+E(Tool Window-project) -&gt; ctrl+home(root folder) | ctrl+ k + r: (루트폴더 상태)탐색기로 열기 -&gt; win+2(작업표시줄-파일탐색기) ctrl+k 누른 뒤, ctrl 떼고 R 눌러야함. | 탐색기로 열어도 바로 안뜸 -&gt; 작업표시줄 탐색기 단축키(win + 숫자)로 눌러서 띄우기 | . | alt + 2 : 새로운 폴더 폴더 생성 alt + 1: 선택한 폴더 속성 | . | ctrl + L(주소표시줄) -&gt; wt -d . wt . 만 하면 에러 뜬다. 조심. | . | | shift + ENTER : Project(Tool window) or ctrl+shift+; or commit(alt+0) 상태에서 주위 파일 측면 창으로 열기 만약 아무파일도 안열린 상태면 F4로 jump to Source하면된다. | . | ctrl + alt + shift + C : 패키지부터~파일까지 경로 복사 alt + shift + C: 컴퓨터에서부터 경로 복사 | commit창에서 파일클릭시 비교창이 뜨는데 shift + enter로 우측체 파일을 띄울 수 있다 만약 아무파일도 안열린 상태면 F4로 jump to Source 하면된다. | . | . | commit에 대한 파일 경로 복사해서 괄호안에 넣기 정리 commit창(alt+0)으로 열고 | 해당 파일에서 F4를 통해 source파일로 가서 ctrl+alt+shift+ C를 통해 경로 복사 | 다시 commit창(alt+0)으로 와서 tab을 눌러 commit message창으로 간 뒤 | ctrl+v로 붙여놓고 앞에 세부경로 + 뒤에 확장자 및 라인을 제거(ctrl+shift+방향키4번) test파일이면, 앞에 test()로 커밋하기(test라는 경로는 안나옴) | . | ctrl+enter로 commit | | alt + ~ -&gt; (show검색) show history : 파일 자체의 commit 히스토리 확인 . | Database(Tool window) : keymap &gt; database 검색후 Tool Windows &gt; database의 단축키 지정 alt+D . | ctrl+shift+B: 기존 코드 수정후, 빨간줄 전파를 전체에서 찾아준다. ctrl+shift+F9: 현재코드만 리빌드 -&gt; html 수정후 바로 반영시킬 때 사용 | my ctrl + shift + B : 자바 코드 수정 후 전체파일에서 오류 찾기 Test 전체 실행 : 자바 코드 수정 후 전체파일에서 로직 오류 찾기 | . | ctrl + shift + F9 : html 코드 수정후 현재파일 업데이트 | . | . | ``ctrl + shift + up/down : 원격 데스크톱에서 멀티 커서(Clone Caret)` 단축키인 ctrl + alt + up/down 중 ctrol+alt가 먹통이어서, 원격용 멀티커서를 지정함 . | shift + F5 : 디버깅 멈추기 cf) 디버깅은 현재 테스트에 대한 디버깅이 없음… F5 or alt+shift+F5로 디버깅 지정해서 실행해야함. | run의 경우 run ant target으로 현재 커서에 위치한 테스트가 바로 실행되는데, debug ant target 은 없다. | . | test 전체 돌릴 때, ctrl+shift+;활용해서 src까지 가서 ctlr+shift+F10으로 전체 테스트 돌리기 현재 테스트파일내 전체 메서드 실행도 ctrl + shift + ; -&gt; F10으로 빠르게 돌릴 수 있다. | . | ctrl + shift + U : markdown 링크 거는 단축키 -&gt; keymap에서 Create link로 ctrl + K 추가함. vscode에서도 keyBinding을 Ctrl+K로 변경했지만, 이게 상용 단축키인가보다. | . | ctrl + alt + Q : javadoc을 renderView 봄 html 코드가 있을 경우, 예쁘게 나옴 | . | ctlr + alt + Y: refresh from disk 중복되어있다면, keymap -&gt; from disk 검색해서 이것만 살리게 한다. | . | 이미 생성된 인터페이스 구현을 쉽게하는 방법: 인터페이스 명칭에서 ctrl+.을 하면 implement interface가 뜬다. 기본 class로 구현하니 abstract(or final)를 붙여준다. | cf) 반대로 구현을 취소하는 것도 바로 가능함. | 추가로 추상클래스 구현도 추상클래스 명칭에서 ctrl+.을 활용한다. | . | class 필드 추가 순서 pf 필드를 선언 | ctrl + .으로 add construct parameter를 이용해서 없으면 생성/있으면 추가 이 방법을 써야 기존 생성자들이 있으면 자동으로 signature 변경 창을 띄우고 + 사용(호출)중인 생성자에 빨간색 추가인자를 끼워놓아 컴파일 에러로 수정하러 갈 수 있다. | 생성자 추가후 build project(ctrl+shift+B)를 활용하면, 인자 추가된 호출부들을 처리하러 갈 수 있음. | . | | README.md에서 원하는 폴더로 링크걸어주기 각자 by Repository root에서의 경로를 합해서 링크를 원하는 원하는 폴더 우클릭 &gt; Copy Path/Reference.. &gt; Path from REPOSITORY root 선택 | 현재 README.md의 위치가 root가 아니라면, root로 가는 경로 만들기 by ../ | README.md 경로(root) + 원하는 폴더(copy path) 주소 합하기 | | ctrl+shift+; -&gt; ctrl+shift+F10 해당 테스트 코드 전체 바로 돌리는 단축키 조합 | . | show explorer(Ctrl+K, R)시 오작동 켜지는 keyboard shortcut PDF 단축키(Ctrl+K, Ctrl+R)제거후 show explorer에 추가 배정하기 . | c + s + a + G(assing): 입력 가능한 live template 목록 보기 keymap -&gt; insert live template검색 후 지정 | . | c + s + a + U: diagram보기 설정빠르게 하도록 수정 : 옵션버튼(Open diagram settings) &gt; [ ] enable animations 체크해제 | shift + F5: Apply current layout으로 이쁘게 만들어 줌 | shift + F6(assign): Apply current layout이후 Fit Content로 화면에 맞게 줌 - shift+F5 이후 연속기로 쓰려고 클릭이외 단축키를 추가함 | . | Ctrl + D in project(assign): 2개 파일 비교하기 keymap &gt; compare file 검색 후 &gt; Ctrl+D로 지정 | 비슷한 파일 차이점 비교할 때 ex&gt; 구상체들의 공통로직(템플릿메소드) +개별로직(훅메서드로 추출) 만들어서 템플릿 메소드로 올릴 때 method정의부를 accept하면, 안에 내용물까지 똑같이 바뀌므로 조심할 것. | 모든 구상체에 대해 구조 = public 템플릿메소드(공통 로직을 포함한 전체로직) + 그 내부에 private 훅메서드(개별로직) public 템플릿 메서드 내에 모든 로직이 담겨있느냐 private 메서드(내부에서 빠진 것)를 제외시키면서 public 메서드 1개만 있으면 된다. | . | 템플릿내부 개별로직이 private 훅메서드로 빠져있느냐 달라서 highlight뜬 line들이 템플릿메서드 내에 보이면 안된다. | 템플릿메서드 내 hightlight -&gt; private메서드로 추출해서 훅메서드안으로 보내야한다. | . | 템플릿내부 private 훅메서드의 이름이 구상체마다 같느냐 | | 이름 확인 템플릿메소드 이름이 추상화되어 동일하느냐 | 훅메서드 이름 역시 추상화되어 동일하느냐 | | | 올릴 구상체 1개에 대해 수정 구조가 잡혔으면 -&gt; 템플릿메서드명와 훅메서드명들을 통일 예정으로서 추상화해놓고 올리기 | . | . | 참고 코드에서 Ctrl+D: 단어블랙지정(최초) -&gt; 같은 단어 순차적 선택 | 참고 Ctrl+F2: 같은 단어 모두 선택 | . | . | ctrl + shift + F6: 필드의 type을 한번에 바꾸기 . | 생성자 인자 추가(ctrl + F6)시 default Value활용하기 deafult값을 주고 생성하면, 기존에 인자없이 사용된 생성자에도 추가된다. 되도록이면 기존 로직에 방해가 안되는 값으로 주기 | . | 기존의 값들도 모두 변해버리니, 새로운 인자 추가시에만 사용하기 | . | 현재 프로젝트명으로 github repository 생성하기 git &gt; github &gt; share on github 으로 쉽게 만들어짐. | . | ctrl + r -&gt; shift + enter: 같이 볼 파일을 최근파일 -&gt; 우측에 띄우기콤보 . | alt + / or alt + shift + / : `cyclic word expand 기존 작성된 것을 바탕으로 자동완성 시켜주는 기능 | . | String sql 작성시 injection language 이용하기 . | (드래그 후)ctrl + alt + F8(assign) : Evaluate Expression 기존 quick evluate expression을 삭제하고 배정한다. | 디버깅시 의심Line F9 -&gt; 디버깅 -&gt; 수정해볼 부분만 드래그후 Evaluate Pression (Ctrl + Alt + F8)** ctrl + shift + enter를 치면 아래 watcher부분에 기록을 남긴다. | . | . | check RexExp: 정규표현식이 들어갈 인자에서 수행가능하다. 순수 RegExp로 해당하는지를 체크하면서 작성할 수 있다. | . | ctrl + F1 : error description (error hint) -&gt; 연속기(에러 수정): alt + shift + enter 참고: parameter hint : ctrl + shift + space | . | ctrl + shift + F: 해당값이 쓰인 곳을 프로젝트 전역으로 찾기 -&gt; Fixture에 저장된 상수등을 상수화할 때 쓰임 . | shift + F12: 직접적으로 사용한 것들만 보이므로 추상클래스, 부모클래스, 인터페이스에 갖다되면, 구상한 것들을 보고 추상화 레벨을 판단할 수 있다. 직접적인 사용체들(Usage -&gt; shift + F12) | 하위 모든 구현체들(inherit -&gt; ctrl + F12) | . | ctrl + shift + L: 해당 단어 빠르게 다찾기 하나씩 찾던 ctrl + d의 전체버전 | . | ctrl + shift + del: unwrap(if/while 등) or remove if/while의 내부영역만 남기고, 바깥의 if/while을 제거해준다. | . | vscode와 sync 맞추기 vscode는 ctrl + E가 최근파일, ctrl + r은 최근 프로젝트이므로, intellij의 ctrl + r(Recent file)에 ctrl + r 추가 | vscode는 ctrl + B가 프로젝트 창 닫기이므로, intellij의 ctrl + shift + E(Project)에 ctrl + b 추가 | vscode는 ctrl + k가 makrdown 하이퍼링크 걸기이므로, intellij의 ctrl + shift + U(Create hyperlink)에 ctrl + k 추가 | | .",
            "url": "blog.chojaeseong.com/intellij/%EC%9A%B0%ED%85%8C%EC%BD%94/%EB%8B%A8%EC%B6%95%ED%82%A4/%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8/plugin/keymap/shortcut/2022/02/13/intellij_%EB%8B%A8%EC%B6%95%ED%82%A4(%EC%99%84).html",
            "relUrl": "/intellij/%EC%9A%B0%ED%85%8C%EC%BD%94/%EB%8B%A8%EC%B6%95%ED%82%A4/%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8/plugin/keymap/shortcut/2022/02/13/intellij_%EB%8B%A8%EC%B6%95%ED%82%A4(%EC%99%84).html",
            "date": " • Feb 13, 2022"
        }
        
    
  
    
        ,"post143": {
            "title": "datagrip 세팅 및 단축키",
            "content": "datagrip . 설정 . intellij settings export | vscode keymap 설치 | intellij settings import | 설정 &gt; Database &gt; Query Execution &gt; shortcut assign &gt; ctrl + enter | 설정 &gt; Database &gt; Query Execution &gt; When inside statement execute : ask -&gt; smallest | 단축키 . ctrl + shift + Q: 새 쿼리 콘솔 열기 | F5(assign) : execute 단축키로 쿼리 실행하기 | alt + 2 : file(tool window) | ctrl + shift + alt + F: table의 where filter 포커싱 | ctrl + shift + alt + G(assing): 입력 가능한 live template 목록 보기 keymap -&gt; insert live template검색 후 지정 | . | ctrl + F6: table선택상태에서 테이블 수정(alter table) . | query console의 In-Editor Result버튼 수동 클릭으로 X 버튼 눌러줘야해서 불편하기도 함. | . | alt+8: service 탭에 query console(*.sql) - session 연결을 확인할 수 있다. alter table 하고 싶은데, sesion이 연결되어있을 경우 작동안한다. | alt+8 -&gt; 각 콘센트를 Close Session해주면 된다. | 참고로 왼쪽 console에 쿼리실행시간도 나온다. | . | Ctrl+Alt+Shift + F4: keymap Close Session검색후 단축키 지정해주기 Close Session: c + a + s + F4 sql파일 내에서 누르면 session 끊기고 + sql파일도 닫힌다. | . | Close Session: c + a + s + F4 + F4 | . | 세션 확인 후 종료 : alt+8(service) -&gt; c+a+s+F4(Close session) . | ctrl + ENTER: default Start New Line 단축키 자동완성을 피하면서 줄바꿈 하기 위함 | shift를 넣어주면 Start New Line Before Current 단축키로, 직전행에 새줄 생성 및 커서 이동 | . | ctrl + shift + T(assign): 조회 결과를 transponse해서 보기 keymap &gt; transpose검색 &gt; plugins하위 &gt; c+s+T로 지정하기 | . | query문 마다 바로 위 --commnet가 result tab의 제목이 된다. comment까지 같이 포함시켜 실행해야하며, 여러 쿼리문 실행시 나눠서 보여준다. | . | result tab에 있는 Compare with 버튼으로 result tab끼리 비교도 할 수 있다. . | F4 + table: table에 담긴 데이터를 바로 볼 수 있는 data editor가 열린다. csv, tsv 등 데이터를 편하게 복붙해도 알아서 인식해서 넣을 수 있음. | F4 상태에서 데이터를 변경하면 submit전에 해당 셀을 revert되돌리기 할 수 있다. 변경이 감지된 셀을 클릭한 상태에서 가능하다. 단축키는 ctrl + alt + Z | . | submit전에 DML을 눈알버튼으로 확인할 수 있다. | | F4 상태에서 fk(파란색열쇠)칼럼에 대해서 F12를 통해 관련된 pk테이블 row로 이동한다 | F4 상태에서 F12를 통한 pk row로 이동했다면, filter에 해당 pk가 필터링 되어있는데 c+s+a+ F를 통해 FILTER(WHERE)에 옵션을 추가해서 확인할 수 있다. | 일반 ctrl+F를 통해 데이터를 검색할 수 있으며, 정규표현식 / 찾은 데이터만 보기 / 검색 범위 넓히기 등이 가능하다. | . | . | alt + F12: table DDL을 팝업으로 띄운다. . | ctrl + LMB: table DDL로 간다. F12: table DDL로 간다. F4-fk칼럼에서 선택시 pk-row로 이동한다 | . | .",
            "url": "blog.chojaeseong.com/datagrip/settings/shortcut/2022/02/13/datagrip_settings_shortcut.html",
            "relUrl": "/datagrip/settings/shortcut/2022/02/13/datagrip_settings_shortcut.html",
            "date": " • Feb 13, 2022"
        }
        
    
  
    
        ,"post144": {
            "title": "생소한 윈도우 로고 단축키 모음",
            "content": "활용 . ctr + shift + win + {Num} : 작업표시줄에 올려진 프로그램을 관리자 권한으로 실행 | alt + win + {Num} : 작업표시줄에 올려진 프로그램에 우클릭 역활(최근 파일, 고정 파일 보기) . | win + m -&gt; win + shift + m : 현재창 최소화 -&gt; (작업) -&gt; 최소화 한 것 복구 | win + home -&gt; win + home : 현재창을 제외한 다른 창들 최소화 -&gt; (작업) -&gt; 최소화 한 것 복구 | win + , : 일시적으로 바탕화면 보기 . | win + ↓ : 현재 창 최소화 | win + shift + ↑: 세로 방향으로만 윈도우에 붙여 최대화 | win + shift + ↓ : 윈도우에 붙은 상태에서 붙기 전 모습 작은 창으로 복구 . | win + shift + ←, →: 윈도우 붙는 단위가 아닌 모니터별 창 이동시키기 . | win + ctrl + backspace: win + tab과 동일 기능 | . 설정 관련 . win + a : 윈도우 액션 설정 창(블루투스, 핫스팍 관련) . | win + i : 윈도우 설정 창 win + u : 접근성 설정 창 | . | win + k : 연결 장치(bluetooth) 검색 . | win + s : 작업표시줄 검색창 . | win + b + → → enter : 인터넷 액세스 상태 보기 | . 부가 기능 . win + alt + d : 달력(다이어리) 열기 | . 실행 명령어 . 실행 명령어 | 실행 폴더 | . 설정 . firewall.cpl: 방화벽 설정 열기 | sysdm.cpl: 시스템 속성 열기 고급 &gt; 환경변수 설정 | . | appwisz.cpl: 프로그램 등록/제거 . | mstsc: 원격 데스크톱 열기 | winver: 윈도우 버전 + 컴퓨터 계정명확인하기 | control userpasswords2 : 사용자 계정 | . 폴더 . %APPDATA%: 설정 폴더들 | %homepath% = %path% = %userprofile%: 사용자명 폴더(C: Users{username}) 유저명 얻기시에만 %homepath%로 통일하자. path는 탐색기 경로(ctrl+L)에서 안먹힌다. | username은 실행(ctrl+R)에서 안먹힌다. | homepath나 userprofile은 둘다 먹힌다. | . | /desktop : 바탕화면 | /downloads : 다운로드 폴더 | /anaconda3 : 아나콘다 폴더 가기 | . | %PROGRAMFILES(X86)% or %PROGRAMFILES%: 프로그램 폴더 . | %temp% : 임시파일들 | . 프로그래밍 . gcm 프로그램명: 프로그램(.exe?) 위치 찾기 Get-Command 프로그래명과 동일 | . | .",
            "url": "blog.chojaeseong.com/windows/shortcut/2022/02/12/windows_unfamiliar_command.html",
            "relUrl": "/windows/shortcut/2022/02/12/windows_unfamiliar_command.html",
            "date": " • Feb 12, 2022"
        }
        
    
  
    
        ,"post145": {
            "title": "powershell_vs_bashshell명령어",
            "content": "개요 . 출저 : 유튜브-드림코딩 . | 참고 : 티스토리 리눅스 명령어모음 블로그 . | 나는 Windows Terminal을 다운 받은 뒤, powershell vs wsl에서 실습하였다. . window의 powershell은 alias를 제공하여 unix shell과 비슷한 명령어를 사용할 수 있다. . . | . | 아직 많은 개발자들이 window를 사용함 . . | . powershell 최신버전 설치 . 링크 : https://docs.microsoft.com/ko-kr/powershell/scripting/install/installing-powershell-core-on-windows?view=powershell-7.1 | . powershell 권한 처리 for IDE(파이참에서 터미널 권한 안생기게) . Set-ExecutionPolicy . Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine . powershell history txt 삭제 . %UserProfile% AppData Roaming Microsoft Windows PowerShell PSReadline ConsoleHost_history.txt . powershell 자동완성(history 기반) . profile 스크립트를 열어서, 아래 줄을 추가한다. . notepad $profile . Import-Module PSReadLine Set-PSReadLineOption -PredictionSource History . | 저장후 프로파일을 reload하고 터미널을 껐다 킨다. . . $PROFILE . | 환경변수 (가상환경) . python가상환경 venv에서 activated한 상태로 적용 venv Scripts activate.ps1에 저장된다. | . | . 등록: . $env:FLASK_APP = &quot;run&quot; #export FLASK_APP=run $env:FLASK_DEBUG = &quot;1&quot; #export FLASK_APP=1 . 파일명은 “ “ 확장자를 뺀 쌍따옴표로 | linux의 export는 파일명에 쌍따옴표 없이 | . $env:FLASK_RUN_PORT = 8000 #export . | 확인 . Get-ChildItem Env: #export . Get-ChildItem Env: | Format-Table -Wrap . ## &#39;LOGONSERVER&#39; 환경변수를 찾고 싶다면, Get-ChildItem Env:LOGONSERVER ## &#39;on&#39;이 포함된 단어, ex) logONserver, ONedrive... Get-ChildItem Env:*on* ## &#39;on&#39;으로 시작하는 단어, ONedrive ... Get-ChildItem Env:on* ## &#39;on&#39;으로 끝나는 단어, ex) processor_revisiON ... Get-ChildItem Env:*on . | 기본 명령어 . man, clear . manual의 약자다. 잘 모를 때 참고하는 명령어 . man man . | Get-Help 명령어를 링크 해놓은 것이다. . | 청소해주는 명령어 . | . man clear clear . 파일 탐색 . pwd(경로 확인) . Print Woring Directory의 약자 | . explorer.exe .(경로상 탐색기열기) . mac에서는 open .을 사용한다. . | explorer가 아니라 explorer.exe .연다. . | . ls [하위폴더] (경로상 파일목록) . list의 약자 . | powershell에서는 mode까지 같이 나오는 반면, . powershell은 ls만 가능하다. ls -l등의 format활용은 X. 처음부터 다 보여준다. . | wsl/mac에서는 파일명만 나온다. . ls -al, ls -atl 등을 활용하면 mode까지 같이 출력된다. | . | . . | . ls . format for WSL2 . ls -l : long의 약자 . . | ls -a : all의 약자 . ui상에서는 보여주지 않는 숨겨진 폴더, 파일을 보여준다. | . . | ls -al : all(숨겨진) + long(mode까지) . . | . format for Powershell . powershell의 ls는 기본적으로 long모드로 보여주는 듯 했다. . | ls -name : 이름만 보고 싶을 때 . mac, wsl의 ls기본과 똑같다. | . | ls -force : 숨겨진 폴더, 파일을 보고 싶을 때 . . | . 폴더이동 . cd [./../-/~] . change directory의 약자 . . : 현재 경로. cd .는 제자리 이동. . | .. : 상위 경로 . | ~ : **현재설정된 사용자의 최상위 폴더 = home 디렉토리 ** . powershell에서도 cd ~를 하면, C: Users 사용자 | wsl에서 cd ~를 하면, root계정 : /root | 특정사용자 : /Users/사용자 | . | . . | - : 직전경로 . powershell은 cd -가 안된다. -&gt; 7.14버전으로 업데이트 해보는 중. . 7버전으로 업데이트하면 된다… . . | 대신, 직전경로 1번만 사용가능하며, 이후 C: 로 이동된다.. . | . | . | . | . 파일, 디렉토리 찾기 . find [경로] -type [f/d] -name “*.*” for shell . 입력한 경로부터 시작하여 하위까지 해당 파일or폴더를 찾는다. . 예시 . 나같은 경우 -type file , -type directory해도 안되길래, f, d로 약어로 넣으니 됬다. | permission denied나니까, 관리자 모드로 접속하자. | . find . -type d -name &quot;*flask*&quot; . find . -type f -name &quot;*.csv&quot; . | . | . 윈도우 폴더 탐색 (파워쉘 아닌 WindowTerminal) . - 윈도우 캡처 임시파일 저장 장소를 찾으려고 했었다. - /ad : directory 검색 - /s : 하위 폴더까지 검색 shell dir &quot;*폴더명*&quot; /ad /s . 파일 탐색 get-childitem for powershell . powershell에서는 사실상 안된다고 보면 된다. get-childitem -File -Filter &quot;*.txt&quot; -Recurse | . | . 프로그램 설치/설정 위치 . which for shell . 프로그램의 실행경로를 확인한다. . which node which code . | . gcm for powershell . get-command의 약자인 gcd를 이용한다. . | 경로는 창을 키워야 보임 . gcm node gcm code . | . 파일 생성 및 관리 . touch [파일명] (파일생성) . 존재하지 않으면, 파일 생성 | . man touch touch new_file1.txt . 이후 new_file1.txt를 열어 파일 | . new-item [파일명] for powershell . touch의 생성은 powershell에 없다. 하지만 cat, echo는 존재함. | . new-item new_file4.txt cat new_file4.txt . cat [파일] [파일2] (파일내용확인) . touch와 달리, powershell에도 사용가능함(alias존재) . | touch로 생성한 파일의 내용을 빠르게 확인 . 여러 파일을 동시에 쓰면, 붙혀서 string으로 확인됨. | . | . touch new_file2.txt cat new_file2.txt second line# cat new_file1.txt new_file2.txt first line 텍스트 추가second line# . echo “문자열” &gt;(») [파일] (&gt;파일생성+컨텐츠입력/ » 컨텐츠 추가) . 기본사용은 작성한 문자열을 터미널에 출력한다. (터미널에 에코~) 거의 사용안한다. | powershell에서도 사용가능하다. | &gt; [파일명]을 통해 파일생성+해당문자열을 컨텐츠로 넣어줌(덮어쓰기) | . echo &quot;third line&quot; &gt; new_file3.txt cat new_file3.txt third line . echo &quot;third line&quot; &gt; new_file3.txt cat new_file3.txt third line . &gt;&gt; [파일명] : 파일생성+덮어쓰기가 아니라 기존파일에 컨텐츠 append개념이다. | . echo &quot;third line--&quot; &gt;&gt; new_file3.txt cat new_file3.txt third line third line-- . 디렉토리 생성 . mkdir -p [폴더/하위폴더/하하위폴더] . make directory의 약자, 폴더 = 경로를 생성하는 명령어 | powershell 공용 | . mkdir dir1 ls -al . -p 옵션을 주면서 하위폴더들을 /로 연결하여 줄줄이 생성할 수 있다. | . mkdir -p dir2/subdir1/subdir2 ls dir2 subdir1 ls dir2/subdir1 subdir2 . 파일관리 cp/mv/rm . 3가지 다 powershell에서 사용가능 | . cp [파일] [원하는 경로/]or[새파일명] . copy의 약자 | . mv [파일] [원하는 경로/]or[새파일명] (파일이동/이름변경) . 이름바꾸는 것도 mv로 하는구나. . mv new_file2.txt file2.txt ll . | . rm [삭제파일명] / rm -r [디렉토리명] . -r 이라는 recursive옵션을 주면 디렉토리삭제+하위경로도 삭제 2가지 역할을 해주게 된다. 파일삭제는 rm 파일명 | 디렉토리삭제는 rm -r 디렉토리명 | . | . rm new_file4.txt rm -r dir3 . rm [디렉토리] 후 선택 / rm [디렉토리] -Recurse . 이부분 만 shell과 다름. | 그냥 rm하면 경고창(wsl)없이 선택화면이 나온다. 디렉토리를 선택하면됨. | 디렉토리 빠르게 삭제는 -r 옵션을 중간에 주는게 아니라 마지막에 -Recurse powershell에서도 마지막에 -r 줘도 삭제되는 듯 싶다. | . | . Grep (select-string) . Global regular expression print 의약자. . | 파일에서 검색 or *를 활용한 프로젝트 전체폴더에서 검색 . | . grep “검색문자열” [파일명] . grep &quot;line&quot; *.txt file2.txt:second line new_file1.txt:first line new_file3.txt:third line new_file3.txt:third line-- . grep -n : 라인정보 같이출력 . 찾은 것이 몇번째 라인에 있는지까지도 같이 출력 | . grep -n &quot;line&quot; *.txt file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . grep -ni : 대소문자상관없이 검색후 라인정보출력 . -i : intensive 옵션을 주면 대소문자 상관없이 검색하라는 말이다. | . grep -ni &quot;LINE&quot; *.txt file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . grep -nir “문자열” . : 프로젝트최상경로에서 하위끝까지 전체를 검색 . grep -nir &quot;LINE&quot; . ./file2.txt:1:second line ./new_file1.txt:1:first line ./new_file3.txt:1:third line ./new_file3.txt:2:third line-- . select-string [파일명] -pattern “검색문자열” . default로 대소문자상관없이 + 라인정보도 같이 출력된다. . select-string *.txt -pattern &quot;LINE&quot; file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . | . select-string [*, */*] -pattern “검색문자열” . -ni는 자동이고, -r 옵션은 없어서 직접 *와 ,를 연결한 경로를 지정(경로패턴)해줘야 전체 프로젝트 검색이 된다. | . select-string *, */* -pattern &quot;LINE&quot; file2.txt:1:second line new_file1.txt:1:first line new_file3.txt:1:third line new_file3.txt:2:third line-- . 대소문자를 구분하고 싶다면, 맨 뒤에 -CaseSensitive옵션을 주면 된다. | . 환경변수 설정 . 모바일, 웹 개발시 환경변수를 설정함 | 내 컴퓨터에서 특정한 키워드가 어떤 일을 하거나 경로를 저장할 수 있게 만드는 것. | . env . 지정한 환경변수 목록을 본다. 사용시에는 앞에 $를 붙인다. . env . | . ls env: . powershell에서 보는 환경변수목록. 사용시에는 $env:를 앞에 붙인다. . ls env: . | . export [대문자_변수명]=”경로or문자열” (환경변수 설정) . 대문자를 사용하고 사이에는 _를 이용하여 구분한다. . mkdir dir1 env # 모든 환경 변수 확인 export MY_DIR=&quot;dir1&quot; . | . $env:[환경변수명] = “경로or문자열” for powershell . $env:MY_DIR = &quot;dir1&quot; . cd $환경변수명 (환경변수 사용) . 환경변수를 터미널 등에서 사용할 수 있다. . cd $MY_DIR pwd . | . cd $env:[환경변수명] for powershell . unset 환경변수명 (환경변수 삭제) . unset MY_DIR env . $env:[환경변수명] = “” . powershell에서 환경변수 삭제는 빈 문자열을 넣어서 없애준다. . $env:MY_DIR = &quot;&quot; ls env: . | .",
            "url": "blog.chojaeseong.com/shell/powershell/windowsterminal/terminal/windows/command/2022/02/12/powershell_and_bashshell.html",
            "relUrl": "/shell/powershell/windowsterminal/terminal/windows/command/2022/02/12/powershell_and_bashshell.html",
            "date": " • Feb 12, 2022"
        }
        
    
  
    
        ,"post146": {
            "title": "fastpages change index.html",
            "content": "참고블로그 및 깃허브 이분은 옛날 버전인 것 같으며, index.md로 paginationd이 작동한다. | 그러나 내 버전의 _config.yml은 md파일을 html파일로 수정하라고 명시하고 있다. | . | . index.md를 posts pagination을 제공 안함. . index.md를 사용하면, 아래 posts의 pagination이 안된다고 _config.yml에 명시되어있었다. 그래서 index.md로 빌드는 되니, 빌드후 html소스를 복붙해서 index.html로 옮기는 방식으로 꾸미려고 한다. | . | index.html을 삭제한 상태에서 main으로 빌드 되어 표기는 되더라. | . index.html -&gt; index_backup.html로 빼놓기 . root에 index.html이 존재하면, index.md이 반영이 안되어 백업해놓는다. | . index.md 생성 후 내용 채워 push . 나름의 시행착오 끝에 완성한 index.md(생성해야함.) | . layout: home search_exclude: true ![](/images/logo_github.png &quot;로고&quot;){: style=&quot;float: right; margin-left: 20px&quot; width=&quot;180&quot;} ## I&#39;m... 평범한 한의사 `돌아온범생`의 우아한 엔지니어 도전기를 기록합니다.&lt;br/&gt; &lt;br/&gt; 조재성 Jaeseong Cho | &lt;br/&gt; Doctor of Korean Medicine, Currently studying SW engineering and biostatistics&lt;br/&gt; [more...](/about) ## Posts . markdown에서 이미지를 float시키는 방법 참고해보자. . !()[]{: style=&quot;float: right; margin-left: 20px&quot; width=&quot;180&quot;} . | . . . 블로그 -&gt; 소스보기 -&gt; html코드로 복붙 . &lt;main class=&quot;page-content&quot; aria-label=&quot;Content&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;home&quot;&gt;&lt;p&gt;&lt;img src=&quot;/images/logo_github.png&quot; alt=&quot;&quot; title=&quot;로고&quot; style=&quot;float: right; margin-left: 25px&quot; width=&quot;200&quot; /&gt;&lt;/p&gt; &lt;h2 id=&quot;iam&quot;&gt;I’m…&lt;/h2&gt; &lt;p&gt;평범한 한의사 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;돌아온범생&lt;/code&gt;의 우아한 엔지니어 도전기를 기록합니다.&lt;br /&gt; &lt;br /&gt; 조재성 Jaeseong Cho | &lt;br /&gt; Doctor of Korean Medicine, Currently studying SW engineering and biostatistics&lt;br /&gt; &lt;a href=&quot;/about&quot;&gt;more…&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;posts&quot;&gt;Posts&lt;/h3&gt; . . index.html 부활시키기 + md는 삭제 . . . layout: home search_exclude: true image: images/logo_github.png &lt;main class=&quot;page-content&quot; aria-label=&quot;Content&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;home&quot;&gt;&lt;p&gt;&lt;img src=&quot;/images/logo_github.png&quot; alt=&quot;&quot; title=&quot;로고&quot; style=&quot;float: right; margin-left: 25px&quot; width=&quot;200&quot; /&gt;&lt;/p&gt; &lt;h2 id=&quot;iam&quot;&gt;I’m…&lt;/h2&gt; &lt;p&gt;평범한 한의사 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;돌아온범생&lt;/code&gt;의 우아한 엔지니어 도전기를 기록합니다.&lt;br /&gt; &lt;br /&gt; 조재성 Jaeseong Cho | &lt;br /&gt; Doctor of Korean Medicine, Currently studying SW engineering and biostatistics&lt;br /&gt; &lt;a href=&quot;/about&quot;&gt;more…&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;posts&quot;&gt;Posts&lt;/h2&gt; .",
            "url": "blog.chojaeseong.com/fastpages/2022/02/12/fastpages_%EB%A9%94%EC%9D%B8%ED%99%94%EB%A9%B4%EB%B0%94%EA%BE%B8%EA%B8%B0.html",
            "relUrl": "/fastpages/2022/02/12/fastpages_%EB%A9%94%EC%9D%B8%ED%99%94%EB%A9%B4%EB%B0%94%EA%BE%B8%EA%B8%B0.html",
            "date": " • Feb 12, 2022"
        }
        
    
  
    
        ,"post147": {
            "title": "전략,팩토리,싱글톤,hasNext,isEmpty",
            "content": "전략패턴 for 대체를 [테스트에서 상수]로 . 전략패턴은 전략을 사용자가 선택해서 상황에 맞는 행동을 하게 할때 주로 사용 필요시 다른 환율적용한 계산 반영 | 해쉬값 생성시 알고리즘을 다르게 적용 | 다른 적용 전략으로서 [랜덤값 포함 조건문] -&gt; [()- &gt; true] 테스트에 적용 여기서는 랜덤값을 -&gt; 테스트용 상수로 적용하기 위해서, 랜덤값 포함 조건문에 전략패턴을 건다 | . | 예시 코드 블로그(노션) | . | . 바뀔 수 있는 부분을 잡아서 상태에 맞게 메소드로 추출해놓는다. . 해당메소드는 인터페이스 impl 구상클래스로 갈 것이다. . public void move() { if( Util.generateRandomNumber() &gt;= 4 ){ this.position++; } } . public void move() { if(isMovable()){ this.position++; } } private boolean isMovable() { return Util.generateRandomNumber() &gt;= 4; } . | . | 인터페이스 XXXXStrategy + 이름만 가진 추상메서드를 만든다. . 랜덤한 조건문이 -&gt; 테스트용으로 대체될 예정이라면 -&gt; boolean등 반환형 + 추출한 메서드를 추상메서드로 이름만 정의한다 | . public interface MoveConditionStrategy { boolean isMovable(); } . | 특정Strategy의 이름을 정해서 impl구상클래스를 추출메소드를 복붙해서 구현한다. . public class RandomMoveConditionStrategy implements MoveConditionStrategy{ @Override public boolean isMovable() { return false; } } . public class RandomMoveConditionStrategy implements MoveConditionStrategy{ @Override public boolean isMovable() { return Util.generateRandomNumber() &gt;= 4; } } . | 특정전략의 메소드가 사용된 곳마다 —&gt; 다른전략을 허용하는 추상화된 인터페이스 객체를 인자로 받은 뒤 -&gt; 추상체.추출메소드()호출로 수정한다. . public void move() { if(isMovable()){ this.position++; } } . public void move(MoveConditionStrategy moveConditionStrategy) { if(moveConditionStrategy.isMovable()){ this.position++; } } . | 이제 에러난 부분을 타고가면서, 내부 매개변수 정의에 사용된 추상 인자를 호출하는 외부 인자 자리에 new 특정전략()를 넣워준다. . 여기서는 매 car마다 랜덤 전략이 각각 적용되어야하는 부분 -&gt; 특정전략을 인자로 넣어준다. | . public void move() { this.cars.forEach(car -&gt; car.move()); } . public void move() { this.cars.forEach(car -&gt; car.move(new RandomMoveConditionStrategy())); } . | 테스트에서 다른전략으로 조건부의 상수인 람다함수로 () -&gt; true를 대입하여 움직임을 확인한다. . 랜덤이 섞인 기능은 테스트하기 힘들다 -&gt; 전략자리로 바꿔서 항상 같은 값인 상수를 들어가게해서 다른 기능을 테스트한다. | . @Test void 자동차_움직임() { Car js = Car.of(&quot;js&quot;); // +1 움직임의 조건부를 &lt;다른전략 사용가능한 전략패턴&gt;으로 정의했으니 -&gt; 특정전략을 넘겨 결정한다. RandomMoveConditionStrategy randomMoveConditionStrategy = new RandomMoveConditionStrategy(); js.move(randomMoveConditionStrategy); js.move(randomMoveConditionStrategy); js.move(randomMoveConditionStrategy); js.printPosition(); // 전략자리-랜덤조건부 대신&gt; [다른전략으로서 람다함수 상수로서 true]로 줘버릴 수 있다. // -&gt; 테스트용으로 항상 움직임을 확인할 수 있다. Car jk = Car.of(&quot;jk&quot;); jk.move( () -&gt; true); jk.move( () -&gt; true); jk.move( () -&gt; true); jk.printPosition(); } js의 위치: 0 jk의 위치: 3 . | 정적 팩토리 메소드 네이밍 컨벤션 . from: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메소드 ex) Date d = Date.from(instant); | Of: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메소드 ex) Set faceCards = EnumSet.of(JACK, QUEEN, KING); | valueOf: from과 of의 더 자세한 버전 ex) BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);; | instance 혹은 getInstance: 매게변수를 받는다면 매게변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다. ex) StackWalker luke = StackWalker,getInstance(options); | create 혹은 newInstance: instance 혹은 getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장한다. . | 참고: 생성자내부에서만 this.필드 = 할당이 가능함. 팩토리 메서드는 변환or검증만 | . 싱글톤 패턴(관리자Machine, InputView스캐너) . //1. class내부에 default생성자로 static finale 객체를 미리 생성해놓는다 -&gt; for getInstance시 반환할 수 있게 미리 생성 private static final $CLASS_NAME$ $VALUE_NAME$ = new $CLASS_NAME$(); //2. 차후 입력시, 싱글톤이 받아서 [관리하는 데이터]를 쌓아둔다. //private Cars cars; //3. 싱글톤 private생성자는 미리 생성해야해서 매개변수 없이 default생성자로 만든다. private $CLASS_NAME$() { } //4. 관리자로서 [관리 데이터]를 매 구동시 초기화 할 수 있게 한다. public void init() { // this.cars = new ArrayList&lt;&gt;(); } //5. 싱글톤은 언제든지 부르면 나갈 수 있게 public static getInstance()메소드르 ㄹ정의한다. public static $CLASS_NAME$ getInstance() { return $VALUE_NAME$; } . //1. class 내부에 default? 생성자로 미리 static final 객체 생성 private static final Scanner scanner = new Scanner(System.in); //2. 싱글톤scanner(getInstance) + .nextLine() &gt; getInput()으로 싱글톤 + 메서드까지 사용 public static String getInput() { return scanner.nextLine(); } . 값객체.hasNext()패턴 . if 남은수 0보다 큰지 물어본다 0보다 크면 1빠진 값객체로 재할당받고 | true를 return해서 바깥 반복문이 계속 돌아가게 한다. | . | 남은수가 0보다 같거나 작으면 false를 return해서 바깥 반복문에 진입을 막는다. | . | public boolean hasNextGame() { if (this.gameCount.moreThanZero()){ this.gameCount = this.gameCount.next(); return true; } return false; } //... public boolean hasNextGame() { return count &gt; 0; } public Count next() { return new Count(this.count - 1); } . isEmpty &lt; isBlank . isEmpy: &quot;&quot;의 빈값 | isBlank: &quot;&quot;를 포함하여 &quot; &quot;까지 다 True되는 넓은 범위 | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/11/%EC%A0%84%EB%9E%B5,-%ED%8C%A9%ED%86%A0%EB%A6%AC,-%EC%8B%B1%EA%B8%80%ED%86%A4,-hasNext,isEmpty.html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/11/%EC%A0%84%EB%9E%B5,-%ED%8C%A9%ED%86%A0%EB%A6%AC,-%EC%8B%B1%EA%B8%80%ED%86%A4,-hasNext,isEmpty.html",
            "date": " • Feb 11, 2022"
        }
        
    
  
    
        ,"post148": {
            "title": "TDD 1 문자열계산기",
            "content": "TDD . red -&gt; green -&gt; refactoring . 실패하는 코드(red)부터 짠다. . 테스트코드부터 짠다. | 프로덕션 코드를 생성하지 않은 체로 작성하면서 생성한다. | given(data), when(actual), then(assert문)의 순서로 짠다. | 최초 에러를 내기 위해 throw new IllegalStateException();를 활용한다. | | green을 만들 때는, 모든case 통과 풀 구현이 아니라, (현재까지의 테스트를 모두 만족시키는) 최소한의 최소한의 수정만 한다. . 예를 들어 expected 1을 만족시키는 코드를 짤 때 . return Integer.parseInt(&quot;1&quot;);이 아닌 return 1;으로 짜야한다. | . | 임의의 1개 case가 아닌 다양한 expected를 만족시켜야할 경우, assert문을 여러개 짜지말고, @Test메서드를 늘려서 2번째부터는 일반화시키는 풀구현을 하자. . @Test void splitAndSum_숫자하나() { final int actual = StringCalculator.splitAndSum(&quot;1&quot;); assertThat(actual).isEqualTo(1); //assertThat(actual).isEqualTo(2); } // assert문 추가가 아니라 테스트를 추가한다. @Test void splitAndSum_숫자하나_2() { final int actual = StringCalculator.splitAndSum(&quot;2&quot;); assertThat(actual).isEqualTo(2); //에러를 고치려면 어쩔 수 없이 2번째부터는 일반화된 풀 구현 } . | . | refactoring은 . 메서드 추출 시, 새롭게 추출된 메서드의 관점에서 인자를 수정할 수 도 있다. . 대상: indent를 늘리는 반복문을 포함한 부분 or 다른 일을 하는 곳 . 참고: method refactoring | . | 인자에 final을 달아서 엄청 긴 코드의 끝에서도 안심하고 사용할 수 있게 해보자. 요즘 언어들은 불변을 default로 한다고 한다. . | 매개변수의 이름도 바뀌어야한다 splitValues -&gt; values . //private static int sum(String[] splitValues) { private static int sum(String[] values) { int result = 0; for (String value : values) { result += Integer.parseInt(value); } return result; . | . | . | 복잡한 요구사항 -&gt; 쪼갠 학습테스트 활용 . 예를 들어, 문자열을 커스텀 문자열로 split -&gt; sum 을 구해야하는데, 일단 split부터 되도록 학습테스트를 작성한다. . 요구사항 . @Test void splitAndSum_custom_구분자() { final int actual = StringCalculator.splitAndSum(&quot;//; n1;2;3&quot;); assertThat(actual).isEqualTo(6); } . | 단계별 학습테스트 추가 1 . 쪼갰을 때 나와야하는 값을 expected로 생각하고 테스트하면 된다. | . @Test void split() { // given final String text = &quot;//; n1;2;3&quot;; // split해보고 -&gt; **내 기준에서 나와야하는 값(**이게 나와야한다**)을 &lt;expected&gt;자리에 넣고 테스트해본다.** // when String[] splitValues = text.split(&quot; n&quot;); assertThat(splitValues[0]).isEqualTo(&quot;//;&quot;); // 앞부분에서 나와야하는 값이 통과했다면, -&gt; 뒷부분도 테스트 코드를 추가해서 돌려본다. assertThat(splitValues[1]).isEqualTo(&quot;1;2;3&quot;); } . | 단계별 학습테스트 추가2 . 잘 쪼개졌어도, 구분자가 기존 코드와는 다른 경우이므로, if 검사 후 -&gt; ealry return 로직을 추가해야하는 상황이다. 특정 경우를 잘 골라내는지 boolean이 expected로 되는 학습테스트를 추가하자. | . | . @Test void startsWith() { //given // data -&gt; &quot;//&quot;로 시작하는지를 확인하는 학습테스트를 만든다. final String text = &quot;//; n1;2;3&quot;; //when // actual -&gt; 슬래쉬 2개로 시작하는 커스텀이냐? boolean isCustom = text.startsWith(&quot;//&quot;); //then // expected -&gt; 나와야하는 값 = true assertThat(isCustom).isTrue(); } . | 학습테스트 통과한 코드를 —&gt; 프로덕션 코드에 반영하자 . | . | . 일부분 수정(private함수or 코드) TDD -&gt; 영향받지 않게 복붙메서드 활용 . [private ] 특정함수 수정 TDD -&gt; Test에 [특정함수]만 복붙 . 요구사항: 음수 -&gt; 예외발생시키세요. -&gt; split한 리팩토링으로 splitAndSum 중 private sum()함수만 TDD해야한다. . Test클래스로 private함수를 복붙해온다. . 복붙을 한 순간, 기존 코드에 영향주지 않는 코드가 된다. | XXX.sum() -&gt; XXXTest.sum()으로 사용해서 테스트할 예정이다. | . | 전체 메서드(splitAndSum)중 일부분(sum())만 가져왔으므로 테스트 호출 메소드도 달라질 것이다. . 기존 전체메서드 테스트 가정 (나중에 완성될 테스트) . @Test void splitAndSum_negative() { assertThatThrownBy(() -&gt; StringCalculator.splitAndSum(&quot;-1,2,3&quot;)) .isInstanceOf(RuntimeException.class); } . | 일부분(전체에 비해 인자 달라짐) 메서드 테스트 ( Test로 복사해온 private함수라 XXXXTest.sum() ) . void sum_negative() { // sum(&quot;-1,2,3&quot;); // sum(&quot;-1,2,3&quot;.split()) // StringCalculatorTest.sum(&quot;-1,2,3&quot;.split(&quot;,&quot;)); assertThatThrownBy(() -&gt; StringCalculatorTest.sum(&quot;-1,2,3&quot;.split(&quot;,&quot;))) .isInstanceOf(RuntimeException.class); } . | Test코드로 복붙해온 일부분 메서드( 이놈을 수정해서 구현후 반영할 예정 ) . private static int sum(String[] values) throws RuntimeException { int result = 0; for (String value : values) { result += Integer.parseInt(value); } return result; } . | . | 예외처리 로직을 중간에 추가 by 변수 추출 . 좌항 = 우항 으로 우항이 할당되기 전 &lt;if 예외처리&gt;로직 추가를 위해서 변수 추출(Ctrl+Alt+V)을 활용한다. . result += Integer.parseInt(value); //우항이 넘어가기 전에 받아준다. int number = Integer.parseInt(value); result += number; int number = Integer.parseInt(value); // 우항이 넘어가기전에 받아 예외처리를 해준다. if (number &lt; 0) { throw new RuntimeException(); } result += number; . | . | 테스트통과시 복붙한 sum()메서드를 -&gt; 원본에 반영 + 원본 테스트함수 돌려보기 . 끝난 코드는 날리는게 맞다. | . | | . [public ] 특정[코드] TDD -&gt; 바로 밑에 [코드포함 222메서드 함수] 복붙 . 예를 들어, 어느정도 완성된 public splitAndSum() 메서드에서 text==null이외에 text.isEmpty() 검사를 추가하고 싶다. 하지만, 이미 다른 코드들과 섞여있는 일부분의 코드이므로 다른 코드에 영향주지 않게 테스트하려고 한다. . 코드를 포함한 메서드 복사 붙혀넣기를 통해 기존 코드 영향 받지 않는 메소드2를 새롭게 생성해서 테스트한다. . // 기존 메소드 public static int splitAndSum(final String text) { if (text == null) { return 0; } return sum(split(text)); } // if 조건에 .isEmpty()를 추가할 예정인데 -&gt; sum(split(text)))가 섞여있으므로 // 코드 수정시 영향이 갈 수 있다. // -&gt; 포함 메서드를 통째로 복붙한 메서드2로 테스트한다. // 대신 테스트할 메서드2 public static int splitAndSum2(final String text) { if (text == null || text.isEmpty()) { return 0; } return sum(split(text)); } . | 메서드2로 테스트하는 테스트메서드를 생성한다. . 기존 null테스트에서 인자 + expected(나와야할 값) + 복붙한 메서드2()로 이름 바꾸기 | . //splitAndSum2 를 테스트 @Test void splitAndSum_emtpy() { final int actual = StringCalculator.splitAndSum2(&quot;&quot;); assertThat(actual).isEqualTo(0); } . | 테스트가 완료되면 수정된 일부 코드만 기존함수에 반영하고, 222메서드랑 테스트는 날린다. . if (text == null || text.isEmpty()) . | . | . 그외 . assertThat()을 여러게 사용하지마라 -&gt; 테스트를 그만큼 만들다보면 일반화 혹온 @ParameterizedTest활용 | . | 테스트메서드는 영어로 대충 짓고 -&gt; @DisplayName()으로 한글을 제대로 적어주자. | private함수를 Test에 복붙해서 테스트하는 것외에 접근제어자를 지워 default로 만들어서 테스트할 수 도 있다. | 메서드명은 snake_Case를 써도 된다. | . 상수화 네이밍 . 검증시 if ~ thr로직 -&gt; checkXXXX . | index들 -&gt; CASE_CASE2_INDEX / 구분자 -&gt; CASE_CASE2_DELIMITER . if (text.startsWith(&quot;//&quot;)){ String[] splitValues = text.split(&quot; n&quot;); String delimiter = splitValues[0].substring(2); String customText = splitValues[1]; return customText.split(delimiter); } if (text.startsWith(CUSTOM_PREFIX)){ String[] splitValues = text.split(CUSTOM_DELIMITER); String delimiter = splitValues[CUSTOM_DELIMITER_INDEX].substring(CUSTOM_PREFIX.length()); String customText = splitValues[CUSTOM_TEXT_INDEX]; return customText.split(delimiter); } . | 특정문자열 다음에 나오는 문자열 추출 -&gt; substring( 특정문자열.length() ) . 예를 들어, “//;”에서 ;를 추출하고 싶다면? | ”//;”.substring( “//”.length()) text.substring( CUSTOM_DELIMITER_PREFIX.length() ) | . | . | assert문을 여러개하지말고, 테스트를 추가하다보면, 일반화할 수 밖에 없다. . | . 강타입 vs 약타입 . 강타입 : 자료형이 맞지 않을 시에 에러 발생, 암묵적 변환을 지원하지 않음 | 약타입 : 자료형이 맞지 않을 시에 암묵적으로 타입을 변환하는 언어 | . 정적타입 vs 동적타입 . 정적타입 언어 : 정적타입 언어는 컴파일 시에 변수의 타입이 결정되는 언어를 의미한다. | 동적타입 언어 : 동적타입 언어는 런타임 시 자료형이 결정되는 언어를 의미한다. | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/11/TDD-%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%84%EC%82%B0%EA%B8%B0_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/11/TDD-%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%84%EC%82%B0%EA%B8%B0_%EC%A0%95%EB%A6%AC(%EC%99%84).html",
            "date": " • Feb 11, 2022"
        }
        
    
  
    
        ,"post149": {
            "title": "DTO와 VO를 비교",
            "content": "DTO vs VO . 참고 사이트 테크톡1 | 테크톡2(인비) | 포모 블로그 | . | . 혼용 사례 . 특정 책 1판에 의해서 사람들이 잘못 인지하게 됨. 지금은 데이터 전달은 TO + Data -&gt; DTO로만 사용 | VO = 값 표현용 | . | . DTO(Data Transfer Object) . DTO는 프로세스 간에 데이터를 전달하는 객체 | 주로 비동기 처리를 해야할 때 사용 | 로직을 갖고 있지 않은 순수한 데이터 전달객체라 setter(보내는쪽)/getter(받는쪽)로만 구성되는데, DB에서 값을 받아오므로 setter가 없이. 생성자에서 값할당한 이후 끝. . | 정확히는 계층간 데이터 전달 객체 Controller(웹)와 Service(서비스)사이에 데이터 전달용으로 사용된다. | . | . 예시를 통한 DTO 학습(CrewDto) . . service layer에서 데이터를 보낼 때 (받는 쪽에서 사용하라고 정의만) . createXXX()메서드를 통해 DTO생성 + Dto에 정의한 setter()로 데이터 박아로 데이터전달`을 수행한다. | . | controllerlayer(웹 레이어)에서 데이터를 받을 땐 . **service에 정의해둔 createXXX()메서드를 통해 -&gt; ** 데이터박힌 DTO 생성 | DTO.getter로 데이터들 받기 | . | . | setter를 제거하고 생성자로만 데이터를 받아 생성된 불변의 DTO주도록 수정 . setter를 삭제한다 -&gt; VO처럼 불변객체가 됨 -&gt; 데이터 전달과정 시 불변성 보장 -&gt; 안정적 | . . | . Entity와 분리 . . View는 요구사항에 의해 자주 변경되는 부분이다. entity기준으로 테이블 생성/ 스키마변경하는 class -&gt; 요청/응닶값 전달 클래스로 사용하지 말 것 view변경시마다 entity도 매번 변경해야함. | 관련된 수많은 비지니스 로직(class)들이 영향을 끼치게 됨. | . | view변경에 따라 -&gt; 다른 class에 영향을 끼치지 않는 DTO class를 요청/응답값에 사용 join한 결과값 조회 -&gt; entity로는 다 표현X | . | . | . 예시(로또, Car 정의) . 예시 - 로또 . | 예시 - Car . class CarDTO { private String name; private int position; } . 생성이후 OutputView로 가공된 DTO 객체를 보내줄 수 있습니다. | . | . 특징 . 데이터 접근 메서드만 가진다. | 정렬과 직렬화 메서드는 가질 수 있다. | 데이터 캡슐화 -&gt; 유연하게 대응된다. 데이터 요청수 감소 효과 | . | VO(Value Object) . 값 객체 | VO의 핵심은 equals()와 hashcode()를 오버라이딩하하여 내부에 선언된 속성(필드)의 모든 값들이 같으면 &gt; 똑같은 객체라고 판단하게 한다 | 원시 값을 감싼다 -&gt; validation이 가장 큰 역할 중 하나 my) 식별자로 접근해야 데이터 변화에 대응한다 | . | . 예시를 통한 VO 학습(Money) . 고유번호 = 내부 값이 같으면 -&gt; 같은 객체 . | Money class . . VO는 값 자체 표현 = DTO처럼 불변 객체 DTO처럼, setter성격의 메소드 X 생성자로서만 초기화 | VO는 DTO와 달리 getter이외에 로직을 포함 ex&gt; getHalfValue | . | . | 일반적인 객체 -&gt; equals비교와 hashCode비교가 불일치로 나온다. . . | 완전한 VO를 위하여 . hashCode()의 return값 비교 -&gt; 같으면 equals()로 한번더 비교 . | 완전한 VO == 객체를 속성값으로만 비교하게 하기 위해 -&gt; 2개 메소드 오버라이딩 . 속성값인 value로만 비교할 수 있게 된다. | . . | . | . 예시(Car) . Car - 움직임이 있다면( 내부 속성이 변함) -&gt; new 새로운 객체로 반환하여 -&gt; 원래 자기가 가지던 값은 변하지 않고 -&gt; 변한 것은 다른 값 객체로 취급 . 내부속성 변화가 없다면 (움직이지않았다면) -&gt; 자기자신 반환 return this; | . public Car move(int randomNum) { if (randomNum &gt;= MOVE_POINT) { return new Car(this.name, position+1) } return this; } . | . 특징 . 값 자체로 의미를 가진다. . | 변하지 않는 값을 가진다 . 불변 보장(변하면 새객체)해서 안전성과 생산성 | . | 객체 비교시 ID를 사용하지 않음 . | 같은 객체로는 속성들의 값을 비교한다. . | DTO와 VO공통점과 차이점 . DTO: 레이어간 데이터 전달을 위함 객체 동등비교시, 속성값 같다고 같은 객체 아니다. | setter를 넣어준다면 가변, 보통 불변 | getter/setter외 로직X | . | VO: 값 자체 표현 객체 동등비교시, 속성값 같으면 같은 객체 by 오버라이딩 | setter없이 생성자로 초기화하는 불변 | getter/setter외 로직을 가질 수 있다. | . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/11/DTO-vs-VO(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/11/DTO-vs-VO(%EC%99%84).html",
            "date": " • Feb 11, 2022"
        }
        
    
  
    
        ,"post150": {
            "title": "method refactoring",
            "content": "메소드관련 리팩토링 . . . 01 메서드 추출로 [for indent] 제거 . . indent는 메서드 분리로 해결한다. . . | . 02 early return으로 [else] 제거 . else 제거 by early return . . | . . 03 메서드 분리 -&gt; [일을 1가지씩 순차적으로] . 1가지 일만하도록 메서드 분리 convert(문자열[]-&gt; 숫자[] ) + 누적합sum | . | . . . 보기 좋음 »&gt; 약간의 성능저하 | . 04 로컬변수 제거 -&gt; [ line 줄이기] . . . 05 compose method 패턴 -&gt; [조건문 보기 좋게] . 조건문에 적용: https://wooyaggo.tistory.com/34 | 심화: https://mygumi.tistory.com/343 | . . 조건문을 의도를 가진 메서드로 바꾼다 -&gt; 파라미터의 type이나 조건이 바뀔 때 사용된 조건문을 일괄해서 바꿀 수 있다. | . . 읽기좋게 레벨 맞추기 . . | 비교 . . | .",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/10/method_refactoring(%EC%99%84).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/10/method_refactoring(%EC%99%84).html",
            "date": " • Feb 10, 2022"
        }
        
    
  
    
        ,"post151": {
            "title": "코드리뷰 방법 1단계 및 피드백",
            "content": "개별 셋팅 . 관리자 짝 매칭 실시 . 관리자 매칭 실시 . | 피매칭자은 확인함. . | . 원본레포에 각 github_id br 생성 . lecture클릭후 미션시작 클릭시 -&gt; 자동으로 내 github_id로 —&gt; 미션repo에 브랜치생성 | 미션시작으로 내 브랜치를 생성하면, 리뷰어도 자동 배정된다. ) 동시성 잇슈가 있을 땐, 관리자가 리뷰어를 재배정한다. | . | 저장소로 와서 내 github_id로 생성된 branch가 정상 생성되었는지 미션repo에 branch 검색해서 확인한다 . . | 원본레포 각 fork . 강의홈페이지를 통해 branch가 생성되었으나 팀원X push권한 X -&gt; fork를 먼저 한다. 문서를 보면서 스텝바이스텝으로 한다. | 여기선 1단계까지만 한다. 코드리뷰 요청 1단계: 미션 진행 후 github에 올리는 단계 | 코드리뷰 요청 2단계: 코드리뷰 요청을 보내고, 피드백을 받은 후 피드백 반영 및 merge하는 단계 | 코드리뷰 요청 3단계: 다음 단계 미션을 위해 준비하는 단계 | . | 이렇게 권한은 없지만 [강의홈페이지를 통한 원본repo에 이름만 내 github_id branch]가 생성된 상태로 -&gt; fork한다. fork가 내 계정으로 잘되어있어야한다 | . | fork를 해도 기존 원본repo의 모든 branch들이 다 fork되어있다. 기본 main으로 되어있다. | . | github_id single-branch만 clone . fork는 모든 branch그대로 보유 —&gt; clone을 통해서 로컬로 가져올 때는 --single-branch만 가져오는 것이 가능하다. . 현업에서는 10개이내 branch이므로 git clone -b [branch명] --single-branch [fork한 레포명]가 필요가 없다 . | 내 이름의 branch가 main브랜치다. | . git clone -b {본인_아이디} --single-branch https://github.com/{본인_아이디}/{저장소 아이디} ex) git clone -b javajigi --single-branch https://github.com/javajigi/java-baseball.git . git clone -b is2js --single-branch https://github.com/is2js/java-racingcar.git intellij 터미널에서 작업하면 된다. | . | . PS C: Users cho_desktop IdeaProjects missions&gt; git clone -b is2js --single-branch https://github.com/is2js/java- racingcar.git . | ​ - . intellij에서 clone한 폴더를 open한다 내 이름의 싱글브랜치만 가져와지는지 확인한다. | . | step1 br(작업 br) 생성 . git checkout -b step1으로 첫번째 리뷰용 브랜치를 만든다. . –single-branch clone 한 입장에서 , 내 id_branch -&gt; main브랜치 | 작업할 branch -&gt; step1 -&gt; ... . | cf) **git alias는 집착해서 알아야한다.-&gt; ** . gco main = git command . | gba = git branch -a . # windows git alias git config --global alias.co checkout git config --global alias.ci commit git config --global alias.st status git config --global alias.br branch git config --global alias.hist &quot;log --pretty=format:&#39;%h %ad | %s%d [%an]&#39; --graph --date=short&quot; git config --global alias.type &#39;cat-file -t&#39; git config --global alias.dump &#39;cat-file -p&#39; # shell git alias alias gs=&#39;git status &#39; alias ga=&#39;git add &#39; alias gb=&#39;git branch &#39; alias gc=&#39;git commit&#39; alias gd=&#39;git diff&#39; alias gco=&#39;git checkout &#39; alias gk=&#39;gitk --all&amp;&#39; alias gx=&#39;gitx --all&#39; alias got=&#39;git &#39; alias get=&#39;git &#39; . | . | . . | 협업 시작 (A와 B) . 일단 github_id가 local에의 user.name과 동일한지 확인한다. . git config user.name . | . . 작업레포(local, A) 정하기 . 페어와 CodeWithMe등으로 작업할 local 레포 정하기 . 나의 경우, 네트워크 잇슈로 화면공유 + B를 colaborator 등록하여 B가 local에 step1만 --single-branch clone후 서로 push &amp;&amp; pull 해서 작성함. . git clone -b step1 --single-branch [git주소] [폴더명 or .] . | . | 작업을 완료한 뒤 push까지 끝낸다. . | . A fork레포(remote 2) —fetch/merge–&gt; B local레포 . 협업해서 push된 [A 원격레포-step1]를 2번째 remote repo로 등록한다. . 1번째는 fork한 나(B)의 원격레포 . | 2번째는 fork한 A의 원격레포 . git remote add pair&lt;원격레포별칭&gt; &lt;Repo URL for pairs fork&gt; git remote -v . origin: 원격 저장소를 가리키는 일반적인 별칭 | pair: 내가 정한 추가 원격 레포의 별칭 | . | . | A 원격레포(remote pair)의 step1(협업했던br)의 내용만 fetch해온다. . A pair repo -&gt; B local repo 우리는 pull을 해버렸다. pull할때마다 merge로 표기되니 조심. | . | git fetch : 다른 사람의 branch의 내용을 가져와 확인한 뒤 (나중에) merge 하고 싶을때 fetch를 사용 | 아직 merge는 하지 않았기 때문에 인텔리제이에 가져온 코드들이 보이진 않을 것이다. | . git fetch pair step1 . 안되면 git fetch pair/step1 | . | fetch로 내역들을 확인했으면 merge한다. . git merge pair/step1 . fetch는 띄워쓰기 / merge는 fetch된 것을 /로 연결 | . | A fork레포(remote2) -&gt; B fork레포(remote1) . 정보를 줄 pair(remote2)의 협업br(step1)로 HEAD 이동시켜놓기 . git checkout pair&lt;원격레포별칭&gt;/step1&lt;협업br&gt; . | 정보를 받을 origin(remote1)의 협업br(step1)으로 push하기 . A pair repo -&gt; B remote repo remote —&gt; remote로 commit내역을 넘기나보다. | fetch -&gt; merge로 local에 가져왔다면, 원격에서 원격으로 한번더 가져오나보다. | . | . git push --force origin step1 . | 사실… B local -&gt; B fork로 가는게 맞다? . 동기 크루 중 1분의 블로그 git remote add pair url | git fetch pair step1 | git merge pair step1 | git push origin step1 | . | . 코드리뷰 요청 . 페어 끊기 . 우테코 홈피 -&gt; 나의팀 -&gt; 피드백을 누르면 페어가 끊어진다. 페어가 끊어져야 리뷰요청이 활성화된다?! | . | forkRepo -&gt; 원본Repo PR (리뷰요청) . 내 fork 원격레포 의 step1 br로 이동한 뒤, 원본(미션)repo로 PR를 누른다. PR을 통한 코드리뷰는 fork레포- 작업br(step1)에서 PR을 걸어 -&gt; 원본레포의 나와관련된 br(is2js)에 요청하는 것 | fork레포의 관련br(is2js)가 아닌 것에 주의하자. | . | PR 받는 곳 원본레포: base repository - is2js(관련 br) | PR 보내는 곳 fork레포: head repository - step1(작업br) branch를 잘 선택해야한다. | . | . | PR메세지까지 다 작성해서 제출한다. | 홈피-&gt;slack에 리뷰요청 알림 . 우측 상단에 리뷰요청 . | slack으로 메세지 전달 . . | slack-&gt;피드백 알림 -&gt; 로컬수정 -&gt; PUSH로 피드백반영 -&gt; 홈피 리뷰요청2 . 슬랙으로 피드백 반영해달라고 알림이 온다 날렸던 PR에 그대로 코드리뷰가 반영되어있다. | . | local에서 step1 br로 수정한다. | local step1 -&gt; remote step1 PUSH 하는 순간 피드백 반영되므로 조심하자. 추가 PR은 필요 없다. | . | push로 피드백 반영이 끝났으면 우테코 학습 홈피 -&gt; 우측상단 리뷰요청 -&gt; 리뷰요청 -&gt; slack메세지 | 리뷰어가 피드백을 보고 merge해줄 것이다. 그럼 다음 단계로 진행하면 된다. |",
            "url": "blog.chojaeseong.com/git/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%ED%98%91%EC%97%85/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/09/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-1%EB%8B%A8%EA%B3%84-%EB%B0%8F-%ED%94%BC%EB%93%9C%EB%B0%B1(%EC%99%84).html",
            "relUrl": "/git/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/%ED%98%91%EC%97%85/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/09/%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-1%EB%8B%A8%EA%B3%84-%EB%B0%8F-%ED%94%BC%EB%93%9C%EB%B0%B1(%EC%99%84).html",
            "date": " • Feb 9, 2022"
        }
        
    
  
    
        ,"post152": {
            "title": "fastpages font & tag page change",
            "content": "font 바꾸기 . 참고: 한국 블로그 | . _includes폴더 &gt; head.html파일에서 웹 폰트 link태그 추가해주기 . &lt;!-- 폰트추가를 위한 link태그 삽입 --&gt; &lt;!-- 폰트1: 기본 spoqa 웹폰트 --&gt; &lt;!-- css에서 * {} 다 뒤집어씀. --&gt; &lt;link href=&#39;//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSansNeo.css&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&gt; &lt;!-- 폰트2: 블로그 제목들 sunflower 웹폰트 --&gt; &lt;!-- 쥬피터 등 포스트 내부 글자 h1, h2 제목은 sunflower체 도입 --&gt; &lt;link href=&quot;//fonts.googleapis.com/css?family=Sunflower:300,500,700&quot; rel=&quot;stylesheet&quot;&gt; . | 해당 폰트를 사용하기 위해 assets폴더 &gt; css폴더 &gt; styles.css를 수정한다 나의 경우, scss수정시 잘 안됬다. 모든 것을 여기서 설정해줬다. | font-family 검색해서 모두 font-family: &#39;Spoqa Han Sans Neo&#39;, normal;로 바꿔주기 | 전역으로 다 먹이기 + 제목들은 다른 글자체로 먹이기 /* 제목들은 먹히는데, 제목만쓰질 않으니.. */ /* test-&gt; 전체를 font-familty 덮어쓰기 */ *{ font-family:&#39;Spoqa Han Sans Neo&#39;, normal!important; } /* font2 제목 글자는 선플라워 */ h1, h2, h3, h4, h5, h6, tag-name { font-family:&quot;Sunflower&quot;, normal!important; color: #152447; } . | . | a태그 리셋시켜서 색 적용되게 하기 /** Links */ /** 폰트 색 (링크 색) -&gt; 이것만 바꾼다고 변경안됨.. */ /* 모든 a태그 프로퍼티들을 리셋 */ a { all: unset; } /* a태그의 가상클래스도 같이 리셋 */ a:link { text-decoration: none; color: #152447; } a:visited { text-decoration: none; color: #152447; } /* 누른상태 */ a:active { text-decoration: none; color: #152447; } /* 갖다덴 상태 */ a:hover { text-decoration: none; color: #152447; } a { color: #152447; text-decoration: none; } a:visited { color: #152447; } a:hover { color: #313266; text-decoration: underline; } . | 마크다운 강조색을 빨간색 글자로 변경 pre, code { font-family: &#39;Spoqa Han Sans Neo&#39;, &quot;Menlo&quot;, &quot;Inconsolata&quot;, &quot;Consolas&quot;, &quot;Roboto Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; font-size: 0.9375em; border: 1px solid #f9f2f4; border-radius: 3px; background-color: #f9f2f4; color:#E53A40;} . | tags.html 수정하기 . 예전 블로그의 css를 가져와 적용할 준비를 한다. style.css /** 예전 블로그에서 쓰던 tag모음 + 각 개별tag적용 css */ .entry-meta { font-size: 12px; font-size: 0.75rem; text-transform: uppercase; color: #152447; } .entry-meta a { color: #152447; } .entry-meta .vcard:before { content: &quot; by &quot;; } .entry-meta .tag { display: inline-block; margin: 4px; color: #fff; border-radius: 3px; background-color: rgba(162, 162, 162, 0.8); } /*my) 상단 태그들 모음 tag1 shap(#) */ .entry-meta .tag span { float: left; padding: 6px 6px; color: #152447; font-family: inherit; /* background-color: #ffffff; */ } /*my) 상단 태그들의 tag2 name(태그명) 색*/ .entry-meta .tag .tag-name { color: #ffffff; background-color: #152447; border-radius: 0 3px 3px 0; /*3px 이상 오그리면, 하이퍼링크랑 막 난리남.*/ } .entry-meta .tag:hover { background-color: rgba(136, 136, 136, 0.8); } .entry-meta .entry-reading-time { float: right; } .inline-list { list-style: none; margin-left: 0; padding-left: 0; } .inline-list li { list-style-type: none; display: inline; } /* 추가) 각 제목들도 tag 작은모양처럼*/ .eachtag { color: #ffffff; background-color: #152447; border-radius: 0 3px 3px 0; } . | tags.html코드를 수정한다. ul태그에 entry-meta inline-list 속성을 추가한다 | 그외 tag, tag-name, eachtag 등의 속성을 이용해서 꾸민다. | . &lt;ul class=&quot;entry-meta inline-list&quot;&gt; &lt;/ul&gt; . |",
            "url": "blog.chojaeseong.com/fastpages/2022/02/09/fastpages-font-&-tags-page-change.html",
            "relUrl": "/fastpages/2022/02/09/fastpages-font-&-tags-page-change.html",
            "date": " • Feb 9, 2022"
        }
        
    
  
    
        ,"post153": {
            "title": "fastpages post preview setting",
            "content": "fast pages 메인에서 preview image 보이게 하기 . 참고: 이미지를 표기하는 fastpages | . _config.yml에서 show_image: false -&gt; true로 변경 . | 미리캔버스를 검색해서 템플릿으로 생성할 이미지 만들기 참고 블로그 | 생성 목록 algo.png | blog.png | config.png | data.png | default.png | git.png | java.png | python.png | sql.png | wootech.png | . | . | 최상단 images폴더 &gt; posts폴더에 이미지들 넣어두기 . | post마다 image: &quot;images/posts/blog.png&quot;형식으로 preview 이미지 설정하기 메인 위쪽은 index.html | 메인 아래쪽 포스트 담당은 home.html이다 | . _config.yml에서 show.image: true일 경우 post_list.html(글만) -&gt; post_list_image_card.html로 바뀌어서 보인다. | . | . |",
            "url": "blog.chojaeseong.com/fastpages/2022/02/08/fastpages-post-preview-setting.html",
            "relUrl": "/fastpages/2022/02/08/fastpages-post-preview-setting.html",
            "date": " • Feb 8, 2022"
        }
        
    
  
    
        ,"post154": {
            "title": "TDD 기본 싸이클 작성",
            "content": "TDD 싸이클 . TDD 구현 싸이클 fail떨어지는 test코드 생성 case별로 메서드_이름을 표기하여 작성한다. | . | main(프로덕션)코드 작성 후 pass 2번째부터는 개별 pass -&gt; 전체pass 순으로 확인 | . | refactoring(rename부터 시작) | | . | . test에서 package &gt; XXXTest class를 먼저 만든다. . . generate(alt+insert)기능으로 @test로 생성 . | 메서드_명은 한글명으로 해도 되고, 단위테스트가 의미하는 바만 잘 나타내면된다. 여기선 여러 경우 중 1가지(구분자 없는) 경우로 시작을 한다. . | . . | 클래스명 + 메소드명을 먼저 사용하여 할당을 반환형 actual변수로 받은 뒤 given(값 -&gt; 변수 선언 등) -&gt; when(actual까지 로직) -&gt; then( asesertThat(actual).isEqualTo(expected)) . // given String data = &quot;(1,2)&quot;; // when String result = data.substring(1, data.length()-1); // then assertThat(result).isEqualTo(&quot;1,2&quot;); . | . | assertThat( actual ).isEqualTo( )에서 인자에 예상값(우리가 원하는 값)을 넣는다. . | SC 없는 클래스를 만들 되, 미리 main쪽에 package를 만들어 놓은 상태에서 -&gt; 생성경로를 main으로 바꿔준다. . test &gt; package &gt; XXXTest class | 내부 XXX클래스.메서드() —&gt; main &gt; package &gt; XXX class로 생성 | test에만 존재하는 package를 선택하면, main에 못만드니 미리 만들어놔야한다. | . | **클래스 생성 직후 바로 돌아와(Back기능 ctrl+u) method도 만들어준다 ** . 이 때, actual(1)을 반환하지 않는 불완전한 메소드를 수정없이 test실행부터해서 Error를 낸다 . . | . | test코드(SCTest)가 pass하도록 프로덕션코드(main코드, SC)를 수정한다. . . | pass한 프로덕션 메소드를 refactoring한다. . 파라미터 이름 바꾸는 것도 F2 = refactoring | @test 막 사용했던 class이름(XXX) 바꾸는 것도 F2 = refactoring 이 때, test class이름 XXXTest도 바꾸자고 권유한다. | . | . | 더이상 refactoring할게 없다면 -&gt; 새로운 단위테스트를 클래스.메소드()부터 만들어서 나아간다. . 직전에 만든 테코랑 비슷하다면, 복붙해서 시작한다. . | 테케는 가능한 가장 작은 단위를 만드는 경우며, 케이스 -&gt; if 상황별 새로운 메소드로 나누고 -&gt; 상황에 맞게 인자 변경 -&gt; expected . 구분자 없음 -&gt; “1” -&gt; 1 | 컴마 구분자 -&gt; “1,2” -&gt; 3 | . . | . | 다음 테케도 프로덕션 코드 수정없이 일단 돌려서 fail을 떨어뜨린 뒤-&gt; 에러보고 참고하여 찾아가서 수정 . | 해당 테케실행 -&gt; 전체 테케도 실행해서 전체 통과하는지 확인을 한다. . | pass후엔 refactoring하기 . for문으로 들어가는 indent -&gt; 메소드 추출 refactoring . return문까지 잡아서 추출해보기(alt+ctrl+m -&gt; 안되면 ctrl+.) . . | . | . | input/output이 명확한 쉬운 TDD였다. . 자동차 경주를 하려면, 너무 힘들 것 | 단위테스트만 만들어서 해볼 것 | fail하는 test생성 -&gt; 프로덕션수정으로 pass -&gt; refactoring | . |",
            "url": "blog.chojaeseong.com/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/08/TDD%EC%8B%B8%EC%9D%B4%ED%81%B4(%EB%8D%A7%EC%85%88%EA%B3%84%EC%82%B0%EA%B8%B0)(%EC%99%842).html",
            "relUrl": "/java/%EC%9A%B0%ED%85%8C%EC%BD%94/tdd/%EA%B0%95%EC%9D%98/2022/02/08/TDD%EC%8B%B8%EC%9D%B4%ED%81%B4(%EB%8D%A7%EC%85%88%EA%B3%84%EC%82%B0%EA%B8%B0)(%EC%99%842).html",
            "date": " • Feb 8, 2022"
        }
        
    
  
    
        ,"post155": {
            "title": "resources 속 파일 읽기",
            "content": "외부파일 읽기 . 01 src&gt;main&gt;resources 안에 파일을 넣는다. . . 02 카테고리(분기)가 있는 경우, enum에 외부문자열로서 파일경로 매핑 . 파일경로는 “src/main/resources/ ~ “로서 src부터 시작한다 . . public enum Course { BACKEND(&quot;백엔드&quot;, &quot;src/main/resources/backend-crew.md&quot;), FRONTEND(&quot;프론트엔드&quot;, &quot;src/main/resources/frontend-crew.md&quot;); private String name; private final String resourcePath; Course(String name, final String resourcePath) { this.name = name; this.resourcePath = resourcePath; } . 03 new File(경로) -&gt; new Scanner( file ) -&gt; if .hasNextLine() -&gt; .nextLine() . 한줄 씩 읽어서 -&gt; 가변 List&lt;String&gt;에 한줄씩 add하는 것이 특징 . utils &gt; FileReaderUtil . public class FileReaderUtil { public static List&lt;String&gt; read(final String pathname) { final File file = new File(pathname); final List&lt;String&gt; crews = new ArrayList&lt;&gt;(); try { final Scanner scanner = new Scanner(file); while (scanner.hasNextLine()) { crews.add(scanner.nextLine()); } } catch (FileNotFoundException e) { System.out.println(&quot;[ERROR] &quot; + e.getMessage()); } return crews; } } . public Crews generateShuffledCrews(final Course course) { final List&lt;String&gt; crewNames = FileReaderUtil.read(course.getResourcePath()); final List&lt;String&gt; shuffledCrew = Randoms.shuffle(crewNames); return Crews.from(course, shuffledCrew); } . | .",
            "url": "blog.chojaeseong.com/java/resources/pair-matching/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/07/resources-%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%9D%BD%EA%B8%B0.html",
            "relUrl": "/java/resources/pair-matching/%EC%9A%B0%ED%85%8C%EC%BD%94/2022/02/07/resources-%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%9D%BD%EA%B8%B0.html",
            "date": " • Feb 7, 2022"
        }
        
    
  
    
        ,"post156": {
            "title": "우테코 프리코스 3주간 요구사항들",
            "content": "요구사항 체크리스트 모음 . 1주차 . 자바의 버전이 8버전인가 | 자바 코드 컨벤션을 지키는가 | Randoms의 pickNumberInRange()를 사용했는가 (3주차) pickNumberInList()를 사용했는가 | . | Console의 readLine()을 사용했는가 | 3항 연산자를 쓰지 않는가 | indent depth가 2이하인가 | 하나의 함수가 한 가지 일만 하도록 하였는가 | (추가) 하드코딩 하진 않았는가 | (추가) style check 및 convention 적용 하였는가 | gradlew.bat clean test의 모든 테스트가 통과하는가 | 과제 제출시 우테코 플랫폼에서도 제출하였는가 | . 2주차(피드백 및 과제에서 추가) . 함수(또는 메소드)의 길이가 15라인을 넘어가지 않도록 구현한다. | else 예약어를 쓰지 않는다 . | 기능 목록을 업데이트하고 재검토 한다 | Class 구현순서( 상수-&gt;멤버 변수-&gt;생성자-&gt;메서드) 지키기 | . 3주차 . 기능 목록에 예외상황도 기록한다. | 일급컬랙션 및 단일변수도 포장한다. | 변수를 줄이려고 노력한다. | . 주차별 미션 수행 키포인트 정리 . 1주차 과제 수행시 키포인트 . 개발 시작전에 요구사항 충분히 파악하기 | 기본 프로젝트 구조 및 뼈대 코드 작성하고 시작하기 | 라이브러리 확인 및 컨벤션 포맷터 적용, 버전 확인 등 기본적인 협업환경 확인하기 | Application에 개발하지 않고 각 class에서 개발하여 구동하기 | scanner 등 input, outview은 static으로 작성해서 재활용하기 | 문자열type의 숫자입력시 검증 여러가지 해보기(길이-&gt; 포맷-&gt; 범위-&gt; 중복여부 등 기타) | else 안쓰고, 반복문안에 if는 method로 빼서 method내에서 하여 indent줄이기 | 무한반복시 조건변수를 결과로 업데이트 하면 됬으나, 재시작 등 추가분기가 필요한 경우, status변수 추가 도입하기 | 상수도 반복되니 따로 class로 빼기 | 중복확인은 list길이로 하는 데, stream으로 편하게 하기 list 중복확인 : list.stream().distinct().count() | 입력받은 문자열배열 -&gt; 정수 list변환 : Arrays.stream(). mapToint(Integer::parseInt).boxed().collect(Collectors.toList()); | . | . 2주차 과제 수행시 키포인트 . Live template을 활용함. 1주차와 반복되는 input코드 등을 미리 작성해둠. | . | fork한 repo를 clone후에 branch부터 바꾸자! 실수로 main브랜치에 commit and push하여 새로 작성하는 경우가 발생했었음. | . | 일급컬렉션 사용하여 객체List에 대한 검증 및 관련 로직을 모음. 쪼개어지는 Input을 받을 때 ex&gt; Names -&gt; Name 미리 names에서 검증을 다 해버리는 전략을 세움 | 쪼개어놓고 내부에서 검증할 시, 다시 입력받으러 가기가 쉽지가 않음. | . | 조건절에서 getter쓰지말고, 객체.부등호를메서드화() 시켜 메세지보낼 것. 비교시 필요한 값은 메서드의 파라미터로 | 입력 받은 int 변수를 포장한 래핑클래스를 만들고 countdown 메서드 구현해보기 | 학습했던 stream위주로 코드 짜보기 max( Comparator)를 쓰더라도 1번에 max값을 충족시키는 여러개의 객체를 구하기는 쉽지 않음. | mapToInt( ) 집계값 구한 뒤 -&gt; 일치하는 객체 List(우승자들) 구하는 방식 | 간단한 출력문은 toString()오버라이딩 해서 쉽게 출력되도록 이용 하기 | | 상수들 및 에러 메세지들의 리팩토링 IDE를 이용하면 정말 간단하게 해결할 수 있음을 깨닫게 됨. | . | . 3주차 과제 수행시 키포인트 . 객체의 각 필드에도 wrapping class를 적용함 원시변수 및 if문의 최소화 -&gt; 래핑변수 및 stream의 활용 | . | 정규식 패턴검사에 stream을 활용함 | List대신 Map 자료구조 래핑하여 DB처럼 사용함 상품 정보등은 List를 포장한 일급컬렉션으로 만들어놓고 정보조회시 사용함 | . | 싱글톤 객체를 활용하여 전체 로직을 운영함 controller 반복문의 조건변수도 싱글톤객체에 메세지를 보내니 상태에 따른 값을 얻어와서 구현하기 수월했음 | . | 자판기 작동 로직에 대해 고민하여 기능 구현 목록을 작성함 | .",
            "url": "blog.chojaeseong.com/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/2021/12/15/%EC%9A%B0%ED%85%8C%EC%BD%94%EA%B0%80_%EB%82%98%ED%95%9C%ED%85%8C_%EC%A4%80_%EC%84%A0%EB%AC%BC.html",
            "relUrl": "/%EC%9A%B0%ED%85%8C%EC%BD%94/%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/2021/12/15/%EC%9A%B0%ED%85%8C%EC%BD%94%EA%B0%80_%EB%82%98%ED%95%9C%ED%85%8C_%EC%A4%80_%EC%84%A0%EB%AC%BC.html",
            "date": " • Dec 15, 2021"
        }
        
    
  
    
        ,"post157": {
            "title": "intelliJ 세팅(vscode keymap + 협업 세팅)",
            "content": "vscode keymap 관련 플러그인 설치 . 설정 &gt; Plugin &gt; vscode kemap검색 후 설치 | key Promoter X 설치 (해당 기능의 단축키를 우측하단에 띄워줌) | | . vscode keymap 기준 단축키 정리 . shift 2번 : 전체 검색(유지) vscode F1 | . | keymap 들어가서 move to opposite group검색후 ctrl+shift+ 오른화살표지정하기 ctrl + 이후 넘기기..왼쪽넘기기 기능 자체는 없나보다. | alt+shift+0으로 세로로 넘기기 가능 | . | alt+shift+F : reformat code -&gt; 한파일내 패키지 or 폴더 선택후 alft+shift+F | . | keymap 들어가서 back검색후 ctrl+u지정하기 . | ctrl + .으로 메인메소드 내용을 extract method 메소드 분리 및 패키지명 작성하고 폴더이동시키기 | . | 신세계) alt+insert로 생성자, getter 등 오버라이딩 . | **신세계) 메서드사용을 위한 객체 만들 때(인스턴스화) 할 때, ** new 클래스명(); 기입후 ctrl+.으로 local변수 자동(선택후)생성하자. | 객체.메서드();기입후 ctrl+.으로 메서드결과값 받는 변수 자동(선택후)생성 | . | keymap -&gt; extend line selection -&gt; ctrl+L을 추가해서 사용하기 라인 선택하기 shift+alt+아래화살표로 복사할때,, 라인 선택해서해야.. 꼬임없을 듯 | . | . | shift+ alt+ F10: 실행할 class파일 선택해서 실행 ctrl+alt+F10은 바로 실행. | . | shift + alt + x: 현재 파일들 다 close . | shift + alt + a : 긴글 주석? . | alt + ~ : git관련 명령어들 목록나옴 . | ctrl+F11 or ctrl+shift+{key}로 북마크 지정 -&gt; ctrl+해당번호로 이동 | keymap -&gt; show bookmaks검색후 -&gt; CTRL+SHIFT + F11 으로 지정함 | . | ctrl+f3 : 같은단어 이동가능한 검색한 상태로 만들기 == ctrl+f f3 : 같은 단어 다음으로 이동 | shift+f3 : 같은단어 이전 단어로 이동 | . | shift+F5 : 실행중인 작업 종료 ctrl+F5 : 실행 | shift+ alt + f10 : main함수 골라서 실행 | . | alt+7: 현재파일 Structure(메소드 등) 한눈에 보기 유틸메서드로 빼기, 상수 옮기기 : f6으로 편하게 | . | 리팩토링 alt+ctrl+c : 값을 상수로 등록해버리기 | alt+ctrl+m : 코드를 메서드화 시키기 2번 눌르면 창으로 하는 듯 | . | alt+ctrl+v: new 클래스()까지 입력후 참조변수 바로 생성 | . | 축약어 iter | fori 추가 | itar | ifn | inn | . | F8: 오류바로 찾아가기 | ctrl+f -&gt; F3 or shift + F3 : 검색항목 순서대로 찾아가기 | . 프리코스를 위한 java8 협업 세팅 요약본 . clone후 branch부터 생성후 바꾸기 . git checkout -b is2js . git CRLF -&gt; LF로 바꾸기 설정하기 . git config --global core.autocrlf true . utf 8 설정 . utf8, lf설정 되어있나 확인하기 . editor &gt; File Encodings &gt; 체크 3가지 모두 utf-8 shift 2번연속 클릭 (search everywhere) . vm검색 Edit Custom VM option 클릭 맨 마지막 줄에 -Dfile.encoding=UTF-8 추가 | . | . | . | . | . | build.gradle 설정 추가 . compileJava.options.encoding = &#39;UTF-8&#39; // UTF-8 설정 compileTestJava.options.encoding = &#39;UTF-8&#39; . | . code style 3가지 / Checkstyle / saveActions . code style에서 . scheme지정 | n으로 선택해주기 | detect하도록도 체크함.. | java탭으로 내려가서 &gt; scheme 지정확인 checkstyle에 안걸리게 됨. | . | | Tools &gt; CheckStyle . 8.24이상 버전 (default) . | scope를 All sources(테스트포함, 나는 테스ㅡㅌ제외)로 변경 . | 파일 선택(일부코드 삭제하여 수정한)하여 추가 -&gt; +로 추가 . . | 해당 스타일체크후 alt +shift + k혹은 하단 체크스타일에서 추가한 naver style선택하여두기 . | | 다 풀고 **맽밑 Other settings &gt; Save Actions &gt; 3가지 체크 ** . . | . java8로 통일하기 . 설정&gt; Build&gt; Build Tools &gt; Gradle &gt; intelliJ IDEA + Gradle JVM 1.8로 바꾸기 exception 및 디버깅용으로 gradle 변경하는 것 | . | 설정&gt; Build&gt; Build Tools &gt; Compiler &gt; Java Compiler &gt; javac의 1.8 바꾸기 | 프로젝트구조(c +s + a + s) &gt;Project &gt; Project SDK 및 language level 1.8, 8 선택 | 프로젝트구조(c +s + a + s) &gt; Modules &gt; 랭귀지레벨에서 8버전 맞나 확인하기 | 프로젝트구조(c +s + a + s) &gt; SDKs에서 1.8버전 확인하기 | window intellij에서 gradle clean, test 해보기 . . shift 2번 or f1 -&gt; gradle task선택 gradle clean 수행 | gradle test 수행 코드 다짜고나서 | | |",
            "url": "blog.chojaeseong.com/java/configuration/2021/12/14/java_intellij_keymap.html",
            "relUrl": "/java/configuration/2021/12/14/java_intellij_keymap.html",
            "date": " • Dec 14, 2021"
        }
        
    
  
    
        ,"post158": {
            "title": "코딩테스트용 라이브러리 정리",
            "content": "참고 벨로그 | justkode | . | . 표준라이브러리 6가지 . 내장함수 . sum, min, max, eval, sorted(key=, reverse=) . result = eval(&quot;(3 + 5) * 7&quot;) print(result) . | . itertools . 반복되는 형태의 데이터를 처리하는 기능을 제공, 순열과 조합 라이브러리르 제공 . permutations(r개의 데이터를 뽑아 나열하는 모든 경우(순열)) . | combinations(r개의 데이터를 뽑아 순서를 고려하지 않고 나열하는 모든 경우(조합)) . | products(r개의 데이터를 뽑아 일렬로 나열하는 모든 경우(순열)를 계산한다. 다만 원소를 중복하여 뽑는다.) . from itertools import product data = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] # 데이터 준비 result = list(product(data, repeat=2)) # 2개를 뽑는 모든 순열 구하기(중복 허용) print(result) # [(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;C&#39;)] . | . heapq . 힙을 활용한 우선순위 큐 기능을 구현할 때 사용되며, O(NlogN)에 오름차순 정렬을 제공한다. PriorityQueue 라이브러리가 따로 있지만, heapq가 더 빠르게 동작한다. . PriorityQueue를 리스트나 힙으로 구현할 수 있지만 리스트는 삽입 O(1) 삭제 O(N) 의 복잡도를 가지지만, | 힙은 삽입 O(logN) 삭제 O(logN) 의 복잡도를 가진다. 그래서 우선순위 큐는 보통 힙으로 구현하고, 시간복잡도도 힙으로 구현한 시간복잡도를 사용한다. | . | . | heapq.heappush() : 원소 삽입 | heapq.heappop() : 원소 꺼내기 | heapq.heapify() | . import heapq def heapsort(iterable): h = [] result = [] # 모든 원소를 차례대로 힙에 삽입 for value in iterable: heapq.heappush(h, value) # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기 for i in range(len(h)): result.append(heapq.heappop(h)) return result result = heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) print(result) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . 히피파이를 이용한 힙정렬 기존에 있는 list 객체로 힙 정렬 만들기 | . | . import heapq h = [3, 9, 1, 4, 2] heapq.heapify(h) # 파라미터로 list 객체를 받는다. for _ in range(6): print(-heapq.heappop(h)) # 작은 값부터 출력된다. . bisect . 이진 탐색을 쉽게 구현할 수 있도록 bisect 라이브러리를 제공함. ‘정렬된 배열’에서 특정한 원소를 찾아야 할 때 매우 효과적이다. O(logN)에 정렬된 배열에 맞는 위치를 찾아준다. | ‘정렬된 리스트’에서 특정 범위에 속하는 원소의 개수를 구하는데 효과적이다. bisect_left(a, x) : 정렬된 순서를 유지하면서 리스트 a에서 데이터 x를 삽입할 가장 왼쪽 인덱스를 찾는 메서드 | bisect_right(a, x) : 정렬된 순서를 유지하면서 리스트 a에서 데이터 x를 삽입할 가장 오른쪽 인덱스를 찾는 메서드 | . | bisect 모듈은 이미 정렬되어 있는 list의 정렬 상태를 유지하기 위해 사용되는 모듈입니다. 이를 이용해서, 기존에 있는 list의 정렬 상태를 유지 할 수 있고, 이를 응용해서 Binary Search 또한 구현할 수 있습니다. | . from bisect import bisect_left, bisect_right a = [1, 2, 4, 4, 8] x = 4 print(bisect_left(a, x)) # 2 print(bisect_right(a, x)) # 4 . 정렬된 리스트’에서 특정 범위(시작과 끝)에 속하는 원소의 개수를 구하는데 효과적이다. . left는 같아도 젤 왼쪽 index(포함), right는 같아도 젤 오른쪽index(미포함, 들어가야하는 자리)를 반환하므로 시작과 끝 index를 알 수 있다. | . from bisect import bisect_left, bisect_right # 값이 [left_value, right_value]인 데이터의 개수를 반환하는 함수 def count_by_range(a, left_value, right_value): right_index = bisect_right(a, right_value) left_index = bissect_left(a, left_value) return right_index - left_index # 리스트 선언 a = [1, 2, 3, 3, 3, 3, 4, 4, 8, 9] # 값이 4인 데이터 개수 출력 print(count_by_range(a, 4, 4)) # 2 # 값이 [-1, 3] 범위에 있는 데이터 개수 출력 print(count_by_range(a, -1, 3)) # 6 . lgN으로 정렬까지 해주는 bisect.insort( )도 있다. . | bisect 모듈은 이미 정렬되어 있는 list의 정렬 상태를 유지하기 위해 사용되는 모듈입니다. 이를 이용해서, 기존에 있는 list의 정렬 상태를 유지 할 수 있고, 이를 응용해서 Binary Search 또한 구현할 수 있습니다. . | . # 1. 삽입 되어야 하는 index 찾기 import bisect arr = [1, 2, 3, 3, 4, 5] print(bisect.bisect_left(arr, 6)) # 6이 들어가야 하는 Index인 6을 반환 print(bisect.bisect_right(arr, 6)) # arr에 6이 없기 때문에 위와 똑같은 값을 반환한다. print(bisect.bisect_left(arr, 3)) # 중복 되는 값 제일 왼쪽, 2를 반환한다. print(bisect.bisect_right(arr, 3)) # 중복 되는 값 제일 오른쪽 + 1, 4를 반환한다. bisect.insort_left(arr, 3) # 중복 되는 값 왼쪽에 삽입 bisect.insort_right(arr, 3) # 중복 되는 값 오른쪽에 삽입 print(arr) . #2. Binary Search 구현 from bisect import bisect_left arr = [1, 2, 3, 3, 4, 5] def bs(arr, x): i = bisect_left(arr, x) # 들어가야 하는 &#39;제일 왼쪽&#39; index 반환 if i != len(arr) and arr[i] == x: # 들어가야 하는 index가 return i # 마지막 index + 1 이라면, arr에 x가 없는 것 else: # arr[i] == x가 아니라면, arr에 x가 없는 것 return -1 a = [1, 2, 4, 4, 8] x = 4 res = bs(a, x) if res == -1: print(x, &quot;는 없습니다!&quot;) else: print(&quot;첫번째&quot;, x, &quot;가 등장한 위치는&quot;, res) . collections . 덱(deque), 카운터(Counter) 등의 유용한 자료구조를 포함하고 있는 라이브러리 . deque . 파이썬에서는 일반적으로 deque를 활용해 큐를 구현한다. | Queue 라이브러리 있지만 일반적인 큐 자료구조를 구현하는 라이브러리는 아니다. | 리스트와 다르게 인덱싱, 슬라이싱 등의 기능은 사용할 수 없다. | 데이터의 시작이나 끝부분에 데이터를 삽입하는데 효과적이다. | . . | Counter 등장 횟수를 세는 기능을 제공한다. iterable 객체가 주어졌을 때, 해당 객체 내부 원소가 몇 번 등장했는지 알려준다. . | . math . 수학적 기능을 제공하는 라이브러리 . 자주 사용되는 수학적인 기능을 포함하고 있는 라이브러리 팩토리얼, 제곱근, 최대공약수(GCD) 등을 계산해주는 기능을 포함 . 종류 math.factorial() : 팩토리얼 | math.sqrt() : 제곱근 | math.gcd() : 최대공약수 | math.pi : 파이 | math.e : 자연상수 | . | . import math print(math.factorial(5)) # 120 print(math.sqrt(7)) # 2.6457513110645907 print(math.gcd(21, 14)) # 7 print(math.pi) # 3.141592653589793 print(math.e) # 2.718281828459045 . . 그외 . map, split, sorted . 주의점 . input말고 . 뭐 어느정도로 더 빠르고 느리냐는, 코딩 테스트 문제푸는 수준에서 다룰만한 내용이 아니므로 넘어가도록 하고, 직관적으로만 느꼈던 것은, input() 으로 코드를 제출할 시, 시간초과가 뜨지만, sys.stdin.readline() 으로 제출할 시 정답이 뜨더라는 것이다. 이와 비슷한 이슈는 이미 이전부터 있었다. | . 한편, 나는 입출력을 지금까지 이런 방식으로 했다. . a = [int(x) for x in input().split()] # a = [1, 2, 3, 4 ,5] . 하지만, 이 방법보다 다음 방법이 더 권장된다. (위와 같은 이유로) . import sys a = list(map(int, sys.stdin.readline().split()))# a = [1, 2, 3, 4, 5] . 재귀풀기 . 이전에 문제풀다가 말한 적이 있는데, 특히 자주접하는 DFS, BFS 문제의 경우 그렇다. . 파이썬의 재귀 허용 깊이의 기본치가 c 보다 약한건지, c 로 짠 DFS, BFS의 경우 문제 없이 돌아가지만, 파이썬으로 돌리면 런타임 오류가 뜨는 경우가 있다. 그래서 다음과 같이 재귀 허용 깊이를 수동으로 늘려주는 코드를, 코드 상단에 적어줘야 한다. . import sys sys.setrecursionlimit(10**8) # 10^8 까지 늘림. . | . Pypy . PyPy 가 뭔지 찾아보니, 쉽게말해 파이썬 보다 몇 배 더 빠른 개선된 파이썬이라고 생각하면 된다. . 좀 더 자세히 말하면, Python3 는 내부적으로는 C로 짜여져있는데 (이 이유 때문에 Python2 보다 빠르다.), 이를 C가 아니라 Python으로 다시 짠 것이다. 당연히 느릴 것 같은데, 의외로 빠르단다. 자세한 내용은 나무위키 참고. . 때문에, 일반적으로 Python3 보다 PyPy로 제출해서 내는게 더 안전한 듯 하다. (빠르다는 의미에서) . 한편, PyPy에서는 sys.setrecursionlimit(10**8) 이 안먹는다. 즉 임의로 재귀 호출 깊이를 설정할 수 없다는 것에 주의해야 한다. . 파이썬으로 문제푸는 게 편한점도 많지만 아직 어색하고, 이런 자잘한 리스크가 많은 듯 하다. 이후 또 뭔가 발견하면 남겨놔야겠다. . | .",
            "url": "blog.chojaeseong.com/algorithm/2021/10/22/python_%EB%AA%A8%EB%93%88%EC%A0%95%EB%A6%AC.html",
            "relUrl": "/algorithm/2021/10/22/python_%EB%AA%A8%EB%93%88%EC%A0%95%EB%A6%AC.html",
            "date": " • Oct 22, 2021"
        }
        
    
  
    
        ,"post159": {
            "title": "협업2)오픈소스PR + 팀원PR + issue로 PR",
            "content": "여러가지 Pull Request 날려보기 . Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . 노팀원 fork PR(팀원-PR받기만/ 타인(나)-Fork후 수정용브랜치로 push하여 타인의 PR) . 앞에서 PR = 팀원1(주인):수정용브랜치 -&gt; 팀원2:collaborator이며 리뷰만 PR(주인-수정용브랜치 / 팀원-리뷰만) 실습 로컬 : git_seminar | 원격 : CS100_Git in is3js . 협동자: is3js | . | . | . | 소샬코딩의 PR . 오픈소스 레포(is3js) : py . 주인 혹은 collaborator임. | . | 기여하고 싶은사람(is2js, 나): py(fork) . 팀원이 아닌 이상 일단 fork한다 | 팀원이 아니더라도 clone후 로컬에서 topic branch를 따서 작업한다. | fork레포(내꺼)에 commit, push한다 | 팀원이 아니지만, fork레포 - topic branch의 변동사항을 push로 PR한다. | . . | . | . 팀원아니더라도 fork-clone-topic따서 작업한 뒤 -&gt; (merge하지않고) commit, push . 나는 오픈소스의 collaborator가 아니므로 오픈소스(py)를 fork한다. . | 작업을 하려면 일단 clone부터해서 local에 가지고 온다. . ❯ git clone https://github.com/is2js/py.git .❯ code . . git 설정을 한번 확인해준다. . ❯ git config --list . remote.origin.url=https://github.com/is2js/py.gitremote.origin.fetch=+refs/heads/*:refs/remotes/origin/*branch.main.remote=originbranch.main.merge=refs/heads/main . | . | fork를 해온 상태는 main브랜치이다. 새로운 topic 브랜치 work를 따서 작업 -&gt; commit -&gt; work를 push까지해보자. . 브랜치 클릭 -&gt; +새 분기 만들기 &gt; work . | main에 merge하는게 아니라 topic branch를 commit -&gt; push해야 팀원아닌데도 PR을 날릴 준비를 할 수 있다. . 명령어로 할 거면 . git push origin [topic branch명] . | . | . | fork한 내 레포라도 topic branch가 merge없이 push되었으면 PR로 인식된다. . 내 개인소스 수정: merge –no-ff -&gt; main commit -&gt; push PR : no merge -&gt; topic commit -&gt; topic push | . | 원본레포인 is3js/py는 미동도 없고, fork한 내 레포 is2js/py에만 PR이 들어온다. | . | topic push로 만든 Fork레포 PR클릭시 원본레포(baserepo) PR을 유도: 전제-main(master)는 변화없이 topicbr만 변화! cf) Fork레포(headrepo)로 merge도 가능함. . 일단 기본적으로 fork한 내 레포(head repo) : is2js/py에서 | 원본 레포(base repo) : is3js/py로 PR를 보내는 것을 기본적으로 수행하려 한다. | fork레포에서 PR버튼 눌렀는데, 이미 원본레포(is3js/py)로 이동되어있다. | . | . . base repo를 수정하면, fork-main &lt;- fork-topic 도 가능한가보다. . | Create pull request해보자. . 원본레포에다가 날리는 것이다. | 원본레포에서 보면 PR이 불들어와있다. | . . | fork레포는 PR에 아무 표시도 안된다. . | 원본레포 팀원은, 팀원X-Fork-topic-PR 날린 것을 commit을 직접 확인하여 request chagnge하거나 approve해준다. . PR 확인후 해당 topic branch의 커밋까지 찾아들어간다. . . | 코멘트를 날릴 땐, +드래그해서 많이 날릴 수 있음. . | 최종적으로는 우측 상단의 review changes &gt; approve까지 해야하지 merge된다. . . | 최종승인하면 원본의 기본branch인 main으로 알아서 merge된다. . | 팀원이 아니더라도 PR(merge)후 delete branch가 원칙: 로컬에서 로컬+fork 2개다 해줌. . 로컬에서 내 fork레포 및 내 로컬레포의 topic branch를 삭제해준다. . main으로 바꾸고, 삭제 | . ❯ git branch -a❯ git checkout main❯ git branch -d work . | . 로컬topic 삭제 -&gt; remote(fork레포)도 자동삭제 반영시키기: git remote update –prune . 로컬에 topic branch가 삭제된 상태에서 git remote update --prune을 사용하여 로컬에 맞춰서 branch삭제 시킨다. . | ❯ git remote update --prune . | 안되서 나는 git push origin :remote_br . git push origin :work . | 참고) origin과 upstream . 레퍼런스: https://pers0n4.io/github-remote-repository-and-upstream/ | . Upstream &amp; Downstream . GitHub에서 repo를 생성하고 나면 다들 origin이라는 용어를 보셨을 겁니다. clone했을 때는 origin이 자동으로 등록돼있고, init했을 때는 git remote add origin ...으로 origin을 직접 등록하라고 안내하죠. 여기서 말하는 origin이 깃허브에 존재하는 repository 즉, remote를 뜻하는 단어입니다. 다만 remote에 origin이라는 이름을 붙인 것뿐이랍니다. . upstream과 downstream은 상대적인 개념이라 origin과 local을 기준으로 생각하면 origin이 upstream, local이 downstream이 됩니다. 그 이유는 push와 pull을 기준으로 생각했을 때 origin으로부터 local로 흐르는 관계가 형성되기 때문입니다. . local에서 origin으로 push한다 | origin에서 local로 pull한다 | . 만약 CLI로 push를 해보셨다면 git push -u origin main3이라는 명령어를 입력했을 텐데, 여기서 -u 옵션이 --set-upstream 옵션의 줄임으로 upstream을 설정한다는 뜻입니다. upstream을 한 번 설정하고 나면 다음부터는 git push 또는 git pull이라고 명령어만 입력해도 자동으로 origin의 main 브랜치로부터 push와 pull을 진행하는 이유가 upstream 옵션을 통해 해당 브랜치에서 upstream과 downstream 관계가 설정됐기 때문이죠. . Fork . GitHub에서 오픈소스 프로젝트에 기여한다거나, 협업을 진행할 때 fork를 이용하게 됩니다. fork는 다른 사람의 repository를 내 소유의 repository로 복사하는 일이죠. 따라서 원래 소유자의 remote repository와 내가 fork한 remote repository 사이에도 upstream과 downstream이라는 관계가 형성된답니다. 그래서 보통 원래 소유자의 remote를 말할 때 upstream, 내가 포크한 remote를 말할 때 origin이라는 용어를 사용하곤 합니다. . 노팀원이지만 [원본repo(오픈소스)] -&gt; fork레포 및 local레포를 최신형으로 유지 by local에서 upstream으로 등록하여 upstream(원본레포) -&gt; origin(fork레포), upstream -&gt; local 통로뚫고 가져오기: git remote add upstream [url] -&gt; git fetch upstream -&gt;[fork레포 ]merge버튼 + [local]git merge upstream/main . 상황 . 갑자기 오픈소스 author가 원본repo -&gt; main을 변경했다면? . 나한테(fork레포, local레포)의 main도 수정된 내용이 들어와야한다. | . . | 기존 local repo에서 -&gt; fork repo를 origin 이라 별칭했음 . local repo에서 -&gt; 원본repo를 upstream으로 별칭 등록 및 원본repo - fork repo를 연결 | . | git fetch: origin to local . git fetch upstream: 원본repo(upstream) to fork repo(origin)으로 업데이트 내용 받아오기 | git merge upstream/main으로 원본repo(upstream) to local repo(local)로 업데이트 내용 받아오기 | . | . | my) 원본repo를 노팀원이 upstream으로 local에서 등록하면 . upstream -&gt; fork | upstream -&gt; local 업데이트가 가능하다. | . | . | 관련 명령어 . . | 참고) upstream 삭제 . 참고 블로그 . git remote -v git remote rm upstream git remote -v . | . | . local에서 원본repo를 upstream으로 등록한다. . ❯ git remote add upstream https://github.com/is3js/py.git . . | git fetch upstream명령어로 upstream의 최신정보를 origin이 받을 수 있도록 업데이트해온다.(아직 받진 X) . ❯ git fetch upstream remote: Enumerating objects: 8, done. remote: Counting objects: 100% (8/8), done. remote: Compressing objects: 100% (3/3), done. remote: Total 5 (delta 2), reused 4 (delta 2), pack-reused 0 Unpacking objects: 100% (5/5), done. From https://github.com/is3js/py * [new branch] main -&gt; upstream/main . origin(fork repo)에 가보면, Fetch해왔다고 뜬다. | . | fork repo에 들어가 git fetch upstream정보를 이용해 최종 merge시킨다. by Fetch upsteam&gt; Fetch and merge 버튼 . | local에서는 git merge upstream/main명령어를 이용해 upstream정보를 가져온다. . 왠지 origin을 pull해서 업데이트 해도될것같긴한데… 따로 upstream -&gt; local로 받는다? | . ❯ git merge upstream/main Updating 476f70b..f7dd8e8 Fast-forward .gitignore | 11 ++++++++++- rb.py | 3 +++ 2 files changed, 13 insertions(+), 1 deletion(-) . 참고) 만약 merge가 conflict나면 . git merge upstream/master --allow-unrelated-histories . | . | 앞으로 계속 . ❯ git fetch upstream # fork repo가서 merge 버튼 # local에서 merge ❯ git merge upstream/main . | 팀작업1: 내부팀원 (not 오픈소스) 초대 및 작업하기 . 내부 소스( not 오픈소스)라고 가정한다. | 관련 명령어 | . 팀리더(is3js)가 팀원(is2js)초대 : github-settings-manage acess-add people(invite collaborator) . 초대받은 사람은 등록 email로만 초대를 받음. push권한이 있다고 한다. = 글쓰기 기능이 있다. | . | . 팀원은 초대되었다면,fork(-&gt; clone -&gt; topic -&gt; PR)할 필요가 없이 clone(-&gt;push)or(-&gt;topic-&gt; review=팀원PR)만 한다. 팀원이라면 바로 local-&gt;팀repo에 바로 push가 가능 . 팀원은 초대되었다면,fork(-&gt; clone -&gt; topic -&gt; PR)할 필요가 없이 clone(-&gt;topic-&gt;push or review=팀원PR) . ❯ mkdir team_py❯ cd team_py❯ git clone https://github.com/is3js/py.git . . | 해당 폴더로 이동후 수정하고 commit -&gt; push까지해보자. . 원래는 topic -&gt; | . code .# main에서 바로 # 파일수정# add commit -&gt;push . | 팀원이라면, 팀repo에 바로 push가 된다. . | 팀작업2: 내부팀원의 clone (local)에서 topic push로 PR권유 -&gt; topic push한 사람만 PR요청 가능 -&gt; 타 팀원review받기 (review안받을거면 main push했음) . . topic push한 작업팀원만, 자신에게 PR권유를 확인 및 요청할 수 있다. . 팀원은 fork필요없이 local clone후 main push해도 되지만, review를 받기 위해 topic push로 PR한다 . user-login topic branch 생성 . git checkout -b user-login . | login.py 생성 후 작업 . | add, commit, (topic branch) push . | | **팀원repo에 들어가도 ** . topic branch를 보낸 사람이 아니면.. PR권유가 안뜬다. . is3js(타팀원) . PR권유는 topic br push한 사람 자신에게만 보인다. | . . branch로는 보여도, PR은 타팀원이 결정안함. | . . | is2js( topic br push한 작업 팀원) . . | . | . | topic br push를 pull request한다. . 메세지에 코드리뷰 부탁한다고 남기자. | . | 타팀원은 PR 불-&gt; commit 메세지-&gt; commit 클릭 -&gt; 코드 리뷰 . author가 아니더라도 모든 팀원들이 확인할 수 있게 ** **PR에 불이 들어와있다. . | Merge를 누르기 전에 메세지에 달려있는 커밋까지 직접들어가서 코드를 살펴보자. . . | code line에서 +를 드래그해서 코드 리뷰를 해준다. . | 거절을 의미하는 코드 리뷰를 해주자. 코드리뷰한 것 바로 밑에 Reply도 달 수 있으니 확인하면된다. | 코드 리뷰를 데면 우측에 Finish your review(1)가 뜬다. 클릭해서 리뷰를 끝내자. | . | 코드 리뷰를 달면, 자동으로 작업 팀원에게 email도 보내준다. | (topic push -&gt;PR했던) 작업 팀원은 확인해서 1) Reply + 2) local에서 추가작업 -&gt; 3) topic br PUSH -&gt; 4) 자동 PR timeline에 추가 . . 거절성 코드리뷰에 대해 대답을 해주고 . | PR 날렸던 topic br로 다시 돌아와서 . 추가 작업을 함. . ❯ git checkout user-login . | . | 다시 한번 topic br push하면, 추가 PR을 안날려도 자동으로 PR 타임라인에 추가된다. . | 타팀원의 2번째 review부터는 [작업팀원의 추가push]가 자동으로 PR timelien에 추가된다. . 타팀원 화면에서는 작업팀원의 추가작업한 커밋 위에 View changes가 떠있다. . 작업팀원이 커밋할 때 . . | 타팀원(리뷰팀원)화면 . | . | 승인은 LGTM(looks good to me) . 코드 리뷰를 다시 한번 남기고 | finish your review에서 approve를 선택해주면 끝난다. 이 때 멘트는 LGMT를 많이 쓴다. | approval이 떴다면, 작업팀원이 merge PR해도 된다. 아무나 팀원이면 다된다. merge후에는 delete (topic) branch -&gt; local code 최신화(git pull) -&gt; local의 topic branch는 직접 삭제() . approve 확인되면 | 작업한 팀원이라도 merge시킬 수 있다. . | 작업이 끝난 topic branch를 삭제하라고 뜬다. 삭제한다. . | 로컬의 main 코드를 최신화하기 위해 main branch로 와서 git pull로 코드 최신화한다. . ❯ git checkout main . | 로컬의 topic branch도 직접 삭제한다. . ❯ git branch -d user-login Deleted branch user-login (was b7bde3a). . | cf) 혹시 delete branch 안해서 서버에 남아있다면? . local branch 수동 삭제 . | remote 동기화로 삭제 . git remote update --prune . | 팀작업3: issue(개선기록) 와 PR(팀원1(주인)-수정용브랜치push PR / 팀원2-리뷰만) 실습 . 로컬 : git_seminar . | 원격 : CS100_Git in is2js . 협동자: is3js | . | . 로컬 readme생성후 -&gt; 원격 빈레포에 push로 시작. 1번째 가이드: …or create a new repository on the command line(init, readme push) . 로컬에서, 빈 레포 생성시 주어지는 가이드1 번째인 …or create a new repository on the command line를 따라치기 . echo &quot;# CS100_Git&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;first commit&quot; git branch -M main git remote add origin https://github.com/is2js/CS100_Git.git git push -u origin main . 아직 git init안한 상태에서 readme.md를 먼저 만들고,, 시작하네 | . | . | 원격레포에 issue생성: issue는 TODO list 역할이나 논의사항 정리용 . 원격레포의 issue 탭 &gt; new issue 클릭 . readme.md 파일을 좀 더 구체적으로 작성해주라고 issue 생성하기 | . | issue 오른쪽 사이드바에 보이는 Assignees를 클릭하여, issue해결자 10명 중 1명으로 나를 등록한다. . . | issue 해결 전에, collaborator 추가 (상대방은 메일로만 초대받음) . settings &gt; manage access &gt; add people . is2js(tingstyle1@gmail.com, 현재) -&gt; (시크릿창) is3js 계정 추가 . . is3js(is2js@naver.com)계정은 깃허브알림 없이 메일로만 초대장이 옴 | . | . | . 로컬에서 생성 후 파일 수정하기: git checkout -b [생성후전환될 브랜치] . 로컬(is2js)에서 feature/readMe 라는 파일 수정용 브랜치를 생성하자 . ❯ git checkout -b feature/readMeSwitched to a new branch &#39;feature/readMe&#39;&gt;glg # git log(HEAD -&gt; feature/readMe, origin/main, main) . branch 변경 후 git log를 확인하니 HEAD가 브랜치를 잘 따라오고 있다. | . | 파일 수정후에는 add전 gitt diff로 어느부분 수정되어있는지 확인 . ❯ git diffdiff --git a/README.md b/README.mdindex 1743ce5..a6cac92 100644 a/README.md+++ b/README.md@@ -1 +1,3 @@ # CS100_Git++This is CS100 No newline at end of file . | add - status - commit 단계를 거친다. . ❯ git add README.md❯ git status . | (PR날릴 브랜치는)순수 git commit후 메세지 작성되는 부분에 [- issue #번호] 삽입하여, 해당issue에 커밋 걸어주기 . git commit만 입력하기 . &gt; git commit . | commit 메세지 작성 에디터에서 - issue #1의 관련된 issue 번호를 기입해주기 . ADD more description in README- issue #1 . . | 나중에 저렇게 삽입한 커밋속 issue #1지정 부분은 PR속에서 issue를 연결해준다. . **즉, issue에 대한 하여 PR(팀원검토)시에는 `#번호`를 커밋메세지에 넣어두자.** . . | . | 원격레포에 없는 지만, push해주면 &lt;알아서생성+PR권유&gt; . 로컬에서 원격레포로 수정용 브랜치를 push . ❯ git push origin feature/readMeCounting objects: 3, done.Writing objects: 100% (3/3), 289 bytes | 289.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)remote: remote: Create a pull request for &#39;feature/readMe&#39; on GitHub by visiting:remote: https://github.com/is2js/CS100_Git/pull/new/feature/readMeremote: To https://github.com/is2js/CS100_Git.git * [new branch] feature/readMe -&gt; feature/readMe . | github에 가보면, . 새로운 브랜치 생성 확인: 로컬에서 수정용브랜치를 push해서 자동으로 생성한 것 . . | 현재는 main우주만 보여주고 있음. 수정한 평행우주는 브랜치를 선택해서 들어가야 보임 . | . | 혼자는merge지만, PR은 를 팀원(collaborator)들에게 확인요청이니 메세지 한번더! . 혼자 작업했다면, . 로컬에서 수정용브랜치 -&gt; main브랜치 merge하면 끝 | . | 여러명 작업시 merge대신 . 로컬에서 수정용 브랜치생성후 파일 수정 . | 원격레포에 push하여 수정용브랜치 생성 . | 합치기전에 PR과정을 전시하여 팀원들에게 확인받기 . | . | . Compare &amp; pull request 클릭 . . | PR은 팀원확인요청이다. 로컬 커밋메세지가 default로 적혀있는데, 커밋메세지에 PR메세지로서 추가로 적어준다. . . | 아래와 같이 커밋메세지 따로에, PR메세지가 덮어서 보인다. . | PR을 검수할 팀원에게 review요청하기(수정용브랜치를 merge해도될지) . PR메세지 우측에 Reviewers가 있다. 여길 선택해서, PR review를 요청하자. | . is3js(팀원)계정을 시크릿창으로 들어가보자. . 레포 &gt; Pull request &gt; 해당PR까지 클릭하고 가야지 Review요청한 것이 보인다. (호버해도 보이긴하네) . . | | . | 리뷰요청받은 뒤 Add your review는 lineByline으로 피드백 주는 것 . add your review 클릭 . | 플러스버튼으로 피드백을 주면되는데 드래그로 여러라인에 대한 피드백을 줄 수 도 있다. . | 리뷰요청시 피드백(라인별코멘트)과 별개로, 칼을 뽑아야함: Approve(merge) or Request changes(다시push해) . 코멘트를 다 남겼으면, 우측 상단에 Finish you review로 칼을 뽑아야한다. . 이 경우 수정이 좀 더 필요하다고 하여 승인거절한다.내용없이 Reqeust changes 클릭 | . | 내가 남긴 코멘트의 위치 및 승인거절=변화요구의 메세지를 확인한다. . | [로컬] review내용인 1) 라인별코멘트에 [대한 대답reply] &amp; 2) 변화요구에 대한 [에서 수정후 다시 push] . 라인별 코멘트에 대한 대답 . | 리뷰어에 의한 Changes requested는 feature/readMe에 푸싱함으로써 커밋을 추가하라고 뜬다. . reviewer에 의한 request changes는 &lt;수정용 브랜치로 추가 커밋하면 다시 검토&gt;를 말하는 것이다. | . 다시 로컬 해당 브랜치로 와서 . | 요구대로 새롭게 작성후 push까지 해준다. . # 파일 수정# add전 git gtatusgit status#git add 파일명git add README.mdgit commitgit loggit push origin feature/readMe . | | PR은 의 단위라서 아직 merge안됬다면, 해당브랜치는 이어지며 가서 확인한다. . git push origin feature/readMe를 통해 push했으면, 아직 해당 PR상황에서 커밋이 추가된다. . main에서는 추가 PR 안내가 없음. 수정용 브랜치에서는 평행우주의 내용은 변화되었음. | . | reviewer에 의해 request changes는 &lt;수정용브랜치로 추가 커밋하면 다시 검토&gt;를 말하는 것이다. 즉, 검토하고 있던 PR상황으로 다시 직접들어가보면, 추가 push를 확인할 수 있게 됨. | . | . . | **의 추가push후**에는 되면 **또다시 review 요청해야한다.** . . | 또다시 PR(수정용브랜치 merge검토)에 대한 review요청을 받음. -&gt; LGTM approve해주기 . 역시 해당 PR까지 클릭해서 들어와야 보인다. . add your review . 라인별 코멘트 -&gt; 생략 | LGTM(Loos Good To me)와 함께 Approve | . . | . | . review가 approve해야 드디어 merge가 뜬다. 동시에 . . . 우측의 Delete branch를 눌러 수정용브랜치를 삭제해주자. . | PR탭은 Merged로 해결됨. . | [issue탭]에서도 Merged가 뜸. -&gt; [PR-&gt;merged]의 해결된 issue를 닫기 . . issue작성 후 . 수정용브랜치 생성 | PR를 위해 커밋 커밋시 issue번호를 #번호형태로 커밋메세지 속에 남기면 issue탭에서도 표기가 된다. | . | . | 수정용브랜치 push -&gt; PR 생성 -&gt; review -&gt; merged로 해결되었으면 issue도 닫아야한다. . 메세지로 닫는다 알리기 . . | Close issue를 눌러서 해당 issue를 닫는다. . | | [로컬]에서 default [main]브랜치로 옮겨와, PR-&gt;merged된 프로젝트 정보를 git pull로 내려받아서, 로컬에서도 통합 및 브랜치삭제가 반영되도록 한다. . 삭제당한 feature/readme&lt;수정용브랜치&gt;가 아닌 default main브랜치로 옮겨와서 git pull받는다. | ❯ git checkout main ❯ git fetch ❯ git pull # git pull origin main 으로 정확하게 표시하면 upstream설정이 안뜬다. # 그러나 한번만 업스트림하면 되므로 그냥 해준다. ❯ git branch --set-upstream-to=origin/main main Branch &#39;main&#39; set up to track remote branch &#39;main&#39; from &#39;origin&#39;. ❯ git fetch ❯ git pull Updating 99ce761..1ed16b7 Fast-forward README.md | 4 ++++ 1 file changed, 4 insertions(+) .",
            "url": "blog.chojaeseong.com/git/2021/10/17/%EA%B9%834_PR%ED%8C%80%EC%9E%91%EC%97%85_1%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4_2%ED%8C%80%EC%9E%91%EC%97%85_3%EC%9E%87%EC%8A%88%EC%99%80%EB%A6%AC%EB%B7%B0%EC%9A%A9PR.html",
            "relUrl": "/git/2021/10/17/%EA%B9%834_PR%ED%8C%80%EC%9E%91%EC%97%85_1%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4_2%ED%8C%80%EC%9E%91%EC%97%85_3%EC%9E%87%EC%8A%88%EC%99%80%EB%A6%AC%EB%B7%B0%EC%9A%A9PR.html",
            "date": " • Oct 17, 2021"
        }
        
    
  
    
        ,"post160": {
            "title": "SKTacademy 코테 TIP과 자료구조",
            "content": "reference SKTacademy | | . 알고리즘 푸는 이유 . 구현: 생각하는 내용을 코드로 옮긴다. 연습안하면 안된다. 500문제 이상 풀어야함. 반복해야 언제 어떤 변수를 선언하고 언제 전처리 해야하는지 알 수 있게 된다. 빨라지고 나만의 코딩스타일이 생긴다. | 효율성: 계속 구현하다보면, 효율성을 챙기면서, 자주 사용하는 함수로 최적화 | 다른 사람들의 코드를 보면서, 효율적인 코드 작성 | . | 절차적 사고: 절차적인 사고에 익숙해짐. 언제 어떤 과정을 하고, 다음은 어떻게 해야하는지 | 적재적소한 알고리즘을 선택할 수 있게 된다. 그럴려면 자료구조, 알고리즘을 따로 공부해야한다. | . | . | 디버깅: 한번만에 맞는 경우는 거의 없다. 예외케이스 탐색을 많이 해야한다. 최저, 최대, 최악 경우를 넣어보면서 한다. | 코드(에러)를 읽는 능력 | . | . | 재미: 적은시간으로 연습 가능 | 프로젝트와 다르게 짧은 주기로 성취감 | . | 문제보고 감잡기 . 1초당 가능한 복잡도 간 미리 계산하기 . python으로 . 백만번(10^6) 반복문or덧셈곱셈 등… -&gt; 1초 안에 다 풀린다. | 천만번(10^7) -&gt; 1초 안에 대부분 풀린다. python으로 1초안에 천만~5천만(10^7 ~ 5* 10^7)까지 연산 가능하다 생각하자. | . | 1억(10^8) -&gt; 불가능 -&gt; 알고리즘 바꿔야함. | . | 다시 문제보기 . 시간제한부터 보기 . 1초 -&gt; 10&amp;7 안에 풀어야한다. | . | 입력 보고, 반복문 횟수 갸늠하기 . n = 10억 = 10^9 -&gt; 단순 반복문 O(N)으로 는 불가능하다. | 입력을 보고 O(N)이상 불가 -&gt; 루트(n) or lgN or O(1)으로 해야한다. | . | . | . | PS팁 . 입력과 초기화 . python의 input은 3가지 종류를 받는다. . 숫자1개 . python에서는 항상 string으로 들어온형변환부터 해준다. | . . | 문자열 . 일반 문장 | 쪼개면서, [i]번째 인덱싱도 하고 싶다 -&gt; list() immutable한 string 대신 list로 변환시켜줘야한다. | . | 다시 붙일려면 ”“.join사용 | . . | 숫자 배열 . map을 써서 형변환한다. | . . | . | **list(배열)의 초기화는 comprehension으로 ** . . | . | 에러메세지 확인하기 RE: 런타임에러 -&gt; zerodivision or indexError | TLE: 시간초과 -&gt; 잘짰는데 무한루프가 있거나, 알고리즘이 안 좋거나 | . | 추상화와 기능분리 . 맨 처음 반복문에 돌아가면서 기능을 해줄 or 테케마다 처리해줄 input()받기부터 시작하는 함수를 짜자. 대충 로직을 슈도코드 짜듯이 짜면서 반복문 - 체크 - 결과값 저장 등의 로직을 짠다. . | 코딩하는 2가지 방법 . 현재가 main함수라고 가정하고 while 문에서 다 돌리기 | process함수를 따로 만들어놓고, 테케를 process함수에서 받아 main에서 돌림 | . | 처음에는 다 while문에 넣고 돌린다. . | 하지만, main함수는 최소화 해서 가벼워야한다. 내용들은 다 함수로 보낸다. . 반복문을 돌되, 각 TestCase마다 따로 처리되도록 함수로, TC별 처리되도록 하는 함수를 만들어서 돌린다. | . . 일단 위에 스샷기준으로는.. 테케별 처리도되록 함수에서 input을 받고 -&gt; 리하고 -&gt; return 하고-&gt; main에서 for문 print(함수return값) | . | . | 예를 들어, 삼성기출-사다리조작문제를 보자. (풀이는 안함) . 삼성쪽은 문제가 되게 길다. 그림 위 수치 위주로 빠르게 한번 보자. . 일단 수치(숫자)를 먼저보고 &quot;아~ 사다리가 5줄, 6줄 되는 구나 &quot; . | 사다리를 중간에 넣을 수 있구나 . | 사다리를 진행해나가는 과정이 있구나 . . | . | 입력 양식(예제 입력)보기 . 첫줄의 숫자와, 나머지 아래 숫자가 같으니까 아 대충 아래쪽이 사다리를 의미하겠구나 | . | 문제를 자세히 읽기 시작하는데 출력 요구사항을 먼저 본다 . | 문제가 복잡해보인다. . **이 때, main함수를 간단하게 만들기 위해, 반복문 어떻게 돌릴지 판단 -&gt; 그안에서 사용될 기능 분리하여 일단 슈도코드로 함수들을 작성해 기능분리 시켜준다. ** . | 사다리를 최대3개까지 놓는데, . i에 놓을지 . j에 놓을지 . k에 놓을지 선택할 수 있게 3중for문을 만들어 탐색가능하게 함. . | 3개에 따라 가능한지 확인하는 check(i,j,k) 함수를 사용하고 슈도코드로 위에다 작성해둔다. . | 가능할 때, 그 i번째 사다리가 i로 내려오는지 체크해주는 함수result()도 슈도코드로 작성해둔다. . | . . | . | | . | 코드를 줄여 가독성을 높이는 조건문, 반복문, 함수 by python indent를 줄이기 . 반복문 eX&gt; N by N by N 3중 포문 . 똑같이 N**3 만큼 횟수는 동일하게 돌아가는데, 한번에 for num in range(N**3)으로 돌리면서 . i = num을 N^2으로 나눈 몫 = num // (N*N) | j = num을 N으로 나눈 몫을, 다시 N으로 나눈 나머지 = num//N % N | k = num을 N으로 나눈 나머지 = num % N | . | **내가 만든 2중 포문을 indent 1개로 ** . i = num을 N으로 나눈 몫 N*N을 통해, ` 0~N-1을 첫번째 구간으로해서 N개` 존재하는데, 0~N-1구간: 행을 0으로 간주해요 | N~2N-1 : 행을 1로 간주해요 | … | ~N^2-1 N개의 구간이 있어요 | . | . | j = num을 N으로 나눈 나머지 구간별로 0~N-1의 열을 담당해요. | . | . for num in range(N**2): i, j = num//N, num%N print(f&quot;({i},{j})&quot; , end = &quot; &quot;) . | 진법, 진수를 활용하면 더 쉬워진다고 한다. . | . | main 반복문 속 조건문을 if True:시 process()가 아니라 if not False시: continue로 아래 process() 건너띄기를 통해 indent를 챙길 수 있다. . . process()함수 위에다가 if not 조건문 :continue를 활용해서 탈락시 건너띄기하면, 반복문내 indent를 줄일 수 있다. | . | 함수안에 if : return 다음에는 else가 필요없다. . **if return / return도 return 삼항연산자로 줄일 수 있다. ** 가장 선호. flag도 이런식으로 할 수 있다. | . | . . | | 변수명은 snake_case로, 함수명은 cameCase로, Pascal은 시작부터 대문자인 Camel . | 적용해보기 주사위네개 . 나는 Counter를 활용했지만.. | . # 기존 내코드 N = int(input()) from collections import Counter max_money = float(&#39;-inf&#39;) # 같은 눈이 4개가 나오면 50,000원+(같은 눈)×5,000원의 상금을 받게 된다. # 같은 눈이 3개만 나오면 10,000원+(3개가 나온 눈)×1,000원의 상금을 받게 된다. # 같은 눈이 2개씩 두 쌍이 나오는 경우에는 2,000원+(2개가 나온 눈)×500원+(또 다른 2개가 나온 눈)×500원의 상금을 받게 된다. # 같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)×100원의 상금을 받게 된다. # 모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)×100원의 상금을 받게 된다. def calc_money(data): max_cnt = max(data.values()) val_lst = [ x[0] for x in data.items() if x[1]==max_cnt] if max_cnt == 4: return 50000 + (val_lst[0]*5000) elif max_cnt == 3: # val_lst = [ x[0] for x in data.items() if x[1]==max_cnt] return 10000 + (val_lst[0]*1000) elif max_cnt == 2: # val_lst = [ x[0] for x in data.items() if x[1]==max_cnt] if len(val_lst) == 2: return 2000+(val_lst[0]*500) + (val_lst[1]*500) else: return 1000 + (val_lst[0]*100) else: return max(data.keys())*100 for _ in range(N): data = list(map(int, input().split())) data = Counter(data) money = calc_money(data) max_money = max(max_money, money) print(max_money) . 수학을 이용하면서 . 기능분리 by 함수 | 입력과 초기화 by 튜플, 컴프리헨션 | 반복문, 조건문 줄이기 by 한번에돌기+ if reutrn후에는 no else noelif + 삼항연산자 | . . | . | 수학 . 반복문을 . range(min(a,b))로 길이를 줄이거나 | range(min(a,b),,-1)로 거꾸로 시작하거나 | range(,,n)으로 간격을 주는 것을 생각하자. | . | 유호제법은 코드로 외우자. . math.gcd써도될듯.. | . # a&gt;b def gcd(a,b): # 1) b가 a의 약수면.. 그냥 b가 최대 공약수 # 2) 그게 아니라면, 재귀로서 gcd(b, a%b)로 재귀로 빨리 구하자. return b if a%b==0 else:gcd(b, a%b) . | 소수판별과 에라토스테네스의 체 . 소수판별 isPrime은 . 이론상 소수=1과 자기자신만을 약수로 가짐 = 2~n-1까지 약수없음, 약수 나오면 탈락인데 . 약수와 배수의 관계에서 약수는 항상 짝을 이루어 존재하니 2~루트(n)까지만 검사한다. | . . | . | 에라토스테네스의 체 . 범위가 주어진다 1~n까지 중 소스의 갯수는? 1은 소수가 아니여서 지움 | 2부터 isPrime으로 소수판별 소수로 판별되면 -&gt; 소수의 배수들을 싹다 지움(어떤수의 배수는.. 소수가 아님 무조건 x2, x3들이 약수가 되니까 | . | . | . . 뭔가를 지울 때는 chk, ck배열에다가 index - T/F를 hashing하여 활용한다. 이미 범위가 정해져있으면 거의 이렇게 사용한다. count 정렬 | 에라토스 테네스의 체 | DFS BFS? | . | . . 그외 자세히 주석으로 달음 . def era(N): # 체크는 hasing용으로서, n index를 쓸 거기때문에 0부터 시작했더라도 range(N+1)까지 돌려준다. ck = [ False for _ in range(N+1) ] p = [] # 1은 소수가 아니므로 제끼고 2부터 체크한다. # 소수의 배수들을 True를 채워놓고, 다음에 올 때 건너뛰게 한다. # 과거에서 판단한 소수의 배수들에 안걸렸으면, 아직 False로 남아있는, 소수는 바로 append해 줘도 된다. # -&gt; 맨처음 2만, 최초이기 때문에 과거에서 True로 소수탈락시킨 경험이 없다. for i in range(2, N+1): # 아직 False인 것만 체크한다. # 아래에서, 미래원소들 중에 소수라고 판별내어놨으면 건너뛴다. # -&gt; check를 활용해서 건너뛰는 [ck 미래 -&gt; continue 로직]이다. if ck[i] == True: continue # False = 2의 배수부터 시작해서, 소수탈락(True)에 안걸렸다면, 소수라고 판단한다. p.append(i) # 현재 i는 소수라는 뜻인데, 소수-&gt; 소수의 배수를 True(소수탈락)로 지워야한다. # * i배수 조작-&gt; i배수는 range(시작수, 끝수, i)를 통해 +i씩 움직인다. # 이 때, i+i or i*2부터 +i씩 i*3, i*4를 지워나가는게 아니라 # * &lt; ixi &gt;부터 시작해서 i의 배수를 지워나간다 range(i*i, N+1, i) # -&gt; 왜냐하면, 이미 과거에서 지워났기 때문인데 # -&gt; 예를 들어, 6은.. 이미 2에서 지워놨음. 3에서 지울 필요X. # -&gt; 3은 뭐부터 지워나가야할까? -&gt; 앞에서 안나왔을, 3의배수로서만 존재하는, # -&gt; 3만을 약수로 가지는 = 9부터 지워나가면 된다. # -&gt; 2*i부터 지눠나가도 괜찮다. # for j in range(i*2, N+1, i): for j in range(i*i, N+1, i): ck[j] = True # 이제 리얼소수는 p 배열에, 체크여부는 ck(소수탈락시True?)로 반환한다. return ck, p print(era(10)) # ([False, False, False, False, True, False, True, False, True, True, True], [2, 3, 5, 7]) . | . | . | 하노이 = 분할정복 by 재귀 . n번째 자체처리를 잘 넣어주자. | 재귀가 꼭 return해줄 필요는 없다. return안한다면 꼭 + 등의 연산으로 연결해줄 필요가 없다. 갯수: return f(n-1) * 2 +1 | 출력: f(n-1) + print(n자체) + f(n-1) f(n-1)내부에서도 print가 호출됨. | . | BUT 재귀함수의 base case if는 반드시 return으로 종료시켜줘야한다!! | . | 변하는 것들을 인자로 잘 넣어주자. 숫자 명칭이 고정이라면, 합이 일정한 것도 이용하자. | . # 1-&gt;3def hanoi(st, ed, n): if n==1: return print(st,ed) # 1-&gt;2 n-1 # st-&gt;mid hanoi(st, 6-(st+ed), n-1) # 1-&gt;3 print(st, ed) # 2-&gt;3 n-1 # mid -&gt;ed hanoi(6-(st+ed), ed, n-1) . | 정렬 . 선택정렬(i+1~n-1와 비교 최소값 찾으면 swap, 매번 맨왼쪽 최소값 확정), 버블정렬( 매번 인접한수 비교후 크면 오른쪽으로 swap, 매번 맨오른쪽 최대값 확정)은 n, n-1, .. 1번 모두 탐색해야해서 시복 O( n(n+1)/2) = O(N^2)으로 너무 느리다. . | 퀵 소트 . 재귀로 구현. 1)p정하고 2) 작, 큰그룹나눠서 3)p자리 확정의 과정을 작은그룹에서 1번, 큰그룹에서 1번 다시 시행한다. . def quick_sort(array): # 리스트가 하나 이하의 원소만을 담고 있다면 종료 if len(array) &lt;= 1: return array pivot = array[0] # 피벗은 첫 번째 원소 tail = array[1:] # 피벗을 제외한 리스트 left_side = [x for x in tail if x &lt;= pivot] # 분할된 왼쪽 부분 right_side = [x for x in tail if x &gt; pivot] # 분할된 오른쪽 부분 return quick_sort(left_side) + [pivot] + quick_sort(right_side) . | . | 머지 소트 . 재귀시, divide후 conquer과정에 투포인터 개념으로 merge를 해야한다. . | 1)절반으로 나누고, 2) 각각을 투포인터개념으로 합친다. . # 합병정렬에서는 conquer과정이 복잡하다. # [divide] 는 그냥 반씩 쪼개면 되지만, # [conquer]된(정렬된 list2개) 것들을 [combine](2개 list 합하여 정렬)시 복잡하기 때문에 이 부분을 merge함수로 뺀다. def merge(list1, list2): merged_list = [] i = 0 j = 0 while i &lt; len(list1) and j &lt; len(list2): if list1[i] &lt; list2[j]: merged_list.append(list1[i]) i+=1 else: merged_list.append(list2[j]) j+=1 if i == len(list1): merged_list += list2[j:] elif j == len(list2): merged_list += list1[i:] return merged_list def merge_sort(my_list): # base case if len(my_list) &lt; 2: return my_list # divide and conquer left_half = my_list[:len(my_list)//2] right_half = my_list[len(my_list)//2:] # 부분문제는 원래함수(부분)을 한 상태가.. 정복된 상태다 조심! return merge(merge_sort(left_half), merge_sort(right_half)) print(merge_sort([12, 13, 11, 14, 10])) . 2개의 배열을 merge할 때, 4개짜리 배열을 미리 대기시켜놓고, 투포인터로 넣어줘야한다. | 즉, 메모리할당이 많아진다. | 머지 소트는 정렬 문제에서 메모리가 넉넉할 때 쓴다. | 퀵 소트는, 최악(역순정렬&amp;p를 맨첫값)의 경우 NN이 될 수도 있다. | . | python sort(), sorted()는 퀵소트, 머지소트보다 더 최적화된 정렬을 쓰니. 그냥 이걸 쓰자. . | . | 라딕스 소트(radix sort) = 카운팅정렬 -&gt; 이범정(10^6~10^7 이하)일 때 . **이미 최소~최대값의 범위가 정해져있을 때 **, 그 범위를 index로 hashing시킨 배열을 미리 만들어놓고 . | 카운팅한다. . | 카운팅수만큼 연속해서 나열� . | | 자료구조 . 쓰는이유: 효율성. 쓰는 의미가 있음. 사용처가 정해져있다. 메모리를 효율적으로 쓴다. ex&gt; stack: undo 마지막에 했던 작업을 되돌리기 위해. 직전꺼를 되돌리기 | . | 추상적: 코드가 정해져있지 않음. 개념이므로 라이브러리가 아니더라도 어느 언어라도 구현가능해야한다. | 재사용성: 계속 쓰기 위해 라이브러리를 제공함 python은 collections에 많음. | . | . | stack 접시닦고 다시 가져가는 것에 비유 많이함. undo | 넣고push 위에서부터 빼는pop 2가지가 핵심 | 배열과 다른점은, 맨 마지막이 빠져나가는 점 : LIFO | python에서는 따로 library없고 배열[]로 바로 사용한다. | 예제 : 괄호 -&gt; 여는괄호만 넣어서 쌓으며, 닫괄시.. 직전에 넣은 여괄 부터 꺼내 짝이 맞나 확인해야한다. | . | queue와 deque 왜쓸까? 배열이랑 달라보이지만, 불필요 메모리를 줄인다.메모리를 효율적으로사용하기 위해 배열로도 구현가능(pop한 앞부분으로 index를 한칸씩 당긴다.?) | 이미 pop한 것들을 붙잡을 이유가 없어서 그럴필요가 없음. | . | server에서 여러 queue를 써서, 여유로운 queue에 task를 넣어주는 형식(task분할) | python에서는 deque = stack + queue라서 queue문제는 deque | 예제: 요세푸스 돌면서 제거된 사람을 빼야하는 경우 -&gt; deque의 queue로 popleft + append를 rotate로 해결 | . | . | . 그래프와 Tree의 저장방법 . 그래프의 특이한 형태로서, 나가는 간선(outdegree)만 있으면 Tree . Tree도 2가지 저장방법이 있다. . 자식마다 부모는 only 1개씩, 자식배열에 저장 cycle없이 root node제외하고 다 부모가 1개씩 존재 | 밑에서부터 부모를 찾아 올라갈 수 있다. 4의 부모 2 -&gt; 2의부모 1 -&gt; 1의 부모 0 == root | . | . | 부모마다 여러개자식을, 자식list로 2차원배열에 저장 인접리스트 저장시, 아래로 내려가면서 순환을 돌기 좋다. 1의 자식2 -&gt; 2는 아래로 4,5,6을 볼 수 있으니 4번 부터 본다. -&gt; 4번은 비어서 leaf node로 끝났따 -&gt; 5번 보고 6번보고 하자. | . | . | . | Tree의 부모저장배열 -&gt; LCA찾기 예시가 촌수문제다. . 조상들 모을 default 0의 N+1개짜리 부모저장배열 생성 입력정보를 배열에 저장함. 부모 없으면 0 | . | 2개 node의 공통조상찾는다? 각각의 (조상, 촌수) 튜플이 담길 list를 선언 | 한번 타고올라갈때마다 거리를 더해줄 각각의 촌수변수 선언 | . | 각 node마다 부모가 없을 때까지 찾아가야한다. default 0이며, 안쓰는 p[0]에 0이 들어가있어 무한루프의 가능성이 있으니, 부모가 0되는 순간 빠져나와서, 아직 처리안된상태로 나와, 마지막에 한번더 처리해준다. | 나부터 시작, 거리0으로서 튜플로(조상,거리)를 모아준다. | 재귀적으로 한번 찾아갈때마다 B = p[B] 로서, 나를 부모로 업데이트해준다. 그러면 나의 부모의 부모를 찾아가도록 된다. | . | . N = int(input()) A, B = map(int, input().split()) # 1. 촌수는 Tree형태 그래프인데, 문제에서 부모(1개만) 저장하는 방식을 택했으니 # -&gt; 1차원 배열에 다가 받아준다. # -&gt; 자신의 부모를 모두 0으로 초기화 해놓는다. (1부터 시작하는 node -&gt; 0은 부모가 없다는 것을 표현함.) # cf) 자식들y는 여러개일 수 있어서 index에 놓고, 각 자식들에 대한 부모는 1명밖이다 -&gt; value로서 1개 p = [0 for _ in range(N+1)] # 2. 관계수를 for문에서 바로 받아, 각 관계 -&gt; 부모배열을 채운다. for _ in range(int(input())): x, y = map(int, input().split()) # * 3.우리는 1차원 배열에 [부모만!] 저장한다. # 1 2 중에 1이 부모니까 index 2에다가 1를 저장한다. # cf) 자식들y는 여러개일 수 있어서 index에 놓고, 각 자식들에 대한 부모는 1명밖이다 -&gt; value로서 1개 p[y] = x # 3. A와 B의 공통 조상을 찾기전에, # * A의 조상들을 모두 모은다, B의 조상들을 모은다 -&gt; 교집합? # ** 참고로, A조상을 모을 때는, A자신을 포함해서 A자신 정보, 촌수거리0 부터 시작해서 -&gt; 재귀적으로 (부모, 부모까지거리(+=1)의 정보를 호출해서 담는다. Aa, Ba =[], [] # Aa: A의 조상a, Ba : B의 조상a # * A의 조상들(부모, 부모의 부모.. ) 모으는 과정에서, A와의 촌수도 같이 튜플로 저장하기 위해 Ad, Bd = 0, 0 # 1) 자신x&lt;-부모p[x]로 업데이트하여, 부모의 부모도 다음번에 찾아가게함 # 2) 자신&lt;-부모 업데이트할 때, 거리도 +1 업데이트해서, 촌수도 올라가게 함. # 3) p[x] &gt; 0를 while if조건절에 놓아서, p[x]==0 부모가없는 지점까지 올라간다. while p[A]&gt;0: # 3-1) 제일처음에 들어가면, 나와의거리Ad=0인.. 나 자신을 0촌 조상으로 튜플로 넣어준다. (나, 나와의거리) Aa.append( (A, Ad)) # 3-2) 재귀적으로 내가 부모가 되도록 업데이트해서, # while p[updated A]부모의부모가 있다면 -&gt; (나 updated A=부모, 전보단 늘어난 거리updated Ad +1) # 을 조상으로서 재귀적으로 모아준다. Ad+=1 A = p[A] # 내가 내 부모가 된다. for 다음단계를 위한 업데이트 # * 부모가 없는 p[A]=0의 root node도 넣어줘야한다... root node가 공통조상이 될 확류은 높다. # - 현재 p[A]==0상태이며, 첫 0이라서.. 루트노드로 업데이트된 것 일 것이다.. 마지막에 한번만 넣어주자. Aa.append((A, Ad)) # 4. B도 마찬가지다. while p[B]&gt;0: Ba.append( (B, Bd)) Bd+=1 B = p[B] Ba.append((B, Bd)) # print(p) # * 5. 2개배열을, &lt;2중 포문&gt;으로 1:1매칭 해보면서, 튜플 (조상, 촌수) 중 조상이 같을 때를 찾늗나. # -&gt; 조상이 같은 순간에서 촌수를 더해버리면 된다. for i in Aa: for j in Ba: # 여기는 Aa, Ba 조상들의 1:1매칭 공간 if i[0] == j[0]: print(i[1]+j[1]) # 등장하면, 제일 빠른 것을 만난 순간 바로 프로그램을 종료하면 된다. exit() else: print(-1) . | . | 나가는 간선외 들어오는 간선(indegree)까지 있으면 Graph . 그래프는 2가지 저장방법이 있음 . 인접행렬 : 행: 출발점 -&gt; 열: 도착점을 나타내는 N by N행렬 . 인접행렬도 3가지가 있음. 노방향 | 방향 | 방향+가중치 | . | . | 인접 리스트 : 튜플로 갈수 있는 (가중치, 노드) list를 인접한 list에 저정함. . 1의 indegree는? 0 (들어오는게 없다) . | 1의 outdgree는? 3 (3개가 나간다.) . in, outdegree가 중요한 이유는 indegree가 0인 지점이 시작점 일 될 수도, 한붓그리기 는 짝수여야한다. 등의 규칙이 있음 | . . | . | 이렇게 그래프를 저장하면, 최단거리나 가중치를 고려한 최소비용 등을 계산할 수 있게 된다 . | . | . | . 규칙적용된 tree인 이진트리로 heap/bst . 이진트리: Tree구조 자체가 graph만큼 어려워서 규칙을 정했는데 Tree의 rootnode가 1부터가 시작 | 자식은 최대2개로 하여-&gt;왼쪽자식node == 부모node의 2배가 너넘버링된다. 나node//2 는 부모node | . | | heap: NlgN으로 정렬을 유지하면서 데이터 pop/push가 가능하다. 그림 출저 | . | bst: python에서는 set, dict의 key를 원소-&gt; hash값 -&gt; hash값들을 bst 구조로 만들어 내부에서 사용되어 중복안되고 bst로 검색해서 빠르다? | . 그래프, 일반Tree, 점, 격자판 다 탐색하는 DFS와 BFS . DFS 전수조사시 사용되하는데, 1-&gt;0 마지막 탐색지점에서 빽할 때, 직전 node가 필요한데, 직전node를 stack 선언후 쌓아두는게 아니라, 재귀를 이용해서 stack을 자동 사용한다. 재귀함수=함수=stack메모리에서 관리되어 stack처럼 쓰임 | . | . | BFS 시작좌표(시작점, root node)에서 시작하여 level별 = 최단거리별 기록하기 위해 queue(deque)을 사용한다. 목표좌표가 나타나는 최단거리(level)을 구하거나 | 해당 level이 끝났을 때 최단거리의 수? | . | level별로 좌-&gt;우순으로 검색한다. | queue에 시작좌표를 넣어놓고 빼고 -&gt; (목표좌푠지확인) -&gt; 자식들 탐색 -&gt; 검사 -&gt; 넣기전 자체처리 -&gt; queue에 넣기 -&gt; (level별 시행시 L+=1) | . | . | . | 2개의 사용차이 찾는 범위가 국한되어서 n번안에 찾아지는 것이 확신을 할 수 있을 경우 -&gt; BFS 숨바꼭질2 | . | 모든 범위를 찾아봐야 하는 경우(매 탐색마다 1-&gt;0 바뀌는 끝을 찍어야하는 경우?) -&gt; DFS 단지번호 붙이기 | . | | . 앞으로 공부하는 방법 . 많이풀기 삼성은 DFS, BFS 30문제정도 | 카카오는 Trie를 포함해서 30문제정도 | | 암기하기 이해로는 X 많이 쓰면서 암기하는 과정이 필요하다. | 자기만의 템플릿이 있어야 한다. | | 주기적 체크하기 대회? | 안내서 노션 | |",
            "url": "blog.chojaeseong.com/python/algorithm/2021/10/17/sktacademy_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_python_%EB%AC%B8%EB%B2%95TIP.html",
            "relUrl": "/python/algorithm/2021/10/17/sktacademy_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_python_%EB%AC%B8%EB%B2%95TIP.html",
            "date": " • Oct 17, 2021"
        }
        
    
  
    
        ,"post161": {
            "title": "협업1) 나혼자 투컴으로 협업",
            "content": "나혼자 투컴협업(local to remote to local2) . Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . local to remote . 이미 로컬에서 관리하던 프로젝트를 github로 . local에서 작업시작 . 폴더 생성: . /home/is2js/workspace/git-github . | git init . | 계정입력(이미 global로 했으면 안해도됨) . | 파일 생성 . cat | mouse | . | 커밋 . ❯ git add -A ❯ git commit -m &quot;FIRST COMMIT&quot; . | . | 혹시나 연결된 원격레포가 있는지 확인 . git remote 아무것도 안뜨면 없는 것 | . | . | 깃헙 레포 생성(git-github) for 로컬을 원격으로 . readmd 등 생성하지 말아야함! 이미 local에서 git으로 관리하고 있던 프로젝트를 올리는 것이므로 아무것도 없어야함. | 아무것도 코드가 없을 때 나타나는 화면이 나와야함 | 구성 : https://github.com/is2js/git-github.git githuburl + /유저명/레포명.git | . | . | . | git status로 현재까지의 상황이 다 커밋되어있는지 확인한다. . ❯ git status On branch master nothing to commit, working tree clean . 빠진게 있으면 전부 add -A해서 commit | . | 로컬내용을 빈 원격레포에: git remote 등록 git push 내용옮기기 . 원격레포에 코드가 없을 경우 뜨는 페이지에서 …or push an existing repository from the command line 란을 복사버튼을 눌러서 . 현존하는 로컬 깃관리 레포를, 원격레포에 push하도록 복사한 내용을 cli에 붙혀넣기 해준다. . 현재는 코드가 main브랜치를 만들고, main 브랜치로 push하도록 변경되어있다. . | 복붙후 내 로컬도 main브랜치로 바껴있다. . | 아예 master브랜치 -&gt; main브랜치로 브랜치이름변경하는 명령어 인가보다. . git branch -M main . With a -m or -M option, will be renamed to | . &gt; git branch * main (END) . | . &gt; git remote add origin https://github.com/is2js/git-github.git git branch -M main git push -u origin main Counting objects: 4, done. Delta compression using up to 12 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (4/4), 273 bytes | 273.00 KiB/s, done. Total 4 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-github.git * [new branch] main -&gt; main Branch &#39;main&#39; set up to track remote branch &#39;main&#39; from &#39;origin&#39;. . | 이 때, 명령어를 뜯어보면 . git remote add origin https://github.com/is2js/git-github.git . git remote add [원격레포의 별칭, default origin] [레포 url]로서 원격레포url의 원격레포를 별칭(origin)으로 등록 | . | git branch -M main . 브랜치명을 main으로 변경 | . | git push -u origin main . git push -u [등록된 원격레포별칭, default origin] [올릴 원격레포의 branch] | . | 이후 나오는 메세지 중 현재 main브랜치가 , 원격레포인 origin의 원격 브랜치main을 추적한다.고 메세지가 뜬다. . Branch &#39;main&#39; set up to track remote branch &#39;main&#39; from &#39;origin&#39;. . | . | git remote명령어로 실제로 연결이 잘되었는지 확인 . ❯ git remote origin . | . | 빈 원격레포에, 관리되던 로컬 프로젝트 내용이 올라갔다면, 레포의 기본페이지가 바뀐다. . 커밋내용은 로컬에서 커밋한 기록들이 다 뜬다. | . | 소스트리에서 해보기 . 소스트리로 해당 레포 열기 | 저장소탭 &gt; 원격 설정 클릭 현재 나는 이미 터미널로 연결된 상태라, 원격 저정소 경로에 하나가 추가 되어있다. | . | 추가 클릭 원격 이름: 원격url의 원격레포에 대한 별칭, default origin | URL/경로: 원격레포의 url 복붙 | 호스트 종류: github | 사용자명: github id 입력 | . | 원격 탭에서 원격레포의 별칭(주로 origin)으로 확인하기 . | push버튼 클릭 로컬 / 원격(리모트) 브랜치를 각각 선택해주고 push해주자. | . | 파일추가(수정) 후 commit까지 한 뒤 push: git push [원격레포별칭] [그 레포의 브랜치] . dog파일 추가 . | git add - A, git commit -m , git push [원격레포별칭, 주로origin] [그 레포의 브랜치] . ❯ git add -A ❯ git commit -m &quot;ADD dog&quot; [main 15a73f6] ADD dog 1 file changed, 1 insertion(+) create mode 100644 dog ❯ git push origin main Counting objects: 3, done. Delta compression using up to 12 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 302 bytes | 302.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-github.git d33f3a8..15a73f6 main -&gt; main . | 올릴필요가 없거나(코드로 자동생성) 올려선 안되는 파일(DB계정 등)처리: .gitignore . 올릴 필요가 없는 파일 : 코드로 자동 빌드되는 파일들 그 때 그 때 실행해서 만들면 되므로 올릴 필요가 없다. 안드로이드나 스프링 등에서 처음부터 골격이 세팅된 체 시작하는 프로젝트들을 생성하면 .gitignore가 미리 만들어져있다!! | . | . | .gitignore에 등록하면 add + commit의 대상으로 안봄. 버전관리 안됨. | . | . 프로젝트폴더 최상위 공간안에 .gitignore파일 생성 . 숨김파일로 지정되니 참고해야함 | . | gitignore에 넣을 파일 secret-animal을 만들고, git status로 상황을 확인하자. . Untracked files(add해야할 목록)로서 아직 add안된 파일 2개를 알려준다. . Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) .gitignore secret-animal . | . | 이 상태에서 secret-animal 파일을 .gitignore에 적으면, git status상 add해야하는 파일에서 제외된다. . 아하~ 아예 add할 파일로조차 보지도 않음. | 내 프로젝트에 있어도 add + commit을 안하므로 push도 관리도 안됨. | . Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) .gitignore . | remote to com1,2 . 원격repo를 현재폴더에다가 가져오기: git clone [url] . . 1개 컴으로 연습하려면, 폴더 2개를 만들어서 해보면 된다. . . 일단 폴더 2개를 만든다 computer-1 | computer-2 | . | 참고) clone시 해당목적지 폴더로이동 &gt; git clone [url] [.] | 소스트리는 해당 목적지폴더 선택만 | . | . | . 컴퓨터1의 폴더를 vscode로 연 다음, 터미널도 켠다. . 윈도우탐색기 &gt; wt -d . &gt; code . &gt; ctrl + ~ + wsl로 repoen? 윈도우 통해서 들어가면.. vscode wsl원격버전이 안켜진다. | . | wt &gt; wsl &gt; 해당폴더로 이동 &gt; code . | . | 기존 작업하던 원격레포(git-github)의 url를 복사한 뒤, vscode 폴더 터미널에다가 git clone한다. . #git clone [url] [.] git clone https://github.com/is2js/git-github.git . . 만약, clone시 [.] 현재폴더 옵션을 안주면, 그 내부에 폴더를 새롭게 만들어버림 . 새로운 컴퓨터의 로컬폴더 컴퓨터-1에다가 원격repogit-github의 내용을 가져왔다. | . | . | 연결된 나의 원격repo가 아니라 아무 원격repo를 클론해오더라도 git log로 모든 작업내역을 볼 수 있다. . git log . | 이제 소스트리로 컴퓨터-2 로컬폴더로 clone해보자. . + (new) tab &gt; Clone &gt; . 소스경로/URL : 원격레포url | 목적지 경로: computer-2폴더 지정 git clone 시에는 [원격레포url] [.] 현재폴더로의 옵션을 붙혀줘야하지만, 소스트리에서는 안해주고 폴더만 선택해주면, 그 폴더로 다 clone | . | . . | 이제 컴퓨터-2도 vscode로 열자. . | . | 새로올린(뒤쳐진) 커밋 내역 자동 확인: git fetch + git status . 컴1작업 -&gt; 원격레포에 push -&gt; 컴-2에서 일일히 작업내역을 확인하지 않고, git fetch로 뒤쳐진 내역이 있는지 확인 컴퓨터1 | 컴퓨터2 | . | . 컴1에서 dog name을 수정하고, add, commit호 원격레포에 push까지 해보자. . local의 global계정이 내 계정이라서 그런가 바로 push된다. . ❯ git add -A ❯ git commit -m &quot;EDIT dog&quot; [main 1eaa722] EDIT dog 1 file changed, 1 insertion(+), 1 deletion(-) ❯ git push origin main . . | . | 이제 컴2에서 일일히 github에 새로 올라운 커밋내역을 확인하기 힘드니 git fetch로 뒤쳐진==새로올라온 커밋의 갯수를 확인한다. . ❯ git fetch ❯ git status On branch main Your branch is behind &#39;origin/main&#39; by 1 commit, and can be fast-forwarded. (use &quot;git pull&quot; to update your local branch) nothing to commit, working tree clean . 원격레포/main 브랜치에비해, 내 브랜치가 1개 커밋 뒤쳐져있다고 나온다. | . | 뒤쳐진 내용 받아오기: git pull [원격별칭] [브랜치명] . 컴2에서 뒤쳐진 1개의 커밋을 받아온다. . &gt; git pull origin main From https://github.com/is2js/git-github * branch main -&gt; FETCH_HEAD Updating 15a73f6..1eaa722 Fast-forward dog | 2 +- 1 file changed, 1 insertion(+), 1 deletion(- . . | 소스트리에서도 git pull을 하기위해 . 컴2에서 dog 이름 수정 . | 소스트리 컴2에서 커밋과 동시에 push . . | 소스트리에서 컴1 폴더를 add . | 컴1폴더에서 패치버튼 선택 &gt; 모든 원격저장소에서 가져오기 선택 . . | main 브랜치에 당겨올 것들이 있다고 메세지가 뜸 . | pull버튼으로 받아오기 . | . | 일단 작업전에 메세지 안떠도 pull부터 누르고 시작하자 . 나혼자 투컴협업 branch, conflict . 브랜치를 이용해서 투컴협업 . 브랜치 전환, 없으면 생성해서 : git checkout -b [브랜치명] . branch기본 생성 : git branch [이름] | 전환 : git checkout [이름] | . | 브랜치 생성과 동시에 전환 git checkout -b [이름] checkout은 커밋id, 브랜치, tag 다되므로.. -b옵션을 주면 브랜치전환인데, 없으면 생성까지 | . | . | . 컴1에서 my-idea 브랜치 생성 . git checkout -b my-idea . . git branch . | my-idea이라는 평행우주에서 파일을 수정하고 add commit까지 한 뒤 push할 준비를 해자. . mouse 삭제 . | dinosaur 추가 . ❯ git add -A ❯ git commit -m &quot;ADD dino&quot; [my-idea e43a292] ADD dino 2 files changed, 1 insertion(+), 1 deletion(-) create mode 100644 dinosaur delete mode 100644 mouse . | . | 새로운 브랜치(평행우주)를 push: git push [origin] [새로운 origin의 브랜치명] . my-idea 브랜치를 -&gt; origin의 특정브랜치로 생성해서 push할 수 있다. 하지만 보통은 원격레포에 로컬과 같은 브랜치명으로 생성해서 올린다. | . | . 컴1의 my-idea브랜치와 동일한 이름으로 원격레포의 브랜치를 생성해서 push까지 해보자. . ❯ git push origin my-idea Counting objects: 3, done. Delta compression using up to 12 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 304 bytes | 304.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) remote: remote: Create a pull request for &#39;my-idea&#39; on GitHub by visiting: remote: https://github.com/is2js/git-github/pull/new/my-idea remote: To https://github.com/is2js/git-github.git * [new branch] my-idea -&gt; my-idea . **new branch로서 [로컬my-idea] -&gt; [원격my-idea]으로 push했다고 나온다. ** 즉, 로컬의 평행우주를 push한다고 해서 1:1대응 되는 것이 아니라 원격의 원하는 이름의 평행우주를 만들어서 push하는 구나. | . | . | 원격레포에서 새로운 브랜치(평행우주)가 생성되었고, push도 되었으니 PR를 고려해보라고 메세지가 뜬다. . . my) PR는 push된 임의의, 새로운 평행우주를 기본branch로 합치겠습니까? 정도이다. | 브랜치를 바꿔서 들어가보면, **새로운 평행우주가 로컬-컴1의 my-idea그대로 ** 펼쳐진다. | . | 원격레포의 새로운브랜치를 받는 방법은 [브랜치 생성&amp;전환명령어] 응용: git fetch -&gt; git branch -a -&gt; git checkout -b [생성할 로컬 브랜치(결국엔 뒤에 기입한 원격브랜치를 받아올 브랜치)] [origin(별칭)/pull해올 원격 브랜치명] . git checkout -b [생성할브랜치(결국엔 뒤에 기입한 원격브랜치를 받아올 로컬 브랜치)] [origin(별칭)/pull해올 원격브랜치명] 브랜치 생성&amp;전환 명령어로 원격레포브랜치를 pull까지 해버린다. | git checkout -b : 생성과 동시에 전환 | [생성할 로컬 브랜치(결국엔 뒤에 기입한 원격브랜치를 받아올 로컬 브랜치)] : 아직 원격이 새 평행우주(branch)가 없는 로컬에서, 받아줄 브랜치(평행우주)를 지정한다. | [origin/pull해올 원격브랜치명] : 원격레포 속 받고 싶은 평행우주 | . | 컴2에서 원격레포의 새로운브랜치(평행우주)를 받아보자. 굳이 main에 합쳐진 것이 아니어도 받아서 사용해도 된다. | . | . 컴2에서 로컬용 git branch에 -a옵션까지 더해서 원격 브랜치도 확인한다 . git branch -a * main remotes/origin/HEAD -&gt; origin/main remotes/origin/main . 원격branch는 github의 소식을 업데이트를 해줘야한다 | . git fetch git branch -a * main remotes/origin/HEAD -&gt; origin/main remotes/origin/main remotes/origin/my-idea . 원격레포의 (HEAD, default 작업장소)가 보는 곳은 아니지만 밑에 새로운 평행우주가 추가되었음 | . | 원격레포의 새로운 평행우주(my-idea)를 컴2의 my-dea로 받아와 보자. . 브랜치 생성&amp;전환명령어로 원격레포브랜치를 pull까지 해버린다. | . #git checkout -b [로컬브랜치명] [origin/원격브랜치명] ❯ git checkout -b my-idea origin/my-idea Branch &#39;my-idea&#39; set up to track remote branch &#39;my-idea&#39; from &#39;origin&#39;. Switched to a new branch &#39;my-idea&#39; . git branch로 확인해보자. . main * my-idea . | . | 소스트리로 컴2:new브랜치생성 to 원격 to 컴1으로 넘겨보기 . 이번엔 소스트리로 컴-2에서 브랜치를 생성후 원격레포에 생성과 동시에 PUSH . 브랜치 탭 &gt; 새 브랜치 : my-another-idea . | cat이름을 nyang으로 변경 . | 커밋과 동시에 origin푸쉬 by 소스트리 . . 만약 소스트리가 아니라면? . ❯ git add -A ❯ git commit -m &quot;EDIT cat name&quot; ❯ git push origin my-another-idea . push origin은 없으면 해당 브랜치 생성해서 push한다. | . | . | 깃허브에서 branch 생성 확인 . . | . | 컴-1의 소스트리에서 컴2-new브랜치(my-anther-idea)받아보기 . **컴1의 소스트리 &gt; 원격 탭 클릭 &gt; 원격의 새 브랜치 더블클릭 &gt; 새 브랜치로 체크아웃 ** . . | **원격 브랜치의 체크아웃만으로 로컬의 새브랜치를 생성 및 가져온다. ** . 따로 pull의 과정이 없는 것이 cli 든 소스트리든 마찬가지다 | . | . | my) 새 브랜치는 pull이 아닌 [checkout -b]만으로 로컬에 새 브랜치를 생성 및 내용을 가져온다. . 로컬 컴1-main에 브랜치들 merge(자동커밋)후 push -&gt; 컴2에서 fetch로 확인후 받아오기 . 컴1에서 브랜치병합후 원격레포에 push해보자. | . main(master)로 이동(받는놈) . | 주는놈인 my-another-idea 우클릭 &gt; 병합하기 . 현재 브랜치로 (주는놈) 병합 | . | push할 커밋수 확인해보기 . 병합전: main옆에 1은 push할 커밋수다. . . | 병합(자동커밋!)후: main2로 push할 커밋 1개 늘어남. . | . | 병합된 내역(커밋)까지 컴1 -&gt; 원격 레포에 소스트리로 push . push버튼 &gt; 병합된 내역 push | . | 이제 컴2의 소스트리에서 fetch로 원격상황 받아오기 . main브랜치에 pull받을 것들이 있다고 업데이트된다. . . | main으로 이동후 pull받아오기 . | . | ### . 충돌해결로 협업 . 한쪽에서 파일1을 수정해서 push했는데 . 다른쪽에서 파일1을 pull받지 않은 상태로 수정후 로컬커밋한 상태 . . | 다른쪽에서 pull받아야하는데, 같은파일이 수정된체 커밋된 상태면, conflict . . | . | . 직접 충돌내보기 . 컴1에서 dog파일 수정, 커밋, push . 한쪽 수정(bark: wang wang)이 push한 상태 . ❯ git add -A ❯ git commit -m &quot;EDIT dog bark wang&quot; ❯ git push . | . | 컴2에서 pull 받지도 않은 체 dog파일 수정후 커밋 . 다른 쪽이 pull안한체로 수정후 커밋한 상태 . ❯ git add -A ❯ git commit -m &quot;EDIT dog bark warl&quot; . ❯ git push To https://github.com/is2js/git-github.git ! [rejected] main -&gt; main (fetch first) error: failed to push some refs to &#39;https://github.com/is2js/git-github.git&#39; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., &#39;git pull ...&#39;) before pushing again. hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details. . pull할게 있으면 push가 안된다. | . | . | push가 안되면 . 원격에 누가 새 작업을 올렸구나. pull부터 받자라고 생각 . ❯ git pull . | . | pull받았는데 conflict나면 . 저쪽에서 같은 파일 수정했구나 ㅠㅠ라고 생각 . | git status로 더 자세한 상황을 보자. . ❯ git status #... both modified: dog #...저쪽과 나 모두 dog파일을 수정했네.. . | vscode에서 처리하기 . HEAD : 내가 작성한 부분 . | ===아래부분 : 저쪽이 작성한 부분 . . | . | . | conflict 후에는 git commit 을 -m 없이 커밋하여, 충돌 메세지를 그대로 저장하도록 한다. . git add -A git commit . git push해서 수정본을 원격레포로 보낸다. | . git push . | 브랜치삭제, 원격브랜치삭제: git branch -d vs git push -d [origin] [원격브랜치] . git branch 목록보기 . git branch -a . | 로컬 삭제 &amp; 원격 삭제 . 로컬 : git branch -d [브랜치명] | 원격 : git push -d origin [브랜치명] | . ❯ git branch -d my-idea Deleted branch my-idea (was e43a292). ❯ git push -d origin my-idea To https://github.com/is2js/git-github.git - [deleted] my-idea . | 소스트리로 충돌만들고 해결해보기 . 충돌일으키기 : pull받기 전, 같은 파일 수정후 로컬 커밋 push하면 충돌 발생 | 소스트리는 커밋과 동시에 push하므로 커밋당시에 발생 | . | 서로 다른브랜치(평행우주)라도 같은파일 수정상태면 conflict남 | . pull받기전에, 저쪽에서 수정한 파일을, 나도 수정한 뒤 소스트리로 커밋&amp;push를 눌러본다. 커밋은 성공했다고 따로 메세지 뜸. | . | push시 에러 -&gt; pull받자 -&gt; conflict뜨면? -&gt; 같은파일수정했네 pull을 했더니 소스트리에서 conflict를 알려준다. | . | **파일상태 탭으로 가보면, ** 충돌파일은 아직 add되지 않은 unstaged된 파일로서 존재 | 충돌파일 클릭시 충돌내용이 vscode처럼 나옴 | 충돌 커밋메세지는 자동 작성되어있음 cli라면 git commit만 하란 소리 | . | . | 직접 에디터(vscode)로 가서 수정해줘야한다. | 다시 소스트리로 와서 add후 커밋&amp;push | my) push에러 -&gt; pull받자 -&gt; conflict -&gt; 같은파일 수정했네. .",
            "url": "blog.chojaeseong.com/git/2021/10/16/%EA%B9%833_%EB%82%98%ED%98%BC%EC%9E%90%ED%88%AC%EC%BB%B4%ED%98%91%EC%97%85_branch_conflict.html",
            "relUrl": "/git/2021/10/16/%EA%B9%833_%EB%82%98%ED%98%BC%EC%9E%90%ED%88%AC%EC%BB%B4%ED%98%91%EC%97%85_branch_conflict.html",
            "date": " • Oct 16, 2021"
        }
        
    
  
    
        ,"post162": {
            "title": "심화) vscode로 git 심화 학습",
            "content": "Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . 깃 기본 with vscode . extension 2개 설치 . git extension pack | git extension pack 검색후 설치 | gitlens와 gitignore가 동시에 설치되어진다. | 왼쪽메뉴에 소스제어 를 클릭하면, gitlens가 통합되서 나온다. | 설정 &gt; git enable이 활성화 되어있는지 확인한다. . | gitlens layout 수정 . gitlens를 왼쪽메뉴에 따로 보이게 되었는데, 설명서를 읽으니 gitlens.setViewsLayout 검색 &gt; default로 클릭해야 source control탭에서 통합해서 볼 수 있다. | . | _git history는 팔레트에서 git log를 검색해서 사용 | . markdown all in one | markdown all in one검색 후 설치 . gitignore (팔레트커맨드) . add전에 설치된 gitignore를 사용하기 위해서ctrl+shift+p(모든 명령어, 팔레트)에서 gitignore를 검색하여, add ignore를 클릭 이후 python 을 검색해서 선택 -&gt; 파이썬을 제외시키는게 아니라 python관련 불필요 파일들이 등록이 된다. | create .gitignore가 생성되었다고 뜬다. | . | 소스제어에서, gitignore도 뜨는데, [파일열기]버튼이 따로 있다. . | python프로젝트를 선택하더라도 .vscode/폴더를 맨끝에 추가해준다. . .vscode로 달아도 되지만, 폴더라서 마지막에 슬래쉬도 넣어준다. | . . | . add remote(팔레트커맨드) . 빈repo를 생성 . readme파일만 체크해서 생성( 첨부터 push안되게 충돌내기 위함. ) | . | &gt; add remote 후 repo 선택 . 주의 [remote name]: origin으로 기본적으로 설정한다!!! . | 참고) add remote를 2개 했다면? git remote + remove [remote name] . | . | git config --list로 연결된 원격레포의 주소 확인하기 . | add, commit, and push in commits . U 파일들에서, +버튼을 눌러 add시키면, staging된 변경사항으로 이동한다. . | commit은 상단의 [소스제어]에서 체크버튼으로 staging된 변경사항을 한번에 다 commit시킨다. . | [commits] 탭 push를 클릭했다. . 해당 repo에서 push내역을 확인 | . . | . pull(명령어) 및 이질적인 프로젝트 병합 허용(–allow-unrelated-histories) . git pull origin main . 현재 remote가 빈 레포가 아니므로, push가 바로 안됨 . readme.md가 있기 때문에 pull당겨와서 충돌해결하고 해야함. . fatal: refusing to merge unrelated histories . | 이건 뭔짓을 하더라도 안됨. 따로 설정하면서 pull을 해줘야한다. . | . | . git pull origin main --allow-unrelated-histories . push . 갑자기 commits탭에서 사라져서.. 그냥 . vscode 작업표시줄을 클릭하여 push . | F1(팔레트)열고 git push검색해서 push . 해도 됨 . | . . | . [개념] branch (실무 많이) . main은 항상 deploy상태로 유지 | topic branch = 수정용 브랜치 = push해서 PR하는 브랜치 push를 자주해서 날라가는 것을 방지하자. | 검토후 merged(PR)후에 바로 삭제하는 브랜치 | . | develop branch는 삭제안한다. | main브랜치는 항상 최신으로 유지하므로 각 기능별 브랜치는 main에서 딴다. | [실습] branch(명령어) . . from-br없이 브랜치를 따면, 현재 브랜치에서 따는 것이므로 git branch명령어를 확인하고 따자. git branch new-br from-br | git branch git branch new-br | . | . | -로 직전브랜치를 checkout할 수 있다. . | checkout -b [new-br] [from-br]로 생성하면서 동시에 브랜치를 변경하게 되므로 가장 자주 쓴다. . git branch testbr main git branch * main testbr git checkout testbr Switched to branch &#39;testbr&#39; git branch main * testbr git checkout - Switched to branch &#39;main&#39; Your branch is up to date with &#39;origin/main&#39;. git branch * main testbr git checkout -b work main Switched to a new branch &#39;work&#39; git branch main testbr * work . | . git merge 와 fastforwad . 그림 출저 | . . merge commit은 서로 다른 상태의 브랜치를 병합해서 새로운 commit을 만드는 경우이고 . fast forward는 동일 내용이 포함되는 브랜치일 경우 브랜치 이동만으로 병합해서 따로 commit을 생성하지 않는 경우입니다. . | . topic branch(작업용브랜치) main에 merge후 삭제: git merge –no-ff / git branch -d . 현재 브런치 목록 . main testbr * work remotes/origin/main . | . work를 토픽브랜치라 가정하고 파일 work.py생성 후 커밋 . | main으로 돌아오면 당연히 파일이 없음. . | main에서 merge했다는 커밋을 남기면서(--no-ff) work브랜치를 받아오자. . 파일의 변화가 차이밖에 없는 경우. HEAD만 이동시키는 merge는 커밋이 발생안하고 앞으로 이동만 -&gt; fast forward가 발생하는데, 여기서는 직접 merge 메세지도 남긴다. | . ❯ git merge --no-ff work . | merge의 log확인을 git history라는 익스텐션으로 해보자. . 나는 git graph라는 익스텐션도 보인다. . . git history . | git graph . . | git log –oneline –graph 의 명령어 . . | . | . | merge확인후 topic branch삭제 . ❯ git branch -d work Deleted branch work (was cbf2765). . | git 탭에서 브랜치 변경후 개별커밋들 확인 . . 해당브랜치 화살표누르면 switch (checkout 됨) . | 왼쪽 화살표를 누르면, 각 브랜치마다 커밋 목록이 보인다. . 브랜치 생성이전 main브랜치 커밋이 그대로 보이는 듯함. | . . | testbr에서만 파일 생성후 커밋해보자. . testbr이 위로 올라왔다. branch 생성이후부터 달라진 커밋 차이가 난다. | . | . | [중요] topic branch에서 [다른topic이 merge된 main] 의 파일 1개만 받아오고 싶다면: git checkout -p . testbr에서 main속 work.py를 가져오고 싶다면 . git checkout -p [가져올브랜치명] [가져올파일명]을 이용한다. wsl2에서 안되서 windows 상태에서 하니깐 됬음. | . | . | . ​ 1. git checkout -p main work + y 로 main브랜치의 work.py를 가지고 온다. . ❯ git checkout -p main work.py diff --git b/work.py a/work.py new file mode 100644 index 0000000..e69de29 (1/1) Apply addition to index and worktree [y,n,q,a,d,?]? y . 현재 상태를 보면 add까진 된체 로 온다. add전후 살펴보는 git status로 봐도, 이미 Add는 되어있다. | . | work.py에 내용을 조금 넣어주고 commit하자. | 직전 commit의 메시지 변경: git commit –amend . git commit --amend를 치면, 직전 commit에 대한 메세지 수정사항이 editor 로 열린다. | git commit --amend . 메세지를 저장하면 자동으로 반영되어진다. . | 참고 . 마지막 커밋A에 일부만 빠졌다? 3을 빼고 1,2만 add 및 커밋한 상태 | 3을 git add한 뒤 git commit --amend | . | 그냥 커밋메세지만 변경 git commit --amend -m &quot;메세지&quot; | . | . | HEAD포함 n번째[에] commit 합치기or삭제 등 commit history 조절: git rebase -i HEAD~[숫자] -&gt; fixup or squash . HEAD~ = HEAD~1 HEAD포함 HEAD1개 전 ~1 = HEAD^ : 헤드의 부모, 헤드의 1개전 | . | . | rebase는 명령어로 하는게 더 빠르고 쉽다. | . . commit 1개당 1개의 의미를 가져야하나, 의미가 없는 커밋들을 하나로 합칠 때 , git rebase -i HEAD~ + [합칠 커밋갯수] 이후에 fixup: (귀찮아서) HEAD포함 n번째커밋에 커밋합치면서 n번째 커밋명으로 커밋합침 | squash: (새로운커밋명을 위해) HEAD포함 n번째커밋에 커밋합치면서 + 새로운 커밋명으로 합침 | 그외 reword(= amend), drop 등: 사용안한다. | . | . 커밋을 1111,222,3333333,4444,55555 5개를 새로 만들자 . | git rebase -i HEAD~[head포함 합칠 커밋갯수 &amp; head에서 뒤로 2칸 간 곳에서 합쳐짐.]을 커맨드로 입력한다. . ❯ git rebase -i HEAD~2 . . 여기서 커밋메시지 같은 git-rebase-todo 메세지에서 pick대신 fixup을 적어서 뭉개자. 최근커밋인 5555(HEAD)를 fixup으로 뭉개서 저장시키면 된다. | . | . 따로 뭔가 뜨지 않으면 .git &gt; rebase-merge &gt; git-rebase-todo를 클릭한다. . | 도착지(HEAD포함 n번째 커밋)는 선택지가 없다. . 최근 것이며 뭉개지는 HEAD는 선택지가 있다. . 여기서 fixup을 선택하면, 귀찮게 새로운 커밋메세지를 작성안하고 n번째 커밋명을 이용하게 된다. . . | start rebase를 해서 커밋을 합친다. . | . | . | 이제 444 -&gt;333으로 . git rebase -i . . 최근 것(아래 것)을 pick to squash로 변경해보자. . 과거커밋으로 합치는데 커밋메세지는 새로작성한다는 것이다. . . | 맨 위에 커밋메세지를 적으면 적용된다. . | . | 이미해버린 commit 취소는 직전HEAD로 돌아가면서 취소: git reset –hard HEAD~ . reset은 해당커밋까지가면서 자연스럽게 삭제한다. | . head의 부모로 가면서, head는 삭제 . ❯ git reset --hard HEAD~HEAD is now at 3460720 Merge branch &#39;testbr&#39; of https://github.com/is2js/git-ssac into testbr . . | add(staging) 취소는 아직commit안됬으므로 commit전 HEAD로 돌아가면서 취소: - or git reset HEAD . git extension으로 는 그냥 -버튼을 누르면 add가 취소됨 . | 명령어로는 git reset HEAD로서 . --hard없이 code를 살린체 최근HEAD로 돌아가면 -&gt; add취소가 자동으로 | . . git reset HEAD # HEAD 대문자여야함. . . | . 깃 심화1 with vscode . ### . git tag는 release의 의미를 가지므로 main에서 딴다. tag 혼자 = 커밋의 합 = 강의 n화 | 협업 = topic -&gt; main에서 merge후에 main에서 배포버전으로서 tag를 딴다. | . | . | . merge는 항상 명령어로 –no-ff를 붙여 커밋을 남기자 . --no-ff를 붙이면 fastfoward = 커밋없이 head위치만 바꾸는 것을 안하고 항상 merge커밋을 남긴다. conflict나면, Accept incoming후 git commit만 입력해주면 메세지 완성되어있음. | . | . main브랜치로 넘어가기 . | 명령어로 merge하기 . ❯ git merge --no-ff testbr Merge made by the &#39;recursive&#39; strategy. hello.py | 3 +++ testbr.py | 0 work.py | 1 + 3 files changed, 4 insertions(+) create mode 100644 testbr.py . | merge후 topic branch는 삭제: git branch -d . merge가 되었다면, topic 브랜치 삭제하기!! . git branch -d testbr Deleted branch testbr (was 74296bb). . 만약, fully merge가 안되었다고 뜨면? 대문자 -D로 강제 삭제해준다. . git branch -D testbr . | . | tag 확인 및 생성 in main브랜치:git tag [v0.0.1] . tag는 release될 main브랜치에서 작성한다. | tag는 release단위 = 배포단위로 생성한다. | tag는 소스코드를 push를 해놓은 상태에서 -&gt; tag를 local에서 따고 -&gt;tag를 push한다. | . ❯ git tag ❯ git tag v0.0.1 ❯ git tag v0.0.1 (END) . tag는 commit과 별개로 따로 push: git push origin [tag(=버전)] . git push origin [태그명=버전명] . ❯ git push origin v0.0.1 Total 0 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-ssac.git * [new tag] v0.0.1 -&gt; v0.0.1 . | git repo에, tag가 생긴 것을 우측사이드에서 확인가능 . | code수정 후 commit-&gt;push 끝난 뒤, 따로 tag 따고 -&gt; push . 파일(코드) 수정 . | local git commit . | local -&gt; origin(원격레포)로 push . ❯ git add -A ❯ git commit -m &quot;askldjflkasd&quot; ❯ git push . | commit의 push가 끝난 뒤, tag를 딴다. . ❯ git tag v0.0.2 ❯ git push origin v0.0.2 Total 0 (delta 0), reused 0 (delta 0) To https://github.com/is2js/git-ssac.git * [new tag] v0.0.2 -&gt; v0.0.2 . | tag는 과감하게 돌아가기: git reset –hard [태그] . git reset --hard [commit_hash]를 하면 해당 커밋까지 돌아가면서 자연스럽게 그 이후의 내용들은 삭제되었다. 하지만, 태그의 경우, code + commit은 돌아가나 tag는 삭제안되고 남아있다. | . | . ❯ git reset --hard v0.0.1 HEAD is now at bd4c018 Merge branch &#39;testbr&#39; into main ❯ git tag v0.0.1 v0.0.2 . 되돌아가도 tag는 남아있으니 직접 삭제해줘야한다. | . reset tag이후에도 local+remote tag 따로 삭제: git tag -d 태그 / git push origin -d 태그 . 로컬 tag를 삭제한다. . git tag -d v0.0.2 Deleted tag &#39;v0.0.2&#39; (was 476f70b) . | 원격에 남아있는 tag도 삭제한다. . git push origin -d v0.0.2 To https://github.com/is3js/py.git - [deleted] v0.0.2 . | 깃 심화2 with 개념위주 . 실수로 다른브랜치에 커밋or코드의존성때문에 다른사람 커밋이 필요할 때: git cherry-pick 으로 특정커밋만 똑! 가져올 때 . . 코드의존성 . 다른사람 커밋 위에서 일해야하는 경우 ex&gt; 다른사람이 버그고침 -&gt; 나는 그위에서 일을 해야할 때 | . | . | master branch의 cccccccc커밋만 -&gt; my branch로 . 커밋해쉬 앞 7글자 . git cherry-pick ccccccc . . | . | . git reset 총정리(add취소, commit취소) . ADD취소 2가지 . 옵션을 안주면 mixed | . . | 커밋취소 3가지 . HEAD뒤에 눈웃음 한개 ^ --soft : commit만 취소 + add + 내용물 그대로 | (mixed) : commt취소 + add취소 + 내용물만 그대로(unstaged) | --hard : commit취소 + add취소 + 내용물취소 | . | . . | . HEAD와 ^, ~숫자 . HEAD: 로컬 workingDir의 현재 작업중인 커밋 switch하면 작업폴더, 작업하는곳도 바뀌니 head도 바뀐다. | add만 했다면? 커밋이 아직 아니므로 HEAD가 보고 있진 않다. | . | HEAD^: 현재작업중 커밋의 부모커밋 ^^ : 부모의부모 | ~3 : ^^^쓰지말고, 3단계 전 커밋 | . | . 다시git reset HEAD 살펴보기with 돌아가서 자연스럽게 취소 . add 취소 . 커밋이 아니므로, HEAD는 아직 안보고 있다. . | 그래서 git reset HEAD를 하게 되면, HEAD커밋을 삭제하는게 아니라 git reset [여기] = [여기]로 돌아가겠다 = 해당커밋이후로 add는 커밋은 필요없다. 자연스럽게 add를 취소 . . | . | 커밋취소 . git reset HEAD^ 현재의 부모커밋으로 가고 싶다. . | 를 통해서 현재커밋을 취소 . . | . | 작업중에 다른작업요청시 commit도 reset도 애매한 임시저장: git stash . 로그인 브랜치에서 작업중인데, 갑자기 로그아웃 브랜치를 수정해달라고함. . 브랜치를 정리해야지만 브랜치변경이 가능함. 커밋한다음 reset을 해도되긴하겠지만,,, | . | 커밋하기엔 미완성, 작업물을 날릴순 없다. 임시저장으로 정리 | . | 현재 어느정도는 add된 상태 . unstage된 = add되지 않는 파일도 있음. . . | add, unstage 다 합쳐서 사진을 스태시! 하고 찍는다. . git stash . . 커밋이후의 상황들 전체가 stash 바구니에 담기게 됨. . . | . | 바구니에 담기면 사라진다. . | . | git stash pop을 통해 stash바구니에서 꺼내면 다시 적용된다. . . stack처럼 pop으로 나온다. | . | git stash, git stash pop 이외에 git stash list도 있다. . | . 마지막 커밋 변경(내용추가, 메세지변경): git commit –amend . . 마지막 커밋A에 일부만 빠졌다? 3을 빼고 1,2만 add 및 커밋한 상태 | 3을 git add한 뒤 git commit --amend | . | 그냥 커밋메세지만 변경 git commit --amend -m &quot;메세지&quot; | . | . merge말고 1줄로 합치는데, 상대주는놈branch 위에 올려서 합칠 때:git rebase . 내 브랜치들을 주는놈branch 위에서 적용시키고 싶을 때 . 최근브랜치가 내꺼가 되면서, 내가 주는놈 위에 적용됨. | . . . | 주의할점으로, 주는놈위에 쌓아올려질 때, 그대로 가는게 아니라 커밋해쉬가 달라짐 . | . merge vs rebase . . merge와 비교 장점: 커밋해쉬 유지 및 흐름 유지되어 돌아갈 수 있음 | 단점: merge라는 불필요커밋을 생성함. | . | rebase 장점: 주는놈위에 받는놈위주로 정리가 됨. 깨끗한 커밋 히스토리가 됨. | . | . 커밋 합침, 삭제 등 커밋 히스토리 조절: git rebase -i . . pull받은이후 rebase로 커밋해쉬가 바뀌었다면? 어쩔수 없이 git push –force . . remote branch2개를 잘 받아왔다. . | 이후 git rebase(주는놈위에 쌓아서 합침)로 내 커밋해쉬가 바뀌었다면? . . 이 상태에서 git push하면 reject된다. | . | 어쩔수 없이 git push --force로 덮어씌워야함. . | 협업중엔 조심해야한다. . 남자가 rebase후 푸쉬포스로 덮어씌워진다면,, . . | 같은 브랜치 협업중에는 미리 말안하는 이상 rebase 및 push force를 하면 안될듯 . | . | . alias . git push까지 . status diff add cache? commit log | . | git폴더에 . . | 내 환경설정에 . | 참고 . 히데쿠마 설정 . ## alias # git alias gst=&#39;git status&#39; alias gc=&#39;git commit&#39; alias gm=&#39;git merge&#39; alias gr=&#39;git reset&#39; alias ga=&#39;git add&#39; alias gaa=&#39;git add --all&#39; alias gloga=&#39;git log --oneline --decorate --color --graph --all&#39; alias glog=&#39;git log --oneline --decorate --color --graph&#39; alias gco=&#39;git checkout&#39; alias gb=&#39;git branch&#39; alias gcb=&#39;git branch | fzf -m | xargs git checkout&#39; alias gmb=&#39;git branch | fzf -m | xargs git merge&#39; alias gdb=&#39;git branch | fzf -m | xargs git branch -D&#39; alias gp=&#39;git push&#39; alias gf=&#39;git fetch&#39; alias gl=&#39;git pull&#39; alias gd=&#39;git diff&#39; alias ghf=&#39;git ls-files -v | grep &quot;^h&quot; | cut -c3-&#39; # dkr alias dkr=&#39;docker&#39; alias dkrp=&#39;docker-compose&#39; # for docker #sudo mount --bind /mnt/c /c sudo mount --bind /mnt/d /d export DOCKER_HOST=tcp://0.0.0.0:2375 # basic alias dotfiles=&#39;cd ~/dotfiles&#39; alias ll=&#39;ls -al&#39; alias l=&#39;clear &amp;&amp; ls -al&#39; #alias cdd=&#39;cd /d/&#39; alias ws=&#39;cd /d/workspace&#39; #alias solup=&#39;cd /d/workspace/solup&#39; alias echost=&#39;cd /d/workspace/solup/echost&#39; alias 12r=&#39;cd /d/workspace/solup/12r&#39; alias private=&#39;cd /d/workspace/private&#39; alias ..=&#39;cd ..&#39; alias ..2=&#39;.. &amp;&amp; ..&#39; alias ..3=&#39;..2 &amp;&amp; ..&#39; # some more ls aliases #alias ll=&#39;ls -alF&#39; alias la=&#39;ls -A&#39; #alias l=&#39;ls -CF&#39; # Add an &quot;alert&quot; alias for long running commands. Use like so: # sleep 10; alert alias alert=&#39;notify-send --urgency=low -i &quot;$([ $? = 0 ] &amp;&amp; echo terminal || echo error)&quot; &quot;$(history|tail -n1|sed -e &#39; &#39;&#39;s/^ s*[0-9] + s*//;s/[;&amp;|] s*alert$//&#39; &#39;&#39;)&quot;&#39; # for python alias python=&#39;python3&#39; alias pip=&#39;pip3&#39; export WORKON_HOME=~/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=&#39;/usr/bin/python3&#39; # Usage of python3 source ~/.local/bin/virtualenvwrapper.sh # for pyenv export PYENV_ROOT=&quot;$HOME/.pyenv&quot; export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot; export PYTHON_CONFIGURE_OPTS=&quot;--enable-shared&quot; export PYENV_VIRTUALENV_DISABLE_PROMPT=1 if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then eval &quot;$(pyenv init -)&quot; eval &quot;$(pyenv virtualenv-init -)&quot; fi . | . | .",
            "url": "blog.chojaeseong.com/git/2021/10/15/%EA%B9%832_%EA%B9%83%EA%B8%B0%EB%B3%B8(vscode)_%EA%B9%83%EC%8B%AC%ED%99%941(vscode)_%EA%B9%83%EC%8B%AC%ED%99%942(%EA%B0%9C%EB%85%90).html",
            "relUrl": "/git/2021/10/15/%EA%B9%832_%EA%B9%83%EA%B8%B0%EB%B3%B8(vscode)_%EA%B9%83%EC%8B%AC%ED%99%941(vscode)_%EA%B9%83%EC%8B%AC%ED%99%942(%EA%B0%9C%EB%85%90).html",
            "date": " • Oct 15, 2021"
        }
        
    
  
    
        ,"post163": {
            "title": "기본) commit&tag/revert&reset/branch",
            "content": "타인repo를 clone후 commit, tag 코드 옮겨다니기 . 실습레포: /home/is2js/workspace/git-test | Reference memi dev | 얄팍한 코딩사전 | kaist 전산학부학생회 | . | . commit_hash or tag로 점프: git checkout [hash or tag] . 환경변수를 파악하고 code . . | vscode로 리조지토리 초기화 . | vscode push 버튼으로 올리기 . . | git fetch는 해두는 게 좋다 . 내 repo에 누가 작업을 추가했는지 파악만 해주는 것 | . | 강의별로 commit을 한다면? . 커밋별로 tag를 추가로 만들어준다. . | 예를 들어 . 5화 작업 . 5화 커밋 git tag 5 | . | . | 6화 작업 . 6화 커밋 git tag 6 | . | . | push by vscode push버튼 . . | . | . | git checkout [git_id]으로 5화 이전의 4화로 점프띄어보자. . 4화 부분의 git id 복사 . | 해당 폴더의 vscode 터미널에서 git checkout [git_id] . git checkout fefc0cacbf262ae0794e64a632afa2da095b622a . 이때 brunch자체가 [git_id]로 변하면서 과거로 돌아간다 | . | 현재로 돌아오려면, 기존 branch(master)로 checkout한다 . git checkout master . | . | git checkout [tag명]으로 점프띄어보자 . 각 커밋마다 커밋후 쉬운 이름표인 tag를 만들어준다. . 아까 5화 작업 끝나고, git tag 5 . 5화 끝난후의 소스를 보고 싶을 땐 이렇게 이동한다 . #git checkout [tag명] git checkout 5 . . | . | . | 다 참조가 끝났다면, 다시 최근소스의 branch로 오면된다. . git checkout master . | . | tag는 대신 따로 push를 해줘야한다. . 커밋들을 push한거로는 tag까지 push가 안됨. | . git push --tags . 버튼으로는 잘 안보이고 팔레트 &gt; push 검색 &gt; git push tags를 선택해준다. . | 참고) . 맨첨 커밋에는 0.0.0의 tag를 만들어주고 . | 그 이후로는 1.0.0부터 쭉 만들면된다. . . | . | . | . 내 repo 돌아가기, 되돌리기 . 기본 세팅 . /home/is2js/workspace/git-practice | . 소스트리 설치 . vscode에서는 설정(ctrl+,)에서 exclude 검색후 .git을 삭제하여 보이게 하기 | . | 디렉토리에서 vscode열기 . vscode 터미널 열여서 git설정 저장하기 . git config --global user.name &quot;is2js&quot; git config --global user.name &quot;tingstyle1@gmail.com&quot; . | . | .git폴더를 삭제후 소스트리에서 해보기 . create를 통해 해당폴더를 선택해서 만들어준다. 이미 폴더가 있는데 이 내부에 .git생성할까 물어보면 OK | . | . | 2개의 파일을 만들고 이 상태를 저장하기 . cat | mouse | . | git status(gst)를 통해 아직 untracked 파일들 확인 후 add . git add -A . git status . | 메세지(-m)와 함께 묻기(commit 해주기) git commit -m &quot;First commit&quot; . | 묻은 것을 소스트리에서 확인해보기 . 터미널에서 히스토리 확인하기 git log --oneline . | 소스트리는 git status없이 묻을 파일을 자동으로 알려준다. . vscode도 extensiont쪽에 알려줌? | dog라는 파일을 만들고 소스트리에서 확인해서 add + 커밋까지해보자. | . | . | 파일 삭제 + 변경 + 생성을 한꺼번에 한 뒤 git status로 보자. 삭제+변경과 생성을 따로따로 알려주며 다 알려주긴 한다. | 소스트리도 아이콘으로 알려준다. | . | git log로 이때까지 묻은 캡슐들을 한꺼번에 볼 수 있음. 소스트리에서는 History탭에서 보면 된다. . . | 과감한 돌아가기: git reset [commit_hash] –hard . . 돌아갈때는 과감한방법과 신중한방법이 있다. . 과감한방법(--hard) : 복원이후시점은 완전히 지우겠다. . git log상의 commit_id 앞6글자만 복사후 . | git reset [commit_id] --hard . . | . | 다시 한번 cat삭제 + dog이름변경 + 펭귄추가를 해주고 commit한뒤 소스트리로 reset –hard해보자. . 이 커밋까지 현재브린치를 초기화 | Hard(버림) 선택 | . | . | 신중한방법(--soft): 시점만 돌아가고 + 그 이후는 커밋되지 않은 상태로 파일은 유지 . | . (반대동작으로 취소시켜, 돌아갈 미래를 남긴체) 되돌리기 : git revert . **[reset으로 돌아갈 수 있는 미래]를 남겨두기 위해, [반대동작으로 취소시켜] 되돌리기 ** . | 다시 3번째 커밋까지 만들어준다. | 이번에는 돌아갈시점 6자리 for reset이 아닌 취소할 시점 6자리 for revert를 git log에서 찾는다. 취소할 커밋을 revert(취소)했다는 커밋이 그대로 이어서 남는다. 소스트리를 통해 확인하면, 정확히 취소할 커밋이, 커밋시 수행한 동작을 정확히 반대로 수행하여 취소함. | 취소할커밋이 커밋기록으로 남아있으니, reset --hard(이 커밋까지 현재브런치를 초기화)을 통한 해당 커밋으로 과감하게 돌아갈 수도 있다. | . | . | **즉, [reset으로 돌아갈 수 있는 미래]를 남겨두는 [반대동작으로 취소시켜] 되돌리기 ** | . 가장 최근 것을 revert로 취소시켜보자. . git log . 제일 최근시점을 취소시키기 위해, 최근 커밋(현재커밋) 6글자 복붙 | . | git revert [취소시점6자리] + :wq . 커밋메세지 작성화면으로 들어온다. | 여기선 :wq로 나와야 해당 revert 커밋메세지가 전달된다. | . | 3번째 커밋이 취소된 것을 파일이 reset처럼 과거상태로 돌아감을 보면 알 수 있다. . | git log를 확인해보니, 돌아간시점이후로 가 삭제된 것(reset –hard, 과감한 돌아가기)가 아니라 새 커밋이 형성되었다. . 소스트리에서 보아도 3번째 커밋을 상쇄시키는 커밋이 추가로 발생함 | . . 자세히 보면, 소스트리를 통해 확인하면, 정확히 취소할 커밋이, 커밋시 수행한 동작을 정확히 반대로 수행하여 취소함 3번째 커밋(취소할 커밋) 때 한 동작들 | 4번째 커밋인 3번째 커밋을 취소함(revert)를 할때의 동작들 | . | . | revert를 통해 취소할커밋도 reset-hard와 다르게 기록으로 남아있으니 reset을 통해 취소하기 전의 3번째 커밋상태로 과감하게 돌아갈 수도 있다. . . | 소스트리를 통한 revert는 커밋 되돌리기다. . 역시.. (반대동작으로 취소시켜) 되돌리기 = revert . 커밋 되돌리기 == 반대동작을 통해 해당 커밋을 취소시킴 . . | . | . | 내repo branch(평행우주) 만들기 for 기존플젝에 새로운 도전 . 회사 프로젝트를 내가 함부로 수정할 수 없으니 현재 프로젝트에서 다른 시도를 해보고 싶을 때, branch를 만들어 평행우주로 넘어간다. | . | . 평행우주로 이동도:git checkout [브랜] or 더블클릭 in 소스트리 . 브랜치 생성 . 브랜치 : 현 시점에서 2개의 미래로 분기를 시작하겠다. 현 시점과 동일한 상태 그대로 가져가면서 분기함. | . | . #git branch [만들 브랜치명] git branch my-idea . . 확인은 git branch만 . . | . | 브랜치 이동도 git checkout . 과거로 점프갔다오기 : git checkout [commit_id or tag] . 과거로 돌아가기 : git reset –hard or git revert [commit_id] | . | 과거가 아닌 현재-&gt;다른평행우주(branch)로 이동도 git checkout + 브랜치명 . #git checktout [브랜치명]git checktout my-idea . . branch변경해도, 내 파일상태에는 변함이 없음. 현재 상태를 그대로 가지고 평행우주를 만들어서 | . | . | 데이터 변경 후 커밋하기 in my-idea브랜치 . mouse 삭제, dinosaur 추가 . 용이름 둘리 | . | 현 branch에서 커밋하기 . git add -Agit commit -m &quot;Add dino&quot; . . | . | 상사가 부를 땐, 원래 우주로 돌아간다. . 원래 브랜치는 master였다. . 이동 전 . | 이동 후 (파일이 원래대로 돌아옴) . git checkout master . . | . | git을 처음 배울때는 파일이 잘못될까바 불안해서 사용안할 수도 있는데, 앞으로 계속 사용해보자~ . | . | 소스트리에서 다시 해보자. 더블클릭으로도 우주를 왔다갔다 하며 확인할 수 있다. . 브랜치 부분에 my-idea가 추가됨. 여기서 각 브랜치를 더블클릭할 때마다, vscode의 파일도 같이 바뀌더라. | . | 브랜치에서 새 브랜치 따기 . my-idea로 checkout된 상태에서, 상단의 브랜치탭에서 새로 생성해보자. . 이 때, 새 브랜치로 체크아웃을 체크해주면, 자동으로 새 브랜치로 넘어가진 상태가 된다. | . . my-idea에서 파생된 브랜치라 그 상태를 그대로 가져갔다. | . | 브랜치의 브랜치 상태에서, 데이터를 변경후 커밋까지 . cat 이름을 변경:tom to nyang | . . | 연결된 3개의 평행우주에서 상황맞이 . 상사가 master의 내용을 바꾸길 원함. . . 요구 대로 바꿔고, commit한다. . git add -Agit commit -m &quot;EDIT dog name&quot; . . | . | 평행우주에서, 타 브랜치의 base가 되는 branch(여기선 maser)가 한발(commit) 나서게 되면, 분기된 branch가 나눠서 그려진다. . . | 다른 우주(의지를 이은 가장 바깥가지 브랜치)에서 변화 가져오기: [ 받을놈branch이동후] git merge [줄놈branch] . 현재 메인프로젝트 master의 변경내용과는 서로다른 평행우주끼리 다른파일 수정이라면, 브랜치의 브랜치라도 편하게 master로 merge되는 것을 권유할 수 있다. . 아래 내용을 상사에게 권해본다. . my-idea에서 mouse삭제 후 dino 추가했고 | my-idea - my-another-idea에서 cat이름을 변경했는데 이것들을 메인프로젝트에 적용해도될까요? Okay 승인 | . | . . | 2개의 평행우주에서 일어난 일을 master브랜치로 가져야가한다. . 이 때, 브랜치1의 브랜치2는 생성부터 브랜치1의 변화를 그대로 가져와서 생성되므로 브랜치2만 반영시키면 된다. . . | . | . | merge를 위해서는 . 먼저 받는놈 브랜치(master)로 이동(checkout)한 상태여야한다. . git merge [줄놈 브랜치명] | . git checkout mastergit merge my-another-idea . . | 변화를 보니 master의 상사지시 + 평행우주에서 한 것들이 모두 반영되어있다. . master에서의 dog name to 바꾼 것도 반영되어이있지만 | my-another-idea에서의 쥐삭제+용추가 한 것도 동시에 반영된 상태다. | . | . | 확인은 . 소스트리 | vscode git graph가 아니라면 | git log --graph --all --decorate로 확인하란다 git log --graph --oneline정도면 충분할듯? | . | . | reset –hard로 merge전으로 돌아간 후, 소스트리로 merge하기 . 소스트리로 실습하기 위해 merge전으로 돌아가보자. | . merge 직전의 받는놈 브랜치의 가장 마지막 커밋 == merge전 커밋으로 . git reset –hard . | 소스트리: 이 커밋까지 현재 브랜치를 초기화 . . | . | 소스트리로 merge하려면 더 간단한데 받는놈의 branch를 더블클릭해서 이동 | 주는놈 branch를 우클릭 &gt; 현재 브랜치(받는놈 더블클릭 상태)로 my-another-idea(주는놈, 우클리상태) 병합 | . | 나중에는.. 수많은 폴더와 파일을 다뤄야하기 때문에, 기존프로젝트에 새 도전을 하려면 반드시 git branch써야함. | . | 아름답지 않은 merge + conflict후에는 메세지없이 git commit . 원래 merge가 성공하면 git이 자동 add + commit까지 한다. | . bark-wang브랜치 생성후, dog 파일 수정 -&gt; commit . ❯ git branch bark-wang❯ git checkout bark-wangSwitched to branch &#39;bark-wang&#39;❯ git add -A❯ git commit -m &quot;EDIT dog file&quot; . . | 이제 받는놈인 master로 돌아와서 같은 dog파일 수정하자. . ❯ git checkout masterSwitched to branch &#39;master&#39;❯ git add -A❯ git commit -m &quot;EDIT dog file bar warlwarl&quot; . master가 한발짝 나가는 순간부터 분기가 갈라져 보인다. | . | 현재, master 와 bark-wang이 서로 같은 파일을 수정한 상태다. . 아까의 merge는 서로 다른파일이 수정된 상태라 merge가 쉽게 되었다. . | 한번 merge해보자 . ❯ git checkout masterAlready on &#39;master&#39;❯ git merge bark-wangAuto-merging dogCONFLICT (content): Merge conflict in dogAutomatic merge failed; fix conflicts and then commit the result. . . | . | merge시 conflict가 뜨는데 같은 파일을 여러 평행우주에서 수정했기 때문이다. conflic가 없었을 때의 merge는? merge를 자동으로 커밋까지 해주는 커밋메세지 확인이 떴었다. | . | terminal에 안내문이 뜬다 | 소스트리에서는 그래프가 회색으로 연결안되어있으면서 &quot;커밋하지 않은 변경사항&quot;의 상태로 뜬다. | vscode에서는 conflict된 부분을 나눠서 알려준다. | | conflict는 vscode에서 택1해서 지울건 지운 뒤, add후 git commit을 -m 없는 상태로 커밋을 날리면 자동으로 merge 메세지가 뜬다. . accept incoming ~ in vscode | . git add -Agit commit . . conflic후 commit은 메세지없이 git commit만 날리며 알아서 merge 메세지가 미리 작성되어있다. . . | . | 앞으로 다른 브랜치끼리는 같은파일을 수정안하도록 작업하면 merge가 편안해진다. | 다른우주도 1줄로 만들어 통합: git rebase(재배치) . 프로젝트의 성격에 따라 필요한 것을 선택해서 사용하면 된다. . . | 지금은 git log상 2갈래 정도만 나오지만 . 실제로는 엄청나게 많은 줄기가 생기게 된다. . . | . | 딱 1줄로 통합되도록 merge하는 방법이 git rebase다 . 소스트리상으로는 master(받는놈)에서 주는놈(bark-warl) 우클릭 &gt; 재배치(rebase)를 클릭한다. . . | 같은 파일을 건들인 상황이니 똑같이 conflict해결후 add+commit한다. . | 재배치가 끝나면 분기가1 줄로 나타난다. . 브랜치라도 합쳐지는 모양이 아니다. | . . | . | . 다 쓴 브랜치 삭제: git branch -D . rebase는 1줄로 받는놈(masetr)에 통합되어버린다. . 그럼 작업한 branch(주는놈)은 더이상 필요 없을 것이다. . | 대문자로 -D옵션을 준다 | 소스트리는 우클릭으로 바로 할 수 있다. | . ❯ git branch -D bark-wang Deleted branch bark-wang (was 5fefbe0). . ​ . | merge를 통해 분기가 합쳐졌던 branch들도 git branch -D로 삭제하였더니 . 분기 표기는 남아있는데, branch만 사라졌다. | . . | .",
            "url": "blog.chojaeseong.com/git/2021/10/14/%EA%B9%831_%EC%BB%A4%EB%B0%8B%ED%83%9C%EA%B7%B8%EC%9D%B4%EB%8F%99_%EB%8F%8C%EC%95%84%EA%B0%80%EA%B8%B0%EB%90%98%EB%8F%8C%EB%A6%AC%EA%B8%B0_%EB%B8%8C%EB%9E%9C%EC%B9%98.html",
            "relUrl": "/git/2021/10/14/%EA%B9%831_%EC%BB%A4%EB%B0%8B%ED%83%9C%EA%B7%B8%EC%9D%B4%EB%8F%99_%EB%8F%8C%EC%95%84%EA%B0%80%EA%B8%B0%EB%90%98%EB%8F%8C%EB%A6%AC%EA%B8%B0_%EB%B8%8C%EB%9E%9C%EC%B9%98.html",
            "date": " • Oct 14, 2021"
        }
        
    
  
    
        ,"post164": {
            "title": "terminal -> choco -> wsl, pyenv",
            "content": "chocolately로 초기 설치 . 관리자권한 powershell . 초코랫리 겟스타트 -&gt; 인스톨 코드 복붙 | 경고떠도됨. 관리자권한으로 다시 껐다 키기 | . | find pakage에서 terminal 검색후 설치 . choco install microsoft-windows-terminal . | python 3 검색후 3.9 설치 . choco install python3 . | vscode 설치 . choco install vscode . | git 설치 . choco install git . git config –global user.name “2js” . git config –global user.email “1@gmail” . | wsl2 설치 -&gt; 재부팅후 한번 더 실행 (-y -f ??) . choco install wsl2 -y -f . 참고사이트 . | 참고) 정식 가이드로 설치시 해주는 다운로드전 설정 . dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart # WSL 활성화 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart # VM platform 활성화 . | . | 관리자 권한으로 윈도우 가상화해주기 for wsl2 . Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All . bcdedit /set hypervisorlaunchtype auto . | AMD CPU SVM mode 설정 in Bios for ubuntu 실행 . del 로 bios 진입 . | advanced 진입(F7) . | OC(Overclock) 진입 . | advanced cpu configuration 진입 . | SVM node: Enable . 우측상단 X로 저장후 종료하기 | . | . | wsl2용 ubuntu1804 설치 -&gt; ms store에서 설치(choco는 update안된 버전이라고함) . msstore 사용시 ms계정 요구함 ~@hanmail.net / ~54 | . | 설치 -&gt; 시작 | . | wsl명령어로 우분투 진입 default 계정 및 비번 설정 is2js / | ~213 | . | . | 항상 wsl접속으로 /mnt된 곳이 아니라 cd ~ (linux 홈폴더)를 한 상태에서 code ~/.zshrc 등의 설정을 하자. | Window Terminal 단축키 설정 . vscode와 비슷하게 추가 매핑해준다. . actions 부분에 추가해주면 된다. | . { &quot;command&quot;: &quot;find&quot;, // 검색키 매핑 // &quot;keys&quot;: &quot;ctrl+shift+f&quot;, &quot;keys&quot;: &quot;ctrl+shift+f&quot; }, // 수직분할 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;vertical&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+plus&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;vertical&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;ctrl+ &quot; }, // 수평분할 매핑(추가) //{ &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;horizontal&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+-&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;horizontal&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+0&quot; }, // 탭 끄기 매핑(추가) { &quot;command&quot;: &quot;closePane&quot;, &quot;keys&quot;: &quot;ctrl+w&quot; }, // 포커스key 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;down&quot; }, &quot;keys&quot;: &quot;alt+down&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;down&quot; }, &quot;keys&quot;: &quot;ctrl+alt+down&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;left&quot; }, &quot;keys&quot;: &quot;ctrl+alt+left&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;right&quot; }, &quot;keys&quot;: &quot;ctrl+alt+right&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;moveFocus&quot;, &quot;direction&quot;: &quot;up&quot; }, &quot;keys&quot;: &quot;ctrl+alt+up&quot; }, // 창이동 단축키 매핑(추가) // { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 0 }, &quot;keys&quot;: &quot;ctrl+alt+1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 0 }, &quot;keys&quot;: &quot;ctrl+1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 1 }, &quot;keys&quot;: &quot;ctrl+2&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 2 }, &quot;keys&quot;: &quot;ctrl+3&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 3 }, &quot;keys&quot;: &quot;ctrl+4&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 4 }, &quot;keys&quot;: &quot;ctrl+5&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 5 }, &quot;keys&quot;: &quot;ctrl+6&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 6 }, &quot;keys&quot;: &quot;ctrl+7&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 7 }, &quot;keys&quot;: &quot;ctrl+8&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;switchToTab&quot;, &quot;index&quot;: 8 }, &quot;keys&quot;: &quot;ctrl+9&quot; }, // Rename a tab to &quot;Foo&quot; { &quot;command&quot;: { &quot;action&quot;: &quot;renameTab&quot;, &quot;title&quot;: &quot;server&quot; }, &quot;keys&quot;: &quot;f1&quot; }, { &quot;command&quot;: { &quot;action&quot;: &quot;renameTab&quot;, &quot;title&quot;: &quot;jupyter&quot; }, &quot;keys&quot;: &quot;f2&quot; }, . | . Window Terminal 및 wsl2 zsh 세팅 . 터미널에서 설정(ctrl+,) &gt; json파일열기 &gt; ubuntu이름을 wsl2로 바꾸고 . wsl2(ubuntu)의 guid를 복사해서 &gt; defaultProfile key에 넣어 기본 프로필로 설정 | . | Fira code설치후, WindowTerminal 및 vscode-editor + vscode terminal font 변경해주기 . 깃허브 &gt; zip파일 다운후 압축풀고 &gt; ttf 다 설치 . Terminal : 없던 defaults속 fontFace속성을 넣어서 폰트를 설정해준다. . | Vscode : font 검색후, 맨앞에 &quot;Fira code&quot; 추가 후 전체복사 . terminal font 검색 후 복붙 . “Fira code”, Consolas, ‘Courier New’, monospace . | . | . | . | zsh설치(zsh는 root로 설치) . sudo apt update &amp;&amp; upgrade . sudo apt install zsh . | oh my zsh(zsh) 설치 (ohmyzsh부터는 user로 설치?!) . github 들어가서 curl로 설치 명령어 날리기 . sh -c “$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)” . | . | ohmyzsh 플러그인 2개(자동완성, 하이라이팅) 설치 . zsh-syntax-highlighting . git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting . zsh-autosuggestions . git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions . .zshrc에 기입해주기 . code ~/.zshrc . plugin 검색 . plugins=(git) 에 공백으로 추가 해주기 . plugins=(git zsh-syntax-highlighting zsh-autosuggestions) . 나와서 . source ~/.zshrc . | . | p10k(ohmyzsh의 테마) 설치 . 깃허브 에서 ohmyzsh 클릭 후 ohmyzsh 하위폴더로 clone시켜주기 . git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k . | p10k를 zsh의 테마로 설정해주기 . code ~/.zshrc . theme검색후 ZSH_THEME=”robbyrussell”를 . ZSH_THEME=”powerlevel10k/powerlevel10k” . 로 변경 . source ~/.zshrc . | p10k configure 설정이 시작됨 . | . | ls -al 등이 파일명 배경색 직접 변경하기 . cd ~ . code ~/.zshrc . # change filname background color . LS_COLORS=”ow=01;36;40” &amp;&amp; export LS_COLORS . 위 내용 추가 . source ~/.zshrc . | Win-terminal 테마 생성 및 설정해주기 . terminalsplash.com에 들어가서 고른다. . VS code theme를 찾음. 아직 json내부에서 &quot;name&quot;이 없는 상태. | . | &quot;profiles&quot; 밑에 &quot;schemes&quot;에 **name을 추가해주면서 ** custom theme를 등록해야한다. . schemes 에 등록한 뒤, colorScheme로 사용된다 | . &quot;schemes&quot;: [ { &quot;name&quot; : &quot;VScode&quot;, &quot;background&quot; : &quot;#232323&quot;, &quot;black&quot; : &quot;#000000&quot;, &quot;blue&quot; : &quot;#579BD5&quot;, &quot;brightBlack&quot; : &quot;#797979&quot;, &quot;brightBlue&quot; : &quot;#9BDBFE&quot;, &quot;brightCyan&quot; : &quot;#2BC4E2&quot;, &quot;brightGreen&quot; : &quot;#1AD69C&quot;, &quot;brightPurple&quot; : &quot;#DF89DD&quot;, &quot;brightRed&quot; : &quot;#F6645D&quot;, &quot;brightWhite&quot; : &quot;#EAEAEA&quot;, &quot;brightYellow&quot; : &quot;#F6F353&quot;, &quot;cyan&quot; : &quot;#00B6D6&quot;, &quot;foreground&quot; : &quot;#D3D3D3&quot;, &quot;green&quot; : &quot;#3FC48A&quot;, &quot;purple&quot; : &quot;#CA5BC8&quot;, &quot;red&quot; : &quot;#D8473F&quot;, &quot;white&quot; : &quot;#EAEAEA&quot;, &quot;yellow&quot; : &quot;#D7BA7D&quot; }, ], . | wsl2(ubuntu)와 win-terminal or terminal 전에 colorScheme으로 지정해준다. . { &quot;guid&quot;: &quot;{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}&quot;, &quot;name&quot;: &quot;Wsl2&quot;, &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot;, &quot;colorScheme&quot; : &quot;VScode&quot;, }, { // Make changes here to the powershell.exe profile. &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;, &quot;name&quot;: &quot;Windows PowerShell&quot;, &quot;commandline&quot;: &quot;powershell.exe&quot;, &quot;hidden&quot;: false, &quot;colorScheme&quot; : &quot;VScode&quot;, }, . &quot;profiles&quot;: { &quot;defaults&quot;: { // Put settings here that you want to apply to all profiles. &quot;fontFace&quot; : &quot;Fira Code&quot;, &quot;colorScheme&quot; : &quot;VScode&quot;, }, . | . | wsl2 계정 및 폴더 설정 in win10 . 항상 특정유저로 wsl2 진입 . /etc/wsl.conf 없으면 생성 . sudo vi /etc/wsl.confg . [user] default=is2js . | . 윈도우 탐색기에 wsl2경로 네트워크로 만들기 . 윈도우( )탐색기 창에서는 wsl$ 로 우분투로 접속가능하다. config등 경로에서는 //wsl$의 슬래쉬로 사용된다. | 참고) 윈도우탐색기상 wt -d .을 통해, 현재경로에서 윈도우 터미널 열기 | . | . wsl 쉘 킨 상태로 연결유지 | 탐색기 &gt; 내PC 우클릭 &gt; 네트워크 위치 추가 사용자 지정 네트워크 위치 선택 | [인터넷 또는 네트워크주소] 부분에 wsl$입력후 찾아보기 | 원하는 경로선택하기 : 우분투/home/is2js/workspace/ | 원하는 이름 입력 : is2js_workspace | . | 여기서 들어간 뒤 wt -d .로 윈도우 터미널(wsl)을 열면 될듯? | wsl2 ubuntu 기본설정 . 루트 계정 비밀번호 초기화참고 블로그 | 유저계정을 root 화시키기 참고 블로그 usermod -aG sudo [계정명]으로만 주기 | . | . openssl 설치 . sudo apt install openssl . | root의 기본 비밀번호 초기화 . sudo passwd root . # : 관리자 | $ : 일반유저 | . | 유저계정에 root권한부여 (파일3개 수정) . root계정으로 권한설정파일에 유저계정-&gt; root권한부여 . su . vi /etc/sudoers . 아래 root쪽에 내 계정도 추가하기 . # User privilege specification root ALL=(ALL:ALL) ALL is2js ALL=(ALL:ALL) ALL . | . wq! (readonly떠서 강제로 저장후 종료) . | root계정으로 비밀번호설정파일에 유저계정-&gt; root권한부여 . root항목처럼, root:x:0:0:root:/~f로 시작하는 부분에서 앞쪽0 : uid | 뒤쪽0: gid 관리자라면 둘다 0임. | 나는 뒤쪽 그룹id만 0으로줌. | . | . | . vi /etc/passwd . wq! . #is2js:x:1002?:1002?:,,,:/home/is2js:/usr/bin/zsh is2js:x:1002?:0:,,,:/home/is2js:/usr/bin/zsh . | root계정으로 그룹설정파일에 유저계정-&gt; root권한부여 . root가 대장인 0그룹에 추가를 해주면됨 . vi /etc/group . wq! . #root:x:0: root:x:0:is2js . | . | zsh 권한 에러시 . sudo chown -R ${LOGNAME}:staff $HOME . | wsl2-ubuntu 시작계정 설정하기 . powershell 에서 . ubuntu[1804] config --default-user [is2js] . | . | wsl2-ubuntu 시작폴더 설정하기 in WindowTerminal . 터미널의 wsl프로필에다가 옵션을 추가해줌 . 출저 | . &quot;startingDirectory&quot;:&quot; wsl$ Ubuntu-[20.04] home [myskan]&quot; . &quot;guid&quot;: &quot;{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}&quot;, &quot;name&quot;: &quot;Wsl2&quot;, &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot;, &quot;colorScheme&quot; : &quot;VScode&quot;, &quot;startingDirectory&quot;:&quot; wsl$ Ubuntu-18.04 home is2js&quot;, . | 참고 . wsl$ : 탐색기에서 우분투 폴더라도 바로 가기 | . | . | windows 업데이트 이후 wsl error 발생할 때 . . 시작 메뉴에서 기능을 검색해서 Windows 기능 켜기/끄기에 들어가 아래 3개 항목을 선택해제 | 재부팅 | 다시 3개 항목 체크한 뒤 사용 | python-&gt;python3 매핑 . 참고블로그 | 더 좋은 블로그 | . Alternatives는 기본 커맨드의 심볼릭 링크를 관리해주는 리눅스 프로그램입니다. 데비안 계열의 리눅스(우분투)에서는 update-alternatives가 제공됩니다. . | 우분투(Ubuntu)를 설치하면 python path가 2.7로 설정되어 있습니다. . 리눅스의 Alternatives를 이용하면 python 버전을 쉽게 변경하고 관리할 수 있습니다. | . ❯ which python /usr/bin/python . python은 /usr/bin/python의 링크인데 | . ❯ ls -al /usr/bin/ | grep python lrwxrwxrwx 1 root root 9 Apr 16 2018 python -&gt; python2.7 lrwxrwxrwx 1 root root 16 Apr 16 2018 python-config -&gt; python2.7-config lrwxrwxrwx 1 root root 9 Apr 16 2018 python2 -&gt; python2.7 lrwxrwxrwx 1 root root 16 Apr 16 2018 python2-config -&gt; python2.7-config -rwxr-xr-x 1 root root 3633000 Feb 28 2021 python2.7 lrwxrwxrwx 1 root root 33 Feb 28 2021 python2.7-config -&gt; x86_64-linux-gnu-python2.7-config lrwxrwxrwx 1 root root 9 Oct 25 2018 python3 -&gt; python3.6 . ❯ ls -al /usr/bin/python lrwxrwxrwx 1 root root 9 Apr 16 2018 /usr/bin/python -&gt; python2.7 . /usr/bin/python 역시 실행파일이 아닌 /usr/bin/python2.7의 링크이다. . | **즉 ** . /usr/bin/python2.7 -&gt; /usr/bin/python -&gt; python | . | . | --config python로 python에 걸려있는 링크를 확인한다. . sudo update-alternatives --config python [sudo] password for is2js: update-alternatives: error: no alternatives for python . alternatives가 없다고 뜨면, 설정을 해줘야한다. | . | --install [symbolic link path(버전을 제외한 공통 경로)] python [real path(버전명시 경로)] [우선순위number]로 여러버전을 등록한다. . #sudo update-alternatives --install /usr/bin/python(버전제외 공통 경로) python(명령어=링크) /usr/bin/python3(버전명시 경로) 10(우선순위) . python2.7 등록 . sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 2 . | python3.6 등록 . 3.6 한개만 등록하고 해당 버전을 선택안해도 python -&gt; python3.6이 걸리도록 하면 된다. | . sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.6 1 . | . | (만약 2개이상 버전 등록했다면) 다시 한번 --config python으로 등록된 버전 확인 및 선택 . sudo update-alternatives --config python There are 2 choices for the alternative python (providing /usr/bin/python). Selection Path Priority Status * 0 /usr/bin/python2.7 2 auto mode 1 /usr/bin/python2.7 2 manual mode 2 /usr/bin/python3.6 1 manual mode Press &lt;enter&gt; to keep the current choice[*], or type selection number: 2 . | **버전을 선택해주면, python의 링크가 특정버전으로 옮겨져있다. ** . ❯ python -V Python 3.6.9 . | pip도 설정해준다. . 1개만 등록하면 pip -&gt; pip3가 될 것이다. | . ❯ sudo update-alternatives --config pip update-alternatives: error: no alternatives for pip . ❯ sudo update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 1 update-alternatives: using /usr/bin/pip3 to provide /usr/bin/pip (pip) in auto mode update-alternatives: warning: not replacing /usr/bin/pip with a lin . ❯ pip -V pip 9.0.1 from /usr/lib/python3/dist-packages (python 3.6) . | 1개만 alternative를 등록해서 python, pip를 default로 3버전으로 지정해주자. | . # pip3 install sudo apt-get update sudo apt-get install -y python3-pip pip3 --version # python3, pip3 alternatives command sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10 sudo update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 1 . python 가상환경 설정 . pip3 &amp; pyenv(격리된 python) 설치 . python3-pip 설치 . sudo apt update &amp;&amp; upgrade sudo apt install python3-pip pip3 -V pip3 --version . | pyenv 설치 . curl https://pyenv.run | bash . WARNING: seems you still have not added &#39;pyenv&#39; to the load path. # See the README for instructions on how to set up # your shell environment for Pyenv. # Load pyenv-virtualenv automatically by adding # the following to ~/.bashrc: eval &quot;$(pyenv virtualenv-init -)&quot; . clone한 pyenv디렉토리를 zshrc에 환경변수(PYENV_ROOT)로 직접지정해줘야한다. . cd ~ # wsl로 정상적으로 열릴려면, /mnt/상태에서 vscode를 열면 안된다. code ~/.zshrc . source ~/.zshrc . | pyenv사용전, 에러를 일으키는 미설치 패키지 다 설치하기 . sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev . | . | pyenv 사용법 . # 설치가능한 python list 확인하기 pyenv install --list # 원하는 python 버전 설치 pyenv install [파이썬버전] # 설치된 파이썬 버전 확인 pyenv versions # 가상환경 만들기 pyenv virtualenvs [파이썬버전] [가상환경명] # 가상환경 시작하기 pyenv activate [가상환경명] # 가상환경 끝내기 pyenv deactivate # 가상환경 목록 확인 pyenv virtualenvs # 가상환경 삭제하기 pyenv uninstall [가상환경명] ### 실사용 pyenv versions pyenv install 3.8.6 pyenv global 3.8.6 # 3.8.6을 pyenv 기본 python으로 지정 . python 저장위치 root -&gt; /root 가 홈폴더 유저의 경우 -&gt; /home/유저명이 홈폴더 | . | ~/.pyenv/ 라는 곳에 versions/폴더에 설치된다. github다. | . | virtualenvwrapper에서도 ~/.pyenv/versions/3.8에서 자동완성후 /3.8.6/bin/python을 이용한다. | . | . | virtualenv &amp; pyenv-virtualenvwrapper(격리된 python으로 가상환경 생성) 설치 . pip3로 virtualenv virtualenvwrapper 2개 패키지 설치 . pip install virtualenv virtualenvwrapper pip3 install virtualenv virtualenvwrapper #에러나므로 --upgrade까지 pip install --upgrade virtualenvwrapper pip3 install --upgrade virtualenvwrapper . | virtualenvwrapper 설정 . # virtualenv 설정 export WORKON_HOME=~/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python # /usr/bin/python3 . | pyenv-virtualenvwrapper 설치 . git clone https://github.com/pyenv/pyenv-virtualenvwrapper.git $(pyenv root)/plugins/pyenv-virtualenvwrapper . pyenv설정 추가 수정 . # pyenv clone후 경로 직접 지정 export PYENV_ROOT=&quot;$HOME/.pyenv&quot; export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot; if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then eval &quot;$(pyenv init -)&quot; fi pyenv virtualenvwrapper_lazy #에러나서 주석처리했다가 다시 풀어줌 . source ~/.zshrc . | virtualenv 추가 설정 . # virtualenv 설정 export WORKON_HOME=~/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python #source /usr/local/bin/virtualenvwrapper.sh source ~/.local/bin/virtualenvwrapper.sh . | . | 실사용 . pyenv install 3.8.6 pyenv versions #~/.pyenv/versions/ 에 격리된 파이썬들 버전명의 폴더에 설치됨. pyenv global 3.8.6 pyenv versions mkvirtualenv goglekaap which python #/home/is2js/.virtualenvs/goglekaap/bin/python deactivate workon # goglegkaap rmvirtualenv goglekaap # pyenv로 만든 python버전을 지정해서 가상환경 생성 mkvirtualenv -p ~/.pyenv/versions/3.8.6/bin/python goglekaap lsvirtualenv # workon이랑 동일한 듯. . # pyenv pyenv install [version] # Python 버전 설치 pyenv versions # 현재 설치된 Python 버전 목록 pyenv global [version] # 전역 Python 버전 변경 #virtualenv wrapper mkvirtualenv [project name] # 프로젝트를 위해 virtualenv 생성 workon [project name] # virtualenv 활성화 deactivate # virtualenv 비활성화 setvirtualenvproject # 현재 디렉토리를 프로젝트의 Home 디렉토리로 설정하기 rmvirtualenv [project name] # virtualenv 삭제 lsvirtualenv # virtualenv 목록 mkvirtualenv [가상환경이름] mkvirtualenv [-p ~/.pyenv/versions/3.8.6/bin/python] [tester(가상환경이름)] #가상환경이름으로 가상환경을 만들어준다. mkvirtualenv test -p [python-path]로 python 버전을 지정해 줄 수 있다. rmvirtualenv [ 가상환경이름] #해당 가상환경을 지운다. workon [가상환경이름] #해당 가상환경으로 진입한다. setvirtualenvproject # &lt;가상환경 진입상태 by workon&gt;에서 프로젝트 디렉토리로 이동 후, 해당 커맨드를 치면 디렉토리&lt;--&gt; 가상환경이 맵핑된다. 그러면 workon커맨드를 치는것 만으로 해당 디렉토리에 이동까지 시켜준다. 아주좋다. cdproject #setvirtualenvproject를 했을 경우, 현재 어디에 있든 해당 커맨드로 프로젝트 디렉토리에 이동이 가능하다. # 예를 들어, 아무폴더에서 workon [가상환경] -&gt; cdproject deactivate #가상환경에서 빠져나온다. . | 참고) path 관련 확인해보기 . python 설치(PATH) 확인 . linux에서는 python + tab, python3 + tab을 통해 깔린 버전을 간접적으로 파악 가능 python3로 자동완성된다면.. python3만 깔린 것 앞으로 모든 명령어 앞에 python+3 | . | . | python3 --help -m [모듈명] : mod로서, library모듈을 script로 실행시키는 옵션 pip, flask, venv 등에서 쓰임. 물론 패키지가 깔린상태여야함. | python3 -m venv [가상환경명] | . | -V : 버전확인 | -c &quot; python코드 &quot; : python코드를 바로 커맨드라인에서 실행함 | . | . win10 환경변수 path로 설치확인 . win+s 에서 환경 변수검색 &gt; 시스템 환경 변수 편집 . | 고급탭 &gt; 환경변수N &gt; 사용자 변수 or 시스템 변수 . 나는 초콜렛리로 설치하였더니 시스템 변수탭에 Path에 설치됨. C: Python39 Scripts : 스크립트 폴더를 더블클릭해서 가보기 | C: Python39 | . | | . | win10 or wsl2 python os모듈로 확인 . import os . | os.environ (dict) . os.environ.get(‘SHELL’) for wsl2 . os.environ.get(&#39;SHELL&#39;) &#39;/usr/bin/zsh&#39; . | . | python path로 실행가능한 python script만들기(앞에 python3 안달아도됨) . which python3 후 경로를 복사해놓는다. . /usr/bin/python3 | . | python 파일의 가장 위에 #! + python경로를 입력한 뒤, python 코드를 작성하면된다. . code calculate.py . #!/usr/bin/python3 def add(x,y): return x+y print(add(2,3)) . 결과물은 print만 되도록한다.(bash실행이라서?) | . | sudo chmod +x calculate.py . | 실행시 calculate.py가 아니라 ./calculate.py로 실행시킨다. . ./calculate.py | 에러 뜨면 sed -i &#39;s/ r$//&#39; calculate.py 실행후 다시 실행 | . | . | .",
            "url": "blog.chojaeseong.com/configuration/choco/windowsterminal/wsl/pyenv/2021/10/13/%EC%84%B8%ED%8C%851_%EC%9C%88%EB%8F%84%EC%9A%B0_choco_terminal_wsl2_python.html",
            "relUrl": "/configuration/choco/windowsterminal/wsl/pyenv/2021/10/13/%EC%84%B8%ED%8C%851_%EC%9C%88%EB%8F%84%EC%9A%B0_choco_terminal_wsl2_python.html",
            "date": " • Oct 13, 2021"
        }
        
    
  
    
        ,"post165": {
            "title": "vscode) python 실행용 tasks.json 기록",
            "content": "VScode . tasks.json . ctrl+shift+B로 python파일 빠르게 출력하기 함. . | 한번 눌러보고 설정&gt;템플릿생성&gt;Others&gt;기록 . | . { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;Project Label&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;python&quot;, &quot;args&quot;: [ &quot;${file}&quot; ], &quot;presentation&quot;: { &quot;reveal&quot;: &quot;always&quot;, &quot;panel&quot;: &quot;new&quot; }, &quot;options&quot;: { &quot;env&quot;: { &quot;PYTHONIOENCODING&quot;: &quot;UTF-8&quot; } }, &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true } } ] } .",
            "url": "blog.chojaeseong.com/configuration/2021/08/24/tasks.html",
            "relUrl": "/configuration/2021/08/24/tasks.html",
            "date": " • Aug 24, 2021"
        }
        
    
  
    
        ,"post166": {
            "title": "PT내용 기록.",
            "content": "스트레칭 . 양손꽉지 -&gt; 어깨내리고, 엄지세우고 -&gt; 턱을 위로 당기기 10초 | 양속 뒤로 꽉지 -&gt; 고개 아래로 잡아당기기 10초 | 고개회전+굴곡으로 대각선 아래보기 -&gt; 귀와 후두부사이를 4손가락으로 잡아서 아래로 당겨 승모근 늘이기 | 삼각근 늘려주기 코끼리코자세로 팔꿈치위쪽을 쭈욱 당긴 뒤 | 양쪽 어깨 내리고 | 다시 쭈욱 당기기 | . | 삼두근 늘이기 한손을 머리뒤로 넘기고 | 반대손으로 팔꿈치를 꾹 눌러 잠근다음 | 안쪽으로 쭉 당겨주기 | . | 꽉지끼고 허리 굴곡시켜주기 | 꽉지끼고 허리 측굴 시키기 꽉찌 위로 껴서 몸을 조금 측굴 후 | 엉덩이를 반대편으로 밀어서 완전히 측굴 | . | 허리 돌리기 양쪽방향 | . | 손목, 발목 돌리기 반대손으로 손목을 잡은 상태에서, 손목+발목 10, 반대10초 돌리기 | . | 상완전완 . 2 트라이셉스(케이블)푸쉬 다운 p.26 . . . 25:28분 . 가슴 . 가슴운동하는 이유 : 중력에 의해 앞으로 쏠리는 게 편하여 생기는 라운드솔뎌의 단축된 가슴을 펴준다. . 가슴단축을 펴준다. | 프레임이 커진다. 등운동과 같이해서 크게한다. | 푸쉬업보다 벤치프레스가 가동범위가 크다. | . | . 1-1덤벨(벤치) 프레스 p.83 . . . 1주차, 2~4kg 허리 아픈 환자는 벤치위에 양발을 올린 상태해서 하면 편하다 | . | . 준비 : 허리아치 + 어깨 내림 + 견갑골 양간 잡아주기 bar로 하듯이 잡은 상태로 팔을 편 상태가 시작. | . | 아령은 앞으로 넘어갈 때의 전완에 힘이 들어오는 선에서 | 수직선으로 내려갔다가 그대로 올려줌(모으는 느낌X) 속도는 빠르게 | . | 1-2덤벨 플라이 p.84 . . 가슴을 이완시켜 가슴 안쪽을 채워주는 운동 여성분들의 벌어진 가슴을 모음 | 남성분들은 가슴 볼륨감을 높혀줌 | . | . 허리아치 + 어깨 내림 + 견갑골 양간 잡아주기 | 팔꿈치는 수직으로 내려가고 손등은 땅바닥을 보는 방향으로 내려간다 약간 손목을 틀어주면서 해야하므로 좀 어려웠다. | . | 중력을 이용해서 내려가며 + 덤벨을 몸에서 최대한 멀리 다 피지말고 덤벨을 잡을 수 있게 약간만 전완이 굽어진 상태 | . | 어깨 . 가슴~팔을 중간 근육 | 등 운동할때도 포함되는 중간 근육 등, 가슴 근육을 눌려주는시 가운데서 버티는 역할 | . | . 1-3시티드 덤벨 프레스 p.41 . 덤벨프레스는 허리에 과부하가 가므로 반드시 앉아서(시티드) + 약간은 뒤로 기울인 상태로 등/엉덩이가 닿은 상태로 시행하자. | . . 엉덩이, 등을 딱 붙이고, 가슴 내밀고, 어깨 내린 상태에서 팔을 든 상태에서 시작. 허리통증이 없는 사람도 생기게 되니 주의 | . | 수직으로 내려오되, 이마가 아니라 정수리 라인까지 내려오게 한다. 옆에 거울 보면서 수직으로 해야 어깨로 드는 것. | . | 1-4사이드 래터럴 레이즈(사래레) p. 48 . . . 전면 삼각을 운동시키기 위해, 팔을 약간 내회전한 상태에서 시작한다. | . 대각선으로 올라간다. | 올라갔다가 바로 내려온다. 버티기X s | 대퇴, 둔부 . 2스쿼트 . . . 어깨보다 한발씩 더 벌린 상태로 발 앞꿈치로 땅바닥을 잡는다 생각하여 엉덩이를 뛰로 빼더라도 안넘어지도록 한다. | . | 약간 무릎을 바깥쪽으로 뺀 상태로 만들어 엉덩이에 자극을 주고 내려가면서 무릎은 더 바깥쪽으로 벌어져서 둔부가 자극되도록 해야한다 | 무릎이 앞으로 안나온다는 생각으로 엉덩이를 최대한 뒤로 빼면서 내려간다. | . | 허리 아픈 사람은 더 엉덩이로 보강해야해서 중요함. . | 10개 3~4세트 | . 하체 . 2런지 . . . 발을 골반너비 정도만(스쿼트는 어깨넓이) | 한쪽발을 뒤로 한뼘 | 반대발을 앞으로 그만큼 | 뒷발의 뒤꿈치를 확 올리면 앞으로 넘어간다 -&gt; 그만큼 앞으로 이동 | 중심잡기 힘들면 앞발만 바깥쪽으로 조금 회전시켜줌 | 앞무릎 고정상태에서 뒤꿈치 편상태로 뒷무릎만 내려갔다 올라온다. | 10개 3~4세트 . 복근, 기립근 . 크런치 . 팔꿉치가 앞으로 뻣어나간다고 생각하고 시행 | . 플랭크 . 발을 약간 벌려 앞으로 세우기 | 손의 위치랑 입이랑 위치 바꾸기 | 엉덩이는 계속 들고 있기 | 20초 2~3세트 | 슈퍼맨 운동 . 기립근을 직접적으로 키운다. . 대자로 뻗은 뒤 | 고개는 들지말고 팔과 다리를 들어서 1~2초간 버티고 돌아온다. |",
            "url": "blog.chojaeseong.com/pt/%EC%9A%B4%EB%8F%99/2021/08/23/PT.html",
            "relUrl": "/pt/%EC%9A%B4%EB%8F%99/2021/08/23/PT.html",
            "date": " • Aug 23, 2021"
        }
        
    
  
    
        ,"post167": {
            "title": "github index, badge 등 생성하여 꾸미기",
            "content": "참고사이트 . 참고 사이트 https://velog.io/@woo0_hooo/Github-github-profile-%EA%B0%84%EC%A7%80%EB%82%98%EA%B2%8C-%EA%BE%B8%EB%AF%B8%EA%B8%B0 | https://butter-shower.tistory.com/142 | https://velog.io/@colorful-stars/Github-%ED%94%84%EB%A1%9C%ED%95%84-%EA%BE%B8%EB%AF%B8%EA%B8%B0 | http://blog.cowkite.com/blog/2102241544/ | . | . github_id 이름으로 repo 생성 . github ID와 동일한 이름으로 repo만들기 + add Readme . local에 clone하여 환경 세팅하자. C:/jupyter_blog/ + is2js . . | . | capsule-render로 header/footer 작성 . typora에서 미리보기를 활용하여 header footer를 작성한다. . 각 옵션 목록 : https://github.com/kyechan99/capsule-render . | default(변경하면됨) . ![header](https://capsule-render.vercel.app/api?type=waving&amp;color=f6ebe1&amp;height=150&amp;section=header&amp;text=Data Engineer and KMD&amp;fontSize=50&amp;fontColor=152447&amp;desc=데이터 엔지니어를 꿈꾸는 한의사, 조재성입니다.&amp;descAlignY=80) ![footer](https://capsule-render.vercel.app/api?type=rect&amp;color=152447&amp;height=20&amp;section=footer) . . | . | sheilds.io로 기술 스택 badge작성 . shields.io를 통해 기술스택, 연락처 등의 스택아이콘 가져온다. . a태그 &gt; img태그 . | a태그는 링크주소를 / img는 badge를 여기를 통해서 편하게 가져온다. . 각 뱃지 목록 : https://github.com/alexandresanlim/Badges4-README.md-Profile | . &lt;p align=&quot;center&quot;&gt; &lt;a href=&quot;mailto:tingstyle1@gmail.com&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Gmail-d14836?style=flat-square&amp;logo=Gmail&amp;logoColor=white&amp;link=tingstyle1@gmail.com&quot;/&gt;&lt;/a&gt;&amp;nbsp &lt;a href=&quot;https://www.facebook.com/tingstyle1&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Facebook-1877F2?style=flat-square&amp;logo=facebook&amp;logoColor=white&quot;/&gt;&lt;/a&gt;&amp;nbsp &lt;a href=&quot;https://www.github.com/is2js&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/GitHub-100000?style=flat-square&amp;logo=github&amp;logoColor=white&quot;/&gt;&lt;/a&gt;&amp;nbsp &lt;/p&gt; . | . productive-box로 커밋시각 통계(gist) 노출(pinned)하기 . 참고 : http://blog.cowkite.com/blog/2102241544/ | . gist.github.com에 public으로 신규 public으로 바꾼 gist를 생성 . . | github토큰 생성 페이지로 가서 repo, gist를 포함한 scope를 설정한 뒤, 발급받은 토큰을 잘 챙겨둔다. . QQQghp_ysd0aOZbgsOJ3rOTAhj4QQQw4su6rrfPp1oc7WrQQQ . | productive-box repository를 fork한다. . 우측 상단의 Fork 버튼을 누르면 된다. . | fork 된 나의 repository의 Actions 탭에서 enabled 버튼을 눌러 Action을 활성화한다 . | .github/workflow/Schedule.yml . 파일을 수정하여 환경변수를 작성해준다 . uses: is2js/productive-box@master : 내github아이디로 바꿔준다? . maxam2017 -&gt; 내 아이디로 | . | GIST_ID: 사전 작업의 1번 step에서 생성된 gist의 id (gist URL은 gist.github.com//로 생성되기 때문에 주소창을 보면 된다.) 042e89789d6054e9b372e755e75f09f5 | . | TIMEZONE: 타임존을 적어준다. Asia/Seoul 형식으로 적어주면 된다. cf) cron : 분시일월주 cron예제 : https://ponyozzang.tistory.com/402 | . | . | . | . | 해당레포 &gt; Settings 탭 &gt; Secrets에 접속한 뒤 New repository secret 버튼을 클릭하여 환경변수를 설정해준다. . GH_TOKEN: 사전 작업의 2번 step에서 발급받은 토큰 . 토큰은 github &gt; secrets &gt; 환경변수에서 설정해주면, workflows.config.yaml을 그것을 이용한다. | . env: GH_TOKEN: $ . | . . | gist를 내 프로필 pinn에 고정시킨다. . | 내 블로그에 embed시킨다. . 아래 코드에서 gist주소만 복사해서 gist_id.js를 넣어주면 됨. | . | 깃허브 프로필 뱃지 얻기 . Github Developer program . https://developer.github.com/program/ 사이트에서 등록한다. . 2가지만 추가로 채워주면 된다. . | Highlights부분에 뱃지 생김 . . | . | 학생 PRO . 유효한 date를 포함하는, 학생증 찍어서 증명하는 부분이 생겨 나는 포기함. | . https://education.github.com 접속후 Student Developer Pack 클릭 . | Get pack &gt; Get Student benefits &gt; 아래쪽 학교인증 . github에 학교계정으로 email을 등록하고 와야한다. . . | . | 마지막에 plan을 Github Pro로 적어주면 된다. . | 증명서를 내라고한다. 나는.. 졸업해서 그냥 생략.. . | 북극곰 2020.02월 . 나는 우연히 그 때 만들어뒀나보다. | .",
            "url": "blog.chojaeseong.com/git/github/2021/08/19/github-profile.html",
            "relUrl": "/git/github/2021/08/19/github-profile.html",
            "date": " • Aug 19, 2021"
        }
        
    
  
    
        ,"post168": {
            "title": "윈도우 터미널 단축키 모음",
            "content": "단축키 . [ALT] + [SHIFT] + [+] : 가로 창 나누기 ![image-20210715145754288] | [ALT] + [SHIFT] + [-] : 세로 창 나누기 | [ALT] + [SHIFT] + [방향키] : 창 크기 조절 | [ALT] + [방향키] : 커서가 위치하는 창 전환 | [CTRL] + [L] : 클리어 | [CTRL] + [SHIFT] + [ W] : 창 닫기 | [ALT] + [SHIFT] + [D] : 쉘 복제 | [CTRL] + [+/-/마우스 휠] : 글자 크기 조절 | [CTRL] + [,] : 설정 | .",
            "url": "blog.chojaeseong.com/configuration/2021/08/18/WindowTerminal_shortcut.html",
            "relUrl": "/configuration/2021/08/18/WindowTerminal_shortcut.html",
            "date": " • Aug 18, 2021"
        }
        
    
  
    
        ,"post169": {
            "title": "알고리즘 문제 풀기용 array 연습 (python)",
            "content": "input array . 1&#52264;&#50896; list . 10 5 1 10 4 9 2 3 8 5 7 6 . a, b = map(int, input().split()) print(a, b) # 1개는 안된다. 튜플 언패킹시에만 따로 받아진다!! c = map(int, input().split()) print(c) . 10 5 &lt;map object at 0x000001F38F7937C0&gt; . arr = list( map(int, input().split()) ) arr . [1, 10, 4, 9, 2, 3, 8, 5, 7, 6] . 2&#52264;&#50896;(&#44396;&#48516;&#51088;O) . 9 0 0 0 1 1 1 -1 -1 -1 0 0 0 1 1 1 -1 -1 -1 0 0 0 1 1 1 -1 -1 -1 1 1 1 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 1 -1 0 1 -1 0 1 -1 0 -1 1 0 1 -1 0 1 -1 0 1 -1 1 0 -1 0 1 -1 . # - 행수만큼 list comp를 돌리고, # - 그 행의 내부요소들은 1줄을 split -&gt; map(int, ) -&gt; list 까지 만든다. N = int(input().strip()) # paper = [ for i in range(N)] paper = [ list(map(int, input().strip().split())) for i in range(N)] . paper . [[0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, -1, 0, 1, -1, 0, 1, -1], [0, -1, 1, 0, 1, -1, 0, 1, -1], [0, 1, -1, 1, 0, -1, 0, 1, -1]] . 2&#52264;&#50896; &#44396;&#48516;&#51088;X (&#49707;&#51088;&#47196; 1character&#50473;&#47564; &#52264;&#51648;) . 문자열(no split) -&gt; map(1글자를 1글자int로) -&gt; list(1글자들을 열로) | . 3 3 011 111 110 . list(&#39;1019&#39;) . [&#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;9&#39;] . list(map(int, &#39;1019&#39;)) . [1, 0, 1, 9] . # - split대신 list(&#39;문자열&#39;) -&gt; 1글자씩 list # - split대신 list( map(int, &#39;문자열&#39;)) -&gt; 숫자1개씩 list # -- map(int, &#39;문자열&#39;)은 문자열을 하나씩 쪼개받아서 int를씌운다. N, M = map(int, input().split()) # map은 튜플로 할당 받을 수 있다. but 1개 변수에 할당시는 맵객체다. # MIRO = [ for i in range(N) ] # 열은 갯수는 M대신 split이 아닌 문자열-&gt;map-&gt;list -&gt; list(map(())으로 쪼개서 받았다. MIRO = [ list(map(int, input())) for i in range(N) ] . MIRO . [[0, 1, 1], [1, 1, 1], [1, 1, 0]] . &#49440;&#50616; array . input으로 받아서 쪼개서 열을 만들지말고, 이번에는 직접 선언해보자. | numpy를 지원하지 않을 때, 리스트로 만드는 n차원 배열이다. | . INIT = -1 # 각 행렬 요소의 초기화 값이다. W = row = N H = column = M C = channel = 3 B = batch = 3 # 1차원 array : 초기화값이 요소 상태로 list comp D1 = [ INIT for _ in range(W)] # 1차원은 행길이만큼 list comp + [] X -&gt; 행길이만큼 요소롤 복제하도록 list comp + 요소 # D1 = [ INIT ] * N # 요소복제의 2번째 방법, list든 str든 곱하면 extend된다. # - but 내부 list comp 요소 + 외부 [] 그만큼 곱은 주의한다. id가 동일한놈들이 복사된다. # 2차원 array : 행[]들 먼저 행길이만큼 list comp돌고 , 내부 1row를 요소 list comp # D2 = [ [] for _ in range(H)] D2 = [ [ INIT for _ in range(W) ] for _ in range(H)] # 3차원 array : 2차원 밖에 [[]]행렬 갯수만큼 list comp 해줌. D3 = [[[ [ INIT for _ in range(W) ] for _ in range(H)]] for _ in range(C)] # 3차원 array : 2차원 밖에 [[]]행렬 갯수만큼 list comp 해줌. D4 = [[[[ [ INIT for _ in range(W) ] for _ in range(H)]] for _ in range(C)] for _ in range(B)] print(D1) print(D2) print(D3) print(D4) . [-1, -1, -1] [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]] [[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]] [[[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]], [[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]], [[[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]], [[[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]]]] . 2&#52264;&#50896; &#51025;&#50857; by range . INIT값이 아닌 1부터 순서대로 채운 N*N 행렬 range( , , 열길이)를 이용한다. N씩 건너뛰어서 가니까... | 시작은 1부터 n(n-1) + 2 로 1부터 n-1까지의 합으로 간다? | . | . 1&#48512;&#53552; &#49692;&#49436;&#45824;&#47196; &#52292;&#50868; (N,N)&#54665;&#47148; . 각행의 첫째항을 등차수열(column : N개) 를 이용해서 만들어준다. . 1부터 N의 등차수열 range(1, , N)과 끝값은 N번째항 뽑은 것 + 1 을 넣어준다 | An = a1 + (n-1)d = 1 + n(n-1) -&gt; range( , n*n-1 + 1, ) | . | 각 행렬의 첫째항부터 1씩 증가하여 N개를 채운 행list를 완성한다. . | # - 일단 1 ~ n*(n-1)/2 에서 마지막항의 의미는 그냥 찍어보면 모른다. n = 6 for i in range(1, n*(n-1)+2, n): print(i) print(n*(n-1)+2) . 1 7 13 19 25 31 32 . # - for문 안의 i가 1에서부터 **등차(k)수열**이 되어버림. # 1부터, 등차가 n이면, n열짜리 행1개를 건너띈 다음 행 첫째항이 된다. # 열의 갯수N을 등차로 하여 일반항을 잡고, 행 N개를 가야하므로 # An = 1 + (n-1)*d = n*(n-1) + 1 이 된다. # 등차수열 range(1, ,n)이 n번째항 까지는 가야하므로, n번째항+1을 넣어준 것이다. for i in range(1, n*(n-1)+2, n): print(i, &quot;&lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다.&quot;) . 1 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 7 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 13 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 19 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 25 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. 31 &lt;&lt;&lt; 1시작, N열(등차), N행까지 채워주는 행렬의 각 행 첫째항입니다. . # 2중 list comp는 요소만 노출할 경우, 1차원 행렬밖에 # - list로 만들경우, 각 요소들이 list로.. # - 행단위로 묵어서는 못만든다 -&gt; result = [] for문 이용 n = 5 result = [] for i in range(1, n*(n-1)+2, n): # 첫째항 i, 등차1 의 수열을 1~n항까지 listcomp로 모으기 result.append([ i+(j-1)*1 for j in range(1, n+1)]) result . [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]] . # 행마다 돌면서 row에접근후 인덱싱.. [ row[4:6] for row in paper[4:7]] . [[0, 0], [0, 0], [1, -1]] . def check_valid(matrix): print(&quot;dict상태&gt;&gt;&gt;&quot;, count_dict) if len(matrix) == 1: print(&quot;1개짜리 돌입. matrix &gt;&gt;&gt;&quot;, matrix) # 1개짜리라면.. 넣고 +1 count_dict.setdefault(matrix[0][0], 0) count_dict[matrix[0][0]] +=1 return True paper_0_0 = matrix[0][0] flag = False for i in range(len(matrix)): for j in range(len(matrix)): if paper_0_0 != matrix[i][j]: flag = True break if flag: print(&quot;다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : &quot;,matrix ) N = len(matrix) # 3x3중 1x1 -&gt; 열 3구간 다 check_valid([ row[:N//3] for row in matrix[:N//3]]) check_valid([ row[N//3:(N//3)*2] for row in matrix[:N//3]]) check_valid([ row[(N//3)*2:] for row in matrix[:N//3]]) # 3x3중 2x2 check_valid([ row[:N//3] for row in matrix[N//3:(N//3)*2]]) check_valid([ row[N//3:(N//3)*2] for row in matrix[N//3:(N//3)*2]]) check_valid([ row[(N//3)*2:] for row in matrix[N//3:(N//3)*2]]) # 3x3중 3x3 check_valid([ row[:N//3] for row in matrix[(N//3)*2:]]) check_valid([ row[N//3:(N//3)*2] for row in matrix[(N//3)*2:]]) check_valid([ row[(N//3)*2:] for row in matrix[(N//3)*2:]]) else: print(&quot;다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix:&quot;, matrix) count_dict.setdefault(paper_0_0, 0) count_dict[paper_0_0] += 1 return True count_dict = {} check_valid(paper) . dict상태&gt;&gt;&gt; {} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [0, 0, 0, 1, 1, 1, -1, -1, -1], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, -1, 0, 1, -1, 0, 1, -1], [0, -1, 1, 0, 1, -1, 0, 1, -1], [0, 1, -1, 1, 0, -1, 0, 1, -1]] dict상태&gt;&gt;&gt; {} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] dict상태&gt;&gt;&gt; {0: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[1, 1, 1], [1, 1, 1], [1, 1, 1]] dict상태&gt;&gt;&gt; {0: 1, 1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]] dict상태&gt;&gt;&gt; {0: 1, 1: 1, -1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[1, 1, 1], [1, 1, 1], [1, 1, 1]] dict상태&gt;&gt;&gt; {0: 1, 1: 2, -1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] dict상태&gt;&gt;&gt; {0: 2, 1: 2, -1: 1} 다 똑같다 통과, dict에 넣고 저장후 return True로 종료 matrix: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] dict상태&gt;&gt;&gt; {0: 3, 1: 2, -1: 1} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 1, -1], [0, -1, 1], [0, 1, -1]] dict상태&gt;&gt;&gt; {0: 3, 1: 2, -1: 1} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 4, 1: 2, -1: 1} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 4, 1: 3, -1: 1} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 4, 1: 3, -1: 2} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 5, 1: 3, -1: 2} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 5, 1: 3, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 5, 1: 4, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 6, 1: 4, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 6, 1: 5, -1: 3} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 6, 1: 5, -1: 4} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 1, -1], [0, 1, -1], [1, 0, -1]] dict상태&gt;&gt;&gt; {0: 6, 1: 5, -1: 4} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 7, 1: 5, -1: 4} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 7, 1: 6, -1: 4} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 7, 1: 6, -1: 5} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 8, 1: 6, -1: 5} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 8, 1: 7, -1: 5} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 8, 1: 7, -1: 6} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 8, 1: 8, -1: 6} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 9, 1: 8, -1: 6} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 9, 1: 8, -1: 7} 다른게 나왔다. N/3으로 한번더.. 총 9개... 대상 matrix : [[0, 1, -1], [0, 1, -1], [0, 1, -1]] dict상태&gt;&gt;&gt; {0: 9, 1: 8, -1: 7} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 10, 1: 8, -1: 7} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 10, 1: 9, -1: 7} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 10, 1: 9, -1: 8} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 11, 1: 9, -1: 8} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 11, 1: 10, -1: 8} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] dict상태&gt;&gt;&gt; {0: 11, 1: 10, -1: 9} 1개짜리 돌입. matrix &gt;&gt;&gt; [[0]] dict상태&gt;&gt;&gt; {0: 12, 1: 10, -1: 9} 1개짜리 돌입. matrix &gt;&gt;&gt; [[1]] dict상태&gt;&gt;&gt; {0: 12, 1: 11, -1: 9} 1개짜리 돌입. matrix &gt;&gt;&gt; [[-1]] . print(*map(lambda x:x[1], sorted(count_dict.items(), key=lambda x:x[0]))) . 10 12 11 .",
            "url": "blog.chojaeseong.com/boj/python/array/2021/08/12/python_%EB%B0%B0%EC%97%B4_%EC%97%B0%EC%8A%B5.html",
            "relUrl": "/boj/python/array/2021/08/12/python_%EB%B0%B0%EC%97%B4_%EC%97%B0%EC%8A%B5.html",
            "date": " • Aug 12, 2021"
        }
        
    
  
    
        ,"post170": {
            "title": "파이썬을 파이썬답게 노트정리",
            "content": "&#52636;&#51200; . 파이썬을 파이썬답게 실습강의를 듣고 느낀점과 함께 풀어낸 노트입니다. | . &#44277;&#48512; &#51060;&#50976; . 정수를 담은 이차원 리스트, mylist 가 solution 함수의 파라미터로 주어집니다. mylist에 들은 각 원소의 길이를 담은 리스트를 리턴하도록 solution 함수를 작성해주세요. . 제한 조건 | mylist의 길이는 100 이하인 자연수입니다. | mylist 각 원소의 길이는 100 이하인 자연수입니다. | . | 위 문제를 아래와 같이 짰다면, 수강해야한다. 나는 list comp로 짬 . | . 아래와 같은 풀이는 c언어 or 자바 풀이임. . | 이것과 같이 짜야함 . | . 용어 설명 iterable: 자신의 멤버를 한 번에 하나씩 리턴할 수 있는 객체입니다. list, str, tuple, dict 등이 여기에 속합니다. | sequence: int 타입 인덱스를 통해, 원소에 접근할 수 있는 iterable 입니다. iterable의 하위 카테고리라고 생각하시면 됩니다. | list, str, tuple이 여기 속합니다. ( dictionary는 다양한 타입을 통해 원소에 접근할 수 있기 때문에 sequence에 속하지 않습니다.) | . | unpacking: 적절한 번역을 찾고 있습니다. | . | . &#51221;&#49688; (2) . &#47787;&#44284; &#45208;&#47672;&#51648; . 문제 설명 숫자 a, b가 주어졌을 때 a를 b로 나눈 몫과 a를 b로 나눈 나머지를 공백으로 구분해 출력해보세요. 입력 설명 입력으로는 공백으로 구분된 숫자가 두 개 주어집니다. 첫 번째 숫자는 a를 나타내며, 두 번째 숫자는 b를 나타냅니다. 출력 설명 a를 b로 나눈 몫과 a를 b로 나눈 나머지를 공백으로 구분해 출력하세요. 제한 조건 a와 b는 자연수입니다. . &#45236;&#54400;&#51060;(list comp) . input_ = &#39;5 3&#39; num_ = input_.strip().split(&#39; &#39;) a, b = [int(x) for x in num_] str(a//b) + &#39; &#39; + str(a%b) . &#39;1 2&#39; . &#45712;&#45184;&#51216; (divmod + unpacking) . divmod는 한번에 목과 나머지를 구한다. //, %보단 느리지만, 갯수가 많을 땐 더 빨라진다고 한다. | 데이터 변환을 list comp전에 map(str, ) map(int, )도 활용해보자. | tuple을 unpacking(콤마할당)을 하면, iterable객체(tuple)이 알아서 나뉜다. | . a, b = map(int, input_.strip().split(&#39; &#39;)) . a . 5 . b . 3 . divmod(a, b) # 순서대로 몫, 나머지를 반환함. . (1, 2) . print(*divmod(a, b)) #unpakcking을 print하면, 각각을 공백으로 나누어서 프린트해준다. . 1 2 . (&#52428;) n&#51652;&#48277;&#51004;&#47196; &#54364;&#44592;&#46108; string&#51012; 10&#51652;&#48277; &#49707;&#51088;&#47196; &#48320;&#54872;&#54616;&#44592; . 문제 설명 base 진법으로 표기된 숫자를 10진법 숫자 출력해보세요. 입력 설명 입력으로는 공백으로 구분된 숫자가 두 개 주어집니다. 첫 번째 숫자는 num을 나타내며, 두 번째 숫자는 base를 나타냅니다. 출력 설명 base 진법으로 표기된 num을 10진법 숫자로 출력해보세요. 제한 조건 base는 10 이하인 자연수입니다. num은 3000 이하인 자연수입니다. 예시 input output 12 3 5 444 5 124 입출력 예 설명 입출력 예 1 3진법으로 표기된 12는 10진법으로 표현하면 5입니다. ( 1*3 + 2 ) 입출력 예 2 5진법으로 표기된 444는 10진법으로 표현하면 124입니다. ( 455 + 4*5 + 4 ) . &#45236;&#54400;&#51060; . num, base = map(int, input().strip().split(&#39; &#39;)) div_sum = 0 for n in sorted(range(0, len(str(num))), reverse=True): k, num = divmod(num, 10**(n)) div_sum += k * (base**(n)) print(div_sum) . &#51221;&#45813; . n진법으로 표기된 string을 10진법 숫자로 변환하기 - int 함수 . 진법 변환 문제는 알고리즘 문제나 숙제로 자주 나오는 유형이지요. 이번 시간에는 n 진법으로 표기된 문자열을 10진법 숫자로 변환하는 방법을 배워봅시다. . 예시) 5진법으로 적힌 문자열 &#39;3212&#39;를 10진법으로 바꾸기 . 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통 사람들은 for 문을 이용해 숫자를 곱해가며 문제를 풉니다. . num = &#39;3212&#39; base = 5 answer = 0 for idx, number in enumerate(num[::-1]): answer += int(number) * (base ** idx) . 파이썬에서는 파이썬의 int(x, base=10) 함수는 진법 변환을 지원합니다. 이 기본적인 함수를 잘 쓰면 코드를 짧게 쓸 수 있고, 또 시간을 절약할 수 있습니다. . num = &#39;3212&#39; base = 5 answer = int(num, base) . &#45712;&#45184;&#51216;(enumerate, int( , base), &#47928;&#51088;&#50676;&#46020; sequence, [::-1]) . 순서가 필요한 list나 문자열은 enumerate를 활용하자. ex&gt; 진법변환 계산 | 뒤에서부터 시작을 꼭 sorted( ,reverse=True)에 집착X iterable전용인 문자열, array, dataframe등을 생각할 때 [::-1]을 활용하자. 문자열도, list처럼 sequence이다. (flatcontainerimmutablemutable) -&gt; 인덱싱으로 꺼꾸로 시작하게 할 수 있다. | . | 파이썬에서는 진법변환함수를 int( , base)로 제공한다. 필요하다면 쓰자. 진법변환시 첫자리부터 하지말고, str()+ [::-1]을 활용해 일의 자리에서부터 풀자 | . | . num = &#39;432&#39; base = &#39;5&#39; # 일의 자리부터 풀어보자. + enumerate로 번호를 줘가면서 풀어보자. num[::-1] . &#39;234&#39; . answer = 0 for idx, number in enumerate(num[::-1]): answer += int(number) * ( int(base) ** (idx) ) answer . 117 . # base진법으로 표기된 string num을 -&gt; 10진법 숫자(int())변환 answer = int(num, base=int(base)) answer . 117 . &#47928;&#51088;&#50676; (2) . &#47928;&#51088;&#50676; &#51221;&#47148;&#54616;&#44592; . 문제 설명 문자열 s와 자연수 n이 입력으로 주어집니다. 문자열 s를 좌측 / 가운데 / 우측 정렬한 길이 n인 문자열을 한 줄씩 프린트해보세요. 제한조건 s의 길이는 n보다 작습니다. (n - s의 길이)는 짝수입니다. s는 알파벳과 숫자로만 이루어져 있으며, 공백 문자가 포함되어있지 않습니다. . &#45236;&#54400;&#51060; . s, n = input().strip().split(&#39; &#39;) n = int(n) space_num = n-len(s) print(s+&#39; &#39;*space_num) print(&#39; &#39;*(space_num//2)+s+&#39; &#39;*(space_num//2)) print(&#39; &#39;*space_num+s) . abc 7 abc abc abc . &#51221;&#45813; . # -&gt; answer =&#39;&#39; 빈 문자열에 공백의 갯수만큼 돌면서(반복작업용for) 누적합으로 공백을 채운다. s = &#39;가나다라&#39; n = 7 answer = &#39;&#39; for i in range(n-(len(s))): answer+=&#39; &#39; answer+=s answer . &#39; 가나다라&#39; . s = &#39;가나다라&#39; n = 7 s.ljust(7) . &#39;가나다라 &#39; . s.center(7) . &#39; 가나다라 &#39; . s.rjust(7) . &#39; 가나다라&#39; . &#45712;&#45184;&#51216;(ljust, center, rjust) . 문자열로 sequence로 빈리스트+for+append대신 빈문자열+for++=누적합작업을 생각하자 for문을 반복작업에 활용하자. | . | python은 문자열의 공백정렬을 위해 문자열+공백으로 n자리를 채워준다. | string.ljust(공백포함 왼쪽정렬될 n자리), string.center(n), string.rjust() | . &#50508;&#54028;&#48307; &#52636;&#47141;&#54616;&#44592; . 입력으로 0이 주어지면 영문 소문자 알파벳을, 입력으로 1이 주어지면 영문 대문자 알파벳을 사전 순으로 출력하는 코드를 짜세요. 예시 1 입력 0 출력 abcd...(중간생략)..xyz . &#45236;&#54400;&#51060; . ord(&#39;a&#39;) . 97 . chr(97) . &#39;a&#39; . chr(122) . str . chr(65), chr(90) . (&#39;A&#39;, &#39;Z&#39;) . answer = &#39;&#39; for i in range(65, 90+1): answer+=chr(i) print(answer) . ABCDEFGHIJKLMNOPQRSTUVWXYZ . num = int(input().strip()) answer = &quot;&quot; if num: # num이 0이면, 소문자로 # ord(&#39;a&#39;) = 97 -&gt; z -&gt;122 for i in range(65, 90+1): answer+=chr(i) else: for i in range(97, 122+1): answer+=chr(i) print(answer) . 1 ABCDEFGHIJKLMNOPQRSTUVWXYZ . &#51221;&#45813; . import string string.ascii_lowercase # 소문자 abcdefghijklmnopqrstuvwxyz string.ascii_uppercase # 대문자 ABCDEFGHIJKLMNOPQRSTUVWXYZ string.ascii_letters # 대소문자 모두 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ string.digits # 숫자 0123456789 . &#39;0123456789&#39; . num = int(input().strip()) # answer = &quot;&quot; if num: # num이 0이면, 소문자로 # ord(&#39;a&#39;) = 97 -&gt; z -&gt;122 #for i in range(65, 90+1): # answer+=chr(i) print(string.ascii_uppercase) else: #for i in range(97, 122+1): # answer+=chr(i) print(string.ascii_lowercase) # print(answer) . 1 ABCDEFGHIJKLMNOPQRSTUVWXYZ . &#45712;&#45184;&#51216;(str.lower(), upper() -&gt; string&#49345;&#49688;, string&#47784;&#46280;.ascii_ , string&#47784;&#46280;.digits, ) . string모듈이란 것이 따로 있고, 소문자모음, 대문자모음, 소-&gt;대문자모음, 숫자모음을 상수로 제공한다. string.ascii_lowercase # 소문자 abcdefghijklmnopqrstuvwxyz | string.ascii_uppercase # 대문자 ABCDEFGHIJKLMNOPQRSTUVWXYZ | string.ascii_letters # 대소문자 모두 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ | string.digits # 숫자 0123456789 | . | 다른 사람 풀이를 보고선 chr(), ord()를 안써도되고 | 소문자만 or 대문자만 작성해서 str.lower() / str.upper() 메소드도 활용하자. | . | . iterable &#45796;&#47336;&#44592; (4) . Iterable이란? 자신의 멤버를 한번에 리턴할 수 있는 객체입니다. ex) list, str, tuple, dictionary 등 | . &#50896;&#48376;&#51012; &#50976;&#51648;&#54620;&#52292;, &#51221;&#47148;&#46108; &#47532;&#49828;&#53944; &#44396;&#54616;&#44592; - sorted . 파이썬의 sort() 함수를 사용하면 리스트의 원소를 정렬할 수 있습니다. 이때, sort 함수는 원본의 멤버 순서를 변경하지요. 따라서 원본의 순서는 변경하지 않고, 정렬된 값을 구하려면 sort 함수를 사용할 수 없습니다. . 이런 경우는 어떻게 해야 할까요? . 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통 사람들은 deep copy와 sort 함수를 이용합니다. . list1 = [3, 2, 1] list2 = [i for i in list1] # 또는 copy.deepcopy를 사용 list2.sort() . 파이썬에서는 파이썬의 sorted를 사용해보세요. 반복문이나, deepcopy 함수를 사용하지 않아도 새로운 정렬된 리스트를 구할 수 있습니다. . list1 = [3, 2, 1] list2 = sorted(list1) . &#45712;&#45184;&#51216; - (copy.deepcopy() -&gt; sort() &#50752; sorted() ) . sort()함수는 객체 직접 변환을 하니, &lt;같은값 할당은 shallow copy지만&gt; copy.deepcopy()이후 sort()를 한다고 한다. | sorted()는 새로운 정렬 list를 바로 반환한다. 그 인자로는 reverse=True, key=len, key=str.lower, key=lambda 등 정렬기준을 만드는 함수를 인자로 넣을 수 도 있다. | . | . (&#52428;) 2&#52264;&#50896; &#47532;&#49828;&#53944; &#46244;&#51665;&#44592; ( transpose&#47928;&#51228;, &#50612;&#47140;&#50880; ) . 다음을 만족하는 함수, solution을 완성해주세요. solution 함수는 이차원 리스트, mylist를 인자로 받습니다 solution 함수는 mylist 원소의 행과 열을 뒤집은 한 값을 리턴해야합니다. 예를 들어 mylist [[1, 2, 3], [4, 5, 6], [7, 8, 9]]가 주어진 경우, solution 함수는 [[1, 4, 7], [2, 5, 8], [3, 6, 9]] 을 리턴하면 됩니다. 제한 조건 mylist의 원소의 길이는 모두 같습니다. mylist의 길이는 mylist[0]의 길이와 같습니다. 각 리스트의 길이는 100 이하인 자연수입니다. . &#54400;&#51060;2&#44032;&#51648;(&#51221;&#52376;&#44592;&#49885;i&gt;j, &#48712;_list [i]&#54665;&#44284; for j &#44592;&#51316;list[j][i]&#50676;&#51012; &#54620; &#49464;&#53944;&#47196; ) . mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] mylist[::-1] # 1x1 -&gt; 1 # 2x2 -&gt; 3 # 3x3 -&gt; 5 # nxn -&gt; 2n-1 line # 각 k in 2n-1 마다.. # k=1, -&gt; 길이 1 0.0 # k=2, -&gt; 길이 2 1.0 0.1 # k=3, -&gt; 길이 3 2.0 1.1 0.2 # k=4, -&gt; 길이 2 # k=5, -&gt; 길이 5 # gg . [[7, 8, 9], [4, 5, 6], [1, 2, 3]] . # 타 문제에서는 각 행마다 길이가 같다는 보장이 없기 때문??? 이번 강의에서는 zip 함수를 이용해 2차원 배열을 뒤집는 방법을 알아봅시다. 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통은 다음과 같이 2중 for 문을 이용해 리스트의 row와 column을 뒤집습니다. . [[]]*4 . [[], [], [], []] . [[]]*len(mylist) . [[], [], []] . &#45712;&#45184;&#51216;( &#51221;&#52376;&#44592;&#49885;, new_list&#51032; &#54665;i == mylist&#51032; &#50676;i&#47196; &#44256;&#51221;&#49884;&#53020;, j&#47484; &#46028;&#47536; &#49345;&#53468;) . 2중 for문으로 행렬을 뒤집으려면, 빈 list -&gt; 빈 list의 [i]행 고정상태에 append ( mylist [행을 j로 돌리면서] [열은 i열로 고정]시켜서 뽑아낸 것들 ) . 새 list의 i행과 기존 list의 i열을 동일시 하면서 기존 list의 i열 값들을 뽑아내기 위해 j를 돌리면서 append한다. | . | 정처기식으로, i, j가 돌아가는데, 행렬 중에 i&gt;j 부분만 찾아서 한쪽만 swap . | mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] new_list = [[], [], []] for i in range(len(mylist)): for j in range(len(mylist[i])): new_list[i].append(mylist[j][i]) new_list . [[1, 4, 7], [2, 5, 8], [3, 6, 9]] . mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # new_list = [[], [], []] # new_list = [[]]*3 # 주의! 안에 요소가 콤마로 붙는다고 해서 list바깥에서 *3 하지말 것. id똑같은놈들임. # new_list = [[] for x in range(len(mylist))] for i in range(len(mylist)): for j in range(len(mylist)): if i &gt; j: mylist[j][i], mylist[i][j] = mylist[i][j], mylist[j][i] mylist . [[1, 4, 7], [2, 5, 8], [3, 6, 9]] . (&#52428;) 2&#52264;&#50896; &#47532;&#49828;&#53944; &#46244;&#51665;&#44592; - &#11088;&#65039;zip&#11088;&#65039; . &#54400;&#51060; . mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] new_list = list(map(list, zip(*mylist))) . &#45712;&#45184;&#51216;( zip(*&#47588;&#54609; 2&#52264;&#50896; &#47532;&#49828;&#53944;) -&gt; &#44033; &#54665;&#46308;&#47560;&#45796; 1&#44060;&#50473; &#48977;&#50500; tuple&#47196; ) . 행렬(2차원리스트)를 *매핑해서 zip()에 던져주면, 각 행들을 zip(a,b,c,...,n_rows)로 판단해서 나눠쓴다. 즉, for문으로 받을 때는 각 행마다 0열요소들 / 1열 요소들 / ... 들이 튜플로 모여서 들어온다. | . | 번역 : zip(*iterables)는 각 iterables 의 요소들을 모으는 이터레이터를 만듭니다. 튜플의 이터레이터를 돌려주는데, i 번째 튜플은 각 인자로 전달된 시퀀스나 이터러블의 i 번째 요소를 포함합니다. | . | 즉, 각 iter들(*매핑리스트시 - 각행들)의 요소를 하나씩 빼와서 튜플형태로 반환한다. i번째 튜플은 각 데이터(행)의 i번째열들의 모아아두었다. | 길이가 다르면, 짧은 데이터를 기준으로 끝난다. | 원래 집은 **zip으로 튜플들을 반환한다. 꼭 튜플 리스트가 아니더라도 2개의 짝을 이룬 튜플요소들이 반환되면 dict로 반환 가능하다. for문에서는 zip이 반환하는 tuple을 언패킹하는 것일 뿐 | . | . print(mylist) #[[*1*, 2, 3], # [*4*, 5, 6], # [*7*, 8, 9]] zip(*mylist) . [[1, 2, 3], [4, 5, 6], [7, 8, 9]] . &lt;zip at 0x1ed8c381800&gt; . list(zip(*mylist)) # 각 행마다 같은 열들을 튜플로 묶어서, 마치 대각선으로 transpose된다. . [(1, 4, 7), (2, 5, 8), (3, 6, 9)] . list(map(list, zip(*mylist))) # zip으로 만들어진 transpose 튜플 리스트를 map으로 각 요소 list로 변환한다. . [[1, 4, 7], [2, 5, 8], [3, 6, 9]] . print(&#39;mylist&#39;, mylist) print(&#39;*mylist&#39;, *mylist) # 함수에 튜플이나 리스트를 매핑해주면, 알아서 나눠서 쓴다는 의미다. # 인자로 대입한다면, 콤마로 나눠서 넣어줘야한다. (튜플, 리스트로 인자대입X) list(zip(*mylist)) . mylist [[1, 2, 3], [4, 5, 6], [7, 8, 9]] *mylist [1, 2, 3] [4, 5, 6] [7, 8, 9] . [(1, 4, 7), (2, 5, 8), (3, 6, 9)] . list1 = [1, 2, 3, 4, 5] list2 = [100, 120, 30, 300] list3 = [392, 2, 33] answer = [] for number1, number2, number3 in zip(list1, list2, list3): print(number1 + number2 + number3) . 493 124 66 . # 짝을 이룬 튜플리스트는 dict로 변환가능하다! animals = [&#39;cat&#39;, &#39;dog&#39;, &#39;lion&#39;] sounds = [&#39;meow&#39;, &#39;woof&#39;, &#39;roar&#39;] # print(list(zip(animals, sounds))) dict(zip(animals, sounds)) . [(&#39;cat&#39;, &#39;meow&#39;), (&#39;dog&#39;, &#39;woof&#39;), (&#39;lion&#39;, &#39;roar&#39;)] . {&#39;cat&#39;: &#39;meow&#39;, &#39;dog&#39;: &#39;woof&#39;, &#39;lion&#39;: &#39;roar&#39;} . (&#52428;) i&#48264;&#51704; &#50896;&#49548;&#50752; i+1&#48264;&#51704; &#50896;&#49548; - zip . 숫자를 담은 리스트 mylist가 solution 함수의 파라미터로 주어집니다. solution 함수가 mylist의 i번째 원소와 i+1번째 원소의 차를 담은 일차원 리스트에 차례로 담아 리턴하도록 코드를 작성해주세요. 단, 마지막에 있는 원소는 (마지막+1)번째의 원소와의 차를 구할 수 없으니, 이 값은 구하지 않습니다. 제한 조건 mylist의 길이는 1 이상 100 이하인 자연수입니다. mylist의 원소는 1 이상 100 이하인 자연수입니다. 예시 mylist output [83, 48, 13, 4, 71, 11] [35, 35, 9, 67, 60] 설명: 83과 48의 차는 35입니다. 48과 13의 차는 35입니다. 13과 4의 차는 9입니다. 4와 71의 차는 67입니다. 71과 11의 차는 60입니다. 따라서 [35, 35, 9, 67, 60]를 리턴합니다. . &#54400;&#51060; . def solution(mylist): return [abs(mylist[i] - mylist[i+1]) for i in range(len(mylist)-1)] . &#51221;&#45813; &#48143; &#45712;&#45184;&#51216; (zip( list, list[1:]) -&gt; &#51064;&#45937;&#49905; i&#50752; i+1&#51032; value&#47484; &#46041;&#49884;&#51217;&#44540; ) . 원래는 for i in n-1까지만 돌기 -&gt; [i], [i+1] | zip( list, 1개 모자란 list[1:] ) -&gt; 2개 요소 value 바로 접근 zip은 짧은 것 까지니까 자동으로 (0,1) &gt; (n-1,n) (n, ) | . | def solution(mylist): answer = [] for number1, number2 in zip(mylist, mylist[1:]): answer.append(abs(number1 - number2)) return answer . &#47784;&#46304; &#47716;&#48260;&#51032; type &#48320;&#54872;&#54616;&#44592; . 문제 설명 문자열 리스트 mylist를 입력받아, 이 리스트를 정수형 리스트로 바꾼 값을 리턴하는 함수, solution을 만들어주세요. 예를 들어 mylist가 [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] 인 경우, solution 함수는 [1, 100, 33] 을 리턴하면 됩니다. 제한조건 mylist의 길이는 100 이하인 자연수입니다. mylist의 원소는 10진수 숫자로 표현할 수 있는 문자열입니다. 즉, &#39;as2&#39; 와 같은 문자열은 들어있지 않습니다. 예시 input output [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] [1, 100, 33] . def solution(mylist): return [ int(x) for x in mylist ] . &#45712;&#45184;&#51216;(map -&gt; &#54632;&#49688;&#47484; &#51064;&#51088;&#47196; or lambda ) . list comp도 되지만, list(map(각 요소에 적용함수, 데이터)) 로 데이터 변형 가능 map( 내장함수 or 실행부없는 함수 or lambda, 데이터) | . | . list1 = [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] list2 = list(map(len, list1)) list2 . [1, 3, 2] . map &#54632;&#49688; &#51025;&#50857;&#54616;&#44592; . 문제 설명 정수를 담은 이차원 리스트, mylist 가 solution 함수의 파라미터로 주어집니다. solution 함수가 mylist 각 원소의 길이를 담은 리스트를 리턴하도록 빈칸을 완성해보세요. hint) 이전 강의에서 배운 map 함수를 활용해보세요 제한 조건 mylist의 길이는 100 이하인 자연수입니다. mylist 각 원소의 길이는 100 이하인 자연수입니다. 예시 input output [[1], [2]] [1, 1] [[1, 2], [3, 4], [5]] [2, 2, 1] . def solution(mylist): answer = list(map(len, mylist)) return answer . Sequence Types &#45796;&#47336;&#44592; (2) . sequence &#47716;&#48260;&#47484; &#54616;&#45208;&#47196; &#51060;&#50612;&#48537;&#51060;&#44592; - join . 문자열 리스트 mylist를 입력받아, 이 리스트의 원소를 모두 이어붙인 문자열을 리턴하는 함수, solution을 만들어주세요. 예를 들어 mylist가 [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] 인 경우, solution 함수는 &#39;110033&#39;을 리턴하면 됩니다. 제한 조건 mylist의 길이는 100 이하인 자연수입니다. mylist의 원소의 길이는 100 이하인 자연수입니다. . my_list = [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] answer = &#39;&#39; for value in my_list: answer += value . my_list = [&#39;1&#39;, &#39;100&#39;, &#39;33&#39;] answer = &#39;&#39;.join(my_list) . &#45712;&#45184;&#51216;( &#39;&#39;.join(sequence) &#44284; &#48712;&#47928;&#51088;&#50676; +=&#45572;&#51201;&#54633; append ) . 빈_문자열 = &#39;&#39; for in 빈문자열 += string(빈 문자열의 누적합 append) -&gt; python join | . &#49340;&#44033;&#54805; &#48324;&#52237;&#44592; - sequence&#51032; *&#50672;&#49328; . 문제 설명 이 문제에는 표준 입력으로 정수 n이 주어집니다. 별(*) 문자를 이용해 높이가 n인 삼각형을 출력해보세요. 제한 조건 n은 100 이하인 자연수입니다. 예시 입력 3 출력 * ** *** . n = int(input().strip()) for i in range(1,n+1): print((&#39;*&#39;*i).ljust(n)) . 5 * ** *** **** ***** . n = int(input().strip()) for i in range(1,n+1): print((&#39;*&#39;*i).center(n)) . 10 * ** *** **** ***** ****** ******* ******** ********* ********** . &#54400;&#51060; . 이번 강의에서는 곱셈 연산 *를 통해 문자열을 반복하는 방법을 배웁니다. | . 예시) . &#39;abc&#39;, &#39;abcabc&#39;, &#39;abcabcabc&#39;, &#39;abcabcabcabc ...&#39; 과 같이 . &#39;abc&#39;가 n번 반복되는 문자열 만들기 (my) 일정길이 문자열의 누적합 반복 -&gt; *) | . | [123, 456, 123, 456, 123, ...] 과같이 123, 456이 n번 반복되는 리스트 만들기 (my) 리스트 안에 요소들전체 의 append 반복 -&gt; *) | . | . answer = &#39;&#39; n = 5 for _ in range(n): answer += &#39;abc&#39; print(answer) . abcabcabcabcabc . # - sequence라 * 연산을 희한하게 한다. answer = &#39;abc&#39; * n answer . &#39;abcabcabcabcabc&#39; . n = 3 answer= [123, 456] * n print(answer) . [123, 456, 123, 456, 123, 456] . answer[3]=3 answer . [123, 456, 123, 3, 123, 456] . &#45712;&#45184;&#51216; (sequence * -&gt; string*, list*) . 문자열 * n : 문자열을 누적합해서 += 한 것처럼 반복된다. | list * n : 기존요소들전체 append | . Itertools / Collections &#47784;&#46280; (4) . (&#52428;) &#44273;&#51665;&#54633;(Cartesian product) &#44396;&#54616;&#44592; - product . 이번 강의에서는 iterable으로 곱집합을 구하는 방법을 알아봅니다. | 예시) 두 스트링 &#39;ABCD&#39;, &#39;xy&#39; 의 곱집합은 Ax Ay Bx By Cx Cy Dx Dy 입니다. | . iterable1 = &#39;ABCD&#39; iterable2 = &#39;xy&#39; iterable3 = &#39;1234&#39; for value1 in iterable1: for value2 in iterable2: for value3 in iterable3: print(value1, value2, value3) . A x 1 A x 2 A x 3 A x 4 A y 1 A y 2 A y 3 A y 4 B x 1 B x 2 B x 3 B x 4 B y 1 B y 2 B y 3 B y 4 C x 1 C x 2 C x 3 C x 4 C y 1 C y 2 C y 3 C y 4 D x 1 D x 2 D x 3 D x 4 D y 1 D y 2 D y 3 D y 4 . # itertools.product를 이용하면, for 문을 사용하지 않고도 곱집합을 구할 수 있습니다. import itertools iterable1 = &#39;ABCD&#39; iterable2 = &#39;xy&#39; iterable3 = &#39;1234&#39; print(list(itertools.product(iterable1, iterable2, iterable3))) . [(&#39;A&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;A&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;A&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;A&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;A&#39;, &#39;y&#39;, &#39;4&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;B&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;B&#39;, &#39;y&#39;, &#39;4&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;C&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;C&#39;, &#39;y&#39;, &#39;4&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;1&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;2&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;3&#39;), (&#39;D&#39;, &#39;x&#39;, &#39;4&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;1&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;2&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;3&#39;), (&#39;D&#39;, &#39;y&#39;, &#39;4&#39;)] . itertools.product(iterable1, iterable2, iterable3) . &lt;itertools.product at 0x1ed8c4750c0&gt; . import itertools iter1 = list(&#39;ABCD&#39;) iter2 = &#39;조재성 조재경 조아라&#39;.split(&#39; &#39;) iter3 = &#39;1234&#39; print(itertools.product(iter1)) # 1개의 iter도 받으며, list()로 변환해야 보인다. print(list(itertools.product(iter1))) # 1개의 iter도 받으며, list()로 변환해야 보인다. print(list(itertools.product(iter1, iter2))) # 2개의 iterable객체를 넣은 순간부터, 곱집합 튜플들의 리스트가 나온다. # 2중 for문을 도는 효과다. [ a + b + c for a,b,c in itertools.product(iter1, iter2, iter3)][:5] . &lt;itertools.product object at 0x000001ED8C58A940&gt; [(&#39;A&#39;,), (&#39;B&#39;,), (&#39;C&#39;,), (&#39;D&#39;,)] [(&#39;A&#39;, &#39;조재성&#39;), (&#39;A&#39;, &#39;조재경&#39;), (&#39;A&#39;, &#39;조아라&#39;), (&#39;B&#39;, &#39;조재성&#39;), (&#39;B&#39;, &#39;조재경&#39;), (&#39;B&#39;, &#39;조아라&#39;), (&#39;C&#39;, &#39;조재성&#39;), (&#39;C&#39;, &#39;조재경&#39;), (&#39;C&#39;, &#39;조아라&#39;), (&#39;D&#39;, &#39;조재성&#39;), (&#39;D&#39;, &#39;조재경&#39;), (&#39;D&#39;, &#39;조아라&#39;)] . [&#39;A조재성1&#39;, &#39;A조재성2&#39;, &#39;A조재성3&#39;, &#39;A조재성4&#39;, &#39;A조재경1&#39;] . &#45712;&#45184;&#51216;( itertools.product(iter1, 2, 3) -&gt; &#51473;&#52393;for &#48152;&#48373;&#51012; &#51228;&#44144; + &#49692;&#49436;&#45824;&#44032; &#51221;&#54644;&#51652; &#51312;&#54633;&#51060;&#45796;.) . itertools.product의 결과물은 list()를 씌워야 튜플 리스트로 들어온다. 1개의iter를 넣어도 (a, ) (b, )의 튜플형태로 받는다. | . | zip은 i, i+1, 같은 위상의 iter들을 동시에 받거나 *2차원리스트 등을 받아서 -&gt; 1차원으로 동시에 처리 itertools.product는 for iter1, for iter2처럼, 누적해서 곱집합을 처리한다. | . | 문자열도 iter로 인식하여 한 문자씩 돌아간다. | . (&#52428;) 2&#52264;&#50896; &#47532;&#49828;&#53944;&#47484; 1&#52264;&#50896; &#47532;&#49828;&#53944;&#47196; &#47564;&#46308;&#44592; - from_iterable . &#45236;&#54400;&#51060;(no pythonic) . def solution(mylist): answer = [] for list_ in mylist: for li in list_: answer.append(li) return answer . my_list = [[1, 2], [3, 4], [5, 6]] [ li for list_ in my_list for li in list_ ] . [1, 2, 3, 4, 5, 6] . &#51221;&#45813; . # 빈리스트[]에 +로 &lt;&lt;괄호떼고&gt;&gt;누적합으로 이어붙이기 . my_list = [[1, 2], [3, 4], [5, 6]] answer = [] for element in my_list: answer += element answer . [1, 2, 3, 4, 5, 6] . sum(my_list, []) . [1, 2, 3, 4, 5, 6] . print(itertools.chain.from_iterable( my_list ) ) list(itertools.chain.from_iterable( my_list ) ) . &lt;itertools.chain object at 0x000001ED8C79CE20&gt; . [1, 2, 3, 4, 5, 6] . # itertools.chain()은 여러 1차 iterable(1글자씩조합-문자열 or list 등)을 분해해서 # -&gt; 통합한 1차 iterable을 만든다. list(itertools.chain(&#39;ABC&#39;, [&#39;abc&#39;,2,3], &#39;F&#39;)) . [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;abc&#39;, 2, 3, &#39;F&#39;] . list(itertools.chain(my_list)) list(itertools.chain(*my_list)) . [1, 2, 3, 4, 5, 6] . 파이썬 * 의 사용 (https://mingrammer.com/understanding-the-asterisk-of-python/) 곱셈 및 거듭제곱 연산으로 사용할 때 | 리스트형 컨테이너 타입의 데이터를 반복 확장하고자 할 때 | 가변인자 (Variadic Arguments)를 사용하고자 할 때 -&gt; 인자시 패킹(내부에서는 *떼고 묶어서 써줘) | 컨테이너 타입의 데이터를 Unpacking 할 때 -&gt; 사용시언패킹(알아서 쪼개줘) | . | . from functools import reduce primes = [2, 3, 5, 7, 11, 13] def product(*numbers): p = reduce(lambda x, y: x * y, numbers) return p product(*primes) # product() 함수가 &lt;이미 내부에서&gt; 가변인자를 받고 있기 때문에, # 실제 입력시에는 콤마로 언패킹상태로 리스트의 데이터를 모두 unpacking하여 함수에 전달해야한다. # -&gt; 인자가 패킹하고있다면, 실제 대입은 콤마, , ,로 나눠서 주던지 *iterable로 알아서 처리하라고 넘겨주면 된다. # 30030 product(primes) # XXXXXXXXXX -&gt; 콤마로 줘야할 곳을 list로 주고 있다. *list로 하면 콤마로 알아서 입력해줘다. # [2, 3, 5, 7, 11, 13] . [2, 3, 5, 7, 11, 13] . list(itertools.chain.from_iterable( my_list )) . [1, 2, 3, 4, 5, 6] . from functools import reduce reduce(lambda x, y: x+y, my_list) from operator import add reduce(add, my_list) . [1, 2, 3, 4, 5, 6] . &#45712;&#45184;&#51216;( 2&#52264;&#50896; : [ ] for += &#44292;&#46524;&#51060;&#50612;&#48537;&#51060;&#44592; / sum( , start =[ ]) / &#54620;&#44732;&#54400; : itertools.chain(*)&#44284; &#51088;&#46041; 2&#44732;&#54400;: chain.from_iterable() / reduce(lambda x,y:x(list)+(new_list), &lt;--2&#52264;&#50896;&#47532;&#49828;&#53944;) . 가장 단순하게 2중 for문 or 2중 list comp로 element까지 가는 것 | 비 파이썬이라도 빈_list[ ]에 for문 1개의 list element에서 append가 아닌 빈_list += 괄호떼고 이어붙이기 | 내장sum(iter)함수에 , start=값을 default 0이 아닌 빈 []에다가 iter각 요소(2차원-&gt;1차원 리스트들)누적되도록 ! sum(iter , start = [] ) | itertools.chain( 1차원or문자열 iterable1 , iter2, ... ) -&gt; 문자열은 1개씩 풀어서, list는 element단위로 풀어서 1차원 iterable로 통합 itertools.chain()은 여러 1차 iterable들을 각각 분해하여 각각 한꺼풀만 벗겨, 통합한 1차 iterable을 만든다. | 2차원을 넣으면 그대로 2차원 반환됨. 한 꺼풀만 벗겨서 다시 통합하므로 -&gt; chain(*2차원)으로 사용시언패킹 시켜주자 | . | %timeit 결과를 보면 sum()함수만 끔찍하게 느리고 나머지 셋은 고만고만함을 알 수 있다. 성능과 가독성 중 무엇을 중시하냐의 차이지만 개인적으로 itertools.chain() 자체도 가독성이 나쁘다고 볼 수 없기에 sum()보다는 chain()을 쓰지 않을까 싶다. | . reduce도 각 데이터 요소들이 와서 연산하는데 lambda로 +연산 or operator.add를 사용해서 list들이 += 누적합이 되도록 해주면 된다. | from itertools import permutations sorted(list(permutations([2, 1,3], 2))) . [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] . (&#52428;) &#49692;&#50676;&#44284; &#51312;&#54633; - combinations, permutations . 문제 설명 숫자를 담은 일차원 리스트, mylist에 대해 mylist의 원소로 이루어진 모든 순열을 사전순으로 리턴하는 함수 solution을 완성해주세요. 제한 조건 mylist 의 길이는 1 이상 100 이하인 자연수입니다. 예시 mylist output [2, 1] [[1, 2], [2, 1]] [1, 2, 3] [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] . from itertools import permutations sorted(list(permutations([2, 1,3],2))) . [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] . &#54056;&#53412;&#51648; &#50630;&#51060; &#49692;&#50676; &#44396;&#54788;( &#54532;&#47196;&#44536;&#47000;&#47672;&#49828; while. &#50612;&#47140;&#50880;) . # # - 자기자신의 index와 value가 같아지는 순간까지만 반복되다가, 다음 index로 넘어가서 반복된다. # # - index가 더크면, 값+1 index 초기화후 # # - 값이 더크거나 같으면, &lt;인덱스+1&gt; 값 초기화 # # my) 값을 인덱스랑 같아질때까지 늘려주는데, 값 증가시 그때마다 i=0부터 시작.. -&gt; 같아지면 index+1 값은 0 # # my) index가 n-1까지 = arr갯수까지만 시행. # # - 그럼, 0` [0`,0] -&gt; `1 [0,`0] -&gt; `0 [`0,1] -&gt; `1 [0, `1] -&gt; 2 [0, 0] -&gt; 조건위배 while중지 # def permute_first(arr): # result = [arr[:]] # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c, arr, result) # # 1. i번째 데이터가 자기 순서(i)보다 값이 작다? 1증가시키고, 처음부터 돌려라. # if c[i] &lt; i : # c[i] +=1 # 값을 +1 # i = 0 # index를 0부터 다시 시작. # # 2. i번째 데이터가 자기 순서(i)보다 크거나 같다? 값을 초기화시키고, 다음 index순서로 넘어가라 # else: # c[i] = 0 # i+=1 # permute_first([0,0]) . # # my) 값을 인덱스랑 같아질때까지 늘려주는데, 값 증가시 그때마다 i=0부터 시작.. -&gt; 같아지면 index+1 값은 0 # # my) index가 n-1까지 = arr갯수까지만 시행. # # - 그럼, 0` [0`,0] -&gt; `1 [0,`0] -&gt; `0 [`0,1] -&gt; `1 [0, `1] -&gt; 2 [0, 0] -&gt; 조건위배 while중지 # # 3. 인덱스가 짝수면, arr[0]번째 값과 해당 index값 arr[i] swap한다. # def permute_two(arr): # result = [arr[:]] # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c[i], c, arr) # if c[i] &lt; i : # # 3. 인덱스가 짝수면, 원본 0번째 값 현재(짝수번째) 값을 교환. # if i % 2 ==0: # arr[0], arr[i] = arr[i], arr[0] # c[i] +=1 # i = 0 # else: # c[i] = 0 # i+=1 # permute_two([0,1,4]) . # result = [arr[:]] # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c[i], c, arr) # if c[i] &lt; i : # # 3. 인덱스가 짝수면, 0번째 값과, 짝수번째 값을 교환. # if i % 2 ==0: # arr[0], arr[i] = arr[i], arr[0] # # 4. 인덱스가 홀수면, [c list의 i번째 값]을 index로 넣고, 데이터 홀수번재 값을 교환 # else: # arr[c[i]], arr[i] = arr[i], arr[c[i]] # c[i] +=1 # i = 0 # else: # c[i] = 0 # i+=1 # permute_three([0,1,4]) . # # - 값이 index랑 같아지는 부분은 횟수를 늘리는 용도일 뿐이라는 말이다. # def permute_four(arr): # result = [arr[:]] # 2차원에 1번째 행을 원본을 넣어놓는다. # c = [0] * len(arr) # i = 0 # while i &lt; len(arr): # print(i, c[i], c, arr) # if c[i] &lt; i : # # 3. 인덱스가 짝수면, 0번째 값과, 짝수번째 값을 교환. # if i % 2 ==0: # arr[0], arr[i] = arr[i], arr[0] # # 4. 인덱스가 홀수면, [c list의 i번째 값]을 index로 넣고, 데이터 홀수번재 값을 교환 # else: # arr[c[i]], arr[i] = arr[i], arr[c[i]] # # 5. arr결과를 result 2차원 리스트(원본을 1행에 가지고 있던 놈)에 append한다. # # - c[i]가 0에서부터 불들어오는 순간부터 교환후 들어올리네. # result.append(arr[:]) # c[i] +=1 # i = 0 # else: # c[i] = 0 # i+=1 # # 6. result 2차원 리스트를 반환한다. # return result # permute_four([1,2,3]) . def permute(arr): result = [arr[:]] c = [0] * len(arr) i = 0 while i &lt; len(arr): if c[i] &lt; i: if i % 2 == 0: arr[0], arr[i] = arr[i], arr[0] else: arr[c[i]], arr[i] = arr[i], arr[c[i]] result.append(arr[:]) c[i] += 1 i = 0 else: c[i] = 0 i += 1 return result . &#48264;&#50808;) python&#51004;&#47196;&#49692;&#50676; &#44396;&#54788;1 (&#48660;&#47196;&#44536;1, &#51116;&#44480;+&#48520;&#53356;&#44256;&#45124;&#44592; ) . https://shoark7.github.io/programming/algorithm/Permutations-and-Combinations | https://programmers.co.kr/learn/courses/4008/lessons/12836 | . arr = [0,1,2,3] r = 2 # def permutation(arr, r): # 1. used(list) : 해당index의 원소 사용 여부 : arr의 길이만큼 빈 [0] * n를 만들자. # - used(list)에는 해당index의 값이 사용됬는지 안됬는지 체크여부. # - 누적합이 아니라도 여부 등은 0 default에서 1 왔다갔다 하면, if문에 False, True로 걸린다. # used = [0] * len(arr) used = [0 for _ in range(len(arr))] # 2. generate( chosen, used ): 함수로 만들어야 -&gt; 내부에서 같은 로직을 한번 더 호출할 수 있다. # - 일단, 빈 list를 던져주고, 사용여부에 따라 append한 다음, 길이가 원하는 순열길이(r)과 같아졌다면 함수를 끝내는 return해준다. # generate([], used) 형태로 사용된다. def generate(chosen, used): # 2-1) default [] chosen이 원하는 길이를 만족했으면 -&gt; 탈출 -&gt; 그전까지는 내부함수 호출로 반복됨. if len(chosen) == r: print(chosen) # 결과값 저장대신 각각 만들어진 경우를 print한다. return # 2-2) arr길이만큼 반복 -&gt; used의 길이랑 arr이랑 같으며, 같이 움직이니까. # arr와 같은 길이의 used는 arr[i]의 사용여부체크시 used[i]를 사용하는 위에 떠있는 데이터 for i in range(len(arr)): # i번째 원소가 아직 사용이 안됬다? print(&#39;used&#39;, used) if not used[i]: # 사용후 -&gt; 사용표시 1 # - 일단 사용안된 i번째 요소를 chosen에 넣고, 사용했다는 표기를 한다. print(&#39;chosen&#39;, chosen) chosen.append(arr[i]) used[i]=1 # i번재 데이터가 담기고 + 사용되었다는 표시와함께 다시 호출하면 # - 재귀적? 반복적으로... i를 제외하고 사용안된 i를 =1,2,3,4에서부터 찾기..전에... generate(chosen, used) # 내부에서, 길이 못채웠고 &amp; 사용된것 넘어가면서 사용안된 것을 j를 0에서부터 찾는다. # 내부에서, 0은 used[0]이 이미 담겨있으니, 1을 chosen에 넣고, 0,1,을 넣은 상태에다. # 내부에서 또 내부함수가 호출되지만, 초기검사에서 r==2를 만족시켜 반환되며 # 내부j에서는, used[j] = 0을 넣고, 안썼다고 표시 + 데이터도 뺀 체로, j=1이 된다. # i=0는 고정상태에서 j=0을 쓴 뒤, j=1을 쓰고, r==2가 만족되면 j=2로 간다... # i 고정 -&gt; j를 돌면서 -&gt; k에서 갯수가 맞추다가,, j를 다돌면, i가 도나보다... used[i] = 0 chosen.pop() # 재귀를 써서 구하는데 # base case가 chosen == r(input)을 맞추면 끝난다... # 이 함수의 핵심이다. 모든 순열은 arr 의 0부터 i-1 번째 값으로 시작하기에 for 문으로 다 만들어야 한다. # recusive case는 nPr = 시작자리에 arr[i] 가 들어갔다고 치면(for를 n번) = N * n-1Pr 이다. # permutation([0,1,2,3], 2) = # ([0],permutation([1,2,3], 1)) + ([1],permutation([0,2,3], 1)) + ([2],permutation([0,1,3], 1))+ ([3],permutation([0,1,2], 1)) # combination([0,1,2,3], 2) = ([0],combination([1,2,3], 1)) + ([1],combination([2,3], 1)) + ([2],combination([3], 1))) # https://cotak.tistory.com/70 . used [0, 0, 0, 0] chosen [] used [1, 0, 0, 0] used [1, 0, 0, 0] chosen [0] [0, 1] used [1, 0, 0, 0] chosen [0] [0, 2] used [1, 0, 0, 0] chosen [0] [0, 3] used [0, 0, 0, 0] chosen [] used [0, 1, 0, 0] chosen [1] [1, 0] used [0, 1, 0, 0] used [0, 1, 0, 0] chosen [1] [1, 2] used [0, 1, 0, 0] chosen [1] [1, 3] used [0, 0, 0, 0] chosen [] used [0, 0, 1, 0] chosen [2] [2, 0] used [0, 0, 1, 0] chosen [2] [2, 1] used [0, 0, 1, 0] used [0, 0, 1, 0] chosen [2] [2, 3] used [0, 0, 0, 0] chosen [] used [0, 0, 0, 1] chosen [3] [3, 0] used [0, 0, 0, 1] chosen [3] [3, 1] used [0, 0, 0, 1] chosen [3] [3, 2] used [0, 0, 0, 1] . def permutation(arr, r): # 1. arr = sorted(arr) # 해당원소가 사용되고 있는 상태인지 arr와 같은길이의 0과 1로 구성될 list 생성 # - 재귀로 내부에서 함수가 또 불려질텐데, 내부함수가 밖에서 어떤 원소가 고정된 상탠지 알려주기 위해 # - 함수 입장에서 전역변수로 만들어준다. used = [0 for _ in range(len(arr))] def generate(chosen, used): # 2.재귀에서 탈출부이다. chosen이 원하는 갯수 r개가 되면 base case로 print하고 해당함수는 끝난다. # - 내부함수들이 끝나는 것이기에... 어느것이 끝나는지는... if len(chosen) == r: print(chosen) return # 3.i번째를 고정시킨 상태에서, # - i에 불이 안들어와있는 상태다 = 가장 바깥은 필요없지만.. 내부함수들은 바깥에서 고정된 것이기에 피해야한다. for i in range(len(arr)): # 사용했다는 불이 안들어온 상태다. 내부함수가 인식하도록, 내부함수호출직전에 켜주고, 직후에 꺼준다. # 맨바깥은 for로 알아서 i가 돌아가고 있기 때문에 노상관. 내부에서 i불들어온 것 제끼고 r-1개 맞추라는 신호임. if not used[i]: # 4. 내부함수가 i원소를 채운 상태로 재귀호출하도록 넣어주고, 불을 켜준다. chosen.append(arr[i]) used[i] = 1 generate(chosen, used) # 재귀상태로, 1개를 채운상태에서 r-1를 채우려고 호출된다. # 5. i고정상태에서 r-1개를 다채워 r개를 완성했다는 뜻이니, 불을 꺼주고, 빼준다. used[i] = 0 chosen.pop() # 6. 자동으로 다음 i가 고정되서 시작한다. generate([], used) permutation(&#39;ABCD&#39;, 2) . [&#39;A&#39;, &#39;B&#39;] [&#39;A&#39;, &#39;C&#39;] [&#39;A&#39;, &#39;D&#39;] [&#39;B&#39;, &#39;A&#39;] [&#39;B&#39;, &#39;C&#39;] [&#39;B&#39;, &#39;D&#39;] [&#39;C&#39;, &#39;A&#39;] [&#39;C&#39;, &#39;B&#39;] [&#39;C&#39;, &#39;D&#39;] [&#39;D&#39;, &#39;A&#39;] [&#39;D&#39;, &#39;B&#39;] [&#39;D&#39;, &#39;C&#39;] . &#48264;&#50808;2 ) python&#51004;&#47196;&#49692;&#50676; &#44396;&#54788;2 (&#48660;&#47196;&#44536;2, full &#51116;&#44480;&#54632;&#49688;&#47196; &#52376;&#47532;. &#45796;&#49884; &#48380; &#44163;) . # 출처: https://cotak.tistory.com/70 [Pool&#39;s Taek] def gen_permutations(arr, n): result = [] if n == 0: return [[]] for i, elem in enumerate(arr): # i번재 원소만 빼고, 대신 n-1개만 나머지로 순열 부분문제 정복상태 -&gt; 각 요소들P for P in gen_permutations(arr[:i] + arr[i+1:], n-1): # i번째 원소를 맨마지막에 extend해서 붙임. # [[2]] # [[1, 2]] # [[0, 1, 2]] # [[0, 1, 2]] # 순열도 제일 마지막에 첨가하면, 조합처럼 n-1개 완성 + 1개요소(n가지)가 된다? result += [[elem]+P] print(result) break return result arr = [0, 1, 2, 3, 4, 5] print(gen_permutations(arr, 3)) . [[2]] [[1, 2]] [[0, 1, 2]] [[0, 1, 2]] . &#51221;&#45813; . # itertools.permutation를 이용하면, for문을 사용하지 않고도 순열을 구할 수 있습니다. import itertools # pool = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] pool = &#39;ABC&#39; print(list(map(&#39;&#39;.join, itertools.permutations(pool)))) # 3개의 원소로 수열 만들기 print(list(map(&#39;&#39;.join, itertools.permutations(pool, 2)))) # 2개의 원소로 수열 만들기 . [&#39;ABC&#39;, &#39;ACB&#39;, &#39;BAC&#39;, &#39;BCA&#39;, &#39;CAB&#39;, &#39;CBA&#39;] [&#39;AB&#39;, &#39;AC&#39;, &#39;BA&#39;, &#39;BC&#39;, &#39;CA&#39;, &#39;CB&#39;] . &#45712;&#45184;&#51216;(itertools.permutations , combinations) . 문자열로 1글자씩으로 구성된 iter라 순열 또는 조합을 구할 수 있다. 리스트는 튜플 조합 리스트로 / 문자열을 문자열그대로의 리스트로 반환됨. | . | 원하는 구성원소갯수를 지정할 수 있다. | . (&#52428;)&#44032;&#51109; &#47566;&#51060; &#46321;&#51109;&#54616;&#45716; &#50508;&#54028;&#48307; &#52286;&#44592; - Counter . 문제 설명 이 문제에는 표준 입력으로 문자열, mystr이 주어집니다. mystr에서 가장 많이 등장하는 알파벳만을 사전 순으로 출력하는 코드를 작성해주세요. 제한 조건 mystr의 원소는 알파벳 소문자로만 주어집니다. mystr의 길이는 1 이상 100 이하입니다. 예시 input output &#39;aab&#39; &#39;a&#39; &#39;dfdefdgf&#39; &#39;df&#39; &#39;bbaa&#39; &#39;ab&#39; . &#45236;&#54400;&#51060; . dict에 단어마다 count 저장함 | dict를 sorted( , reverse=True, key=lambda x:x[1])로 밸류순으로 역순으로 정렬 -&gt; 가장 첫밸류값이 가장 최대값 | 첫, 두번째 밸류 동점일 수 있으니, value만 뽑은 뒤.. dict.items()를 돌면서 value가 같은 것을 출력함. | . my_str = input().strip() counter_dict = {} for key in my_str: counter_dict.setdefault(key, 0) counter_dict[key]+=1 max_value = sorted(counter_dict.items(), key=lambda x:x[1],reverse=True)[0][1] answer_list = [] for k,v in counter_dict.items(): if v == max_value: answer_list.append(k) print(&#39;&#39;.join(sorted(answer_list))) . aab a . &#51221;&#45813; . # 다른 언어에서는..(또는 이 기능을 모르시는 분은) 보통 사람들은 반복문을 이용해 수를 셉니다. my_list = [1, 2, 3, 4, 5, 6, 7, 8, 7, 9, 1, 2, 3, 3, 5, 2, 6, 8, 9, 0, 1, 1, 4, 7, 0] answer = {} for number in my_list: try: answer[number] += 1 except KeyError: answer[number] = 1 print(answer[1]) # = 4 print(answer[3]) # = 3 print(answer[100]) # = raise KeyError . import collections my_str = input().strip() answer = collections.Counter(my_str) print(answer) # dict형태로 출력됨. #Counter객체는 .most_common() 으로 key, count의 튜플리스트가 나옴. answer.most_common() # . asdklfjaskdfekekjek Counter({&#39;k&#39;: 5, &#39;e&#39;: 3, &#39;a&#39;: 2, &#39;s&#39;: 2, &#39;d&#39;: 2, &#39;f&#39;: 2, &#39;j&#39;: 2, &#39;l&#39;: 1}) . [(&#39;k&#39;, 5), (&#39;e&#39;, 3), (&#39;a&#39;, 2), (&#39;s&#39;, 2), (&#39;d&#39;, 2), (&#39;f&#39;, 2), (&#39;j&#39;, 2), (&#39;l&#39;, 1)] . dict_ = {&#39;k&#39;: 5, &#39;e&#39;: 3, &#39;a&#39;: 2, &#39;s&#39;: 2, &#39;d&#39;: 2, &#39;f&#39;: 2, &#39;j&#39;: 2, &#39;l&#39;: 1} dict_.values() # dict_.keys(), dict_.items() max(answer.values()) . 5 . # -&gt; values로 max값 바로 찾을 수 있다. # -&gt; max값을 알 때, for문을 돌면서, key값들을 누적할 수 있다? # -&gt; max값이 여러개일 수 있으니, 미리구한 최대값 == count 하면서 돌아야한다. my_list = input() max_count = max(collections.Counter(my_list).values()) [ word for word, count in collections.Counter(my_list).items() if count == max_count] . aaadddwqierie . [&#39;a&#39;, &#39;d&#39;] . &#45712;&#45184;&#51216; ( collections.Counter - dict + .most_common() ) . 비 파이썬이라도 dict에 저장하는 것은 똑같았다. | collections.Counter() -&gt; dict와 유사하니, Counter.values()로 max()를 구하고 | list comp로 Counter.items()를 k,v를 받아서 필터링하자 | . | 빈도순으로 튜플리스트를 반환하는 것은 .most_common()이다. | &#44592;&#53440; (7) . for &#47928;&#44284; if&#47928;&#51012; &#54620;&#48264;&#50640; - List comprehension&#51032; if &#47928; . 문제 설명 정수를 담은 리스트 mylist를 입력받아, 이 리스트의 원소 중 짝수인 값만을 제곱해 담은 새 리스트를 리턴하는 solution함수를 완성해주세요. 예를 들어, [3, 2, 6, 7]이 주어진 경우 3은 홀수이므로 무시합니다. 2는 짝수이므로 제곱합니다. 6은 짝수이므로 제곱합니다. 7은 홀수이므로 무시합니다. 따라서 2의 제곱과 6의 제곱을 담은 리스트인 [4, 36]을 리턴해야합니다. 제한 조건 mylist는 길이가 100이하인 배열입니다. mylist의 원소는 1이상 100 이하인 정수입니다. . mylist = [3, 2, 6, 7] answer = [number**2 for number in mylist if number % 2 == 0] answer . [4, 36] . &#45712;&#45184;&#51216;( X ) . mylist = [3, 2, 6, 7] answer = [] for number in mylist: if number % 2 == 0: answer.append(number**2) # 들여쓰기를 두 번 함 # 파이썬의 list comprehension을 사용하면 한 줄 안에 for 문과 if 문을 한 번에 처리할 수 있습니다. mylist = [3, 2, 6, 7] answer = [number**2 for number in mylist if number % 2 == 0] . (&#52428;) flag&#48320;&#49688; &#45824;&#49888; for-else &#49324;&#50857;&#54616;&#44592; . 문제 설명 본 문제에서는 자연수 5개가 주어집니다. 숫자를 차례로 곱해 나온 수가 제곱수가 되면 found를 출력하고 모든 수를 곱해도 제곱수가 나오지 않았다면 not found를 출력하는 코드를 작성해주세요. 예시 1 입력 2 4 2 5 1 출력 found 설명 수를 곱해나가면 2, 8, 16, 80, 80 이 나옵니다. 16은 4를 제곱해 나온 수이므로 이 수는 제곱수입니다. 따라서 found를 출력합니다. 예시 2 입력 5 1 2 3 1 출력 not found 설명 수를 곱해나가면 5, 5, 10, 30, 30 이 나옵니다. 이중 어떤 수도 제곱 수가 아니므로 not found를 출력합니다. . data = [ int(input()) for _ in range(5)] import math product = 1 check=False for n in data: product*=n if math.sqrt(product) == int(math.sqrt(product)) : print(&#39;found&#39;) check=True break if check == False: print(&#39;not found&#39;) . 2 4 2 5 1 2 1.4142135623730951 8 2.8284271247461903 16 4.0 found 2 not found . &#51221;&#45813; . # https://harryp.tistory.com/317 [Park&#39;s Life] import math data = [ int(input()) for _ in range(5)] product = 1 # check=False # 1. for내부에 if로 끊김을 나타내는 flag변수를 안쓴다. for n in data: product*=n if math.sqrt(product) == int(math.sqrt(product)) : print(&#39;found&#39;) #check=True break # if check == False: # 2. for가 안끊기고 다 돌았다면, else문 실행시킨다. else: print(&#39;not found&#39;) . 2 4 2 5 1 found . &#45712;&#45184;&#51216;( flag&#48320;&#49688; &#45824;&#49888; for-else&#47928; -&gt; for if &#52286;&#50520;&#51004;&#47732; flag break &#45824;&#49888; for if &#52286;&#50520;&#51004;&#47732;&#52376;&#47532; else&#47803;&#52286;&#50520;&#45796;&#52376;&#47532; + &#51228;&#44273;&#49688; + &#49548;&#49688;&#51216;.0&#51032; int&#54869;&#51064;) . for_if 조건: break -&gt; 만약 다 돌았는데도 if brea에 안걸린 not found == for 다돈 경우 else 조건X시 처리 . 원래는.. for문 내부에서 if 걸렸다? -&gt; break하고 for문 뒤에는 실행 X 를 for문 밖 flag=True/False 변수에 전달해줬다. | 이제는 for문 if 걸려서 flag = True + break -&gt; if flag: 처리는 하지 말자. for문 if 걸려서 break -&gt; 만약 안걸리고 다돌면 처리를 else문에서 | . | . | 제곱수의 판단 : math.sqrt()를 씌웠을 때 int여야한다. . 하지만 sqrt()씌우는 순간 int라도 2.0 3.0 이 되어버린다. | 정수.0의 int 판단방법 int()변환값 == 현재값 ( 전환된 값의 비교로 판단 ) | . | cf) 정수 판단 방법 isinstance( , int) | type( v ) == int | . | . | . &#46160; &#48320;&#49688;&#51032; &#44050; &#48148;&#44984;&#44592; - swap . # 비 파이썬은 덮어쓰기 당할 변수값을 temp에 넣어놓고 덮어쓰기 -&gt; 다른쪽 덮어쓰기 a = 3 b = &#39;abc&#39; temp = a a = b b = temp . 파이썬에서는 다음과 같이 한 줄로 두 값을 바꿔치기할 수 있음. . a = 3 b = &#39;abc&#39; a, b = b, a . (&#52428;) &#51060;&#51652; &#53456;&#49353;&#54616;&#44592; - bisect &#47784;&#46280; . 알고리즘 문제를 풀다 보면 이진 탐색을 써야할 때가 많습니다. 이런 문제를 풀 때마다 이진 탐색 알고리즘을 작성하는 건 비효율적이지요. 이번 시간엔 Python의 이진 탐색 모듈, bisect를 알아봅시다. | . # - while문에 if 탈출(break or def-return)이 없다? -&gt; 다돌고 &lt;조건문 직후 상태&gt;로 빠져나와서 최종 처리한다는 뜻 # ex&gt; while low &lt; high -&gt; low &gt;= high순간에 빠져나옴. 주로 직후인 low==high에서 빠져나와 마지막 처리 def bisect(a, x, lo=0, hi=None): if lo &lt; 0: raise ValueError(&#39;lo must be non-negative&#39;) if hi is None: hi = len(a) while lo &lt; hi: mid = (lo + hi) // 2 if a[mid] &lt; x: lo = mid + 1 else: hi = mid return lo mylist = [1, 2, 3, 7, 9, 11, 33] print(bisect(mylist, 5)) # ??? 없는 것도 나온다? . 3 . # 실제 list index의 +1을 반환하는 것 같다. # ** 해당 숫자 n을 어디에 insert해야하는지의 위치를 보여준다.** # 1) 같은게 있으면? 그 index +1 자리에 넣어라 # 2) 같은게 없으면? 오름차순으로 넣어야할 자리는 여기다. import bisect mylist = [1, 2, 3, 7, 9, 11, 33] print(bisect.bisect(mylist, 9)) # 같은게 4에 있으니 5번째 들어가야한다. print(bisect.bisect(mylist, 33)) # 같은게 6에 있으니 7에 들어가야한다. print(bisect.bisect(mylist, 5)) # 없는데 &lt;&lt;오름차순&gt;&gt; 4-&gt;value 3 뒤의 5자리에 들어가야한다. . 5 7 3 . # index 함수는 이진 탐색이 아닌 선형 탐색 함수입니다. # (물론 주어진 input에 대해서 index 함수를 쓰면 정확한 output 값을 얻을 수 있긴 합니다.) # 이진탐색의 시간복잡도는 O(logN) 이나, # index 함수는 선형탐색을 하므로 시간복잡도가 O(N)이라 시간이 오래 걸립니다. # bisect.bisect(mylist, n)의 n은 mylist에서 찾고자하는 값입니다. # bisect.bisect(mylist, n)이 리턴하는 값, x는 mylist에서 n이 위치한 index의 오른쪽 값을 나타냅니다. # insertion point를 리턴합니다. 즉, 3의 인덱스는 2이므로 이 다음에 있는 insertion point는 2+1 = 3이 되는 것이지요. # 말씀하신대로 bisect는 key 가 없으면 key가 들어갈 위치를 반환합니다. . # - 내뱉은 point가 .. 직전에 같은값이 있어서 그 바로 뒤라면? i-1 반환 # - 내뱉은 point가.. 직전에 같은값은 없으나.. 순서라서 줬다면? 그냥 탐색 실패-&gt; -1반환 import bisect def b_s(ary,key): i= bisect.bisect(ary,key) return i-1 if ary[i-1]==key else -1 . &#45712;&#45184;&#51216;(bisect.bisect( list, value) &gt; return or insert point, &#48148;&#47196;&#50526;&#50640; &#51080;&#44144;&#45208; &#47803;&#52286;&#50520;&#51648;&#47564; &#51221;&#47148;&#49345; &#44536;&#51088;&#47532;) . 정렬된 list라면, 이진탐색을 bisect.bisect로 할 수 있다. return된 값이. 실제 있떤 값이면 i + 1 = return값이다. -&gt; return값 - 1을 하자 | return된 값이. 없으나 정렬상 그자리에 들어가라고 return한 값이다 -&gt; ??? 직전과 값이 같앗 뱉은 건지 확인해야한다. if number == list[return value - 1] -&gt;returnvalue -1 else None.. | . | . | . &#53364;&#47000;&#49828; &#51064;&#49828;&#53556;&#49828; &#52636;&#47141;&#54616;&#44592; - class&#51032; &#51088;&#46041; string casting . 이번 강의에서는 인스턴스 출력 형식을 지정하는 방법을 배워봅시다. . 예) 2차원 평면 위의 점을 나타내는 Coord 클래스의 인스턴스를 (x 값, y 값)으로 출력하기 . class Coord(object): def __init__(self, x, y): self.x, self.y = x, y point = Coord(1, 2) print( &#39;({}, {})&#39;.format(point.x, point.y) ) # 또는 def print_coord(coord): print( &#39;({}, {})&#39;.format(coord.x, coord.y) ) print_coord(point) . # __str__ 메소드를 사용해 class 내부에서 **출력 format**을 지정할 수 있습니다. class Coord(object): def __init__ (self, x, y): self.x, self.y = x, y def __str__ (self): return &#39;({}, {})&#39;.format(self.x, self.y) point = Coord(1, 2) print(point) point . (1, 2) . &lt;__main__.Coord at 0x1ed8d397e80&gt; . &#45712;&#45184;&#51216; ( str&#50724;&#48260;&#46972;&#51060;&#46377; ) . print + interpret에 출력까지 될라면 repr를 오버라이딩한다. | 객체정보를 직접 찍어보지말자! 메소드 정의(비파이썬) 나 메소드 오버라이딩으로 확인하자.! | (&#52428;) &#44032;&#51109; &#53360; &#49688;, inf . 코딩 테스트 문제 등을 풀다 보면, 최솟값을 저장하는 변수에 아주 큰 값을 할당해야 할 때가 있습니다. 이번 시간에는 이때에 사용하기 좋은 inf에 대해 알아봅시다. . 이 기능을 모르시는 분은 본인이 생각하는 임의의 큰 수(99999등)를 할당합니다. . # 비파이썬에서, 최소값을 구할려구 미리 큰값을 넣어올 때, min_val = 99999 min_val &gt; 100000000 # ? . # 파이썬에서, 최소값을 구할려구 미리 큰값을 넣어올 때, # 파이썬이 제공하는 inf 를 사용. inf는 어떤 숫자와 비교해도 무조건 크다고 판정 min_val = float(&#39;inf&#39;) min_val &gt; 10000000000 . inf에는 음수 기호를 붙이는 것도 가능합니다. . max_val = float(&#39;-inf&#39;) . &#45712;&#45184;&#51216; - float(&#39;inf&#39;), float(&#39;-inf&#39;) . 최대값을 찾을 때, 일단 작은값을 변수에 넣어놓고 돈다. 가장 작은 값은 float(&#39;-inf&#39;) / 가장 큰 값은 float(&#39;inf&#39;) 로 초기값을 넣고 해결하자! | . | float(&#39;inf&#39;) . inf . float(&#39;-inf&#39;) . -inf . &#54028;&#51068; &#51077;&#52636;&#47141; &#44036;&#45800;&#54616;&#44172; &#54616;&#44592; - with open as f for line in f.readlines() . 이번 강의에서는 파일 입출력 코드를 간결하게 짜는 법을 알아봅시다. . &#39;myfile.txt&#39;라는 이름의 파일을 읽는 코드를 짜보세요 . # 1. open -&gt; 2. 반복문 while -&gt; 3.line = readlins() + if not line: break + line처리 -&gt; 4. close f = open(&#39;myfile.txt&#39;, &#39;r&#39;) while True: line = f.readline() if not line: break raw = line.split() print(raw) f.close() . FileNotFoundError Traceback (most recent call last) &lt;ipython-input-467-4f9a0ee2adde&gt; in &lt;module&gt; 1 # 비파이썬 2 # 1. open -&gt; 2. 반복문 while -&gt; 3.line = readlins() + if not line: break + line처리 -&gt; 4. close -&gt; 3 f = open(&#39;myfile.txt&#39;, &#39;r&#39;) 4 while True: 5 line = f.readline() FileNotFoundError: [Errno 2] No such file or directory: &#39;myfile.txt&#39; . # with - as 구문을 이용하면 코드를 더 간결하게 짤 수 있습니다. 코드를 아래와 같이 쓰면 다음과 같은 장점이 있습니다. # 1. 파일을 close 하지 않아도 됩니다: with - as 블록이 종료되면 파일이 자동으로 close 됩니다. # 2. readlines가 EOF까지만 읽으므로, while 문 안에서 EOF를 체크할 필요가 없습니다. # my) python은 readlines()가 EOF를 알아서 인식하니 -&gt; 반복문 in 자리에 넣으면 된다. -&gt; EOF 체크 필요없음. with open(&#39;myfile.txt&#39;) as file: for line in file.readlines(): print(line.strip().split(&#39; t&#39;)) . FileNotFoundError Traceback (most recent call last) &lt;ipython-input-468-1cec8ae34904&gt; in &lt;module&gt; 5 6 # my) python은 readlines()가 EOF를 알아서 인식하니 -&gt; 반복문 in 자리에 넣으면 된다. -&gt; EOF 체크 필요없음. -&gt; 7 with open(&#39;myfile.txt&#39;) as file: 8 for line in file.readlines(): 9 print(line.strip().split(&#39; t&#39;)) FileNotFoundError: [Errno 2] No such file or directory: &#39;myfile.txt&#39; . &#45712;&#45184;&#51216; - with as &#50752; python readlines() . with as f -&gt; close 안해도됨 + f.readlines()시 EOF 체크 자동으로 되니 반복문에 바로 삽입 | boj input() 등 f.readlines()와 달리 언제 EOF인지는 모를 땐, try except EOFError로 break해주자. | &#52280;&#44256;) &#51077;&#47141;&#51032; &#45149;(EOF) &#54869;&#51064; by except EOFError: break . f.readlines()는 알아서 EOF(end of file)을 체크하지만, boj등 input()이 언제 EOF인지는 모르니까, try except EOFError로 break해주자. | . | . while 1: try: ins=input() ans = fun(ins) if ans == -1: break; else: print(ans) except EOFError: break .",
            "url": "blog.chojaeseong.com/algorithm/2021/08/11/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_python_pythonic.html",
            "relUrl": "/algorithm/2021/08/11/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_python_pythonic.html",
            "date": " • Aug 11, 2021"
        }
        
    
  
    
        ,"post171": {
            "title": "알고리즘 문제 풀기용 input 코드 모음(python)",
            "content": "&#52280;&#44256; . 블로그 | 그외 백준 공식 레퍼런스 | . input.txt&#47484; &#51060;&#50857;&#54620; local &#54400;&#51060; &#44396;&#51312; . 폴더 input.txt | xxx.py | . | . import sys sys.stdin = open(&quot;./input.txt&quot;, &quot;rt&quot;) # jupyter notebook시 필수 input = sys.stdin.readline # 콘솔에선 미리 안해도되며, 속도향상 필요시만 해준다. / ###################################################### N = int(input()) # print(N) data = list(map(int, input().split())) # print(data) . &#44277;&#48177; &#44592;&#51456; &#45936;&#51060;&#53552; &#51077;&#47141;&#48155;&#44592;(map, int, input.split ) . map객체를 이용해 str -&gt; int 변환했지만, sequence는 아니라 인덱싱을 못한다. a, b = map : 인덱싱은 못해도 할당시 나눠받을 수 있다. | list_ = list(map) : 할당시 나눠받기가 불가능할 정도로 많으면, list()로 sequence로 변환시켜 받아야한다. | . | . # - 1개는 map쓰지말자~! n = int(input().strip()) # 2개 - int a, b= map(int, input().split()) # for문으로 n번 2개씩 n = int(input().strip()) for _ in range(n): a, b= map(int, input().split()) # 3개이상의 - list data = list(map(int, input().split())) # for문으로 n번 3개이상시 n = int(input().strip()) for _ in range(n): data = list(map(int, input().split())) . &#49884;&#44036;&#51012; &#45908; &#48736;&#47476;&#44172; &#45936;&#51060;&#53552; &#51077;&#47141;&#48155;&#44592;(sys &#47784;&#46280;) . sys.stdin.readline() 사용 | 단, 입력 후 엔터가 사용되므로 rstrip() 를 함께 사용 | . import sys str = sys.stdin.readline().rstrip() # 1개 - int import sys n = sys.stdin.readline() # 2개 int import sys N, M = map(int, sys.stdin.readline().split()) # 2차원 리스트 입력 받기 # - 행의 수 N을 입력받고, 각 행의 데이터들을 한번에 받아서 split()해서 열로 들어간다. import sys N = sys.stdin.readline() board = [list(map(int,sys.stdin.readline().split())) for _ in range(N)] . ValueError Traceback (most recent call last) &lt;ipython-input-11-198e9d917b91&gt; in &lt;module&gt; 9 # 2개 int 10 import sys &gt; 11 N, M = map(int, sys.stdin.readline().split()) 12 13 ValueError: not enough values to unpack (expected 2, got 0) . &#44277;&#48177;&#44592;&#51456; &#52636;&#47141;&#49884; *(&#49324;&#50857;&#49884;&#50616;&#54056;&#53433;)&#51004;&#47196; . result = [1, 2, 3] # 기본적인 리스트 출력시 print(result) # [1,2,3] # for loop으로 원소를 하나씩 출력 for i in range(len(result)): print(result[i], end=&#39; &#39;) # 1 2 3 # 리스트의 원소를 언패킹 시켜서 출력 print(*result) # 1 2 3 . [1, 2, 3] 1 2 3 1 2 3 . N x M &#53356;&#44592;&#51032; &#51060;&#52264;&#50896; &#47532;&#49828;&#53944; &#52488;&#44592;&#54868; &#48143; &#51077;&#47141;&#48155;&#44592; . 시뮬레이션 문제에서 주어지는 입력 중 가장 많은 형태의 입력을 list comprehension 으로 받을 수 있다. . n, m = map(int, input().split()) board = [list(map(int, input().split())) for _ in range(n)] visited = [[False]*m for _ in range(n)] print(visited) print(board) # 입력(행 열 -&gt; 열의 갯수만큼 False==0으로 채워진 행x열의 visited 2차원 리스트) # 5 9 # 0 0 0 0 0 0 0 0 0 # 0 0 0 1 1 0 0 0 0 # 0 0 0 1 1 0 1 1 0 # 0 0 1 1 1 1 1 1 0 # 0 0 1 1 1 1 1 0 0 . [[False, False, False, False, False], [False, False, False, False, False], [False, False, False, False, False]] [[3], [3], [3]] . &#51116;&#44480;&#54632;&#49688;&#50640;&#49436; &#53084;&#49828;&#53469; &#51228;&#54620;(&#51116;&#44480;&#54620;&#46020;) &#54400;&#50612;&#51452;&#44592; . import sys; sys.setrecursionlimit(10000) .",
            "url": "blog.chojaeseong.com/algorithm/2021/08/10/boj_input_codes.html",
            "relUrl": "/algorithm/2021/08/10/boj_input_codes.html",
            "date": " • Aug 10, 2021"
        }
        
    
  
    
        ,"post172": {
            "title": "타이타닉 정리",
            "content": "import numpy as np import pandas as pd # %matplotlib nbagg %matplotlib inline import matplotlib.pyplot as plt import matplotlib import seaborn as sns sns.set(font_scale=1.5) sns.set_style(&#39;whitegrid&#39;) #whitegrid sns.set_palette(&#39;muted&#39;) # 한글사용가능하게하기 from matplotlib import font_manager font_name = font_manager.FontProperties(fname=&#39;C:/Windows/Fonts/malgun.ttf&#39;).get_name() matplotlib.rc(&#39;font&#39;, family=font_name) print (plt.rcParams[&#39;font.family&#39;] ) . [&#39;Malgun Gothic&#39;] . &#45936;&#51060;&#53552; &#47196;&#46377; . import pandas as pd train = pd.read_csv(&#39;data/titanic/train.csv&#39;) test = pd.read_csv(&#39;data/titanic/test.csv&#39;) . &#45936;&#51060;&#53552; &#54869;&#51064; . train과 test 비교후, test에 없는 칼럼이 종속변수 | head()와 info()를 비교하여 범주형과 숫자형의 type이 제대로 되었는지 확인하기 | . print(train.shape) print(train.columns) train.head() . (891, 12) Index([&#39;PassengerId&#39;, &#39;Survived&#39;, &#39;Pclass&#39;, &#39;Name&#39;, &#39;Sex&#39;, &#39;Age&#39;, &#39;SibSp&#39;, &#39;Parch&#39;, &#39;Ticket&#39;, &#39;Fare&#39;, &#39;Cabin&#39;, &#39;Embarked&#39;], dtype=&#39;object&#39;) . PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | male | 22.0 | 1 | 0 | A/5 21171 | 7.2500 | NaN | S | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | female | 38.0 | 1 | 0 | PC 17599 | 71.2833 | C85 | C | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | female | 26.0 | 0 | 0 | STON/O2. 3101282 | 7.9250 | NaN | S | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 | 1 | 0 | 113803 | 53.1000 | C123 | S | . 4 5 | 0 | 3 | Allen, Mr. William Henry | male | 35.0 | 0 | 0 | 373450 | 8.0500 | NaN | S | . train.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 891 entries, 0 to 890 Data columns (total 12 columns): PassengerId 891 non-null int64 Survived 891 non-null int64 Pclass 891 non-null int64 Name 891 non-null object Sex 891 non-null object Age 714 non-null float64 SibSp 891 non-null int64 Parch 891 non-null int64 Ticket 891 non-null object Fare 891 non-null float64 Cabin 204 non-null object Embarked 889 non-null object dtypes: float64(2), int64(5), object(5) memory usage: 83.6+ KB . print(test.shape) print(test.columns) test.head() . (418, 11) Index([&#39;PassengerId&#39;, &#39;Pclass&#39;, &#39;Name&#39;, &#39;Sex&#39;, &#39;Age&#39;, &#39;SibSp&#39;, &#39;Parch&#39;, &#39;Ticket&#39;, &#39;Fare&#39;, &#39;Cabin&#39;, &#39;Embarked&#39;], dtype=&#39;object&#39;) . PassengerId Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked . 0 892 | 3 | Kelly, Mr. James | male | 34.5 | 0 | 0 | 330911 | 7.8292 | NaN | Q | . 1 893 | 3 | Wilkes, Mrs. James (Ellen Needs) | female | 47.0 | 1 | 0 | 363272 | 7.0000 | NaN | S | . 2 894 | 2 | Myles, Mr. Thomas Francis | male | 62.0 | 0 | 0 | 240276 | 9.6875 | NaN | Q | . 3 895 | 3 | Wirz, Mr. Albert | male | 27.0 | 0 | 0 | 315154 | 8.6625 | NaN | S | . 4 896 | 3 | Hirvonen, Mrs. Alexander (Helga E Lindqvist) | female | 22.0 | 1 | 1 | 3101298 | 12.2875 | NaN | S | . test.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 418 entries, 0 to 417 Data columns (total 11 columns): PassengerId 418 non-null int64 Pclass 418 non-null int64 Name 418 non-null object Sex 418 non-null object Age 332 non-null float64 SibSp 418 non-null int64 Parch 418 non-null int64 Ticket 418 non-null object Fare 417 non-null float64 Cabin 91 non-null object Embarked 418 non-null object dtypes: float64(2), int64(4), object(5) memory usage: 36.0+ KB . &#52860;&#47100;&#47749; &#49548;&#47928;&#51088;&#47196; &#51068;&#44292;&#48320;&#44221; . &#48169;&#48277;1 : &#46357;&#49492;&#45320;&#47532; &#54805;&#53468;&#47196; &#48320;&#44221;( &#51068;&#48512;&#48516;&#47564; &#44032;&#45733;) . train = train.rename( columns = { &#39;PassengerId&#39; : &#39;passengerid&#39;, &#39;Pclass&#39; : &#39;pclass&#39; , &#39;Name&#39; : &#39;name&#39;, &#39;Sex&#39; : &#39;sex&#39;, &#39;Age&#39; : &#39;age&#39;, &#39;SibSp&#39; : &#39;sibsp&#39;, &#39;Ticket&#39; : &#39;ticket&#39; , &#39;Fare&#39; : &#39;fare&#39;, &#39;Cabin&#39; : &#39;cabin&#39;, &#39;Embarked&#39; : &#39;embarked&#39;, &#39;Parch&#39; : &#39;Parch&#39;.lower() , &#39;Survived&#39; : &#39;survived&#39;, }) . test = test.rename( columns = { &#39;PassengerId&#39; : &#39;passengerid&#39;, &#39;Pclass&#39; : &#39;pclass&#39; , &#39;Name&#39; : &#39;name&#39;, &#39;Sex&#39; : &#39;sex&#39;, &#39;Age&#39; : &#39;age&#39;, &#39;SibSp&#39; : &#39;sibsp&#39;, &#39;Ticket&#39; : &#39;ticket&#39; , &#39;Fare&#39; : &#39;fare&#39;, &#39;Cabin&#39; : &#39;cabin&#39;, &#39;Embarked&#39; : &#39;embarked&#39;, &#39;Parch&#39; : &#39;Parch&#39;.lower() , # &#39;Survived&#39; : &#39;survived&#39;, }) . &#47532;&#49828;&#53944; &#52980;&#54532;&#47532;&#54760;&#49496;&#51012; &#53685;&#54620; &#54620;&#48264;&#50640; &#49548;&#47928;&#51088; &#52376;&#47532; . train.columns . Index([&#39;passengerid&#39;, &#39;survived&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;age&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;ticket&#39;, &#39;fare&#39;, &#39;cabin&#39;, &#39;embarked&#39;], dtype=&#39;object&#39;) . [col.lower() for col in train.columns] . [&#39;passengerid&#39;, &#39;survived&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;age&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;ticket&#39;, &#39;fare&#39;, &#39;cabin&#39;, &#39;embarked&#39;] . train.columns = [col.lower() for col in train.columns] train.head() . passengerid survived pclass name sex age sibsp parch ticket fare cabin embarked . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | male | 22.0 | 1 | 0 | A/5 21171 | 7.2500 | NaN | S | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | female | 38.0 | 1 | 0 | PC 17599 | 71.2833 | C85 | C | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | female | 26.0 | 0 | 0 | STON/O2. 3101282 | 7.9250 | NaN | S | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 | 1 | 0 | 113803 | 53.1000 | C123 | S | . 4 5 | 0 | 3 | Allen, Mr. William Henry | male | 35.0 | 0 | 0 | 373450 | 8.0500 | NaN | S | . &#48276;&#51452; &lt;-&gt; &#49707;&#51088; type &#51228;&#45824;&#47196; &#46104;&#50632;&#45716;&#51648; &#54869;&#51064; . Pclass 범주인데 숫자로 | Survived 범주인데 숫자로 | Parch 도 | Sipsp 도 | . train[&#39;survived&#39;] = train[&#39;survived&#39;].astype( object ) train[&#39;pclass&#39;] = train[&#39;pclass&#39;].astype( object ) train[&#39;parch&#39;] = train[&#39;parch&#39;].astype( object ) train[&#39;sibsp&#39;] = train[&#39;sibsp&#39;].astype( object ) . test[&#39;pclass&#39;] = test[&#39;pclass&#39;].astype( object ) train[&#39;parch&#39;] = train[&#39;parch&#39;].astype( object ) train[&#39;sibsp&#39;] = train[&#39;sibsp&#39;].astype( object ) . Null &#52404;&#53356; . train.isnull().sum() . passengerid 0 survived 0 pclass 0 name 0 sex 0 age 177 sibsp 0 parch 0 ticket 0 fare 0 cabin 687 embarked 2 dtype: int64 . train.isnull().sum().reset_index() . index 0 . 0 passengerid | 0 | . 1 survived | 0 | . 2 pclass | 0 | . 3 name | 0 | . 4 sex | 0 | . 5 age | 177 | . 6 sibsp | 0 | . 7 parch | 0 | . 8 ticket | 0 | . 9 fare | 0 | . 10 cabin | 687 | . 11 embarked | 2 | . missing_df = train.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df . columns count . 0 passengerid | 0 | . 1 survived | 0 | . 2 pclass | 0 | . 3 name | 0 | . 4 sex | 0 | . 5 age | 177 | . 6 sibsp | 0 | . 7 parch | 0 | . 8 ticket | 0 | . 9 fare | 0 | . 10 cabin | 687 | . 11 embarked | 2 | . missing_df = train.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df[&#39;missing_rate&#39;] = missing_df[&#39;count&#39;] / train.shape[0] # 미싱 갯수 / 전체데이터의 데이터수 - shape(row,col)의 첫번째!! missing_df . columns count missing_rate . 0 passengerid | 0 | 0.000000 | . 1 survived | 0 | 0.000000 | . 2 pclass | 0 | 0.000000 | . 3 name | 0 | 0.000000 | . 4 sex | 0 | 0.000000 | . 5 age | 177 | 0.198653 | . 6 sibsp | 0 | 0.000000 | . 7 parch | 0 | 0.000000 | . 8 ticket | 0 | 0.000000 | . 9 fare | 0 | 0.000000 | . 10 cabin | 687 | 0.771044 | . 11 embarked | 2 | 0.002245 | . train . missing_df = train.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df[&#39;missing_rate&#39;] = missing_df[&#39;count&#39;] / train.shape[0] # 미싱 갯수 / 전체데이터의 데이터수 - shape(row,col)의 첫번째!! missing_df.loc[ missing_df[&#39;missing_rate&#39;] != 0, :] # missing_Rate가 0이 아닌 것들만 가졍괴 . columns count missing_rate . 5 age | 177 | 0.198653 | . 10 cabin | 687 | 0.771044 | . 11 embarked | 2 | 0.002245 | . test . missing_df = test.isnull().sum().reset_index() missing_df.columns = [&#39;columns&#39;, &#39;count&#39;] missing_df[&#39;missing_rate&#39;] = missing_df[&#39;count&#39;] / test.shape[0] # 미싱 갯수 / 전체데이터의 데이터수 - shape(row,col)의 첫번째!! missing_df.loc[ missing_df[&#39;missing_rate&#39;] != 0, :] # missing_Rate가 0이 아닌 것들만 가졍괴 . columns count missing_rate . 4 age | 86 | 0.205742 | . 8 fare | 1 | 0.002392 | . 9 cabin | 327 | 0.782297 | . &#51333;&#49549;&#48320;&#49688; &#54869;&#51064; &#48143; &#51333;&#49549;&#48320;&#49688;&#50640; &#45824;&#54620; &#45796;&#47480;&#48320;&#49688;&#46308; &#44288;&#44228; &#52628;&#47200; . &#51333;&#49549;&#48320;&#49688;&#51032; &#48276;&#51452;&#48324; &#48712;&#46020; &#52404;&#53356; . matplotlib &#44592;&#48376; . train[&#39;survived&#39;].value_counts().plot(kind=&#39;bar&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x259dad8add8&gt; . sns . fig, ax = plt.subplots(1, 2, # 1x2 Pieplot + barplot figsize= (12,8)) # 1 X1 Pie plot train[&#39;survived&#39;].value_counts().plot.pie( explode = [0, 0.1], autopct = &#39;%1.1f%%&#39;, # 퍼센트는 소수점1자리까지 ax = ax[0], shadow = True ) ax[0].set_title(&#39;Pie plot&#39;) ax[0].set_ylabel(&#39;&#39;) # # 1 X 2 bar plot (sns.countplot) # train[&#39;survived&#39;].value_counts().plot( # kind= &#39;bar&#39;, # ax = ax[1], # ) sns.countplot( &#39;survived&#39;, #칼럼명 data = train, # df ax = ax[1] # 좌표평면 ) plt.tight_layout() . import relationship as r r.categorical_all(train, &#39;survived&#39;) . 0 549 1 342 Name: survived, dtype: int64 . &#45800;&#48320;&#49688; &#53456;&#49353;1 : &#48276;&#51452;&#54805; &#52860;&#47100;&#51032; &#48712;&#46020; . &#48276;&#51452;&#54805; &#52860;&#47100;&#47749;&#47564; &#44032;&#51256;&#50724;&#44592; &amp; id&#50752; &#51333;&#49549;&#48320;&#49688; &#51228;&#50808;&#49884;&#53412;&#44592; . train[&#39;survived&#39;].dtypes . train[&#39;survived&#39;].dtypes == &quot;object&quot; . category_feature = [ col for col in train.columns if train[col].dtypes == &quot;object&quot;] category_feature . [&#39;survived&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;ticket&#39;, &#39;cabin&#39;, &#39;embarked&#39;] . id&#52860;&#47100;&#44284; &#51333;&#49549;&#48320;&#49688;&#52860;&#47100; &#51228;&#50808;&#49884;&#53412;&#44592; by set . # set으로 마이너스 연산을 한 뒤, list()로 감싸서 다시 리스트로 만든다. categorical_feature = list( set(category_feature) - set( [&#39;passengerid&#39;, &#39;survived&#39;]) ) categorical_feature . [&#39;embarked&#39;, &#39;ticket&#39;, &#39;parch&#39;, &#39;cabin&#39;, &#39;pclass&#39;, &#39;name&#39;, &#39;sex&#39;, &#39;sibsp&#39;] . &#48276;&#51452;&#52860;&#47100;&#47749; &#47532;&#49828;&#53944;&#47484; &#51060;&#50857;&#54620; &#48276;&#51452;&#52860;&#47100;&#46308; &#54620;&#44732;&#48264;&#50640; &#48712;&#46020; &#48372;&#44592; . for col in categorical_feature: f, ax = plt.subplots(1, 1, figsize=(10,7)) sns.countplot( col, #칼럼명 data = train, # df ) plt.title(col) plt.show() # 여러개 그림을 한셀에 띄울 때, plt.show()를 통해 하나씩 끊어주기! . &#54632;&#49688;&#54868;&#54616;&#44592; ( &#45800;&#48320;&#49688; &#48276;&#51452;&#54805; &#52860;&#47100;&#51032; &#48712;&#46020; ) with &#48276;&#51452;&#54805; &#52860;&#47100;&#47749; &#47532;&#49828;&#53944; . def categorical_all(df, categorical_feature): # 칼럼명 하나만 입력시 if type(categorical_feature) is str: sns.countplot( categorical_feature, #칼럼명 1개 data = df, # df ) plt.title(categorical_feature) #칼럼명 1개 plt.tight_layout() plt.show() # 여러개 그림을 한셀에 띄울 때, plt.show()를 통해 하나씩 끊어주기! else: # 범주형 칼럼명 리스트가 들어왔을 때 for col in categorical_feature: sns.countplot( col, #칼럼명 data = df, # df ) plt.title(col) plt.tight_layout() plt.show() # 여러개 그림을 한셀에 띄울 때, plt.show()를 통해 하나씩 끊어주기! . categorical_all(train, &#39;cabin&#39;) . categorical_all(train, categorical_feature) . &#45800;&#48320;&#49688; &#53456;&#49353;2 : &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252; . &#49707;&#51088;&#54805; &#52860;&#47100;&#47749; &#44032;&#51256;&#50724;&#44592; = &#51204;&#52404;&#52860;&#47100; - &#48276;&#51452;&#54805;&#52860;&#47100; - (id+&#51333;&#49549;&#48320;&#49688;) . train.head() . passengerid survived pclass name sex age sibsp parch ticket fare cabin embarked . 0 1 | 0 | 3 | Braund, Mr. Owen Harris | male | 22.0 | 1 | 0 | A/5 21171 | 7.2500 | NaN | S | . 1 2 | 1 | 1 | Cumings, Mrs. John Bradley (Florence Briggs Th... | female | 38.0 | 1 | 0 | PC 17599 | 71.2833 | C85 | C | . 2 3 | 1 | 3 | Heikkinen, Miss. Laina | female | 26.0 | 0 | 0 | STON/O2. 3101282 | 7.9250 | NaN | S | . 3 4 | 1 | 1 | Futrelle, Mrs. Jacques Heath (Lily May Peel) | female | 35.0 | 1 | 0 | 113803 | 53.1000 | C123 | S | . 4 5 | 0 | 3 | Allen, Mr. William Henry | male | 35.0 | 0 | 0 | 373450 | 8.0500 | NaN | S | . numerical_feature = list( set(train.columns) - set(categorical_feature) - set([&#39;passengerid&#39;, &#39;survived&#39;]) ) numerical_feature . [&#39;age&#39;, &#39;fare&#39;] . np.sort(numerical_feature) . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . numerical_feature = list( set(train.columns) - set(categorical_feature) - set([&#39;passengerid&#39;, &#39;survived&#39;]) ) numerical_feature = np.sort(numerical_feature) numerical_feature . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252; sns.distplot &#54620;&#44732;&#48264;&#50640; &#44536;&#47532;&#44592; . for col in numerical_feature: print(train[col].describe()) sns.distplot( train.loc[train[col].notnull(), col] ) # 해당칼럼 중 NaN아닌것만 인덱싱한 칼럼만 그리기 plt.title(col) plt.show() . count 714.000000 mean 29.699118 std 14.526497 min 0.420000 25% 20.125000 50% 28.000000 75% 38.000000 max 80.000000 Name: age, dtype: float64 . count 891.000000 mean 32.204208 std 49.693429 min 0.000000 25% 7.910400 50% 14.454200 75% 31.000000 max 512.329200 Name: fare, dtype: float64 . &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252;2 boxplot . for col in numerical_feature: print(train[col].describe()) sns.boxplot( data=train.loc[train[col].notnull(), col] ) plt.title(col) plt.show() . count 714.000000 mean 29.699118 std 14.526497 min 0.420000 25% 20.125000 50% 28.000000 75% 38.000000 max 80.000000 Name: age, dtype: float64 . count 891.000000 mean 32.204208 std 49.693429 min 0.000000 25% 7.910400 50% 14.454200 75% 31.000000 max 512.329200 Name: fare, dtype: float64 . &#49707;&#51088;&#54805; &#52860;&#47100;&#51032; &#48516;&#54252;( hist(dist) + boxplot ) &#54620;&#48264;&#50640; &#44536;&#47532;&#44592; . for col in numerical_feature: # 숫자형 칼럼의 기술통계량 print(train[col].describe()) print(f&quot;Skewed : {train[col].skew():.2f}&quot;) f, ax = plt.subplots(1, 2, figsize=(18,9)) # dist sns.distplot( train.loc[train[col].notnull(), col], ax = ax[0] ) ax[0].set_title(col +&#39; &#39;s hist(dist) plot&#39; ) # boxplot sns.boxplot( data=train.loc[train[col].notnull(), col], ax = ax[1] ) ax[1].set_title(col +&#39; &#39;s boxplot&#39;) plt.tight_layout() plt.show() . count 714.000000 mean 29.699118 std 14.526497 min 0.420000 25% 20.125000 50% 28.000000 75% 38.000000 max 80.000000 Name: age, dtype: float64 Skewed : 0.39 . count 891.000000 mean 32.204208 std 49.693429 min 0.000000 25% 7.910400 50% 14.454200 75% 31.000000 max 512.329200 Name: fare, dtype: float64 Skewed : 4.79 . &#54632;&#49688;&#54868;&#54616;&#44592; ( &#45800;&#48320;&#49688; &#49707;&#51088;&#54805; &#48516;&#54252; dist+boxplot ) with &#49707;&#51088;&#54805; &#52860;&#47100;&#47749; &#47532;&#49828;&#53944; . def numerical_all(df, numerical_feature): for col in numerical_feature: # 숫자형 칼럼의 기술통계량 print(df[col].describe()) print(f&quot;Skewed : {train[col].skew():.2f}&quot;) f, ax = plt.subplots(1, 2, figsize=(18,9)) # dist sns.distplot( df.loc[train[col].notnull(), col], ax = ax[0] ) ax[0].set_title(col +&#39; &#39;s hist(dist) plot&#39; ) ax[0].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 # boxplot sns.boxplot( data=df.loc[df[col].notnull(), col], ax = ax[1] ) ax[1].set_title(col +&#39; &#39;s boxplot&#39;) ax[1].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 plt.tight_layout() plt.show() . &#51060;&#48320;&#49688; &#53456;&#49353;1 : &#51333;&#49549;&#48320;&#49688;(&#48276;&#51452;)&#48324; - &#48276;&#51452;&#54805; &#48320;&#49688; . &#48169;&#48277;1: &#53945;&#51221;(&#51333;&#49549;)&#48276;&#51452;&#48324; &#48276;&#51452;&#52860;&#47100; &#51064;&#45937;&#49905;&#54616;&#50668;&#49436; &#44033; &#48276;&#51452;&#48324; series&#47484; df&#47196; &#54633;&#52824;&#44592; . survived = train.loc[ train[&#39;survived&#39;] == 0,&#39;sex&#39; ].value_counts() survived.name = &#39;Survived&#39; dead = train.loc[ train[&#39;survived&#39;] == 1,&#39;sex&#39; ].value_counts() dead.name = &#39;Dead&#39; # 시리즈를 리스트형식으로 df합치기 df = pd.DataFrame( [ survived, dead] ) df.head() . male female . Survived 468 | 81 | . Dead 109 | 233 | . print(df) df.plot(kind=&#39;bar&#39;) . male female Survived 468 81 Dead 109 233 . &lt;matplotlib.axes._subplots.AxesSubplot at 0x2962005c550&gt; . &#48169;&#48277;2 : pd.crosstab &#51004;&#47196; &#44536;&#47532;&#44592; . &#48712;&#46020; . pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;]) . survived 0 1 . sex . female 81 | 233 | . male 468 | 109 | . pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;]).plot(kind=&#39;barh&#39;, stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x296212901d0&gt; . pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;], margins = True).style.background_gradient(cmap=&#39;summer_r&#39;) . survived 0 1 All . sex . female 81 | 233 | 314 | . male 468 | 109 | 577 | . All 549 | 342 | 891 | . &#48708;&#50984; . cross = pd.crosstab( train[&#39;sex&#39;], train[&#39;survived&#39;]) cross_ratio = cross / cross.sum() cross_ratio . survived 0 1 . sex . female 0.147541 | 0.681287 | . male 0.852459 | 0.318713 | . cross_ratio.plot(kind=&#39;bar&#39;, stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cfa31ef0&gt; . cross_ratio.transpose().plot(kind=&#39;bar&#39;, stacked=True) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cfd34eb8&gt; . &#48169;&#48277;3 : groupby( &#48276;&#51452;) [ &#51333;&#49549;&#48320;&#49688;].&#51665;&#44228;.unstack() - &#48712;&#46020;+&#54217;&#44512;&#46020; &#44032;&#45733; + &#44032;&#49345;df&#47196;&#49436; apply()&#47196; &#48708;&#50984;&#44228;&#49328;&#44032;&#45733;&#54632; . &#48712;&#46020; . sex_to_survived = train.groupby(&#39;sex&#39;) [&#39;survived&#39;].value_counts().unstack() sex_to_survived . survived 0 1 . sex . female 81 | 233 | . male 468 | 109 | . sex_to_survived.plot(kind=&#39;bar&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cf4b85f8&gt; . &#48708;&#50984; : groupby( [&#39;&#48276;&#51452;&#39; ,&#39;&#51333;&#49549;&#39;]) [&#39;&#51333;&#49549;&#39;] &#51004;&#47196; &#48708;&#50984; &#44228;&#49328;&#54616;&#44592; . 비율을 계산하려면, 숫자칼럼 형태( 범주에서 counts() .unstack()도 먹인상태) | .count().unstack() : 범주별, 종속별, 종속의 범주마다 row단순 count -&gt; 칼럼으로 | .count().unstack() 한 것을 칼럼별로 계산하도록 df/df.sum() 으로 비율계산 | .transpose() 를 통해 index = x축에 종속변수가 가야 비율이 가득찬다 | . dict( list( train.groupby([&#39;sex&#39;, &#39;survived&#39;]) ) ).keys() . dict_keys([(&#39;female&#39;, 0), (&#39;female&#39;, 1), (&#39;male&#39;, 0), (&#39;male&#39;, 1)]) . dict( list( train.groupby([&#39;sex&#39;, &#39;survived&#39;]) ) )[&#39;female&#39;, 0].head() . passengerid survived pclass name sex age sibSp parch ticket fare cabin embarked . 14 15 | 0 | 3 | Vestrom, Miss. Hulda Amanda Adolfina | female | 14.0 | 0 | 0 | 350406 | 7.8542 | NaN | S | . 18 19 | 0 | 3 | Vander Planke, Mrs. Julius (Emelia Maria Vande... | female | 31.0 | 1 | 0 | 345763 | 18.0000 | NaN | S | . 24 25 | 0 | 3 | Palsson, Miss. Torborg Danira | female | 8.0 | 3 | 1 | 349909 | 21.0750 | NaN | S | . 38 39 | 0 | 3 | Vander Planke, Miss. Augusta Maria | female | 18.0 | 2 | 0 | 345764 | 18.0000 | NaN | S | . 40 41 | 0 | 3 | Ahlin, Mrs. Johan (Johanna Persdotter Larsson) | female | 40.0 | 1 | 0 | 7546 | 9.4750 | NaN | S | . train.groupby(&#39;sex&#39;)[&#39;survived&#39;].value_counts() . sex survived female 1 233 0 81 male 0 468 1 109 Name: survived, dtype: int64 . cross_df = train.groupby(&#39;sex&#39;) [&#39;survived&#39;].value_counts().unstack() cross_ratio = cross_df / cross_df.sum() cross_ratio . survived 0 1 . sex . female 0.147541 | 0.681287 | . male 0.852459 | 0.318713 | . cross_ratio.transpose().plot(kind=&#39;bar&#39;, stacked=True, figsize=(10,8)) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196d17e84a8&gt; . &#48169;&#48277;4 : sns.countplot( &#39;&#48276;&#51452;&#52860;&#47100;&#39; , hue= &#39;&#51333;&#49549;&#48320;&#49688;&#39; ) -&gt; &#48708;&#50984;&#51008; &#48380; &#49688; &#50630;&#45796; . sns.countplot(&#39;sex&#39;, data = train, hue=&#39;survived&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x196cfa68080&gt; . &#48276;&#51452;-&#51333;&#49549;(&#48276;&#51452;) &#51333;&#49549;&#48320;&#49688;&#48324; &#48276;&#51452;&#51032; &#48708;&#50984; &#54620;&#48264;&#50640; &#44536;&#47532;&#44592; . cross_df = train.groupby(&#39;pclass&#39;)[&#39;survived&#39;].value_counts().unstack() # 세로로 합하고, 칼럼별로 나누어 비율계산하기 print(pd.DataFrame(cross_df)) cross_ratio = cross_df/ cross_df.sum() # 세로방향기준으로 각 비율이 나눠져있는데, 그냥 그리면 row별로 x축에 틱이 찍힘 # 뒤집기 cross_ratio = cross_ratio.transpose() cross_ratio.plot(kind=&#39;bar&#39;, stacked=True, figsize=(10,5)) . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . &lt;matplotlib.axes._subplots.AxesSubplot at 0x1dd55006e48&gt; . &#51333;&#49549;-&#48276;&#51452;&#54805;&#48320;&#49688; &#44288;&#44228; &#54632;&#49688;&#51221;&#51032;&#54616;&#44592; . def cate_to_categorical(data,name_c, name_d ): # index 범주형 변수/ col 종속 변수 cross_df = data.groupby( name_c)[name_d].value_counts().unstack() # 세로로 합하고, 칼럼별로 나누어 비율계산하기 print(cross_df) cross_ratio = cross_df/ cross_df.sum() # 세로방향기준으로 각 비율이 나눠져있는데, 그냥 그리면 row별로 x축에 틱이 찍힘 # 뒤집기 cross_ratio = cross_ratio.transpose() f, ax = plt.subplots(1, 2, figsize=(18,9)) cross_df.plot(kind=&#39;bar&#39;, ax=ax[0]) ax[0].set_title(name_c +&#39; to &#39; +name_d ) ax[0].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 cross_ratio.plot(kind=&#39;bar&#39;, ax = ax[1], stacked=True) ax[1].set_title(name_d +&#39; to &#39;+name_c +&#39; ratio&#39; ) ax[1].legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0)) # 범례 밖으로 빼기 plt.tight_layout() plt.show() # for문에 들어갈 것 대비 끝내기 . relationship_new.cate_to_categorical(train, &#39;survived&#39;, &#39;sex&#39;) . survived 0 1 sex female 81 233 male 468 109 . cate_to_categorical(train, &#39;survived&#39;, &#39;pclass&#39;) . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . import relationship_new relationship_new.cate_to_categorical(train, &#39;survived&#39;, &#39;pclass&#39;) . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . relationship_new.cate_to_categorical(train, &#39;survived&#39;, &#39;parch&#39;) . survived 0 1 parch 0 445.0 233.0 1 53.0 65.0 2 40.0 40.0 3 2.0 3.0 4 4.0 NaN 5 4.0 1.0 6 1.0 NaN . for+&#54632;&#49688;(&#48276;&#51452;-&#48276;&#51452;)&#47928;&#51012; &#53685;&#54644; &#47784;&#46304; &#51333;&#49549;&#52860;&#47100;&#50640; &#45824;&#54644; &#47784;&#46304; &#48276;&#51452;&#52860;&#47100;&#51032; &#48516;&#54252;&#50752; &#48708;&#50984; &#44536;&#47140;&#48372;&#44592; . 범주가 너무 많을때는 금지!! feature engineering | . for col in categorical_feature: relationship_new.cate_to_categorical(train, &#39;survived&#39;, col) . survived 0 1 embarked C 75 93 Q 47 30 S 427 217 . survived 0 1 sex female 81 233 male 468 109 . survived 0 1 name Abbing, Mr. Anthony 1.0 NaN Abbott, Mr. Rossmore Edward 1.0 NaN Abbott, Mrs. Stanton (Rosa Hunt) NaN 1.0 Abelson, Mr. Samuel 1.0 NaN Abelson, Mrs. Samuel (Hannah Wizosky) NaN 1.0 Adahl, Mr. Mauritz Nils Martin 1.0 NaN Adams, Mr. John 1.0 NaN Ahlin, Mrs. Johan (Johanna Persdotter Larsson) 1.0 NaN Aks, Mrs. Sam (Leah Rosen) NaN 1.0 Albimona, Mr. Nassef Cassem NaN 1.0 Alexander, Mr. William 1.0 NaN Alhomaki, Mr. Ilmari Rudolf 1.0 NaN Ali, Mr. Ahmed 1.0 NaN Ali, Mr. William 1.0 NaN Allen, Miss. Elisabeth Walton NaN 1.0 Allen, Mr. William Henry 1.0 NaN Allison, Master. Hudson Trevor NaN 1.0 Allison, Miss. Helen Loraine 1.0 NaN Allison, Mrs. Hudson J C (Bessie Waldo Daniels) 1.0 NaN Allum, Mr. Owen George 1.0 NaN Andersen-Jensen, Miss. Carla Christine Nielsine NaN 1.0 Anderson, Mr. Harry NaN 1.0 Andersson, Master. Sigvard Harald Elias 1.0 NaN Andersson, Miss. Ebba Iris Alfrida 1.0 NaN Andersson, Miss. Ellis Anna Maria 1.0 NaN Andersson, Miss. Erna Alexandra NaN 1.0 Andersson, Miss. Ingeborg Constanzia 1.0 NaN Andersson, Miss. Sigrid Elisabeth 1.0 NaN Andersson, Mr. Anders Johan 1.0 NaN Andersson, Mr. August Edvard (&#34;Wennerstrom&#34;) NaN 1.0 ... ... ... Widegren, Mr. Carl/Charles Peter 1.0 NaN Widener, Mr. Harry Elkins 1.0 NaN Wiklund, Mr. Jakob Alfred 1.0 NaN Wilhelms, Mr. Charles NaN 1.0 Willey, Mr. Edward 1.0 NaN Williams, Mr. Charles Duane 1.0 NaN Williams, Mr. Charles Eugene NaN 1.0 Williams, Mr. Howard Hugh &#34;Harry&#34; 1.0 NaN Williams, Mr. Leslie 1.0 NaN Williams-Lambert, Mr. Fletcher Fellows 1.0 NaN Windelov, Mr. Einar 1.0 NaN Wiseman, Mr. Phillippe 1.0 NaN Woolner, Mr. Hugh NaN 1.0 Wright, Mr. George 1.0 NaN Yasbeck, Mr. Antoni 1.0 NaN Yasbeck, Mrs. Antoni (Selini Alexander) NaN 1.0 Young, Miss. Marie Grice NaN 1.0 Youseff, Mr. Gerious 1.0 NaN Yousif, Mr. Wazli 1.0 NaN Yousseff, Mr. Gerious 1.0 NaN Yrois, Miss. Henriette (&#34;Mrs Harbeck&#34;) 1.0 NaN Zabour, Miss. Hileni 1.0 NaN Zabour, Miss. Thamine 1.0 NaN Zimmerman, Mr. Leo 1.0 NaN de Messemaeker, Mrs. Guillaume Joseph (Emma) NaN 1.0 de Mulder, Mr. Theodore NaN 1.0 de Pelsmaeker, Mr. Alfons 1.0 NaN del Carlo, Mr. Sebastiano 1.0 NaN van Billiard, Mr. Austin Blyler 1.0 NaN van Melkebeke, Mr. Philemon 1.0 NaN [891 rows x 2 columns] . C: Users is2js Anaconda3 lib site-packages matplotlib tight_layout.py:181: UserWarning: Tight layout not applied. The bottom and top margins cannot be made large enough to accommodate all axes decorations. warnings.warn(&#39;Tight layout not applied. &#39; . survived 0 1 pclass 1 80 136 2 97 87 3 372 119 . survived 0 1 cabin A10 1.0 NaN A14 1.0 NaN A16 NaN 1.0 A19 1.0 NaN A20 NaN 1.0 A23 NaN 1.0 A24 1.0 NaN A26 NaN 1.0 A31 NaN 1.0 A32 1.0 NaN A34 NaN 1.0 A36 1.0 NaN A5 1.0 NaN A6 NaN 1.0 A7 1.0 NaN B101 NaN 1.0 B102 1.0 NaN B18 NaN 2.0 B19 1.0 NaN B20 NaN 2.0 B22 1.0 1.0 B28 NaN 2.0 B3 NaN 1.0 B30 1.0 NaN B35 NaN 2.0 B37 1.0 NaN B38 1.0 NaN B39 NaN 1.0 B4 NaN 1.0 B41 NaN 1.0 ... ... ... E12 NaN 1.0 E121 NaN 2.0 E17 NaN 1.0 E24 NaN 2.0 E25 NaN 2.0 E31 1.0 NaN E33 NaN 2.0 E34 NaN 1.0 E36 NaN 1.0 E38 1.0 NaN E40 NaN 1.0 E44 1.0 1.0 E46 1.0 NaN E49 NaN 1.0 E50 NaN 1.0 E58 1.0 NaN E63 1.0 NaN E67 1.0 1.0 E68 NaN 1.0 E77 1.0 NaN E8 NaN 2.0 F E69 NaN 1.0 F G63 1.0 NaN F G73 2.0 NaN F2 1.0 2.0 F33 NaN 3.0 F38 1.0 NaN F4 NaN 2.0 G6 2.0 2.0 T 1.0 NaN [147 rows x 2 columns] . C: Users is2js Anaconda3 lib site-packages matplotlib tight_layout.py:181: UserWarning: Tight layout not applied. The bottom and top margins cannot be made large enough to accommodate all axes decorations. warnings.warn(&#39;Tight layout not applied. &#39; . survived 0 1 ticket 110152 NaN 3.0 110413 1.0 2.0 110465 2.0 NaN 110564 NaN 1.0 110813 NaN 1.0 111240 1.0 NaN 111320 1.0 NaN 111361 NaN 2.0 111369 NaN 1.0 111426 NaN 1.0 111427 NaN 1.0 111428 NaN 1.0 112050 1.0 NaN 112052 1.0 NaN 112053 NaN 1.0 112058 1.0 NaN 112059 1.0 NaN 112277 NaN 1.0 112379 1.0 NaN 113028 1.0 NaN 113043 1.0 NaN 113050 1.0 NaN 113051 1.0 NaN 113055 NaN 1.0 113056 1.0 NaN 113059 1.0 NaN 113501 1.0 NaN 113503 1.0 NaN 113505 NaN 2.0 113509 1.0 NaN ... ... ... SOTON/OQ 392082 1.0 NaN SOTON/OQ 392086 1.0 NaN SOTON/OQ 392089 NaN 1.0 SOTON/OQ 392090 1.0 NaN STON/O 2. 3101269 NaN 1.0 STON/O 2. 3101273 1.0 NaN STON/O 2. 3101274 1.0 NaN STON/O 2. 3101275 1.0 NaN STON/O 2. 3101280 1.0 NaN STON/O 2. 3101285 NaN 1.0 STON/O 2. 3101286 NaN 1.0 STON/O 2. 3101288 NaN 1.0 STON/O 2. 3101289 NaN 1.0 STON/O 2. 3101292 1.0 NaN STON/O 2. 3101293 1.0 NaN STON/O 2. 3101294 1.0 NaN STON/O2. 3101271 1.0 NaN STON/O2. 3101279 1.0 1.0 STON/O2. 3101282 NaN 1.0 STON/O2. 3101283 NaN 1.0 STON/O2. 3101290 1.0 NaN SW/PP 751 NaN 1.0 W./C. 14258 NaN 1.0 W./C. 14263 1.0 NaN W./C. 6607 2.0 NaN W./C. 6608 4.0 NaN W./C. 6609 1.0 NaN W.E.P. 5734 1.0 NaN W/C 14208 1.0 NaN WE/P 5735 1.0 1.0 [681 rows x 2 columns] . C: Users is2js Anaconda3 lib site-packages matplotlib tight_layout.py:181: UserWarning: Tight layout not applied. The bottom and top margins cannot be made large enough to accommodate all axes decorations. warnings.warn(&#39;Tight layout not applied. &#39; . &#51060;&#48320;&#49688; &#53456;&#49353;2 &#49707;&#51088;-&#49707;&#51088;&#54805;&#51032; &#49328;&#51216;&#46020;&#54665;&#47148; with &#51333;&#49549;&#48320;&#49688; . numerical_feature . array([&#39;age&#39;, &#39;fare&#39;, &#39;parch&#39;, &#39;sibsp&#39;], dtype=&#39;&lt;U5&#39;) . # list는 (-)연산은 안되도 (+) 연산은 된다. list(numerical_feature) + [&#39;survived&#39;] . [&#39;age&#39;, &#39;fare&#39;, &#39;parch&#39;, &#39;sibsp&#39;, &#39;survived&#39;] . sns.pairplot( train[ list(numerical_feature) + [&#39;survived&#39;] ], hue = &#39;survived&#39;, x_vars = numerical_feature, y_vars = numerical_feature) . C: Users is2js Anaconda3 lib site-packages statsmodels nonparametric kde.py:448: RuntimeWarning: invalid value encountered in greater X = X[np.logical_and(X &gt; clip[0], X &lt; clip[1])] # won&#39;t work for two columns. C: Users is2js Anaconda3 lib site-packages statsmodels nonparametric kde.py:448: RuntimeWarning: invalid value encountered in less X = X[np.logical_and(X &gt; clip[0], X &lt; clip[1])] # won&#39;t work for two columns. . &lt;seaborn.axisgrid.PairGrid at 0x296230e9828&gt; . &#54632;&#49688;&#54868;( &#49707;&#51088; - &#49707;&#51088;&#51032; &#49328;&#51216;&#46020; &#54665;&#47148; : pairplot) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) by &#49707;&#51088;&#54805;&#52860;&#47100;&#47749;&#47532;&#49828;&#53944; . type(numerical_feature) . numpy.ndarray . list().dtype . AttributeError Traceback (most recent call last) &lt;ipython-input-119-0901fc39190d&gt; in &lt;module&gt; -&gt; 1 list().dtype AttributeError: &#39;list&#39; object has no attribute &#39;dtype&#39; . numerical_feature . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . type(list(numerical_feature)) is list . True . len(numerical_feature) . 2 . def num_to_numerical(df, numerical_feature, name_d=None): # 종속변수 없을 때 if name_d == None: sns.pairplot( df[ list(numerical_feature) ] , # 숫자형칼럼들만 인덱싱 x_vars = numerical_feature, y_vars = numerical_feature ) plt.tight_layout() # 숫자 - 숫자 산점도 행렬 with 종속변수 범례 else: sns.pairplot( df[ list(numerical_feature) + [name_d]] , # 숫자형칼럼들 + 종속변수 인덱싱 hue = name_d, # 범례(색)으로 종속변수 추가 x_vars = numerical_feature, y_vars = numerical_feature ) plt.tight_layout() . num_to_numerical(train, {&#39;age&#39;, &#39;fare&#39;}, &#39;survived&#39;) . &#51060;&#48320;&#49688; &#53456;&#49353;3 : &#48276;&#51452;&#48324; - &#49707;&#51088;&#54805; &#52860;&#47100;(&#46308;)&#51032; &#48516;&#54252;(boxplot) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) by &#49707;&#51088;&#54805;&#52860;&#47100;&#47749;&#47532;&#49828;&#53944; . &#48276;&#51452;&#48324; &#49707;&#51088;&#52860;&#47100;1&#44060;&#51032; &#48516;&#54252;(boxplot) . print(train.groupby(&#39;sex&#39;)[&#39;age&#39;].describe()) plt.figure(figsize=(18,9)) sns.boxplot(x=&#39;sex&#39;, y=&#39;age&#39;, data=train.dropna()) plt.title(&quot;Sex - { }&quot;.format(&#39;age&#39;)) plt.show() . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . KeyError Traceback (most recent call last) &lt;ipython-input-277-1a8c01f185d7&gt; in &lt;module&gt; 2 plt.figure(figsize=(18,9)) 3 sns.boxplot(x=&#39;sex&#39;, y=&#39;age&#39;, data=train.dropna()) -&gt; 4 plt.title(&#34;Sex - { }&#34;.format(&#39;age&#39;)) 5 plt.show() KeyError: &#39; &#39; . &#54632;&#49688;&#54868;(&#48276;&#51452;&#48324; &#49707;&#51088;&#52860;&#47100;1&#44060;&#51032; &#48516;&#54252;(boxplot)) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) . def cate_to_num_box(df, name_c, name_n, name_d=None): # 범주별 기술통계량 if name_d != None: print(df.groupby([name_c, name_d])[name_n].describe()) else : print(df.groupby(name_c)[name_n].describe()) # 범주별 boxplot - 범례는 선택 plt.figure(figsize=(18,9)) sns.boxplot(x=name_c, y=name_n, data=df.dropna(), hue = name_d) plt.title(&quot;{} to {}&quot;.format(name_c, name_n)) plt.tight_layout() plt.show() . cate_to_num_box(train, &#39;sex&#39;, &#39;age&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . type(numerical_feature) . numpy.ndarray . type(&quot;age&quot;) . str . &#54632;&#49688;&#54868;( &#48276;&#51452;&#48324; - &#49707;&#51088;&#52860;&#47100;(&#46308;)&#51032; &#48516;&#54252;(boxplot)) with &#51333;&#49549;&#48320;&#49688;(&#48276;&#47168;) . def cate_to_num_box(df, name_c, numerical_feature, name_d=None): # 숫자형 칼럼명 1개 ( 칼럼명 = 문자열 1개 직접 입력) if type(numerical_feature) is str: # 범주별 기술통계량 if name_d != None: print(df.groupby([name_c, name_d])[numerical_feature].describe()) else : print(df.groupby(name_c)[numerical_feature].describe()) # 범주별 boxplot - 범례는 선택 plt.figure(figsize=(18,9)) sns.boxplot(x=name_c, y=numerical_feature, data=df.dropna(), hue = name_d) plt.title(&quot;{} to {}&quot;.format(name_c, numerical_feature)) plt.tight_layout() plt.show() # 숫자형 칼럼명 리스트가 들어와서 for문을 돌면서 여러개 그릴 때 else : for col in numerical_feature: if name_d != None: print(df.groupby([name_c, name_d])[col].describe()) else : print(df.groupby(name_c)[col].describe()) plt.figure(figsize=(18,9)) sns.boxplot(x=name_c, # 범주칼럼명 y=col, # 숫자칼럼명 data=df.dropna() , # df hue = name_d ) # 종속칼럼명(선택) plt.title(&quot;{} to {}&quot;.format(name_c, col)) plt.tight_layout() plt.show() . cate_to_num_box(train, &#39;sex&#39;, &#39;age&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . cate_to_num_box(train, &#39;sex&#39;, &#39;age&#39;, &#39;pclass&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 count mean std min 25% 50% 75% max sex pclass female 1 85.0 34.611765 13.612052 2.00 23.000 35.0 44.00 63.0 2 74.0 28.722973 12.872702 2.00 22.250 28.0 36.00 57.0 3 102.0 21.750000 12.729964 0.75 14.125 21.5 29.75 63.0 male 1 101.0 41.281386 15.139570 0.92 30.000 40.0 51.00 80.0 2 99.0 30.740707 14.793894 0.67 23.000 30.0 36.75 70.0 3 253.0 26.507589 12.159514 0.42 20.000 25.0 33.00 74.0 . numerical_feature . array([&#39;age&#39;, &#39;fare&#39;], dtype=&#39;&lt;U4&#39;) . cate_to_num_box(train, &#39;sex&#39;, numerical_feature, &#39;pclass&#39;) . count mean std min 25% 50% 75% max sex pclass female 1 85.0 34.611765 13.612052 2.00 23.000 35.0 44.00 63.0 2 74.0 28.722973 12.872702 2.00 22.250 28.0 36.00 57.0 3 102.0 21.750000 12.729964 0.75 14.125 21.5 29.75 63.0 male 1 101.0 41.281386 15.139570 0.92 30.000 40.0 51.00 80.0 2 99.0 30.740707 14.793894 0.67 23.000 30.0 36.75 70.0 3 253.0 26.507589 12.159514 0.42 20.000 25.0 33.00 74.0 . count mean std min 25% 50% sex pclass female 1 94.0 106.125798 74.259988 25.9292 57.24480 82.66455 2 76.0 21.970121 10.891796 10.5000 13.00000 22.00000 3 144.0 16.118810 11.690314 6.7500 7.85420 12.47500 male 1 122.0 67.226127 77.548021 0.0000 27.72810 41.26250 2 108.0 19.741782 14.922235 0.0000 12.33125 13.00000 3 347.0 12.661633 11.681696 0.0000 7.75000 7.92500 75% max sex pclass female 1 134.500000 512.3292 2 26.062500 65.0000 3 20.221875 69.5500 male 1 78.459375 512.3292 2 26.000000 73.5000 3 10.008300 69.5500 . &#51060;&#48320;&#49688; &#53456;&#49353;4 : &#48276;&#51452;&#48324; &#49707;&#51088;&#54805;&#52860;&#47100;&#51032; &#48276;&#50948;&#48324; kde&#48516;&#54252; &#53456;&#49353; . facet = sns.FacetGrid(train, hue = &#39;survived&#39;, height = 4.5,aspect=4) facet.map(sns.kdeplot, &#39;age&#39;, shade=True) facet.set(xlim = (0, train[&#39;age&#39;].max())) facet.add_legend() . &lt;seaborn.axisgrid.FacetGrid at 0x2241e1602b0&gt; . facet = sns.FacetGrid(train, hue = &#39;survived&#39;, aspect=4) facet.map(sns.kdeplot, &#39;age&#39;, shade=True) facet.set(xlim = (0, train[&#39;age&#39;].max())) facet.add_legend() plt.xlim([10,20]) . (10, 20) . &#54632;&#49688;&#54868; . # ( dataFrame, &#39;범주형 칼럼명&#39; , &#39;숫자형 칼럼명&#39; ) or # ( dataFrame, &#39;범주형 칼럼명&#39; , &#39;숫자형 칼럼명&#39; , xlim = [ a, b ] ) def cate_to_num_kde(df, name_c, name_n, xlim = None ): print(df.groupby(name_c)[name_n].describe()) facet = sns.FacetGrid(df.dropna(), hue = name_c, aspect=4) # df 및 범주형 변수 설정 및 가로길이(aspect) facet.map(sns.kdeplot, name_n, shade=True) # kdeplot 설정 및 숫자형변수 지정 facet.set(xlim = (df[name_n].min(), df[name_n].max())) # 숫자형 변수의 최소값부터 최대값까지 x범위 최초 지정 facet.add_legend() if xlim != None: print( &#39;범위지정 : {}&#39;.format(xlim)) plt.xlim(xlim) # xlim 지정시 그 범위만 출력 . cate_to_num_kde(train, &#39;sex&#39;, &#39;age&#39;) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 . cate_to_num_kde(train, &#39;sex&#39;, &#39;age&#39;, xlim = [20, 30]) . count mean std min 25% 50% 75% max sex female 261.0 27.915709 14.110146 0.75 18.0 27.0 37.0 63.0 male 453.0 30.726645 14.678201 0.42 21.0 29.0 39.0 80.0 범위지정 : [20, 30] . &#49340;&#48320;&#49688; &#53456;&#49353;1 : &#48276;&#51452;2(&#48276;&#47168;)&#48324;&#47196;&#48372;&#45716; &#48276;&#51452;1(x&#52629;)&#48324; --&gt; &#50672;&#49549;(&#51333;&#49549;)&#48320;&#49688; &#51032; &#48708;&#50984; . 범주1이 종속변수에 끼는 영향에 대해 범주2(범례)의 영향이 있는지(크로스) 없는지(평행) 판단 | . # https://kaggle-kr.tistory.com/17?category=821486 sns.catplot(&#39;sex&#39;, &#39;survived&#39;, hue=&#39;pclass&#39;, data=train, kind=&#39;point&#39;, # default kind - factorplot height=6, aspect=1.5) . &lt;seaborn.axisgrid.FacetGrid at 0x1dd548ba160&gt; . &#54632;&#49688;&#54868; . def legend_to_cate_to_num(df, name_l, name_c, name_n): sns.catplot(name_c, name_n, hue=name_l, data=df, kind=&#39;point&#39;, # default kind - factorplot height=6, aspect=1.5) plt.tight_layout() plt.show() . legend_to_cate_to_num(train, &#39;sex&#39;, &#39;pclass&#39;, &#39;survived&#39;) . &#49340;&#48320;&#49688; &#53456;&#49353;2 : &#48276;&#47168;&#48324;(&#51333;&#49549;&#48320;&#49688;)&#48324;&#47196; &#48372;&#45716; &#48276;&#51452;&#48324;(x&#52629;) &#49707;&#51088;&#54805;(y&#52629;-&#48148;&#51060;&#50732;&#47536;)&#51032; &#48516;&#54252; . sns.violinplot(&quot;pclass&quot;,&quot;age&quot;, hue=&quot;survived&quot;, data=train, scale=&#39;count&#39;, split=True) plt.legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 plt.tight_layout() plt.show() # for문에 들어갈 것 대비 . &#54632;&#49688;&#54868;(&#48276;&#47168;&#48324;(&#51333;&#49549;&#48320;&#49688;)&#48324;&#47196; &#48372;&#45716; &#48276;&#51452;&#48324;(x&#52629;) &#49707;&#51088;&#54805;(y&#52629;-&#48148;&#51060;&#50732;&#47536;)&#51032; &#48516;&#54252;) . def legend_to_cate_to_num_violin(df,name_l, name_c, name_n): sns.violinplot(name_c,name_n, hue=name_l, data=df, scale=&#39;count&#39;, split=True) plt.legend(loc=&#39;upper left&#39;, bbox_to_anchor=(1.0, 1.0) ) # 범례 밖으로 빼기 plt.tight_layout() plt.show() # for문에 들어갈 것 대비 . legend_to_cate_to_num_violin(train, &#39;survived&#39;, &#39;sex&#39;, &#39;age&#39;) . categorical_all(train, &#39;embarked&#39;) . cate_to_categorical(train, &#39;survived&#39;, &#39;embarked&#39;) . survived 0 1 embarked C 75 93 Q 47 30 S 427 217 .",
            "url": "blog.chojaeseong.com/data/2021/08/06/%EC%97%91%EC%85%80%EC%A0%95%EB%A6%AC-05-%EC%BA%90%EA%B8%80-1-%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89-%EB%B3%80%EC%88%98%EB%B3%84-EDA-+-%ED%95%A8%EC%88%98%EC%A0%95%EC%9D%98%EB%A1%9C-%EC%A0%95%EC%9D%98(upload).html",
            "relUrl": "/data/2021/08/06/%EC%97%91%EC%85%80%EC%A0%95%EB%A6%AC-05-%EC%BA%90%EA%B8%80-1-%ED%83%80%EC%9D%B4%ED%83%80%EB%8B%89-%EB%B3%80%EC%88%98%EB%B3%84-EDA-+-%ED%95%A8%EC%88%98%EC%A0%95%EC%9D%98%EB%A1%9C-%EC%A0%95%EC%9D%98(upload).html",
            "date": " • Aug 6, 2021"
        }
        
    
  
    
        ,"post173": {
            "title": "fastpages로 블로그 제작",
            "content": "1 fastpages 만들기 . 클릭만으로 repo, actions key 생성/ 추가 merge | . google에서 fastpages검색후 &gt; 깃허브 &gt; setup instruction &gt; on this link (generating by link) . is2js(@naver.com) / 12!@ | . | 블로그 원본 내용이 들어갈 레포지토리 생성임.(github.io 아님) . is2js/blog_raw 이후 자동으로 https://is2js.github.io/blog_raw/ 로 생성된다. | . | . | 조금 기다리면, Pull Request가 자동으로 올라온다. . link클릭으로 create/clone repo + PR으로 설치까지 자동화된 것임. . | PR로 온 Initial Setup부분을 보자. merge전에 1,2,3번은 순서대로 직접 작동시켜야한다. . 1. ctrl+클릭으로 this uility를 클릭 &gt; RSA - 4096 클릭 &gt; 생성된 key 그대로 복사 . Private Key . --BEGIN RSA PRIVATE KEY-- . Publick key . ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCGIVY8FQf9x1Y52HUUJmpAyOfrzH96K4QtGb7 . | 2.도 컨트롤+클릭해서 1.에서 생성한 ssh key를 붙혀넣어 Action secret key를 만든다. . actions secrets 부분에 New repository secret을 클릭해서 붙혀넣음. Name : SSH_DEPLOY_KEY | Value : SSH RSA 4096 private key 복붙 | . | . | 3. 도 컨트롤+클릭해서 fastpages-blog의 Deploy (public) key를 생성해야한다. Add deploy key클릭 . 여기서는 생성한 ssh RSA 4096 key중에 밑에 있는 publick key를 사용한다. . Title : fastpages-blog | Key : SSH RSA 4096 public key 복붙 | [O] Allow write acess | . | . | . | . | PR 아래부분에 merge PR &gt; merge를 눌러준다. . Actions에 보면 Merge가 진행중인 것이 보인다. 2분 정도 걸림. | 다 되고나면, &lt;code&gt;탭으로 와서 맨 첫줄에 블로그 주소가 보이게 된다. | . | 2 설정해주기 . blog 타이틀 변경 . 깃헙을 다룰 줄 알면, 로컬에서 clone을 떠서 수정하면 된다. . push만 해주면, actions가 자동으로 돌아가면서 static 파일로 수정해준다. | 우리가 올린 파일 기준으로 static한 파일을 생성해준다. | . _config.yaml 수정 &gt; title 변경 &gt; commit | jupyter upload . fastpages가 만들어준 readme에 보면, writing blogs with jupyter가 있다. . 여기서는 .md or .ipynb의 파일이름 양식만 참고함. . YYYY-MM-DD-*.ipynb | . 2020-01-28-My-First-Post.ipynb 2012-09-12-how-to-write-a-blog.ipynb . | Front Matter : 내 블로그 첨에 작성된 ipynb글(Fastpages Notebook Blog Post)을 참고해서 가져다 쓴다.(공식은 너무 김) . 쥬피터 노트북 맨 위에 들어갈 markdown 양식이다. . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true - branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . | 올릴 쥬피터에 아래와 같이 작성한다. . | 노트북 이름을 바꾼다. . 2021-08-06-엑셀정리 05 캐글 1 타이타닉 - 변수별 EDA + 함수정의로 정의(upload).ipynb . | github의 _notebooks 폴더로 가서 add file &gt; 업로드 &gt; commit해보았음. . | . | . | markdown upload . 해당 폴더는 _posts다 . | 제목양식은 yyyy-mm-dd-제목.md다 . 실제로 표시되는 이름은 예제파일속 format의 title:이 실제로 포스트 제목이 된다. | _posts &gt; 예제파일.md &gt; raw를 클릭해서 내용을 복사후 &gt; add file &gt; create file | . toc: true layout: post description: A minimal example of using markdown with fastpages. categories: [markdown] title: An Example Markdown Post # Example Markdown Post ## Basic setup . | . 3. local에서 clone해와서 작업해보기 . C: jupyter_blog에 폴더를 만들고, 우클릭 &gt; 터미널 &gt; code . . | git clone https://github.com/is2js/blog_raw.git . C: jupyter_blog blog_raw에 파일 복사됨. . | vscode는 해당 폴더로 들어가야함. . cd blog_raw/ . | . | 블로그 계정(is2js)과, 컴퓨터 전체 git 계정(is3js)이 다르므로, --local로 깃 계정을 설정해준다. . 참고 | . git config --local user.name &quot;is2js&quot; git config --local user.email &quot;is2js@naver.com&quot; . vscode에서 github확장관리에서 로그인을 제공하고 있어서, 로그아웃후 is2js로 로그인했다. | . | 첫화면 수정 . index.html은 첫 화면에 대한 내용을 md형식으로 닮고 있다. | 내용을 수정하고 이미지가 필요하면, images폴더에 업로드후 사용한다. 작성글들은 이 페이지 아래 자동으로 모아진다. | . | 메뉴 추가 . . _pages/폴더에 들가면 각각의 메뉴가 md파일로 작성되어있다. . about은 md파일로 작성되어있으며, 추가 nav 메뉴는 다 md파일로 작성한다. . layout: page title: About Me permalink: /about/ . 파일명이 아니라 양식속 title이 nav메뉴에 뜨는 페이지명이 된다. | . | 404, search, tags는 html파일로 섞어서 작성되어있다. . | . | _pages/에서 파일을 하나 생성하여 메뉴를 추가한다. . about에 있는 양식을 사용한다. | 작성하고 commit해준다. | . | comment 추가 . utterances를 이용하여 깃허브로 댓글 달도록 함. | . 현재 아무 post에나 comment를 달면 is2js/blog_raw/폴더에 앱이 인스톨 안되어있다고 나옴. install_app을 클릭해서 어터런스 설치 | install을 all repo가 아니라 select해준다. 필요한 저장소마다 설치를 추가로 해주면 된다. | . | . | social comment . disqus를 이용하여 소셜 or 깃헙없이 댓글 달도록 함. | utterances설치시 생성된 _includes/utterances.html을 수정하여 스크립트로 disqus스크립트를 넣어준다. disqus는 url기준으로 댓글창을 열어준다. | url만 다르다면, 다른 댓글창이 열린다. | . | . 구글에서 disqus 검색 블로그 &gt; 로고클릭 &gt; com | . | 난 페북으로 로그인함. -&gt; get start | 선택 | i want to comment on sites | I want to install Disqus on my site | . site네임은 is2js_blog_raw로 함 . | basic버전을 subscribe now로 선택함 . | 우리는 스크립트로 넣을 거라 platform선택 없이 아래 i don&#39;t see my platform 선택 . 스크립트는 카피 해놓는다. . &lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt; &lt;script&gt; /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page&#39;s canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page&#39;s unique identifier variable }; */ (function() { // DON&#39;T EDIT BELOW THIS LINE var d = document, s = d.createElement(&#39;script&#39;); s.src = &#39;https://is2js-blog-raw.disqus.com/embed.js&#39;; s.setAttribute(&#39;data-timestamp&#39;, +new Date()); (d.head || d.body).appendChild(s); })(); &lt;/script&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;https://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; . | . | configure(next랑 똑같음) 클릭후 정보는 비워놓아도 된다. . | 4. 추가 커스텀 . 방문자 카운터 . 해당 프로젝트는 오픈소스라 작동이 안되거나 없어질 수 있음. | 키워드를 기억했다가 다른 것을 검색해서 | . 구글에서 github blog hits counter를 검색 . 최상단 hit-counter 깃허브 들어갔음. https://hits.seeyoufarm.com/ | . | . | 해당 내용을 채운다. . . | 3가지 타입으로 넣을 수 있다. 특히 embed로 넣을 수 있는 것은 노션으로도 넣을 수 있다는 말이 된다. . markdown . ![Hits](https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fis2js.github.io%2Fblog_raw&amp;count_bg=%239E9E9E&amp;title_bg=%2308445E&amp;icon=python.svg&amp;icon_color=%23E1DFDF&amp;title=%EB%B0%A9%EB%AC%B8%EC%9E%90+%EC%88%98&amp;edge_flat=false) . | html . &lt;a href=&quot;https://hits.seeyoufarm.com&quot;&gt;&lt;img src=&quot;https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fis2js.github.io%2Fblog_raw&amp;count_bg=%239E9E9E&amp;title_bg=%2308445E&amp;icon=python.svg&amp;icon_color=%23E1DFDF&amp;title=%EB%B0%A9%EB%AC%B8%EC%9E%90+%EC%88%98&amp;edge_flat=false&quot;/&gt;&lt;/a&gt; . | embed url . https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fis2js.github.io%2Fblog_raw&amp;count_bg=%239E9E9E&amp;title_bg=%2308445E&amp;icon=python.svg&amp;icon_color=%23E1DFDF&amp;title=%EB%B0%A9%EB%AC%B8%EC%9E%90+%EC%88%98&amp;edge_flat=false . | . | 이제 markdown을 index.html안에다 넣어주자. . | 5. 깃허브 잔디와 레포 페이지(git.html) 추가 . 잔디이미지는 솔루션을 통해 https://ghchart.rshah.org/is2js | . | 레포정보는 url로 접근하는 github api를 통해 레포들정보 : https://api.github.com/users/[is2js]/repos | 특정레포정보 : [https://api.github.com/repos/[is2js]/[레포명] | . | 참고자료(노션) | . 솔루션(https://ghchart.rshah.org )을 이용하여, 잔디정보를 이미지로 가져올 수 있다. . index.html에 유저이름만 적어준 이미지 url or MD을 붙혀넣어준다. . 이미지 주소 : https://ghchart.rshah.org/is2js . | 이미지태그 . &lt;img src=&quot;https://ghchart.rshah.org/is2js&quot;/&gt; or &lt;img src=&quot;https://ghchart.rshah.org/is2js&quot; /&gt;로 변경 . | 마크다운 주소 . ![잔디](https://ghchart.rshah.org/is2js &quot;https://github.com/is2js&quot;) . | . | index.html의 hits 아래에 넣고 확인해보자. . . | . | 새로운 페이지 /_pages/git.html을 만들자. . 노션에 미리 작성해둔 코드를 복붙하자. . js스크립트를 사용하기 위해 html양식으로 작성한다. github API를 script태그를 이용하여 github repo정보를 가져온 것이다. api -&gt; h2, p, a태그로 map으로 돌면서 정보출력. 원하면 태그를 바꾸면 된다. | . | is2js부분을 해당하는 githubID로 변경해서 사용하면된다. | . layout: default permalink: /gitInfo/ title: gitInfo search_exclude: true &lt;img src=&quot;https://ghchart.rshah.org/is2js&quot; alt=&quot;&quot; style=&quot;width: 660px; height: 100px;&quot;&gt; &lt;div id=&quot;repos&quot;&gt; &lt;script&gt; // 비동기 작업을 위해 async function 선언 const initRepo = async () =&gt;{ const _username = &#39;is2js&#39; // 추가할 dom선택 const repoUl = document.getElementById(&quot;repos&quot;) // headers 설명 : 깃허브에 요청할 형식 지정 let response = await fetch(&#39;https://api.github.com/users/is2js/repos&#39;, {headers:{ &#39;Accept&#39; : &#39;application/vnd.github.v3+json&#39; }}); const repoJson = await response.json() // repo받아온 내용 확인 // console.log(repoJson); // json내용을 map을 이용해 각 dom을 만들고 추가 repoJson.map((repos)=&gt;{ let h2Element = document.createElement(&quot;h2&quot;) h2Element.textContent = repos.name let pElementDesc = document.createElement(&quot;p&quot;) pElementDesc.textContent = &quot;레포설명 : &quot; + repos.description let aElementURL = document.createElement(&quot;a&quot;) aElementURL.href = repos.svn_url aElementURL.textContent = repos.svn_url //각 요소를 &lt;div id=&quot;repos&quot;&gt;에 추가 repoUl.append(h2Element) repoUl.append(pElementDesc) repoUl.append(aElementURL) repoUl.append(document.createElement(&quot;br&quot;)) }) } initRepo() &lt;/script&gt; . | . | 6. repo마다 언어 퍼센트 출력하도록 변경 . 특정 레포 : [https://api.github.com/repos/[is2js]/[레포명] . 특정레포에서 쏴주는 정보를 관찰해보기 : blog_raw . | 랭기쥐만 출력해서 보기 : blog_raw/languages . 각 언어의 line수가 출력된다. | 다 더한 뒤, 총합으로 나누고, 100을 곱해서 %를 만든다. | . { &quot;Jupyter Notebook&quot;: 12491591, &quot;HTML&quot;: 20989, &quot;JavaScript&quot;: 10532, &quot;SCSS&quot;: 9877, &quot;Shell&quot;: 5458, &quot;Python&quot;: 2772, &quot;Smarty&quot;: 1965, &quot;Ruby&quot;: 1945, &quot;Makefile&quot;: 1422, &quot;Dockerfile&quot;: 364 } . | . | . git.html의 script부분(단순정보나열)을 퍼센트까지 뿌려주도록 변경된 스크립트를 복붙해주면 된다. . 모든 line수(values)를 sumcodeline에 더해주고, 각각의 value에다 나눈 뒤, 100을 곱한다. | strong태그로 출력을 해서, h2 아래에 추가해준다. | count변수를 사용해서 불러올 repo를 5개로 지정해준다. 최대갯수는 100개다. | . // 사용한 언어를 return해주는 함수 const repoLanguage = async (repo) =&gt; { let response = await fetch( `https://api.github.com/repos/is2js/${repo}/languages`, { headers: { Accept: &#39;application/vnd.github.v3+json&#39;, }, } ); let resJson = await response.json(); let sumcodeline = Object.values(resJson).reduce((a, b) =&gt; a + b, 0); s = &#39;&#39;; for (const [key, value] of Object.entries(resJson)) { s += `${key} : ${((value / sumcodeline) * 100).toFixed(3)}% `; } return s; }; // 비동기 작업을 위해 async function 선언 const initRepo = async () =&gt; { // 추가할 dom선택 const repoUl = document.getElementById(&#39;repos&#39;); //갯수설정 const count = 5; // headers 설명 : 깃허브에 요청할 형식 지정 let response = await fetch( &#39;https://api.github.com/users/is2js/repos?&#39; + &#39;per_page=&#39; + count, { headers: { Accept: &#39;application/vnd.github.v3+json&#39;, }, } ); const repoJson = await response.json(); // repo받아온 내용 확인 // console.log(repoJson); // json내용을 map을 이용해 각 dom을 만들고 추가 // repoLanguage 함수의 비동기 작업을 위한 async function선언 repoJson.map(async (repos) =&gt; { let h2Element = document.createElement(&#39;h2&#39;); h2Element.textContent = repos.name; let pElementDesc = document.createElement(&#39;p&#39;); pElementDesc.textContent = &#39;레포설명 : &#39; + repos.description; let aElementURL = document.createElement(&#39;a&#39;); aElementURL.href = repos.svn_url; aElementURL.textContent = repos.svn_url; //사용한 언어 불러오기 let language = await repoLanguage(repos.name); let strongElementLang = document.createElement(&#39;strong&#39;); strongElementLang.textContent = &#39;사용언어 : &#39; + language.toString(); //각 요소를 &lt;div id=&quot;repos&quot;&gt;에 추가 repoUl.append(h2Element); //사용언어부분 추가 repoUl.append(strongElementLang); repoUl.append(pElementDesc); repoUl.append(aElementURL); repoUl.append(document.createElement(&#39;br&#39;)); }); }; initRepo(); . | latex 사용 on . _config.yml에서 LaTex 적용이 default가 true가 아니라서 아래와 같이 _config.yml 파일에 use_math 옵션을 true로 변경해주시면 됩니다. . use_math: true . | 구조 . ### . index.html : 첫 화면에 대한 내용을 md형식으로 닮고 있지만, html파일임. . ``/images/diagram.png “https://github.com/fastai/fastpages”) . . ``은 나중에 is2js.github.io/blog_raw/ 폴더(깃허브 블로그 원본 폴더)로 연결된다. | . | . | _pages/ : md or html의 nav메뉴들의 모음 . about.md, search.html 등 | 추가된 md파일의 양식속 title:[ ]이 nav메뉴에 뜨는 페이지명이 된다. resume.md | git.html | . | . | images/ . 사진, favicon | . | . 커스텀 . 커스텀 도메인을 붙이는 조건 . 내 블로그는 is2js.github.io는 아니지만, github의 네임서버가 is2js.github.io.가 작동하는 것 같았다. (뒤에 . 있음) 원래는 리눅스서버의 공인ip주소를 적어줘야한다. | 하지만, github는 따로 ip주소를 제공하지 않으므로, [git_id].github.io.를 적어두고 해당폴더에서 설정과정을 추가한다. | . | . 가비아 DNS관리 페이지로 간다 dns.gabia.com | . | blog라는 서브도메인에다가 CNAME &amp; [github_id].github.io.로 레코드를 추가한다. . | 해당 fastpage 깃폴더 -&gt; settings &gt; pages로 이동한다. custom domain 부분에 dns에 등록한 서브도메인 blog.chojaseong.com을 적어준다. | 어떠한 확인과정이 있는데, 여기서 dns에 적어둔 [git_id.github.io.]에다가 현재깃폴더 배포ip를 배정시켜주는 작업을 하는 듯 싶다 | . | 밑에 https도 되도록 체크해준다. . | LOCAL 블로그폴더의 root에 CNAME이라는 파일을 만들고, 내부에 커스텀 도메인의 url만 적어준다. . CNAME . blog.chojaeseong.com . | root폴더의 _config.yml속 url 과 baseurl을 수정한다. . url: &quot;https://is2js.github.io&quot; -&gt; &quot;blog.chojaeseong.com&quot; | baseurl: &quot;/blog_raw&quot; -&gt; &quot;&quot; 아~ fastpage가 git_id.github.io아름의 레포가 아닌데도 page로 배포된 이유는 url을 git_id.github.io | baseurl을 /레포명으로 가지고 있어서 기 때문이구나. | . | 하지만, 커스텀도메인에서는 레포명까지 풀로 포함되서 github가 해당 커스텀도메인에 배포해준다. 그로 인해 baseurl은 사라진다.(빈문자열) | . | . | . | . . | _action_files폴더 속 settings.ini파일에도 baseurl이 있으니 수정해준다. 지워서 빈칸 남겨놓기 | . | 커스텀도메인으로 접속하는 순간부터, search 결과의 link들이.. 상대주소화되어 있어서, 도메인/search + 도메인/풀/주소.html 형식으로 잇슈가 있음. . search.js에서 만들어주는 a태그의 주소에 https://를 붙혀서 절대주소화 시켜 뒤에 붙지않고 바로 접속되게 한다. | . search.js . var resultLink = document.createElement(&#39;a&#39;); resultLink.classList.add(&#39;search-result&#39;); // a태그에 http:// 등이 없어서, 상대주소로 걸려서 커스텀도메인 + 다시 또 풀경로가 상대주소처럼 붙음.. // -&gt; href에 https://를 명시해주면, 상대주소가 아니라 절대주소로 인식되어 그 주소로만 간다. resultLink.setAttribute(&#39;href&#39;, &quot;https://&quot; + doc.url); //resultLink.setAttribute(&#39;target&#39;, &quot;_blank&quot;); . . |",
            "url": "blog.chojaeseong.com/fastpages/2021/08/06/fastpages%EB%A1%9C_%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%A0%9C%EC%9E%91.html",
            "relUrl": "/fastpages/2021/08/06/fastpages%EB%A1%9C_%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%A0%9C%EC%9E%91.html",
            "date": " • Aug 6, 2021"
        }
        
    
  
    
        ,"post174": {
            "title": "Notebook posting example(title)",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "blog.chojaeseong.com/example/2021/08/05/test.html",
            "relUrl": "/example/2021/08/05/test.html",
            "date": " • Aug 5, 2021"
        }
        
    
  
    
        ,"post175": {
            "title": "markdown 사용법",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . `![](/images/logo.png &quot;fast.ai&#39;s logo&quot;)` . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "blog.chojaeseong.com/example/markdown/2021/08/05/markdown.html",
            "relUrl": "/example/markdown/2021/08/05/markdown.html",
            "date": " • Aug 5, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "준비중입니다. .",
          "url": "blog.chojaeseong.com/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "",
          "content": "공사중입니다(template).. 자세한 정보는 github.com/is2js . 데이터엔지니어로서의 역량 . Data Engineer란? . Data관련 직군 출저 : Youtube-indiflex | . 프로젝트 . python를 활용한 진료보조프로그램들 한방병원 진료기록부(ipywidget, panel) | 초진기록지(ipywidget) | 환자 티칭 프로그램(ipywidget) | 동료선생님들 거주지역 확진자수 알림(flask, GCP, jandi) | . | Class를 활용한 CLI blog (CRUD) | NLP 분석 Packages | . | 사람인 공고 수집 크롤링 프로젝트 - 크롤링 심화 프로젝트 | . | 데이터 분석 프로젝트 . 나만의 데이터분석 노트 gitbook(Updating~) | 나만의 데이터분석(EDA) 패키지 -Cho Package : numpy, pandas, matplotlib, seaborn . | 논문작성을 위한 한의학 박사들의 설문지 분석후 ROC커브 작성 [노트] | DL논문 작성을 위한 image전처리, DL, ROC커브 작성 [노트] | 관심기업 과제와 유사한 데이터 분석 프로젝트 [노트] 관심기업 과제 pandas to SQL | . | inflearn Pipeline . | 멋쟁이사자 X Naver 연계 프로그램 - clovar API이용 프로젝트 | | Flask 프로젝트 게시판 : Docker, MongoDB, Flask, JQuery | 질답앱 : | 대쉬보드 | like finterest 메모대쉬보드 | . | FastAPI 프로젝트 API : | . | Algorithm &amp; Pythonic . Pythonic Python 정리 및 회고 [노트, 출저-프로그래머스] | 알고리즘 패러다임 및 연습문제 풀이 [저장소], 출저-Codeit] | 알고리즘 자료구조 및 연습문제 풀이[노트, 출저-프로그래머스] | 알고리즘 고득점 kit 연습문제 풀이[노트, 출저-프로그래머스] | Python 고급 [저장소] | DataAnalyst . DS스쿨 - DL반 수료 | DS스쿨 - ML반 수료 | FastCampus - 논문작성을 위한 R 통계 수료 | DL(cnn)을 활용한 독성약재감별 논문작성 논문 | 논문 작성을 위한 설문지 분석후 ROC커브 작성 [노트] | 관련 프로젝트 in 고려대 [노트, 프로젝트] | . | penguin package를 활용한 통계분석 정리[노트] | 고려대 빅데이터 청년인재 수료 NLP | Vision | ML, DL | . | Data Engineer . DS스쿨 - Pandas 데이터분석반 수료 | FastCampus - 전처리CAMP 수료 | Udemy - The Complete Python &amp; PostgreSQL Developer Course 수료 | DataCamp - Data Engineering for Everyone 수료 | DB &amp; SQL . DAP자격대비 데이터 모델링 스터디[노트, 출저-데이터와사람들] | SQL 데이터 분석[노트, 출저-책] | SQL, Bigquery를 이용한 코호트 분석[노트, 출저-탈잉] | MySQL 심화[노트, 출저-SSAC] | Postgresql tutorial 4hour[노트, 출저-FreeCodeCamp] | Postgresql for DataEngineer[노트, 출저-itversity] | Postgrsql &amp;Python course[노트, 출저-udemy] | SQL vs Pandas 비교정리[노트, 출저-조재성] | mongoDB for 데이터수집[노트, 출저-멋쟁이사자처럼, 그외] | SQLAlchemy . 2.0과 이전버전 비교 및 튜토리얼[노트, 출저-Youtube] | SQLAlchemy - pandas 비교 튜토리얼[노트] | Infra . 운영체제 공부[ 노트, 출저 - 정보처리기사 및 유튜브 ] | PowerShell vs BashShell 다빈도 명렁어 정리[노트, | Docker 기본 문법[노트, 출저-Indiflex] | Docker &amp; Ncloud[노트, 출저-SSAC] | Linux 기본[노트, 출저-Indiflex] 출저-드림코딩] | git 기본 | git flow | Frontend . HTML, CSS, JAVASCRIPT로 모던 웹페이지 만들기[프로젝트] | Javasctip와 TypeScript 정리 | React | Vue |",
          "url": "blog.chojaeseong.com/_pages/edustudy.html",
          "relUrl": "/_pages/edustudy.html",
          "date": ""
      }
      
  

  

  

  
      ,"page5": {
          "title": "",
          "content": "공사중입니다…(template) 제시한 정보는 github.com/is2js . 기본정보 . Photo Future . | | . Name | 조재성 | . - Chinese | 趙在聖 | . - English | ChoJaeSeong | . Age | 1987 | . Birth Day | 1987.12.18 | . Email | tingstyle1@gmail.com | . Mobile | xxx-46xx-62xx | . 신상정보 . Profile Content . Address | 서울시 관악구 | . Married | 미혼 | . Family | 2남 1녀 | . Blood type | RH+ O | . Religion | 없음 | . 학력정보 . Level School Name Major Start End Status 최종학력 . University | DongShin University | Korean Medicine | YYYY.MM | YYYY.MM | graduated | 최종 | . High School | NamHae High School |   | YYYY.MM | YYYY.MM | graduated |   | . 직장이력 . Period Company Part &gt; Team . 2011.10 - 2013.4 | Company Inc | R&amp;D &gt; Mobile | . 2010.05 - 2011.9 | Company Corp | Big Data &gt; Visualize | . 2008.08 - 2010.3 | Venture | Web &gt; UI | . 2007.02 - 2008.8 | Company Name | Marketing 3 | . 오픈소스 프로젝트 (2012.03 ~ 현재) . 프로젝트 공식 명칭 . 소개 프로젝트에 대한 간략한 소개를 한다. . | 주요기능 주요 기능을 일일이 상세히 나열한다. | . | 사용기술 . 사용된 기술을 상세히 나열한다. | . | 개발기간 : 2013.2.3 을 시작으로 최근까지 xxx 커밋 | 공식 사이트 - http://rhiokim.github.io/resume | 소스 저장소 - https://github.com/rhiokim/resume | . | 마크다운 이력서 표준화 프로젝트 . 소개 . 이력서에 대한 몇가지 불편한 마음을 개선하고자 마크다운 이력서 표준화 프로젝트를 시작한다. . 개발자를 잘 표현할 이력서 양식이 없다. | 2,3 년에 한번씩 업데이트 해야하는 이력서 너무 힘들다. | 이력서 양식이 도구에 너무 의존적이다. | | 주요기능 . 마크다운으로 기술한다. | PDF, HTML, EPUB, Mobi 등 다양한 포맷으로 변환할 수 있다. | 개발자를 잘 표현할 수 있다. | . | 사용기술 마크다운. . | 개발기간 : 2012.3 을 시작으로 약 6개월에 걸쳐 500여 커밋 | 공헌자 : https://github.com/rhiokim/resume/contributors | 공식 사이트 - http://rhiokim.github.io/resume | 소스 저장소 - https://github.com/rhiokim/resume | . | . 기타 공개/비공개 프로젝트 . 프로젝트 명 추가 설명 : https://vimeo.com/51812784 | . | . 진행중인 프로젝트 (2013.04 ~ 현재) . 프로젝트 명 소개 모바일 앱으로 현재 3명의 멤버가 개발 진행 중 . | 사용기술 Node.js, Mongodb, APNS(Apple Notification), Gumby2 (Responsive CSS Framework) . | 역할 RESTful API 디자인, 시스템(Node.js, Mongodb, APNS) 엔지니어링, 웹 사이트 개발 . | . | . 참여한 프로젝트 이력 . 회사명 1 . 프로젝트 소개 프로젝트에 대한 간략한 소개를 한다. . | 역할 자기가 참여한 프로젝트에서 했던 역할에 대해서 기술한다. | . | 사용기술 Backbone.js, jQuery, require.js, grunt.js, twitter bootstrap, Node.js 등 | . | 개발기간: 12개월 | 공식 사이트: https://project.com | 소스 저장소: https://github.com/company/project | . | . 회사명 2 . 프로젝트 소개 프로젝트에 대한 간략한 소개를 한다. . | 역할 자기가 참여한 프로젝트에서 했던 역할에 대해서 기술한다. | . | 사용기술 Backbone.js, jQuery, require.js, grunt.js, twitter bootstrap, Node.js 등 | . | 개발기간: 6개월 | 공식 사이트: https://project.com | 소스 저장소: https://github.com/company/project | . | . 대외 활동 내역 . 커뮤니티 . 커뮤니티명 주제 관련 참고 자료 . 2010.05 | Title | http://slidesha.re/xxxxxx | . 2010.10 | Title | http://scr.bi/xxxxxxx | . 세미나 . 행사 / 모임 주제 규모 관련 참고 자료 . XX R&amp;D Campus | 1. subject 1 | 30 | http://bit.ly/xxxxxx | . 2. subject 2 |   | http://bit.ly/xxxxxx |   | . 컨퍼런스, 강연 . 행사 / 모임 주제 규모 관련 참고 자료 . Conference | Title | 250 | http://bit.ly/xxxxxx | . Conference | Title | 1,000 | http://bit.ly/xxxxxx | . 소셜 . Site URL . Github | https://github.com/{account} | . Twitter | https://twitter.com/{account} | . Facebook | https://facebook.com/{account} | . . 위의 사실은 GNU 정신에 의거하여 사실임을 증명하며, 만약 사실이 아닐 경우 MIT 라이센스로 공개해도 무방합니다. . YYYY년 MM월 DD일 {홍길동} .",
          "url": "blog.chojaeseong.com/_pages/resume.html",
          "relUrl": "/_pages/resume.html",
          "date": ""
      }
      
  

  
  

  

  
  

  

  
  

  

  

  

  

  

  

  

  

  
  

}