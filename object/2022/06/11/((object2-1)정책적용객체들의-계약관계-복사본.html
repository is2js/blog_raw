<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>OBJECT 17 정책적용 객체들의 계약관계 | 돌범텤놑</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="OBJECT 17 정책적용 객체들의 계약관계" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="object 책을 강의한 코드스핏츠 유튜브 요약" />
<meta property="og:description" content="object 책을 강의한 코드스핏츠 유튜브 요약" />
<link rel="canonical" href="https://blog.chojaeseong.com/object/2022/06/11/((object2-1)%EC%A0%95%EC%B1%85%EC%A0%81%EC%9A%A9%EA%B0%9D%EC%B2%B4%EB%93%A4%EC%9D%98-%EA%B3%84%EC%95%BD%EA%B4%80%EA%B3%84-%EB%B3%B5%EC%82%AC%EB%B3%B8.html" />
<meta property="og:url" content="https://blog.chojaeseong.com/object/2022/06/11/((object2-1)%EC%A0%95%EC%B1%85%EC%A0%81%EC%9A%A9%EA%B0%9D%EC%B2%B4%EB%93%A4%EC%9D%98-%EA%B3%84%EC%95%BD%EA%B4%80%EA%B3%84-%EB%B3%B5%EC%82%AC%EB%B3%B8.html" />
<meta property="og:site_name" content="돌범텤놑" />
<meta property="og:image" content="https://blog.chojaeseong.com/images/posts/java.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-06-11T00:00:00-05:00" />
<script type="application/ld+json">
{"datePublished":"2022-06-11T00:00:00-05:00","url":"https://blog.chojaeseong.com/object/2022/06/11/((object2-1)%EC%A0%95%EC%B1%85%EC%A0%81%EC%9A%A9%EA%B0%9D%EC%B2%B4%EB%93%A4%EC%9D%98-%EA%B3%84%EC%95%BD%EA%B4%80%EA%B3%84-%EB%B3%B5%EC%82%AC%EB%B3%B8.html","@type":"BlogPosting","image":"https://blog.chojaeseong.com/images/posts/java.png","headline":"OBJECT 17 정책적용 객체들의 계약관계","dateModified":"2022-06-11T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chojaeseong.com/object/2022/06/11/((object2-1)%EC%A0%95%EC%B1%85%EC%A0%81%EC%9A%A9%EA%B0%9D%EC%B2%B4%EB%93%A4%EC%9D%98-%EA%B3%84%EC%95%BD%EA%B4%80%EA%B3%84-%EB%B3%B5%EC%82%AC%EB%B3%B8.html"},"description":"object 책을 강의한 코드스핏츠 유튜브 요약","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<!-- 폰트추가를 위한 link태그 삽입 -->
  <!-- 폰트1:  기본 spoqa 웹폰트 -->
  <!-- css에서 * {} 다 뒤집어씀. -->
  <link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSansNeo.css' rel='stylesheet' type='text/css'>
  <!-- 폰트2:  블로그 제목들 sunflower 웹폰트 -->
  <!-- 쥬피터 등 포스트 내부 글자 h1, h2 제목은 sunflower체 도입 -->
  <link href="//fonts.googleapis.com/css?family=Sunflower:300,500,700" rel="stylesheet"> 

  <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://blog.chojaeseong.com/feed.xml" title="돌범텤놑" /><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">돌범텤놑</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About Me</a><a class="page-link" href="/search/">Search</a><a class="page-link" href="/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">OBJECT 17 정책적용 객체들의 계약관계</h1><p class="page-description">object 책을 강의한 코드스핏츠 유튜브 요약</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-06-11T00:00:00-05:00" itemprop="datePublished">
        Jun 11, 2022
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      18 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/categories/#object">object</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <!-- toc가 먼저 나오므로 h3로 안내하기 -->
    <h3>📜 제목으로 보기</h3>
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#계약에-의한-설계">계약에 의한 설계</a>
<ul>
<li class="toc-entry toc-h3"><a href="#계약의-조건-4가지">계약의 조건 4가지</a></li>
<li class="toc-entry toc-h3"><a href="#01-불변성invariant-검증">01 불변성(invariant) 검증</a>
<ul>
<li class="toc-entry toc-h4"><a href="#plan">Plan</a>
<ul>
<li class="toc-entry toc-h5"><a href="#문제점과-해결객체-필드-상태null---setter호출-이전에-빈값으로-초기화">문제점과 해결(객체 필드 상태null -&gt; setter호출 이전에 빈값으로 초기화)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#02-사전조건precondition-검증---인자값-검증전처리">02 사전조건(precondition) 검증 - 인자값 검증(전처리)</a>
<ul>
<li class="toc-entry toc-h4"><a href="#plan-1">plan</a>
<ul>
<li class="toc-entry toc-h5"><a href="#문제점과-해결인자null-or-인자의-상태null---if로무시with불린flag토하기with기존값사용가능확인--or--if-thrwith메세지로통보">문제점과 해결(인자null or 인자의 상태null -&gt; if로무시With불린flag토하기with기존값사용가능확인  or  if thrWith메세지로통보)</a></li>
<li class="toc-entry toc-h5"><a href="#사전조건-검증null인자에-대한-정책-31가지-정리">사전조건 검증(null인자)에 대한 정책 3+1가지 정리</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#03-사후조건postcondition-검증---받아온-결과값-검증후처리">03 사후조건(postcondition) 검증 - (받아온) 결과값 검증(후처리)</a>
<ul>
<li class="toc-entry toc-h4"><a href="#plan-2">plan</a>
<ul>
<li class="toc-entry toc-h5"><a href="#문제점과-해결결과값-검증---도메인의-영역이다">문제점과 해결(결과값 검증 -&gt; 도메인의 영역이다.)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#계약별-책임할당">계약별 책임할당</a>
<ul>
<li class="toc-entry toc-h3"><a href="#사전계약조건-책임할당">사전계약조건 책임할당</a>
<ul>
<li class="toc-entry toc-h4"><a href="#precondition1-자신의-상태null-인자null체크는-상대방에게-위임할-수-없다">precondition1) 자신의 상태null, 인자null체크는 상대방에게 위임할 수 없다.</a></li>
<li class="toc-entry toc-h4"><a href="#precondition2-인자의-상태nullemtpy체크는--해당-객체인자가-자신상태validation메소드를-제공해주는데">precondition2) 인자의 상태null/emtpy체크는?  해당 객체인자가 자신상태validation메소드를 제공해주는데?</a>
<ul>
<li class="toc-entry toc-h5"><a href="#isempty는-간접적으로-내장을-까는-메소드-물어보고-행동하면-변화시의-여파가-찾아온다-검증도-스스로-죽어라고-시킨다위임">isEmpty()는 간접적으로 내장을 까는 메소드. &lt;물어보고 행동하면, 변화(시)의 여파가 찾아온다. 검증도 스스로 죽어라고 시킨다(위임)&gt;</a></li>
<li class="toc-entry toc-h5"><a href="#if로무시with불린flag보다-thr로-멈추게하면-좋은-점">if로무시with불린Flag보다 thr로 멈추게하면 좋은 점</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#사후계약조건-책임할당">사후계약조건 책임할당</a>
<ul>
<li class="toc-entry toc-h4"><a href="#postcondition1-this가-필요없는-결과값-검증this조차-받아가는-객체은-결과계산-위임객체에게-계산후-검증도-위임한다">postcondition1) this가 필요없는 결과값 검증(this조차 받아가는 객체)은, 결과계산 위임객체에게 계산후 검증도 위임한다.</a>
<ul>
<li class="toc-entry toc-h5"><a href="#사전사후계약조건-검증-중에-내-contextthis-보라색변수를-통한-검증이-아니면-검증도-물어보지말고-스스로-죽도록-시킨다위임">사전/사후계약조건 검증 중에 내 context(this, 보라색변수)를 통한 검증이 아니면, 검증도 물어보지말고 스스로 죽도록 시킨다.(위임)</a></li>
<li class="toc-entry toc-h5"><a href="#prepostcondition-검증책임은-대부분-위임받은-객체들이-가져가야하며-인자결과값로직의-검증-코드가-안보인다면-이미-계약관계라고-판단한다">pre/postcondition 검증책임은 대부분 위임받은 객체들이 가져가야하며, 인자/결과값로직의 검증 코드가 안보인다면, 이미 계약관계라고 판단한다.</a></li>
<li class="toc-entry toc-h5"><a href="#precondition은-내가받은쪽이-발동할게-postcondition은-니위임객체가-처리해와">precondition은 내가(받은쪽이) 발동할게, postcondition은 니(위임객체)가 처리해와</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#협력을-통한-책임분할">협력을 통한 책임분할</a>
<ul>
<li class="toc-entry toc-h3"><a href="#postcondition검증인-결과값-검증에-외부인자-검증이-포함되어있는데-검증-통과못하면-계산의-의미가-없는-경우-애초에-오염되지-않은-인자만-넘어오는게-더-좋다">postcondition검증인 결과값 검증에 외부인자 검증이 포함되어있는데, 검증 통과못하면 계산의 의미가 없는 경우, 애초에 오염되지 않은 인자만 넘어오는게 더 좋다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#런타임에-의한-계약조건">런타임에 의한 계약조건</a>
<ul>
<li class="toc-entry toc-h3"><a href="#setter가-있어-생성시점에-불변을-보장못하는-상태변화하는-객체-인자는-인자의-상태검증-발동을-precondition에-위치시켜선-안되고-실제-계산에-사용될-때마다-매번-스스로-검증하도록-메세지-처리전-invariant를-스스로-걸어야한다">setter가 있어 생성시점에 불변을 보장못하는, 상태변화하는 객체 인자는, 인자의 상태검증 발동을 precondition에 위치시켜선 안되고, 실제 계산에 사용될 때마다 매번 스스로 검증하도록 메세지 처리전, invariant를 스스로 걸어야한다.</a>
<ul>
<li class="toc-entry toc-h4"><a href="#calculator-plan">Calculator, Plan</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#다시-precondition">다시 precondition</a>
<ul>
<li class="toc-entry toc-h4"><a href="#calculator">Calculator</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#계약의-전파">계약의 전파</a>
<ul>
<li class="toc-entry toc-h3"><a href="#package가시성으로-precondition검증을-생략하기">package(가시성)으로 precondition검증을 생략하기</a>
<ul>
<li class="toc-entry toc-h4"><a href="#좋은-인자들이-검증없이-전파-유지되기-위해서는-이미-앞에서-검증이-끝난-인자라면-호출하는-주체가-계약-맺는-놈만-public이-아니어야">좋은 인자들이 검증없이 전파 유지되기 위해서는,,, 이미 앞에서 검증이 끝난 인자라면, 호출하는 주체가 계약 맺는 놈만… public이 아니어야..</a>
<ul>
<li class="toc-entry toc-h5"><a href="#pricepertime">PricePerTime</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#precondition메서드-인자이-검증이-없어서-찾아보는-원천-인자">precondition(메서드 인자)이 검증이 없어서 찾아보는 원천 인자</a></li>
<li class="toc-entry toc-h4"><a href="#좋은-인자로-전파가-시작됬다면-문제는-package와-접근제한자에-있다">좋은 인자로 전파가 시작됬다면, 문제는 package와 접근제한자에 있다</a></li>
<li class="toc-entry toc-h4"><a href="#계약체인을-보장하는-방법은-package구성을-통한-가시성-밖에-없다">계약체인을 보장하는 방법은 package구성을 통한 가시성 밖에 없다.</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#가시성을-위해-포기한-인터페이스로-인해-등장한-안좋은-부모">가시성을 위해 포기한 인터페이스로 인해 등장한 안좋은 부모</a>
<ul>
<li class="toc-entry toc-h4"><a href="#문제점과-해결">문제점과 해결</a></li>
<li class="toc-entry toc-h4"><a href="#계약관계라-할지라도-좋은부모자식의-protected관계라면-패키지를-이동시킬-수-있다">계약관계라 할지라도, 좋은부모자식의 protected관계라면, 패키지를 이동시킬 수 있다.</a></li>
<li class="toc-entry toc-h4"><a href="#계약관계에-의한-package-최종-구성">계약관계에 의한 package 최종 구성</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#postcondition검사는">postcondition검사는?</a>
<ul>
<li class="toc-entry toc-h4"><a href="#condition검사할-때-메세지-처리전-상태필드들의-invariant뿐만-아니라-postcondition검사-이전에-로직에-사용된-보라색-필드들에도-주목해야한다">condition검사할 때, 메세지 처리전 상태(필드)들의 invariant뿐만 아니라, postcondition검사 이전에, 로직에 사용된 보라색 필드들에도 주목해야한다.</a></li>
<li class="toc-entry toc-h4"><a href="#다시-postcondition검사로">다시 postcondition검사로</a></li>
</ul>
</li>
</ul>
</li>
</ul><ul>
  <li>참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk</li>
  <li>정리본: https://github.com/LenKIM/object-book</li>
  <li>코드: https://github.com/eternity-oop/object</li>
  <li>
    <p>책(목차) : https://wikibook.co.kr/object/</p>
  </li>
  <li>참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk</li>
  <li>정리본: https://github.com/LenKIM/object-book</li>
  <li>코드: https://github.com/eternity-oop/object</li>
  <li>
    <p>책(목차) : https://wikibook.co.kr/object/</p>
  </li>
  <li>책 12장은 range bind 개념으로 여기선 건너띈다.</li>
  <li>13장 contract와 관련된 개념을 다룬다.</li>
</ul>

<h2 id="계약에-의한-설계">
<a class="anchor" href="#%EA%B3%84%EC%95%BD%EC%97%90-%EC%9D%98%ED%95%9C-%EC%84%A4%EA%B3%84" aria-hidden="true"><span class="octicon octicon-link"></span></a>계약에 의한 설계</h2>

<ul>
  <li>계약은 짠 코드가 장난감인지 vs 제품인지 판가름하게 된다.
    <ul>
      <li>계약하지 않는 코드는, 돌아가게 스냅샷만 짜서, 장난감 코드가 대부분이다.</li>
    </ul>
  </li>
  <li>단위테스트를 안걸어도 안정적인 코드를 짜려면??
    <ul>
      <li>계약에 의한 프로그래밍으로 경우의 수가 없어야한다.</li>
      <li>경우의 수가 있는 코드들은, 그만큼만 커버해서, 다른 경우의수에 불안정하다</li>
    </ul>
  </li>
</ul>

<h3 id="계약의-조건-4가지">
<a class="anchor" href="#%EA%B3%84%EC%95%BD%EC%9D%98-%EC%A1%B0%EA%B1%B4-4%EA%B0%80%EC%A7%80" aria-hidden="true"><span class="octicon octicon-link"></span></a>계약의 조건 4가지</h3>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712111915576.png" alt="image-20220712111915576"></p>

<ul>
  <li>객체지향의 세계에서는 메세지를 통해 계약한다.
    <ul>
      <li>메세지를 보내는 sender</li>
      <li>메세지를 받는 receiver사이에 <strong>더 상세한 내용이 계약으로 있다.</strong>
        <ul>
          <li>범위, 시간, 등 다 계약으로 정해놔야한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<ol>
  <li>전달받은 메세지의 규격 = precondition을 지켜줘야한다.
    <ul>
      <li><strong>sender가 규격을 지켜서 보내진 않는다.</strong></li>
      <li><strong>precondition검증은 receiver가 한다.</strong></li>
      <li><strong>우리는 receiver가 메세지를 전달받아 규격(precondition)을 검증하는 것을 기본정책으로 하고 있다. 안맞으면 안받는다.</strong></li>
    </ul>
  </li>
  <li>전달할 메세지의 규격(postcondition)
    <ul>
      <li>receiver가 받아 검증했지만, <strong>자기가 보낼 것도 receiver 안에서 검증</strong>해야한다.</li>
      <li>
<strong>receiver는 내 결과물을 상대방에 전달하기 전에 검증</strong>해야한다.</li>
    </ul>
  </li>
  <li>객체 자신의 규격(class invariant)
    <ul>
      <li>객체는 원래 상태를 가지는데, <strong>메세지를 받았을 때, 특정 필드값을 만족할 때만 제대로 메세지가 처리된다.</strong>
</li>
      <li>
<strong>메세지를 받기 이전에, 불변성invariant 검증이 되어있어야한다.</strong>
        <ul>
          <li><strong>내 상태조건이 변하지 않도록 확정되어서 메세지 처리가 가능한지 검증</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>위임된 책임의 context
    <ul>
      <li><strong>내가 하는 짓이 이 context가 맞는지</strong></li>
    </ul>
  </li>
</ol>

<ul>
  <li>4가지 조건이 다 만족되어야 계약이 가능하다.</li>
</ul>

<h3 id="01-불변성invariant-검증">
<a class="anchor" href="#01-%EB%B6%88%EB%B3%80%EC%84%B1invariant-%EA%B2%80%EC%A6%9D" aria-hidden="true"><span class="octicon octicon-link"></span></a>01 불변성(invariant) 검증</h3>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712112918519.png" alt="image-20220712112918519"></p>

<ul>
  <li>
<strong>메세지를 주고 받기 전</strong>에, <strong>(setter등으로 상태가 변화한다면 thr로) 객체 자신은 불변성 검증을 통해 불변성을 확보</strong>해야 메세지 처리가 가능하다</li>
  <li>
<strong>객체 초기상태, 객체 메세지 수신 전 상태가 확립</strong>되어야한다.
    <ul>
      <li>
<strong>메세지와 무관한 객체의 상태</strong>는 <strong>필드값</strong>이다.
        <ul>
          <li>메세지는 인자값(pre) or 리턴값(post) or 지역변수들(post)로 이루어진다.</li>
        </ul>
      </li>
      <li><strong>필드값들을 제대로 갖고 있는지 상태 점검 해야한다</strong></li>
      <li>
<strong>초기화 할당해서 확보</strong> or <strong>DI로 위임해서 꽂아서 확보</strong>하던지 해야한다.
        <ul>
          <li>객체 초기화는 프로그래머 역량에 달려있어서 믿을 수 없다. solution, computer에게 DI로 맡기자</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="plan">
<a class="anchor" href="#plan" aria-hidden="true"><span class="octicon octicon-link"></span></a>Plan</h4>

<ul>
  <li>
    <p>기존</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712113109006.png" alt="image-20220712113109006"></p>

    <ul>
      <li>하나의 요금제를 감당하고 있는 Plan은 set으로 calls통화기록를 받아서 가지고 있다.</li>
      <li>이 calls를, 전략주입 구상클래스에게 넘겨줘서 계산책임을 위임하고, 결과를 받는다.</li>
      <li>private필드, final을 준수하고 있으니 확장가능(상속을 해줘도) 안전하다</li>
    </ul>
  </li>
</ul>

<h5 id="문제점과-해결객체-필드-상태null---setter호출-이전에-빈값으로-초기화">
<a class="anchor" href="#%EB%AC%B8%EC%A0%9C%EC%A0%90%EA%B3%BC-%ED%95%B4%EA%B2%B0%EA%B0%9D%EC%B2%B4-%ED%95%84%EB%93%9C-%EC%83%81%ED%83%9Cnull---setter%ED%98%B8%EC%B6%9C-%EC%9D%B4%EC%A0%84%EC%97%90-%EB%B9%88%EA%B0%92%EC%9C%BC%EB%A1%9C-%EC%B4%88%EA%B8%B0%ED%99%94" aria-hidden="true"><span class="octicon octicon-link"></span></a>문제점과 해결(객체 필드 상태null -&gt; setter호출 이전에 빈값으로 초기화)</h5>

<ol>
  <li>
    <p><strong>주입받을 calculator필드는 초기값이 null이다.</strong> 
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712113445989.png" alt="image-20220712113445989"></p>

    <ol>
      <li><strong>setter를 호출하지 않았따면, calculateFee호출시 NP에러가 날 것이다.</strong></li>
      <li>그러나 대외적인 인터페이스(class signature)를 보면, <strong>thr가 안달려있어서, 예외가 발생할 것이라 예상도 할 수 없다.(보고서 정상작동 하지 않을 것이라는 생각을 할 수도 없다)</strong>
</li>
      <li>Calculator 내부를 보면, 
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712114046938.png" alt="image-20220712114046938">
        <ol>
          <li>부분적인 계산체인을 위한 calcs라는 전략객체 컬렉션 필드를 소유하고 있고</li>
          <li>위임받은 책임인 calcCallFee를 보면, calls는 한꺼번에 받고, 초기값을 받아서, 누적해서 결과물을 낸다.</li>
          <li><strong>즉, 자신이 계산하는 것이 아니라, 자신 소유 전략객체들을 계산합으로 결과물을 내어준다.</strong></li>
        </ol>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>calculator는 <code class="language-plaintext highlighter-rouge">생성</code>자에 받아야하는 <code class="language-plaintext highlighter-rouge">조건</code>이 없으므로 <code class="language-plaintext highlighter-rouge">null초기화로 인해 없는 상태를 방지</code>하기 위해서 <code class="language-plaintext highlighter-rouge">객체를 미리 넣어주는 방법으로 안정성을 확보</code>할 수 있다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712114414774.png" alt="image-20220712114414774"></p>
    <ul>
      <li>또한, calculateFee()의 calls 역시 미리 초기화된 상태라, 에러날 일이 없다</li>
    </ul>
  </li>
  <li>
    <p><strong>필드에 대해 유효한 초기화 방법은 <code class="language-plaintext highlighter-rouge">필드 초기화 or 생성자</code>로 할당하여 <code class="language-plaintext highlighter-rouge">NULL대신 NULL을 대신할 수 있는 empty객체를 할당</code>해주는 것이다.</strong></p>
  </li>
</ol>

<h3 id="02-사전조건precondition-검증---인자값-검증전처리">
<a class="anchor" href="#02-%EC%82%AC%EC%A0%84%EC%A1%B0%EA%B1%B4precondition-%EA%B2%80%EC%A6%9D---%EC%9D%B8%EC%9E%90%EA%B0%92-%EA%B2%80%EC%A6%9D%EC%A0%84%EC%B2%98%EB%A6%AC" aria-hidden="true"><span class="octicon octicon-link"></span></a>02 사전조건(precondition) 검증 - 인자값 검증(전처리)</h3>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712114708054.png" alt="image-20220712114708054"></p>

<ul>
  <li>사전조건은 일반적으로 validation이라 부르며, 다른 언어들에서는 required라고도 부른다.
    <ul>
      <li>넘어가기전에 위에서 검증하고 가</li>
      <li>white list 이론: 38선을 경계로 위에서 방역/검증하고, 밑에서는 valdiation로직 없이 깨끗한 white list영역으로 취급한다.
        <ul>
          <li>모든 인자들이나 검증되지 않는 값들을 위에서 검증하여 white list를 만든 뒤, 로직을 전개한다.</li>
          <li>if로 return으로 짤라버리는 쉴드패턴</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>메세지로 받는 값을 스스로 검증한다.</li>
  <li>내가 직접검증안하고, 형으로도 검증할 수 있다.
    <ul>
      <li>VO Money가 대표적인 예. Money클래스를 브릿지로 써서, integer를 중간에 형을 더 만들어서 안정성/불변성을 확보하는 형태</li>
      <li>검증때문에 한번더 감싸는 것</li>
    </ul>
  </li>
</ul>

<h4 id="plan-1">
<a class="anchor" href="#plan-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>plan</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712154225367.png" alt="image-20220712154225367"></p>

<h5 id="문제점과-해결인자null-or-인자의-상태null---if로무시with불린flag토하기with기존값사용가능확인--or--if-thrwith메세지로통보">
<a class="anchor" href="#%EB%AC%B8%EC%A0%9C%EC%A0%90%EA%B3%BC-%ED%95%B4%EA%B2%B0%EC%9D%B8%EC%9E%90null-or-%EC%9D%B8%EC%9E%90%EC%9D%98-%EC%83%81%ED%83%9Cnull---if%EB%A1%9C%EB%AC%B4%EC%8B%9Cwith%EB%B6%88%EB%A6%B0flag%ED%86%A0%ED%95%98%EA%B8%B0with%EA%B8%B0%EC%A1%B4%EA%B0%92%EC%82%AC%EC%9A%A9%EA%B0%80%EB%8A%A5%ED%99%95%EC%9D%B8--or--if-thrwith%EB%A9%94%EC%84%B8%EC%A7%80%EB%A1%9C%ED%86%B5%EB%B3%B4" aria-hidden="true"><span class="octicon octicon-link"></span></a>문제점과 해결(인자null or 인자의 상태null -&gt; if로무시With불린flag토하기with기존값사용가능확인  or  if thrWith메세지로통보)</h5>

<ol>
  <li>
    <p>java는 모든 객체형에 대해 null이 가능하므로 <strong><code class="language-plaintext highlighter-rouge">NULL인자로 호출가능한 메서드</code>들의 인자로 넘어온 객체메세지를 null검사안하는 것이 맘에 안든다.</strong></p>

    <ol>
      <li>제임스고슬링이 java에서 null을 만든 것을 실수라 한 것처럼, <strong>null은 모든 메서드의 시그니쳐를 무력화시킨다.</strong>
        <ul>
          <li>null이 값이 없다는 것이 문제가 아니라, <strong>null이 만능키라서 문제</strong>
</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>첫번째 해결책: <code class="language-plaintext highlighter-rouge">언어나 컴파일러의 기능</code></strong>을 이용하여 <strong><code class="language-plaintext highlighter-rouge">인자에 @NonNull</code>같은 어노테이션을 쓰자</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712154716736.png" alt="image-20220712154716736"></p>

    <ul>
      <li>컴파일시, 컴파일러가 모든 코드를 조사해서 null이 생기면 컴파일에러로 거른다.
        <ul>
          <li><strong>컴파일 때가 아닌, 런타임상에서 null이 아닌 실제 인스턴스가 들어갈 수 있으며, 컴파일러는 런타임시점을 모르므로 제한이 있다.</strong></li>
          <li>다른 필드나 지역변수들은 null이 허용되기 때문에, @NonNull인자외에 다른변수들이 runtime시 null을 만들어서 인자에 null이 들어갈 수 있다.</li>
        </ul>
      </li>
      <li>typescript, swift, kotlin 등과 같이 애초에 null이 올수 없는 변수를 쓰는 경우에는 해결이 되는 방법이다.</li>
    </ul>
  </li>
  <li>
    <p><strong>두번째 해결책: <code class="language-plaintext highlighter-rouge">null이면 if로 무시 with 외부에서 알수 있는 boolean flag + 무시하고 기존값 써도되는지 확인 </code></strong> 
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712155307224.png" alt="image-20220712155307224"></p>

    <ol>
      <li><strong>null이면 if로 무시하고 해당로직은 슬그머니 넘어가되 최소한 boolean값으로 결과를 응답해준다. 우리가 많이 하는 선택지</strong></li>
      <li>나빠보이지만, <strong>자바컬렉션들은 add나 put시 if로 슬그머니 null을 넘어가며, 넘어간 여부를 boolean으로 대답을 해준다.</strong>
        <ol>
          <li><strong>그렇다면, <code class="language-plaintext highlighter-rouge">void가 아니라 최소한 boolean형으로 return하도록 수정</code>해야만한다. <code class="language-plaintext highlighter-rouge">외부에서 알수 있는 flag를 세워줘야한다.</code></strong></li>
          <li>
<strong>또한, <code class="language-plaintext highlighter-rouge">if로 무시할 수 있는 상태 == 실패시 기본값(add시 빈컬렉션) 이미 존재하며 그대로 사용해도 되는 상태인지 확인</code>도 해야한다.</strong>
            <ul>
              <li><strong>실패해도 기본값이 이미 초기화되어있으며, 그 것을 사용해도 되는지</strong></li>
              <li>예를 들어, setCalculator에서 if로 무시해서, 기본calc를 사용하게 되는데, 요금이 250만원 넘게 나와버리면, 기본calc는 사용하면 안되는 상황이다. <strong>이럴 경우, if로 무시하고 넘어가면 안된다.</strong>
</li>
            </ul>
          </li>
          <li><strong>근데, boolean으로 응답해줬다면, 밖에서 기존값 쓰면 안되어서 따로 처리하게 될 것이다.</strong></li>
        </ol>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>세번째해결책: <code class="language-plaintext highlighter-rouge">예외로 처리</code></strong>
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712160521184.png" alt="image-20220712160521184"></p>
    <ol>
      <li>
<strong>if로무시하며 boolean flag하는 것보다 더 강력하게, <code class="language-plaintext highlighter-rouge">null이면 예외메세지로 통보</code>하고 있다.</strong>
        <ul>
          <li><strong>참고로 <code class="language-plaintext highlighter-rouge">if로무시하며 불린flag를 바깥에 토하는 것</code>과 <code class="language-plaintext highlighter-rouge">if thr로 멈추는 것</code>둘다 runtime에서 조치할 수 있는 2가지 모든 것이다.</strong></li>
        </ul>
      </li>
      <li>
<strong>한번 <code class="language-plaintext highlighter-rouge">null에 대한 정책</code>을 thr로 태웠으면, if무시with불린flag토하기는 더이상하지말고, 다른 로직도 모두 thr를 태우도록 통일해야한다.</strong>
        <ul>
          <li>어떤 것은 불린flag토하고, 어떤 것은 thr토하면 괴롭다</li>
          <li><strong>정책을 세우면, 통일해서 일관성을 만들어야한다.</strong></li>
        </ul>
      </li>
    </ol>
  </li>
</ol>

<h5 id="사전조건-검증null인자에-대한-정책-31가지-정리">
<a class="anchor" href="#%EC%82%AC%EC%A0%84%EC%A1%B0%EA%B1%B4-%EA%B2%80%EC%A6%9Dnull%EC%9D%B8%EC%9E%90%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EC%B1%85-31%EA%B0%80%EC%A7%80-%EC%A0%95%EB%A6%AC" aria-hidden="true"><span class="octicon octicon-link"></span></a>사전조건 검증(null인자)에 대한 정책 3+1가지 정리</h5>

<ol>
  <li>
    <p>언어를 바꾸거나  <strong>애노테이션을 쓴다.</strong></p>
  </li>
  <li>
    <p><strong>if를 통해 불린flag를 리턴하거나</strong></p>
  </li>
  <li>
    <p><strong>명시적인 thr로 멈춘다.</strong></p>

    <ul>
      <li>
        <p>우리는 3번을 중심으로 한다.</p>
      </li>
      <li>
        <p><strong>모든 인자를 가진 함수에 다 써야한다.</strong> 그래서 인자가 많은 함수가 귀찮다.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>객체 메세지라면, 객체의 사용될 상태 검사(null/empty)</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712161651441.png" alt="image-20220712161651441"></p>

    <ul>
      <li>Calculator는 전략객체들을 컬렉션필드에 담고 있으므로, <strong>컬렉션 필드가 비었으면, null이나 마찬가지인 놈</strong>으로서 <strong>해당필드 empty검사</strong>를 해줘야한다.</li>
      <li>
<strong>객체는 자기자신에 대한 validation의 책임을 외부에 제공해야하므로 <code class="language-plaintext highlighter-rouge">객체가 메세지로 사용된다면, 책임수행 중에 자기자신의 상태에 대한 validation책임도 늘어난다</code></strong>
        <ul>
          <li>validation때문에 <strong>main/client에서 보이지 않는 메서드들이 늘어나는 경우로서,  <code class="language-plaintext highlighter-rouge">메세지로 들어가는 타class의 메서드 내부의 인자 사전조건 검사에 쓰이는 자기 상태검증용 메소드</code>들이 늘어난다.</strong>
</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h3 id="03-사후조건postcondition-검증---받아온-결과값-검증후처리">
<a class="anchor" href="#03-%EC%82%AC%ED%9B%84%EC%A1%B0%EA%B1%B4postcondition-%EA%B2%80%EC%A6%9D---%EB%B0%9B%EC%95%84%EC%98%A8-%EA%B2%B0%EA%B3%BC%EA%B0%92-%EA%B2%80%EC%A6%9D%ED%9B%84%EC%B2%98%EB%A6%AC" aria-hidden="true"><span class="octicon octicon-link"></span></a>03 사후조건(postcondition) 검증 - (받아온) 결과값 검증(후처리)</h3>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712162559912.png" alt="image-20220712162559912"></p>

<ul>
  <li>일반적으로 결과값 검증이라고 한다.
    <ul>
      <li>재고처리 시스템 등은 사후조건 검증을 빡빡하게 찬다.</li>
    </ul>
  </li>
  <li>보내줄 값이 올바름을 검증한다.</li>
  <li>return하는 형에 대해, 그 형을 만드냐 못만드냐로 검증을 미룰 수도 있음.</li>
</ul>

<h4 id="plan-2">
<a class="anchor" href="#plan-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>plan</h4>

<h5 id="문제점과-해결결과값-검증---도메인의-영역이다">
<a class="anchor" href="#%EB%AC%B8%EC%A0%9C%EC%A0%90%EA%B3%BC-%ED%95%B4%EA%B2%B0%EA%B2%B0%EA%B3%BC%EA%B0%92-%EA%B2%80%EC%A6%9D---%EB%8F%84%EB%A9%94%EC%9D%B8%EC%9D%98-%EC%98%81%EC%97%AD%EC%9D%B4%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>문제점과 해결(결과값 검증 -&gt; 도메인의 영역이다.)</h5>

<ul>
  <li>
    <p>사후검증 대상은 calculateFee()이다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712162849249.png" alt="image-20220712162849249"></p>

    <ul>
      <li>일반적으로 <strong>객체는 자기의 일을 직접수행하지 않고, <code class="language-plaintext highlighter-rouge">메세지를 통해  책임수행이 적합한 객체에게 위임</code>해서 결과값을 받아온다. <code class="language-plaintext highlighter-rouge">받아온 결과값은 내가 한 것이 아니므로 반드시 검증한 뒤 반환한다</code></strong>
</li>
      <li>계산책임을 위임받은 calculator가 결과를 반환해주는데, <strong>받아서 다른 데 반환하기 전에 다시, 내가 검증을 해야하는데 <code class="language-plaintext highlighter-rouge">사후조건 검증은 로직이 아니라 도메인의 영역</code>이다.</strong>
        <ul>
          <li><strong>Money를 반환할 예정인데, 0원이나 음수를 보내줘도 되는지 확인 -&gt; call이 있다면 0원이하일 수 없다.</strong></li>
        </ul>
      </li>
      <li>
        <p><strong>위임해서 받아온 값은 반환하기 전에 내가 검증한다.</strong></p>

        <ul>
          <li>
            <p><strong>계산재료인 call이 없었으면 모르겠는데, <code class="language-plaintext highlighter-rouge">call이 있는데도 불구하고 &amp;&amp;  돈이 0원이나 음수가 되면 thr</code></strong></p>
          </li>
          <li>
            <p>도메인지식을 if에 올려 죽여버린다</p>
          </li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712164140977.png" alt="image-20220712164140977"></p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="계약별-책임할당">
<a class="anchor" href="#%EA%B3%84%EC%95%BD%EB%B3%84-%EC%B1%85%EC%9E%84%ED%95%A0%EB%8B%B9" aria-hidden="true"><span class="octicon octicon-link"></span></a>계약별 책임할당</h2>

<ul>
  <li>Plan이 현재 모든 계약조건을 다 검증하고 있다.</li>
  <li>하지만 <strong>Plan은 Calculator에게 계산책임은 위임</strong>한 상태이므로 <strong>같이 일하고 있는데, 모든 계약조건을 Plan이 다 검증해야할까?</strong>
</li>
</ul>

<h3 id="사전계약조건-책임할당">
<a class="anchor" href="#%EC%82%AC%EC%A0%84%EA%B3%84%EC%95%BD%EC%A1%B0%EA%B1%B4-%EC%B1%85%EC%9E%84%ED%95%A0%EB%8B%B9" aria-hidden="true"><span class="octicon octicon-link"></span></a>사전계약조건 책임할당</h3>

<ul>
  <li>인자로 넘어왔을 때, 인자가 null인지 체크하는데, <strong>인자의 상태체크는 물어보지말고 스스로 죽도록 위임할 수 있음.</strong>
</li>
</ul>

<h4 id="precondition1-자신의-상태null-인자null체크는-상대방에게-위임할-수-없다">
<a class="anchor" href="#precondition1-%EC%9E%90%EC%8B%A0%EC%9D%98-%EC%83%81%ED%83%9Cnull-%EC%9D%B8%EC%9E%90null%EC%B2%B4%ED%81%AC%EB%8A%94-%EC%83%81%EB%8C%80%EB%B0%A9%EC%97%90%EA%B2%8C-%EC%9C%84%EC%9E%84%ED%95%A0-%EC%88%98-%EC%97%86%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>precondition1) 자신의 상태null, 인자null체크는 상대방에게 위임할 수 없다.</h4>

<ul>
  <li>
    <p>참고로, 인텔리제이는 <strong>precondition으로 인자 null체크를 넣어둔 메서드에 대해, null을 넣으면, 코드힌트에서 알려준다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712164920750.png" alt="image-20220712164920750"></p>
  </li>
</ul>

<h4 id="precondition2-인자의-상태nullemtpy체크는--해당-객체인자가-자신상태validation메소드를-제공해주는데">
<a class="anchor" href="#precondition2-%EC%9D%B8%EC%9E%90%EC%9D%98-%EC%83%81%ED%83%9Cnullemtpy%EC%B2%B4%ED%81%AC%EB%8A%94--%ED%95%B4%EB%8B%B9-%EA%B0%9D%EC%B2%B4%EC%9D%B8%EC%9E%90%EA%B0%80-%EC%9E%90%EC%8B%A0%EC%83%81%ED%83%9Cvalidation%EB%A9%94%EC%86%8C%EB%93%9C%EB%A5%BC-%EC%A0%9C%EA%B3%B5%ED%95%B4%EC%A3%BC%EB%8A%94%EB%8D%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>precondition2) 인자의 상태null/emtpy체크는?  해당 객체인자가 자신상태validation메소드를 제공해주는데?</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712165114221.png" alt="image-20220712165114221"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712165124254.png" alt="image-20220712165124254"></p>

<h5 id="isempty는-간접적으로-내장을-까는-메소드-물어보고-행동하면-변화시의-여파가-찾아온다-검증도-스스로-죽어라고-시킨다위임">
<a class="anchor" href="#isempty%EB%8A%94-%EA%B0%84%EC%A0%91%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%82%B4%EC%9E%A5%EC%9D%84-%EA%B9%8C%EB%8A%94-%EB%A9%94%EC%86%8C%EB%93%9C-%EB%AC%BC%EC%96%B4%EB%B3%B4%EA%B3%A0-%ED%96%89%EB%8F%99%ED%95%98%EB%A9%B4-%EB%B3%80%ED%99%94%EC%8B%9C%EC%9D%98-%EC%97%AC%ED%8C%8C%EA%B0%80-%EC%B0%BE%EC%95%84%EC%98%A8%EB%8B%A4-%EA%B2%80%EC%A6%9D%EB%8F%84-%EC%8A%A4%EC%8A%A4%EB%A1%9C-%EC%A3%BD%EC%96%B4%EB%9D%BC%EA%B3%A0-%EC%8B%9C%ED%82%A8%EB%8B%A4%EC%9C%84%EC%9E%84" aria-hidden="true"><span class="octicon octicon-link"></span></a>isEmpty()는 간접적으로 내장을 까는 메소드. &lt;물어보고 행동하면, 변화(시)의 여파가 찾아온다. 검증도 스스로 죽어라고 시킨다(위임)&gt;</h5>

<ul>
  <li>
    <p>간접적으로 내 안의 컬렉션필드의 size를 알려주는 코드라서 getter나 마찬가지다.</p>

    <ul>
      <li>
        <p><strong>메소드가 캡슐화하는데 실패한 코드다</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712171349693.png" alt="image-20220712171349693"></p>

        <ul>
          <li><strong>if로 물어보고 어떤 행동을 했기 때문이다.</strong></li>
          <li>
<strong>물어보고 check를 시켜서 스스로 thr로 죽여야</strong>한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>my) <code class="language-plaintext highlighter-rouge">인자로 넘어온 특정 객체에 대한 상태검사</code>는 <code class="language-plaintext highlighter-rouge">내가 하지말고 시켜서 스스로 죽게 만들자</code></strong></p>

    <ul>
      <li>자신에 대한 검증메소드가 추가될 때, 스스로 죽도록 하는 메소드로 만들 것</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712171739114.png" alt="image-20220712171739114">
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712171746455.png" alt="image-20220712171746455"></p>

    <ul>
      <li>
<strong>각 객체의 상태검증은 본인이 하도록 위임해서 스스로 죽게</strong>하고 <strong>나는 호출만 한다</strong>.
        <ul>
          <li><strong>객체도 구조가 바뀌면 다 바뀔텐데, 니가 알아서 검증하고 스스로 죽고 오세요.</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="if로무시with불린flag보다-thr로-멈추게하면-좋은-점">
<a class="anchor" href="#if%EB%A1%9C%EB%AC%B4%EC%8B%9Cwith%EB%B6%88%EB%A6%B0flag%EB%B3%B4%EB%8B%A4-thr%EB%A1%9C-%EB%A9%88%EC%B6%94%EA%B2%8C%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%A0%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>if로무시with불린Flag보다 thr로 멈추게하면 좋은 점</h5>

<ul>
  <li>만약 if로무시했다면 불린flag를 받아서 내가 thr를 처리해줘얗나다.</li>
  <li>thr로 처리했다면, 스스로 죽게 <strong>검증을 완벽하게 위임할 수 있다.</strong>
</li>
</ul>

<h3 id="사후계약조건-책임할당">
<a class="anchor" href="#%EC%82%AC%ED%9B%84%EA%B3%84%EC%95%BD%EC%A1%B0%EA%B1%B4-%EC%B1%85%EC%9E%84%ED%95%A0%EB%8B%B9" aria-hidden="true"><span class="octicon octicon-link"></span></a>사후계약조건 책임할당</h3>

<h4 id="postcondition1-this가-필요없는-결과값-검증this조차-받아가는-객체은-결과계산-위임객체에게-계산후-검증도-위임한다">
<a class="anchor" href="#postcondition1-this%EA%B0%80-%ED%95%84%EC%9A%94%EC%97%86%EB%8A%94-%EA%B2%B0%EA%B3%BC%EA%B0%92-%EA%B2%80%EC%A6%9Dthis%EC%A1%B0%EC%B0%A8-%EB%B0%9B%EC%95%84%EA%B0%80%EB%8A%94-%EA%B0%9D%EC%B2%B4%EC%9D%80-%EA%B2%B0%EA%B3%BC%EA%B3%84%EC%82%B0-%EC%9C%84%EC%9E%84%EA%B0%9D%EC%B2%B4%EC%97%90%EA%B2%8C-%EA%B3%84%EC%82%B0%ED%9B%84-%EA%B2%80%EC%A6%9D%EB%8F%84-%EC%9C%84%EC%9E%84%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>postcondition1) this가 필요없는 결과값 검증(this조차 받아가는 객체)은, 결과계산 위임객체에게 계산후 검증도 위임한다.</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712172242654.png" alt="image-20220712172242654"></p>

<ul>
  <li>
    <p>객체는 적합한 객체에게 책임을 위임하고 결과값을 받아오며, 그 결과값을 반환하기 전에 내가 직접 검증해야한다고 했다.</p>
  </li>
  <li>
    <p><strong>하지만, <code class="language-plaintext highlighter-rouge">메소드 내부에서 결과값(result) 검증 로직</code>을 보면 <code class="language-plaintext highlighter-rouge">Plan 자신의 의존성(this)</code>이 존재하질 않아, plan이 검사할 이유가 1개도 없다</strong></p>

    <ul>
      <li>this가 존재하는지 유무는 <strong>보라색 변수</strong>를 확인하면 되는데, <strong>사용되는 보라색 변수는 <code class="language-plaintext highlighter-rouge">calls</code>하나가 있긴 하지만, <code class="language-plaintext highlighter-rouge">이미 계산메서드의 인자로 던져준 상태</code>이므로, <code class="language-plaintext highlighter-rouge">계산로직 위임 객체calc가 이미 가진 의존성</code>이다.</strong>
</li>
    </ul>
  </li>
  <li>
    <p><strong>빨간 박스안에는 <code class="language-plaintext highlighter-rouge">this가 나올 요소가 하나도 없는 상태</code>이다.</strong></p>

    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">this가 안나오면 나의 메서드가 아니다</code>라는 증거이다.</strong></li>
    </ul>
  </li>
  <li>
    <p><strong>즉, 쉽게말하면 result는 내가 가진 정보(this)로 와서 검증받을 대상이 아니라, result를 반환해주는 책임객체에서 검증을 끝내고 와야하는 대상이다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712173126719.png" alt="image-20220712173126719"></p>

    <ul>
      <li>
<strong>위임한 객체 calc에서 알아서 결과값을 검증하고,  thr로 스스로 죽어라고 검증책임을 위임</strong>한다.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712173223267.png" alt="image-20220712173223267"></p>
  </li>
  <li>
    <p>계약조건의 준수는, 한쪽에 모는 것이 아니라 <strong>섬세하게 누구에게 책임이 있는지 판단해서, 그쪽에 위임</strong>해야한다.</p>
  </li>
</ul>

<h5 id="사전사후계약조건-검증-중에-내-contextthis-보라색변수를-통한-검증이-아니면-검증도-물어보지말고-스스로-죽도록-시킨다위임">
<a class="anchor" href="#%EC%82%AC%EC%A0%84%EC%82%AC%ED%9B%84%EA%B3%84%EC%95%BD%EC%A1%B0%EA%B1%B4-%EA%B2%80%EC%A6%9D-%EC%A4%91%EC%97%90-%EB%82%B4-contextthis-%EB%B3%B4%EB%9D%BC%EC%83%89%EB%B3%80%EC%88%98%EB%A5%BC-%ED%86%B5%ED%95%9C-%EA%B2%80%EC%A6%9D%EC%9D%B4-%EC%95%84%EB%8B%88%EB%A9%B4-%EA%B2%80%EC%A6%9D%EB%8F%84-%EB%AC%BC%EC%96%B4%EB%B3%B4%EC%A7%80%EB%A7%90%EA%B3%A0-%EC%8A%A4%EC%8A%A4%EB%A1%9C-%EC%A3%BD%EB%8F%84%EB%A1%9D-%EC%8B%9C%ED%82%A8%EB%8B%A4%EC%9C%84%EC%9E%84" aria-hidden="true"><span class="octicon octicon-link"></span></a>사전/사후계약조건 검증 중에 내 context(this, 보라색변수)를 통한 검증이 아니면, 검증도 물어보지말고 스스로 죽도록 시킨다.(위임)</h5>

<ol>
  <li>
    <p>인자 calc의 상태검증을, isEmpty()로 물어보고 검증한다면? <strong>calc가 변할 때, 변화의 여파가 여기까지 온다.</strong></p>

    <ul>
      <li><strong>내 정보this가 필요한 것도 아닌데, 물어보고 행동하면, 변화의 여파가 온다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712174637225.png" alt="image-20220712174637225"></p>
  </li>
  <li>
    <p>결과값 result의 검증을, 0이냐/음수냐를 물어보고 행동한다면, <strong>결과값계산로직이 바뀐다면</strong> 변화시 여파가 온다.</p>

    <ul>
      <li><strong>내 정보(this)를 이미 결과계산로직에서 받아갔다면, 결과값 검증은 물어보지말고 결과값 계산하는 객체가 스스로 죽도록 시킨다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712172242654.png" alt="image-20220712172242654"></p>
  </li>
</ol>

<h5 id="prepostcondition-검증책임은-대부분-위임받은-객체들이-가져가야하며-인자결과값로직의-검증-코드가-안보인다면-이미-계약관계라고-판단한다">
<a class="anchor" href="#prepostcondition-%EA%B2%80%EC%A6%9D%EC%B1%85%EC%9E%84%EC%9D%80-%EB%8C%80%EB%B6%80%EB%B6%84-%EC%9C%84%EC%9E%84%EB%B0%9B%EC%9D%80-%EA%B0%9D%EC%B2%B4%EB%93%A4%EC%9D%B4-%EA%B0%80%EC%A0%B8%EA%B0%80%EC%95%BC%ED%95%98%EB%A9%B0-%EC%9D%B8%EC%9E%90%EA%B2%B0%EA%B3%BC%EA%B0%92%EB%A1%9C%EC%A7%81%EC%9D%98-%EA%B2%80%EC%A6%9D-%EC%BD%94%EB%93%9C%EA%B0%80-%EC%95%88%EB%B3%B4%EC%9D%B8%EB%8B%A4%EB%A9%B4-%EC%9D%B4%EB%AF%B8-%EA%B3%84%EC%95%BD%EA%B4%80%EA%B3%84%EB%9D%BC%EA%B3%A0-%ED%8C%90%EB%8B%A8%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>pre/postcondition 검증책임은 대부분 위임받은 객체들이 가져가야하며, 인자/결과값로직의 검증 코드가 안보인다면, 이미 계약관계라고 판단한다.</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712175645352.png" alt="image-20220712175645352"></p>

<ul>
  <li>상태값이나 결과값에 대한 검증을 물어보지말고, 위임된 객체에게 시킨다.
    <ul>
      <li><strong>인자 객체의 검증코드없이 <code class="language-plaintext highlighter-rouge">나는 검증된 값임을 메소드로 증명</code>하고있다면 <code class="language-plaintext highlighter-rouge">이미 계약관계</code>라고 판단한다</strong></li>
      <li><strong><code class="language-plaintext highlighter-rouge">결과값에 대한 검증로직이 안보인다</code>면, 사후조건 검증을 가져간 상태로서, <code class="language-plaintext highlighter-rouge">이미 계약관계</code>라고 판단한다</strong></li>
    </ul>
  </li>
  <li>
<strong>precondition</strong>은 인자에 대한 precondition조건을 <strong>명시적으로 호출</strong>하는 것이 필요하지만, <strong>postcondition은 위임한 메소드안에 지 스스로 보장</strong>해서 줘야한다.</li>
</ul>

<h5 id="precondition은-내가받은쪽이-발동할게-postcondition은-니위임객체가-처리해와">
<a class="anchor" href="#precondition%EC%9D%80-%EB%82%B4%EA%B0%80%EB%B0%9B%EC%9D%80%EC%AA%BD%EC%9D%B4-%EB%B0%9C%EB%8F%99%ED%95%A0%EA%B2%8C-postcondition%EC%9D%80-%EB%8B%88%EC%9C%84%EC%9E%84%EA%B0%9D%EC%B2%B4%EA%B0%80-%EC%B2%98%EB%A6%AC%ED%95%B4%EC%99%80" aria-hidden="true"><span class="octicon octicon-link"></span></a>precondition은 내가(받은쪽이) 발동할게, postcondition은 니(위임객체)가 처리해와</h5>

<ul>
  <li>처음에는 Plan에 precondition과 postcondition을 모두 두었다가, <strong>precondition도 옮기고, postcondition도 옮겼지만 <code class="language-plaintext highlighter-rouge">둘의 옮긴다는 같은 의미가 아니다</code></strong>
    <ul>
      <li>preconidtion의 책임은 받은쪽이 호출해야하는 책임을 가지며</li>
      <li>postcondition의 책임은 <strong>위임받아 주는쪽이 책임을 가져서 다 처리하고 준다</strong>.</li>
    </ul>
  </li>
  <li>
    <p>**일반적으로 calc를 받아들인 쪽인 plan이 precondition을 명시적으로 호출한다. 그에 비해 postcondition은 위임받은 쪽이 검증까지 다 처리하고 주는 책임이 있다. **</p>

    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">precondition은 내가(받은쪽)이 처리할게, postcondition은 니(위임객체)가 처리해와</code></strong></li>
    </ul>
  </li>
  <li>
<strong>회사에서 룰로 짜야한다.</strong>
    <ul>
      <li><strong>postcondition은 return하는 쪽이 다 책임지고 줘야해</strong></li>
      <li>
<strong>precondition은 잘못된 값줬다고 뭐라하지말고, 받은놈이 검증해</strong>
        <ul>
          <li>이것을 안지키면, 제품이 어떤쪽에선 되고, 어떤쪽에선 안되고가 발생한다</li>
          <li>일관성있게 검사해야한다.</li>
        </ul>
      </li>
      <li><strong>70%가 validation코드가 되기 때문에, 스프링 등에서 애노테이션으로 제공해준다.</strong></li>
    </ul>
  </li>
</ul>

<h2 id="협력을-통한-책임분할">
<a class="anchor" href="#%ED%98%91%EB%A0%A5%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%B1%85%EC%9E%84%EB%B6%84%ED%95%A0" aria-hidden="true"><span class="octicon octicon-link"></span></a>협력을 통한 책임분할</h2>

<ul>
  <li>지금까지는 precondition은 받은쪽이 발동,  postcondition은 return주는 놈에게 정도로만 나눴지만, <strong>더 세밀하게 나눠야한다.</strong>
</li>
</ul>

<h3 id="postcondition검증인-결과값-검증에-외부인자-검증이-포함되어있는데-검증-통과못하면-계산의-의미가-없는-경우-애초에-오염되지-않은-인자만-넘어오는게-더-좋다">
<a class="anchor" href="#postcondition%EA%B2%80%EC%A6%9D%EC%9D%B8-%EA%B2%B0%EA%B3%BC%EA%B0%92-%EA%B2%80%EC%A6%9D%EC%97%90-%EC%99%B8%EB%B6%80%EC%9D%B8%EC%9E%90-%EA%B2%80%EC%A6%9D%EC%9D%B4-%ED%8F%AC%ED%95%A8%EB%90%98%EC%96%B4%EC%9E%88%EB%8A%94%EB%8D%B0-%EA%B2%80%EC%A6%9D-%ED%86%B5%EA%B3%BC%EB%AA%BB%ED%95%98%EB%A9%B4-%EA%B3%84%EC%82%B0%EC%9D%98-%EC%9D%98%EB%AF%B8%EA%B0%80-%EC%97%86%EB%8A%94-%EA%B2%BD%EC%9A%B0-%EC%95%A0%EC%B4%88%EC%97%90-%EC%98%A4%EC%97%BC%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EC%9D%B8%EC%9E%90%EB%A7%8C-%EB%84%98%EC%96%B4%EC%98%A4%EB%8A%94%EA%B2%8C-%EB%8D%94-%EC%A2%8B%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>postcondition검증인 결과값 검증에 외부인자 검증이 포함되어있는데, 검증 통과못하면 계산의 의미가 없는 경우, 애초에 오염되지 않은 인자만 넘어오는게 더 좋다.</h3>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712182851586.png" alt="image-20220712182851586"></p>

<ul>
  <li>precondition으로서 내부에서 책임진다는원칙을 적용할 수도 있겠지만</li>
  <li>
<strong>calls는 외부에서 인자로 오는데, 왜 내부에서 검사하지?</strong>
    <ul>
      <li><strong>내 책임이 아니라서 <code class="language-plaintext highlighter-rouge">외부에서 넘어올때부터 검증된 것만 넘어오게</code> 한다.</strong></li>
    </ul>
  </li>
  <li>
    <p><strong>메세지에 white list만 흐르게 하면, 내부 검증 로직이 제거된다.</strong></p>
  </li>
  <li>
    <p>외부 재료call이 1개이상일 때, 결과값이 0원이나 음수면  -&gt; 결과값 반환없이 스스로 죽는다.</p>

    <ul>
      <li>외부 재료call이 0개일 땐? 0원인데, 그대로 두어도 0원으로 반환된다. <strong>하지만, 1개이상이 아니라면, 계산의 의미가 없어진다.</strong>
</li>
    </ul>
  </li>
  <li>
    <p><strong>애초에 외부재료call(<code class="language-plaintext highlighter-rouge">인자</code>)이 1개 이상일때(<code class="language-plaintext highlighter-rouge">특정 검증 통과해야</code>)만 <code class="language-plaintext highlighter-rouge">결과값계산이 의미를 가지는 경우</code>라면, <code class="language-plaintext highlighter-rouge">외부에서 인자를 넘길 때, 미리 검증하고 넘기고, 아니라면 아예 안넘어오도록 삼항연산자를 활용해서 검증을 옮긴다</code></strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712185231191.png" alt="image-20220712185231191"></p>
  </li>
  <li>
    <p>계약관계에 있더라도, <strong>위임된객체.메서드()의 시그니쳐가 보여주는 것</strong>은 아주 일부분이며, <strong>코드로 계약관계를 명시한다.</strong></p>

    <ul>
      <li>
        <p><strong>결과값 검증없이 책임객체의 결과값 반환</strong>하는 계야관계 -&gt; <strong>계약서 중 제목밖에 차지 안하는 부분</strong>이다.</p>
      </li>
      <li>
        <p><strong>나머지 계약내용들은 위의 삼항연산자 코드처럼 계약내용이 명시되는 것이다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712185844782.png" alt="image-20220712185844782"></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220712190149813.png" alt="image-20220712190149813"></p>
      </li>
    </ul>
  </li>
  <li>
<strong>계약서의 내용으로 인해 <code class="language-plaintext highlighter-rouge">계약의 의미</code>가 달라졌다.</strong>
    <ul>
      <li>plan은 나의 calls을 보내는 것이 아니라 <strong><code class="language-plaintext highlighter-rouge">내것(this)와 다른 1건이상의 calls</code>을 보낸다.</strong>
        <ul>
          <li><strong>더이상 plan의 calls이 아닌 calls.</strong></li>
          <li><strong>코드만 보고 계약내용을 모를 경우, <code class="language-plaintext highlighter-rouge">OneMoreCalls</code>라는 형을 만들어서 인자로 보내기도 한다.</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="런타임에-의한-계약조건">
<a class="anchor" href="#%EB%9F%B0%ED%83%80%EC%9E%84%EC%97%90-%EC%9D%98%ED%95%9C-%EA%B3%84%EC%95%BD%EC%A1%B0%EA%B1%B4" aria-hidden="true"><span class="octicon octicon-link"></span></a>런타임에 의한 계약조건</h2>

<ul>
  <li>
<strong>방금 봤던, size가 0보다 더 큰 것을 검증하는 것도 섬세한 문제</strong>였지만, <strong>런타임은 더 큰 문제</strong>다</li>
</ul>

<h3 id="setter가-있어-생성시점에-불변을-보장못하는-상태변화하는-객체-인자는-인자의-상태검증-발동을-precondition에-위치시켜선-안되고-실제-계산에-사용될-때마다-매번-스스로-검증하도록-메세지-처리전-invariant를-스스로-걸어야한다">
<a class="anchor" href="#setter%EA%B0%80-%EC%9E%88%EC%96%B4-%EC%83%9D%EC%84%B1%EC%8B%9C%EC%A0%90%EC%97%90-%EB%B6%88%EB%B3%80%EC%9D%84-%EB%B3%B4%EC%9E%A5%EB%AA%BB%ED%95%98%EB%8A%94-%EC%83%81%ED%83%9C%EB%B3%80%ED%99%94%ED%95%98%EB%8A%94-%EA%B0%9D%EC%B2%B4-%EC%9D%B8%EC%9E%90%EB%8A%94-%EC%9D%B8%EC%9E%90%EC%9D%98-%EC%83%81%ED%83%9C%EA%B2%80%EC%A6%9D-%EB%B0%9C%EB%8F%99%EC%9D%84-precondition%EC%97%90-%EC%9C%84%EC%B9%98%EC%8B%9C%EC%BC%9C%EC%84%A0-%EC%95%88%EB%90%98%EA%B3%A0-%EC%8B%A4%EC%A0%9C-%EA%B3%84%EC%82%B0%EC%97%90-%EC%82%AC%EC%9A%A9%EB%90%A0-%EB%95%8C%EB%A7%88%EB%8B%A4-%EB%A7%A4%EB%B2%88-%EC%8A%A4%EC%8A%A4%EB%A1%9C-%EA%B2%80%EC%A6%9D%ED%95%98%EB%8F%84%EB%A1%9D-%EB%A9%94%EC%84%B8%EC%A7%80-%EC%B2%98%EB%A6%AC%EC%A0%84-invariant%EB%A5%BC-%EC%8A%A4%EC%8A%A4%EB%A1%9C-%EA%B1%B8%EC%96%B4%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>setter가 있어 생성시점에 불변을 보장못하는, 상태변화하는 객체 인자는, 인자의 상태검증 발동을 precondition에 위치시켜선 안되고, 실제 계산에 사용될 때마다 매번 스스로 검증하도록 메세지 처리전, invariant를 스스로 걸어야한다.</h3>

<ul>
  <li>
    <p>즉, setter를 가진 객체는, pre나 post가 아니라 메세지처리전, 실시간 자신의 불변성 검증으로 돌려야한다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713002340242.png" alt="image-20220713002340242"></p>
  </li>
</ul>

<h4 id="calculator-plan">
<a class="anchor" href="#calculator-plan" aria-hidden="true"><span class="octicon octicon-link"></span></a>Calculator, Plan</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713000622034.png" alt="image-20220713000622034"></p>

<ul>
  <li>전략객체들을 실시간으로 받는 calculator는
    <ul>
      <li>
<strong>Plan에 들어가는 runtime(시점)</strong>에는<strong>1개이상인지 상태검증을 제공</strong>하는데
        <ul>
          <li><strong>check()메서드의 가정: 생성시점에 가지고 있는 전략객체 컬렉션이 확정되어있으며, 내가 plan에 들어갈 때, 내가 전략객체가 없으면 잘못된 놈이야.</strong></li>
        </ul>
      </li>
      <li>**runtime상에서 상태변화를 언제든지 변화시키는 setter받기기능이 존재하고 있다. **
        <ul>
          <li>전략객체를 추가하는 것은 <strong>생성시점이 아니라 runtime시 자유롭게 추가</strong>할 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>상태가 시간(타이밍)마다 달라지는 것이 어렵다
    <ul>
      <li>Calculator 생성시점에는 아무것도 없다</li>
      <li>Plan에 집어넣을 때도 아무것도 없다. 근데 검사는 여기서 이루어진다.</li>
      <li>근데, plan에 들어가서 검사 이후에 얼마든지 setter로 전략객체를 추가할 수 있다</li>
      <li><strong>나중에 추가될 수 있으면, plan에 집어넣을 때 검사하면 안된다.</strong></li>
    </ul>
  </li>
  <li><strong>생성시점에 확정되지 않는 애들(setter를 가진 필드)은 runtime에 의존성이 있고, 시차가 생기는데, 특정시점(plan에 들어가는 시점)에 검사하고 마치면 안된다.</strong></li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713001324325.png" alt="image-20220713001324325"></p>

<ul>
  <li>
    <p><strong>calc.check()는, <code class="language-plaintext highlighter-rouge">나중에 계산시</code> 전략객체가 없으면 안되니까 미리 검사하는 것이었다.</strong></p>

    <ol>
      <li>
        <p><strong>calc.check()는 precondition으로서 들어갈 때 인자의 상태검사를 할 것이 아니다</strong> -&gt; plan에서 삭제한다.</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713001953348.png" alt="image-20220713001953348"></p>
      </li>
      <li>
        <p><strong>setter를 가져 상태변화하는 calc<code class="language-plaintext highlighter-rouge">인자</code>의 <code class="language-plaintext highlighter-rouge">상태 검사</code>는, <code class="language-plaintext highlighter-rouge">자신이 사용될 때 실시간 스스로 검증</code>해야한다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713002054160.png" alt="image-20220713002054160"></p>
      </li>
    </ol>
  </li>
  <li>
<strong>다시 보니, 내가 <code class="language-plaintext highlighter-rouge">메세지를 처리하기 전에 내 상태를 검증하고 있는 invariant검사</code>다.</strong>
    <ul>
      <li>
<strong>메세지 처리전에, <code class="language-plaintext highlighter-rouge">상태변화가 가능한 자신부터 thr로 불변성 검증</code>하는  01 불변성 검증</strong>이다.</li>
      <li><strong>precondition으로 봤던 calc인자의 상태 검증은 알고 봤더니, 상태가 수시로 변하므로, 계산할때 상태 검증 -&gt; 스스로 불변성 검증하는 <code class="language-plaintext highlighter-rouge">invariant</code>였다</strong></li>
    </ul>
  </li>
  <li>
    <p><strong>상태가 변하는 객체는, 실행될 때마다 자신의 상태를 검증해야한다.</strong></p>
  </li>
  <li>
    <p><strong>불변식이라는 것은, 1번만 검사하고 끝나는 immutable이 아니라, <code class="language-plaintext highlighter-rouge">특정 조건하에서만 메세지를 처리하는 것이 invariant</code>이며, <code class="language-plaintext highlighter-rouge">변하지 않는 필수조건</code>을 의미한다</strong></p>

    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">메세지 처리를 하기 전에, 확인해야하는 필수조건 = invariant</code></strong></li>
      <li><strong><code class="language-plaintext highlighter-rouge">메서드내에 인자나 지역변수와는 상관없이 먼저 깔려야한다</code></strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713002819826.png" alt="image-20220713002819826"></p>
  </li>
  <li>
<strong>메서드호출인 <code class="language-plaintext highlighter-rouge">실행시점</code>보다 앞 시점은 <code class="language-plaintext highlighter-rouge">생성시점</code>밖에 없다.</strong>
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">생성시점에 1번만 보장하면 되는</code> immutable이 아니라 상태변화를 하는 상태값이라면</strong></li>
      <li><strong><code class="language-plaintext highlighter-rouge">실행시점마다 == 메서드호출시마다 보장</code>해야하는 <code class="language-plaintext highlighter-rouge">invariant</code>다</strong></li>
    </ul>
  </li>
  <li>생성 -&gt; initialize -&gt; calculate 순으로 메서드를 생성했다.
    <ul>
      <li>
<strong>client에서는 initialize를 호출해준다는 보장이 없다.</strong>
        <ul>
          <li><strong>컴파일러는 메서드 순서를 빼먹은 것을 걸러주지 못한다.</strong></li>
        </ul>
      </li>
      <li>
<strong>런타임에 와서야 뭔가 부족해서 에러가 난다.</strong>
        <ul>
          <li>런타임으로 올라간다면, 단위테스트로 모든 경우를 테스트할 수 밖에 없어진다.</li>
        </ul>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">컴파일타임에 확정</code>지으려면, <code class="language-plaintext highlighter-rouge">생성자에서 확인</code>할 수 밖에 없다</strong></li>
      <li>
<strong>메서드의 순서로서 <code class="language-plaintext highlighter-rouge">런타임으로 미뤄진다면</code>, <code class="language-plaintext highlighter-rouge">호출시마다 invariant를 확정</code>하는 방법 밖에 안남았다.</strong>
        <ul>
          <li>스프링은 라이프사이클(순서)로 객체를 만들던데?</li>
          <li><strong>스프링은 자동으로 자신이 순서대로 객체를 다 만들어서 빼틀일 일이 없다 = 상태가 에러나는 쪽으로 변하지 않는다 = 런타임 에러가 안난다.</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>불변상태로서 생성시점에 검사를 한다면, 컴파일러에 걸려서 에러를 미리 잡을 수 있으나, setter로 변하는 상태를 가졌다면 -&gt; 생성시점에 검사는 의미가 없고, 호출시점마다 매번 invariant를 확정하고 메세지를 처리하는 수 밖에 없다</strong></li>
</ul>

<h3 id="다시-precondition">
<a class="anchor" href="#%EB%8B%A4%EC%8B%9C-precondition" aria-hidden="true"><span class="octicon octicon-link"></span></a>다시 precondition</h3>

<h4 id="calculator">
<a class="anchor" href="#calculator" aria-hidden="true"><span class="octicon octicon-link"></span></a>Calculator</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713004119098.png" alt="image-20220713004119098"></p>

<ul>
  <li>setter도 인자의 null검사를 precondition으로서 검사해줘야한다.</li>
</ul>

<h2 id="계약의-전파">
<a class="anchor" href="#%EA%B3%84%EC%95%BD%EC%9D%98-%EC%A0%84%ED%8C%8C" aria-hidden="true"><span class="octicon octicon-link"></span></a>계약의 전파</h2>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713004238485.png" alt="image-20220713004238485"></p>

<ul>
  <li>지금까지 이것을 배우기 위해 공부했던 것</li>
  <li>계약은 전파된다.
    <ul>
      <li>한번 앞에서 검증했다면, 또 검증해야할까?</li>
      <li>독립성을 위해서, 확인하기 귀찮으니, 무조건 다시 검사할까?</li>
      <li>갑-을만 계약할까? 어디에서 계약이 이어질까?</li>
    </ul>
  </li>
</ul>

<h3 id="package가시성으로-precondition검증을-생략하기">
<a class="anchor" href="#package%EA%B0%80%EC%8B%9C%EC%84%B1%EC%9C%BC%EB%A1%9C-precondition%EA%B2%80%EC%A6%9D%EC%9D%84-%EC%83%9D%EB%9E%B5%ED%95%98%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>package(가시성)으로 precondition검증을 생략하기</h3>

<h4 id="좋은-인자들이-검증없이-전파-유지되기-위해서는-이미-앞에서-검증이-끝난-인자라면-호출하는-주체가-계약-맺는-놈만-public이-아니어야">
<a class="anchor" href="#%EC%A2%8B%EC%9D%80-%EC%9D%B8%EC%9E%90%EB%93%A4%EC%9D%B4-%EA%B2%80%EC%A6%9D%EC%97%86%EC%9D%B4-%EC%A0%84%ED%8C%8C-%EC%9C%A0%EC%A7%80%EB%90%98%EA%B8%B0-%EC%9C%84%ED%95%B4%EC%84%9C%EB%8A%94-%EC%9D%B4%EB%AF%B8-%EC%95%9E%EC%97%90%EC%84%9C-%EA%B2%80%EC%A6%9D%EC%9D%B4-%EB%81%9D%EB%82%9C-%EC%9D%B8%EC%9E%90%EB%9D%BC%EB%A9%B4-%ED%98%B8%EC%B6%9C%ED%95%98%EB%8A%94-%EC%A3%BC%EC%B2%B4%EA%B0%80-%EA%B3%84%EC%95%BD-%EB%A7%BA%EB%8A%94-%EB%86%88%EB%A7%8C-public%EC%9D%B4-%EC%95%84%EB%8B%88%EC%96%B4%EC%95%BC" aria-hidden="true"><span class="octicon octicon-link"></span></a>좋은 인자들이 검증없이 전파 유지되기 위해서는,,, 이미 앞에서 검증이 끝난 인자라면, 호출하는 주체가 계약 맺는 놈만… public이 아니어야..</h4>

<h5 id="pricepertime">
<a class="anchor" href="#pricepertime" aria-hidden="true"><span class="octicon octicon-link"></span></a>PricePerTime</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713010412965.png" alt="image-20220713010412965"></p>

<ul>
  <li>
    <p>1분당 18원을 계산하기 위해서, 1분을 60초 Duration으로 받고, 분당가격을 Money로 받는다.</p>
  </li>
  <li>
    <p><strong>문제점: invariant / pre / post 검증을 아무것도 안하고 있는 전략객체</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713010825966.png" alt="image-20220713010825966"></p>

    <ul>
      <li>생성자에 만능키인 null이 들어올 수 있으므로 invariant 만족이 안되는 상태다</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713011018995.png" alt="image-20220713011018995"></p>

    <ul>
      <li>contract의 문제때문에, 인자2개를 아무것도 안하고 있다.
        <ul>
          <li>인자null/인자상태검사인 precondition도 검증안했고</li>
          <li>반환해줄 결과값인 result도 검증안했다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>이렇게 짜면, 제품세계에서 장난감이 되는 것이다. <strong>확정 버그 클래스로 보면 된다. pre/post condition/invaraint가 안걸린 class는 테스트도 필요없는 버그클래스다.</strong></p>
    <ul>
      <li>보자마자 병균. <strong>3가지를 만족하지 않으면, 아무리 단위테스트를 많이 짜도 101번째에 버그가 발생한다.</strong>
</li>
    </ul>
  </li>
</ul>

<h4 id="precondition메서드-인자이-검증이-없어서-찾아보는-원천-인자">
<a class="anchor" href="#precondition%EB%A9%94%EC%84%9C%EB%93%9C-%EC%9D%B8%EC%9E%90%EC%9D%B4-%EA%B2%80%EC%A6%9D%EC%9D%B4-%EC%97%86%EC%96%B4%EC%84%9C-%EC%B0%BE%EC%95%84%EB%B3%B4%EB%8A%94-%EC%9B%90%EC%B2%9C-%EC%9D%B8%EC%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>precondition(메서드 인자)이 검증이 없어서 찾아보는 원천 인자</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713101323490.png" alt="image-20220713101323490"></p>

<ul>
  <li>
    <p>전략객체calc의 <strong>전략메서드 calc를 호출하는 주체</strong>는 전략객체를 소유하고 있는 Calculator다</p>

    <ul>
      <li>
        <p><strong>PricePerTime에 precondition이 되는 인자를 준 놈은 Calculator이고</strong></p>
      </li>
      <li>
        <p>calc.calc()의 인자는 <strong>Calculator의 calcCallFee( , )의 파라미터에서 받아온다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713101534094.png" alt="image-20220713101534094"></p>
      </li>
      <li>
        <p>따라서, 넘어가는 파라미터에 대한 책임은 <strong>Calculator를 소유한 Plan에서 넣어주는 인자들</strong>이다.</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713101625017.png" alt="image-20220713101625017"></p>
      </li>
      <li>
        <p><strong>원천 인자를 찾아보니, Plan은 1건이상의 calls + 누적결과값변수의 초기값이라는 <code class="language-plaintext highlighter-rouge">최초 인자가 계약을 잘지킨 좋은 인자</code>를 <code class="language-plaintext highlighter-rouge">Plan과 Calculator사이에는 확신</code>할 수 있다.</strong></p>

        <ul>
          <li>
            <p>이렇게 되면, Calculator로 넘어간 파라미터는 precondition계약을 잘 지킨 좋은 인자라고 확신할 수 있다.</p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713102128596.png" alt="image-20220713102128596"></p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="좋은-인자로-전파가-시작됬다면-문제는-package와-접근제한자에-있다">
<a class="anchor" href="#%EC%A2%8B%EC%9D%80-%EC%9D%B8%EC%9E%90%EB%A1%9C-%EC%A0%84%ED%8C%8C%EA%B0%80-%EC%8B%9C%EC%9E%91%EB%90%AC%EB%8B%A4%EB%A9%B4-%EB%AC%B8%EC%A0%9C%EB%8A%94-package%EC%99%80-%EC%A0%91%EA%B7%BC%EC%A0%9C%ED%95%9C%EC%9E%90%EC%97%90-%EC%9E%88%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>좋은 인자로 전파가 시작됬다면, 문제는 package와 접근제한자에 있다</h4>

<ul>
  <li>
<strong>Calculator의 calcCallFee()는 좋은 인자를 받았다고 했지만, <code class="language-plaintext highlighter-rouge">public 메서드는 계약 맺은 Plan이 아닌 놈도 호출</code>할 수 있는 문제점이 있다</strong>
    <ul>
      <li>precondition을, 앞에서 호출하는 놈이 <strong>계약내용을 코드로 책임을</strong> 지어주었는데, <strong>public 메서드라 precondition의 계약내용을 책임을 안지어주는 놈이 나쁜 인자를 넣어서 호출할 수  있는 문제가 생길 수 있다.</strong>
</li>
    </ul>
  </li>
  <li>
<strong>우리가 계약을 믿으려면, Calculator의 메서드는 Plan만 호출할 수 있어야하고,Calc의 메서드는 Calculator만 호출할 수 있어야한다.</strong>
    <ul>
      <li>이것을 확정지어야 좋은 인자를 처음에 검사했다면, 더이상 precondition검사를 할 필요가 없게 된다.</li>
    </ul>
  </li>
  <li>
<strong>java의 package는 계약관계때문에 쓰는 것</strong>이다.
    <ul>
      <li>java같은 패키지언어에서는, 가상화경로를 가지는 package를 통해서 물리적인 위치의 불편함을 해소했다.
        <ul>
          <li>c의 manifest의 물리적인 파일위치용 package가 아니라 , 물리적 위치가 달라도 같은 패키지로 링킹</li>
        </ul>
      </li>
      <li><strong>계약관계로 인해서 package를 만들어 어떤애가 호출하지 못하게 만들려고 한다.</strong></li>
    </ul>
  </li>
  <li>plan은 calculator호출시 안전하다. 왜? plan에 계약서 내용이 명시되어 있어서
    <ul>
      <li>calculator가 calc를 호출하는 것도 안전하다. 왜? 이미 안전한 인자를 받아서 내부에서 호출하기 때문에</li>
    </ul>
  </li>
  <li><strong>계약의 체인을 확정하기 위해서는 <code class="language-plaintext highlighter-rouge">package 구성</code>를 통해 외부호출을 차단하고, 내부에서 좋은 인자로 체인이 가능하도록 해야한다</strong></li>
</ul>

<h4 id="계약체인을-보장하는-방법은-package구성을-통한-가시성-밖에-없다">
<a class="anchor" href="#%EA%B3%84%EC%95%BD%EC%B2%B4%EC%9D%B8%EC%9D%84-%EB%B3%B4%EC%9E%A5%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%80-package%EA%B5%AC%EC%84%B1%EC%9D%84-%ED%86%B5%ED%95%9C-%EA%B0%80%EC%8B%9C%EC%84%B1-%EB%B0%96%EC%97%90-%EC%97%86%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>계약체인을 보장하는 방법은 package구성을 통한 가시성 밖에 없다.</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713104558837.png" alt="image-20220713104558837"></p>

<ul>
  <li>
    <p>외부에서 간섭할 수 없게하려면, <strong>오직 Plan만이 인식할 수 있는 영역안에서만 Calculator를 호출할 수 있게 하고 싶다</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713104639985.png" alt="image-20220713104639985"></p>
  </li>
</ul>

<ol>
  <li>
    <p><strong>plan을 일단 <code class="language-plaintext highlighter-rouge">package plan</code>에 집어넣는다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713104730411.png" alt="image-20220713104730411"></p>
  </li>
  <li>
    <p>계산위임을 받아 내부에서 호출되며, <strong>계약된 인자를 받는 합성객체 Calculator도 package plan안으로</strong> 집어넣는다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713104901590.png" alt="image-20220713104901590"></p>

    <ul>
      <li><strong>Calculator자체는 client코드에서 new때려서 만들어야하기 때문에, public class여야한다.</strong></li>
      <li>
<strong>하지만 계약된 메소드calcCallFee 는 <code class="language-plaintext highlighter-rouge">접근제한자 없는 internal</code>로서 <code class="language-plaintext highlighter-rouge">패키지 안에서만 호출</code>된다.</strong>
        <ul>
          <li>이것으로 <strong>외부에서 더이상 계약된 메소드를 호출할 수 없음을 보장</strong>할 수 있다.</li>
          <li>package내부에서는 plan밖에 호출하지 않도록, 우리가 통제하고 있다.</li>
        </ul>
      </li>
      <li>
<strong>internal메서드를 통해서, 계약을 체결하고 있는 객체만 호출되도록 계약서에 추가명시된 것과 마찬가지다.</strong>
        <ul>
          <li><strong><code class="language-plaintext highlighter-rouge">internal</code>가시성을 통해 calcCallFee()메소드는<code class="language-plaintext highlighter-rouge">Plan에 독점공급</code>된다는 계약내용이 추가되었다.</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>문제는 Calculator에 주입되는 전략객체들을, Calculator만 호출할 수 있게 만드는 것이다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713105833512.png" alt="image-20220713105833512"></p>

    <ul>
      <li>일반 구상클래스들 합성에서는 같은 package에 넣고 호출되는 쪽 메서드를 internal로 만들면, 외부호출을 막을 수 있었음.</li>
      <li>
        <p>여러개의 합성객체들 및 전략메서드(인터페이스 오퍼레이터)를 internal로 막을 수 있을까?</p>
      </li>
      <li>
        <p><strong>일단 같은 pakcage안에 위치시킬 것인데, plan안에는 calc를 호출할 순 없다. 우리 통제권안에 있는 상태 = calculator만 호출할 수 있는 상태</strong>인데</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713110041775.png" alt="image-20220713110041775"></p>
      </li>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">java의 인터페이스</code>는 가시성 누수 때문에 <code class="language-plaintext highlighter-rouge">무조건 public으로 만들어야한다는 제한</code>이 생긴다.</strong></p>

        <ul>
          <li><strong>그렇다면, public외적인 가시성을 가지려면 인터페이스를 포기해야한다.</strong></li>
          <li><strong>인터페이스를 포기해도 두려워할 필요없다. 우리는 <code class="language-plaintext highlighter-rouge">좋은 부모를 만드는 방법</code>을 알기 때문에</strong></li>
        </ul>
      </li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713110231819.png" alt="image-20220713110231819"></p>

    <ul>
      <li>
<strong>가시성 확보를 위해, internal Calc 추상클래스와 internal calc추상메서드를 만들었다.</strong>
        <ul>
          <li>뿐만 아니라, <strong>Calc는 internal class기 때문에, 외부에서 상속도 할 수 없다.</strong>
</li>
        </ul>
      </li>
      <li><strong>전략객체들도, 훅메서드 구현구상체들도 변경해준다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713110751843.png" alt="image-20220713110751843"></p>

    <ul>
      <li>
<strong>훅메서드구현시 internal로 만들어, calculator만 Calc의 구상체들을 호출</strong>할 수 있도록 바뀌었다.
        <ul>
          <li>이렇게 calculator나 calc에서 precondition을 걸 필요가 없게 된다.</li>
          <li>처음에 계약된, plan이 주는  깨끗한 인자를 보장할 수 있게 되었으므로</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<ul>
  <li>
    <p><strong>무조건적으로 precondition이 없다고 나쁜코드가 아니다. 계약만 잘되어있다면, precondition은 보장되어서 걸 필요가 없게 된다.</strong></p>

    <ul>
      <li>
        <p>계약내용으로 <strong>코드만 있는게 아니라 가시성 조정도 계약의 일부였다.</strong></p>
      </li>
      <li>
<strong>짬이 생기면, package구성만으로도 어떤 계약을 맺고 있는지 보이게 된다.</strong>
        <ul>
          <li>my) 어?? precondition이 없네? -&gt; 같은 package내에서 계약관계로 보장되는가보네?</li>
          <li><strong>얘네들이 어떤 관계로 연관관계 계약관계를 맺고 있는지 보이네? 한쪽에만 집어넣으면, 나머지는 다 안전할 것이네</strong></li>
        </ul>
      </li>
      <li><strong>정상적으로 설계를 잘했다면, package별로 역할이 분리되어있고, package에 public으로 노출되는 메서드 인터페이스가 1개씩으로 구성되고, 안에서는 체인으로 막아줘야한다.</strong></li>
    </ul>
  </li>
</ul>

<h3 id="가시성을-위해-포기한-인터페이스로-인해-등장한-안좋은-부모">
<a class="anchor" href="#%EA%B0%80%EC%8B%9C%EC%84%B1%EC%9D%84-%EC%9C%84%ED%95%B4-%ED%8F%AC%EA%B8%B0%ED%95%9C-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A1%9C-%EC%9D%B8%ED%95%B4-%EB%93%B1%EC%9E%A5%ED%95%9C-%EC%95%88%EC%A2%8B%EC%9D%80-%EB%B6%80%EB%AA%A8" aria-hidden="true"><span class="octicon octicon-link"></span></a>가시성을 위해 포기한 인터페이스로 인해 등장한 안좋은 부모</h3>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713110751843.png" alt="image-20220713110751843"></p>

<ul>
  <li><strong>좋은 부모클래스는 abstract가 아니라 <code class="language-plaintext highlighter-rouge">템플릿메소드</code> +<code class="language-plaintext highlighter-rouge">protected abstract</code> 만 있어야한다.</strong></li>
  <li><strong>좋은 상속구상체는 @Override가 부모의 자체메소드가 아니라 <code class="language-plaintext highlighter-rouge">protected</code>만 있어야한다.</strong></li>
</ul>

<h4 id="문제점과-해결">
<a class="anchor" href="#%EB%AC%B8%EC%A0%9C%EC%A0%90%EA%B3%BC-%ED%95%B4%EA%B2%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>문제점과 해결</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713115518883.png" alt="image-20220713115518883"></p>

<ul>
  <li>
    <p><strong>부모가 internal의 abstract만 가지는게 아니라 public템플릿처럼 <code class="language-plaintext highlighter-rouge">(internal)템플릿</code>을 가져야한다.</strong></p>
  </li>
  <li>
    <p><strong>그리고 그 내부에, 자식들이 개별구현해야할 로직이 <code class="language-plaintext highlighter-rouge">전체로직이라고 할지라도 protected abstract 훅메서드</code>로 빼서 줘야한다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713115739279.png" alt="image-20220713115739279"></p>
  </li>
  <li>
    <p><strong>자식은 부모의 abstract메서드를 오버라이딩하는게 아니라  protected abstract 훅메서드만 오버라이딩 해야한다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713120111039.png" alt="image-20220713120111039"></p>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713120124043.png" alt="image-20220713120124043"></p>

<h4 id="계약관계라-할지라도-좋은부모자식의-protected관계라면-패키지를-이동시킬-수-있다">
<a class="anchor" href="#%EA%B3%84%EC%95%BD%EA%B4%80%EA%B3%84%EB%9D%BC-%ED%95%A0%EC%A7%80%EB%9D%BC%EB%8F%84-%EC%A2%8B%EC%9D%80%EB%B6%80%EB%AA%A8%EC%9E%90%EC%8B%9D%EC%9D%98-protected%EA%B4%80%EA%B3%84%EB%9D%BC%EB%A9%B4-%ED%8C%A8%ED%82%A4%EC%A7%80%EB%A5%BC-%EC%9D%B4%EB%8F%99%EC%8B%9C%ED%82%AC-%EC%88%98-%EC%9E%88%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>계약관계라 할지라도, 좋은부모자식의 protected관계라면, 패키지를 이동시킬 수 있다.</h4>

<ul>
  <li>
    <p>계약관계로 internal로만 호출되게 하기 위해 같은 package에 위치시켰었는데</p>

    <ul>
      <li><strong>Calculator와 calc는 이제 인터페이스&lt;-&gt;전략객체의 관계가 아닌 <code class="language-plaintext highlighter-rouge">부모&lt;-&gt;자식</code>관계이므로 <code class="language-plaintext highlighter-rouge">package의 위치와 상관없이 protected범위인 자식이 어디서든 호출될 수 있다.</code></strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713120325865.png" alt="image-20220713120325865"></p>

    <ul>
      <li><strong>plan &lt;-&gt; calculator: 같은package의 internal관계</strong></li>
      <li>
        <p><strong>calculator &lt;-&gt; calc구상체들: protected관계로서 아무package나 위치해도 가능</strong></p>
      </li>
      <li>부모만 바깥의 상투클래스로 나가있고, 자식들은 내부의 다른 패키지에 위치시켜놓는다.</li>
    </ul>
  </li>
  <li>
    <p>package구성은 카테고리만 할 것이 아니라 계약관계에 달려있다.</p>
    <ul>
      <li><strong>전략인터페이스였던, 구상체들의 <code class="language-plaintext highlighter-rouge">부모 Calc추상클래스만 Calculator와 계약</code>하는 것이고 <code class="language-plaintext highlighter-rouge">구상클래스들은 Calc와 proected로서 따로 계약하여 따로 위치</code>하고 있다.</strong></li>
    </ul>
  </li>
</ul>

<h4 id="계약관계에-의한-package-최종-구성">
<a class="anchor" href="#%EA%B3%84%EC%95%BD%EA%B4%80%EA%B3%84%EC%97%90-%EC%9D%98%ED%95%9C-package-%EC%B5%9C%EC%A2%85-%EA%B5%AC%EC%84%B1" aria-hidden="true"><span class="octicon octicon-link"></span></a>계약관계에 의한 package 최종 구성</h4>

<ul>
  <li>
    <p><strong>package구성을 끝내면, <code class="language-plaintext highlighter-rouge">calc안에는 구상체들만 구성</code>되어있고 <code class="language-plaintext highlighter-rouge">나머지 계약관계의 주인공들은 밖에서 같은pacakge내 internal로 통신하는 병행package를 구성</code>되어있다</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713120730090.png" alt="image-20220713120730090"></p>

    <p>​	<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713121307458.png" alt="image-20220713121307458">
<img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713121342208.png" alt="image-20220713121342208"></p>

    <ul>
      <li>노란색들은 외부호출이 안되서 보호됨. -&gt; <strong>따라서 앞에 계약만 확실하다면, 아래부분은 검증하지 않아도 된다.</strong>
        <ul>
          <li>precondition은 plan에서만 처리되고 다른 곳에서는 안했다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="postcondition검사는">
<a class="anchor" href="#postcondition%EA%B2%80%EC%82%AC%EB%8A%94" aria-hidden="true"><span class="octicon octicon-link"></span></a>postcondition검사는?</h3>

<ul>
  <li>아래 파란색 인자는, <strong>precondition검사는 <code class="language-plaintext highlighter-rouge">더 상위레이어에서 계약을 체결</code>해서 생략되었다.</strong>
    <ul>
      <li>precondition 검사는 <strong>반드시 명시적인 validation코드가 있어야만 하는 것이 아니었다. 가시성으로 계약을 체결해서 해결된다. 특히 condition체인들이 해결된다.</strong>
</li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713121538506.png" alt="image-20220713121538506"></p>

<h4 id="condition검사할-때-메세지-처리전-상태필드들의-invariant뿐만-아니라-postcondition검사-이전에-로직에-사용된-보라색-필드들에도-주목해야한다">
<a class="anchor" href="#condition%EA%B2%80%EC%82%AC%ED%95%A0-%EB%95%8C-%EB%A9%94%EC%84%B8%EC%A7%80-%EC%B2%98%EB%A6%AC%EC%A0%84-%EC%83%81%ED%83%9C%ED%95%84%EB%93%9C%EB%93%A4%EC%9D%98-invariant%EB%BF%90%EB%A7%8C-%EC%95%84%EB%8B%88%EB%9D%BC-postcondition%EA%B2%80%EC%82%AC-%EC%9D%B4%EC%A0%84%EC%97%90-%EB%A1%9C%EC%A7%81%EC%97%90-%EC%82%AC%EC%9A%A9%EB%90%9C-%EB%B3%B4%EB%9D%BC%EC%83%89-%ED%95%84%EB%93%9C%EB%93%A4%EC%97%90%EB%8F%84-%EC%A3%BC%EB%AA%A9%ED%95%B4%EC%95%BC%ED%95%9C%EB%8B%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>condition검사할 때, 메세지 처리전 상태(필드)들의 invariant뿐만 아니라, postcondition검사 이전에, 로직에 사용된 보라색 필드들에도 주목해야한다.</h4>

<ul>
  <li>
    <p><strong>결과값 검증하기 전에, <code class="language-plaintext highlighter-rouge">내 필드값들이 눈에 밟혀서 invariant검증이 안된 것이 눈에 밟혀야한다.</code></strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713121910224.png" alt="image-20220713121910224"></p>
  </li>
  <li>
    <p><strong>result를 검증하기 전에, 사용되는 필드들 invariant부터 안정화되어야한다.</strong></p>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713122017278.png" alt="image-20220713122017278"></p>

<ul>
  <li>
    <p>**<code class="language-plaintext highlighter-rouge">해당 invariant들을 보니 생성자 type</code>이다 -&gt; <code class="language-plaintext highlighter-rouge">컴파일타임에 1번 null + 상태검사해서 invariant를 1번에 확정</code>지을 수 있겠다. **</p>

    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">setter로 상태가 변해서 런타임검사시 호출될때마다 매번 검사</code>안해도 되겠다.</strong></li>
    </ul>
  </li>
  <li>
    <p><strong>null체크 뿐만 아니라, <code class="language-plaintext highlighter-rouge">하한을 가지는 객체는 하한선도 같이 섬세하게 검사하는 도메인검사</code>도 같이 한다</strong></p>

    <ul>
      <li>
        <p>**price의 <code class="language-plaintext highlighter-rouge">상태검증</code>은 <code class="language-plaintext highlighter-rouge">물어보면 변화의 여파가 오니, 스스로 죽도록 시켜</code>서 price.check()로 변경할 수 있다. **</p>

        <ul>
          <li><strong>게다가, <code class="language-plaintext highlighter-rouge">||로 연결되어야하는 상황이니 불린flag를 반환해주도록 .isChecked()로 만들어줘야한다?</code></strong></li>
        </ul>
      </li>
      <li>
        <p>Money라는 형은 언제든지 바뀔 수 있는 객체라서, 충격을 감당하려면, 처음부터 OverZeroMoney라는 형을 새로 만들어서 받아도 된다.</p>

        <ul>
          <li>검증만큼 형을 만들어주면 다 해결 된다. <strong>형을 안받은 만큼, 형 안받은 포괄쪽인 곳에 코드로 나오게 되고 하드코딩이 되고 변화가 생기면 하드코딩해야한다. 그러나 형을 만들면, 그 형만 바꾸면 된다.</strong>
</li>
        </ul>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713123110846.png" alt="image-20220713123110846"></p>
      </li>
      <li>
        <p><strong>하지만, Duration 타입은, 외부객체라서 내가 시킬수 없다.</strong></p>

        <ul>
          <li>Duration을 상속받은 &amp;&amp; isChecked()를 가진 새로운형을 이용해서 처리해도 되긴한다.</li>
          <li>
            <p>새로만든 형만 오면 검증을 안해도 되는 로직으로 만들어도 된다.</p>
          </li>
          <li>형으로 해결하는 것이 코드가 줄기 때문에 더 우아하다</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="다시-postcondition검사로">
<a class="anchor" href="#%EB%8B%A4%EC%8B%9C-postcondition%EA%B2%80%EC%82%AC%EB%A1%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>다시 postcondition검사로</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220713125344236.png" alt="image-20220713125344236"></p>

<ul>
  <li>calls는 1건이상으로 들어도록 해놨고
    <ul>
      <li>call마다 먼저 계산을 한다.
        <ul>
          <li>최종반환 전에, for문의 개별 결과값도 만든 뒤 postcondition검사를 한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<strong>sum을 다 계산한 <code class="language-plaintext highlighter-rouge">나만의 계산</code>이 맞는지 result이전에 <code class="language-plaintext highlighter-rouge">지역변수 sum을 만들어 계산</code>한다.</strong>
    <ul>
      <li><strong>result는 <code class="language-plaintext highlighter-rouge">건너온 메세지로서 객체context로, postcondition검증이 다 끝난 후에야 업데이트</code>해줘야한다.</strong></li>
      <li>그러기 위해 <strong>초기값 ZERO result를 바로 사용하지 않고, 지역변수에 새로 할당해서 나만의 계산을 먼저 한다.</strong>
</li>
    </ul>
  </li>
  <li>
<strong>기존에는 그냥 객체context(파라미터 result)에 바로 더했던 것에 비해서, 나만의 계산부터 먼저할 수 있도록 한다.</strong>
    <ul>
      <li><strong>postcondition을 고려하지 않고, 바로 context에 때려박으면, 디버깅도 X 추적도 X</strong></li>
    </ul>
  </li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">반드시 끊을 수 있게 지역변수를 선언해서 짜야</code>한다.</strong>
    <ul>
      <li>sum단계</li>
      <li>r단계</li>
      <li>sum다시 검사(<strong>여긴 없는데 sum이 0이상인지도 검사해야하는데, 암묵지로 생략해버린 것은 문제점이다.</strong>)</li>
    </ul>
  </li>
  <li>**단계별로 postcondition검사를 할 수 있는 로직으로 짜야한다. **
    <ul>
      <li><strong>그렇게 짜지 않았더라면, 테스트를 안하고 짠 것이다.</strong></li>
      <li><strong>지역변수로 받아서, 중간상태를 볼 수 있는 상태/검사가능한 상태로 바꿔줘야한다.</strong></li>
    </ul>
  </li>
  <li>
    <p><strong>코드로 계약을 짜야하고, 단계별로 검사할 수 있도록 짜야한다.</strong></p>

    <ul>
      <li>
        <p><strong>계약내용(pre, post, invariant) vs 로직</strong>을 구분해서 확인가능하도록 짜여져야함</p>
      </li>
      <li>코드의 70%는 계약서내용이고, <strong>중간에 지역변수 쓴 것도 다 계약내용 때문이다.</strong> 알고리즘은 아주조금만 들어가있다.</li>
      <li><strong>코드로 명시하는 것은, thr의 제어문으로 만들 수 도 있지만, 형을 만드는 것으로 바꿔서, 그 코드를 형으로 그대로 옮겨줘도 된다.</strong></li>
    </ul>
  </li>
</ul>


  </div><a class="u-url" href="/object/2022/06/11/((object2-1)%EC%A0%95%EC%B1%85%EC%A0%81%EC%9A%A9%EA%B0%9D%EC%B2%B4%EB%93%A4%EC%9D%98-%EA%B3%84%EC%95%BD%EA%B4%80%EA%B3%84-%EB%B3%B5%EC%82%AC%EB%B3%B8.html" hidden></a>
</article>


<!-- <script src="https://utteranc.es/client.js"
        repo="is2js/blog_raw"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script> -->
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="https://blog.chojaeseong.com/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>평범한 한의사 돌범의 엔지니어 도전기</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
  <a href="/feed.xml" target="_blank" title="rss">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://github.com/is2js/" target="_blank" title="github">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#github"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://twitter.com/yarotheslav" target="_blank" title="twitter">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#twitter"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://www.linkedin.com/in/yshmarov/" target="_blank" title="linkedin">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#linkedin"></use>
    </svg>
  </a>
</li>
</ul>
</div>

  </div>

</footer>
</body>

</html>
