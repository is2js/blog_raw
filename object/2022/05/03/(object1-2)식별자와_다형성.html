<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">OBJECT 02 식별자와 다형성(코드스핏츠)</h1><p class="page-description">object 책을 강의한 코드스핏츠 유튜브 요약</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-05-03T00:00:00-05:00" itemprop="datePublished">
        May 3, 2022
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      4 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/categories/#object">object</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <!-- toc가 먼저 나오므로 h3로 안내하기 -->
    <h3>📜 제목으로 보기</h3>
    <ul class="section-nav">
<li class="toc-entry toc-h3"><a href="#ch2-객체지향이라면">ch2. 객체지향이라면</a>
<ul>
<li class="toc-entry toc-h4"><a href="#value--identifier-객체는-값이-아닌-식별자메모리주소로-식별">value &lt; identifier: 객체는 값이 아닌 식별자(메모리주소)로 식별</a></li>
<li class="toc-entry toc-h4"><a href="#polymorphism-이게-지원되야-진짜-객체지향">Polymorphism: 이게 지원되야 진짜 객체지향</a>
<ul>
<li class="toc-entry toc-h5"><a href="#대체가능성-포인터1위쪽-여러-형들-껍데기의-포인터2변형가능성있는-메소드-or-변수">대체가능성: 포인터1(위쪽 여러 형들, 껍데기)의 포인터2(변형가능성있는 메소드 or 변수)</a></li>
<li class="toc-entry toc-h5"><a href="#내적-동질성-메소드참조는-다른-형인-상태라도-출신class메소드를-참조">내적 동질성: 메소드참조는 다른 형인 상태라도 출신class메소드를 참조</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#object">object</a></li>
</ul>
</li>
</ul><ul>
  <li>참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk</li>
  <li>정리본: https://github.com/LenKIM/object-book</li>
  <li>코드: https://github.com/eternity-oop/object</li>
  <li>책(목차) : https://wikibook.co.kr/object/</li>
</ul>

<h3 id="ch2-객체지향이라면">
<a class="anchor" href="#ch2-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%B4%EB%9D%BC%EB%A9%B4" aria-hidden="true"><span class="octicon octicon-link"></span></a>ch2. 객체지향이라면</h3>

<h4 id="value--identifier-객체는-값이-아닌-식별자메모리주소로-식별">
<a class="anchor" href="#value--identifier-%EA%B0%9D%EC%B2%B4%EB%8A%94-%EA%B0%92%EC%9D%B4-%EC%95%84%EB%8B%8C-%EC%8B%9D%EB%B3%84%EC%9E%90%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%A3%BC%EC%86%8C%EB%A1%9C-%EC%8B%9D%EB%B3%84" aria-hidden="true"><span class="octicon octicon-link"></span></a>value &lt; identifier: 객체는 값이 아닌 식별자(메모리주소)로 식별</h4>

<ul>
  <li>
    <p>값과 식별자</p>

    <ul>
      <li>
        <p>객체지향에서의 <strong><code class="language-plaintext highlighter-rouge">객체</code> 구분은 <code class="language-plaintext highlighter-rouge">식별자</code>(runtime 적재되어있는 <code class="language-plaintext highlighter-rouge">메모리주소</code>)</strong> 한다.</p>
      </li>
      <li>
        <p>값이 같다고 똑같은 객체X <strong><code class="language-plaintext highlighter-rouge">메모리주소</code>가 같다 = 같은 <code class="language-plaintext highlighter-rouge">식별자</code> = 같은 <code class="language-plaintext highlighter-rouge">객체</code>다</strong></p>
      </li>
      <li>
        <p>값을 사용하는 context는 값만 같으면 같은 것이다.</p>
      </li>
      <li>
        <p>값이 같더라도 메모리로 같고 다름을 평가한다? 객체로 평가한 것이다.</p>
      </li>
      <li>
        <p><strong>java에서 문자열 비교시 .equals()를 사용하는 이유</strong></p>

        <ul>
          <li><strong>java에서는 <code class="language-plaintext highlighter-rouge">그냥 비교</code>하면 <code class="language-plaintext highlighter-rouge">식별자</code>를 비교해버린다.</strong></li>
          <li>문자열을 값으로서 비교를 원하면 equals를 써야한다.</li>
        </ul>
      </li>
      <li>
        <p>현대언어에서는 이 모순(그냥 비교 == 식별자 비교 like java)를 해결해서</p>

        <ul>
          <li>값 context를 쓰는 애들은, <code class="language-plaintext highlighter-rouge">그냥 비교</code> = <code class="language-plaintext highlighter-rouge">값 비교</code>가 default가 연산자가 작동하게 된다.</li>
          <li>javascript에서는 string을 객체로 안보고 값으로 본다.
            <ul>
              <li>할당하거나 인자를 보내면 무조건 복제본이 된다.(주소전달X)</li>
              <li>비교시에도 안에 내용물만 비교</li>
            </ul>
          </li>
          <li>java에서는 string을 값으로 보기엔, 사람들이 너무 멍청하니까, 기본적으로 객체(식별자)로 기본 비교하게 해놨다. -&gt; equals()를 써야 값으로만 비교한다.
            <ul>
              <li>비교시, 메모리의 주소인 식별자로 평가된다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>name이라는 <code class="language-plaintext highlighter-rouge">field</code>를 이용해서,  equals 메소드를 <code class="language-plaintext highlighter-rouge">field 값</code>이 <code class="language-plaintext highlighter-rouge">== 같은지</code>의 결과로 판단하도록 메소드를 짠다.
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220122193121636.png" alt="image-20220122193121636"></p>

        <ul>
          <li>
            <p><strong>(필드)값으로써 비교하는 메소드가 된다.</strong></p>
          </li>
          <li>
            <p><strong>값으로 쓰려고 마음 먹은 메소드. 더이상 객체가 아니라고 생각한다</strong></p>
          </li>
          <li>
            <p>cf) 코틀린에서 <code class="language-plaintext highlighter-rouge">==</code> : 값으로 평가 <code class="language-plaintext highlighter-rouge">equals()</code>를 호출 / <code class="language-plaintext highlighter-rouge">===</code> : 식별자로 평가</p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220122193414611.png" alt="image-20220122193414611"></p>

            <ul>
              <li>
<code class="language-plaintext highlighter-rouge">값</code>으로 평가하는 메소드 <code class="language-plaintext highlighter-rouge">ValueType()</code>는 true가 나오고</li>
              <li>
<code class="language-plaintext highlighter-rouge">식별자</code>비교시에는 false가 나온다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p><strong>내가 이 객체를 값으로 볼지 vs 객체로 볼지 를 먼저 정해야한다.</strong></p>

        <ul>
          <li><strong>객체로 본다면 -&gt; 무슨 값을 가지든 식별자로서 확인이 된다</strong></li>
          <li><strong>값으로 본다면 -&gt; 안에 있는 값만 확인한다.</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>객체지향에서는 객체를 지향하므로 <strong>모든 평가를 <code class="language-plaintext highlighter-rouge">식별자(identifier)</code>로 평가한다?</strong></p>

    <ul>
      <li>
        <p><strong>Okay. 미리 정해진 답이 아니라면 객체로 쓰자</strong>.</p>

        <ul>
          <li>
            <p><strong>우리는 식별자로 시스템을 만들어가야한다</strong></p>
          </li>
          <li>
            <p>setter로 협력자 객체를 받아왔다?</p>

            <ul>
              <li><strong>값으로 확인? (X) 식별자context를 통해서 식별한다.</strong></li>
            </ul>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220122194001367.png" alt="image-20220122194001367"></p>
          </li>
        </ul>
      </li>
      <li>
        <p>특정값을 정해서 미리 가지고 있는 유형이 아니라면</p>

        <ul>
          <li>객체지향이라고 해서 숫자, 문자 안쓰는 것은 아님.</li>
          <li>값 지향 -&gt; 함수형 시스템에서는 참조를 지향하지 않는다
            <ul>
              <li>불변성과 순수함수를 위해서</li>
              <li>똑같이 나오려면 값 지향을 해야한다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="polymorphism-이게-지원되야-진짜-객체지향">
<a class="anchor" href="#polymorphism-%EC%9D%B4%EA%B2%8C-%EC%A7%80%EC%9B%90%EB%90%98%EC%95%BC-%EC%A7%84%EC%A7%9C-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5" aria-hidden="true"><span class="octicon octicon-link"></span></a>Polymorphism: 이게 지원되야 진짜 객체지향</h4>

<ul>
  <li>객체지향이라 부를려면, <code class="language-plaintext highlighter-rouge">폴리모피즘(다형성)</code>이 시스템에서 지원되어야 객체지향이라 부를 수 있다.
    <ul>
      <li>
<strong>이게 안되면</strong> 객체지향 <strong>방식으로 짜는 것일 뿐</strong>이다.</li>
    </ul>
  </li>
  <li>
<strong>다형성은 구체적인 2가지 요소가 충족</strong>되어야한다.
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">Substitution(대체가능성)</code>:</strong></li>
      <li><strong><code class="language-plaintext highlighter-rouge">Internal identity(내적동질성)</code>:</strong></li>
    </ul>
  </li>
</ul>

<h5 id="대체가능성-포인터1위쪽-여러-형들-껍데기의-포인터2변형가능성있는-메소드-or-변수">
<a class="anchor" href="#%EB%8C%80%EC%B2%B4%EA%B0%80%EB%8A%A5%EC%84%B1-%ED%8F%AC%EC%9D%B8%ED%84%B01%EC%9C%84%EC%AA%BD-%EC%97%AC%EB%9F%AC-%ED%98%95%EB%93%A4-%EA%BB%8D%EB%8D%B0%EA%B8%B0%EC%9D%98-%ED%8F%AC%EC%9D%B8%ED%84%B02%EB%B3%80%ED%98%95%EA%B0%80%EB%8A%A5%EC%84%B1%EC%9E%88%EB%8A%94-%EB%A9%94%EC%86%8C%EB%93%9C-or-%EB%B3%80%EC%88%98" aria-hidden="true"><span class="octicon octicon-link"></span></a>대체가능성: 포인터1(위쪽 여러 형들, 껍데기)의 포인터2(변형가능성있는 메소드 or 변수)</h5>

<ul>
  <li>예를 들어
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220122195245713.png" alt="image-20220122195245713">
    <ul>
      <li>클래스 Worker가 Runnable(인터페이스)를 implements해서 run()을 구현하고 있다.</li>
      <li>이 때, 클래스Worker()객체는 Worker형이 아니라, Runnable형(인터페이스를 형)으로 지정해서 객체를 집어넣는다.
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220122195422209.png" alt="image-20220122195422209">
        <ul>
          <li>
<strong>worker는 클래스Worker타입인데, 어떻게 인터페이스Runnable타입으로 들어갔을까</strong>
            <ul>
              <li>
<strong>클래스Worker가 인페Runnable을 구상한 것이기 때문에 가능</strong>해진다.</li>
              <li>
<strong><code class="language-plaintext highlighter-rouge">자기형은 아닌데 자기형을 포괄하는 형에는 소속될 수 있다.</code>(상속아니므로 실제 포괄X)</strong>
                <ul>
                  <li>클래스Wokrer는 자기형=Worker형뿐만 아니라 Runnable형을 가지고 있다. 둘 중에 하나를 선택해서 객체를 집어넣을 수 있다.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>**포괄하는형에 넣은 순간부터는 worker는 Worker로서는 기능하지 못하고 Runnable로써 밖에 기능을 못한다 **
        <ul>
          <li><strong>왜냐면, <code class="language-plaintext highlighter-rouge">Pointer of Pointer</code>개념으로서, <code class="language-plaintext highlighter-rouge">껍데기인 Runnable</code>의 포인터를 통해서 <code class="language-plaintext highlighter-rouge">worker</code>의 포인터를 다루게 되므로</strong></li>
          <li>
<strong>Runnable의 포인터를 통해서 worker를 다루게 되므로</strong>
            <ul>
              <li><strong>Runnable안에 있는 집합만 사용가능</strong></li>
              <li><strong>Worker객체지만, Worker의 run()만 사용가능해짐</strong></li>
              <li>Runnable - run() —매핑—&gt; 실제구현된 worker 속 run() 메소드</li>
              <li>사용자는 Runnable 밖에 못다룬다. -&gt; run() 밖에 못다룬다.</li>
              <li>run()을 찾아들어간다면?  직접 run()? ㄴㄴ
                <ul>
                  <li>관계에 의해 Runnable을 통해 -&gt; run() -&gt; 매핑 -&gt; 실제구현된 worker의 run() 메소드까지 포인터의 포인터로 찾아들어간다.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>다형성을 쓰면, 직접 run()을 호출하는 것보다 느려질 수 밖에 없게 된다.
            <ul>
              <li>포인터의 포인터를 찾아가서. 그냥 바로 쓰는게 아니다.</li>
              <li>다형성은 꽁짜가 아니라 비용이 크다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>자세히 보자면
    <ul>
      <li>인터페이스 상속한 클래스가 객체를 생성하는 순간, 쉽게 생각하려면, 
  <strong>객체 생성자 호출시 -&gt;  메모리 속에 2개의 변수가 동시에 생성된다고 생각</strong>하자.
        <ul>
          <li><strong>Runnable 객체</strong></li>
          <li><strong>Worker 객체</strong></li>
          <li>
<strong>2개 중에 배정하는 형에 포인터를 배정</strong>한다.
            <ul>
              <li>Runnable</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Runnable 객체인 <code class="language-plaintext highlighter-rouge">worker.run()</code>을 때리면 run()을 찾기 위해서
        <ul>
          <li>Runnable(껍데기 포인터)부터 찾아들어간 다음</li>
          <li>run(내부 포인터)를 찾아들어간 다음</li>
          <li>실제 구현부 Worker - run()을 찾아들어간다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>대체가능성(포인터의 포인터)을 실현하는 방법은 간단하다
    <ul>
      <li>자바스크립트: 프로토타입 체인 생성 -&gt; 포인터의 포인터…</li>
      <li>책에서는 <code class="language-plaintext highlighter-rouge">동적 바인딩</code>이라 부르는데, runtime에서 포인터의 연쇄를 계산하기 때문이다.</li>
    </ul>
  </li>
  <li>이번에는 인터페이스 -&gt; 구현이 아니라, class -&gt; 상속받은 클래스를 예를 들어보자.
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220122201811311.png" alt="image-20220122201811311">
    <ul>
      <li>HardWorker()의 생성자를 호출하는 순간, 3개형의 변수가 메모리에 생성된다
        <ul>
          <li>Runnable</li>
          <li>Worker</li>
          <li>HardWorker
            <ul>
              <li>
<strong>3개 중에 배정하는 형에 포인터를 배정</strong>한다.</li>
            </ul>
          </li>
          <li>
<strong>Runnable형인 <code class="language-plaintext highlighter-rouge">worker =</code> 변수에다가 할당</strong>해주는 순간
            <ul>
              <li>Runnable에 포인터를 배정하게 된다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<strong>대체가능성</strong>의 실체
    <ul>
      <li>
<strong>내가 객체를 만들 때, 다수의 형(상속, 구현 등 위쪽 껍데기-포인터1 후보들)을 선택할 수 있는 가능성</strong>이며</li>
      <li>
<strong>하나의 형을 선택하면, 그 형에 해당되는 포인터를 노출함으로써</strong>
  <strong><code class="language-plaintext highlighter-rouge">동적 바인딩</code>으로 진짜 구현되어있는 곳으로 인도하는 행위</strong>
</li>
    </ul>
  </li>
</ul>

<h5 id="내적-동질성-메소드참조는-다른-형인-상태라도-출신class메소드를-참조">
<a class="anchor" href="#%EB%82%B4%EC%A0%81-%EB%8F%99%EC%A7%88%EC%84%B1-%EB%A9%94%EC%86%8C%EB%93%9C%EC%B0%B8%EC%A1%B0%EB%8A%94-%EB%8B%A4%EB%A5%B8-%ED%98%95%EC%9D%B8-%EC%83%81%ED%83%9C%EB%9D%BC%EB%8F%84-%EC%B6%9C%EC%8B%A0class%EB%A9%94%EC%86%8C%EB%93%9C%EB%A5%BC-%EC%B0%B8%EC%A1%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>내적 동질성: 메소드참조는 다른 형인 상태라도 출신class메소드를 참조</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220122211317113.png" alt="image-20220122211317113"></p>

<ul>
  <li>
    <p>Worker클래스안에 print()라는 메소드를 신설했다.</p>

    <ul>
      <li>보면, 내부에서는 run()을 호출하면서 프린트한다.</li>
    </ul>
  </li>
  <li>
    <p>HardWorker객체를 Runnable형이 아니라 Worker형으로 만들었다.</p>

    <ul>
      <li>HardWorker()를 만드는 순간,
        <ul>
          <li>Runnable형</li>
          <li>Worker형</li>
          <li>HardWork형의 변수가 3개가 생성되며</li>
        </ul>
      </li>
      <li>Worker형에 넣은 순간, 포인터가 Worker를 가리킨다고 했다.</li>
    </ul>
  </li>
  <li>
    <p><strong>그렇다면, worker.print() 때린다면</strong></p>

    <ul>
      <li>포인터가 가리키는 —&gt; Worker —&gt; 그내부 print()호출시, println( <strong>run()</strong> )에서의 run()은 <strong>this.run()</strong>일 텐데
        <ul>
          <li>
<strong>Worker내부의 run()일까?  아니면 HardWorker내부의 run()일까?</strong>
            <ul>
              <li>나는 지금 Worker의 context로 들어와서 호출한 상태임.</li>
              <li>context상 바로 위에 있는 Worker의 run()일까?  아니면 생성자 Hardworker()의 객체의 run()일까?</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>OOP 객체지향 프로그래밍에서 약속한 <code class="language-plaintext highlighter-rouge">내적 동질성</code>에 의해</strong></p>

    <ul>
      <li><strong>최초 생성한 객체(HardWorker)에 <code class="language-plaintext highlighter-rouge">함수포인터</code>는 여기로 유지하겠다.</strong></li>
      <li>
<strong><code class="language-plaintext highlighter-rouge">비록 형은 달라지더라도, 변형된 형(class)속 함수가 아니라 내적으로 동질성은 유지하기 위해 생성자를 호출한 출신지class의 함수를 참조</code>한다.</strong>
        <ul>
          <li>Worker형으로 포장되더라도 run() 메소드는, Worker의 run()이 아니라 원래 객체의 class인 HardWorker의 run()을 참조한다.</li>
          <li><strong>메소드 참조에서는 출신지가 더 중요하다.</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="object">
<a class="anchor" href="#object" aria-hidden="true"><span class="octicon octicon-link"></span></a>object</h4>

<ul>
  <li>객체지향에서 객체가 갖춰야할 2가지
    <ol>
      <li>
<strong><code class="language-plaintext highlighter-rouge">기능의 캡슐화(Encapsulation of Functionality)</code></strong>
        <ul>
          <li>ATM기: 외부에 상세기능을 다 노출하지 않고, 보다 잘 쓸 수 있게 노출한다.</li>
          <li>이것을 하는 이유는 궁극적인 목표는, <strong><code class="language-plaintext highlighter-rouge">변화에 따라서 프로그램 수정/추가 등을 격리시키기 위함</code></strong>이다.
            <ul>
              <li><strong><code class="language-plaintext highlighter-rouge">캡슐화</code>하여 일부만 외부노출 -&gt; 다양한 나머지들은 <code class="language-plaintext highlighter-rouge">내부에 갖힘 = 격리 -&gt; 외부에 영향 줄어듬</code></strong></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
<strong><code class="language-plaintext highlighter-rouge">상태 관리(Maintenance of State)</code></strong>
        <ul>
          <li>
<code class="language-plaintext highlighter-rouge">관리</code> 중 대표적인 것이 은닉화</li>
          <li>자율적인 데이터 갱신</li>
          <li>변화시 외부 노티피케이션</li>
          <li>B가 배신때릴 때, C와 D가 망가진 것은 상태관리에 실패한 것</li>
          <li><strong>객체지향이 레퍼런스를 가리키고, 식별자로 참작, 식별자로만 구분 등 하는 이유는 <code class="language-plaintext highlighter-rouge">포인터의 포인터</code>를 쓰기 위함이다. 더 근본적으로는 상태관리를 위해서</strong></li>
        </ul>
      </li>
    </ol>
  </li>
  <li>격리되었는지 안되어있는지 확인 -&gt; 해당안건의 특정 파일만 수정했는데 성공</li>
</ul>


  </div><a class="u-url" href="/object/2022/05/03/(object1-2)%EC%8B%9D%EB%B3%84%EC%9E%90%EC%99%80_%EB%8B%A4%ED%98%95%EC%84%B1.html" hidden></a>
</article>