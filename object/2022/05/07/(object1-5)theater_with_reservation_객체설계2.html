<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>OBJECT 05 객체설계2_Theater_with_Reservation(코드스핏츠) | 돌범텤놑</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="OBJECT 05 객체설계2_Theater_with_Reservation(코드스핏츠)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="object 책을 강의한 코드스핏츠 유튜브 요약" />
<meta property="og:description" content="object 책을 강의한 코드스핏츠 유튜브 요약" />
<link rel="canonical" href="blog.chojaeseong.com/object/2022/05/07/(object1-5)theater_with_reservation_%EA%B0%9D%EC%B2%B4%EC%84%A4%EA%B3%842.html" />
<meta property="og:url" content="blog.chojaeseong.com/object/2022/05/07/(object1-5)theater_with_reservation_%EA%B0%9D%EC%B2%B4%EC%84%A4%EA%B3%842.html" />
<meta property="og:site_name" content="돌범텤놑" />
<meta property="og:image" content="blog.chojaeseong.com/images/posts/java.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-07T00:00:00-05:00" />
<script type="application/ld+json">
{"datePublished":"2022-05-07T00:00:00-05:00","url":"blog.chojaeseong.com/object/2022/05/07/(object1-5)theater_with_reservation_%EA%B0%9D%EC%B2%B4%EC%84%A4%EA%B3%842.html","@type":"BlogPosting","image":"blog.chojaeseong.com/images/posts/java.png","headline":"OBJECT 05 객체설계2_Theater_with_Reservation(코드스핏츠)","dateModified":"2022-05-07T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"blog.chojaeseong.com/object/2022/05/07/(object1-5)theater_with_reservation_%EA%B0%9D%EC%B2%B4%EC%84%A4%EA%B3%842.html"},"description":"object 책을 강의한 코드스핏츠 유튜브 요약","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<!-- 폰트추가를 위한 link태그 삽입 -->
  <!-- 폰트1:  기본 spoqa 웹폰트 -->
  <!-- css에서 * {} 다 뒤집어씀. -->
  <link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSansNeo.css' rel='stylesheet' type='text/css'>
  <!-- 폰트2:  블로그 제목들 sunflower 웹폰트 -->
  <!-- 쥬피터 등 포스트 내부 글자 h1, h2 제목은 sunflower체 도입 -->
  <link href="//fonts.googleapis.com/css?family=Sunflower:300,500,700" rel="stylesheet"> 

  <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="blog.chojaeseong.com/feed.xml" title="돌범텤놑" /><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">돌범텤놑</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About Me</a><a class="page-link" href="/search/">Search</a><a class="page-link" href="/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">OBJECT 05 객체설계2_Theater_with_Reservation(코드스핏츠)</h1><p class="page-description">object 책을 강의한 코드스핏츠 유튜브 요약</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-05-07T00:00:00-05:00" itemprop="datePublished">
        May 7, 2022
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      21 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/categories/#object">object</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <!-- toc가 먼저 나오므로 h3로 안내하기 -->
    <h3>📜 제목으로 보기</h3>
    <ul class="section-nav">
<li class="toc-entry toc-h3"><a href="#ch5-theater-with-reservation">ch5. Theater with Reservation</a>
<ul>
<li class="toc-entry toc-h4"><a href="#저번시간까지-모델">저번시간까지 모델</a></li>
<li class="toc-entry toc-h4"><a href="#이번-시간-모델">이번 시간 모델</a></li>
<li class="toc-entry toc-h4"><a href="#main">Main</a></li>
<li class="toc-entry toc-h4"><a href="#"></a>
<ul>
<li class="toc-entry toc-h5"><a href="#검토하기">검토하기</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#discounttype">DiscountType</a>
<ul>
<li class="toc-entry toc-h6"><a href="#메세지">메세지</a></li>
<li class="toc-entry toc-h5"><a href="#discountpolicy">DiscountPolicy</a>
<ul>
<li class="toc-entry toc-h6"><a href="#더-못난-인터페이스discountcondition-공략">더 못난 인터페이스(DiscountCondition) 공략</a></li>
</ul>
</li>
<li class="toc-entry toc-h5"><a href="#implement-inversion">implement inversion</a>
<ul>
<li class="toc-entry toc-h6"><a href="#요구-인터페이스discountpolicy-공략">요구 인터페이스(DiscountPolicy) 공략</a></li>
</ul>
</li>
<li class="toc-entry toc-h5"><a href="#movie">Movie</a>
<ul>
<li class="toc-entry toc-h6"><a href="#제네릭">제네릭</a></li>
</ul>
</li>
<li class="toc-entry toc-h5"><a href="#다시-movie">다시 movie</a></li>
<li class="toc-entry toc-h5"><a href="#money">Money</a>
<ul>
<li class="toc-entry toc-h6"><a href="#value-object">value object</a></li>
</ul>
</li>
<li class="toc-entry toc-h5"><a href="#reservationvalue-object2">Reservation(value object2)</a></li>
<li class="toc-entry toc-h5"><a href="#screeningvalue-object3">Screening(value object3)</a></li>
<li class="toc-entry toc-h5"><a href="#theater-업글하기">Theater 업글하기</a></li>
<li class="toc-entry toc-h5"><a href="#ticketoffice">TicketOffice</a></li>
<li class="toc-entry toc-h5"><a href="#ticketseller">TicketSeller</a></li>
<li class="toc-entry toc-h5"><a href="#customer">Customer</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#main-다시보기">Main 다시보기</a></li>
</ul>
</li>
</ul><ul>
  <li>참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk</li>
  <li>정리본: https://github.com/LenKIM/object-book</li>
  <li>코드: https://github.com/eternity-oop/object</li>
  <li>책(목차) : https://wikibook.co.kr/object/</li>
</ul>

<h3 id="ch5-theater-with-reservation">
<a class="anchor" href="#ch5-theater-with-reservation" aria-hidden="true"><span class="octicon octicon-link"></span></a>ch5. Theater with Reservation</h3>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220126223153536.png" alt="image-20220126223153536"></p>

<h4 id="저번시간까지-모델">
<a class="anchor" href="#%EC%A0%80%EB%B2%88%EC%8B%9C%EA%B0%84%EA%B9%8C%EC%A7%80-%EB%AA%A8%EB%8D%B8" aria-hidden="true"><span class="octicon octicon-link"></span></a>저번시간까지 모델</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303679386d4e366779316739393633666b337a766a333131713069676d79372e6a7067" alt="image-20191124163632027"></p>

<ul>
  <li>극장이 ticket이나 invitation을 발행할 수 있다( 생성시 theater가 생성자 인자로 )</li>
  <li>ticket의 <strong>판매는 복잡한 책임</strong>이 있기 때문에, 극장은 생성만 하고 -&gt; <strong>TicketOffice에 위임</strong>한다.
    <ul>
      <li>대신 TicketOffice는 Fee를 받는다.</li>
    </ul>
  </li>
  <li>TicketOffice는 Office로서 Fee만 받게하고, <strong>고객상대는</strong> -&gt; 프리랜서인 <strong>TicketSeller를 고용</strong>한다.</li>
</ul>

<h4 id="이번-시간-모델">
<a class="anchor" href="#%EC%9D%B4%EB%B2%88-%EC%8B%9C%EA%B0%84-%EB%AA%A8%EB%8D%B8" aria-hidden="true"><span class="octicon octicon-link"></span></a>이번 시간 모델</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220126224317186.png" alt="image-20220126224317186"></p>

<ul>
  <li>
    <p>ticket 물물교환은 끝났다 -&gt; 인터넷예매의 시대</p>

    <ul>
      <li>초대장도 없앴다. 대신 예약을 한다.</li>
    </ul>
  </li>
  <li>
    <p>theater가 Reservation을 허용해 줄 수 밖에 없다.</p>

    <ul>
      <li>이 책에서는 Screening이 적당한 expert다. -&gt;  <code class="language-plaintext highlighter-rouge">expert pattern</code>을 따르게 하고 있다.
        <ul>
          <li>
<strong>책임을 누가 질 것이냐? -&gt; <code class="language-plaintext highlighter-rouge">정보 전문가가 책임</code>을 부여하는게 가장 낫다.</strong>
            <ul>
              <li><strong>객체의 특성(<code class="language-plaintext highlighter-rouge">자기의 상태를 외부에 노출하지 않는다</code>) 때문이다.</strong></li>
              <li>최대한 노출하지않고 수행하려면, <strong>가장 관련있는/정보를 가장 많이 가지고 있는 객체</strong>가 받아서 처리하는게 좋다. <strong>캡슐화가 가장 덜 깨진다.</strong>
</li>
            </ul>
          </li>
          <li>하지만 이 패턴에 따르면 말이 안되는 경우가 많다.
            <ul>
              <li>팀장, 사장이 정보가 전문가가 아니다. -&gt; 현실세계는 정보 전문가가 그 책임을 수용하진 않는다. 정보 전문가 패턴의 단점이다. 실제 짜보면 그렇게 안된다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>책에서는 Screening(상영)이  Reservation을 받는 까닭은?</strong></p>

    <ul>
      <li>
        <p>Reservation관련 정보를 가장 많이 가지고 있기 때문에, <code class="language-plaintext highlighter-rouge">정보전문가 패턴</code>에 의해 Screening이 Reservation을 책임진다.</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220126225218799.png" alt="image-20220126225218799"></p>
      </li>
      <li>
        <p><strong>상영 정보가  예매를 한다는게 이해가 되나?</strong></p>

        <ul>
          <li>말이 안된다. 설계가 안된다. <code class="language-plaintext highlighter-rouge">screening.reserveSeat()</code>가 말이 안된다.
            <ul>
              <li>쓸데 / 안쓸때를 구분해서 써야한다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>진짜 도메인에서는, 상영 정보는 자리번호/순서/시간을 가진 <code class="language-plaintext highlighter-rouge">시간표일 뿐</code>이다.</p>

        <ul>
          <li>여러 영화가 <code class="language-plaintext highlighter-rouge">공유</code>할 수 있다. 10시 상영객체 -&gt; 인디아나존스도, 스타워즈도 각각 2개 가질 수 있다.
            <ul>
              <li>10시-스타워즈 / 10시-인디아나존스를 따로 만들필요가 없다.</li>
              <li>DB 정규화와 관련되어있다.</li>
              <li>어떤 객체가 2개 만들어질 필요가 있는지 고민해볼 필요가 있다.</li>
              <li>함부러 객체를 남발한다 = 더이상 객체context 사용X = 값 context를 쓰겟다고 하는 것과 마찬가지다.
                <ul>
                  <li>1, 2는 값으로 분리될 수 있어서 값을 넣어, 인스턴스를 여러개 만든다?</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>객체는 객체 고유정보만 들고 있다면, 관계형 DB처럼 참조객체로서 보여주면 되는 것이다.
            <ul>
              <li>10시상영 시간표객체는 1개만 있으면 된다. -&gt; 각 영화들이 10시면 참조만 해주면 된다.
                <ul>
                  <li>굳이 영화를 field로 받아서 각각 영화마다 여러개를 만들 필요가 없다.?</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>객체지향 설계에 도움되는 개념 = RDB의 정규화(1~3정규화)
            <ul>
              <li>객체의 역할과 책임을 분리할 때, 어디까지 얘의 정보로 다룰지 결정할 수 있다.
                <ul>
                  <li>인디아나존스 영화1, 스타워즈 영화2가 있다면,
                    <ul>
                      <li>상영정보(Screening)은 영화제목을 가질 게 아니라, 시간만 있으면 된다. -&gt; 각각의 영화에 참조만 시간별로 참조가 되어주면 된다.</li>
                      <li>만약, 상영정보(Screening)에 영화제목을 넣는다면..
                        <ul>
                          <li>상영정보-시간/영화1</li>
                          <li>상영정보-시간/영화2
                            <ul>
                              <li>똑같은 시간에 영화마다 여러개의 객체를 만들어줘야하니.. 그냥 안만들고 참조만 해주면 된다.</li>
                            </ul>
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Screening은 시간표일 뿐 -&gt; 알고있는 정보는 시간뿐 -&gt; Reserve를 받기에 적합하지 않다.</p>
    <ul>
      <li>정보전문가패턴에서도 그랬다 -&gt; 이번시간 모델에서는 아예 안받게 함.</li>
      <li>현실세계에서는 극장도 여러개 / 영화도 여러개 / 영화마다 상영도 여러개</li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220126232008885.png" alt="image-20220126232008885"></p>

<ul>
  <li>책에서는 할인정책도 소개하고 있다.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">discount policy(어떻게 할인 하는가)</code> 2가지 정책 타입이 있다.
        <ul>
          <li>amount</li>
          <li>percent
            <ul>
              <li>그외 고정금액 확정도 있고 보너스 정립 등 많은 정책들이 있다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
<code class="language-plaintext highlighter-rouge">discount condition(언제 할인이 일어나는가)</code>도 2가지다.
        <ul>
          <li>time condition: 언제를 기준으로 할인</li>
          <li>sequence condition: 몇번째인지를 기준으로 할인
            <ul>
              <li>그외 몇명이상일 때/소아일때/여성일때 등 많은 condition정책들이 있다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>위에 그림처럼 보는 것처럼 <strong>연관관계가 수직적 성립하진 않는다. 각각 교차조건이다. 서로 부모자식관계 없다.</strong>
        <ul>
          <li>
<strong>Type시스템의 문제: <code class="language-plaintext highlighter-rouge">부모자식 관계가 없는데, 어떻게 소화하지?</code></strong>
            <ul>
              <li>책에서는 비겁하게 무기에다가 상수값으로 타입을 놓거나</li>
              <li>객체간 분리해야할 것을 무기의 속성으로 소화하고 있으나 -&gt; 그러면 안된다.
                <ul>
                  <li>무기의 속성으로 소화 -&gt; throw return시 -&gt; 중간메소드 2개씩이 생겨남
                    <ul>
                      <li>자기 타입불렀는데 아니면 죽는 메소드가 2개나 가지고 있게 된다.</li>
                      <li>즉 조건분기만큼 하드코딩으로 메세지를 받게 된다?
                        <ul>
                          <li>쓸대없이 값을 가지고 있기 때문</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>
<strong>책 4장까지 나온 movie 클래스로서는 discount 1개만 더 추가되더라도 많은 변화를 시켜야함.</strong>
                <ul>
                  <li>person, amount외 다른 type를 추가하면 다 고쳐야한다. -&gt; <strong><code class="language-plaintext highlighter-rouge">내부에 type에 의한 if분기</code>가 있기 때문!!</strong>
</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="main">
<a class="anchor" href="#main" aria-hidden="true"><span class="octicon octicon-link"></span></a>Main</h4>

<ul>
  <li><strong>client코드인 Main코드부터 짠다.</strong></li>
</ul>

<h4>
<a class="anchor" href="#" aria-hidden="true"><span class="octicon octicon-link"></span></a><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220127212251961.png" alt="image-20220127212251961">
</h4>
<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220127220145163.png" alt="image-20220127220145163"></p>

<ul>
  <li>client코드부터 짜야
    <ul>
      <li>class짜기가 쉽다</li>
      <li>충분한 도메인 검증(제대로 작동하는지) 검증할 수 있다.</li>
    </ul>
  </li>
</ul>

<ol>
  <li>
    <p>극장을 100원으로 만들어냈다.</p>

    <ul>
      <li>극장의 처음 받는인자는 자본금이었다. <strong>책에서 <code class="language-plaintext highlighter-rouge">값 객체</code> = <code class="language-plaintext highlighter-rouge">Money</code>를 쓰기 원해서 바꿨다.</strong>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">new Theater(100L);</code></li>
          <li>
<code class="language-plaintext highlighter-rouge">new Theater(Money.of(100.0));</code>
            <ul>
              <li><strong>값 객체는 값을 대신하는 객체라서 <code class="language-plaintext highlighter-rouge">레퍼런스형 객체</code>와는 다르다.</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>그 담으로 극장 상영을 위해 <code class="language-plaintext highlighter-rouge">영화</code>를 만들어낸다.
 <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220127212749778.png" alt="image-20220127212749778"></p>

    <ul>
      <li>
<strong>영화의 타입으로 AmountDiscount를 받는다. 왜?</strong>
        <ul>
          <li>책에서 내건 제약조건이 <code class="language-plaintext highlighter-rouge">1 영화 = 1 policy</code> 제약조건을 줘서
            <ul>
              <li>
<code class="language-plaintext highlighter-rouge">AmountDiscount</code>or <code class="language-plaintext highlighter-rouge">PencentDiscount</code>  둘 중 1개의 Type조건을 가진다. <strong>값도 객체도 아닌 Type(형)으로 인식해야할 문제다.</strong>
</li>
            </ul>
          </li>
          <li>
<strong>그냥 Movie가 아니라, Type 2개 중 1개의 Movie, 즉, Subtype을 가지는 Movie로 인식해야한다.</strong>
            <ul>
              <li>책의 제약조건 <code class="language-plaintext highlighter-rouge">영화란, 단 1개의 할인정책을 갖는 존재</code>라고 했기 때문이다.</li>
            </ul>
          </li>
          <li><strong><code class="language-plaintext highlighter-rouge">제네릭</code>도 두려워하지말고 일단 지르자. 회사에 잘하는 사람이 알아서 짜줄 것이다.</strong></li>
        </ul>
      </li>
      <li>Movie의 Type이 정해졌으면, 나머지
        <ul>
          <li>영화제목</li>
          <li>지속시간</li>
          <li>영화가격(실제에서는 영화에 가격X Screen-상영(시간)에 따라서 가격이 정재짐)</li>
          <li>컨디션
            <ul>
              <li>AmountDiscount 중에 Sequence를 쓰는 것으로 나타냈다.</li>
              <li>위에서 지정한 Type을 썼고, 그 중에서도 Time/Sequence 중에 sequence를 쓴 것이다.
                <ul>
                  <li>amount 1000원 할인 + sequence가 1일 때 할인</li>
                </ul>
              </li>
              <li>컨디션도 Type에 맞춰서 넣어줘야한다. 그렇지 않으면 제네릭에 걸려 죽게 된다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>theater에 만들어진 movie를 추가</p>

    <ul>
      <li><strong>movie는 상영(screen)을 가지고 있지 않기 때문에, 따로 theater-movie(1)-screen(N)매칭시켜줄 필요가 있다.</strong></li>
    </ul>
  </li>
  <li>
    <p>theater에 Screening을 추가하는데, <strong>각 movie에 맞춰서 Screening을 추가해줘야한다. ** **일별 x (매일마다) 시간별</strong>로 여러개를 추가한다.
 <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220127215027520.png" alt="image-20220127215027520"></p>

    <ul>
      <li>
<strong>2019년, 7월, for</strong> 7일<strong>부터</strong> / 매일(1일<strong>마다(간격으로)</strong>) / 31일<strong>까지</strong>
        <ul>
          <li>
<strong>for 10시부터</strong> / 3시간<strong>간격으로</strong> / 24시 전<strong>까지</strong>
            <ul>
              <li>**for sequence 1부터 / <code class="language-plaintext highlighter-rouge">시간간격마다</code>+ 1되면서 **</li>
              <li>sequence는 <strong>안쪽 for문에서 hour처럼 매일 1로 초기화되서 커짐</strong>
</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Screening을 만드는데
        <ul>
          <li>순서=seq(시간마다 1부터 +1씩 증가되서 번호가 생성됨)</li>
          <li>상영시간=LocalDateTime으로 2019년 7월 &lt;7일부터 31일까지 매일, 시간은 10시부터 3시간 간격으로&gt;</li>
          <li>상영마다 <strong>가용한 좌석 수</strong>(상영관 class(여기에 예매가능한 좌석정보 포함?) 만들어야하는데, 너무 오래걸려서)
            <ul>
              <li>
<strong>무한 예매를 방지</strong>하기 위함.</li>
              <li>상영관이 없으면 무한예약이 될 수 있다. 대신 <strong>상영마다</strong> 가용 자석수를 배정하면, 무한예매가 방지된다. (좌석수만큼만 예매가능)</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>TicketOffice를 자본금 0원으로 만들고, <strong>theater &lt;-&gt; TicketOffice가 계약(contract)하게 만든다.</strong>
 <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220127220210626.png" alt="image-20220127220210626"></p>

    <ul>
      <li>계약시 TicketOffice에게는 Fee(수수료) 10%를 떼어준다</li>
    </ul>
  </li>
  <li>
    <p>프리랜서 TicketSeller를 만들고, <strong>TicketOffice &lt;-&gt; Seller와 계약</strong>시킨다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220127220334538.png" alt="image-20220127220334538"></p>
  </li>
  <li>
    <p><strong>customer만드는 코드가 빠짐</strong></p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="nc">Customer</span> <span class="n">customer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Customer</span><span class="o">(</span><span class="nc">Money</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mf">20000.0</span><span class="o">));</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>마지막 <strong>예약</strong>한다. <strong>예매를 할 때는</strong>
 <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220127220425401.png" alt="image-20220127220425401"></p>

    <ol>
      <li>
<strong>theater으로부터 특정 movie에 대한 상영시간표(Screen)들을 얻어온다.</strong>
        <ul>
          <li>theater는 공개적으로 특정영화 선택시 Screen들에 대한 인터페이스를 외부에 공개할 책임(기능,함수)이 있다.</li>
        </ul>
      </li>
      <li>지금은 for문 돌리면서 break로  첫번째 Screening만 예약하지만, 실제에서는 특정 Screen을 UI로 선택할 것이다.
        <ul>
          <li>
<strong>customer가 .reserve()예약하는데</strong>
            <ul>
              <li>특정seller에게</li>
              <li>이 theater에서</li>
              <li>이 movie를
                <ul>
                  <li>이 때(screening)</li>
                </ul>
              </li>
              <li>2명이서
                <ul>
                  <li>보고싶다고 예약한다.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>customer는 예매후 theater.enter()입장을 한다.
        <ul>
          <li>customer는 인자로 넘어가면, 내부에 표를 2장 가지고 있을 것이다.
            <ul>
              <li>1사람이 표2장을 제시하면서 입장한다.</li>
            </ul>
          </li>
          <li>결과로 입장가능한지 결과를 알려준다.</li>
        </ul>
      </li>
    </ol>
  </li>
</ol>

<ul>
  <li>실제 예매과정과 비슷하다
    <ul>
      <li>
<strong>핵심은 class가 아니라 Main의 client코드부터 시나리오대로 짜보는 것이다.</strong>
        <ul>
          <li>이것 가지고 회의를 먼저 한다.
            <ul>
              <li>UI에 넘겨줄 부분.. 등</li>
            </ul>
          </li>
          <li>중요한 건 class가 아니라 <strong>instance, 실체, 진짜 일하는 놈들</strong>
            <ul>
              <li>일, 활동의 결과는 return값(isOK)가 되기도 하고</li>
              <li>인자로 넘어가기도 한다.(theater.enter(customer))</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="검토하기">
<a class="anchor" href="#%EA%B2%80%ED%86%A0%ED%95%98%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>검토하기</h5>

<ul>
  <li>TicketOffice를 생성할 때, 생성자로 넘기는 인자는 값 <code class="language-plaintext highlighter-rouge">객체</code>다.
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220128002847964.png" alt="image-20220128002847964">
    <ul>
      <li>Money를 만들 때는 값(0.0)이 어쩔수 없이 들어갔지만</li>
      <li>TicketOffice입장에서는 객체(Money)가 들어간다.</li>
    </ul>
  </li>
  <li>
    <p>contract할 때도, 객체를 받아들였다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220128002929648.png" alt="image-20220128002929648"></p>

    <ul>
      <li>
        <p>rate(할인율) 10.0은 좀 아쉽지만, 이것까지 객체로 하긴 귀찮아서 일단 안함.</p>

        <ul>
          <li>사실은 이부분은 객체지향 위반 중이다. 값이 들어가면 안된다.</li>
        </ul>
      </li>
      <li>
        <p>그렇다면, 예매한 좌석 수(사람 수) count 2도 값으로 들어가서 안좋은 것</p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220128003048335.png" alt="image-20220128003048335"></p>

        <ul>
          <li>실제로는 count객체가 들어와야한다.</li>
          <li>return값이 isOK도 boolean = 값이라서 위반이다. 원래 객체로 리턴되야한다.</li>
        </ul>
      </li>
      <li>
        <p>여기도 100대신 seatCount라는 객체로 들어가야한다.
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220128003147119.png" alt="image-20220128003147119"></p>
      </li>
      <li>
        <p>여기도 1이 아니라 sequenceNumber객체로
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220128003206503.png" alt="image-20220128003206503"></p>
      </li>
      <li>
        <p>spiderman 문자열도 title객체로
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220128003235903.png" alt="image-20220128003235903"></p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>농담하는 것 같지만, 고도화된 객체지향 시스템에서는 값이 등장하지 않는다.</strong></p>

    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">객체</code>만이 <code class="language-plaintext highlighter-rouge">역할</code>을 수행할 수 있고</strong></li>
      <li>
<strong><code class="language-plaintext highlighter-rouge">Type</code>만이 <code class="language-plaintext highlighter-rouge">책임</code>을 수행할 수 있다.</strong>
        <ul>
          <li><strong>형이 아니면, 책임을 질 수 없고, 역할을 수행할 수 없다.</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<strong>아래 예제에서는 값1을 쓴이유: 작성자는 sequenceNumber라는 객체는 더이상 관여할 일이 없음을 확신하고 씀</strong>
    <ul>
      <li>대부분 이러한  착각때문에 시스템을 뜯어고치게 된다.
        <ul>
          <li>
<strong>값은 더이상 확장할 수 없다.</strong>
            <ul>
              <li><strong>seat 100석이 더이상 바뀔일이 없다고 확신? 절대 하지마라</strong></li>
            </ul>
          </li>
          <li>만약, 객체를 썼다면?
            <ul>
              <li>포인터의 포인터를 통해 어떻게든 반응할 여력이 생김</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="discounttype">
<a class="anchor" href="#discounttype" aria-hidden="true"><span class="octicon octicon-link"></span></a>DiscountType</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220129001023447.png" alt="image-20220129001023447"></p>

<ul>
  <li>
    <p>일단 위의 구조는 틀렸다고 했다. 짜보면 안다.</p>
  </li>
  <li>
    <p><strong>DiscountCondition</strong>할 것은 2가지다.</p>

    <ul>
      <li>대부분의 <strong>최소화된 인터페이스</strong>가 가지는  <strong>2가지 조건(발동 조건+액션)</strong>을 가진다.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220129001057595.png" alt="image-20220129001057595"></p>

    <ol>
      <li>
        <p><strong>이 조건들을 만족하는가(hasNext = 발동 조건)</strong></p>
      </li>
      <li>
        <p><strong>Fee를 계산해봐(next = (발동조건 만족시)액션)</strong></p>
        <ul>
          <li>2가지</li>
          <li>
<strong><code class="language-plaintext highlighter-rouge">iterator패턴</code> 중  <code class="language-plaintext highlighter-rouge">hasNext</code> -&gt; <code class="language-plaintext highlighter-rouge">next</code> 쓰는 것이 중요한게 아니다. <code class="language-plaintext highlighter-rouge">아래 2쌍의 pair가 더 중요하다.</code></strong>
            <ol>
              <li>
<code class="language-plaintext highlighter-rouge">내가 발동할 조건을 가지고 있는지</code> 와</li>
              <li><code class="language-plaintext highlighter-rouge">내 action이 무엇인지</code></li>
            </ol>
          </li>
          <li>
<strong>여기서 DiscountCondition은 <code class="language-plaintext highlighter-rouge">실제 액션</code>하기 위해 쓰인 것이다.</strong>
            <ul>
              <li><strong>더 추상화된 개념에서 보면 actor -&gt; action을 할 녀석 -&gt; 발동trigger를 가지고, trigger만족시 action한다.</strong></li>
            </ul>
          </li>
          <li>하지만 <strong>DiscountCondition는 자율적인 애가 아니라 <code class="language-plaintext highlighter-rouge">외부에 위탁</code></strong>한다.
            <ul>
              <li><strong>1. 발동 조건을 가지고 있는지 <code class="language-plaintext highlighter-rouge">외부에서 알려주는 인터페이스</code></strong></li>
              <li>
<strong>2. <code class="language-plaintext highlighter-rouge">본인이 진짜 action하는 인터페이스</code></strong>
                <ul>
                  <li><strong>이런 수동적인 객체는 <code class="language-plaintext highlighter-rouge">lazy = 외부사정에 맞춰서 발동trigger를 확인후 -&gt; 나를 action시킴</code>하기 위해서 작성된다.</strong></li>
                </ul>
              </li>
            </ul>
          </li>
          <li>iterator패턴을 쓰는 이유 :
            <ul>
              <li>
<strong>내가 원할 때</strong> hasNext 호출후 trigger 만족하면 -&gt; next로 액션하려고 씀.</li>
              <li><strong>while이 아니라 <code class="language-plaintext highlighter-rouge">이 담에도 있어? -&gt; 해</code>의 <code class="language-plaintext highlighter-rouge">능동형 queue = 내가 원할 때 작동하는 queue</code>를 만들 때 <code class="language-plaintext highlighter-rouge">while이 아니라 hasNext -&gt; next의 iterator</code>를 쓰게 된다.</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>DiscountCondition은 <strong><code class="language-plaintext highlighter-rouge">인터페이스</code>로 2개의 <code class="language-plaintext highlighter-rouge">역할(책임)</code>을 동시에 수행하고 있다.</strong></p>

    <ul>
      <li>책임으로 보면, 2개의 책임 -&gt; **와 <action>을 분리가 가능**하다.
</action>발동trigger&gt;        <ul>
          <li><strong>발동 trigger</strong></li>
          <li><strong>action</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">인터페이스</code>가 <code class="language-plaintext highlighter-rouge">2개 이상의 메소드(책임)을 가지면, 해체 가능</code>하다.</strong></p>

    <ul>
      <li>**<code class="language-plaintext highlighter-rouge">인터페이스는 함부러 2개이상 메소드가지면 안된다!!</code> **</li>
      <li><strong><code class="language-plaintext highlighter-rouge">기본이 1개를 갖도록 분리시키는 것</code>이다.</strong></li>
    </ul>
  </li>
</ul>

<h6 id="메세지">
<a class="anchor" href="#%EB%A9%94%EC%84%B8%EC%A7%80" aria-hidden="true"><span class="octicon octicon-link"></span></a>메세지</h6>

<ul>
  <li>
<strong>세상에서 제일 좋은 함수: 인자 없는 함수 = <code class="language-plaintext highlighter-rouge">프로시져</code></strong>
    <ul>
      <li>자율적으로 업무를 수행함</li>
      <li>유틸함수 -&gt; 프로시져
        <ul>
          <li>객체 -&gt; 객체 내부 상태만 이용하는 객체</li>
        </ul>
      </li>
      <li>
<strong><code class="language-plaintext highlighter-rouge">인자</code>가 없다  =  UML에서는 <code class="language-plaintext highlighter-rouge">dependency</code>라 부르는 것이 없다.</strong>
        <ul>
          <li>결합이 약해진다</li>
        </ul>
      </li>
      <li><strong>하지만, 우리 수준에선 못짠다.</strong></li>
      <li>
<strong>세상 2번째로 <code class="language-plaintext highlighter-rouge">좋은 함수</code>: <code class="language-plaintext highlighter-rouge">인자가 1개 만 있는 함수</code></strong>
        <ul>
          <li>3번째로 좋은 함수는 ? 없다
            <ul>
              <li><strong>인자 2개이상부터는 나쁜 함수</strong></li>
            </ul>
          </li>
          <li><strong>우리가 짤 수 있는 제일 좋은 함수 = 2번째로 좋은 함수 = 인자가 1개만 있는 함수</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>**어떻게 좋은 함수(=<code class="language-plaintext highlighter-rouge">인자가 1개</code> 뿐인 함수)를 만들까? **
    <ul>
      <li>우리의 수준에서는 세상에서 제일 좋은 함수 = 인자 없는 함수 = 프로시져를 만들긴 힘들다.</li>
      <li>그렇다면 어떻게 인자 1개인 함수를 만들까?
        <ul>
          <li>
<strong><code class="language-plaintext highlighter-rouge">모든 인자를 추상화 -&gt; 객체화</code>시켜서 <code class="language-plaintext highlighter-rouge">객체를 1개의 인자로 받는 함수</code>를 만들면 된다.</strong>
            <ul>
              <li>언제나 옳은 정답이며, <strong><code class="language-plaintext highlighter-rouge">객체지향에서 메세지</code>라 부르는 것이다.</strong>
</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>메소드의 인자를 정할 때, <strong>전달된 인자가 2개이상</strong>이다?
        <ul>
          <li>메세지가 충분히 추상화 되지 않았다.</li>
          <li>메세지가 충분히 <strong>Type(형)</strong>이 되지 않았다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>세상에서 <strong>제일 좋은 인터페이스</strong>는?</p>

    <ul>
      <li>
<strong>메소드가 없는 인터페이스</strong>
        <ul>
          <li>진정한 역할은 역할자체만 나타냄 -&gt; 어떻게 해야한다(메소드)를 정의해주지 않는다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>세상에서 <code class="language-plaintext highlighter-rouge">2번째로 좋은 인터페이스</code> = <code class="language-plaintext highlighter-rouge">메소드 정의가 1개만</code> 있는 인터페이스</strong></p>

    <ul>
      <li>
        <p>메소드 정의 2개부터는 다 나쁜 인터페이스다</p>

        <ul>
          <li>
            <p>우리의 예제도 나쁜 인터페이스 -&gt; <strong>인터페이스가 충분히 추상화되지 않아서</strong></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220202211756025.png" alt="image-20220202211756025"></p>
          </li>
          <li>
            <p>하지만 책에서는 이정도 수준으로 만족하고 있다.</p>

            <ul>
              <li>
                <p><strong>메소드 1개짜리 인터페이스로 인도되려면, Layer가 지금보다 더 많아진다. ( 머리에 한계가 찾아옴.. ) -&gt; 너무 깊은 추상화는 팀원들이 화냄</strong></p>

                <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220202211836162.png" alt="image-20220202211836162"></p>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="discountpolicy">
<a class="anchor" href="#discountpolicy" aria-hidden="true"><span class="octicon octicon-link"></span></a>DiscountPolicy</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220202213429164.png" alt="image-20220202213429164"></p>

<ul>
  <li>policy야말고 마커 인터페이스다.
    <ul>
      <li>책에서는 enum으로 정의하고 있지만, <strong>enum은 Type이 될 수 없다.</strong>
        <ul>
          <li>enum(에넘)을 type으로 generate하는 언어들도 있지만 java에선 허용하지 않는다.</li>
        </ul>
      </li>
      <li><strong>java에서는 interface로 정의한다.</strong></li>
    </ul>
  </li>
  <li>
<strong>인터페이스를 DiscountPolicy를 상속받는 AMOUNT, PERCENT 등의 type들을 interface로 다시 정의해서 Type을 만든다.</strong>
    <ul>
      <li>
<strong>인터페이스</strong> DiscountPolicy<strong>를 따르는 다양한 마커인터페이스를 정의</strong>할 수 있다.
        <ul>
          <li><strong>마커 인터페이스 = 메소드가 없는 (인터페이스만 여러개) 인터페이스 = 세상에서 제일 좋은 인터페이스</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h6 id="더-못난-인터페이스discountcondition-공략">
<a class="anchor" href="#%EB%8D%94-%EB%AA%BB%EB%82%9C-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4discountcondition-%EA%B3%B5%EB%9E%B5" aria-hidden="true"><span class="octicon octicon-link"></span></a>더 못난 인터페이스(DiscountCondition) 공략</h6>

<ul>
  <li>
<strong>더 못난 인터페이스 DiscountCondition에 <code class="language-plaintext highlighter-rouge">메소드 2개</code>가 정의</strong> 되어있다.
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">둘 중에 하나의 메소드를 막아야</code>한다.</strong></li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220202214044462.png" alt="image-20220202214044462"></p>

<ul>
  <li>DiscountCondition에 있는 <strong>인자 2개인 나쁜 함수 <code class="language-plaintext highlighter-rouge">isSatisfiedBy()를 막도록 공략</code>하자.</strong>
    <ul>
      <li>
<strong><code class="language-plaintext highlighter-rouge">방법:</code> 인터페이스 속 메소드 1개 처리를 <code class="language-plaintext highlighter-rouge">추상체(추상클래스)</code> SequenceDiscount<code class="language-plaintext highlighter-rouge">로 공략한다.</code></strong>
        <ol>
          <li>
<strong><code class="language-plaintext highlighter-rouge">생성자 인자로 sequence</code>를 받아들여, <code class="language-plaintext highlighter-rouge">sequence기반으로 isSatisfiedBy를 final로 더이상 안내려가게 잡아준다.</code></strong>
            <ul>
              <li>
<strong>SequenceDiscount를 상속하는 애들은,  만족하는지여부를 Screening의 sequence와 비교하는 로직은 다 똑같아진다.</strong>
                <ul>
                  <li>AMOUNT, PERCENT, COUNT, NONE이든 상관없이 모두 <strong>sequence기반으로 <code class="language-plaintext highlighter-rouge">isSatisfiedBy 만족여부를 추상체에서 커버</code>하도록 한다.</strong>
</li>
                  <li>이후 상속받는 애들은
                    <ul>
                      <li>sequence기반의 DISCOUNT가 된다.</li>
                      <li><strong>차후 implements를 AMOUNT, PERCENT, COUNT, NONE 각각 분기처럼 나눠서 구현한다.</strong></li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
<strong>추상체가</strong> DiscountCondition를 <strong>implements해서 isSatisfiedBy를 @ Override <code class="language-plaintext highlighter-rouge">public -&gt; public final로 정의</code>해서 <code class="language-plaintext highlighter-rouge">이후 상속받은 구현체들은 정의못하게 == 그대로 갖다쓰도록 막아버린다.</code></strong>
            <ul>
              <li>DiscountCondition대신 공략용 추상체 SequenceDiscount를 상속하는 애들은 calculateFee만 정의시켜주면 된다.</li>
            </ul>
          </li>
        </ol>
      </li>
    </ul>
  </li>
  <li><strong>2개 메소드를 가지는 인터페이스를 처리하는 전략: 1개 메소드를 xxx기반으로 처리되도록 정의하는 추상체(추상클래스)를 만든다.</strong></li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220202220037834.png" alt="image-20220202220037834"></p>

<ol>
  <li>
<strong>추상체 SequenceDiscount를 상속받는 애들은 (ex&gt; SequenceAmountDiscount)</strong>
    <ul>
      <li>SequenceAmountDiscount를 하고 싶다면, extends는 SequenceDiscount로 상속받은 상태에서 <strong>implements를 <code class="language-plaintext highlighter-rouge">DiscountPolicy.AMOUNT(분기처럼 선택해서)로 구현</code>해서 Amount개념을 입힌다.</strong>
</li>
      <li>
<strong>이 때, 생성자에서 <code class="language-plaintext highlighter-rouge">sequence</code>는 <code class="language-plaintext highlighter-rouge">super()를 이용해서, 부모인 SequenceAmount에게 처리</code>해달라고 한다.</strong>
        <ul>
          <li><strong><code class="language-plaintext highlighter-rouge">sequence</code>의 처리는 부모(막은 추상체)에게 맞기고 우리는 현재기반인 <code class="language-plaintext highlighter-rouge">amount</code>를 생성자에서 받아준다.</strong></li>
          <li><strong>my) <code class="language-plaintext highlighter-rouge">메소드 1개 처리는 추상체</code>로 막았지만, <code class="language-plaintext highlighter-rouge">인자는 2개 모두 이후 구현체</code>에서 생성자가 받긴 다 받는다.</strong></li>
        </ul>
      </li>
      <li>그럼, <strong>Amount기반으로 calculateFee만 정의</strong>해주면 된다.</li>
    </ul>
  </li>
  <li>
    <p>같은 개념으로 Amount대신 Percent기반으로 sequenceDiscount에 적용해보자.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220202220951941.png" alt="image-20220202220951941"></p>

    <ul>
      <li>똑같이 SequenceDiscount받기, 구현implements만 <code class="language-plaintext highlighter-rouge">DiscountPolicy.PERCENT</code>로</li>
      <li>생성자에선, 부모가 처리해줄 sequence도 같이 받는다.</li>
      <li>Discount정책중
        <ul>
          <li>Sequence정책 중
            <ul>
              <li>PERCENT 정책으로</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><strong>받은 sequence는 부모(추상체)에게 super()로 맡기고</strong></li>
      <li><strong>caculateFee만 percent를 곱해서 원래fee에서 빼준다.</strong></li>
    </ul>
  </li>
  <li>
<strong>추상체를 통해 메소드 1개처리를 막는 이러한 추상화는 4개 자식들의 공통조상이 되어버린다.</strong>
    <ul>
      <li>
<strong>도메인, movie에서는 discountPolicy가 공통으로 묶였으면 했지만, 4개로 분리 되어버렸고, DiscountCondition중에 하나인 SequenceDiscount로 묶였다.</strong>
        <ul>
          <li><strong>추상층을 Condition으로 시작하면 안됬다.</strong></li>
          <li><strong>다시 추상화 해야함.</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h5 id="implement-inversion">
<a class="anchor" href="#implement-inversion" aria-hidden="true"><span class="octicon octicon-link"></span></a>implement inversion</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220202225020093.png" alt="image-20220202225020093"></p>

<h6 id="요구-인터페이스discountpolicy-공략">
<a class="anchor" href="#%EC%9A%94%EA%B5%AC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4discountpolicy-%EA%B3%B5%EB%9E%B5" aria-hidden="true"><span class="octicon octicon-link"></span></a>요구 인터페이스(DiscountPolicy) 공략</h6>

<ul>
  <li>잘못된 공략: 문제가 원하는 인터페이스(DiscountPolicy)가 아닌 Discount<strong>Condition</strong>을 구현한 <strong>추상체를 통해 메소드 1개 처리를 중간에서 추상체가 처리하여 막았다</strong>.
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220202221639981.png" alt="image-20220202221639981">
    <ul>
      <li><strong>이번에는 문제 <code class="language-plaintext highlighter-rouge">반대방향으로 implementation</code>하면서 Condition( Sequence -&gt; isStatisfiedBy()막기 )가 아닌 <code class="language-plaintext highlighter-rouge">AMOUNT -&gt; calcuateFee()를 막는 추상체</code>를 생성해서 1개 메소드를 막아보자.</strong></li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220202221617404.png" alt="image-20220202221617404"></p>

<ol>
  <li>**원하는 interface인 <code class="language-plaintext highlighter-rouge">DiscountPolicy.AMOUNT</code>를 implements하면서, 동시에 <code class="language-plaintext highlighter-rouge">DiscountCondition</code>도 implements **
    <ul>
      <li>
<strong>AMOUNT계열의 Condition임을 나타내고 있다.</strong>
        <ul>
          <li>그러나 <strong>AMOUNT처리가 메인</strong>이며 -&gt; 관련된 메소드인 calculateFee를
            <ul>
              <li>public -&gt; <strong>@Override <code class="language-plaintext highlighter-rouge">public final</code></strong>
</li>
              <li>
<strong>추상체가 calculateFee()를 커버</strong>함.
                <ul>
                  <li>isSatisfiedBy는 sequence/time의 처리영역</li>
                  <li>amount -&gt; fee.minus(amount)</li>
                </ul>
              </li>
              <li><strong>관심사가 sequnece가 아니라 amount(Money)이므로 생성자에서 amount를 받는다.</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220202231618756.png" alt="image-20220202231618756"></p>

<ul>
  <li>2번째 추상클래스는 AMOUNT대신  <code class="language-plaintext highlighter-rouge">오타</code> -&gt; Discount<code class="language-plaintext highlighter-rouge">.PERCENT</code> &amp;&amp; DiscountCondition을 상속한 추상체를 만들면
    <ul>
      <li>calculateFee를 percent단위로 discount하게 추상체를 정의한다.
        <ul>
          <li>PERCENT계열의 부모가 된다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<strong>AMOUNT or PERCENT계열의 부모</strong>
    <ul>
      <li>공통적인 처리는 <strong>policy -&gt; calcuateFee()로 묶게 된다.</strong>
</li>
    </ul>
  </li>
  <li>
    <p><strong>discountCondition이 2개의 메소드를 가져서 문제 -&gt; 분리가 필요했었다. -&gt; 1개의 메소드를 중간 추상체를 만들어서 정의시킨다.</strong></p>

    <ol>
      <li>isSatisfiedBy 를 추상체에 올려서 정의 -&gt; 아래쪽에 calcuateFee를 각자 정의</li>
      <li>
<strong>반대로</strong> calculateFee를 추상체에 올려서 정의  -&gt; 아래쪽에 isSatisfiedBy를 각자 정의
        <ul>
          <li>
<strong>인터페이스 2개 이상(Condition, Policy)이 모이면 경우의 수가 폭증되는 문제점</strong>
            <ul>
              <li><strong>도메인이 무엇과 일치(여기선 Policy정책을 기준으로 도메인이 정해짐)하는가를 찾아서 -&gt; 기준이 되도록 추상화 만들면 된다.</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220202232240453.png" alt="image-20220202232240453"></p>

<ul>
  <li>
    <p>이제 Policy가 추상화된 상태에서 -&gt; Sequence + Policy(AMOUNT or ~) + Discount (SequenceAmountDiscount)를 만들어보자.</p>

    <ul>
      <li><strong>받은 amount는 <code class="language-plaintext highlighter-rouge">부모(= 1개 메소드 처리해준 추상체)에 보내서 처리</code>하고</strong></li>
      <li>이제 <code class="language-plaintext highlighter-rouge">is~</code>쪽을 각자 정의해주면 된다.
        <ul>
          <li>sequence가 같은지를 비교한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>다른 Policy를 선택해서 sequenceDiscount를 만들어도 똑같이 <code class="language-plaintext highlighter-rouge">is~</code>만 정의해준다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220202232539870.png" alt="image-20220202232539870"></p>
  </li>
  <li>
    <p>이러고 봤더니, <code class="language-plaintext highlighter-rouge">sequence</code>관련된 로직들은 <code class="language-plaintext highlighter-rouge">어느 policy</code>든 공통되는 것을 확인했다.</p>
    <ul>
      <li>
<strong>implements는 여러개 가능하지만, <code class="language-plaintext highlighter-rouge">상속은 1개 밖에 안된다.</code></strong>
        <ul>
          <li>인터페이스 2개메소드 -&gt; 메소드 1개 처리용 중간 <code class="language-plaintext highlighter-rouge">구상체</code> -&gt; <code class="language-plaintext highlighter-rouge">상속</code>한 구현체</li>
          <li>
<strong>상속 구현체의 한계 =  <code class="language-plaintext highlighter-rouge">병합 되어있는  여러 경우의 수(자식들)에 걸린   코드중복</code>을 제거할 방법이 없다.</strong>
            <ul>
              <li>
<strong><code class="language-plaintext highlighter-rouge">별도의 [전략 객체]를 받아들이는 수 밖에 없다</code></strong>
                <ul>
                  <li>cf) 코틀린은 classby를 선언하면 자동으로 해준다?!</li>
                </ul>
              </li>
              <li><strong><code class="language-plaintext highlighter-rouge">생성자에서 sequence처리 로직을 갖는 전략객체를 외부에서 수입 -&gt; 받아서 해결</code></strong></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
<strong>우리가 원하던 <code class="language-plaintext highlighter-rouge">추상화</code> 계열은 <code class="language-plaintext highlighter-rouge">도메인 요구 -&gt; policy</code>별로</strong>
        <ul>
          <li>
<code class="language-plaintext highlighter-rouge">AmountDiscount</code> or<code class="language-plaintext highlighter-rouge">PercentDiscount</code>를 상속받아서
            <ul>
              <li>SequenceAmountDiscount or SequencePercentDiscount를 만드는 쪽
                <ul>
                  <li>원하면 TimingAmountDiscount  or TimingPercentDiscount도 만드는 쪽</li>
                </ul>
              </li>
            </ul>
          </li>
          <li><strong>movie에 꽂을 수 있는 <code class="language-plaintext highlighter-rouge">특정 policy</code>를 따르는 객체들이 된다.</strong></li>
        </ul>
      </li>
      <li>seqeuence이외에 나머지를 직접 구현해보자.</li>
    </ul>
  </li>
</ul>

<h5 id="movie">
<a class="anchor" href="#movie" aria-hidden="true"><span class="octicon octicon-link"></span></a>Movie</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203143256759.png" alt="image-20220203143256759"></p>

<h6 id="제네릭">
<a class="anchor" href="#%EC%A0%9C%EB%84%A4%EB%A6%AD" aria-hidden="true"><span class="octicon octicon-link"></span></a>제네릭</h6>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">제네릭</code>을 통해 <code class="language-plaintext highlighter-rouge">if문을 완전히 제거</code>할 수 있다.
    <ul>
      <li>cf) 라우터: 조건에 맞는 객체를 생성 (객체처리기?) -&gt; if문이 사라짐</li>
    </ul>
  </li>
  <li>
    <p><strong>추상클래스 등이 잘 지원되는 jvm을 쓰는 동안은 <code class="language-plaintext highlighter-rouge">제네릭</code>의 필요성을 거의 못느낀다.</strong></p>

    <ul>
      <li>제네릭외 해결방법이 많으므로
        <ul>
          <li>but swift같이 철저히 프로토콜, extends만 지원하는 언어들은 대부분을 제네릭으로 해결한다.</li>
        </ul>
      </li>
      <li><strong>my) <code class="language-plaintext highlighter-rouge">T 제네릭</code>을 통해, <code class="language-plaintext highlighter-rouge">policy와 condition 2개를 다 만족하는 추상체 -&gt; 의 하위객체</code>를 movie <code class="language-plaintext highlighter-rouge">T</code>에 꽂을 수 있따.</strong></li>
    </ul>
  </li>
  <li>
    <p>제네릭을 깊이 공부하다보면 <strong>상위경계 / 하위경계 라는 개념이 나온다. 그리고 각각을 조합</strong>할 수 있다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203143555853.png" alt="image-20220203143555853"></p>

    <ul>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">DiscountPolicy 이자 Condition을 만족하는 T</code>ype(의 하위)만 올 수 있다.</strong></p>

        <ul>
          <li>
            <p><strong>여기오는 <code class="language-plaintext highlighter-rouge">T</code>형은 반드시 <code class="language-plaintext highlighter-rouge">Policy이면서 Condition</code>이어야만 한다.</strong></p>

            <ul>
              <li>
                <p><strong>상속은 안되고 <code class="language-plaintext highlighter-rouge">2개 동시에 implement를 통해 만든 것</code>이어야한다.</strong></p>

                <ul>
                  <li><strong>제네릭T의 경계 조건(2개이상 사용가능) -&gt; 필요한 것만 받는다. -&gt; if분기를 대체할 수 도 있다.</strong></li>
                </ul>

                <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203143917090.png" alt="image-20220203143917090"></p>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<code class="language-plaintext highlighter-rouge">제네릭</code> -&gt; <strong><code class="language-plaintext highlighter-rouge">형</code>에 따른 if분기를 컴파일러에게 맡긴다.</strong>
    <ul>
      <li>if를 제거하는 유일한 방법: 바깥에 if분기를 위임 -&gt; 거기에서 <strong>객체처리기</strong>로 객체 생성 -&gt; 받기
        <ul>
          <li>
<strong>바깥에 위임한 <code class="language-plaintext highlighter-rouge">객체처리기</code>조차 <code class="language-plaintext highlighter-rouge">형</code>으로 대체할 수 있다. -&gt; <code class="language-plaintext highlighter-rouge">제네릭</code></strong>
            <ul>
              <li><strong>if분기 대체를 <code class="language-plaintext highlighter-rouge">객체 -&gt; 형</code>으로 대체하는 방법</strong></li>
            </ul>
          </li>
          <li>형으로 대체해서 집어넣는 것만으로도 if를 대체할 수 있으니 제네릭을 사용한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>이 <strong>제네릭 T의 <code class="language-plaintext highlighter-rouge">상위경계(bound)</code> —&gt;  <code class="language-plaintext highlighter-rouge">if에서의 조건</code>을 의미</strong>하게 된다.
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203144804236.png" alt="image-20220203144804236"></p>

    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">각 if에서 맞는 객체처리기 객체</code>—&gt; 상위경계를 만족하는 추상체를 <code class="language-plaintext highlighter-rouge">상속받아서 구현한 자식class들</code>
</li>
    </ul>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">if문</code>을 쓰는 대신 -&gt; <code class="language-plaintext highlighter-rouge">각 case에 맞는 interface를 상속 or impl한 추상클래스를 만들고</code> —&gt; <code class="language-plaintext highlighter-rouge">그것(들)을  상위경계로 하는 제네릭&lt;T extends&gt;</code>를 사용해서 대체할 수 있다.</strong></p>

    <ol>
      <li>
        <p>**<code class="language-plaintext highlighter-rouge">2중 if문</code>을 -&gt; 각 조건(policy + condition)마다  interface로 만들고, **
 <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203145753014.png" alt="image-20220203145753014"></p>

        <ul>
          <li>
            <p><strong>2개의 인터페이스로 빼낸 뒤</strong></p>
          </li>
          <li>
            <p><strong>1개를 막아주는 구상클래스로 바꿈</strong></p>
          </li>
        </ul>
      </li>
      <li>
        <p><strong>2개 조건을 각각 implementation으로 넘어오게 하는 추상클래스를 구현한다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203150021161.png" alt="image-20220203150021161"></p>

        <ul>
          <li>컴파일러가 각 조건에 맞는 코드를 내부에서 구현하게 된다.
            <ul>
              <li>컴파일러가 제공해주는 Type의 router로 봐도 된다는 개념</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">class의 이름</code>에서부터 <code class="language-plaintext highlighter-rouge">이중 if조건</code>이 걸려있도록 정의한다.</strong></p>

        <ul>
          <li>A: Sequence &amp; B: Percent인   Discount
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203145649869.png" alt="image-20220203145649869">
</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>코드에서 if를 안보이게 하는 방법
    <ul>
      <li>router도입이 아니라 <code class="language-plaintext highlighter-rouge">제네릭</code>을 도입하는 것이다.
        <ul>
          <li>if문 자체가 -&gt; 컴파일러로 숨어진다. (사용자코드에서 존재하지 않게 됨)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<strong>응용: <code class="language-plaintext highlighter-rouge">if조건이 3개</code>다? –&gt; <code class="language-plaintext highlighter-rouge">implements에 3개가 오는 추상클래스</code>를 구현 –&gt; 제네릭이 상위경계로 받으며 구상클래스(Moive) 정의</strong>
    <ul>
      <li>조건의 갯수 = 추상클래스가 implements하는 갯수</li>
      <li>
<strong>조건의 분기갯수 = 각 추상클래스마다 정의해놓아야하는 구상클래스</strong>
        <ul>
          <li>제네릭은 이 구상클래스들을 <code class="language-plaintext highlighter-rouge">&lt;T extends 조건1구상 &amp; 조건2구상 &amp; 조건3구상&gt;</code>으로 상위경계를 잡는다.
            <ul>
              <li>
<strong>재귀함수를 loop로 바꾸듯이 익숙해져야한다.</strong>
                <ul>
                  <li>재귀함수 -&gt; 꼬리물기 최적화 -&gt; loop</li>
                </ul>
              </li>
              <li>
<strong>if문 -&gt; 제네릭으로 분산시키는 것도 자연스러워야한다!</strong>
                <ul>
                  <li>제네릭 분산시스템 -&gt; 묶어서 -&gt; if문 객체들로 바꾸는 것도 자연스러워야한다.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="다시-movie">
<a class="anchor" href="#%EB%8B%A4%EC%8B%9C-movie" aria-hidden="true"><span class="octicon octicon-link"></span></a>다시 movie</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203151117547.png" alt="image-20220203151117547"></p>

<ul>
  <li>
    <p><strong>movie가 제네릭인 이유?</strong></p>

    <ol>
      <li>
        <p><strong>movie에 적용되어야하는 조건이 2가지다.</strong></p>

        <ol>
          <li>조건갯수만큼의 추상클래스 -&gt; 그 조건의 분기만큼의 구상클래스 中 1개 선택</li>
          <li>그 조건의 갯수만큼 extends로 연결한 제네릭을 사용</li>
        </ol>
      </li>
      <li>
        <p><strong>조건에 대한 경우의수를 받아들이는 조건을 <code class="language-plaintext highlighter-rouge">제네릭 - 상위경계</code>로 받아들여서 class를 정의한다.</strong></p>
      </li>
      <li>
        <p><strong>생성자에서도 <code class="language-plaintext highlighter-rouge">T</code>제네릭형에 맞는 condition을 받아들인다.</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203151416317.png" alt="image-20220203151416317"></p>

        <ul>
          <li>T형의 <code class="language-plaintext highlighter-rouge">conditions</code>는 반드시 상위경계의 하위 형으로만 올 수 있기 때문에 <strong>일관된 policy를 가진 condition이 올 것이다.</strong>
</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>conditions들을 Set으로 만들어서 추가로 집어넣는다.</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203151616732.png" alt="image-20220203151616732"></p>

    <ul>
      <li>
<strong>list를 쓴다? <code class="language-plaintext highlighter-rouge">값 context</code>를 생각하고 있는 것이다.</strong>
        <ul>
          <li>
<strong><code class="language-plaintext highlighter-rouge">0번과 1번 element가 반드시 다를 것이라고 생각</code>한다면, <code class="language-plaintext highlighter-rouge">set</code>을 안쓸 수가 없다.</strong>
            <ul>
              <li><strong>객체 context -&gt; 식별자에 의한 구분만 한다? -&gt; list 쓸리가 없다. set을 쓴다.</strong></li>
            </ul>
          </li>
          <li>list의 index -&gt; 값 -&gt; 이것에 의존해서  0번과 5번을 구분한다. -&gt; 값에 의존한다.비록&gt;</li>
        </ul>
      </li>
      <li><strong>컨테이너에 값이 아닌 객체로 식별하고 싶다 -&gt; set만 사용해서 집어넣는다.</strong></li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203152018279.png" alt="image-20220203152018279"></p>

<ul>
  <li>Movie가 할인정책(<code class="language-plaintext highlighter-rouge">discountConditions</code>)과 원가(<code class="language-plaintext highlighter-rouge">fee</code>)를 알고 있기 때문에, <strong>정보전문가패턴으로? Movie만이 calculateFee()를 할 수 있다.</strong>
    <ul>
      <li>어떤 상영인지, 관객수 를 외부에서 받아서 계산한다.</li>
      <li>할인조건은 여러개일 수 있다.
        <ul>
          <li>for문으로 돌면서 현재에 맞는 조건을 찾는다.  -&gt; <strong>맞는 조건 = 여러조건들 중 발동조건 = <code class="language-plaintext highlighter-rouge">isSatisfiedBy()</code></strong>
</li>
        </ul>
      </li>
      <li>condition에 내제된 있는 계산방법을 통해, 인원수만큼 multi해서 return해준다.</li>
    </ul>
  </li>
  <li>여기서 애매한 점:
    <ul>
      <li>moive calculateFee에 audienceCount를 곱하는 책임을 가져야하냐?
        <ul>
          <li>미래에 fee를 계산할 때, <strong>관객수에 따라 fee에 미칠 것 같았으므로, movie에게 audienceCount를 넘겨서 condition내부의 multi를 수행하는 권한을 줬다.</strong>
            <ul>
              <li>역할
                <ul>
                  <li>권한: 내부 나만이 알 수 있는 것들 (알 책임)
                    <ul>
                      <li>니가 그런 권한이 있으니, 그것을 할 수 있지로 설명</li>
                    </ul>
                  </li>
                  <li>책임: 외부한테 수행하는 메세지 (할 책임)</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>맨 처음에는 audienceCount가 isSatisfiedBy()를 판단하는 인자 중 1개로 들어갔다.
            <ul>
              <li>시간대 말고, <code class="language-plaintext highlighter-rouge">몇명이 예약했는지에 따라 더 깍아주기 위해서 받아들였었다.</code>
</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>if 발동조건에 안걸렸더라면  (<code class="language-plaintext highlighter-rouge">return안되고</code> 생략된 else 부분쪽으로 빠져나오면 -&gt;) 할인없는 <code class="language-plaintext highlighter-rouge">할인없이 fee를 받환하도록 return</code>걸어준다.</li>
</ul>

<h5 id="money">
<a class="anchor" href="#money" aria-hidden="true"><span class="octicon octicon-link"></span></a>Money</h5>

<h6 id="value-object">
<a class="anchor" href="#value-object" aria-hidden="true"><span class="octicon octicon-link"></span></a>value object</h6>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203154006848.png" alt="image-20220203154006848"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203154025289.png" alt="image-20220203154025289"></p>

<ul>
  <li>객체처럼 <strong>참조의 참조</strong>가 가능(껍데기 -&gt; 업데이트된 내부 접근)하지만,
    <ul>
      <li>
<strong>값의 특성도 가지고 있는 박쥐같은 녀석</strong>이다.</li>
    </ul>
  </li>
  <li>
<strong>값객체의 참조는 -&gt; 새로운 참조(새 객체)를 return하게끔 되어있다.</strong>
    <ol>
      <li><strong>불변성으로서 값은 불변이다.</strong></li>
      <li>
<strong>값이 변할때마다 <code class="language-plaintext highlighter-rouge">새 객체</code>를 return한다.</strong>
        <ul>
          <li>유용하기 때문에, 다른언어들은 내장하고 있다. ex&gt; swift-structure</li>
          <li>객체기 때문에 참조의 참조가 되긴한다.
            <ul>
              <li><strong>그렇지만 복사본만 return되고 값은 불변</strong></li>
            </ul>
          </li>
          <li>
<strong>java에선 지원안해서 직접 구현</strong>해야한다.</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
<strong>자세히 보기</strong>
    <ol>
      <li>
<strong>처음에 <code class="language-plaintext highlighter-rouge">final</code>로 Double amount가 <code class="language-plaintext highlighter-rouge">확정</code>된다.</strong>
        <ul>
          <li><strong>모든 필드는 final이어야한다. (불변특성을 확정하고 있다)</strong></li>
        </ul>
      </li>
      <li>
<strong>일반적인 연산에서도 <code class="language-plaintext highlighter-rouge">new Money()</code>의 새로운 객체를 return하고 있다.</strong>
        <ul>
          <li>값을 갱신(변경)할 수 없으니, 새로운 값을 가지는 객체를 만들어 return한다.
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203161047062.png" alt="image-20220203161047062">
            <ul>
              <li>뺄셈에 있어서는, 본인amount &gt; 받아온 amount의 크기를 비교하고, 작거나 같으면 하한선 0을 return하게 한다</li>
            </ul>
          </li>
          <li>
<strong>multi()는 amount(Money)객체가 아니라 Double times인 값을 받아들인다.</strong>
            <ul>
              <li><strong>audienceCount를 객체가 아닌 값으로 처리했던 응보를 받는 부분이다.</strong></li>
              <li>어떤 객체context에서라도 단 1개의  primitive를 채용하면… -&gt; 전역적으로 값을 쓰는 이질적 api를 생성하게 되어버린다.</li>
            </ul>
          </li>
          <li>
<strong>되도록이면 객체로 바꿔야한다.</strong>
            <ul>
              <li>times는 money와는 다른 것 같지만, times를 객체로 처리했고 &amp; times와 money를 추상화했을 때, <strong>abstractNumbers의 공통 추상체</strong>가 만들어질지 아무도 모른다.
                <ul>
                  <li>객체로 만들면 추상화될 희망이 있다.</li>
                  <li>2개의 책임 모으기 -&gt; 1개의 역할 도출의 추상화 할 가능성이 있다.</li>
                  <li>역할을 상속받은 2개를 만듬 -&gt; 한번에 처리될 수 있음.</li>
                </ul>
              </li>
              <li><strong>primitive가 온 순간 확장(추상화 등)은 없다. 반드시 객체가 오도록 하자.</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203161813546.png" alt="image-20220203161813546"></p>

<ul>
  <li>
    <p>greaterThan()과 같은 비교연산도 얄짤없이 내부api로 정의해서 은닉화된다.</p>

    <ul>
      <li><strong>amount는 private한 속성으로서 외부에 노출안된다.</strong></li>
      <li>외부에 boolean 값을 return하는 경우에도, 내부에서 연산해서 건네준다.</li>
    </ul>
  </li>
  <li>
    <p>값 객체의 장점</p>

    <ol>
      <li>
        <p><strong>번거로워도 값객체 -&gt; private필드로 내부에 데이터 은닉 -&gt; 외부는 정의한 api를 통해서만 대화할 수 있다. -&gt; <code class="language-plaintext highlighter-rouge">연산의 안전성 보장</code>.</strong></p>
      </li>
      <li>
        <p><strong><code class="language-plaintext highlighter-rouge">new 새객체를 return</code>하기 때문에 -&gt; 기존 상태에 간섭할 수 없음.  -&gt; 객체임에도 <code class="language-plaintext highlighter-rouge">동시성 문제에 자유로워진다</code></strong></p>
      </li>
    </ol>
  </li>
  <li>
    <p>확정된 도메인, 확정된 연산 -&gt; 값 객체로 바꾸는 것을 고려하자</p>
    <ul>
      <li>이유: 동시성 문제에 자유로워지니까</li>
    </ul>
  </li>
</ul>

<h5 id="reservationvalue-object2">
<a class="anchor" href="#reservationvalue-object2" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reservation(value object2)</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203162318753.png" alt="image-20220203162318753"></p>

<ul>
  <li>이펙티브 자바에서 나오는 <strong>null대신에 쓰는 static final <code class="language-plaintext highlighter-rouge">NONE</code>객체 나온다.</strong>
    <ul>
      <li>NONE 객체는 불변으로final, 돌려쓰기static는 객체인가보다.</li>
    </ul>
  </li>
  <li>그외에 <strong><code class="language-plaintext highlighter-rouge">예약</code>은 순수한 데이터 정보 -&gt; 다 <code class="language-plaintext highlighter-rouge">final</code>이다.</strong>
    <ul>
      <li>극장</li>
      <li>영화</li>
      <li>상영시간</li>
      <li>명수</li>
    </ul>
  </li>
  <li>
<strong>Reservation도 순수한 <code class="language-plaintext highlighter-rouge">값객체</code>이다.</strong>
    <ul>
      <li><strong>연산을 제공하지 않아서 <code class="language-plaintext highlighter-rouge">복사본 new Reservation()</code>이 없는 것 뿐이지, <code class="language-plaintext highlighter-rouge">모든 필드가 final</code>인 값객체다.</strong></li>
      <li><strong>다 <code class="language-plaintext highlighter-rouge">final인 값 객체</code>는 return새객체가 없어도 <code class="language-plaintext highlighter-rouge">만들고 나면 못건듬=변경불가=다final</code>이라서  <code class="language-plaintext highlighter-rouge">쓰레드안전</code></strong></li>
    </ul>
  </li>
</ul>

<h5 id="screeningvalue-object3">
<a class="anchor" href="#screeningvalue-object3" aria-hidden="true"><span class="octicon octicon-link"></span></a>Screening(value object3)</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203164740902.png" alt="image-20220203164740902"></p>

<ul>
  <li>
<strong>Screening도 다 final로 들어오는 순수 데이터 정보라서 <code class="language-plaintext highlighter-rouge">값객체</code></strong>다.
    <ul>
      <li><strong>단지 <code class="language-plaintext highlighter-rouge">seat</code>만 private이면서 final이 아닌데, <code class="language-plaintext highlighter-rouge">TRIGGER(is~/has~) 와 -&gt; ACTION</code>을 통해 발동조건에 따라 변동(count보다 많을 때, count만큼 까야지 완성)이 있기 때문이다.</strong></li>
    </ul>
  </li>
  <li>
<strong>객체 생성시 <code class="language-plaintext highlighter-rouge">trigger</code>(bool반환 메소드) 와 그 trigger발동조건 만족시 <code class="language-plaintext highlighter-rouge">action</code>이 있다면?</strong>
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">외부 상황(count)</code>에 사정에 따라 맞춰서 사용되는(<code class="language-plaintext highlighter-rouge">lazy하게 사용</code>) 것들일 경우, 최소한의 인터페이스 2개 (trigger + action)를 정의한다.</strong></li>
    </ul>
  </li>
  <li>trigger: 현재 Screening이 외부 count만큼 seat를 가지고 있나??
    <ul>
      <li>count만큼 예약해줘 -&gt; 가지고 있는 seat에서 까줘(Screening이 할 수 있는 것은 전체seat수에서 count만큼 빼는 것)</li>
    </ul>
  </li>
  <li>action: trigger를 만족할 경우에만 처리
    <ul>
      <li>안그럼 thr</li>
    </ul>
  </li>
</ul>

<h5 id="theater-업글하기">
<a class="anchor" href="#theater-%EC%97%85%EA%B8%80%ED%95%98%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>Theater 업글하기</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203165805132.png" alt="image-20220203165805132"></p>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203170013057.png" alt="image-20220203170013057"></p>

<ul>
  <li>
    <p>amount -&gt; 값객체 Money로 업그레이드</p>
  </li>
  <li>
    <p>각 Theater마다 계약하고 있는 TicketOffice Set들이 있다.
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203170213819.png" alt="image-20220203170213819"></p>
  </li>
  <li>
    <p><strong>각 Movie마다, movie에 맞는 Screening Set들이 있다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203170121495.png" alt="image-20220203170121495"></p>

    <ul>
      <li><strong>TicketOffice처럼 그냥 Set&lt;&gt;으로 정의해도 될 것 같지만, <code class="language-plaintext highlighter-rouge">Movie에 Screening이 없는 경우</code>에 편하게 <code class="language-plaintext highlighter-rouge">map.empty()</code>처럼 편하게 메소드를 쓸 수 있도록 <code class="language-plaintext highlighter-rouge">set위에 hasmap을 씌웠다</code>.</strong></li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203170438126.png" alt="image-20220203170438126"></p>

<ul>
  <li>addMovie<strong>(key추가)</strong>시
    <ul>
      <li>이미 존재하는 거면, add의 결과로 false를 / 그게 아니라면 <strong>새로운 movie마다 set에 보관할 수 있도록 빈set을 생성</strong>해준다.</li>
    </ul>
  </li>
  <li>addScreening(<strong>value추가</strong>)시
    <ul>
      <li>해당 movie에 screening을 추가해주는 것이므로 2개의 인자를 받는다.</li>
      <li>movie가 아예 존재하지도 않으면, false로 끝낸다.</li>
      <li>있으면, movie마다 빈  set에 있던 곳에 screening을 넣어준다.</li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203201948747.png" alt="image-20220203201948747"></p>

<ul>
  <li>
    <p>rate를 가지고 특정 office와 계약한다</p>

    <ul>
      <li>office에서도 계약을 해보고 잘됬으면, 여러 offices들 중 한개로 추가한다.</li>
    </ul>
  </li>
  <li>
    <p>remove로 계약을 cancel할 수 도 있다.</p>
  </li>
  <li>
    <p><strong>plusAmount(Money amount)</strong></p>

    <ul>
      <li>
        <p><strong>ticketOffice가 표를 팔았으면, theater의 재산을 plusAmount</strong>해준다.</p>
      </li>
      <li>
        <p>가지고 있는 값 객체(amount)를 <strong>plus해주면 -&gt; new Amount새 값객체</strong>가 나오고 -&gt; 다시 <strong>재할당</strong>해준다.</p>

        <ul>
          <li>
            <p><strong>값 객체의 변동은 새 객체 -&gt; 재할당해줘야하는 것이 숙명</strong></p>

            <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203202450918.png" alt="image-20220203202450918"></p>

            <ul>
              <li><strong><code class="language-plaintext highlighter-rouge">this.amount</code>같은 <code class="language-plaintext highlighter-rouge">값 객체의 할당부분을 외부</code>에 노출해선 안된다.</strong></li>
            </ul>
          </li>
          <li>
            <p>값 객체는 <code class="language-plaintext highlighter-rouge">포인터(Money)의 포인터(amount)</code>를 깨먹고 있다.</p>

            <ul>
              <li>
<code class="language-plaintext highlighter-rouge">amount의 참조</code>를 바꾸고 싶지 않았다.</li>
              <li>Money객체(외부)는 그대로 있고, double amount(내부)만 바뀌었으면 좋겠는데
                <ul>
                  <li>Money객체(외부)가 새객체로 재할당되었다.</li>
                </ul>
              </li>
              <li>
<code class="language-plaintext highlighter-rouge">this.amount</code> 자체의 <code class="language-plaintext highlighter-rouge">포인터</code>가 변경된다.( <strong>my) 내부 내용만 바뀌던 것이 <code class="language-plaintext highlighter-rouge">껍데기 자체가 바뀜</code></strong> )
                <ul>
                  <li>기존Money -&gt; 새 Money객체 by <code class="language-plaintext highlighter-rouge">this.amount.plus(amount)</code> - <code class="language-plaintext highlighter-rouge">값객체연산</code>
</li>
                </ul>
              </li>
              <li>따라서, <strong>값객체를 할당하고 있는 field</strong>(<code class="language-plaintext highlighter-rouge">this.amount</code>) <strong>= 값객체 껍데기 필드</strong>가 외부에서 노출안되게 한다.
                <ul>
                  <li>
<code class="language-plaintext highlighter-rouge">this.amount</code> =  값 객체(껍데기)를 가리키는 포인터
                    <ul>
                      <li><strong>값객체의 내부 연산시  -&gt; 새객체할당 -&gt; 껍데기 자체가 바뀐다.</strong></li>
                      <li><strong>이 새객체 할당 to <code class="language-plaintext highlighter-rouge">this.amount(값 객체 포인터)</code> 부분이 외부에선 드러나선 안된다.</strong></li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>
<code class="language-plaintext highlighter-rouge">+= </code>의 증감이 아니라 <code class="language-plaintext highlighter-rouge">=</code>새객체 재할당부분이 외부에 노출되었다 ?
                <ul>
                  <li><strong>그 외부에 노출된 부분은 -&gt; <code class="language-plaintext highlighter-rouge">새객체 재할당 이전의 옛날 Money(값객체)</code>를 가지고 있을 것</strong></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p><strong>my) 값객체: <code class="language-plaintext highlighter-rouge">객체 사용</code> = <code class="language-plaintext highlighter-rouge">껍데기-&gt;내부필드</code> =<code class="language-plaintext highlighter-rouge">포인터의 포인터</code> 과정이 없어지고</strong></p>

        <ul>
          <li>**<code class="language-plaintext highlighter-rouge">값 객체 할당부분(this.amount = )</code> = <code class="language-plaintext highlighter-rouge">껍데기 보단 내부필드나 마찬가지</code>  -&gt; <code class="language-plaintext highlighter-rouge">외부에서 쓰지마. 내부 부분이나 마찬가지 이므로, 한번 노출되면 업데이트 안됨. 외부노출된 것들은 과거의 것 가지게 됨.</code> **</li>
          <li>값 객체의 할당은 <strong>뒤쳐지기 싫으면, <code class="language-plaintext highlighter-rouge">내부 연산 -&gt; 새객체 할당에서만 사용</code></strong>
</li>
        </ul>
      </li>
      <li>
        <p><strong>my) 일반적인 값의 변화</strong></p>

        <ul>
          <li>원래 객체로 쌈 -&gt;  껍데기에 접근 -&gt; 내부에서 원시필드 한번 더 접근
            <ul>
              <li><strong><code class="language-plaintext highlighter-rouge">내부 원시필드 변화</code> -&gt; 껍데기(포인터1)에 접근하면 -&gt; 업데이트된 내부원시필드(포인터2)를 받아볼 수 있다.</strong></li>
              <li>값 객체는 <strong><code class="language-plaintext highlighter-rouge">외부 껍데기의 변화</code> -&gt; 내부는 final로 고정된 값. 아예 외부껍데기 1개밖에 존재 안함 -&gt; 어떻게 접근하든 업데이트는 안됨 -&gt; 외부에서 사용금지</strong>
</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>값객체의 외부노출은 -&gt; <code class="language-plaintext highlighter-rouge">값으로 환원해서 외부노출</code>밖에 없다.</strong></p>

    <ul>
      <li>값객체의 변화는 껍데기-&gt;<code class="language-plaintext highlighter-rouge">내부필드 변화</code>가 아니라,  <code class="language-plaintext highlighter-rouge">껍데기 자체의 변화</code>이므로 업데이트를 받아볼 길이 없기 때문</li>
      <li>
<strong>값 객체의 숙명</strong>
        <ul>
          <li><strong>값객체를 그대로 외부에 노출한다면? -&gt; 값객체연산후 새객체가 들어옴 -&gt; 참조가 깨지게 됨.(옜날 객체에서 업데이트 안됨)</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203204559699.png" alt="image-20220203204559699"></p>

<ul>
  <li>getScreening은 movie에서부터 screening Set 리스트를 얻어내는 것
    <ul>
      <li>movie가 존재하지 않으면 null return아니라 EMPTY객체 return</li>
    </ul>
  </li>
  <li>isValidScreening: 상영중인지 확인하는 인터페이스
    <ul>
      <li>이 movie가 이 screening을 가지고 있는지 감정해주는 것
        <ul>
          <li>movie를 가지고 &amp;&amp; 그 screening을 가지고 있다</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203204801307.png" alt="image-20220203204801307"></p>

<ul>
  <li>enter
    <ul>
      <li>Customer가 오면, 거기에 있는 reservation을 가져와서
        <ol>
          <li>NONE이 아니다.</li>
          <li>예약속.theater == this(현재 극장)</li>
          <li>예약속 movie-screening이 유요한지</li>
          <li>예약속 count == 현재 들어온 사람수 맞는지 다 통과하면 true가 반환된다.</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>reserve
    <ul>
      <li>movie, screening, count를 보내면
        <ul>
          <li>movie, screening이 valid한 것인지 확인</li>
          <li>screening한테 hasSeat있는지 물어본다
            <ul>
              <li>둘중에 하나라도 아니면 -&gt; NONE객체 반환</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>screening한테 seat를 count만큼 까라고 시킨다.</li>
      <li>극장(this)를 포함해서, movie, screening, count다 포함시켜서 -&gt; Reservation을 만든다.
        <ul>
          <li>**요청을 받게 되면 무조건 예약 발급된다? **
            <ul>
              <li>**<code class="language-plaintext highlighter-rouge">public이 아니다</code> = 내부만 호출한다 = 계약맺은 애들만 reserve를 호출 할 수 있게 한다. **</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">reserve호출 여부 판단</code>은 변화율이 크다 -&gt; 외부로 ticketOffice한테 뺐다.</strong></li>
    </ul>
  </li>
</ul>

<h5 id="ticketoffice">
<a class="anchor" href="#ticketoffice" aria-hidden="true"><span class="octicon octicon-link"></span></a>TicketOffice</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203205814111.png" alt="image-20220203205814111"></p>

<ul>
  <li>ticketOffice는 자본금인 amount를 가지고 있고</li>
  <li>Map을 통해서 &lt;극장마다, 얼마의 할인율Rate&gt;로 계약맺었는지를 가지고 있다.
    <ul>
      <li>contract()할 때, map에 집어넣는다.</li>
      <li>cancel()을 통해, map에서 빼낸다.</li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203210611290.png" alt="image-20220203210611290"></p>

<ul>
  <li>**핵심적인 것은 TicketOffice에게 <code class="language-plaintext highlighter-rouge">TicketSeller</code>가 <code class="language-plaintext highlighter-rouge">reserve</code>해달라고 요청한다. **</li>
  <li>이게 TicketOffice에게 있는 <code class="language-plaintext highlighter-rouge">reserve()</code>의 역할이다.
    <ul>
      <li>
<strong>궁극적으로는 theater에게 reserve해달라고 한다. 그전에</strong>
        <ul>
          <li>office에 계약된 theater인지 확인하고</li>
          <li>극장에게 상영중인 movie인지 물어보고</li>
          <li>스크리닝한테 seat자리 있는지 물어보고
            <ul>
              <li>만족안하면 reservation불가인 NONE객체로 처리한다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>극장에게 <strong>reserve요청한 결과물  reservation이 NONE만 아니면 -&gt; 제대로 예약된 것이다.</strong>
      - NONE 객체라면, 그 NONE객체를 담고있는 결과물변수를 return해주면 된다.
    <ul>
      <li>극장에서 reservation이 되었다면?
        <ul>
          <li>movie에게 calculateFee()를 때려서 총매출을 구하고</li>
          <li>총매출에서 commissionRate를 곱해, 내(Office)가 먹을 커미션을 구한다.</li>
          <li>내 재산amount에 commision만큼 더해주고</li>
          <li>극장에게는 <strong>총매출 - 커미션</strong>만큼을 매출로 더해준다.</li>
        </ul>
      </li>
      <li>여기까지가 Office에서 하는 reserve</li>
    </ul>
  </li>
</ul>

<h5 id="ticketseller">
<a class="anchor" href="#ticketseller" aria-hidden="true"><span class="octicon octicon-link"></span></a>TicketSeller</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203211346707.png" alt="image-20220203211346707"></p>

<ul>
  <li>tickerOffice와 계약맺는 절차가 있고</li>
  <li>reserve는 Customer와 한다.
    <ul>
      <li><strong>일단은 기본적으로 Reservation이 없다고 생각하고 진행한다.(중첩if의 else마다 할당될 값을 else 없이 &amp; 미리 할당해놓음)</strong></li>
      <li>일단 movie에게서 price를 가져온 뒤</li>
      <li>customer에게 그 돈이 있는지 일단 물어본다.
        <ul>
          <li>customer가 돈있는게 확인되면</li>
          <li>Office에게 reserve()로 reservation을 받아온 다음,</li>
          <li>유효한 reservation이라면, customer에게 돈을 뜯어낸다.</li>
        </ul>
      </li>
      <li>NONE이든 유효한 reservation이든 -&gt; reservation을 return해서 끝낸다.</li>
    </ul>
  </li>
</ul>

<h5 id="customer">
<a class="anchor" href="#customer" aria-hidden="true"><span class="octicon octicon-link"></span></a>Customer</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203212017919.png" alt="image-20220203212017919"></p>

<ul>
  <li>
<strong>일단은 기본적으로 Reservation이 없다고 생각하고 <code class="language-plaintext highlighter-rouge">NONE객체를 가진체</code> 진행한다.</strong>
    <ul>
      <li>TicketSeller도 이걸로 시작 -&gt; 받아오기 시도 -&gt; 없으면 그대로 NONE객체 반환</li>
      <li>Customer도 이걸로 시작 -&gt; 받아오기 시도  -&gt; 없으면 그대로 NONE객체 반환</li>
    </ul>
  </li>
  <li>seller에게  seller.reserve()를 요청하는 reserve를 정의한다.</li>
  <li>hasAmount와 minusAmount는 값객체를 외부에 공개해야하는 api</li>
</ul>

<h4 id="main-다시보기">
<a class="anchor" href="#main-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>Main 다시보기</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203212055140.png" alt="image-20220203212055140"></p>

<ul>
  <li>
    <p>Movie를 만들 때</p>

    <ul>
      <li>**제네릭 <amountdiscount>를 상위경계 T로 지정했으므로**
</amountdiscount>        <ul>
          <li>그 자식인 Sequence + AmountDiscount를 받았다.</li>
          <li>XXXX +  AmountDiscount를 다 받을 수 있게 된다.
            <ul>
              <li>**if문 2개를 대체한 것 ( Amount vs Time ) -&gt; 그 추상체 자식들 중 ( Sequence vs …. ) **</li>
              <li>Sequence 자리의 XXX는 DI(injection)이 주입해준다.</li>
            </ul>
          </li>
          <li>
<strong>제네릭과 친해지면 if문이 완전히 없어진다.(router나 외부 객체처리기 없이 if문 다 없어짐)</strong>
            <ul>
              <li>IF문 -&gt; 제네릭이 대체함.</li>
              <li>제네릭에서 인젝션을 DI가 해준다.
                <ul>
                  <li><strong>우리는 인젝션할 DI의 객체만 바꿔주면 된다.</strong></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203212309896.png" alt="image-20220203212309896"></p>

    <ul>
      <li>sequnce가 1일 때, amount 1000원을 깍아주는 discount policy다.</li>
    </ul>
  </li>
  <li>theater에게 movie집어넣기</li>
  <li>theater에게 movie마다 여러개의 screening들을 map에 집어넣어서 movie-screening들쌍을 만들어준다.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220203213050132.png" alt="image-20220203213050132"></p>

<ul>
  <li>
    <p>ticketOffice를 만들고-&gt; theater와 계약을 하고</p>
  </li>
  <li>
    <p>seller를 만들어서 -&gt; ticketOffice와 계약하고</p>
  </li>
  <li>
    <p><strong>customer만드는 코드가 빠짐</strong></p>

    <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  <span class="nc">Customer</span> <span class="n">customer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Customer</span><span class="o">(</span><span class="nc">Money</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mf">20000.0</span><span class="o">));</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>screening이 돌아가면서</p>

    <ul>
      <li>customer가 seller와 예약을 함
        <ul>
          <li><strong>예약시 customer내부에 reservation객체를 가지게 됨.</strong></li>
        </ul>
      </li>
      <li>reservation을 가진 customer가 theater에 enter입장함
        <ul>
          <li>결과를 return받아서 출력</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>4장, 5장 일부까지 정리</p>
    <ul>
      <li>실제 워킹하는 코드임.</li>
      <li>본인만의 역할모델 짜보기</li>
    </ul>
  </li>
</ul>


  </div><a class="u-url" href="/object/2022/05/07/(object1-5)theater_with_reservation_%EA%B0%9D%EC%B2%B4%EC%84%A4%EA%B3%842.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="blog.chojaeseong.com/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>평범한 한의사 돌범의 엔지니어 도전기</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
  <a href="/feed.xml" target="_blank" title="rss">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://github.com/is2js/" target="_blank" title="github">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#github"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://twitter.com/yarotheslav" target="_blank" title="twitter">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#twitter"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://www.linkedin.com/in/yshmarov/" target="_blank" title="linkedin">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#linkedin"></use>
    </svg>
  </a>
</li>
</ul>
</div>

  </div>

</footer>
</body>

</html>
