<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>OBJECT 07 SOLID 5원칙 + DDHL + GRAPS 9패턴(코드스핏츠) | 돌범텤놑</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="OBJECT 07 SOLID 5원칙 + DDHL + GRAPS 9패턴(코드스핏츠)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="object 책을 강의한 코드스핏츠 유튜브 요약" />
<meta property="og:description" content="object 책을 강의한 코드스핏츠 유튜브 요약" />
<link rel="canonical" href="blog.chojaeseong.com/object/2022/05/10/(object1-7)SOLID5%EC%9B%90%EC%B9%99_GRAPS9%ED%8C%A8%ED%84%B4.html" />
<meta property="og:url" content="blog.chojaeseong.com/object/2022/05/10/(object1-7)SOLID5%EC%9B%90%EC%B9%99_GRAPS9%ED%8C%A8%ED%84%B4.html" />
<meta property="og:site_name" content="돌범텤놑" />
<meta property="og:image" content="blog.chojaeseong.com/images/posts/java.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-10T00:00:00-05:00" />
<script type="application/ld+json">
{"datePublished":"2022-05-10T00:00:00-05:00","url":"blog.chojaeseong.com/object/2022/05/10/(object1-7)SOLID5%EC%9B%90%EC%B9%99_GRAPS9%ED%8C%A8%ED%84%B4.html","@type":"BlogPosting","image":"blog.chojaeseong.com/images/posts/java.png","headline":"OBJECT 07 SOLID 5원칙 + DDHL + GRAPS 9패턴(코드스핏츠)","dateModified":"2022-05-10T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"blog.chojaeseong.com/object/2022/05/10/(object1-7)SOLID5%EC%9B%90%EC%B9%99_GRAPS9%ED%8C%A8%ED%84%B4.html"},"description":"object 책을 강의한 코드스핏츠 유튜브 요약","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<!-- 폰트추가를 위한 link태그 삽입 -->
  <!-- 폰트1:  기본 spoqa 웹폰트 -->
  <!-- css에서 * {} 다 뒤집어씀. -->
  <link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSansNeo.css' rel='stylesheet' type='text/css'>
  <!-- 폰트2:  블로그 제목들 sunflower 웹폰트 -->
  <!-- 쥬피터 등 포스트 내부 글자 h1, h2 제목은 sunflower체 도입 -->
  <link href="//fonts.googleapis.com/css?family=Sunflower:300,500,700" rel="stylesheet"> 

  <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="blog.chojaeseong.com/feed.xml" title="돌범텤놑" /><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">돌범텤놑</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About Me</a><a class="page-link" href="/search/">Search</a><a class="page-link" href="/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">OBJECT 07 SOLID 5원칙 + DDHL + GRAPS 9패턴(코드스핏츠)</h1><p class="page-description">object 책을 강의한 코드스핏츠 유튜브 요약</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-05-10T00:00:00-05:00" itemprop="datePublished">
        May 10, 2022
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      14 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/categories/#object">object</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <!-- toc가 먼저 나오므로 h3로 안내하기 -->
    <h3>📜 제목으로 보기</h3>
    <ul class="section-nav">
<li class="toc-entry toc-h3"><a href="#ch7-solid-5원칙과-grasp-9패턴">ch7. SOLID 5원칙과 GRASP 9패턴</a>
<ul>
<li class="toc-entry toc-h4"><a href="#알려진-기본-설계요령-5원칙-solid">알려진 기본 설계요령 5원칙: SOLID</a>
<ul>
<li class="toc-entry toc-h5"><a href="#srp">SRP</a></li>
<li class="toc-entry toc-h5"><a href="#ocp">OCP</a></li>
<li class="toc-entry toc-h5"><a href="#lsp">LSP</a></li>
<li class="toc-entry toc-h5"><a href="#isp">ISP</a></li>
<li class="toc-entry toc-h5"><a href="#dip">DIP</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#그외-설계요령-추가-4원칙">그외 설계요령 추가 4원칙</a>
<ul>
<li class="toc-entry toc-h5"><a href="#의존성-부패방지와-최소지식의-모순">의존성 부패방지와 최소지식의 모순</a></li>
<li class="toc-entry toc-h5"><a href="#mock객체-활용-검증">mock객체 활용 검증</a></li>
</ul>
</li>
<li class="toc-entry toc-h4"><a href="#grasp과-9-패턴">GRASP과 9 패턴</a>
<ul>
<li class="toc-entry toc-h5"><a href="#information-expert">Information Expert</a></li>
<li class="toc-entry toc-h5"><a href="#creator">Creator</a></li>
<li class="toc-entry toc-h5"><a href="#controller">Controller</a></li>
<li class="toc-entry toc-h5"><a href="#low-coupling">Low Coupling</a></li>
<li class="toc-entry toc-h5"><a href="#high-cohesion">High Cohesion</a></li>
<li class="toc-entry toc-h5"><a href="#protected-variations">Protected Variations</a></li>
<li class="toc-entry toc-h5"><a href="#polymorphism">Polymorphism</a></li>
<li class="toc-entry toc-h5"><a href="#pure-fabrication">Pure Fabrication</a></li>
<li class="toc-entry toc-h5"><a href="#indirection">Indirection</a></li>
</ul>
</li>
</ul>
</li>
</ul><ul>
  <li>참고 유튜브 : https://www.youtube.com/watch?v=navJTjZlUGk</li>
  <li>정리본: https://github.com/LenKIM/object-book</li>
  <li>코드: https://github.com/eternity-oop/object</li>
  <li>책(목차) : https://wikibook.co.kr/object/</li>
</ul>

<h3 id="ch7-solid-5원칙과-grasp-9패턴">
<a class="anchor" href="#ch7-solid-5%EC%9B%90%EC%B9%99%EA%B3%BC-grasp-9%ED%8C%A8%ED%84%B4" aria-hidden="true"><span class="octicon octicon-link"></span></a>ch7. SOLID 5원칙과 GRASP 9패턴</h3>

<h4 id="알려진-기본-설계요령-5원칙-solid">
<a class="anchor" href="#%EC%95%8C%EB%A0%A4%EC%A7%84-%EA%B8%B0%EB%B3%B8-%EC%84%A4%EA%B3%84%EC%9A%94%EB%A0%B9-5%EC%9B%90%EC%B9%99-solid" aria-hidden="true"><span class="octicon octicon-link"></span></a>알려진 기본 설계요령 5원칙: SOLID</h4>

<ul>
  <li>
    <p>책 6~8장</p>
  </li>
  <li>1940년대 대부분의 개발이론이 다 나왔다.</li>
  <li>1960년대 대부분의 이론 다 완성</li>
  <li>1980년대 완성된 이론을 -&gt; 차근차근 실현단계</li>
  <li>100년의 역사지만, 처음부터 고등학문(천재들이 만들어서)
    <ul>
      <li>평민들은 공부할 수가 없음</li>
      <li>
<strong>1980년대부터 평민의 언어</strong>로 바꾸기 시작
        <ul>
          <li>우리가 아는 문건들 -&gt; 평민 언어로 쉬운 것만 추린 것</li>
          <li><strong>그것이 5개 SOLID원칙</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="srp">
<a class="anchor" href="#srp" aria-hidden="true"><span class="octicon octicon-link"></span></a>SRP</h5>

<ul>
  <li>
    <p><strong>SRP( 단일책임원칙, Single responsibility)</strong></p>
  </li>
  <li>책임: 오브젝트 책 p117
    <ul>
      <li>
<strong>srp에서의 책임: <code class="language-plaintext highlighter-rouge">코드의 변화하는(수정하는) 이유가  1개</code>가 되도록 객체를 설계해라</strong>
        <ul>
          <li>코드 수정 이유에 가장 좋은 방법: <strong><code class="language-plaintext highlighter-rouge">변화율(코드의 변동 주기(시간)+이유)에 따라서 분리</code></strong>한다
            <ul>
              <li><strong>“이 객체는 <code class="language-plaintext highlighter-rouge">이 때 + 이래서 변해</code> -&gt; 나눠줘야겠어 -&gt; <code class="language-plaintext highlighter-rouge">변하는 이유를 &lt;변화율:이때+이래서 변함&gt;로 선택</code> “</strong></li>
              <li>seller와 office를 나눈(분리시킨) 이유도 마찬가지
                <ul>
                  <li>고객에게 <strong>갈취하는 역할</strong>: seller</li>
                  <li>티켓을 <strong>정산하는 역할</strong>: office는 다를 거야. <strong>이러한 이유로 서로 다르게 변할거야.</strong>
</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>쓸데 없는 책임을 벗어나게 하는 방법:
    <ul>
      <li>SRP는 spring API처리에서 많이 언급된다.
        <ul>
          <li>똑같이 트랜잭션처리+로그처리가 어느 클래스든 공통로직으로 들어가있다.
            <ul>
              <li>이 공통로직이 되어있다면, 공통로직 수정 -&gt; 수많은 클래스 같이 수정해야하는 문제여러&gt;</li>
            </ul>
          </li>
          <li>
<strong>클래스 변화 이유: 도메인이어야하는데, <code class="language-plaintext highlighter-rouge">일반로직까지 같이 가지고 있기 때문에 문제</code>가 생긴다.</strong>
            <ul>
              <li>변화하는 이유 : 도메인이어야한다. -&gt; 여러 이유(+일반로직까지)를 가지고 있다.</li>
              <li>cf) 공통로직 -&gt; 유틸리티 클래스로 빼면 된다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>SRP가 제대로 지켜지 않을 때:
    <ul>
      <li><strong>1가지 변화 이유로 수정시작 -&gt; <code class="language-plaintext highlighter-rouge">수많은 클래스를 고치게 되는 문제점(산탄총 수술, shotgun surgery)</code></strong></li>
      <li>변화는 이유: <code class="language-plaintext highlighter-rouge">trigger</code>는 1개가 되도록 -&gt; <code class="language-plaintext highlighter-rouge">클래스도 거기에 맞게 나눠서 구축</code>하자</li>
    </ul>
  </li>
</ul>

<h5 id="ocp">
<a class="anchor" href="#ocp" aria-hidden="true"><span class="octicon octicon-link"></span></a>OCP</h5>

<ul>
  <li>
<strong>OCP(개방폐쇄원칙, Open and Close)</strong>
    <ul>
      <li>
<strong><code class="language-plaintext highlighter-rouge">다형성</code>이라 생각해도 무관하다.</strong> <strong>구현보다는 <code class="language-plaintext highlighter-rouge">인터페이스를 참조</code>하자.</strong>
</li>
      <li>
<strong>open:확장이 열려있다.  / close: 수정이 닫혀있다.</strong>
        <ul>
          <li>a -&gt; b 직접 참조시
            <ul>
              <li>b의 수정 -&gt; a에도 충격 : close원칙에 위배</li>
              <li>b를 안고침 -&gt; a에도 변화X : a의 open원칙을 위배
                <ul>
                  <li>안고쳤다 = 수정이나 확장에 열려있지 않다</li>
                </ul>
              </li>
            </ul>
          </li>
          <li><strong>직접참조 = 건들이면 망가지고 안건들이면 확장이 없음</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">직접참조를 피</code>하면 <code class="language-plaintext highlighter-rouge">OCP</code>를 만족시키는 것이다.</strong>
    <ul>
      <li>포인터의 포인터: 포인터를 직접참조하지말자.</li>
      <li>a -&gt; b의 외부 interface -&gt; 다양한 b 구현체orClass</li>
    </ul>
  </li>
</ul>

<h5 id="lsp">
<a class="anchor" href="#lsp" aria-hidden="true"><span class="octicon octicon-link"></span></a>LSP</h5>

<ul>
  <li>LSP(<strong>리스코프 치환 원칙, Liskov Substitusion, 업캐스팅 안전 때문에 존재)</strong>
</li>
  <li>**<code class="language-plaintext highlighter-rouge">부모CLASS형 자리에는 자식Class형을 집어넣을 수 있다.</code> **
    <ul>
      <li><strong>-&gt; 그렇지 않을 땐, 부모class(추상층의) 메소드를 따로 빼내서 자식들의 공통점만 가지게 수정한다.</strong></li>
      <li><strong>모든 case를 다 알아아야하고, 공통점만 가지도록 -&gt; 구상화된 메소드는 인터페이스로 뺀다</strong></li>
      <li>이게 왜 원칙일까?</li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204153556529.png" alt="image-20220204153556529"></p>

<ul>
  <li>
    <p><strong>추상층이 너무 구체적이면 구상층 구현에 문제가 생기므로 <code class="language-plaintext highlighter-rouge">추상층을 어떻게 잘만들까? 어떻게 추상층이 함부러 나대지 않게 만들까?</code>에 관한 얘기다</strong></p>
  </li>
  <li>
    <p><strong>추상층에 <code class="language-plaintext highlighter-rouge">생물</code>을 만들고, 메소드 2개 정의</strong></p>

    <ul>
      <li>숨을 쉰다</li>
      <li>다리로 이동한다</li>
    </ul>
  </li>
  <li>
    <p>구상층으로서 생물-&gt; <code class="language-plaintext highlighter-rouge">사람</code> / 생물-&gt; <code class="language-plaintext highlighter-rouge">타조</code>를 구현하고</p>

    <ul>
      <li><strong>리스코프 치환 원칙에 따라, <code class="language-plaintext highlighter-rouge">부모</code>자리에 <code class="language-plaintext highlighter-rouge">자식</code>을 넣어보자.</strong></li>
      <li>지금까지는 어색하지 않다
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204154155711.png" alt="image-20220204154155711">
        <ul>
          <li>사람이 숨을 쉰다. / 사람이 다리로 이동한다.</li>
          <li>타조가 숨을 쉰다. / 타조가 다리로 이동한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>문제는 다른 구상층들 중에서 발생한다 <code class="language-plaintext highlighter-rouge">아메바</code>, <code class="language-plaintext highlighter-rouge">독수리</code>, <code class="language-plaintext highlighter-rouge">고래</code>는 다리로 이동할 수 없다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204154345513.png" alt="image-20220204154345513"></p>

    <ul>
      <li>
<strong><code class="language-plaintext highlighter-rouge">이러한 일은 왜 일어났을까?</code></strong>
        <ul>
          <li><strong><code class="language-plaintext highlighter-rouge">추상층에 있는</code> 다리로 이동한다<code class="language-plaintext highlighter-rouge"> 메소드</code>가</strong></li>
          <li><strong><code class="language-plaintext highlighter-rouge">앞으로 일어날 구상층의 확장</code>에서 <code class="language-plaintext highlighter-rouge">도메인을 반영할 수 없기 때문</code>이다.</strong></li>
        </ul>
      </li>
      <li>
<strong>너무 나댄 것이다. 욕심이 나지만.. 함부러 추상층에서 정의해선 안됬다.</strong>
        <ul>
          <li>
<strong>사람, 타조만 보고선 -&gt; “어? 공통인데 추상화해서 추상층으로 빼면 좋지 않을까”</strong> 라고 욕심이 났다</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>위의 예에 따르면 <code class="language-plaintext highlighter-rouge">리스코프 치환 원칙</code> = <code class="language-plaintext highlighter-rouge">추상층은 구상층의 확장을 모두 포용할 수 있는 교집합만을 가지고 있어야한다.</code></strong></p>

    <ul>
      <li>my) 여러 구상층들을 미리 생각해서 -&gt; 그것들의 교집합, 공통점만 추상층에 올리도록 해야한다.  -&gt; <strong>머리가 좋은 사람들만 할 수 있다. 다 파악해야한다. 그래서 어렵다.</strong>
</li>
      <li><strong>발견하자마자 추상층 메소드를 수정/제거할 수 있어야한다.</strong></li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204154807594.png" alt="image-20220204154807594"></p>
  </li>
  <li>
    <p><strong>그럼 일부 구상층만 가지는 메소드는? -&gt; <code class="language-plaintext highlighter-rouge">인터페이스로 따로 빼놓고, 해당하는 구상층들만 추가 impl</code>하게 한다</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204154932059.png" alt="image-20220204154932059"></p>

    <ul>
      <li>추상층 - 생물 - 숨을 쉰다()  메소드 1개만
        <ul>
          <li>다리로 이동() -&gt; <strong>인터페이스로 빼내기</strong>
</li>
        </ul>
      </li>
      <li>구상층
        <ul>
          <li>생물만 구상하다가 -&gt; 해당하는 구상층만 다리이동()인터페이스 추가 impl</li>
          <li>나머지들은 생물만 구상</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="isp">
<a class="anchor" href="#isp" aria-hidden="true"><span class="octicon octicon-link"></span></a>ISP</h5>

<ul>
  <li>
    <p><strong>ISP(인터페이스 분리 원칙, Interface Segregation)</strong></p>
  </li>
  <li>
    <p>구상형으로 쓰지말고, <strong>외부호출별(?) 모듈별(?) 접근하는 객체별(?) <code class="language-plaintext highlighter-rouge">외부 접근을 인터페이스(형)별로 분리시켜 엉뚱한 접근을 막는다.</code></strong>한다.</p>

    <ul>
      <li><strong>안그럴시, 밖에서 엉뚱한 메소드를 호출하더라도 못막는다?</strong></li>
      <li>
<strong>엉뚱한 호출(<code class="language-plaintext highlighter-rouge">메소드접근권한</code>)을 막는 방법 : <code class="language-plaintext highlighter-rouge">형</code>밖에 없다 -&gt; <code class="language-plaintext highlighter-rouge">인터페이스별로 분리</code>한다</strong>
        <ul>
          <li>ex&gt; 모듈A야 너는 인터페이스A에 있는 메소드 2개만 바라봐</li>
          <li>ex&gt; 모듈B야 너는 인터페이스B에 있는 메소드 1개만 바라봐</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>예를 들어, 어떤 객체에 <strong>메소드가 6개</strong>가 있다. <strong>아래와 같이 짜면 안된다.</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204190242478.png" alt="image-20220204190242478"></p>

    <ul>
      <li>
        <p>왼쪽 2개 메소드 -&gt; 모듈A에서 사용</p>
      </li>
      <li>
        <p>가운데 1개 메소드 -&gt; 모듈B에서 사용</p>
      </li>
      <li>
        <p>오른쪽 1개 메소드 -&gt; 모듈C에서 사용</p>
      </li>
      <li>
        <p>나머지 2개 메소드 -&gt; 객체 자체에서 사용</p>

        <ul>
          <li>
<strong>(멍청한) 우리가 Class를 짜면 항상 이런식</strong>으로 작성된다.
            <ul>
              <li><strong>이렇게 하지말라는 말 -&gt; 왜? <code class="language-plaintext highlighter-rouge">인터페이스 분리가 안되어있다.</code></strong></li>
              <li><strong><code class="language-plaintext highlighter-rouge">메소드들이 모여있으면, 모듈A가 다른 엉뚱한 메소드들을 호출해도 못막는다.</code></strong></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p><strong>첫번째 ISP 방법</strong></p>

        <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204190645061.png" alt="image-20220204190645061"></p>

        <ul>
          <li>
<strong><code class="language-plaintext highlighter-rouge">hasA방법</code>:</strong> 각각을 모듈별로 인터페이스를 가지도록 객체자체를 나눈 뒤 -&gt; 모든 객체를 소유</li>
        </ul>
      </li>
      <li>
        <p><strong>두번째 ISP 방법</strong>
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204190814982.png" alt="image-20220204190814982"></p>

        <ul>
          <li>
<strong>일반적인 <code class="language-plaintext highlighter-rouge">인터페이스 모델</code>방법:</strong>
            <ol>
              <li><strong>인터페이스별로 메소드를 분리</strong></li>
              <li><strong>implements A, B, C -&gt; 각각의 메소드들 구현</strong></li>
              <li><strong>자체메소드 2개 구현</strong></li>
            </ol>
          </li>
        </ul>
      </li>
      <li>
        <p>경우에 따라서 <code class="language-plaintext highlighter-rouge">소유모델(hasA)</code>와 <code class="language-plaintext highlighter-rouge">인터페이스(형)모델</code>을 섞어서 쓰기도 한다.</p>
      </li>
    </ul>
  </li>
</ul>

<h5 id="dip">
<a class="anchor" href="#dip" aria-hidden="true"><span class="octicon octicon-link"></span></a>DIP</h5>

<ul>
  <li>
    <p><strong>DIP(의존성 역전 원칙, Dependency Inversion, 다운캐스팅 금지)</strong></p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204191630558.png" alt="image-20220204191630558"></p>

    <ul>
      <li>어려운말로 나타내면 위와 같다. 고쳐 말하면
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204191654048.png" alt="image-20220204191654048">
</li>
      <li>
<strong>빨간색 말만 봐라보면 -&gt; <code class="language-plaintext highlighter-rouge">구상 클래스에 의존X 추상 인터페이스나 추상 클래스에 의존하자.</code></strong>
        <ul>
          <li><strong>구상화된 형을 가리키는 코드가 있다면 -&gt; 추상화된 형으로 바꿔줘야한다.</strong></li>
          <li>그러려면 <strong>4. 인터페이스 분리(ISP, 접근별로 인터페이스를 분리해놓고 impl하자)</strong>가 되어야하고</li>
          <li>그러기 위해선 <strong>3. 업캐스팅 안전(LSP. 모든 case를 다 알아아야하고, 공통점만 가지도록 -&gt; 구상화된 메소드는 인터페이스로 뺀다)</strong> 도 되어야한다.
            <ul>
              <li>그래서 어렵다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="그외-설계요령-추가-4원칙">
<a class="anchor" href="#%EA%B7%B8%EC%99%B8-%EC%84%A4%EA%B3%84%EC%9A%94%EB%A0%B9-%EC%B6%94%EA%B0%80-4%EC%9B%90%EC%B9%99" aria-hidden="true"><span class="octicon octicon-link"></span></a>그외 설계요령 추가 4원칙</h4>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204195428064.png" alt="image-20220204195428064"></p>

<ul>
  <li>로버티 마틴이 줄여서 말한게 5가지고 그 외에도 설계요령이 많다. <strong>기본적으로 우린 머리가 나쁘니까 이렇게 해야해가 대부분이다. -&gt; 머리를 덜 쓰기 위해서 지켜야할 원칙</strong>
    <ul>
      <li>
<strong>DI</strong>: 의존성 주입(Dependency Injection)
        <ul>
          <li>너흰 추론 불가능이야.</li>
        </ul>
      </li>
      <li>
<strong>DRY</strong>: 중복방지(Don’t Repeat Yourself)
        <ul>
          <li>너흰 기억력이 엉망이야</li>
        </ul>
      </li>
      <li>
<strong>Hollywood Principle</strong>: <strong>의존성 부패방지(헐리우드 원칙)</strong>
        <ul>
          <li>나한테 연락하지마. 내가 필요시 전화할테니 너 전번만 줘</li>
          <li>묻지말고 시켜라.  ex&gt; 묻지말고 500원만 줘.
            <ul>
              <li>물으면 많은 것들을 알게됨 ex&gt; 지갑사정을 보고 500원만 줘. 대출사정을 보고 500원만 줘.</li>
              <li>물어보지 않은 원칙 -&gt; <strong>모두 시키기만</strong> 하자. 물어보지 말자.
                <ul>
                  <li>물어본놈: 간첩</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>빨리 500원을 받아야하는데, 물어보는 순간 -&gt; 얘네 집안과 연동됨 -&gt; 의존성 부패
            <ul>
              <li>
<strong>물어보는 순간 일반적으로 부패</strong>된다.</li>
              <li>객체지향에서는 물어보는 순간 -&gt; <strong>대답용 객체가 온다(return)</strong>. -&gt; <strong>새 의존성이 추가</strong>되어버린다.</li>
            </ul>
          </li>
          <li>응답기반으로 프로그램을 짜면 안된다. 대답이 올지 장담할 수 가 없다. <strong>시키는 원칙을 지키자. <code class="language-plaintext highlighter-rouge">getter(응답객체가 return됨)형은 나쁜 것</code>.</strong>
</li>
        </ul>
      </li>
      <li>
<strong>Law of demeter</strong>: <strong>디미터의 법칙 = 최소지식만 요구</strong>한다.
        <ul>
          <li>책 6장에서 다루는 디미터의 법칙</li>
          <li>classA안에 메소드 methodA가 가질 수 있는 최대 지식은?
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204193354859.png" alt="image-20220204193354859">
            <ul>
              <li>필드 / 필드들의 형 / 자기가 만든 객체 / 인자로 넘어온 객체 / 지역변수들</li>
              <li>
<strong>나머지는 알면 안된다. <code class="language-plaintext highlighter-rouge">1차원 관계의 것들만 이용하자. 1차원이 안되면,직거래를 유도하도록 래핑메소드를 제공해서 1차원적으로 만들자.</code></strong>
                <ul>
                  <li>인자로 넘어간 객체가 호출 메소드의 return값</li>
                  <li>필드에 있는 객체가 호출한 메소드의 return값
                    <ul>
                      <li>다 이용하지말자.</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li><strong>직거래만 하자. <code class="language-plaintext highlighter-rouge">타고 가서 return되는 간접거래는 하지마</code>. 간접적으로 아는 것들(걔의 집안사정)은 머리가 나빠서 기억못한다. <code class="language-plaintext highlighter-rouge">모르는게 최고</code></strong></li>
            </ul>
          </li>
          <li>
<strong>어기면 <code class="language-plaintext highlighter-rouge">열차전복 (train wreck)</code> 사고가 난다.</strong>
            <ul>
              <li>A.B.C 다 연결되서 문제가 생기고 의존성이 생긴다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="의존성-부패방지와-최소지식의-모순">
<a class="anchor" href="#%EC%9D%98%EC%A1%B4%EC%84%B1-%EB%B6%80%ED%8C%A8%EB%B0%A9%EC%A7%80%EC%99%80-%EC%B5%9C%EC%86%8C%EC%A7%80%EC%8B%9D%EC%9D%98-%EB%AA%A8%EC%88%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a>의존성 부패방지와 최소지식의 모순</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204195307676.png" alt="image-20220204195307676"></p>

<ul>
  <li>지금 나오는 것을 암기 하지 않으면 책을 읽을때 이해가 안된다.
    <ul>
      <li>참고할정도도 아니고 <strong>총 <code class="language-plaintext highlighter-rouge">9개 설계원칙</code>은 코드짤 때 항상 머리속에서 벨리데이션 하고 있어야한다.</strong>
        <ul>
          <li>solid + DDHL</li>
        </ul>
      </li>
      <li>
<strong>헐리우드 원칙</strong>(묻지말고=<strong>응답(return객체) 바라지말고, 시키자</strong>)</li>
      <li>
<strong>디미터 원칙</strong>(최소지식만 요구 = <strong>알고 있는 1차원의 것들만 직거래</strong>)</li>
    </ul>
  </li>
  <li>
    <p>헐리우드 원칙(시키기만) + 디미터 원칙(보이는 것만 직거래) <strong>두 원칙을 지키다 보면 모순점</strong>이 발생</p>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204195733419.png" alt="image-20220204195733419"></p>

    <ul>
      <li>객체망에서 핵심내용은 <strong>메세지만 주고받아 객체간통신은 가능하지</strong> 내부를 들여다 보진 않는다.
        <ul>
          <li>내장은 까지 않는다.</li>
        </ul>
      </li>
      <li>
<strong><code class="language-plaintext highlighter-rouge">내가 메세지를 주면서 시켰는데, 걔가 잘했는지 확신은 어떻게 하지?</code></strong>
        <ul>
          <li>내가 던지기만 하면 그만인가? 객체지향은 무책임한가?</li>
        </ul>
      </li>
      <li>
<strong><code class="language-plaintext highlighter-rouge">우리가 던전 메세지가 제대로 작동했는지 확인하는 코드가 필요</code>하다.</strong>
        <ul>
          <li><strong>work를 확인하는게 아니라 <code class="language-plaintext highlighter-rouge">메세지가 제대로 수신되었는지만 확인</code>한다.</strong></li>
          <li>그 메세지로부터 <strong><code class="language-plaintext highlighter-rouge">다른 메세지들도 잘 퍼져나갔는지가 중요</code></strong>
</li>
          <li>실제 작동은 안궁금하다.</li>
        </ul>
      </li>
      <li>객체망의 성립은 쉽지가 않다.
        <ol>
          <li>단방향이지만 알아야한다.</li>
          <li>runtime에 만들어지기도 해야한다</li>
          <li>어떤 것은 set으로 할당되기도 하지만, 어떤 것은 생성자에서 만들어진다.</li>
          <li>활성화되었는지 껍데기 객체인지도 모른다.</li>
        </ol>
      </li>
      <li>메세지 전파부터 제대로 해야한다.
        <ul>
          <li>
<strong>클라코드에서 screening.reserve() 호출하는 것은 보았지만</strong>
            <ul>
              <li>
<strong>더 중요한 실제 movie의 calculateFee()를 호출하는지</strong>
                <ul>
                  <li>메세지 전파 -&gt; 다른 메세지 제대로 전파되었는지 확인</li>
                  <li><strong><code class="language-plaintext highlighter-rouge">우리는 reserve() 내장을 깔 방법이 없기 때문에 들여다볼 방법이 없다.</code></strong></li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
<strong>객체 생성이라는 것은 runtime에 이루어지기 때문에, 코드를 짜는 우리로서는 제대로 객체통신(메세지전달)을 확인할 방법이 없다.</strong>
            <ul>
              <li>객체지향은 runtime context를 극한으로 = lazy하게 이용하려고 하기 때문에 생기는 문제점</li>
              <li><strong>즉 runtime context 시점에서만 확인가능. 코드로는 정적분석 불가능</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204200739653.png" alt="image-20220204200739653"></p>

<ul>
  <li>
<strong>객체망 통신(메세지 전달)을 확인하려면 (<code class="language-plaintext highlighter-rouge">가운데 객체로 확인</code>)</strong>
    <ol>
      <li>회색 -&gt; 테스트객체로 메세지를 보내고</li>
      <li>테스트 객체 -&gt; 파/빨강 객체로 다시 메세지를 잘 보내어지는지</li>
      <li>
<strong>테스트 객체와 <code class="language-plaintext highlighter-rouge">(원래 내장까는) 이웃한 객체들의 메세지 수신</code>조사해서 확인</strong>한다.
        <ul>
          <li>회색 -&gt; trigger객체 -&gt; 대상객체 -&gt; 파/빨이 다시 메세지 제대로 수신했는지 확인해서</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
<strong>가운데 테스트 객체를 깔 방법은 없다 -&gt; <code class="language-plaintext highlighter-rouge">(처음부터 내장까지는 전/후 이웃) 3 객체들</code>을 까서 조사한다</strong>
    <ul>
      <li>대상 객체의 단위테스트는 안중요하다
        <ul>
          <li>객체망 진짜 테스트 -&gt; 감싸고 있는 회/빨/파 내장까지는 객체가 메세지 수신하는지?</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204201353166.png" alt="image-20220204201353166"></p>

<ul>
  <li>
<strong>내장까지는 객체는 어떻게 만들까?</strong>
    <ul>
      <li><strong>Mock객체를 활용해서 검증한다.</strong></li>
      <li>
<strong>내부를 log찍는 인터페이스</strong>를 구현 -&gt; 인터페이스를 구상하는 객체 -&gt; 구현</li>
    </ul>
  </li>
</ul>

<h5 id="mock객체-활용-검증">
<a class="anchor" href="#mock%EA%B0%9D%EC%B2%B4-%ED%99%9C%EC%9A%A9-%EA%B2%80%EC%A6%9D" aria-hidden="true"><span class="octicon octicon-link"></span></a>mock객체 활용 검증</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204210212717.png" alt="image-20220204210212717"></p>

<ul>
  <li>
    <p>내부를 log찍는 인터페이스 구현도 반복적이므로 <code class="language-plaintext highlighter-rouge">mock</code>객체를 쓴다</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">단위테스트를 하는데 mock을 사용하지?</code></strong></p>

    <ul>
      <li>실환경에 존재하고 해주는 일을 하는 객체를 대신하여 사용하는 것일까?
        <ul>
          <li>아니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>우리는 객체망을 통해 문제를 해결하는데, 해당객체를 추론해서 볼 수 없으므로 <code class="language-plaintext highlighter-rouge">객체망검증</code>을위해 mock객체가 필요하다</strong></p>

    <ul>
      <li>회색/파란/빨강 객체 -&gt; mock객체 -&gt; 대상 테스트 객체가 제대로 작동하는지를 검증할 수 있다.</li>
    </ul>
  </li>
  <li>
    <p>목 객체 용어</p>

    <ol>
      <li>mockery(모조 객체)  vs <code class="language-plaintext highlighter-rouge">mock(목 객체)</code>
</li>
      <li>테스트 관리 객체 vs <code class="language-plaintext highlighter-rouge">테스트용 모의 객체</code>
        <ul>
          <li><strong>mock(모의 객체)들의 우두머리 -&gt; mockery</strong></li>
          <li>
<code class="language-plaintext highlighter-rouge">mockery</code>는 일종의 테스트관장하는 우두머리 <code class="language-plaintext highlighter-rouge">context</code>라고 볼 수 있따.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204210714935.png" alt="image-20220204210714935"></p>

<ul>
  <li>일단 context인 mockery부터 배치를 한다.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220204210641461.png" alt="image-20220204210641461"></p>

<ol>
  <li>
    <p>필요한 목객체 생성은 <code class="language-plaintext highlighter-rouge">context</code>로부터 생성한다.</p>

    <ul>
      <li>
        <p>context는 자기로부터 생성된 <strong>목객체들을 감시할 수 있다.</strong></p>
      </li>
      <li>
        <p>아까 봤던 회색 / 파란 / 빨간색 객체를 생성한다.</p>

        <ul>
          <li>mockery인 context를 안고 생성하게 한다.</li>
          <li>해당 인터페이스 구현부에 만들어진다?</li>
          <li>안에 context에 보고하는 로직으로 구현되어있다
  <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220205110407718.png" alt="image-20220205110407718">
</li>
        </ul>
      </li>
      <li>
        <p>대상 객체를 둘러싼, 객체망을 검증할 수 있는 주변 객체들을 생성했다</p>

        <ul>
          <li>
<strong>객체</strong> 본질 = <strong>책임 = 메세지를 주고 받는다</strong> = 주는사람이 있으면 받는 사람도 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>테스트할 객체를 둘러싼 객체망으로 구성하기
 <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220205110539358.png" alt="image-20220205110539358"></p>

    <ul>
      <li>실제 대상객체를 만들고</li>
      <li>목객체 3개를 원하는 구조를 구성한다(보통 DI구성 or 직접수동으로)</li>
    </ul>
  </li>
  <li>
    <p>트리거 발동하여, 회색객체에 첫번째 메세지 발동
 <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220205110656857.png" alt="image-20220205110656857">
 <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220205110707290.png" alt="image-20220205110707290"></p>

    <ul>
      <li>테스트 대상객체 내장은 못깐다. 못건들인다고 생각하고</li>
      <li>회색객체에서 할 수 있는 것 = <code class="language-plaintext highlighter-rouge">목객체에서 메세지를 쐈다</code>.<strong>를 mockery에서 보고받음.</strong>
</li>
      <li>파랑/빨강객체에서 할 수 있는 것 = <code class="language-plaintext highlighter-rouge">목객체로서 메세지 수신했다</code>를 <strong>mockery에서 보고 받음</strong>
</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220205110855464.png" alt="image-20220205110855464">
 <img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220205110905643.png" alt="image-20220205110905643"></p>

    <ul>
      <li>
<strong>전체적으로 mockery가 원하는 시나리오 대로 성립했는지 확인할 수 있다.</strong>
        <ul>
          <li><strong><code class="language-plaintext highlighter-rouge">대상객체에의 메세지처리가 정상적으로 유통되고 있어.</code>를 판단한다</strong></li>
        </ul>
      </li>
      <li>객체망 참가하는, 대상객체 테스트 방법은, <strong>이방법이 유일</strong>하다.
        <ul>
          <li>객체 내장은 못깐다.</li>
          <li>객체는 책임으로서만 의미가 있다.
            <ul>
              <li>책임 = 메세지를 주고 받는 행위다
                <ul>
                  <li>객체를 바르게 테스트 하는 방법은, 주변객체를 활용해서 메세지 송수신이 제대로 유통되는지를, mockery에서 확인하는 방법밖이다.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
<strong><code class="language-plaintext highlighter-rouge">목 시스템 외에는 객체테스트가 불가능하다</code>는 결론</strong>
        <ul>
          <li><strong>테스트 작성 -&gt; 무조건 mock이 필요하다</strong></li>
          <li><strong>mock없이는 객체지향 테스트는 불가능하다.</strong></li>
        </ul>
      </li>
      <li>
<strong><code class="language-plaintext highlighter-rouge">객체 메소드 단위테스트</code>는 <code class="language-plaintext highlighter-rouge">정상작동하는 객체다</code>를 증명할 수 없다.</strong>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">객체는 오직, 객체만이 참가해서, 메세지를 주고받을 때 의미가 있으므로</code></li>
          <li>정말 바른 객체다?를 증명하려면, 메세지를 주고받는 것으로 확인할 수밖에없다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<ul>
  <li>객체지향 개발을 한다 = <strong>mock기반의 테스트를 작성</strong>해야만 가능하다.
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">runtime</code>에서 잘 작동할지 알 방법이 없다</li>
      <li>
<strong>보통 주변 객체들이 <code class="language-plaintext highlighter-rouge">적시에 그자리에 있냐</code> or <code class="language-plaintext highlighter-rouge">setter로 세팅한 것이 적시에 이루어지냐</code>에서 뻑난다</strong>
        <ul>
          <li>screening 안에서 movie.calculateFee()를 호출한다고 하더라도
            <ul>
              <li>movie가 적시에 바르게 작동하고 있는지의 문제가 생긴다</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>안하면 코드를 상상으로 하는 것이다.
        <ul>
          <li>선택이 아니다.</li>
          <li>객체 테스트는 이 방법 밖에없다.</li>
        </ul>
      </li>
      <li>단위 테스트(메소드)도 객체가 가시성을 내어놓은 상태로 짜는 것. 꽁꽁 숨겨둔 객체라면 못짠다.</li>
    </ul>
  </li>
  <li>객체는 오직 객체통신을 통해서만 = 책임이라는 메세지를 호출하는 것으로만 의미를 가지기 때문에
    <ul>
      <li>테스트방법도 메세지 테스트 외에는 방법이 없다.</li>
    </ul>
  </li>
</ul>

<h4 id="grasp과-9-패턴">
<a class="anchor" href="#grasp%EA%B3%BC-9-%ED%8C%A8%ED%84%B4" aria-hidden="true"><span class="octicon octicon-link"></span></a>GRASP과 9 패턴</h4>

<ul>
  <li>오브젝트 책 5장의 주제다</li>
  <li>
<strong>객체지향 기본이론(5+4)를 base로 <code class="language-plaintext highlighter-rouge">보다 더 민간용으로 나온 설계요령</code></strong>
    <ul>
      <li>다른 관점에서 SOLID법칙, 헐리우드법칙, 디미터법칙을 인식하는 좋은 계기가 된다.</li>
    </ul>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220205112944699.png" alt="image-20220205112944699"></p>

<ul>
  <li>9가지 <del>원칙</del> 패턴
    <ul>
      <li><strong>거성들의 원칙(5+4)보다 객체지향 적용의 약한 레벨에 적용할 수 있게  좀 풀어놓은 버전</strong></li>
      <li><strong>응용범위는 더 좁을 수 있다. 패턴은 특정상황에서 쓰는 것</strong></li>
    </ul>
  </li>
  <li>켄트백은 적용할 수 있는 레벨을 여러가지로 분류했다.
    <ul>
      <li>원칙, 가치, 패턴
        <ul>
          <li>원칙: 무조건 지켜야하는 것(이유 없이)</li>
          <li>
<strong>가치</strong>: 돈이 되는 행위(보다 돈이 방향으로 움직여라)
            <ul>
              <li>코드를 잘짜는 것 &lt; <strong>디버깅을 할 필요가 없는 코드</strong>를 만들기
                <ul>
                  <li>개발시간은 디버깅의 1/4밖에 안되므로</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>패턴: 원칙+가치를 반복적으로 하다보니 만들어진 모범답안</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>9가지 패턴으로 쓰면
    <ul>
      <li>도움이 되고 시간 절약 + 많은 오류 해소</li>
      <li>반드시 적용되는 것은 아님</li>
    </ul>
  </li>
</ul>

<h5 id="information-expert">
<a class="anchor" href="#information-expert" aria-hidden="true"><span class="octicon octicon-link"></span></a>Information Expert</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220205113619818.png" alt="image-20220205113619818"></p>

<ul>
  <li>SOLID원칙 이전에, <strong>객체지향의 은닉성 자체</strong>을 의미
    <ul>
      <li>데이터 하이딩, 은닉을 지키고 싶다라면, **<code class="language-plaintext highlighter-rouge">데이터를 가진 애</code>가 <code class="language-plaintext highlighter-rouge">책임(메소드)도 가지는게</code> 좋아(패턴) cf)(맞어 -&gt;원칙) **
        <ul>
          <li>패턴이라서 ~ 하는게 좋아. 정도의 어감. 항상 지킬 수 있는게 아닌 패턴
            <ul>
              <li>ex&gt; 어떻게 screening이 reserve를 하나..</li>
            </ul>
          </li>
          <li><strong><code class="language-plaintext highlighter-rouge">은닉성을 잘 지켜지니까, 데이터를 가진 놈이 메소드도 가지면 좋아</code></strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="creator">
<a class="anchor" href="#creator" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creator</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220205113920449.png" alt="image-20220205113920449"></p>

<ul>
  <li>정보 은닉성과 연결된 얘기
    <ul>
      <li>니가 객체를 만드는 일이 생겨도 (in runtime) 그 때도 정보 전문가 패턴을 적용할 필요가 있다.</li>
      <li>
<strong>객체를 만드는 것 = <code class="language-plaintext highlighter-rouge">그 객체(가 가질 필드)정보를 많이 알고 있는</code> or <code class="language-plaintext highlighter-rouge">포함/이용/부분으로 삼는 놈</code>이 -&gt; <code class="language-plaintext highlighter-rouge">그 객체와 친밀한 놈이 그 객체를 만드는게 좋아</code></strong>
        <ul>
          <li>실제로 지키기 힘든 패턴이다.</li>
          <li>정보전문가패턴과 일치할때도 있고 아닐때도 있다.
            <ul>
              <li>ex&gt; reservation에 <strong><code class="language-plaintext highlighter-rouge">들어갈 필드정보를 많이 알고 있는 screening</code>이 reservation 생성을 맡긴다.</strong>
</li>
            </ul>
          </li>
          <li>나중에 고친 모델에서는 <strong>reservation을 <code class="language-plaintext highlighter-rouge">사용하는 theater</code>가 생성을 담당했다.</strong>
            <ul>
              <li>ex&gt; theater가 검표(표 확인)시 reservation을 <strong><code class="language-plaintext highlighter-rouge">이용할 것</code></strong>이기 때문에</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="controller">
<a class="anchor" href="#controller" aria-hidden="true"><span class="octicon octicon-link"></span></a>Controller</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220205115356075.png" alt="image-20220205115356075"></p>

<ul>
  <li>컨트롤러가 무슨 패턴이냐 -&gt; 패턴이다.
    <ul>
      <li><strong>컨트롤러: 어떤일을 중개할 때, 직접접촉하는게 나은지 아닌지를 판단하는 것</strong></li>
      <li>
<strong><code class="language-plaintext highlighter-rouge">어댑터 패턴</code>과 <code class="language-plaintext highlighter-rouge">미디에이터 패턴</code>을 공통적으로 한꺼번에 적용할 필요가 있을 때 -&gt; <code class="language-plaintext highlighter-rouge">컨트롤러 패턴</code>으로 퉁치는게 좋아.</strong>
        <ul>
          <li>
<code class="language-plaintext highlighter-rouge">미디에이터 패턴</code>: 객체가 다수의 객체를 알아야할 경우, 객체망이 너무 복잡해지니, <strong>미디에이터를 중심에 두고, 미디에이터가 다 알게 한 다음 -&gt; 나머지는 미디에이터만 알게 한다</strong>
            <ul>
              <li>나머지가 하고 싶은일이 있으면 미디에이터에게 위임하면, 알아서 해준다.</li>
              <li>하나의 시스템이 -&gt; 여러시스템에 물려서 통신한다. -&gt; 중개자가 처리한다.</li>
              <li><strong>모든 case를 알고 있는 법원으로 가서, 사람들이 따지게 하는 방법</strong></li>
            </ul>
          </li>
          <li>
<code class="language-plaintext highlighter-rouge">어댑터 패턴</code>: 내가 직접하는 것보다 <strong>간접적으로 아는게 훨씬 유리</strong>하다.
            <ul>
              <li>MVC에서 <strong>Model(데이터)</strong> -&gt; Controller(어댑터) -&gt; View(UI, 콘솔, 사운드 등) 여러 구상체로 나뉠 수 있으니, <strong>구상체를 직접아는 것보다. 중간에 어댑터를 알게 하는 것이 더 좋다.</strong>
</li>
            </ul>
          </li>
          <li>어댑터가 1개 시스템(1개 Model-데이터)만 아는게 아니라, 여러 시스템이 알고 있는 경우가 미디에이터패턴도 해당한다
            <ul>
              <li><strong>Controller를 만들어서, MVC의 <code class="language-plaintext highlighter-rouge">어댑터</code>를 맡기던지, 법원의<code class="language-plaintext highlighter-rouge">미디에이터</code>를 맡긴다.</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>객체지향 설계를 공부하다보면, 고프의 디자인 패턴을 이야기한다.
    <ul>
      <li>반대로도 통하는 사람에게 통하니 문제다</li>
      <li>
<strong>학습루트 추천</strong>
        <ul>
          <li>디자인 패턴(구현물)을 일단 달달 외운다.</li>
          <li>객체지향 원리를 공부하면서 외운 패턴을 적용하면서, 패턴이 왜 그렇게 만들었는지 생각해본다.
            <ul>
              <li>2개를 동시에 학습할 수 없다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>컨트롤러 패턴이 나온 이유:
    <ul>
      <li>어떤 객체가, 어댑터패턴 &amp;&amp; 미디에이터패턴을 동시에 사용해야할 대 -&gt; 컨트롤러를 만들어서 사용한다.</li>
      <li>컨트롤러를 보면
        <ul>
          <li><strong>외부에 대해선 어댑터</strong></li>
          <li><strong>내부에 대해선 미디에이터다</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="low-coupling">
<a class="anchor" href="#low-coupling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Low Coupling</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220205121726198.png" alt="image-20220205121726198"></p>

<ul>
  <li>오래된 이론이다.</li>
  <li>객체지향에서
    <ul>
      <li>
<strong>커플링(결합도)가 낮다 = <code class="language-plaintext highlighter-rouge">알고 있는 객체가 적다</code></strong>
        <ul>
          <li>책에서는 적절한 객체를 알고 있다고 표현해놨다. 비겁한 표현이다.</li>
          <li>우리는 알아야만 하는 객체를 알고 있을 뿐이다.
            <ul>
              <li>알아야할 필요가 없는 객체 -&gt; 설계 대상이 아니라 리팩토링 대상이다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<strong><code class="language-plaintext highlighter-rouge">알아야만 하는 것</code>에 대해 <code class="language-plaintext highlighter-rouge">단방향 의존성</code>이 Low Coupling의 목표다</strong>
    <ul>
      <li>양방향 의존성(참조)이 되는 순간 -&gt; 상태를 보고서 버그를 확정할 수가 없다.
        <ul>
          <li>디버거들이 무력화 된다.</li>
          <li>주고 받았기 때문에, 값이 얼만지 모른다.</li>
          <li>주고 받지 않아야만, <code class="language-plaintext highlighter-rouge">메세지 보내기 전/후로 나눠서 디버깅</code> 가능해짐.</li>
          <li>
<strong><code class="language-plaintext highlighter-rouge">양방향 참조</code>는  100% 제거해야한다.</strong>
            <ul>
              <li><strong><code class="language-plaintext highlighter-rouge">순환참조</code>를 통한 양방향 참조도 무서운 것 -&gt; 제거하자.</strong></li>
              <li>RDB의 기술: M:N -&gt; 1:M으로 바꾸는 것</li>
              <li>
<strong><code class="language-plaintext highlighter-rouge">DB-중개테이블처럼 &lt;중개 객체&gt;가 더들어와야지 양방향 참조를 제거할 수 있다.</code></strong>
                <ul>
                  <li>
<strong><code class="language-plaintext highlighter-rouge">형</code>1개가 늘어날 수 밖에 없다.</strong>
                    <ul>
                      <li>어댑터패턴에서도 -&gt; 어댑터 인터페이스 + 어댑터구상체가 늘어나듯이</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>주고 받았으면 누구 책임인지 알 수 가 없다. runtime에서는 에러를 못잡는다.</li>
    </ul>
  </li>
  <li>
<strong>Low Coupling</strong> -&gt; 알고 있는 객체가 적다 -&gt; <strong>양방항참조를 제거</strong>한다 -&gt;  <strong>제거 과정에서 M:N을 풀듯이 가운데 객체로 인해 형이 1개 추가될 수밖에없지만 두려워말라. 양방향은 디버깅조차 안되므로</strong>
    <ul>
      <li>형을 통해 단방향으로 바꾸는 수 밖에 없다.</li>
    </ul>
  </li>
</ul>

<h5 id="high-cohesion">
<a class="anchor" href="#high-cohesion" aria-hidden="true"><span class="octicon octicon-link"></span></a>High Cohesion</h5>

<ul>
  <li>그에 비해 <strong>High Cohesion(높은 응집성)은 달성 방법이 정해져있다.</strong>
    <ul>
      <li>SRP의 책임 -&gt; <strong>변화율</strong> 요인을 1개로만들어서 <strong>분리</strong>
        <ul>
          <li>
<strong>도메인(내가 가진 정보)</strong>에 의해 변한다. or <strong>변하는 주기(자주 변하는 부분과 안변하는 부분의 공존시 분리)</strong>에 의해 변한다.</li>
          <li>최종 목표: <strong>변화율에 따라 코드를 나누고, 변화시 다른 곳에 영향주지 않게 격리</strong>시켜라
            <ul>
              <li>격리 유일한 방법: 형 경계를 넘지 않게(?)= Dependency를 단방향으로 의존하는 것</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="protected-variations">
<a class="anchor" href="#protected-variations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Protected Variations</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220205124008768.png" alt="image-20220205124008768"></p>

<ul>
  <li>인터페이스 분리 원칙을 적용한 것
    <ul>
      <li>
<strong>가능한</strong> 직접적인 형을 참조 하지말고 <strong>공통점 찾아 <code class="language-plaintext highlighter-rouge">인터페이스로 추상화</code> 하라는 얘기</strong>
</li>
      <li>가능하지 않는 대부분의 이유:  <strong>다양한 case들 때문에</strong> 추상화(<strong>공통점 찾기가</strong>)하기 <strong>어려움</strong>
        <ul>
          <li>공통점을 억지로 찾아도 의미가 없다</li>
          <li>공통점 찾는 이유: <strong>인터페이스로 노출하여 -&gt; 책임을 할당</strong>하기 위함이다. 억지로 찾아봤자다
            <ul>
              <li>3~5년 역할책임모델의 눈을 가지게 되는데 오래걸리는 이유</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="polymorphism">
<a class="anchor" href="#polymorphism" aria-hidden="true"><span class="octicon octicon-link"></span></a>Polymorphism</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220205124322870.png" alt="image-20220205124322870"></p>

<ul>
  <li>인터페이스로 추상화하라는 얘기랑 비슷하게 들지만 아니다. <strong><code class="language-plaintext highlighter-rouge">전략패턴</code>을 의미한다.</strong>
    <ul>
      <li>
<strong>얘가 하는 행동이 추상적으로 의미가 같지만, 실제 하는 행동은 여러가지로 달라질 수 있을 때</strong>
        <ul>
          <li>책의 예제, policy나 condition차원에서는 isSatisfiedBy나 calculateFee메소드 2개를 공통적으로 사용해 퉁칠 수 있지만, 내부구현은 다 달라질 수 있을 때</li>
        </ul>
      </li>
      <li>
<strong><code class="language-plaintext highlighter-rouge">폴리모피즘 패턴</code>으로 <code class="language-plaintext highlighter-rouge">전략패턴</code>처럼 구현하는게 더 좋아</strong>
        <ul>
          <li><strong>추상체를 인자로 받아들이고</strong></li>
          <li>구상적인 체들은 <strong>달라질 수 있는 부분을 나중에 구현</strong>한 뒤, 받아들일 수 있게 하는게 좋아</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="pure-fabrication">
<a class="anchor" href="#pure-fabrication" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pure Fabrication</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220205130734458.png" alt="image-20220205130734458"></p>

<ul>
  <li>SRP를 AOP적인 관점을 바라볼 수 도 있다고 했었는데
    <ul>
      <li>
<strong>단일책임원칙</strong>: 코드수정은 이 때 + 이래서 변하는 <strong>변화율 1개로 기준을 잡아서 객체 분리</strong>.
        <ul>
          <li>
<strong>공통된 기능을 분리해서 가지고</strong> 있으면, 관심사 수정시, <strong>수정여파가 다른 곳으로 가지 못하게 한다.</strong>
</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>단일책임원칙에 의거해서,
    <ul>
      <li>**<code class="language-plaintext highlighter-rouge">공통된 기능</code>을  **귀찮다고&gt;</li>
      <li><strong>빨리빨리 <code class="language-plaintext highlighter-rouge">추상층으로 빼내든지</code></strong></li>
      <li><strong><code class="language-plaintext highlighter-rouge">공통클래스로 빼내라</code></strong></li>
    </ul>
  </li>
  <li>
<strong>완성판 객체 = <code class="language-plaintext highlighter-rouge">추상화가 끝난 객체</code></strong>는
    <ul>
      <li>공통 기능들은 <strong><code class="language-plaintext highlighter-rouge">인터페이스를 구현한 추상클래스</code>에</strong> 템플릿 메소드로 되어있고
        <ul>
          <li>
<strong>소유를 통해 처리하는 public 메소드</strong>
            <ul>
              <li>훅이 아니라 독립객체 인터페이스 구상한 것을 hasA모델로 추상클래스에 넣어줌</li>
            </ul>
          </li>
          <li><strong>훅을 통해 처리하는 template 메소드가 노출되어있고</strong></li>
        </ul>
      </li>
      <li>
<strong><code class="language-plaintext highlighter-rouge">그 추상클래스를 구현한 구상클래스</code>에서는</strong>
        <ul>
          <li>훅들을 구성해서  채워줌</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
<strong>디자인패턴 중 세련되게 + 많이 + 능숙하게 써야하는 패턴은 <code class="language-plaintext highlighter-rouge">템플릿메소드패턴</code>+<code class="language-plaintext highlighter-rouge">전략패턴</code>이다</strong>
    <ul>
      <li>밥 먹듯이 써야한다.</li>
      <li>
<strong>템플릿메소드패턴 &lt;-&gt; 전략패턴 밥먹듯이 바꿀 수 있어야한다.(loop&lt;-&gt;재귀 바꾸듯)</strong>
        <ul>
          <li>case(객체)들이 확정되었다고 생각해서 <code class="language-plaintext highlighter-rouge">템플릿 메소드 패턴</code>을 사용했는데</li>
          <li>지금보니 runtime에서 더 많은 case(객체)들을 정의할 것 같다 -&gt; <code class="language-plaintext highlighter-rouge">전략패턴</code>으로 바꿔야지</li>
        </ul>
      </li>
      <li>
<strong>딱딱할수록 <code class="language-plaintext highlighter-rouge">고정 구상층을 가진 추상클래스</code>가 유리</strong>
        <ul>
          <li>템플릿 메소드 패턴</li>
        </ul>
      </li>
      <li>
<strong>유연할수록(=확장될 가능성이 있음) 구상층 일일히 다 만드는 귀차니즘이 없도록 <code class="language-plaintext highlighter-rouge">인터페이스가 확장성이 유리</code></strong>
        <ul>
          <li>전략패턴</li>
        </ul>
      </li>
      <li>2장에 나와있는 인터페이스로 구현한 추상클래스가 훅을 이용하고 + 템플릿메소드를 제공하고 있는지 확인해봐야한다
        <ul>
          <li>다 그렇게 되어있다. 추상화를 다 하고 나면, <code class="language-plaintext highlighter-rouge">hasA</code>도 쓰고 <code class="language-plaintext highlighter-rouge">isA</code>도 같이 쓰기 때문에</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="indirection">
<a class="anchor" href="#indirection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Indirection</h5>

<p><img src="https://raw.githubusercontent.com/is3js/screenshots/main/image-20220205135613477.png" alt="image-20220205135613477"></p>

<ul>
  <li>포인터를 직접 참조하지말고, <strong>포인터의 포인터를 참조</strong>해라
    <ul>
      <li><strong>왠만하면 직접적으로 가지 않는게 좋다</strong></li>
    </ul>
  </li>
  <li>포인터의 포인터는 다른의미로
    <ul>
      <li>
<strong>인터페이스</strong>같은 <strong>추상형</strong>을 사용하거나</li>
      <li>직접만든 <strong>데코레이터패턴</strong> or <strong>어댑터패턴</strong>을 통해 직접명령이 아닌 <strong>걔를 통해 간접적으로 명렁을 내리는 것</strong> 를 말하는 것일 수도 있다.</li>
    </ul>
  </li>
  <li>
<strong>간접참조(껍데기)를 하면, 직접참조를 하는 애(업데이트 되는 내용물)는 바꿀 필요가 없다.</strong>
    <ul>
      <li><strong>SOLID원칙에서 OCP를 말하는 것</strong></li>
    </ul>
  </li>
</ul>


  </div><a class="u-url" href="/object/2022/05/10/(object1-7)SOLID5%EC%9B%90%EC%B9%99_GRAPS9%ED%8C%A8%ED%84%B4.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="blog.chojaeseong.com/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>평범한 한의사 돌범의 엔지니어 도전기</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
  <a href="/feed.xml" target="_blank" title="rss">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://github.com/is2js/" target="_blank" title="github">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#github"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://twitter.com/yarotheslav" target="_blank" title="twitter">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#twitter"></use>
    </svg>
  </a>
</li>
<li>
  <a rel="me" href="https://www.linkedin.com/in/yshmarov/" target="_blank" title="linkedin">
    <svg class="svg-icon grey">
      <use xlink:href="/assets/minima-social-icons.svg#linkedin"></use>
    </svg>
  </a>
</li>
</ul>
</div>

  </div>

</footer>
</body>

</html>
