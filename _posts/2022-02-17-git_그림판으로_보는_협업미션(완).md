---
toc: true
layout: post
title: fork로 시작하는 git협업 미션
description: 그림판으로 보는 관리자1+pair1,2 3명의 git협업

categories: [git, 협업, 코드리뷰, 우테코]
image: "images/posts/wootech.png"
---

### 준의 git 강의

#### upstream

![image-20220216104610592](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220216104610592.png)



- **기본적**으로 **최초push**에서는
    - local ->  origin의 연결에  `local에 대한 상대적 상류(upstream) `를 `-u`로 명시해줘야한다.
    
    - -`u`는 `--set-upstream`으로 상대적인 상류를 표기한 것이다.
    
        
- **일반적**으로 
    - **origin에 대한 origin이 `upstream`**이라고 **별칭**한다.
        - 미션repo(`upstream`) -> fork repo(`origin`) -> clone repo(`local`)
    - 최초 명시해준 것처럼 **upstream**은 downstream에 대해 상대적인 것이다.



- 깃허브 초기 메세지 박스를 보면 `-u`가 있는데 **상대적 상-하 관계를 설정하는 upstream설정을 요약**한 단어다

    - 없으면 push가 안된다.
    - 내 local의 remote인 `origin`이라는 원천이라는 upstream으로 사용한다
        - 보통은 원천(origin)보다 위쪽(stream)은 없다.  
        - 하지만, **`fork`로 `가운데origin`이 생기면서, 원본 repo를`별칭stream`을 사용하게 된다.**
        - **우테코의 경우, 미션repo를 fork해해서 `origin`보다 더 상위단계가 생기므로 `upstream`**

    ![image-20220216105030785](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220216105030785.png)

    - **여러개의 downstream**이 존재함을 안보이더라도 생각해야한다.
        - **git clone시**((origin <-> local)에는 origin을 알고 있기 때문에 **자동으로 stream관계가 설정**되어 push할 때 `-u`를 통한 upstream 설정은 안해도 된다. 





#### --help명령어와 git 객체

- 퀴즈1
    ![image-20220216105638129](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220216105638129.png)

    `O`

    - `git help`메세지들을 잘 보자.
        ![image-20220216105744351](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220216105744351.png)

        - `.git`안에 깃 저장소를 초기화 했습니다.
        - `ls -al` 숨긴 파일, 폴더 보면 `.git`이 깃 저장소(`로컬 저장소`)가 보인다.

        ![image-20220216105853695](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220216105853695.png)

        - `tree .git/`으로 로컬저장소의 구조를 보면![image-20220216105941160](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220216105941160.png)

    - 명령어 도움말은 `명령어` + **`--help`를 뒤에 달면된다.**
        ![image-20220216110218535](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220216110218535.png)
    
- 퀴즈2
    ![image-20220216110227506](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220216110227506.png)

    - blob은 파일으로 생각하자.

    - 답은 `5`번

        - branch는 commit객체에 대한 참조만 가지고 있다.

        ![image-20220216110335830](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220216110335830.png)

    - commit

        - 커밋 = 작업 디렉토리 스냅샷  = 세이브 포인트
        - **돌아가기 위한 포인트.. commit + push만 하지말자**
        - 돌아가기 위한 정보를 어떻게 담고 있을까

        ![image-20220216110639929](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220216110639929.png)

    - add시 생성객체, commit시 생성객체를 나누었다.

        ![image-20220216110841734](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220216110841734.png)
        ![image-20220216110908919](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220216110908919.png)

        - `add`하면, git이 **`a.txt`를 관리대상으로 인식**한다.
            - **아까는 없었던, `index`와 `object`가 추가 된다.**

        ![image-20220216111032274](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220216111032274.png)

        - `commit`하면, tree(파일관련), commit(tree를 담고 있는)객체까지 만들어서 2개가 더 만들어진다.

        ![image-20220216111155902](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220216111155902.png)

        

        

        

        

    - 퀴즈3

        ![image-20220216111320270](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220216111320270.png)

        - git은 변경사항만 저장한다?
            - 흔한 오해 -> **파일을 통채로 저장한다!**
            - 엄청 뒤로 갈 때, 변경사항만으로 추적? -> **연산 엄청 많아진다. 그냥 속도측면을 중요시해서 `통채로 저장` = `객체`로 관리**
            - **원본 파일마다 `tree`객체를 가지고 있다.** 통채로 저장해놓고, 그것들을 관리하기 위한 커밋이 가진다.
                - 마지막 commit상태의 blob을 본다.
                - 변경사항을 저장하는게 아니라서..





### git-mission

https://github.com/woowacourse/retrospective/discussions/4

- 미션repo `관리자`와 fork하는 `페어1`과 `페어2`가 있다.
    - `관리자`(upstream) - `페어1,2`(origin) - `각 로컬`(local) 형태로 구성할 예정



1. `관리자`는 github에서 repo(git-mission)를 파고, readme.MD를 작성한다.

    ```md
    README.md
    
    # 백엔드팀
    ```

    ![image-20220217114126984](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220217114126984.png)

2. `pair1`, `pair2`가 각각 `관리자`의 repo( 예정upstream) -> fork(origin) -> clone(local)한 뒤

    - main만 있던 repo안에 **작업용 각자의 `{github_id}`**로

    - 미션repo(관리자repo)는 main만 일단 유지한다고 가정하며, 

    - **작업자들은 main fork -> main clone -> local main외 local `{본인github_id}`를 파서 작업하자.**

        ```shell
        git checkout -b is2js<github_id>
        ```

        ```shell
        git branch -a
        ```

        

        ![image-20220217115249981](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220217115249981.png)

        - **우테코와 같이 특수한 경우(관리자 repo가 main이외에 개별 br를 다 가지고 있는 경우)**
            - 작업자들은 학습사이트를 통해 생성된  **`main` + 수많은 `{본인github_id}`** fork ->  **`--single-branch`하여 `{본인github_id}` clone ** -> local {본인github_id} 외에 **`step1` 을 파서 작업한다.**

3. `pair1`**부터** readme.md를 수정 -> `pair2`는 대기(파일 수정해도 됨)

    - 파일수정

    - add + commit

    - (clone해왔지만, br바꿨기 때문에) **`push` with origin과의 upstream 최초 설정**

        ```shell
        git push --set-upstream origin is2js<github_id>
        ```

        ![image-20220217115906928](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220217115906928.png)

4. `pair1`은 [fork repo]의 `main외 작업br{github_id}` -> **[원본repo]` main`에 PR을 날릴 수 있다.**
    ![image-20220217120608907](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220217120608907.png)

    - 보통 fork -> clone -> 작업br 파기 ->(origin입장에서 new br인)작업br push -> **fork `작업br` to 원본 `main br`로 PR in github**

5. 관리자의 merge in github

6. `pair2`가 **conflict를 내기 위해 `관리자 최신main from pair1` or `pair1 최신`을  가져오지 않고**

    - **`pair1`이 `작업끝내기 전에 같은 파일에 작업`시작**

    ![image-20220217121756406](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220217121756406.png)

7. `pair2`의 무지성 PR -> **conflict를 github가 알려준다.**

    - 공통 작업자가 있다면, 같은 파일 수정 가능성이 있다면, **PR전에 `pair`나 `upstream`의 pull부터 해야함.**
        ![image-20220217121952676](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220217121952676.png)
        ![image-20220217122213362](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220217122213362.png)
    - github에서 PR을 만드려고 하면 conflict를 알려준다.
        ![image-20220217122103056](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220217122103056.png)



7. **`pair2`는 최신소스가 업데이트된 원본repo를 받아오기 위해 `local` <-> `원본repo` upstream으로 등록하고, 받아와야한다. **

    - `pair1`을 pair로 등록하고 받아와도 될 것 같은데, 중심은 원본repo에서 받아온다.

    - 중간 다리인 fork는 주고/받을 때 별 영향이 없다. **`local과 원본repo가 연결`되어야 최신소스**를 받으니, **`upstream라는 별칭`으로 `원격저장소를 추가하여 연결`한다.** 

        ![image-20220217122745898](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220217122745898.png)

        ```shell
        git remote -v
        # fork -> clone으로 형성된 origin = fork레포만 연결되어있다.
        
        git remote add upstream<원본레포 별칭> <원본레포 URL>
        
        git remote -v
        
        git fetch upstream
        # fetch는 커밋내역만 가져오는데 [원격저장소별칭]만으로 가져올 수 있다.
        # 가져올 br이 있는지 확인한다.
        git branch -a
        
        git merge upstream/main 
        # 가져올 [원격저장소별칭/br]  형태로 merge를 요청한다.
        ```

        

8. 가져와서 conflict를 (vscode 등에서) 해결하고, 다시 **fork(origin)으로 push** -> **github에서 PR**을 날리면 된다.

    ```shell
    git push origin is2js{github_id}
    ```

    

    ![image-20220217123533765](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220217123533765.png)



9. 우테코의 코드리뷰는 더 복잡하다.

    - 원본repo의 관리자 -> 리뷰어들이 merge를 담당한다

    - fork전, 우테코 학습사이트를 통해 원본repo에 main외 내 {github_id}로 <main은 기본코드유지>하면서 PR의 최종merge가  각자의 {github_id}로 되도록 먼저 생성한다.

    - fork하면, main + 모든 리뷰이들의 {github_id}들이 있다. -> 내 {gihub_id}의 br만 로컬로 clone해와야한다.

        ```shell
         git clone -b is2js<내github_id> --single-branch https://github.com/is2js/java-
         racingcar.git<url>
        ```

    - clone후, 내입장에서의 main branch인 {github_id}에서 **작업용=리뷰어br**인 `step1`부터 파서 시작한다.

    - 만약, 페어가 있다면 한 곳의 step1을 선택한 다음, 작업이 끝나면 찢어진 뒤 

        - pair라는 별칭으로 `git remote add pair <URL>`을 하고
        - fetch -> merge하여 작업된 pair의 코드를 가져온 뒤, 작업을 시작한다.

    ![image-20220216010500314](https://raw.githubusercontent.com/is3js/screenshots/main/image-20220216010500314.png)

