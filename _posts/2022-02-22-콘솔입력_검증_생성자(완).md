---
toc: true
layout: post
title: Console 입력-검증-생성자 정리
description: getInput -> valid -> 객체 생성자

categories: [java, console, input, validation, 우테코]
image: "images/posts/java.png"
---

## 콘솔 프로그램 입력/검증/생성자

- 자동차경주 1,2차 피드백(1단계 미션)후 `콘솔입력 -> 검증 -> 개별 모델 생성자` 구조를 생각해보았다.



### InputView



#### 재활용 SCANNER

1. **스캐너**를 사용하는 public static `getInput()`

    ```java
    private static final Scanner SCANNER = new Scanner(System.in);
    
    public static String getInput() {
        return SCANNER.nextLine();
    }
    ```



#### 4단계 getXXX()

1. **개별 모델input**들을 의미하는 `getXXX()`는 **4단계로 구성**됨.

    ```java
    public static List<String> getCarNames() {
        OutputView.printRequestInstruction(REQUEST_CARS_NAME);
        List<String> carsName = Arrays.stream(getInput().split(SPLIT_DELIMITER, -1))
            .map(String::trim)
            .collect(Collectors.toList());
        Validator.validateCarNames(carsName);
        return carsName;
    }
    
    public static String getRound() {
        OutputView.printRequestInstruction(REQUEST_ROUND_VALUE);
        String inputRound = InputView.getInput();
        Validator.validateInputNumber(inputRound);
        return inputRound;
    }
    ```

    1. **OuputView.print( 안내메세지 )**

    2. 스캐너를 사용해서 받은, 복수형이면 **split(,-1)** by `Arrays.stream( ).map().collect()` / 단수형이면 **그냥** 

        - **`List<String>`  or `String`**

    3. 복수형이면 **실제이름XXXX**를 붙이고 / 단수형이면 **Input**(String) or **InputNumber**(StringNumber)를 붙인 

        1. **Input루트의 공통검증:  `Validator.validate~`** -> **재료는 `List<String>` 아니면 `String(Number)`로 무조건 String타입을 검증대상으로 보게 정했다.**

            1. 복수형이면 **check복수형(**개별Empty, 중복) -> **for** validateInput or validateInputNumber의 **단수 공통검증**

                ```java
                private Validator() { // 유틸클래스는 따로 객체생성안한다는 private생성자로 표시
                }
                
                public static void validateCarNames(List<String> carNames) {
                    checkCarNamesEmpty(carNames);
                    checkDuplicated(carNames);
                    for (String carName : carNames) {
                        validateInput(carName);
                    }
                }
                ```

            2. 단수형이면 String이냐 StringNumber냐에 따라서 다르게

                1. String: `NullOrEmpty` + `IncludeBlank`
                2. StringNumber: `NullOrEmpty` + `Format`(**넣으면 IncludeBlank안넣어도 된다**)

                ```java
                private static void validateInput(String carName) {
                    checkNullOrEmpty(carName);
                    checkIncludeBlank(carName);
                }
                
                public static void validateInputNumber(String inputRound) {
                    checkNullOrEmpty(inputRound);
                    checkValidFormat(inputRound);
                }
                ```

                

    4. **`return`** `List<String>  or String`(2번)

    



### Controller  

#### try/catch

- 입력받을 때, **`입력 예외발생시 다시 입력받기`** 받으려면 **`getXXXX()`가 **

    - **`검증을 포함하는 부분`시켜서**
    - **`재귀호출하는 하도록 메서드화`**되어 있고 그부분을 **`try/catch`로** 쌓여있여있어야하는데,

- **`getXXX()` + 받아서 `모델의 (정펙매)생성자 호출하는 과정`까지 try/catch로 감싸면, `도메인 자체검증`도 try/catch의 재귀에 걸려 `도메인 자체검증 예외발생시에도 재입력`받을 수 있게 된다.**

    - 객체 생성로직( 자체 검증 -> 객체 생성)까지 포함시켰으니, 해당 메서드는 **try성공시 객체를 returnType으로**

    ```java
    private Cars getCars() {
        try {
            return Cars.fromInput(InputView.getCarNames());
        } catch (IllegalArgumentException e) {
            OutputView.printErrorMessage(e);
            return getCars();
        }
    }
    ```

    ```java
    RacingGame racingGame = RacingGame.createRacingGame(
        getCars(),
        getRound(),
        new RandomNumberGeneratePolicy()
    );
    ```





### 생성자

#### 01 private 기본생성자

##### 복수

```java
private Cars(List<Car> cars) {
    this.cars = cars;
}
```



##### VO

```java
private Name(String name) {
    this.name = name;
}
```





#### 02 .fromInput( `String` or `List<String>` )

##### 복수

- input을 거쳐왔으므로, 공통 검증을 해줄 필요가 없다. -> **자체 검증만 시행**
    - 만일, **내부 포장객체를 속성으로** 가지는 일급컬렉션 등이라면? **자체검증은 포장객체에게** 갈 수도 있다.

```java
public static Cars fromInput(List<String> InputNames) {
    Names names = Names.fromInput(InputNames);
    return new Cars(names.getNames().stream()
                    .map(Car::fromName)
                    .collect(Collectors.toList()));
}
```



##### VO 는 .from(원본 1개만)

- 정팩메 1개 -> input이지만  .from + 유일 자체 검증 생성자

```java
public static Name from(String name) {
    checkValidLengthOfName(name);
    return new Name(name);
}
```



#### 03 .from( 원본재료 ) 

##### 복수

- input없이 프로덕션내부 or 테스트에서 사용된다. -> **유틸화된 공통검증 + 자체 검증**
    - 만일, 원본**재료**가 포장된 객체라면, **자체검증은 포장객에게 갈 수 있다.**

```java
public static Cars from(List<Car> cars) {
    return new Cars(cars);
}
```



##### VO 는 .from(원본 1개만)

- 정팩메 1개 -> input이지만  .from + 유일 자체 검증 생성자

```java
    public static Position from(int position) {
        validatePosition(position);
        return new Position(position);
    }
```

